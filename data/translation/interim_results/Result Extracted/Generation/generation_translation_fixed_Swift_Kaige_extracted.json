[
  {
    "task_id": "Swift/1",
    "prompt": {
      "en": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "sq": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nKontrolloni nëse në vargun e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\npragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "hy": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nՍտուգել, արդյոք տրված թվերի զանգվածում որևէ երկու թիվ միմյանց ավելի մոտ են, քան տրված շեմը։\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "bn": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nদেওয়া সংখ্যার অ্যারেতে, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "bg": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nПроверете дали в дадения масив от числа, някои две числа са по-близо едно до друго\nот дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "zh": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\n检查在给定的数字数组中，是否有任意两个数字之间的距离小于给定的阈值。\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "fr": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nVérifiez si, dans le tableau de nombres donné, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "de": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nÜberprüfen Sie, ob in dem gegebenen Array von Zahlen zwei Zahlen näher beieinander liegen als der gegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "ha": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nDuba idan a cikin jerin lambobin da aka bayar, akwai wasu lambobi biyu da suke kusa da juna fiye da\niyakar da aka bayar.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "hi": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nजांचें कि दिए गए संख्याओं के एरे में, कोई दो संख्याएँ एक-दूसरे के जितना करीब हैं, वह दिए गए सीमा से कम है या नहीं।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "hu": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nEllenőrizze, hogy a megadott szám tömbben bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9805550788485896",
      "bn": "0.9805550788485896",
      "bg": "1",
      "zh": "0.9722715960682917",
      "fr": "0.992889230989332",
      "de": "0.9916966541815986",
      "ha": "0.9796491256806895",
      "hi": "0.9779448770114102",
      "hu": "0.9757573606250729"
    },
    "canonical_solution": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}",
    "instruction": {
      "en": "Write a Swift function `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` to solve the following problem:\n\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n",
      "sq": "Shkruani një funksion Swift `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` për të zgjidhur problemin e mëposhtëm:\n\nKontrolloni nëse në vargun e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Swift ֆունկցիա գրեք `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` հետևյալ խնդիրը լուծելու համար:\n\nՍտուգեք, արդյոք տրված թվերի զանգվածում որևէ երկու թիվ իրարից ավելի մոտ են, քան տրված շեմը:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bn": "একটি Swift ফাংশন `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nযাচাই করুন যে প্রদত্ত সংখ্যার অ্যারেতে, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bg": "Напишете Swift функция `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` за решаване на следния проблем:\n\nПроверете дали в дадения масив от числа, някои две числа са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "zh": "编写一个 Swift 函数 `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` 来解决以下问题：\n\n检查在给定的数字数组中，是否存在任意两个数字之间的距离小于给定的阈值。\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "fr": "Écrire une fonction Swift `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` pour résoudre le problème suivant :\n\nVérifiez si dans le tableau de nombres donné, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "de": "Schreiben Sie eine Swift-Funktion `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {`, um das folgende Problem zu lösen:\n\nÜberprüfen Sie, ob in dem gegebenen Array von Zahlen zwei beliebige Zahlen näher beieinander liegen als der gegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Rubuta aikin Swift `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` don warware matsalar mai zuwa:\n\nDuba idan a cikin jerin lambobin da aka bayar, akwai kowanne lambobi biyu da ke kusa da juna fiye da\niyakar da aka bayar.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hi": "Swift फ़ंक्शन `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nजाँचें कि दिए गए संख्याओं के array में, कोई भी दो संख्याएँ एक-दूसरे के कितनी करीब हैं, यह दिए गए threshold से कम है या नहीं।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hu": "Írj egy Swift függvényt `func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {` a következő probléma megoldására:\n\nEllenőrizd, hogy a megadott szám tömbben bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9653415807043655",
      "bn": "0.9982198745251654",
      "bg": "0.999999801369619",
      "zh": "0.9711165604025738",
      "fr": "0.999999801369619",
      "de": "0.9841999463405798",
      "ha": "0.9808861956937748",
      "hi": "0.9761798474455341",
      "hu": "0.979350385587613"
    },
    "level": "easy",
    "test": "func check(_ hasCloseElements: ([Double], Double) -> Bool) {\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true)\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false)\nassert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false)\n}\n\ncheck(hasCloseElements)",
    "entry_point": "hasCloseElements",
    "signature": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {",
    "docstring": {
      "en": "\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n",
      "sq": "Kontrollo nëse në vargun e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Ստուգել, արդյոք տրված թվերի զանգվածում որևէ երկու թիվ ավելի մոտ են միմյանց, քան տրված շեմը:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bn": "প্রদত্ত সংখ্যার অ্যারেতে, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bg": "Проверете дали в дадения масив от числа, някои две числа са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "zh": "检查在给定的数字数组中，是否有任意两个数字之间的距离小于给定的阈值。  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  ",
      "fr": "Vérifiez si, dans le tableau de nombres donné, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  ",
      "de": "Überprüfen Sie, ob in dem gegebenen Zahlenarray zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Duba idan a cikin jerin lambobin da aka bayar, akwai kowanne lambobi biyu da suke kusa da juna fiye da ƙayyadadden tazara.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hi": "जांचें कि दिए गए संख्याओं के सरणी में, कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं या नहीं।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hu": "Ellenőrizze, hogy a megadott szám tömbben bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9657283140562404",
      "bn": "0.962549632068539",
      "bg": "1",
      "zh": "0.9520736671423781",
      "fr": "0.9916217705279484",
      "de": "0.9589581961490473",
      "ha": "0.9592638883054599",
      "hi": "0.9628169885614121",
      "hu": "0.9650023200135579"
    }
  },
  {
    "task_id": "Swift/2",
    "prompt": {
      "en": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "sq": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nGjen dhe kthen fjalën e parë palindrome në vargun e dhënë të fjalëve.\nNëse nuk gjendet asnjë fjalë palindrome, kthen një varg të zbrazët \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "hy": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nԳտնում և վերադարձնում է առաջին պալինդրոմ տողը տրված բառերի զանգվածում:\nԵթե պալինդրոմ տող չի գտնվել, վերադարձնում է դատարկ տող \"\":\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "bn": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nপ্রদত্ত শব্দগুলির অ্যারেতে প্রথম প্যালিনড্রোম স্ট্রিংটি খুঁজে বের করে এবং ফেরত দেয়।\nযদি কোনো প্যালিনড্রোম স্ট্রিং পাওয়া না যায়, তাহলে একটি খালি স্ট্রিং \"\" ফেরত দেয়।\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "bg": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nНамира и връща първия палиндром в дадения масив от думи.\nАко не е намерен палиндром, връща празен низ \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "zh": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\n在给定的单词数组中查找并返回第一个回文字符串。\n如果没有找到回文字符串，则返回空字符串 \"\"。\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "fr": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nTrouve et retourne la première chaîne de caractères palindrome dans le tableau de mots donné.\nSi aucune chaîne de caractères palindrome n'est trouvée, retourne une chaîne vide \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "de": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFindet und gibt den ersten Palindrom-String im gegebenen Array von Wörtern zurück.\nWenn kein Palindrom-String gefunden wird, wird ein leerer String \"\" zurückgegeben.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "ha": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nNemo kuma ya dawo da kalmar palindrome ta farko a cikin jerin kalmomin da aka bayar.\nIdan ba a sami wata kalmar palindrome ba, ya dawo da kirtani mara komai \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "hi": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nदिए गए शब्दों की सूची में पहला पालिंड्रोम स्ट्रिंग खोजता है और उसे लौटाता है।\nयदि कोई पालिंड्रोम स्ट्रिंग नहीं मिलती है, तो एक खाली स्ट्रिंग \"\" लौटाता है।\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "hu": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nMegkeresi és visszaadja az első palindróm szót a megadott szavak tömbjében.\nHa nem található palindróm szó, akkor egy üres stringet \"\" ad vissza.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.992410730401419",
      "hy": "0.9935409372695075",
      "bn": "0.9959566799636538",
      "bg": "0.9883777391448866",
      "zh": "0.9933595877316227",
      "fr": "0.999999801369619",
      "de": "0.9851114611591489",
      "ha": "0.9808605723746213",
      "hi": "0.9956329124425669",
      "hu": "0.9888953699178635"
    },
    "canonical_solution": "for word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}",
    "instruction": {
      "en": "Write a Swift function `func firstPalindrome(_ words: [String]) -> String {` to solve the following problem:\n\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n",
      "sq": "Shkruani një funksion Swift `func firstPalindrome(_ words: [String]) -> String {` për të zgjidhur problemin e mëposhtëm:\n\nGjen dhe kthen stringun e parë palindrome në vargun e dhënë të fjalëve.\nNëse nuk gjendet asnjë string palindrome, kthen një string bosh \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "hy": "Գրեք Swift ֆունկցիա `func firstPalindrome(_ words: [String]) -> String {` հետևյալ խնդիրը լուծելու համար:\n\nԳտնում և վերադարձնում է առաջին պալինդրոմ տողը տրված բառերի զանգվածում։\nԵթե պալինդրոմ տող չի գտնվել, վերադարձնում է դատարկ տող \"\"։\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "bn": "একটি Swift ফাংশন `func firstPalindrome(_ words: [String]) -> String {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nপ্রদত্ত শব্দের অ্যারেতে প্রথম প্যালিনড্রোম স্ট্রিংটি খুঁজে বের করে এবং ফেরত দেয়।\nযদি কোন প্যালিনড্রোম স্ট্রিং না পাওয়া যায়, তাহলে একটি খালি স্ট্রিং \"\" ফেরত দেয়।\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "bg": "Напишете Swift функция `func firstPalindrome(_ words: [String]) -> String {`, за да решите следния проблем:\n\nНамира и връща първия палиндромен низ в дадения масив от думи.\nАко не е намерен палиндромен низ, връща празен низ \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "zh": "编写一个 Swift 函数 `func firstPalindrome(_ words: [String]) -> String {` 来解决以下问题：\n\n查找并返回给定单词数组中的第一个回文字符串。\n如果没有找到回文字符串，则返回一个空字符串 \"\"。\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "fr": "Écrire une fonction Swift `func firstPalindrome(_ words: [String]) -> String {` pour résoudre le problème suivant :\n\nTrouve et renvoie la première chaîne de caractères palindrome dans le tableau de mots donné.\nSi aucune chaîne de caractères palindrome n'est trouvée, renvoie une chaîne vide \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "de": "Schreiben Sie eine Swift-Funktion `func firstPalindrome(_ words: [String]) -> String {`, um das folgende Problem zu lösen:\n\nFindet und gibt den ersten Palindrom-String im gegebenen Array von Wörtern zurück.\nWenn kein Palindrom-String gefunden wird, wird ein leerer String \"\" zurückgegeben.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "ha": "Rubuta aikin Swift `func firstPalindrome(_ words: [String]) -> String {` don warware matsalar mai zuwa:\n\nNemi kuma dawo da kalmar palindrome ta farko a cikin jerin kalmomin da aka bayar.\nIdan ba a sami wata kalmar palindrome ba, dawo da kirtani mai komai \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "hi": "Swift फ़ंक्शन `func firstPalindrome(_ words: [String]) -> String {` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n\nदिए गए शब्दों की array में पहला palindrome स्ट्रिंग खोजता है और उसे लौटाता है।\nयदि कोई palindrome स्ट्रिंग नहीं मिलती है, तो एक खाली स्ट्रिंग \"\" लौटाता है।\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "hu": "Írj egy Swift függvényt `func firstPalindrome(_ words: [String]) -> String {` a következő probléma megoldására:\n\nMegkeresi és visszaadja az első palindróm szót a megadott szavak tömbjében.\nHa nem található palindróm szó, akkor egy üres stringet ad vissza \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\""
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9941630476229087",
      "bg": "0.9862065104497942",
      "zh": "0.9941630476229087",
      "fr": "0.9941630476229087",
      "de": "0.9867589015394523",
      "ha": "0.9834918290321905",
      "hi": "0.9826446704570766",
      "hu": "0.989717898325729"
    },
    "level": "easy",
    "test": "func checkFirstPalindrome(_ firstPalindrome: ([String]) -> String) {\nassert(firstPalindrome([\"apple\", \"banana\", \"civic\"]) == \"civic\", \"Test failed: Expected 'civic'\")\nassert(firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"]) == \"ada\", \"Test failed: Expected 'ada'\")\nassert(firstPalindrome([\"hello\", \"world\"]) == \"\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"radar\", \"rotor\", \"level\"]) == \"radar\", \"Test failed: Expected 'radar'\")\nassert(firstPalindrome([\"not\", \"a\", \"single\", \"palindrome\"]) == \"a\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"A\", \"B\", \"C\", \"D\"]) == \"A\", \"Test failed: Expected 'A'\")\nassert(firstPalindrome([\"noon\", \"evening\", \"morning\"]) == \"noon\", \"Test failed: Expected 'noon'\")\n}\n\n\ncheckFirstPalindrome(firstPalindrome)",
    "entry_point": "firstPalindrome",
    "signature": "func firstPalindrome(_ words: [String]) -> String {",
    "docstring": {
      "en": "\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n",
      "sq": "Gjen dhe kthen vargun e parë palindrome në vargun e dhënë të fjalëve. Nëse nuk gjendet asnjë varg palindrome, kthen një varg bosh \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "hy": "Գտնում և վերադարձնում է առաջին պալինդրոմ տողը տրված բառերի զանգվածում:\nԵթե պալինդրոմ տող չի գտնվել, վերադարձնում է դատարկ տող \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "bn": "প্রদত্ত শব্দের অ্যারেতে প্রথম যে প্যালিনড্রোম স্ট্রিংটি পাওয়া যায় তা খুঁজে এবং ফেরত দেয়।  \nযদি কোনো প্যালিনড্রোম স্ট্রিং না পাওয়া যায়, তাহলে একটি খালি স্ট্রিং \"\" ফেরত দেয়।  \n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])  \n\"civic\"  \n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])  \n\"ada\"  \n>>> firstPalindrome([\"hello\", \"world\"])  \n\"\"  ",
      "bg": "Намира и връща първия палиндромен низ в дадения масив от думи.  \nАко не бъде намерен палиндромен низ, връща празен низ \"\".  \n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])  \n\"civic\"  \n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])  \n\"ada\"  \n>>> firstPalindrome([\"hello\", \"world\"])  \n\"\"  ",
      "zh": "查找并返回给定单词数组中的第一个回文字符串。\n如果未找到回文字符串，则返回空字符串 \"\"。\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "fr": "Trouve et renvoie la première chaîne palindrome dans le tableau de mots donné.\nSi aucune chaîne palindrome n'est trouvée, renvoie une chaîne vide \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "de": "Findet und gibt den ersten Palindrom-String im gegebenen Array von Wörtern zurück.\nWenn kein Palindrom-String gefunden wird, wird ein leerer String \"\" zurückgegeben.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "ha": "Nemo kuma ya dawo da farkon kalmar palindrome a cikin jerin kalmomin da aka bayar. Idan ba a sami wata kalmar palindrome ba, ya dawo da kirtani mara komai \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "hi": "दिए गए शब्दों की सूची में पहला पालिंड्रोम स्ट्रिंग खोजता है और लौटाता है।  \nयदि कोई पालिंड्रोम स्ट्रिंग नहीं मिलती है, तो एक खाली स्ट्रिंग \"\" लौटाता है।  \n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])  \n\"civic\"  \n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])  \n\"ada\"  \n>>> firstPalindrome([\"hello\", \"world\"])  \n\"\"  ",
      "hu": "Megkeresi és visszaadja az első palindrom sztringet a megadott szavak tömbjében.\nHa nem található palindrom sztring, akkor egy üres sztringet ad vissza \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\""
    },
    "docstring_bertscore": {
      "sq": "0.9892755484671644",
      "hy": "0.994119348939081",
      "bn": "0.9877427178167181",
      "bg": "0.9848061662634983",
      "zh": "0.9892755484671644",
      "fr": "0.9892755484671644",
      "de": "0.9841524736795125",
      "ha": "0.9735400496815805",
      "hi": "0.9948467333944309",
      "hu": "0.994119348939081"
    }
  },
  {
    "task_id": "Swift/3",
    "prompt": {
      "en": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "sq": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nKthen numrin maksimal të fjalëve të gjetura në çdo fjali të vetme brenda vargut të dhënë të fjalive.\nNjë fjali përbëhet nga fjalë të ndara nga një hapësirë e vetme, dhe nuk ka hapësira në fillim ose në fund.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "hy": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nՎերադարձնում է առավելագույն բառերի քանակը, որը գտնվել է տրված նախադասությունների զանգվածում որևէ առանձին նախադասության մեջ:\nՆախադասությունը բաղկացած է բառերից, որոնք բաժանված են մեկական բացատով, և չկան առաջատար կամ հետևող բացատներ:\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "bn": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nপ্রদত্ত বাক্যগুলির অ্যারের মধ্যে যেকোন একক বাক্যে পাওয়া সর্বাধিক শব্দের সংখ্যা ফেরত দেয়।\nএকটি বাক্য শব্দ দ্বারা গঠিত যা একটি একক স্পেস দ্বারা পৃথক করা হয়, এবং কোন শুরুর বা শেষের স্পেস নেই।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "bg": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nВръща максималния брой думи, намерени в което и да е едно изречение в дадения масив от изречения.\nИзречението се състои от думи, разделени с единично пространство, и няма водещи или завършващи интервали.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "zh": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\n返回在给定句子数组中任一单个句子中找到的最大单词数。\n一个句子由用单个空格分隔的单词组成，并且没有前导或尾随空格。\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "fr": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nRenvoie le nombre maximum de mots trouvés dans une seule phrase parmi le tableau de phrases donné.\nUne phrase est composée de mots séparés par un espace unique, et il n'y a pas d'espaces en début ou en fin.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "de": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nGibt die maximale Anzahl von Wörtern zurück, die in einem einzelnen Satz innerhalb des gegebenen Arrays von Sätzen gefunden werden.\nEin Satz besteht aus Wörtern, die durch ein einzelnes Leerzeichen getrennt sind, und es gibt keine führenden oder nachgestellten Leerzeichen.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "ha": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nYana dawowa da mafi girman adadin kalmomi da aka samu a cikin kowace jumla guda a cikin jerin jumlolin da aka bayar.\nJumla tana kunshe da kalmomi da aka raba su da sarari guda, kuma babu sarari a farkon ko a karshen.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "hi": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nदिए गए वाक्यों की सूची में किसी भी एकल वाक्य में पाए गए शब्दों की अधिकतम संख्या लौटाता है।\nएक वाक्य शब्दों से बना होता है जो एकल स्थान द्वारा अलग होते हैं, और कोई अग्रणी या पिछला स्थान नहीं होता है।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "hu": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nVisszaadja a maximális szavak számát, amelyet bármelyik mondat tartalmaz a megadott mondatok tömbjében.\nEgy mondat szavakból áll, amelyeket egyetlen szóköz választ el, és nincsenek vezető vagy záró szóközök.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.973622679920091",
      "hy": "0.9832125547164554",
      "bn": "0.994312616299828",
      "bg": "0.9894255144048456",
      "zh": "0.990008295942802",
      "fr": "0.9890421577694484",
      "de": "0.9898476039645447",
      "ha": "0.9680691730967366",
      "hi": "0.9859874211395128",
      "hu": "0.9738215089315069"
    },
    "canonical_solution": "var maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}",
    "instruction": {
      "en": "Write a Swift function `func maxWordCount(_ sentences: [String]) -> Int {` to solve the following problem:\n\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n",
      "sq": "Shkruani një funksion Swift `func maxWordCount(_ sentences: [String]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nKthen numrin maksimal të fjalëve të gjetura në çdo fjali të vetme brenda vargut të dhënë të fjalive. Një fjali përbëhet nga fjalë të ndara me një hapësirë të vetme, dhe nuk ka hapësira para ose pas.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "hy": "Գրեք Swift ֆունկցիա `func maxWordCount(_ sentences: [String]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՎերադարձնում է առավելագույն բառերի քանակը, որը գտնվել է տրված նախադասությունների զանգվածի ցանկացած նախադասության մեջ:\nՆախադասությունը բաղկացած է բառերից, որոնք բաժանված են մեկ բացատով, և չկան առաջատար կամ վերջնական բացատներ:\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "bn": "একটি Swift ফাংশন `func maxWordCount(_ sentences: [String]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nপ্রদত্ত বাক্যগুলির অ্যারের মধ্যে যে কোনো একটি বাক্যে পাওয়া শব্দের সর্বাধিক সংখ্যা ফেরত দেয়। একটি বাক্য শব্দ দ্বারা গঠিত যা একটি একক স্পেস দ্বারা পৃথক করা হয়, এবং কোনো প্রারম্ভিক বা শেষের স্পেস নেই।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "bg": "Напишете Swift функция `func maxWordCount(_ sentences: [String]) -> Int {` за решаване на следния проблем:\n\nВръща максималния брой думи, намерени в което и да е отделно изречение в дадения масив от изречения. Изречението се състои от думи, разделени с един интервал, и няма водещи или завършващи интервали.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "zh": "编写一个 Swift 函数 `func maxWordCount(_ sentences: [String]) -> Int {` 来解决以下问题：\n\n返回在给定句子数组中任何单个句子中找到的最大单词数。\n一个句子由单个空格分隔的单词组成，没有前导或尾随空格。\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "fr": "Écrire une fonction Swift `func maxWordCount(_ sentences: [String]) -> Int {` pour résoudre le problème suivant :\n\nRenvoie le nombre maximum de mots trouvés dans une seule phrase au sein du tableau de phrases donné.  \nUne phrase est composée de mots séparés par un seul espace, et il n'y a pas d'espaces avant ou après.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "de": "Schreiben Sie eine Swift-Funktion `func maxWordCount(_ sentences: [String]) -> Int {`, um das folgende Problem zu lösen:\n\nGibt die maximale Anzahl von Wörtern zurück, die in einem einzelnen Satz innerhalb des gegebenen Arrays von Sätzen gefunden werden.\nEin Satz besteht aus Wörtern, die durch ein einzelnes Leerzeichen getrennt sind, und es gibt keine führenden oder nachgestellten Leerzeichen.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "ha": "Rubuta aikin Swift `func maxWordCount(_ sentences: [String]) -> Int {` don warware matsalar mai zuwa:\n\nDawo da mafi yawan adadin kalmomi da aka samu a kowace jumla guda a cikin jerin jimlolin da aka bayar.  \nJumla tana ƙunshe da kalmomi da aka raba su da tazara guda, kuma babu tazarar da ke gaba ko ƙarshe.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "hi": "Swift फ़ंक्शन `func maxWordCount(_ sentences: [String]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nदिए गए वाक्यों की सूची में किसी एकल वाक्य में पाए गए शब्दों की अधिकतम संख्या लौटाता है।  \nएक वाक्य शब्दों से बना होता है जो एकल स्पेस द्वारा अलग होते हैं, और इसमें कोई अग्रणी या पिछला स्पेस नहीं होता है।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "hu": "Írj egy Swift függvényt `func maxWordCount(_ sentences: [String]) -> Int {` a következő probléma megoldására:\n\nVisszaadja a maximális szószámot, amely bármelyik mondatban található a megadott mondatok tömbjében.\nEgy mondat szavakból áll, amelyeket egyetlen szóköz választ el, és nincsenek vezető vagy záró szóközök.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5"
    },
    "instruction_bertscore": {
      "sq": "0.9770035676356859",
      "hy": "0.9861578460064407",
      "bn": "0.9928352035256905",
      "bg": "0.9916390513710984",
      "zh": "0.9839516583642862",
      "fr": "0.9783544528571041",
      "de": "0.9898918985395155",
      "ha": "0.988795657466584",
      "hi": "0.9668128359366909",
      "hu": "0.9730085147819311"
    },
    "level": "easy",
    "test": "func checkMaxWordCount(_ maxWordCount: ([String]) -> Int) {\nassert(maxWordCount([\"Hello world\", \"Swift is amazing\"]) == 3)\nassert(maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"]) == 5)\nassert(maxWordCount([\"single\"]) == 1)\nassert(maxWordCount([\"\", \"one two\", \"one two three\"]) == 3)\nassert(maxWordCount([\"This is a test sentence\", \"This is another\"]) == 5)\nassert(maxWordCount([\"Sentence with five words\", \"Shorter one\"]) == 4)\n}\n\ncheckMaxWordCount(maxWordCount)",
    "entry_point": "maxWordCount",
    "signature": "func maxWordCount(_ sentences: [String]) -> Int {",
    "docstring": {
      "en": "\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n",
      "sq": "Kthen numrin maksimal të fjalëve të gjetura në çdo fjali të vetme brenda vargut të dhënë të fjalive. Një fjali përbëhet nga fjalë të ndara nga një hapësirë e vetme, dhe nuk ka hapësira në fillim ose në fund.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "hy": "Վերադարձնում է առավելագույն բառերի քանակը, որը գտնվել է ցանկացած առանձին նախադասության մեջ տրված նախադասությունների զանգվածում:\nՆախադասությունը կազմված է բառերից, որոնք բաժանված են մեկական բացատով, և չկան բացատներ նախադասության սկզբում կամ վերջում:\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "bn": "প্রদত্ত বাক্যগুলির অ্যারেতে যেকোনো একক বাক্যে পাওয়া সর্বাধিক শব্দের সংখ্যা ফেরত দেয়। একটি বাক্য একক স্পেস দ্বারা পৃথক করা শব্দ নিয়ে গঠিত, এবং কোনো প্রারম্ভিক বা শেষের স্পেস নেই।\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "bg": "Връща максималния брой думи, намерени в което и да е изречение в дадения масив от изречения. Изречението се състои от думи, разделени с единично пространство, и няма водещи или завършващи интервали.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "zh": "返回给定句子数组中任何单个句子中找到的最大单词数。  \n一个句子由单个空格分隔的单词组成，并且没有前导或尾随空格。  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "fr": "Retourne le nombre maximum de mots trouvés dans une seule phrase au sein du tableau de phrases donné.  \nUne phrase est composée de mots séparés par un seul espace, et il n'y a pas d'espaces avant ou après.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "de": "Gibt die maximale Anzahl von Wörtern zurück, die in einem einzelnen Satz innerhalb des gegebenen Arrays von Sätzen gefunden werden.\nEin Satz besteht aus Wörtern, die durch ein einzelnes Leerzeichen getrennt sind, und es gibt keine führenden oder nachgestellten Leerzeichen.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "ha": "Yana mayar da mafi yawan kalmomi da aka samu a cikin kowace jumla guda a cikin jerin jumlolin da aka bayar. \nJumla tana kunshe da kalmomi da aka raba ta hanyar sarari guda, kuma babu sarari a farkon ko a ƙarshen. \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "hi": "दिए गए वाक्यों की सूची में किसी भी एकल वाक्य में पाए गए शब्दों की अधिकतम संख्या लौटाता है।  \nएक वाक्य शब्दों से बना होता है जो एकल स्पेस द्वारा अलग होते हैं, और कोई अग्रणी या पिछली स्पेस नहीं होती है।  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "hu": "Visszaadja a maximális szavak számát, amelyet bármelyik mondat tartalmaz a megadott mondatok tömbjében.\nEgy mondat szavakból áll, amelyeket egyetlen szóköz választ el, és nincsenek előtte vagy utána szóközök.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5"
    },
    "docstring_bertscore": {
      "sq": "0.9697332984290469",
      "hy": "0.9657591017653008",
      "bn": "0.9880962798949602",
      "bg": "0.9784408570728542",
      "zh": "0.9842303367888782",
      "fr": "0.9742171806505284",
      "de": "0.9883693966688831",
      "ha": "0.9744279274848064",
      "hi": "0.9710933206479927",
      "hu": "0.9411406537094558"
    }
  },
  {
    "task_id": "Swift/4",
    "prompt": {
      "en": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "sq": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nKontrollon nëse matrica e dhënë `n x n` është një matricë e vlefshme. Një matricë është e vlefshme nëse çdo rresht dhe kolonë përmban të gjitha numrat nga 1 deri në n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "hy": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nՍտուգում է, արդյոք տրված `n x n` մատրիցը վավեր մատրից է։ Մատրիցը վավեր է, եթե յուրաքանչյուր տող և սյունակ պարունակում է բոլոր ամբողջ թվերը 1-ից n։\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "bn": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nপ্রদত্ত `n x n` ম্যাট্রিক্সটি একটি বৈধ ম্যাট্রিক্স কিনা তা পরীক্ষা করে। একটি ম্যাট্রিক্স বৈধ যদি প্রতিটি সারি এবং \nকলামে 1 থেকে n পর্যন্ত সমস্ত পূর্ণসংখ্যা থাকে।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "bg": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nПроверява дали дадената `n x n` матрица е валидна. Една матрица е валидна, ако всеки ред и \nколона съдържа всички цели числа от 1 до n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "zh": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\n检查给定的 `n x n` 矩阵是否为有效矩阵。如果每一行和每一列都包含从 1 到 n 的所有整数，则矩阵有效。\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "fr": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nVérifie si la matrice `n x n` donnée est une matrice valide. Une matrice est valide si chaque ligne et \ncolonne contient tous les entiers de 1 à n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "de": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nÜberprüft, ob die gegebene `n x n` Matrix eine gültige Matrix ist. Eine Matrix ist gültig, wenn jede Zeile und \njede Spalte alle ganzen Zahlen von 1 bis n enthält.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "ha": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nDuba idan matrix `n x n` da aka bayar yana da inganci. Matrix yana da inganci idan kowace layi da \nkowane ginshiƙi suna ɗauke da duk lambobi daga 1 zuwa n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "hi": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nजाँच करता है कि दिया गया `n x n` मैट्रिक्स एक मान्य मैट्रिक्स है या नहीं। एक मैट्रिक्स मान्य है यदि प्रत्येक पंक्ति और स्तंभ में 1 से n तक के सभी पूर्णांक होते हैं।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "hu": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nEllenőrzi, hogy a megadott `n x n` mátrix érvényes mátrix-e. Egy mátrix akkor érvényes, ha minden sor és oszlop tartalmazza az összes egész számot 1-től n-ig.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9934491700334694",
      "hy": "0.99850292281814",
      "bn": "0.99850292281814",
      "bg": "0.9881620265510828",
      "zh": "0.9892477402138194",
      "fr": "1",
      "de": "0.9940859790350672",
      "ha": "0.9817820187122421",
      "hi": "0.9862156474473218",
      "hu": "0.9971170786496596"
    },
    "canonical_solution": "let n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}",
    "instruction": {
      "en": "Write a Swift function `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` to solve the following problem:\n\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n",
      "sq": "Shkruani një funksion Swift `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` për të zgjidhur problemin e mëposhtëm:\n\nKontrollon nëse matrica e dhënë `n x n` është një matricë e vlefshme. Një matricë është e vlefshme nëse çdo rresht dhe kolonë përmban të gjitha numrat nga 1 deri në n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hy": "Գրեք Swift ֆունկցիա `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` հետևյալ խնդիրը լուծելու համար:\n\nՍտուգում է, արդյոք տրված `n x n` մատրիցը վավեր մատրից է։ Մատրիցը վավեր է, եթե յուրաքանչյուր տող և սյունակ պարունակում է բոլոր թվերը 1-ից մինչև n։\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "bn": "একটি Swift ফাংশন `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nযাচাই করে যে প্রদত্ত `n x n` ম্যাট্রিক্স একটি বৈধ ম্যাট্রিক্স কিনা। একটি ম্যাট্রিক্স বৈধ যদি প্রতিটি সারি এবং কলাম 1 থেকে n পর্যন্ত সব পূর্ণসংখ্যা ধারণ করে।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "bg": "Напишете функция на Swift `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` за решаване на следния проблем:\n\nПроверява дали дадената `n x n` матрица е валидна матрица. Матрицата е валидна, ако всеки ред и \nколона съдържа всички цели числа от 1 до n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "zh": "编写一个 Swift 函数 `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` 来解决以下问题：\n\n检查给定的 `n x n` 矩阵是否为有效矩阵。如果每一行和每一列都包含从 1 到 n 的所有整数，则该矩阵是有效的。\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "fr": "Écrire une fonction Swift `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` pour résoudre le problème suivant :\n\nVérifie si la matrice `n x n` donnée est une matrice valide. Une matrice est valide si chaque ligne et colonne contient tous les entiers de 1 à n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "de": "Schreiben Sie eine Swift-Funktion `func isValidMatrix(_ matrix: [[Int]]) -> Bool {`, um das folgende Problem zu lösen:\n\nÜberprüft, ob die gegebene `n x n` Matrix eine gültige Matrix ist. Eine Matrix ist gültig, wenn jede Zeile und jede Spalte alle Ganzzahlen von 1 bis n enthält.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "ha": "Rubuta aikin Swift `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` don warware matsalar mai zuwa:\n\nDuba idan matrix `n x n` da aka bayar matrix ne mai inganci. Matrix yana da inganci idan kowace layi da kowane shafi suna dauke da duk lambobi daga 1 zuwa n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hi": "Swift फ़ंक्शन `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nजाँच करता है कि दिया गया `n x n` मैट्रिक्स एक मान्य मैट्रिक्स है या नहीं। एक मैट्रिक्स मान्य है यदि प्रत्येक पंक्ति और स्तंभ में 1 से n तक के सभी पूर्णांक होते हैं।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hu": "Írj egy Swift függvényt `func isValidMatrix(_ matrix: [[Int]]) -> Bool {` a következő probléma megoldására:\n\nEllenőrzi, hogy a megadott `n x n` mátrix érvényes mátrix-e. Egy mátrix akkor érvényes, ha minden sor és oszlop tartalmazza az összes egész számot 1-től n-ig.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse"
    },
    "instruction_bertscore": {
      "sq": "0.9919358051603646",
      "hy": "0.9953226517873904",
      "bn": "0.99475059629001",
      "bg": "0.9944824452756129",
      "zh": "0.9922007780886651",
      "fr": "0.9980099222124115",
      "de": "0.9943078491706832",
      "ha": "0.9874334503134468",
      "hi": "0.980175297560051",
      "hu": "0.9987760395920631"
    },
    "level": "middle",
    "test": "func checkIsValidMatrix(_ isValidMatrix: ([[Int]]) -> Bool) {\nassert(isValidMatrix([[1,2,3],[3,1,2],[2,3,1]]) == true)\nassert(isValidMatrix([[1,2,3],[3,2,1],[1,2,3]]) == false)\nassert(isValidMatrix([[1]]) == true)\nassert(isValidMatrix([[1,2],[2,1]]) == true)\nassert(isValidMatrix([[1,2],[1,2]]) == false)\nassert(isValidMatrix([[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]) == true)\nassert(isValidMatrix([[4,3,2,1],[3,2,1,4],[2,1,4,3],[1,4,3,2]]) == true)\nassert(isValidMatrix([[1,2,3],[3,1,2],[3,2,1]]) == false)\n}\n\ncheckIsValidMatrix(isValidMatrix)",
    "entry_point": "isValidMatrix",
    "signature": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {",
    "docstring": {
      "en": "\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n",
      "sq": "Kontrollon nëse matrica e dhënë `n x n` është një matricë e vlefshme. Një matricë është e vlefshme nëse çdo rresht dhe kolonë përmban të gjitha numrat e plotë nga 1 deri në n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hy": "Ստուգում է, արդյոք տրված `n x n` մատրիցը վավեր մատրից է: Մատրիցը վավեր է, եթե յուրաքանչյուր տող և սյունակ պարունակում են բոլոր ամբողջ թվերը 1-ից մինչև n:\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "bn": "প্রদত্ত `n x n` ম্যাট্রিক্সটি একটি বৈধ ম্যাট্রিক্স কিনা তা পরীক্ষা করে। একটি ম্যাট্রিক্স বৈধ যদি প্রতিটি সারি এবং কলামে 1 থেকে n পর্যন্ত সমস্ত পূর্ণসংখ্যা থাকে।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "bg": "Проверява дали дадената `n x n` матрица е валидна матрица. Една матрица е валидна, ако всеки ред и колона съдържат всички цели числа от 1 до n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "zh": "检查给定的 `n x n` 矩阵是否为有效矩阵。如果每一行和每一列都包含从 1 到 n 的所有整数，则矩阵是有效的。\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "fr": "Vérifie si la matrice `n x n` donnée est une matrice valide. Une matrice est valide si chaque ligne et colonne contient tous les entiers de 1 à n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "de": "Prüft, ob die gegebene `n x n`-Matrix eine gültige Matrix ist. Eine Matrix ist gültig, wenn jede Zeile und Spalte alle ganzen Zahlen von 1 bis n enthält.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "ha": "Duba idan matrix `n x n` da aka bayar matrix ne mai inganci. Matrix yana da inganci idan kowace layi da kowace shafi suna dauke da dukkan lambobi daga 1 zuwa n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hi": "जांच करता है कि दिया गया `n x n` मैट्रिक्स एक मान्य मैट्रिक्स है या नहीं। एक मैट्रिक्स तब मान्य होता है जब प्रत्येक पंक्ति और स्तंभ में 1 से n तक के सभी पूर्णांक होते हैं।\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "hu": "Ellenőrzi, hogy a megadott `n x n` mátrix érvényes mátrix-e. Egy mátrix akkor érvényes, ha minden sor és oszlop tartalmazza az összes egész számot 1-től n-ig.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse"
    },
    "docstring_bertscore": {
      "sq": "0.9983565322273174",
      "hy": "0.9950991926087263",
      "bn": "0.9895516446968028",
      "bg": "1",
      "zh": "0.987742320555956",
      "fr": "0.9952827270808025",
      "de": "1",
      "ha": "0.9813494017423482",
      "hi": "0.9792846389314904",
      "hu": "0.9983565322273174"
    }
  },
  {
    "task_id": "Swift/5",
    "prompt": {
      "en": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n*/",
      "sq": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nLlogarit koston minimale totale për të blerë të gjitha karamelet nën një promovim ku\nblerja e dy karameleve ju jep një karamele falas (me çmimin më të vogël ose të barabartë me më të voglin nga dy të blerat).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Bli karamelet që kushtojnë 4 dhe 3, merr 2 falas; paguaj për 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Bli të dyja karamelet, nuk ka karamele falas të disponueshme.\n*/",
      "hy": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nՀաշվարկում է կոնֆետներ ձեռք բերելու նվազագույն ընդհանուր արժեքը այնպիսի ակցիայի պայմաններում, \nորտեղ երկու կոնֆետ գնելիս ստանում եք մեկ անվճար կոնֆետ (որի գինը փոքր կամ հավասար է գնված երկուսի փոքրագույնին):\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Գնել կոնֆետներ, որոնք արժեն 4 և 3, ստանալ 2-ը անվճար; վճարել 1-ի համար:\n>>> minCostToBuyCandies([1, 2])\n3 // Գնել երկու կոնֆետները, անվճար կոնֆետներ չկան:\n*/",
      "bn": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nক্যান্ডি কেনার জন্য সর্বনিম্ন মোট খরচ গণনা করে যেখানে একটি প্রচারে দুটি ক্যান্ডি কিনলে একটি ফ্রি ক্যান্ডি পাওয়া যায় (যার মূল্য কেনা দুটি ক্যান্ডির মধ্যে কম দামের সমান বা কম হতে হবে)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 এবং 3 মূল্যের ক্যান্ডি কিনুন, 2 ফ্রি পান; 1 এর জন্য অর্থ প্রদান করুন।\n>>> minCostToBuyCandies([1, 2])\n3 // উভয় ক্যান্ডি কিনুন, ফ্রি ক্যান্ডি পাওয়া যায় না।\n*/",
      "bg": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nИзчислява минималната обща цена за придобиване на всички бонбони при промоция, където\nкупуването на два бонбона осигурява един безплатен бонбон (с цена, по-малка или равна на по-евтиния от двата закупени).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Купете бонбони на стойност 4 и 3, получете 2 безплатно; платете за 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Купете и двата бонбона, няма налични безплатни бонбони.\n*/",
      "zh": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\n计算在促销活动下获取所有糖果的最低总成本，其中购买两颗糖果可免费获得一颗糖果（其价格小于或等于所购买的两颗糖果中较低者）。\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 购买价格为4和3的糖果，免费获得价格为2的糖果；支付1。\n>>> minCostToBuyCandies([1, 2])\n3 // 购买两颗糖果，没有免费糖果。\n*/",
      "fr": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalcule le coût total minimum pour acquérir tous les bonbons sous une promotion où\nacheter deux bonbons permet d'obtenir un bonbon gratuit (avec un prix inférieur ou égal au moins cher des deux achetés).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Acheter des bonbons coûtant 4 et 3, obtenir 2 gratuitement ; payer pour 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Acheter les deux bonbons, aucun bonbon gratuit disponible.\n*/",
      "de": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nBerechnet die minimalen Gesamtkosten, um alle Süßigkeiten unter einer Aktion zu erwerben, bei der\nbeim Kauf von zwei Süßigkeiten eine kostenlose Süßigkeit (mit einem Preis kleiner oder gleich dem der günstigeren der beiden gekauften) erhalten wird.\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Kaufe Süßigkeiten, die 4 und 3 kosten, erhalte 2 kostenlos; zahle für 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Kaufe beide Süßigkeiten, keine kostenlosen Süßigkeiten verfügbar.\n*/",
      "ha": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nYana lissafin mafi ƙarancin jimillar kuɗi don siyan duk alewa a ƙarƙashin tayin inda\nsiyan alewa biyu yana samun alewa ɗaya kyauta (tare da farashinsa ya zama ƙasa ko daidai da ƙaramin daga cikin biyun da aka saya).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Sayi alewa masu tsada 4 da 3, sami 2 kyauta; biya don 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Sayi duk alewa biyu, babu alewa kyauta da ake da su.\n*/",
      "hi": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nसभी कैंडीज को प्राप्त करने की न्यूनतम कुल लागत की गणना करता है एक प्रमोशन के तहत जहां\nदो कैंडीज खरीदने पर एक मुफ्त कैंडी मिलती है (जिसकी कीमत खरीदी गई दो में से कम कीमत वाली के बराबर या उससे कम होती है)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 और 3 की कीमत वाली कैंडीज खरीदें, 2 मुफ्त में प्राप्त करें; 1 के लिए भुगतान करें।\n>>> minCostToBuyCandies([1, 2])\n3 // दोनों कैंडीज खरीदें, कोई मुफ्त कैंडी उपलब्ध नहीं है।\n*/",
      "hu": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nKiszámítja a minimális összköltséget az összes cukorka megszerzéséhez egy olyan akció keretében, ahol\nkét cukorka vásárlása esetén egy ingyen cukorka jár (amelynek ára kisebb vagy egyenlő a két vásárolt közül a kisebbikkel).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Vásárolj cukorkákat, amelyek 4 és 3-ba kerülnek, kapj 2-t ingyen; fizess 1-ért.\n>>> minCostToBuyCandies([1, 2])\n3 // Vásárold meg mindkét cukorkát, nincs ingyen cukorka.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9626110088562788",
      "hy": "0.9484937517849863",
      "bn": "0.941192893499668",
      "bg": "0.9741736805970818",
      "zh": "0.9368009771446055",
      "fr": "0.9798245163071433",
      "de": "0.9688313178687674",
      "ha": "0.9639491817333109",
      "hi": "0.9661662940464223",
      "hu": "0.9679347003287759"
    },
    "canonical_solution": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}",
    "instruction": {
      "en": "Write a Swift function `func minCostToBuyCandies(_ costs: [Int]) -> Int {` to solve the following problem:\n\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n",
      "sq": "Shkruani një funksion Swift `func minCostToBuyCandies(_ costs: [Int]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nLlogarit koston totale minimale për të blerë të gjitha karamelet nën një promovim ku\nblerja e dy karameleve ju jep një karamele falas (me çmimin e saj më të vogël ose të barabartë me më të voglin nga dy të blerat).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Blini karamele me kosto 4 dhe 3, merrni 2 falas; paguani për 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Blini të dyja karamelet, nuk ka karamele falas të disponueshme.",
      "hy": "Swift ֆունկցիա գրեք `func minCostToBuyCandies(_ costs: [Int]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է կոնֆետների ձեռքբերման նվազագույն ընդհանուր արժեքը այն ակցիայի պայմաններում, որտեղ երկու կոնֆետ գնելու դեպքում ստանում եք մեկ անվճար կոնֆետ (որի գինը փոքր կամ հավասար է գնված երկու կոնֆետներից փոքրագույնին):\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Գնեք 4 և 3 արժողությամբ կոնֆետները, ստացեք 2-ը անվճար; վճարեք 1-ի համար:\n>>> minCostToBuyCandies([1, 2])\n3 // Գնեք երկու կոնֆետները, անվճար կոնֆետներ չկան:",
      "bn": "একটি Swift ফাংশন `func minCostToBuyCandies(_ costs: [Int]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nপ্রমোশনের অধীনে সমস্ত ক্যান্ডি অর্জনের জন্য ন্যূনতম মোট খরচ গণনা করে যেখানে দুটি ক্যান্ডি কিনলে একটি ফ্রি ক্যান্ডি পাওয়া যায় (যার দাম কেনা দুটি ক্যান্ডির মধ্যে কম দামের সমান বা তার চেয়ে কম)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 এবং 3 দামের ক্যান্ডি কিনুন, 2 ফ্রি পান; 1 এর জন্য অর্থ প্রদান করুন।\n>>> minCostToBuyCandies([1, 2])\n3 // উভয় ক্যান্ডি কিনুন, কোনো ফ্রি ক্যান্ডি পাওয়া যায় না।",
      "bg": "Напишете функция на Swift `func minCostToBuyCandies(_ costs: [Int]) -> Int {` за решаване на следния проблем:\n\nИзчислява минималната обща стойност за придобиване на всички бонбони при промоция, където купуването на два бонбона получава един безплатно (с цена по-малка или равна на по-малката от двата купени).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Купете бонбони на стойност 4 и 3, получете 2 безплатно; платете за 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Купете и двата бонбона, няма налични безплатни бонбони.",
      "zh": "编写一个 Swift 函数 `func minCostToBuyCandies(_ costs: [Int]) -> Int {` 来解决以下问题：\n\n计算在促销活动下获取所有糖果的最低总成本，其中购买两颗糖果可以免费获得一颗糖果（其价格小于或等于所购买的两颗糖果中较便宜的那颗）。\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 购买价格为4和3的糖果，免费获得价格为2的糖果；支付价格为1的糖果。\n>>> minCostToBuyCandies([1, 2])\n3 // 购买两颗糖果，没有可免费获得的糖果。",
      "fr": "Écrire une fonction Swift `func minCostToBuyCandies(_ costs: [Int]) -> Int {` pour résoudre le problème suivant :\n\nCalcule le coût total minimum pour acquérir tous les bonbons sous une promotion où\nl'achat de deux bonbons permet d'obtenir un bonbon gratuit (avec un prix inférieur ou égal au moins cher des deux achetés).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Acheter des bonbons coûtant 4 et 3, obtenir 2 gratuitement; payer pour 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Acheter les deux bonbons, aucun bonbon gratuit disponible.",
      "de": "Schreiben Sie eine Swift-Funktion `func minCostToBuyCandies(_ costs: [Int]) -> Int {`, um das folgende Problem zu lösen:\n\nBerechnet die minimalen Gesamtkosten, um alle Süßigkeiten unter einer Aktion zu erwerben, bei der der Kauf von zwei Süßigkeiten eine kostenlose Süßigkeit erhält (deren Preis kleiner oder gleich dem der beiden gekauften ist).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Kaufen Sie Süßigkeiten, die 4 und 3 kosten, erhalten Sie 2 kostenlos; zahlen Sie für 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Kaufen Sie beide Süßigkeiten, keine kostenlosen Süßigkeiten verfügbar.",
      "ha": "Rubuta aikin Swift `func minCostToBuyCandies(_ costs: [Int]) -> Int {` don warware matsalar mai zuwa:\n\nLissafa mafi ƙarancin jimillar kuɗi don siyan dukkan alewa a ƙarƙashin gabatarwa inda\nsiyan alewa biyu yana samun alewa ɗaya kyauta (tare da farashinsa ƙasa ko daidai da ƙaramin daga cikin biyun da aka saya).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Saya alewa masu tsada 4 da 3, sami 2 kyauta; biya don 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Saya dukkan alewa, babu alewa kyauta da ake da su.",
      "hi": "Swift फ़ंक्शन `func minCostToBuyCandies(_ costs: [Int]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nएक प्रमोशन के तहत सभी कैंडीज़ प्राप्त करने की न्यूनतम कुल लागत की गणना करता है जहाँ\nदो कैंडीज़ खरीदने पर एक मुफ्त कैंडी मिलती है (जिसकी कीमत खरीदी गई दो में से कम कीमत के बराबर या उससे कम होती है)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 और 3 की कीमत वाली कैंडीज़ खरीदें, 2 मुफ्त में मिलती है; 1 के लिए भुगतान करें।\n>>> minCostToBuyCandies([1, 2])\n3 // दोनों कैंडीज़ खरीदें, कोई मुफ्त कैंडी उपलब्ध नहीं है।",
      "hu": "Írj egy Swift függvényt `func minCostToBuyCandies(_ costs: [Int]) -> Int {` a következő probléma megoldására:\n\nKiszámítja a minimális teljes költséget az összes cukorka megszerzéséhez egy olyan promóció keretében, ahol két cukorka vásárlása esetén egy cukorkát ingyen kapunk (melynek ára kisebb vagy egyenlő a megvásárolt kettő közül a kisebbikkel).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Vásárolj 4 és 3 árú cukorkákat, kapd meg a 2 árút ingyen; fizess az 1-ért.\n>>> minCostToBuyCandies([1, 2])\n3 // Vásárold meg mindkét cukorkát, nincs elérhető ingyen cukorka."
    },
    "instruction_bertscore": {
      "sq": "0.9563346860763384",
      "hy": "0.9330047533022667",
      "bn": "0.9674645422168664",
      "bg": "0.9760215390318493",
      "zh": "0.9388635550212717",
      "fr": "0.9672226104127658",
      "de": "0.9829581091983497",
      "ha": "0.9714427114882331",
      "hi": "0.9438048830102767",
      "hu": "0.934606508694932"
    },
    "level": "easy",
    "test": "func checkMinCostToBuyCandies(_ minCostToBuyCandies: ([Int]) -> Int) {\nassert(minCostToBuyCandies([1, 2, 3, 4]) == 8)\nassert(minCostToBuyCandies([1, 2]) == 3)\nassert(minCostToBuyCandies([1, 6, 3, 5, 2, 4]) == 16)\nassert(minCostToBuyCandies([5, 5, 5, 5, 5, 5]) == 20)\nassert(minCostToBuyCandies([7, 1, 2, 9, 6, 4]) == 22)\nassert(minCostToBuyCandies([1]) == 1)\nassert(minCostToBuyCandies([]) == 0)\n}\n\ncheckMinCostToBuyCandies(minCostToBuyCandies)",
    "entry_point": "minCostToBuyCandies",
    "signature": "func minCostToBuyCandies(_ costs: [Int]) -> Int {",
    "docstring": {
      "en": "\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n",
      "sq": "Llogarit koston totale minimale për të blerë të gjitha karamelet nën një promovim ku blerja e dy karameleve të jep një karamele falas (me çmimin më të vogël ose të barabartë me atë më të voglin nga dy të blerat).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Bli karamelet që kushtojnë 4 dhe 3, merr 2 falas; paguaj për 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Bli të dyja karamelet, nuk ka karamele falas të disponueshme.",
      "hy": "Հաշվում է բոլոր կոնֆետները ձեռք բերելու նվազագույն ընդհանուր արժեքը՝ այնպիսի ակցիայի պայմաններում, որտեղ երկու կոնֆետ գնելիս ստանում եք մեկ անվճար կոնֆետ (որի գինը փոքր կամ հավասար է գնված երկուսի փոքրագույնին):\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Գնել 4 և 3 արժեքով կոնֆետները, ստանալ 2-ը անվճար; վճարել 1-ի համար:\n>>> minCostToBuyCandies([1, 2])\n3 // Գնել երկու կոնֆետները, անվճար կոնֆետներ չկան:",
      "bn": "সকল ক্যান্ডি একটি প্রচারের অধীনে অর্জন করার জন্য সর্বনিম্ন মোট খরচ গণনা করে যেখানে দুটি ক্যান্ডি কিনলে একটি ক্যান্ডি বিনামূল্যে পাওয়া যায় (যার মূল্য ক্রয়কৃত দুটি ক্যান্ডির মধ্যে কম মূল্যের সমান বা তার চেয়ে কম)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 এবং 3 মূল্যের ক্যান্ডি কিনুন, 2 বিনামূল্যে পান; 1 এর জন্য অর্থ প্রদান করুন।\n>>> minCostToBuyCandies([1, 2])\n3 // উভয় ক্যান্ডি কিনুন, কোন বিনামূল্যের ক্যান্ডি পাওয়া যাবে না।",
      "bg": "Изчислява минималната обща цена за придобиване на всички бонбони при промоция, където купуването на два бонбона получаваш един безплатно (с цена по-малка или равна на по-евтиния от двата закупени).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Купете бонбони на стойност 4 и 3, получете 2 безплатно; платете за 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Купете и двата бонбона, няма налични безплатни бонбони.",
      "zh": "计算在促销活动下获取所有糖果的最低总成本，其中购买两颗糖果可以免费获得一颗糖果（其价格小于或等于所购买的两颗糖果中较便宜的那颗）。\n\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 购买价格为4和3的糖果，免费获得价格为2的糖果；支付价格为1的糖果。\n\n>>> minCostToBuyCandies([1, 2])\n3 // 购买两颗糖果，没有免费糖果。",
      "fr": "Calcule le coût total minimum pour acquérir tous les bonbons dans le cadre d'une promotion où l'achat de deux bonbons permet d'obtenir un bonbon gratuit (dont le prix est inférieur ou égal au moins cher des deux achetés).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Acheter des bonbons coûtant 4 et 3, obtenir 2 gratuitement ; payer pour 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Acheter les deux bonbons, aucun bonbon gratuit disponible.",
      "de": "Berechnet die minimalen Gesamtkosten, um alle Süßigkeiten unter einer Aktion zu erwerben, bei der der Kauf von zwei Süßigkeiten eine kostenlose Süßigkeit erhält (mit einem Preis, der kleiner oder gleich dem der günstigeren der beiden gekauften ist).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Kaufe Süßigkeiten, die 4 und 3 kosten, erhalte 2 kostenlos; bezahle für 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Kaufe beide Süßigkeiten, keine kostenlosen Süßigkeiten verfügbar.",
      "ha": "Yana ƙididdige mafi ƙarancin jimlar kuɗi don siyan dukkan alewa a ƙarƙashin tayin inda\nsiyan alewa biyu yana samun alewa ɗaya kyauta (tare da farashinsa ƙasa ko daidai da ƙaramin daga cikin biyun da aka siya).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Sayi alewa masu tsada 4 da 3, sami 2 kyauta; biya don 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Sayi dukkan alewa biyu, babu alewa kyauta da ake da su.",
      "hi": "सभी मिठाइयों को एक प्रमोशन के तहत प्राप्त करने की न्यूनतम कुल लागत की गणना करता है जहाँ दो मिठाइयाँ खरीदने पर एक मुफ्त मिलती है (जिसकी कीमत खरीदी गई दो में से कम कीमत वाली के बराबर या उससे कम होती है)।\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 और 3 की कीमत वाली मिठाइयाँ खरीदें, 2 मुफ्त में मिलती है; 1 के लिए भुगतान करें।\n>>> minCostToBuyCandies([1, 2])\n3 // दोनों मिठाइयाँ खरीदें, कोई मुफ्त मिठाई उपलब्ध नहीं है।",
      "hu": "Kiszámítja a minimális összköltséget az összes cukorka megszerzéséhez egy olyan promóció keretében, ahol két cukorka vásárlása esetén egy ingyen jár (amelynek ára kisebb vagy egyenlő a megvásárolt két cukorka közül a kisebbikével).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Vásárolj 4 és 3 árú cukorkákat, kapj egy 2 árút ingyen; fizess az 1-ért.\n>>> minCostToBuyCandies([1, 2])\n3 // Vásárold meg mindkét cukorkát, nincs ingyen cukorka."
    },
    "docstring_bertscore": {
      "sq": "0.957521899863784",
      "hy": "0.9480849704608164",
      "bn": "0.9451851655280881",
      "bg": "0.9655376288904469",
      "zh": "0.9147003677987586",
      "fr": "0.9557068154418872",
      "de": "0.9811765933108478",
      "ha": "0.9533774769634911",
      "hi": "0.9287183096795338",
      "hu": "0.9392338020515208"
    }
  },
  {
    "task_id": "Swift/6",
    "prompt": {
      "en": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n*/",
      "sq": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nNumëron numrin e elementeve në varg që kanë të paktën një element rreptësisht më të vogël dhe \nnjë element rreptësisht më të madh.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një element më të madh (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një element më të madh (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nuk ka elemente me si një element më të vogël ashtu edhe një element më të madh.\n*/",
      "hy": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nՀաշվում է այն տարրերի քանակը զանգվածում, որոնք ունեն առնվազն մեկ խիստ փոքր և \nմեկ խիստ մեծ տարր:\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Միայն '2' տարրը ունի և՛ փոքր (1), և՛ մեծ (3) տարր:\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Միայն '2' տարրը ունի և՛ փոքր (1), և՛ մեծ (3) տարր:\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Չկան տարրեր, որոնք ունեն և՛ փոքր, և՛ մեծ տարր:\n*/",
      "bn": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nঅ্যারের মধ্যে কতগুলি উপাদান রয়েছে যা অন্তত একটি কঠোরভাবে ছোট এবং একটি কঠোরভাবে বড় উপাদান রয়েছে তা গণনা করে।\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // শুধুমাত্র উপাদান '2' এর উভয় একটি ছোট (1) এবং একটি বড় (3) উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // শুধুমাত্র উপাদান '2' এর উভয় একটি ছোট (1) এবং একটি বড় (3) উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // এমন কোন উপাদান নেই যার উভয় একটি ছোট এবং একটি বড় উপাদান রয়েছে।\n*/",
      "bg": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nБрои броя на елементите в масива, които имат поне един строго по-малък и \nедин строго по-голям елемент.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Няма елементи с както по-малък, така и по-голям елемент.\n*/",
      "zh": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\n计算数组中至少有一个严格较小和一个严格较大元素的元素数量。\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // 只有元素 '2' 同时有一个较小的元素 (1) 和一个较大的元素 (3)。\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // 只有元素 '2' 同时有一个较小的元素 (1) 和一个较大的元素 (3)。\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // 没有元素同时具有较小和较大的元素。\n*/",
      "fr": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCompte le nombre d'éléments dans le tableau qui ont au moins un élément strictement plus petit et \nun élément strictement plus grand.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Il n'y a pas d'éléments avec à la fois un élément plus petit et un élément plus grand.\n*/",
      "de": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nZählt die Anzahl der Elemente im Array, die mindestens ein strikt kleineres und \nein strikt größeres Element haben.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Es gibt keine Elemente mit sowohl einem kleineren als auch einem größeren Element.\n*/",
      "ha": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nYana ƙirga adadin abubuwan da ke cikin jerin waɗanda ke da aƙalla ɗaya da ya fi ƙanƙanta da \nɗaya da ya fi girma.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Abun '2' kawai ne ke da ƙanƙanta (1) da kuma girma (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Abun '2' kawai ne ke da ƙanƙanta (1) da kuma girma (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Babu abubuwan da ke da ƙanƙanta da kuma girma.\n*/",
      "hi": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nऐरे में उन तत्वों की संख्या गिनता है जिनके पास कम से कम एक सख्ती से छोटा और \nएक सख्ती से बड़ा तत्व है।\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // ऐसे कोई तत्व नहीं हैं जिनके पास एक छोटा और एक बड़ा तत्व हो।\n*/",
      "hu": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nMegszámolja azokat az elemeket a tömbben, amelyeknek van legalább egy szigorúan kisebb és egy szigorúan nagyobb eleme.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nincsenek olyan elemek, amelyeknek mind kisebb, mind nagyobb eleme lenne.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9772085541889138",
      "hy": "0.9968550851770747",
      "bn": "0.9835833976378475",
      "bg": "1",
      "zh": "0.970309127903667",
      "fr": "0.9753525519085239",
      "de": "1",
      "ha": "0.9605353213744643",
      "hi": "0.988493739287411",
      "hu": "0.9878172042096062"
    },
    "canonical_solution": "guard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}",
    "instruction": {
      "en": "Write a Swift function `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` to solve the following problem:\n\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n",
      "sq": "Shkruani një funksion Swift `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nNumëron elementet në varg që kanë të paktën një element rreptësisht më të vogël dhe një element rreptësisht më të madh.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një element më të madh (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një element më të madh (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nuk ka elemente me të dyja një element më të vogël dhe një element më të madh.",
      "hy": "Գրեք Swift ֆունկցիա `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է տարրերի քանակը զանգվածում, որոնք ունեն առնվազն մեկ խիստ փոքր և մեկ խիստ մեծ տարր:\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Միայն '2' տարրը ունի և՛ փոքր (1), և՛ մեծ (3) տարր:\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Միայն '2' տարրը ունի և՛ փոքր (1), և՛ մեծ (3) տարր:\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Չկան տարրեր, որոնք ունեն և՛ փոքր, և՛ մեծ տարր:\n",
      "bn": "Swift ফাংশন `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nঅ্যারের মধ্যে কতগুলি উপাদান আছে তা গণনা করে যা অন্তত একটি কঠোরভাবে ছোট এবং \nএকটি কঠোরভাবে বড় উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // শুধুমাত্র উপাদান '2'-এর উভয় একটি ছোট (1) এবং একটি বড় (3) উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // শুধুমাত্র উপাদান '2'-এর উভয় একটি ছোট (1) এবং একটি বড় (3) উপাদান রয়েছে।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // এখানে কোন উপাদান নেই যার উভয় একটি ছোট এবং একটি বড় উপাদান রয়েছে।",
      "bg": "Напишете функция на Swift `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` за решаване на следния проблем:\n\nБрои броя на елементите в масива, които имат поне един строго по-малък и един строго по-голям елемент.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Няма елементи с както по-малък, така и по-голям елемент.",
      "zh": "编写一个 Swift 函数 `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` 来解决以下问题：\n\n计算数组中至少有一个严格较小和一个严格较大元素的元素数量。\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // 只有元素 '2' 同时有一个较小的元素 (1) 和一个较大的元素 (3)。\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // 只有元素 '2' 同时有一个较小的元素 (1) 和一个较大的元素 (3)。\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // 没有元素同时有一个较小和一个较大的元素。",
      "fr": "Écrire une fonction Swift `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` pour résoudre le problème suivant :\n\nCompte le nombre d'éléments dans le tableau qui ont au moins un élément strictement plus petit et un élément strictement plus grand.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Il n'y a pas d'éléments avec à la fois un élément plus petit et un élément plus grand.",
      "de": "Schreiben Sie eine Swift-Funktion `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {`, um das folgende Problem zu lösen:\n\nZählt die Anzahl der Elemente im Array, die mindestens ein strikt kleineres und ein strikt größeres Element haben.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Es gibt keine Elemente mit sowohl einem kleineren als auch einem größeren Element.",
      "ha": "Rubuta aikin Swift `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` don warware matsalar mai zuwa:\n\nYa ƙidaya yawan abubuwan da ke cikin jerin waɗanda ke da aƙalla ɗaya da ya fi ƙanƙanta kuma ɗaya da ya fi girma sosai.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Abin da kawai '2' yana da ƙarami (1) da kuma babba (3) abu.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Abin da kawai '2' yana da ƙarami (1) da kuma babba (3) abu.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Babu abubuwa da ke da ƙarami da babba abu.",
      "hi": "Swift फ़ंक्शन `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nऐरे में उन तत्वों की संख्या गिनें जिनके पास कम से कम एक सख्ती से छोटा और एक सख्ती से बड़ा तत्व है।\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // ऐसे कोई तत्व नहीं हैं जिनके पास एक छोटा और एक बड़ा तत्व हो।",
      "hu": "Írj egy Swift függvényt `func countElementsWithStrictBounds(_ nums: [Int]) -> Int {` a következő probléma megoldására:\n\nMegszámolja a tömb azon elemeinek számát, amelyeknek van legalább egy szigorúan kisebb és egy szigorúan nagyobb eleme.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nincs olyan elem, amelynek mind kisebb, mind nagyobb eleme lenne."
    },
    "instruction_bertscore": {
      "sq": "0.9736314196568565",
      "hy": "0.9954376587780096",
      "bn": "0.9682521116776697",
      "bg": "0.9959189401912572",
      "zh": "0.9748313457886882",
      "fr": "0.9764716354752744",
      "de": "1",
      "ha": "0.9560518364137448",
      "hi": "0.9709107793278217",
      "hu": "0.9953504600407354"
    },
    "level": "easy",
    "test": "func checkCountElementsWithStrictBounds(_ countElementsWithStrictBounds: ([Int]) -> Int) {\nassert(countElementsWithStrictBounds([2, 1, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 2, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 1, 1]) == 0)\nassert(countElementsWithStrictBounds([3, 3, 5, 2, 2, 7, 4]) == 4)\nassert(countElementsWithStrictBounds([10, 5, 9, 1, 7, 6, 8]) == 5)\nassert(countElementsWithStrictBounds([-2, -1, 0, 1, 2]) == 3)\nassert(countElementsWithStrictBounds([]) == 0)\n}\n\ncheckCountElementsWithStrictBounds(countElementsWithStrictBounds)",
    "entry_point": "countElementsWithStrictBounds",
    "signature": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n",
      "sq": "Numëron numrin e elementeve në varg që kanë të paktën një element rreptësisht më të vogël dhe një element rreptësisht më të madh.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një më të madh (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Vetëm elementi '2' ka si një element më të vogël (1) ashtu edhe një më të madh (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nuk ka elemente me si një element më të vogël ashtu edhe një më të madh.",
      "hy": "Հաշվում է այն տարրերի քանակը զանգվածում, որոնք ունեն առնվազն մեկ խիստ փոքր և մեկ խիստ մեծ տարր:\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Միայն տարրը '2' ունի և՛ փոքր (1), և՛ մեծ (3) տարր:\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Միայն տարրը '2' ունի և՛ փոքր (1), և՛ մեծ (3) տարր:\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Չկան տարրեր, որոնք ունեն և՛ փոքր, և՛ մեծ տարր:",
      "bn": "Counts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // শুধুমাত্র উপাদান '2' এর উভয় একটি ছোট (1) এবং একটি বড় (3) উপাদান আছে।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // শুধুমাত্র উপাদান '2' এর উভয় একটি ছোট (1) এবং একটি বড় (3) উপাদান আছে।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // এমন কোনো উপাদান নেই যার উভয় একটি ছোট এবং একটি বড় উপাদান আছে।",
      "bg": "Брои броя на елементите в масива, които имат поне един строго по-малък и един строго по-голям елемент.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Само елементът '2' има както по-малък (1), така и по-голям (3) елемент.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Няма елементи с както по-малък, така и по-голям елемент.",
      "zh": "计算数组中至少有一个严格较小和一个严格较大元素的元素数量。\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // 只有元素 '2' 同时有一个较小的 (1) 和一个较大的 (3) 元素。\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // 只有元素 '2' 同时有一个较小的 (1) 和一个较大的 (3) 元素。\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // 没有元素同时具有较小和较大的元素。",
      "fr": "Compte le nombre d'éléments dans le tableau qui ont au moins un élément strictement plus petit et un élément strictement plus grand.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Seul l'élément '2' a à la fois un élément plus petit (1) et un élément plus grand (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Il n'y a pas d'éléments avec à la fois un élément plus petit et un élément plus grand.",
      "de": "Zählt die Anzahl der Elemente im Array, die mindestens ein strikt kleineres und ein strikt größeres Element haben.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Nur das Element '2' hat sowohl ein kleineres (1) als auch ein größeres (3) Element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Es gibt keine Elemente mit sowohl einem kleineren als auch einem größeren Element.",
      "ha": "Yana ƙidaya adadin abubuwan da ke cikin jerin waɗanda ke da aƙalla ɗaya da ya fi ƙanƙanta da ɗaya da ya fi girma.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Abun '2' kawai yana da ƙarami (1) da kuma babba (3) abu.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Abun '2' kawai yana da ƙarami (1) da kuma babba (3) abu.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Babu wani abu da ke da ƙarami da kuma babba abu.",
      "hi": "गिनती करता है कि कितने तत्वों के पास कम से कम एक सख्ती से छोटा और एक सख्ती से बड़ा तत्व है।\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // केवल तत्व '2' के पास एक छोटा (1) और एक बड़ा (3) तत्व है।\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // कोई भी तत्व नहीं है जिसके पास एक छोटा और एक बड़ा तत्व हो।",
      "hu": "Számolja meg azokat az elemeket a tömbben, amelyeknek van legalább egy szigorúan kisebb és egy szigorúan nagyobb eleme.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Csak a '2' elemnek van mind kisebb (1), mind nagyobb (3) eleme.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Nincs olyan elem, amelynek lenne mind kisebb, mind nagyobb eleme."
    },
    "docstring_bertscore": {
      "sq": "0.9704092376157085",
      "hy": "0.996220063848906",
      "bn": "0.9941533147342381",
      "bg": "1",
      "zh": "0.9816638336355263",
      "fr": "0.9706384570754228",
      "de": "1",
      "ha": "0.9660056020681651",
      "hi": "0.9562655627037383",
      "hu": "0.9767777248924492"
    }
  },
  {
    "task_id": "Swift/7",
    "prompt": {
      "en": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n*/",
      "sq": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nVazhdimisht dyfishon vlerën e 'original' nëse gjendet në vargun 'nums'.\nKthen vlerën përfundimtare të 'original' pas përsëritjes së këtij procesi.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 gjendet, bëhet 6; 6 gjendet, bëhet 12; 12 gjendet, bëhet 24; 24 nuk gjendet.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nuk gjendet, original mbetet 4.\n*/",
      "hy": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nՇարունակաբար կրկնապատկում է 'original' արժեքը, եթե այն գտնվում է 'nums' զանգվածում:\nՎերադարձնում է 'original'-ի վերջնական արժեքը այս գործընթացը կրկնելուց հետո:\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3-ը գտնվեց, դարձավ 6; 6-ը գտնվեց, դարձավ 12; 12-ը գտնվեց, դարձավ 24; 24-ը չգտնվեց:\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4-ը չգտնվեց, original-ը մնաց 4:\n*/",
      "bn": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\n'original' এর মানটি যদি 'nums' অ্যারেতে পাওয়া যায় তবে এটি ক্রমাগত দ্বিগুণ করে।\nএই প্রক্রিয়া পুনরাবৃত্তি করার পরে 'original' এর চূড়ান্ত মান ফেরত দেয়।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 পাওয়া যায়, 6 হয়; 6 পাওয়া যায়, 12 হয়; 12 পাওয়া যায়, 24 হয়; 24 পাওয়া যায় না।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 পাওয়া যায় না, original 4 থাকে।\n*/",
      "bg": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nНепрекъснато удвоява стойността на 'original', ако тя се намери в масива 'nums'.\nВръща крайната стойност на 'original' след повтаряне на този процес.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 е намерено, става 6; 6 е намерено, става 12; 12 е намерено, става 24; 24 не е намерено.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 не е намерено, original остава 4.\n*/",
      "zh": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\n如果在数组 'nums' 中找到 'original' 的值，则不断将其加倍。\n返回重复此过程后的 'original' 的最终值。\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 找到 3，变为 6；找到 6，变为 12；找到 12，变为 24；24 未找到。\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 未找到，original 保持为 4。\n*/",
      "fr": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nDouble continuellement la valeur de 'original' si elle est trouvée dans le tableau 'nums'.\nRenvoie la valeur finale de 'original' après avoir répété ce processus.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 est trouvé, devient 6; 6 est trouvé, devient 12; 12 est trouvé, devient 24; 24 non trouvé.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 n'est pas trouvé, original reste 4.\n*/",
      "de": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nVerdoppelt kontinuierlich den Wert von 'original', wenn er im Array 'nums' gefunden wird.\nGibt den Endwert von 'original' zurück, nachdem dieser Prozess wiederholt wurde.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 wird gefunden, wird zu 6; 6 wird gefunden, wird zu 12; 12 wird gefunden, wird zu 24; 24 wird nicht gefunden.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 wird nicht gefunden, original bleibt 4.\n*/",
      "ha": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nKoyaushe yana ninka darajar 'original' idan an same shi a cikin jerin 'nums'.\nYana mayar da ƙarshe darajar 'original' bayan maimaita wannan tsari.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 an same shi, ya zama 6; 6 an same shi, ya zama 12; 12 an same shi, ya zama 24; 24 ba a same shi ba.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 ba a same shi ba, original ya kasance 4.\n*/",
      "hi": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\n'original' के मान को लगातार दोगुना करता है यदि यह 'nums' array में पाया जाता है।\nइस प्रक्रिया को दोहराने के बाद 'original' का अंतिम मान लौटाता है।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 पाया गया, 6 बन जाता है; 6 पाया गया, 12 बन जाता है; 12 पाया गया, 24 बन जाता है; 24 नहीं पाया गया।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 नहीं पाया गया, original 4 ही रहता है।\n*/",
      "hu": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nFolyamatosan megduplázza az 'original' értékét, ha az megtalálható a 'nums' tömbben.\nVisszaadja az 'original' végső értékét a folyamat ismétlése után.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 megtalálható, 6 lesz belőle; 6 megtalálható, 12 lesz belőle; 12 megtalálható, 24 lesz belőle; 24 nem található.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nem található, az eredeti marad 4.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9982111347883998",
      "hy": "0.9814656005152536",
      "bn": "0.9685800504367583",
      "bg": "0.9982111347883998",
      "zh": "0.9518839751284898",
      "fr": "0.9991566154021259",
      "de": "0.9931585737860154",
      "ha": "0.9862182296422753",
      "hi": "0.9798092217678036",
      "hu": "0.9737464266474757"
    },
    "canonical_solution": "var current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}",
    "instruction": {
      "en": "Write a Swift function `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` to solve the following problem:\n\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n",
      "sq": "Shkruani një funksion Swift `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nVazhdimisht dyfishon vlerën e 'original' nëse gjendet në vargun 'nums'.\nKthen vlerën përfundimtare të 'original' pas përsëritjes së këtij procesi.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 gjendet, bëhet 6; 6 gjendet, bëhet 12; 12 gjendet, bëhet 24; 24 nuk gjendet.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nuk gjendet, original mbetet 4.",
      "hy": "Գրեք Swift ֆունկցիա `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՇարունակաբար կրկնապատկում է 'original'-ի արժեքը, եթե այն գտնվի 'nums' զանգվածում:\nՎերադարձնում է 'original'-ի վերջնական արժեքը այս գործընթացը կրկնելուց հետո:\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3-ը գտնվել է, դառնում է 6; 6-ը գտնվել է, դառնում է 12; 12-ը գտնվել է, դառնում է 24; 24-ը չի գտնվել:\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4-ը չի գտնվել, original-ը մնում է 4:",
      "bn": "Swift ফাংশন `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nযদি 'original' মানটি 'nums' অ্যারেতে পাওয়া যায় তবে এটি ক্রমাগত দ্বিগুণ করে।\nএই প্রক্রিয়া পুনরাবৃত্তির পরে 'original' এর চূড়ান্ত মানটি ফেরত দেয়।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 পাওয়া যায়, 6 হয়; 6 পাওয়া যায়, 12 হয়; 12 পাওয়া যায়, 24 হয়; 24 পাওয়া যায় না।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 পাওয়া যায় না, original 4 থাকে।",
      "bg": "Напишете Swift функция `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` за решаване на следния проблем:\n\nНепрекъснато удвоява стойността на 'original', ако тя се намери в масива 'nums'.\nВръща крайната стойност на 'original' след повторение на този процес.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 е намерено, става 6; 6 е намерено, става 12; 12 е намерено, става 24; 24 не е намерено.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 не е намерено, original остава 4.",
      "zh": "编写一个 Swift 函数 `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` 来解决以下问题：\n\n如果在数组 'nums' 中找到 'original' 的值，则不断将其加倍。\n返回重复此过程后的 'original' 的最终值。\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 找到 3，变为 6；找到 6，变为 12；找到 12，变为 24；24 未找到。\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 未找到，original 保持为 4。",
      "fr": "Écrire une fonction Swift `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` pour résoudre le problème suivant :\n\nDouble continuellement la valeur de 'original' si elle est trouvée dans le tableau 'nums'.\nRenvoie la valeur finale de 'original' après avoir répété ce processus.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 est trouvé, devient 6 ; 6 est trouvé, devient 12 ; 12 est trouvé, devient 24 ; 24 non trouvé.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 n'est pas trouvé, original reste 4.",
      "de": "Schreiben Sie eine Swift-Funktion `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {`, um das folgende Problem zu lösen:\n\nVerdoppelt kontinuierlich den Wert von 'original', wenn er im Array 'nums' gefunden wird.\nGibt den Endwert von 'original' zurück, nachdem dieser Prozess wiederholt wurde.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 wird gefunden, wird zu 6; 6 wird gefunden, wird zu 12; 12 wird gefunden, wird zu 24; 24 wird nicht gefunden.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 wird nicht gefunden, original bleibt 4.",
      "ha": "Rubuta aikin Swift `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` don warware matsalar mai zuwa:\n\nCi gaba da ninka darajar 'original' idan an same shi a cikin jerin 'nums'.\nMayar da darajar ƙarshe na 'original' bayan maimaita wannan tsari.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 an same shi, ya zama 6; 6 an same shi, ya zama 12; 12 an same shi, ya zama 24; 24 ba a same shi ba.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 ba a same shi ba, original ya kasance 4.",
      "hi": "Write a Swift function `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` निम्नलिखित समस्या को हल करने के लिए:\n\nयदि 'original' को 'nums' array में पाया जाता है, तो इसे लगातार दोगुना करता है।\nइस प्रक्रिया को दोहराने के बाद 'original' का अंतिम मान लौटाता है।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 पाया गया, 6 बन गया; 6 पाया गया, 12 बन गया; 12 पाया गया, 24 बन गया; 24 नहीं पाया गया।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 नहीं पाया गया, original 4 ही रहता है।",
      "hu": "Írj egy Swift függvényt `func findFinalValue(_ nums: [Int], _ original: Int) -> Int {` a következő probléma megoldására:\n\nFolyamatosan megduplázza az 'original' értékét, ha az megtalálható a 'nums' tömbben.\nVisszaadja az 'original' végső értékét a folyamat ismétlése után.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 megtalálható, 6 lesz belőle; 6 megtalálható, 12 lesz belőle; 12 megtalálható, 24 lesz belőle; 24 nem található.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nem található, az eredeti marad 4."
    },
    "instruction_bertscore": {
      "sq": "0.9956493987641929",
      "hy": "0.9882043348222431",
      "bn": "0.9518537833105725",
      "bg": "0.9956493987641929",
      "zh": "0.9554152260425279",
      "fr": "0.9973500720866135",
      "de": "0.9908920025080262",
      "ha": "0.9835532058199302",
      "hi": "0.9586449560381552",
      "hu": "0.9650966694445494"
    },
    "level": "easy",
    "test": "func checkFindFinalValue(_ findFinalValue: ([Int], Int) -> Int) {\nassert(findFinalValue([5, 3, 6, 1, 12], 3) == 24)\nassert(findFinalValue([2, 7, 9], 4) == 4)\nassert(findFinalValue([1, 2, 4, 8, 16], 1) == 32)\nassert(findFinalValue([10, 20, 30, 40], 10) == 80)\nassert(findFinalValue([5, 10, 20, 40], 2) == 2)\nassert(findFinalValue([], 1) == 1)\nassert(findFinalValue([100, 200, 300], 100) == 400)\n}\n\ncheckFindFinalValue(findFinalValue)",
    "entry_point": "findFinalValue",
    "signature": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {",
    "docstring": {
      "en": "\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n",
      "sq": "Vazhdimisht dyfishon vlerën e 'original' nëse gjendet në vargun 'nums'.\nKthen vlerën përfundimtare të 'original' pasi të përsëritet ky proces.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 gjendet, bëhet 6; 6 gjendet, bëhet 12; 12 gjendet, bëhet 24; 24 nuk gjendet.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nuk gjendet, original mbetet 4.",
      "hy": "Շարունակաբար կրկնապատկում է 'original'-ի արժեքը, եթե այն գտնվի 'nums' զանգվածում:\nՎերադարձնում է 'original'-ի վերջնական արժեքը այս գործընթացը կրկնելուց հետո:\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3-ը գտնվեց, դառնում է 6; 6-ը գտնվեց, դառնում է 12; 12-ը գտնվեց, դառնում է 24; 24-ը չի գտնվել:\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4-ը չի գտնվել, original-ը մնում է 4:",
      "bn": "'original' এর মানকে ক্রমাগত দ্বিগুণ করে যদি এটি 'nums' অ্যারেতে পাওয়া যায়। এই প্রক্রিয়া পুনরাবৃত্তির পরে 'original' এর চূড়ান্ত মান ফেরত দেয়।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 পাওয়া যায়, 6 হয়; 6 পাওয়া যায়, 12 হয়; 12 পাওয়া যায়, 24 হয়; 24 পাওয়া যায় না।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 পাওয়া যায় না, original 4 থাকে।",
      "bg": "Непрекъснато удвоява стойността на 'original', ако тя се намери в масива 'nums'.\nВръща крайната стойност на 'original' след повтаряне на този процес.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 се намира, става 6; 6 се намира, става 12; 12 се намира, става 24; 24 не се намира.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 не се намира, original остава 4.",
      "zh": "不断地将 'original' 的值加倍，如果在数组 'nums' 中找到它。\n返回重复此过程后的 'original' 的最终值。\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 找到 3，变为 6；找到 6，变为 12；找到 12，变为 24；24 未找到。\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 未找到，original 保持为 4。",
      "fr": "Double continuellement la valeur de 'original' si elle est trouvée dans le tableau 'nums'.\nRenvoie la valeur finale de 'original' après avoir répété ce processus.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 est trouvé, devient 6; 6 est trouvé, devient 12; 12 est trouvé, devient 24; 24 non trouvé.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 n'est pas trouvé, original reste 4.",
      "de": "Verdoppelt kontinuierlich den Wert von 'original', wenn er im Array 'nums' gefunden wird.\nGibt den endgültigen Wert von 'original' zurück, nachdem dieser Prozess wiederholt wurde.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 wird gefunden, wird zu 6; 6 wird gefunden, wird zu 12; 12 wird gefunden, wird zu 24; 24 wird nicht gefunden.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 wird nicht gefunden, original bleibt 4.",
      "ha": "Yana ci gaba da ninka ƙimar 'original' idan an same shi a cikin jerin 'nums'. \nYana mayar da ƙimar ƙarshe na 'original' bayan maimaita wannan tsari.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 an same shi, ya zama 6; 6 an same shi, ya zama 12; 12 an same shi, ya zama 24; 24 ba a same shi ba.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 ba a same shi ba, original ya kasance 4.",
      "hi": "लगातार 'original' के मान को दोगुना करता है यदि यह 'nums' array में पाया जाता है। इस प्रक्रिया को दोहराने के बाद 'original' का अंतिम मान लौटाता है।\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 पाया गया, 6 बन गया; 6 पाया गया, 12 बन गया; 12 पाया गया, 24 बन गया; 24 नहीं पाया गया।\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 नहीं पाया गया, original 4 ही रहता है।",
      "hu": "Folyamatosan megduplázza az 'original' értékét, ha az megtalálható a 'nums' tömbben.\nVisszaadja az 'original' végső értékét a folyamat ismétlése után.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 megtalálva, 6 lesz belőle; 6 megtalálva, 12 lesz belőle; 12 megtalálva, 24 lesz belőle; 24 nem található.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 nem található, az eredeti marad 4."
    },
    "docstring_bertscore": {
      "sq": "0.9869893127814527",
      "hy": "0.9811301138016856",
      "bn": "0.9768103002749389",
      "bg": "0.997278565149441",
      "zh": "0.9714474786173779",
      "fr": "0.9871506006508531",
      "de": "0.990941660103285",
      "ha": "0.968173851307542",
      "hi": "0.9697382641885727",
      "hu": "0.9681194265831384"
    }
  },
  {
    "task_id": "Swift/8",
    "prompt": {
      "en": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "sq": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nRiorendon vargun 'nums' duke renditur indeksat tek në rend zbritës dhe indeksat çift në rend rritës.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indekset çift (0, 2) të renditura si [2, 4], indekset tek (1, 3) të renditura si [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "hy": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nՎերադասավորում է 'nums' զանգվածը՝ զույգ ինդեքսները դասավորելով չնվազող կարգով և կենտ ինդեքսները՝ չաճող կարգով:\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Զույգ ինդեքսները (0, 2) դասավորված են որպես [2, 4], կենտ ինդեքսները (1, 3) դասավորված են որպես [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "bn": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nঅ্যারে 'nums' পুনর্বিন্যাস করে যাতে বিজোড় সূচকগুলি অবনমিত ক্রমে এবং জোড় সূচকগুলি ঊর্ধ্বমুখী ক্রমে সাজানো হয়।\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // জোড় সূচক (0, 2) সাজানো হয়েছে [2, 4] হিসাবে, বিজোড় সূচক (1, 3) সাজানো হয়েছে [3, 1] হিসাবে।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "bg": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nПреурежда масива 'nums', като сортира нечетните индекси в намаляващ ред и четните индекси в нарастващ ред.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Четни индекси (0, 2) сортирани като [2, 4], нечетни индекси (1, 3) сортирани като [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "zh": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\n重新排序数组 'nums'，使得奇数索引按非递增顺序排序，偶数索引按非递减顺序排序。\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // 偶数索引 (0, 2) 排序为 [2, 4]，奇数索引 (1, 3) 排序为 [3, 1]。\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "fr": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nRéorganise le tableau 'nums' en triant les indices impairs par ordre décroissant et les indices pairs par ordre croissant.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indices pairs (0, 2) triés comme [2, 4], indices impairs (1, 3) triés comme [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "de": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nOrdnet das Array 'nums' neu, indem ungerade Indizes in nicht-zunehmender Reihenfolge und gerade Indizes in nicht-abnehmender Reihenfolge sortiert werden.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Gerade Indizes (0, 2) sortiert als [2, 4], ungerade Indizes (1, 3) sortiert als [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "ha": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nSake tsara jerin 'nums' ta hanyar tsara alamomin waje a cikin oda mai raguwa kuma alamomin ciki a cikin oda mai karuwa.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Alamomin ciki (0, 2) an tsara su kamar [2, 4], alamomin waje (1, 3) an tsara su kamar [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "hi": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\n'nums' array को पुनः क्रमबद्ध करता है जिसमें विषम सूचकांकों को अवरोही क्रम में और सम सूचकांकों को आरोही क्रम में क्रमबद्ध किया जाता है।\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // सम सूचकांक (0, 2) को [2, 4] के रूप में क्रमबद्ध किया गया, विषम सूचकांक (1, 3) को [3, 1] के रूप में क्रमबद्ध किया गया।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "hu": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nAz 'nums' tömböt úgy rendezi át, hogy a páratlan indexeket nem növekvő sorrendbe, a páros indexeket pedig nem csökkenő sorrendbe rendezi.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Páros indexek (0, 2) rendezve [2, 4], páratlan indexek (1, 3) rendezve [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.953884183065511",
      "hy": "0.9795080981101547",
      "bn": "0.960237773063674",
      "bg": "0.9584574489584583",
      "zh": "0.966324006568964",
      "fr": "0.9564449259378128",
      "de": "1",
      "ha": "0.9361985311989267",
      "hi": "0.9571188788206642",
      "hu": "0.962037165685469"
    },
    "canonical_solution": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}",
    "instruction": {
      "en": "Write a Swift function `func reorderArray(_ nums: [Int]) -> [Int] {` to solve the following problem:\n\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n",
      "sq": "Shkruani një funksion Swift `func reorderArray(_ nums: [Int]) -> [Int] {` për të zgjidhur problemin në vijim:\n\nRiorganizon vargun 'nums' duke renditur indeksat tek në rend zbritës dhe indeksat çift në rend rritës.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indekset çift (0, 2) të renditura si [2, 4], indekset tek (1, 3) të renditura si [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "hy": "Swift ֆունկցիա գրեք `func reorderArray(_ nums: [Int]) -> [Int] {` հետևյալ խնդիրը լուծելու համար:\n\nՎերադասավորում է 'nums' զանգվածը՝ զույգ ինդեքսները դասավորելով չնվազող կարգով, իսկ կենտ ինդեքսները՝ չաճող կարգով:\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Զույգ ինդեքսները (0, 2) դասավորված են որպես [2, 4], կենտ ինդեքսները (1, 3) դասավորված են որպես [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "bn": "একটি Swift ফাংশন `func reorderArray(_ nums: [Int]) -> [Int] {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nঅ্যারে 'nums' পুনর্বিন্যাস করে যাতে বিজোড় সূচকগুলি অবনমিত ক্রমে এবং জোড় সূচকগুলি আরোহী ক্রমে সাজানো হয়।\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // জোড় সূচক (0, 2) সাজানো হয়েছে [2, 4] হিসাবে, বিজোড় সূচক (1, 3) সাজানো হয়েছে [3, 1] হিসাবে।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "bg": "Напишете Swift функция `func reorderArray(_ nums: [Int]) -> [Int] {` за решаване на следния проблем:\n\nПренарежда масива 'nums', като сортира нечетните индекси в намаляващ ред и четните индекси в нарастващ ред.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Четните индекси (0, 2) сортирани като [2, 4], нечетните индекси (1, 3) сортирани като [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "zh": "编写一个 Swift 函数 `func reorderArray(_ nums: [Int]) -> [Int] {` 来解决以下问题：\n\n将数组 'nums' 重新排序，使得奇数索引按非递增顺序排序，偶数索引按非递减顺序排序。\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // 偶数索引 (0, 2) 排序为 [2, 4]，奇数索引 (1, 3) 排序为 [3, 1]。\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "fr": "Écrire une fonction Swift `func reorderArray(_ nums: [Int]) -> [Int] {` pour résoudre le problème suivant :\n\nRéorganise le tableau 'nums' en triant les indices impairs par ordre décroissant et les indices pairs par ordre croissant.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indices pairs (0, 2) triés comme [2, 4], indices impairs (1, 3) triés comme [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "de": "Schreiben Sie eine Swift-Funktion `func reorderArray(_ nums: [Int]) -> [Int] {`, um das folgende Problem zu lösen:\n\nOrdnet das Array 'nums' neu, indem ungerade Indizes in nicht-zunehmender Reihenfolge und gerade Indizes in nicht-abnehmender Reihenfolge sortiert werden.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Gerade Indizes (0, 2) sortiert als [2, 4], ungerade Indizes (1, 3) sortiert als [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "ha": "Rubuta aikin Swift `func reorderArray(_ nums: [Int]) -> [Int] {` don warware matsalar mai zuwa:\n\nSake tsara jerin 'nums' ta hanyar tsara alamun lambobi masu banbanci a cikin tsari mai raguwa kuma alamun lambobi masu daidaita a cikin tsari mai karuwa.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Alamun lambobi masu daidaita (0, 2) an tsara su kamar [2, 4], alamun lambobi masu banbanci (1, 3) an tsara su kamar [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "hi": "Swift फ़ंक्शन `func reorderArray(_ nums: [Int]) -> [Int] {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nएरे 'nums' को इस प्रकार पुनः व्यवस्थित करें कि विषम इंडेक्स को घटते क्रम में और सम इंडेक्स को बढ़ते क्रम में क्रमबद्ध किया जाए।\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // सम इंडेक्स (0, 2) को [2, 4] के रूप में क्रमबद्ध किया गया, विषम इंडेक्स (1, 3) को [3, 1] के रूप में क्रमबद्ध किया गया।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "hu": "Írj egy Swift függvényt `func reorderArray(_ nums: [Int]) -> [Int] {` a következő probléma megoldására:\n\nÚjrarendezi a 'nums' tömböt úgy, hogy a páratlan indexek nem növekvő sorrendben, a páros indexek pedig nem csökkenő sorrendben legyenek rendezve.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Páros indexek (0, 2) rendezve mint [2, 4], páratlan indexek (1, 3) rendezve mint [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]"
    },
    "instruction_bertscore": {
      "sq": "0.9602455196485343",
      "hy": "0.965134210586565",
      "bn": "0.9620095560625053",
      "bg": "0.9644201343667446",
      "zh": "0.973565871631115",
      "fr": "0.9596055325608399",
      "de": "0.9985988612921799",
      "ha": "0.9375432588785328",
      "hi": "0.9495496708905677",
      "hu": "0.9704767719452604"
    },
    "level": "middle",
    "test": "func checkReorderArray(_ reorderArray: ([Int]) -> [Int]) {\nassert(reorderArray([4, 1, 2, 3]) == [2, 3, 4, 1])\nassert(reorderArray([6, 5, 4, 3, 2, 1]) == [2, 5, 4, 3, 6, 1])\nassert(reorderArray([1, 2, 3, 4, 5, 6]) == [1, 6, 3, 4, 5, 2])\nassert(reorderArray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [2, 9, 4, 7, 6, 5, 8, 3, 10, 1])\nassert(reorderArray([1]) == [1])\nassert(reorderArray([1, 2]) == [1, 2])\nassert(reorderArray([]) == [])\n}\n\ncheckReorderArray(reorderArray)",
    "entry_point": "reorderArray",
    "signature": "func reorderArray(_ nums: [Int]) -> [Int] {",
    "docstring": {
      "en": "\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n",
      "sq": "Riorganizon vargun 'nums' duke renditur indeksat tek në rend zbritës dhe indeksat çift në rend rritës.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indekset çift (0, 2) të renditura si [2, 4], indekset tek (1, 3) të renditura si [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "hy": "Վերադասավորում է 'nums' զանգվածը՝ զույգ ինդեքսները դասավորելով աճման կարգով և կենտ ինդեքսները՝ նվազման կարգով:\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Զույգ ինդեքսները (0, 2) դասավորված են որպես [2, 4], կենտ ինդեքսները (1, 3) դասավորված են որպես [3, 1]:\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "bn": "Reorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // জোড় ইনডেক্স (0, 2) [2, 4] হিসেবে সাজানো হয়েছে, বিজোড় ইনডেক্স (1, 3) [3, 1] হিসেবে সাজানো হয়েছে।\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "bg": "Преурежда масива 'nums', като сортира нечетните индекси в низходящ ред и четните индекси във възходящ ред.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Четни индекси (0, 2) сортирани като [2, 4], нечетни индекси (1, 3) сортирани като [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "zh": "重新排序数组 'nums'，通过将奇数索引按非递增顺序排序，偶数索引按非递减顺序排序。\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // 偶数索引 (0, 2) 排序为 [2, 4]，奇数索引 (1, 3) 排序为 [3, 1]。\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "fr": "Réorganise le tableau 'nums' en triant les indices impairs par ordre décroissant et les indices pairs par ordre croissant.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Indices pairs (0, 2) triés comme [2, 4], indices impairs (1, 3) triés comme [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "de": "Ordnet das Array 'nums' neu, indem ungerade Indizes in nicht-zunehmender Reihenfolge und gerade Indizes in nicht-abnehmender Reihenfolge sortiert werden.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Gerade Indizes (0, 2) sortiert als [2, 4], ungerade Indizes (1, 3) sortiert als [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "ha": "Sake tsara jerin 'nums' ta hanyar tsara alamun masu lamba mara kyau a cikin tsari mara karuwa da alamun masu lamba maɗaukaki a cikin tsari mai ƙaruwa.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Alamun maɗaukaki (0, 2) an tsara su azaman [2, 4], alamun masu lamba mara kyau (1, 3) an tsara su azaman [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "hi": "Reorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.  \nएरे 'nums' को पुनः क्रमबद्ध करता है ताकि विषम अनुक्रमणिकाएँ अवरोही क्रम में और सम अनुक्रमणिकाएँ आरोही क्रम में हों।  \n>>> reorderArray([4, 1, 2, 3])  \n[2, 3, 4, 1] // सम अनुक्रमणिकाएँ (0, 2) को [2, 4] के रूप में क्रमबद्ध किया गया है, विषम अनुक्रमणिकाएँ (1, 3) को [3, 1] के रूप में क्रमबद्ध किया गया है।  \n>>> reorderArray([6, 5, 4, 3, 2, 1])  \n[2, 5, 4, 3, 6, 1]  ",
      "hu": "Átrendezi a 'nums' tömböt úgy, hogy a páratlan indexeket nem növekvő sorrendbe, a páros indexeket pedig nem csökkenő sorrendbe rendezi.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Páros indexek (0, 2) rendezve [2, 4], páratlan indexek (1, 3) rendezve [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]"
    },
    "docstring_bertscore": {
      "sq": "0.9457224607087875",
      "hy": "0.9314931761025912",
      "bn": "0.9889086781533929",
      "bg": "0.9476454014275862",
      "zh": "0.970884361487144",
      "fr": "0.9427553200768883",
      "de": "0.9914741881548395",
      "ha": "0.9381753007509859",
      "hi": "0.9288716523336927",
      "hu": "0.9460070980448105"
    }
  },
  {
    "task_id": "Swift/9",
    "prompt": {
      "en": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n*/",
      "sq": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nNumëron numrin e çifteve (i, j) në vargun 'nums' ku nums[i] == nums[j] dhe (i * j) është i pjestueshëm me 'k'.\nKushtet: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Çiftet (0, 3) plotësojnë kushtet.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Të gjitha çiftet plotësojnë kushtet pasi çdo (i * j) është i pjestueshëm me 1.\n*/",
      "hy": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nՀաշվում է զույգերի (i, j) քանակը 'nums' զանգվածում, որտեղ nums[i] == nums[j] և (i * j) բաժանվում է 'k'-ի վրա:\nՊայմաններ: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Զույգերը (0, 3) բավարարում են պայմանները:\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Բոլոր զույգերը բավարարում են պայմանները, քանի որ յուրաքանչյուր (i * j) բաժանվում է 1-ի վրա:\n*/",
      "bn": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nঅ্যারে 'nums' এর মধ্যে (i, j) জোড়ার সংখ্যা গণনা করে যেখানে nums[i] == nums[j] এবং (i * j) 'k' দ্বারা বিভাজ্য।\nশর্তাবলী: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // জোড়া (0, 3) শর্তগুলি পূরণ করে।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // সমস্ত জোড়া শর্তগুলি পূরণ করে যেহেতু প্রতিটি (i * j) 1 দ্বারা বিভাজ্য।\n*/",
      "bg": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nБрои броя на двойките (i, j) в масива 'nums', където nums[i] == nums[j] и (i * j) се дели на 'k'.\nУсловия: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Двойките (0, 3) удовлетворяват условията.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Всички двойки удовлетворяват условията, тъй като всяко (i * j) се дели на 1.\n*/",
      "zh": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\n计算数组 'nums' 中满足 nums[i] == nums[j] 且 (i * j) 能被 'k' 整除的对数 (i, j)。\n条件: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // 对 (0, 3) 满足条件。\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // 所有对都满足条件，因为每个 (i * j) 都能被 1 整除。\n*/",
      "fr": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCompte le nombre de paires (i, j) dans le tableau 'nums' où nums[i] == nums[j] et (i * j) est divisible par 'k'.\nConditions : 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Les paires (0, 3) satisfont les conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Toutes les paires satisfont les conditions puisque chaque (i * j) est divisible par 1.\n*/",
      "de": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nZählt die Anzahl der Paare (i, j) im Array 'nums', bei denen nums[i] == nums[j] und (i * j) durch 'k' teilbar ist.\nBedingungen: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Die Paare (0, 3) erfüllen die Bedingungen.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Alle Paare erfüllen die Bedingungen, da jedes (i * j) durch 1 teilbar ist.\n*/",
      "ha": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nYana ƙididdige adadin ma'aurata (i, j) a cikin jerin 'nums' inda nums[i] == nums[j] kuma (i * j) yana raba 'k' ba tare da saura ba.\nYanayi: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Ma'aurata (0, 3) suna cika yanayin.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Duk ma'aurata suna cika yanayin tunda kowane (i * j) yana raba 1 ba tare da saura ba.\n*/",
      "hi": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nगिनती करता है कि 'nums' array में कितने जोड़े (i, j) हैं जहाँ nums[i] == nums[j] और (i * j) 'k' द्वारा विभाज्य है।\nशर्तें: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // जोड़े (0, 3) शर्तों को पूरा करते हैं।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // सभी जोड़े शर्तों को पूरा करते हैं क्योंकि हर (i * j) 1 द्वारा विभाज्य है।\n*/",
      "hu": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nMegszámolja azokat a párokat (i, j) a 'nums' tömbben, ahol nums[i] == nums[j] és (i * j) osztható 'k'-val.\nFeltételek: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // A (0, 3) párok megfelelnek a feltételeknek.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Minden pár megfelel a feltételeknek, mivel minden (i * j) osztható 1-gyel.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9915355649425793",
      "hy": "0.9873877653258087",
      "bn": "0.986364818863479",
      "bg": "0.9873424775989328",
      "zh": "0.9687999342685639",
      "fr": "0.9879800811220548",
      "de": "0.9865839081737605",
      "ha": "0.951600926835515",
      "hi": "0.9787904465434757",
      "hu": "0.9699929083370594"
    },
    "canonical_solution": "var count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}",
    "instruction": {
      "en": "Write a Swift function `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` to solve the following problem:\n\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n",
      "sq": "Shkruani një funksion Swift `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nNumëron çiftet (i, j) në vargun 'nums' ku nums[i] == nums[j] dhe (i * j) është i pjestueshëm me 'k'.\nKushtet: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Çiftet (0, 3) plotësojnë kushtet.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Të gjitha çiftet plotësojnë kushtet pasi çdo (i * j) është i pjestueshëm me 1.",
      "hy": "Գրեք Swift ֆունկցիա `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է զույգերի (i, j) քանակը 'nums' զանգվածում, որտեղ nums[i] == nums[j] և (i * j)-ն բաժանվում է 'k'-ի վրա:\nՊայմաններ: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Զույգերը (0, 3) բավարարում են պայմանները:\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Բոլոր զույգերը բավարարում են պայմանները, քանի որ յուրաքանչյուր (i * j) բաժանվում է 1-ի վրա:",
      "bn": "একটি Swift ফাংশন `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nঅ্যারে 'nums' এর মধ্যে (i, j) জোড়ার সংখ্যা গণনা করে যেখানে nums[i] == nums[j] এবং (i * j) 'k' দ্বারা বিভাজ্য।\nশর্তাবলী: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // জোড়া (0, 3) শর্তগুলি পূরণ করে।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // সমস্ত জোড়া শর্তগুলি পূরণ করে কারণ প্রতিটি (i * j) 1 দ্বারা বিভাজ্য।",
      "bg": "Напишете Swift функция `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` за решаване на следния проблем:\n\nБрои броя на двойките (i, j) в масива 'nums', където nums[i] == nums[j] и (i * j) е делимо на 'k'.\nУсловия: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Двойката (0, 3) удовлетворява условията.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Всички двойки удовлетворяват условията, тъй като всяко (i * j) е делимо на 1.",
      "zh": "编写一个 Swift 函数 `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` 来解决以下问题：\n\n计算数组 'nums' 中满足 nums[i] == nums[j] 且 (i * j) 能被 'k' 整除的数对 (i, j) 的数量。\n条件: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // 数对 (0, 3) 满足条件。\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // 所有数对都满足条件，因为每个 (i * j) 都能被 1 整除。",
      "fr": "Écrivez une fonction Swift `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` pour résoudre le problème suivant :\n\nCompte le nombre de paires (i, j) dans le tableau 'nums' où nums[i] == nums[j] et (i * j) est divisible par 'k'.\nConditions : 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Les paires (0, 3) satisfont les conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Toutes les paires satisfont les conditions puisque chaque (i * j) est divisible par 1.",
      "de": "Schreiben Sie eine Swift-Funktion `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {`, um das folgende Problem zu lösen:\n\nZählt die Anzahl der Paare (i, j) im Array 'nums', bei denen nums[i] == nums[j] und (i * j) durch 'k' teilbar ist.\nBedingungen: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Die Paare (0, 3) erfüllen die Bedingungen.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Alle Paare erfüllen die Bedingungen, da jedes (i * j) durch 1 teilbar ist.",
      "ha": "Rubuta aikin Swift `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` don warware matsalar mai zuwa:\n\nYana ƙidaya adadin ma'aurata (i, j) a cikin jerin 'nums' inda nums[i] == nums[j] kuma (i * j) yana raba 'k' ba tare da saura ba.\nYanayi: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Ma'aurata (0, 3) suna cika yanayin.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Duk ma'aurata suna cika yanayin tunda kowane (i * j) yana raba 1 ba tare da saura ba.",
      "hi": "Swift फ़ंक्शन `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nऐरे 'nums' में जोड़े (i, j) की संख्या गिनें जहाँ nums[i] == nums[j] और (i * j) 'k' से विभाज्य है।\nशर्तें: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // जोड़े (0, 3) शर्तों को पूरा करते हैं।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // सभी जोड़े शर्तों को पूरा करते हैं क्योंकि प्रत्येक (i * j) 1 से विभाज्य है।",
      "hu": "Írj egy Swift függvényt `func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {` a következő probléma megoldására:\n\nMegszámolja az 'nums' tömbben az (i, j) párok számát, ahol nums[i] == nums[j] és (i * j) osztható 'k'-val.\nFeltételek: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // A (0, 3) párok teljesítik a feltételeket.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Minden pár teljesíti a feltételeket, mivel minden (i * j) osztható 1-gyel."
    },
    "instruction_bertscore": {
      "sq": "0.9765232793743435",
      "hy": "0.988960123422081",
      "bn": "0.9851031186831455",
      "bg": "0.9882869650607536",
      "zh": "0.973691008771167",
      "fr": "0.9855212356352239",
      "de": "0.9903171661853113",
      "ha": "0.9517610229226291",
      "hi": "0.9654784370368985",
      "hu": "0.98578918801924"
    },
    "level": "easy",
    "test": "func checkCountDivisiblePairs(_ countDivisiblePairs: ([Int], Int) -> Int) {\nassert(countDivisiblePairs([1, 2, 3, 1, 2, 3], 3) == 1)\nassert(countDivisiblePairs([1, 1, 1, 1], 1) == 6)\nassert(countDivisiblePairs([1, 2, 3, 4, 5, 6], 7) == 0)\nassert(countDivisiblePairs([1, 2, 2, 1, 2], 2) == 4)\nassert(countDivisiblePairs([4, 4, 4, 4], 4) == 3)\nassert(countDivisiblePairs([], 5) == 0)\nassert(countDivisiblePairs([2, 2, 2, 2, 2], 3) == 7 )\n}\n\ncheckCountDivisiblePairs(countDivisiblePairs)",
    "entry_point": "countDivisiblePairs",
    "signature": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {",
    "docstring": {
      "en": "\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n",
      "sq": "Numëron numrin e çifteve (i, j) në vargun 'nums' ku nums[i] == nums[j] dhe (i * j) është i pjestueshëm me 'k'.\nKushtet: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Çiftet (0, 3) plotësojnë kushtet.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Të gjitha çiftet plotësojnë kushtet pasi çdo (i * j) është i pjestueshëm me 1.",
      "hy": "Հաշվում է զույգերի (i, j) քանակը 'nums' զանգվածում, որտեղ nums[i] == nums[j] և (i * j) բաժանվում է 'k'-ի վրա:\nՊայմաններ: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Զույգերը (0, 3) բավարարում են պայմանները:\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Բոլոր զույգերը բավարարում են պայմանները, քանի որ յուրաքանչյուր (i * j) բաժանվում է 1-ի վրա:",
      "bn": "Counts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nশর্তাবলী: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // জোড়া (0, 3) শর্তগুলি পূরণ করে।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // সমস্ত জোড়া শর্তগুলি পূরণ করে কারণ প্রতিটি (i * j) 1 দ্বারা বিভাজ্য।",
      "bg": "Брои броя на двойките (i, j) в масива 'nums', където nums[i] == nums[j] и (i * j) се дели на 'k'.\nУсловия: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Двойката (0, 3) удовлетворява условията.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Всички двойки удовлетворяват условията, тъй като всяко (i * j) се дели на 1.",
      "zh": "计算数组 'nums' 中满足 nums[i] == nums[j] 且 (i * j) 能被 'k' 整除的 (i, j) 对的数量。\n条件: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // 对 (0, 3) 满足条件。\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // 所有对都满足条件，因为每个 (i * j) 都能被 1 整除。",
      "fr": "Compte le nombre de paires (i, j) dans le tableau 'nums' où nums[i] == nums[j] et (i * j) est divisible par 'k'.\nConditions : 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Les paires (0, 3) satisfont les conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Toutes les paires satisfont les conditions puisque chaque (i * j) est divisible par 1.",
      "de": "Zählt die Anzahl der Paare (i, j) im Array 'nums', bei denen nums[i] == nums[j] und (i * j) durch 'k' teilbar ist.\nBedingungen: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Die Paare (0, 3) erfüllen die Bedingungen.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Alle Paare erfüllen die Bedingungen, da jedes (i * j) durch 1 teilbar ist.",
      "ha": "Yana ƙididdige adadin ma'aurata (i, j) a cikin jerin 'nums' inda nums[i] == nums[j] kuma (i * j) yana raba 'k'.\nYanayi: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Ma'aurata (0, 3) suna cika yanayin.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Dukkan ma'aurata suna cika yanayin saboda kowanne (i * j) yana raba 1.",
      "hi": "गिनती करता है कि 'nums' array में कितने जोड़े (i, j) हैं जहाँ nums[i] == nums[j] और (i * j) 'k' से विभाज्य है।\nशर्तें: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // जोड़े (0, 3) शर्तों को पूरा करते हैं।\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // सभी जोड़े शर्तों को पूरा करते हैं क्योंकि हर (i * j) 1 से विभाज्य है।",
      "hu": "Számolja meg az 'nums' tömbben az (i, j) párok számát, ahol nums[i] == nums[j] és (i * j) osztható 'k'-val.\nFeltételek: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // A (0, 3) párok teljesítik a feltételeket.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Minden pár teljesíti a feltételeket, mivel minden (i * j) osztható 1-gyel."
    },
    "docstring_bertscore": {
      "sq": "0.9894429938783768",
      "hy": "0.9847507483871896",
      "bn": "0.981223271450391",
      "bg": "0.9842931039892852",
      "zh": "0.9552706231251346",
      "fr": "0.9793547554559958",
      "de": "0.9824102866074554",
      "ha": "0.9696254421321449",
      "hi": "0.9696911887882674",
      "hu": "0.9804841678025602"
    }
  },
  {
    "task_id": "Swift/10",
    "prompt": {
      "en": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n*/",
      "sq": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nNumëron numrin e vargjeve në vargun 'words' që fillojnë me parashtesën 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", dhe \"application\" fillojnë me \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Vetëm \"hello\" fillon me \"he\".\n*/",
      "hy": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nՀաշվում է 'words' զանգվածում այն տողերի քանակը, որոնք սկսվում են 'pref' նախածանցով։\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", և \"application\" սկսվում են \"app\"-ով։\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Միայն \"hello\"-ն է սկսվում \"he\"-ով։\n*/",
      "bn": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nঅ্যারে 'words'-এর মধ্যে কতগুলি স্ট্রিং 'pref' উপসর্গ দিয়ে শুরু হয় তা গণনা করে।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", এবং \"application\" \"app\" দিয়ে শুরু হয়।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // শুধুমাত্র \"hello\" \"he\" দিয়ে শুরু হয়।\n*/",
      "bg": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nБрои броя на низовете в масива 'words', които започват с префикса 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" и \"application\" започват с \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Само \"hello\" започва с \"he\".\n*/",
      "zh": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\n计算数组 'words' 中以前缀 'pref' 开头的字符串数量。\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", 和 \"application\" 以 \"app\" 开头。\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // 只有 \"hello\" 以 \"he\" 开头。\n*/",
      "fr": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCompte le nombre de chaînes dans le tableau 'words' qui commencent par le préfixe 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", et \"application\" commencent par \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Seul \"hello\" commence par \"he\".\n*/",
      "de": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nZählt die Anzahl der Zeichenfolgen im Array 'words', die mit dem Präfix 'pref' beginnen.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" und \"application\" beginnen mit \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Nur \"hello\" beginnt mit \"he\".\n*/",
      "ha": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nYana ƙididdige adadin igiyoyi a cikin jerin 'words' waɗanda suka fara da farkon 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", da \"application\" suna farawa da \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sai dai \"hello\" kawai yana farawa da \"he\".\n*/",
      "hi": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nगिनती करता है कि 'words' नामक array में कितने strings 'pref' उपसर्ग से शुरू होते हैं।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", और \"application\" \"app\" से शुरू होते हैं।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // केवल \"hello\" \"he\" से शुरू होता है।\n*/",
      "hu": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nMegszámolja, hogy hány string kezdődik a 'words' tömbben a 'pref' előtaggal.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // Az \"apple\", \"app\" és \"application\" kezdődik \"app\"-el.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Csak a \"hello\" kezdődik \"he\"-vel.\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9867261275265815",
      "bn": "0.9863977915067309",
      "bg": "1",
      "zh": "0.992137613627496",
      "fr": "1",
      "de": "0.9969601606486421",
      "ha": "0.9945620960584078",
      "hi": "0.985271358615882",
      "hu": "0.977551588856961"
    },
    "canonical_solution": "return words.filter { $0.hasPrefix(pref) }.count\n}",
    "instruction": {
      "en": "Write a Swift function `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` to solve the following problem:\n\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n",
      "sq": "Shkruani një funksion Swift `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nNumëron numrin e vargjeve në vargun 'words' që fillojnë me parashtesën 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", dhe \"application\" fillojnë me \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Vetëm \"hello\" fillon me \"he\".",
      "hy": "Գրեք Swift ֆունկցիա `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է 'words' զանգվածի այն տողերի քանակը, որոնք սկսվում են 'pref' նախածանցով:\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" և \"application\" սկսվում են \"app\"-ով:\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Միայն \"hello\"-ն սկսվում է \"he\"-ով:",
      "bn": "Swift ফাংশন `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nঅ্যারের 'words' এর মধ্যে কতগুলো স্ট্রিং 'pref' উপসর্গ দিয়ে শুরু হয় তা গণনা করে।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", এবং \"application\" \"app\" দিয়ে শুরু হয়।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // শুধুমাত্র \"hello\" \"he\" দিয়ে শুরু হয়।",
      "bg": "Напишете функция на Swift `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` за решаване на следния проблем:\n\nБрои броя на низовете в масива 'words', които започват с префикса 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" и \"application\" започват с \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Само \"hello\" започва с \"he\".",
      "zh": "编写一个 Swift 函数 `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` 来解决以下问题：\n\n计算数组 'words' 中以前缀 'pref' 开头的字符串数量。\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\"、\"app\" 和 \"application\" 以 \"app\" 开头。\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // 只有 \"hello\" 以 \"he\" 开头。",
      "fr": "Écrire une fonction Swift `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` pour résoudre le problème suivant :\n\nCompte le nombre de chaînes dans le tableau 'words' qui commencent par le préfixe 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", et \"application\" commencent par \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Seul \"hello\" commence par \"he\".",
      "de": "Schreiben Sie eine Swift-Funktion `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {`, um das folgende Problem zu lösen:\n\nZählt die Anzahl der Zeichenfolgen im Array 'words', die mit dem Präfix 'pref' beginnen.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" und \"application\" beginnen mit \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Nur \"hello\" beginnt mit \"he\".",
      "ha": "Rubuta aikin Swift `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` don warware matsalar mai zuwa:\n\nYana ƙididdige yawan igiyoyi a cikin jerin 'words' waɗanda suka fara da farkon 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", da \"application\" suna farawa da \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sai dai kawai \"hello\" yana farawa da \"he\".",
      "hi": "Swift फ़ंक्शन `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nगिनती करें कि 'words' array में कितने strings 'pref' उपसर्ग से शुरू होते हैं।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", और \"application\" \"app\" से शुरू होते हैं।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // केवल \"hello\" \"he\" से शुरू होता है।",
      "hu": "Írj egy Swift függvényt `func countPrefixStrings(_ words: [String], _ pref: String) -> Int {` a következő probléma megoldására:\n\nMegszámolja, hány string kezdődik a 'words' tömbben a 'pref' előtaggal.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // Az \"apple\", \"app\" és \"application\" kezdődik \"app\"-pal.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Csak a \"hello\" kezdődik \"he\"-vel."
    },
    "instruction_bertscore": {
      "sq": "0.9943402259227919",
      "hy": "0.9864834012009569",
      "bn": "0.9709967862828097",
      "bg": "1",
      "zh": "0.9943402259227919",
      "fr": "0.9943402259227919",
      "de": "1",
      "ha": "0.9907944749909381",
      "hi": "0.9589923605745853",
      "hu": "0.9776044245383163"
    },
    "level": "easy",
    "test": "func checkCountPrefixStrings(_ countPrefixStrings: ([String], String) -> Int) {\nassert(countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\") == 3)\nassert(countPrefixStrings([\"hello\", \"world\"], \"he\") == 1)\nassert(countPrefixStrings([\"python\", \"php\", \"perl\", \"java\"], \"p\") == 3)\nassert(countPrefixStrings([\"swift\", \"scala\"], \"s\") == 2)\nassert(countPrefixStrings([\"go\", \"rust\", \"ruby\"], \"c\") == 0)\nassert(countPrefixStrings([], \"test\") == 0)\nassert(countPrefixStrings([\"prefix\", \"preference\", \"preliminary\"], \"pre\") == 3)\n}\n\ncheckCountPrefixStrings(countPrefixStrings)",
    "entry_point": "countPrefixStrings",
    "signature": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {",
    "docstring": {
      "en": "\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n",
      "sq": "Numëron numrin e vargjeve në vargun 'words' që fillojnë me parashtesën 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" dhe \"application\" fillojnë me \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Vetëm \"hello\" fillon me \"he\".",
      "hy": "Հաշվում է 'words' զանգվածում այն տողերի քանակը, որոնք սկսվում են 'pref' նախածանցով:\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" և \"application\" սկսվում են \"app\"-ով:\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Միայն \"hello\"-ն սկսվում է \"he\"-ով:",
      "bn": "গণনা করে কতগুলি স্ট্রিং অ্যারে 'words'-এ আছে যা 'pref' উপসর্গ দিয়ে শুরু হয়।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", এবং \"application\" \"app\" দিয়ে শুরু হয়।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // শুধুমাত্র \"hello\" \"he\" দিয়ে শুরু হয়।",
      "bg": "Брои броя на низовете в масива 'words', които започват с префикса 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" и \"application\" започват с \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Само \"hello\" започва с \"he\".",
      "zh": "计算数组 'words' 中以前缀 'pref' 开头的字符串数量。\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\"、\"app\" 和 \"application\" 以 \"app\" 开头。\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // 只有 \"hello\" 以 \"he\" 开头。",
      "fr": "Compte le nombre de chaînes dans le tableau 'words' qui commencent par le préfixe 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" et \"application\" commencent par \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Seul \"hello\" commence par \"he\".",
      "de": "Zählt die Anzahl der Zeichenfolgen im Array 'words', die mit dem Präfix 'pref' beginnen.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" und \"application\" beginnen mit \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Nur \"hello\" beginnt mit \"he\".",
      "ha": "Yana ƙidaya adadin igiyoyin rubutu a cikin jerin 'kalma' waɗanda suka fara da farkon 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", da \"application\" suna farawa da \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sai dai \"hello\" kawai yake farawa da \"he\".",
      "hi": "शब्दों की सूची 'words' में उन स्ट्रिंग्स की संख्या गिनता है जो उपसर्ग 'pref' से शुरू होती हैं।\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", और \"application\" \"app\" से शुरू होते हैं।\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // केवल \"hello\" \"he\" से शुरू होता है।",
      "hu": "Számolja meg a 'words' tömbben azon karakterláncok számát, amelyek a 'pref' előtaggal kezdődnek.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // Az \"apple\", \"app\" és \"application\" \"app\"-pal kezdődik.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Csak a \"hello\" kezdődik \"he\"-vel."
    },
    "docstring_bertscore": {
      "sq": "0.9960339471818764",
      "hy": "0.9641859491475044",
      "bn": "0.968493050329865",
      "bg": "1",
      "zh": "0.9867922714434662",
      "fr": "0.9883825062740315",
      "de": "0.9960339471818764",
      "ha": "0.9836247127571028",
      "hi": "0.9899004396459",
      "hu": "0.9792788786504405"
    }
  },
  {
    "task_id": "Swift/11",
    "prompt": {
      "en": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n*/",
      "sq": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nHeq në mënyrë të përsëritur një element nga 'words' në indeksin 'i' nëse 'words[i]' dhe 'words[i - 1]' janë anagrame,\nderisa të mos mbeten çifte të tilla. Kthen vargun e modifikuar 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" dhe \"dc\" hiqen pasi janë anagrame të elementeve të mëparshme.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Heqja e njëpasnjëshme e anagrameve rezulton në [\"abc\", \"bac\"], pastaj [\"abc\"].\n*/",
      "hy": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nԿրկնակի հեռացնում է 'words' զանգվածից 'i' ինդեքսում գտնվող տարրը, եթե 'words[i]' և 'words[i - 1]' տարրերը անագրամներ են,\nմինչև նման զույգեր չմնան։ Վերադարձնում է փոփոխված 'words' զանգվածը։\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\"-ն և \"dc\"-ն հեռացվում են, քանի որ դրանք իրենց նախորդ տարրերի անագրամներն են։\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Անագրամների հաջորդական հեռացումը բերում է [\"abc\", \"bac\"], ապա [\"abc\"]։\n*/",
      "bn": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\n'words' তালিকা থেকে 'i' সূচকে থাকা উপাদানটি বারবার সরিয়ে দেয় যদি 'words[i]' এবং 'words[i - 1]' অ্যানাগ্রাম হয়,\nযতক্ষণ না এমন কোনো জোড়া অবশিষ্ট থাকে। পরিবর্তিত 'words' তালিকা ফেরত দেয়।\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" এবং \"dc\" সরানো হয় কারণ তারা তাদের পূর্ববর্তী উপাদানের অ্যানাগ্রাম।\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // অ্যানাগ্রামগুলির ক্রমাগত অপসারণের ফলে [\"abc\", \"bac\"], তারপর [\"abc\"] হয়।\n*/",
      "bg": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nМногократно премахва елемент от 'words' на индекс 'i', ако 'words[i]' и 'words[i - 1]' са анаграми,\nдокато не останат такива двойки. Връща модифицирания масив 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" и \"dc\" са премахнати, тъй като са анаграми на предишните си елементи.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Последователното премахване на анаграмите води до [\"abc\", \"bac\"], след това [\"abc\"].\n*/",
      "zh": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\n重复移除 'words' 中索引为 'i' 的元素，如果 'words[i]' 和 'words[i - 1]' 是变位词，\n直到没有这样的对存在。返回修改后的 'words' 数组。\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" 和 \"dc\" 被移除，因为它们是其前一个元素的变位词。\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // 连续移除变位词的结果是 [\"abc\", \"bac\"]，然后是 [\"abc\"]。\n*/",
      "fr": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nSupprime de manière répétée un élément de 'words' à l'index 'i' si 'words[i]' et 'words[i - 1]' sont des anagrammes,\njusqu'à ce qu'il n'y ait plus de tels couples. Renvoie le tableau 'words' modifié.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" et \"dc\" sont supprimés car ce sont des anagrammes de leurs éléments précédents.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La suppression séquentielle des anagrammes donne [\"abc\", \"bac\"], puis [\"abc\"].\n*/",
      "de": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nEntfernt wiederholt ein Element aus 'words' an der Stelle 'i', wenn 'words[i]' und 'words[i - 1]' Anagramme sind,\nbis keine solchen Paare mehr vorhanden sind. Gibt das modifizierte 'words'-Array zurück.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" und \"dc\" werden entfernt, da sie Anagramme ihrer vorherigen Elemente sind.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Die sequentielle Entfernung von Anagrammen führt zu [\"abc\", \"bac\"], dann [\"abc\"].\n*/",
      "ha": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nAkan cire wani abu daga cikin 'words' a ma'aunin 'i' idan 'words[i]' da 'words[i - 1]' anagrams ne,\nhar sai babu irin waɗannan ma'aurata da suka rage. Yana mayar da gyararren jerin 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" da \"dc\" an cire su saboda suna anagrams na abubuwan da suka gabata.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Cire anagrams a jere yana haifar da [\"abc\", \"bac\"], sannan [\"abc\"].\n*/",
      "hi": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\n'words' से 'i' इंडेक्स पर तत्व को बार-बार हटाता है यदि 'words[i]' और 'words[i - 1]' एनाग्राम हैं,\nजब तक कि ऐसे जोड़े नहीं बचते। संशोधित 'words' array को लौटाता है।\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" और \"dc\" को हटा दिया जाता है क्योंकि वे उनके पिछले तत्वों के एनाग्राम हैं।\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // एनाग्राम्स के क्रमिक हटाने से परिणाम होता है [\"abc\", \"bac\"], फिर [\"abc\"]।\n*/",
      "hu": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nIsmételten eltávolít egy elemet a 'words' tömbből az 'i' indexnél, ha a 'words[i]' és a 'words[i - 1]' anagrammák,\namíg ilyen párok nem maradnak. Visszaadja a módosított 'words' tömböt.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" és \"dc\" eltávolításra kerülnek, mivel anagrammák az előző elemeikkel.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Az anagrammák sorozatos eltávolítása eredményezi a [\"abc\", \"bac\"], majd [\"abc\"] tömböt.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9828812392408892",
      "hy": "0.9685818381101876",
      "bn": "0.9736163237478979",
      "bg": "0.9826484444343163",
      "zh": "0.9721399041256655",
      "fr": "0.9898968642990414",
      "de": "0.9781200690074829",
      "ha": "0.9578780441369795",
      "hi": "0.9889519795764585",
      "hu": "0.9730095079338363"
    },
    "canonical_solution": "var result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}",
    "instruction": {
      "en": "Write a Swift function `func removeAnagramWords(_ words: [String]) -> [String] {` to solve the following problem:\n\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n",
      "sq": "Shkruani një funksion Swift `func removeAnagramWords(_ words: [String]) -> [String] {` për të zgjidhur problemin në vijim:\n\nHiqni në mënyrë të përsëritur një element nga 'words' në indeksin 'i' nëse 'words[i]' dhe 'words[i - 1]' janë anagrame, derisa të mos mbeten më çifte të tilla. Kthen vargun e modifikuar 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" dhe \"dc\" hiqen pasi janë anagrame të elementeve të tyre të mëparshme.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Heqja e njëpasnjëshme e anagrameve rezulton në [\"abc\", \"bac\"], pastaj [\"abc\"].",
      "hy": "Swift ֆունկցիա գրեք `func removeAnagramWords(_ words: [String]) -> [String] {` հետևյալ խնդիրը լուծելու համար:\n\nԿրկնակի հեռացնում է 'words' զանգվածի 'i' ինդեքսում գտնվող տարրը, եթե 'words[i]' և 'words[i - 1]' տարրերը անագրամներ են, մինչև որ նման զույգեր չեն մնում: Վերադարձնում է փոփոխված 'words' զանգվածը:\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\"-ն և \"dc\"-ն հեռացվում են, քանի որ դրանք իրենց նախորդ տարրերի անագրամներն են:\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Անագրամների հաջորդական հեռացումը բերում է [\"abc\", \"bac\"], ապա [\"abc\"] արդյունքին:",
      "bn": "একটি Swift ফাংশন `func removeAnagramWords(_ words: [String]) -> [String] {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n'words' থেকে 'i' সূচকে একটি উপাদান বারবার সরিয়ে দেয় যদি 'words[i]' এবং 'words[i - 1]' অ্যানাগ্রাম হয়, যতক্ষণ না এমন কোনো জোড়া অবশিষ্ট থাকে। পরিবর্তিত 'words' অ্যারে ফেরত দেয়।\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" এবং \"dc\" সরানো হয়েছে কারণ তারা তাদের পূর্ববর্তী উপাদানের অ্যানাগ্রাম।\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // অ্যানাগ্রামগুলির ক্রমানুসারে অপসারণের ফলে [\"abc\", \"bac\"], তারপর [\"abc\"] হয়।",
      "bg": "Напишете Swift функция `func removeAnagramWords(_ words: [String]) -> [String] {`, за да решите следния проблем:\n\nПовтарящо се премахва елемент от 'words' на индекс 'i', ако 'words[i]' и 'words[i - 1]' са анаграми, докато не останат такива двойки. Връща модифицирания масив 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" и \"dc\" са премахнати, тъй като са анаграми на предишните им елементи.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Последователното премахване на анаграми води до [\"abc\", \"bac\"], след това [\"abc\"].",
      "zh": "编写一个 Swift 函数 `func removeAnagramWords(_ words: [String]) -> [String] {` 来解决以下问题：\n\n重复地从 'words' 中移除索引 'i' 处的元素，如果 'words[i]' 和 'words[i - 1]' 是字谜，直到没有这样的对为止。返回修改后的 'words' 数组。\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" 和 \"dc\" 被移除，因为它们是其前一个元素的字谜。\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // 连续移除字谜结果为 [\"abc\", \"bac\"]，然后是 [\"abc\"]。",
      "fr": "Écrire une fonction Swift `func removeAnagramWords(_ words: [String]) -> [String] {` pour résoudre le problème suivant :\n\nSupprime de manière répétée un élément de 'words' à l'indice 'i' si 'words[i]' et 'words[i - 1]' sont des anagrammes, jusqu'à ce qu'il ne reste plus de tels paires. Renvoie le tableau 'words' modifié.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" et \"dc\" sont supprimés car ils sont des anagrammes de leurs éléments précédents.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La suppression séquentielle des anagrammes donne [\"abc\", \"bac\"], puis [\"abc\"].",
      "de": "Schreiben Sie eine Swift-Funktion `func removeAnagramWords(_ words: [String]) -> [String] {`, um das folgende Problem zu lösen:\n\nEntfernt wiederholt ein Element aus 'words' an Index 'i', wenn 'words[i]' und 'words[i - 1]' Anagramme sind, bis keine solchen Paare mehr vorhanden sind. Gibt das modifizierte 'words'-Array zurück.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" und \"dc\" werden entfernt, da sie Anagramme ihrer vorherigen Elemente sind.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Die sequentielle Entfernung von Anagrammen führt zu [\"abc\", \"bac\"], dann [\"abc\"].",
      "ha": "Rubuta aikin Swift `func removeAnagramWords(_ words: [String]) -> [String] {` don warware matsalar mai zuwa:\n\nA maimaita cire wani abu daga 'words' a alamar 'i' idan 'words[i]' da 'words[i - 1]' suna anagrams,\nhar sai babu irin waɗannan ma'aurata da suka rage. Yana mayar da 'words' da aka gyara.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" da \"dc\" an cire su saboda suna anagrams na abubuwan da suka gabata.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Cire anagrams a jere yana haifar da [\"abc\", \"bac\"], sannan [\"abc\"].",
      "hi": "Swift फ़ंक्शन `func removeAnagramWords(_ words: [String]) -> [String] {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nबार-बार 'words' से तत्व को हटाता है यदि 'words[i]' और 'words[i - 1]' एनाग्राम हैं, जब तक कि ऐसे जोड़े नहीं बचते। संशोधित 'words' array को लौटाता है।\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" और \"dc\" को हटा दिया जाता है क्योंकि वे उनके पिछले तत्वों के एनाग्राम हैं।\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // एनाग्राम्स के क्रमिक हटाने से परिणामस्वरूप [\"abc\", \"bac\"], फिर [\"abc\"] मिलता है।",
      "hu": "Írj egy Swift függvényt `func removeAnagramWords(_ words: [String]) -> [String] {` a következő probléma megoldására:\n\nIsmételten eltávolít egy elemet a 'words' listából az 'i' indexnél, ha a 'words[i]' és a 'words[i - 1]' anagrammák,\namíg ilyen párok már nincsenek. Visszaadja a módosított 'words' tömböt.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // A \"ba\" és a \"dc\" eltávolításra kerülnek, mivel anagrammák az előző elemekkel.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Az anagrammák sorozatos eltávolítása eredményezi a [\"abc\", \"bac\"], majd [\"abc\"] listát."
    },
    "instruction_bertscore": {
      "sq": "0.982914609144903",
      "hy": "0.9713120126975121",
      "bn": "0.9814904293128829",
      "bg": "0.9832814794586745",
      "zh": "0.9831785889212984",
      "fr": "0.989421939057987",
      "de": "0.9913506400578358",
      "ha": "0.9696899970059812",
      "hi": "0.9600844304095151",
      "hu": "0.9723401235497487"
    },
    "level": "middle",
    "test": "func checkRemoveAnagramWords(_ removeAnagramWords: ([String]) -> [String]) {\nassert(removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"]) == [\"ab\", \"cd\", \"e\"])\nassert(removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"]) == [\"abc\"])\nassert(removeAnagramWords([\"word\", \"drow\", \"hello\", \"world\"]) == [\"word\", \"hello\",\"world\"])\nassert(removeAnagramWords([\"a\", \"b\", \"c\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\nassert(removeAnagramWords([\"zzz\", \"zzz\", \"zzz\"]) == [\"zzz\"])\nassert(removeAnagramWords([\"abcd\", \"dbca\", \"dcba\"]) == [\"abcd\"])\n}\n\ncheckRemoveAnagramWords(removeAnagramWords)",
    "entry_point": "removeAnagramWords",
    "signature": "func removeAnagramWords(_ words: [String]) -> [String] {",
    "docstring": {
      "en": "\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n",
      "sq": "Heq në mënyrë të përsëritur një element nga 'words' në indeksin 'i' nëse 'words[i]' dhe 'words[i - 1]' janë anagrame, derisa të mos mbeten çifte të tilla. Kthen vargun e modifikuar 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" dhe \"dc\" hiqen pasi janë anagrame të elementeve të tyre të mëparshme.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Heqja e njëpasnjëshme e anagrameve rezulton në [\"abc\", \"bac\"], pastaj [\"abc\"].",
      "hy": "Կրկնակի հեռացնում է 'words'-ից տարրը 'i' ինդեքսում, եթե 'words[i]' և 'words[i - 1]' տարրերը անագրամներ են,\nմինչև այդպիսի զույգեր չմնան։ Վերադարձնում է փոփոխված 'words' զանգվածը։\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" և \"dc\" հեռացվում են, քանի որ դրանք իրենց նախորդ տարրերի անագրամներն են։\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Անագրամների հաջորդական հեռացումը բերում է [\"abc\", \"bac\"], ապա [\"abc\"]։",
      "bn": "Repeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams, until no such pairs are left. Returns the modified 'words' array. >>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"]) [\"ab\", \"cd\", \"e\"] // \"ba\" এবং \"dc\" সরানো হয়েছে কারণ তারা তাদের পূর্ববর্তী উপাদানের অ্যানাগ্রাম। >>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"]) [\"abc\"] // অ্যানাগ্রামগুলির ধারাবাহিক অপসারণের ফলে [\"abc\", \"bac\"], তারপর [\"abc\"]।",
      "bg": "Повтарящо се премахва елемент от 'words' на индекс 'i', ако 'words[i]' и 'words[i - 1]' са анаграми, докато не останат такива двойки. Връща модифицирания масив 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" и \"dc\" са премахнати, тъй като са анаграми на предишните си елементи.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Последователното премахване на анаграми води до [\"abc\", \"bac\"], след това [\"abc\"].",
      "zh": "反复从 'words' 中移除索引 'i' 处的元素，如果 'words[i]' 和 'words[i - 1]' 是变位词，直到没有这样的对出现。返回修改后的 'words' 数组。\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" 和 \"dc\" 被移除，因为它们是其前一个元素的变位词。\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // 连续移除变位词的结果是 [\"abc\", \"bac\"]，然后是 [\"abc\"]。",
      "fr": "Supprime de manière répétée un élément de 'words' à l'index 'i' si 'words[i]' et 'words[i - 1]' sont des anagrammes, jusqu'à ce qu'il n'y ait plus de tels paires. Renvoie le tableau 'words' modifié.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" et \"dc\" sont supprimés car ils sont des anagrammes de leurs éléments précédents.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La suppression séquentielle des anagrammes donne [\"abc\", \"bac\"], puis [\"abc\"].",
      "de": "Entfernt wiederholt ein Element aus 'words' an der Stelle 'i', wenn 'words[i]' und 'words[i - 1]' Anagramme sind, bis keine solchen Paare mehr vorhanden sind. Gibt das modifizierte 'words'-Array zurück.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" und \"dc\" werden entfernt, da sie Anagramme ihrer vorherigen Elemente sind.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Die sequentielle Entfernung von Anagrammen führt zu [\"abc\", \"bac\"], dann [\"abc\"].",
      "ha": "Sake cire wani abu daga 'words' a wurin 'i' idan 'words[i]' da 'words[i - 1]' suna da anagram,\nhar sai babu irin waɗannan ma'auratan da suka rage. Yana mayar da gyare-gyaren 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" da \"dc\" an cire su saboda suna da anagram na abubuwan da suka gabata.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Cire anagram a jere yana haifar da [\"abc\", \"bac\"], sannan [\"abc\"].",
      "hi": "Repeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams, until no such pairs are left. Returns the modified 'words' array.  \nबार-बार 'words' से इंडेक्स 'i' पर तत्व को हटाता है यदि 'words[i]' और 'words[i - 1]' एनाग्राम हैं, जब तक कि ऐसे जोड़े नहीं बचते। संशोधित 'words' array लौटाता है।  \n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])  \n[\"ab\", \"cd\", \"e\"] // \"ba\" और \"dc\" को हटा दिया जाता है क्योंकि वे अपने पिछले तत्वों के एनाग्राम हैं।  \n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])  \n[\"abc\"] // एनाग्राम के क्रमिक हटाने से [\"abc\", \"bac\"], फिर [\"abc\"] प्राप्त होता है।  ",
      "hu": "Ismételten eltávolít egy elemet a 'words' listából az 'i' indexnél, ha a 'words[i]' és a 'words[i - 1]' anagrammák, amíg ilyen párok nem maradnak. Visszaadja a módosított 'words' tömböt.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // A \"ba\" és a \"dc\" eltávolításra kerül, mivel anagrammák az előző elemeikkel.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Az anagrammák sorozatos eltávolítása eredményezi a [\"abc\", \"bac\"], majd a [\"abc\"] listát."
    },
    "docstring_bertscore": {
      "sq": "0.9797742628207414",
      "hy": "0.9685351599706444",
      "bn": "0.9886750888252959",
      "bg": "0.9820855259344634",
      "zh": "0.9729403845612361",
      "fr": "0.9859522635620696",
      "de": "0.9736266525277116",
      "ha": "0.9455548166671941",
      "hi": "0.909099785575099",
      "hu": "0.9612013290420742"
    }
  },
  {
    "task_id": "Swift/12",
    "prompt": {
      "en": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n*/",
      "sq": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nGjen numrin e plotë 'target' që shfaqet më shpesh menjëherë pas 'key' të specifikuar në vargun 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Numri 2 shfaqet dy herë pas 1, më shpesh se çdo numër tjetër.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Numri 1 shfaqet një herë pas 1, që është më i shpeshti.\n*/",
      "hy": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nԳտնում է 'target' ամբողջ թիվը, որը ամենահաճախն է հայտնվում նշված 'key'-ից անմիջապես հետո 'nums' զանգվածում:\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Թիվ 2-ը հայտնվում է երկու անգամ 1-ից հետո, ավելի հաճախ, քան ցանկացած այլ թիվ:\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Թիվ 1-ը հայտնվում է մեկ անգամ 1-ից հետո, որը ամենահաճախն է:\n*/",
      "bn": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nনির্দিষ্ট 'key' এর পরে 'nums' অ্যারেতে যে পূর্ণসংখ্যা 'target' সবচেয়ে ঘন ঘন উপস্থিত হয় তা খুঁজে বের করে।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // সংখ্যা 2, 1 এর পরে দুবার উপস্থিত হয়, যা অন্য যেকোন সংখ্যার চেয়ে বেশি ঘন ঘন।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // সংখ্যা 1, 1 এর পরে একবার উপস্থিত হয়, যা সবচেয়ে ঘন ঘন।\n*/",
      "bg": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nНамира целочислената стойност 'target', която най-често се появява непосредствено след зададения 'key' в масива 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Числото 2 се появява два пъти след 1, по-често от всяко друго число.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Числото 1 се появява веднъж след 1, което е най-честото.\n*/",
      "zh": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\n找到在数组 'nums' 中指定 'key' 之后最频繁出现的整数 'target'。\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 数字 2 在 1 之后出现了两次，比其他任何数字都频繁。\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 数字 1 在 1 之后出现了一次，这是最频繁的。\n*/",
      "fr": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nTrouve l'entier 'target' qui apparaît le plus fréquemment immédiatement après le 'key' spécifié dans le tableau 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Le nombre 2 apparaît deux fois après 1, plus fréquemment que tout autre nombre.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Le nombre 1 apparaît une fois après 1, ce qui est le plus fréquent.\n*/",
      "de": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFindet die ganze Zahl 'target', die am häufigsten unmittelbar nach dem angegebenen 'key' im Array 'nums' erscheint.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Die Zahl 2 erscheint zweimal nach 1, häufiger als jede andere Zahl.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Die Zahl 1 erscheint einmal nach 1, was am häufigsten ist.\n*/",
      "ha": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nNemo lamba 'target' wanda yafi yawan bayyana nan take bayan takamaiman 'key' a cikin jerin 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Lamba 2 ta bayyana sau biyu bayan 1, fiye da kowace lamba.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Lamba 1 ta bayyana sau daya bayan 1, wanda shine mafi yawa.\n*/",
      "hi": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nऐसे पूर्णांक 'target' को खोजता है जो सरणी 'nums' में निर्दिष्ट 'key' के तुरंत बाद सबसे अधिक बार प्रकट होता है।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // संख्या 2, 1 के बाद दो बार प्रकट होती है, जो किसी अन्य संख्या की तुलना में अधिक बार है।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // संख्या 1, 1 के बाद एक बार प्रकट होती है, जो सबसे अधिक बार है।\n*/",
      "hu": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nMegkeresi azt az egész számot ('target'), amely a leggyakrabban jelenik meg közvetlenül a megadott 'key' után a 'nums' tömbben.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // A 2-es szám kétszer jelenik meg 1 után, gyakrabban, mint bármely más szám.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Az 1-es szám egyszer jelenik meg 1 után, ami a leggyakoribb.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9970400100618181",
      "hy": "0.9835577743186941",
      "bn": "0.9786230011322633",
      "bg": "0.9896036858566339",
      "zh": "0.9854580711740548",
      "fr": "0.9992898963878003",
      "de": "0.9992898963878003",
      "ha": "0.9597217313337454",
      "hi": "0.9905672418350342",
      "hu": "0.9845946249076961"
    },
    "canonical_solution": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}",
    "instruction": {
      "en": "Write a Swift function `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` to solve the following problem:\n\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n",
      "sq": "Shkruani një funksion Swift `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nGjen numrin 'target' që shfaqet më shpesh menjëherë pas 'key' të specifikuar në vargun 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Numri 2 shfaqet dy herë pas 1, më shpesh se çdo numër tjetër.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Numri 1 shfaqet një herë pas 1, që është më i shpeshti.",
      "hy": "Գրեք Swift ֆունկցիա `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nԳտնում է 'target' ամբողջ թիվը, որը ամենահաճախն է հայտնվում նշված 'key'-ից անմիջապես հետո 'nums' զանգվածում:\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Թիվ 2-ը հայտնվում է երկու անգամ 1-ից հետո, ավելի հաճախ, քան ցանկացած այլ թիվ:\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Թիվ 1-ը հայտնվում է մեկ անգամ 1-ից հետո, որը ամենահաճախն է:",
      "bn": "একটি Swift ফাংশন `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nনির্দিষ্ট 'key' এর পরে সরাসরি যে পূর্ণসংখ্যা 'target' সবচেয়ে ঘন ঘন উপস্থিত হয় তা খুঁজে বের করে 'nums' অ্যারেতে।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // সংখ্যা 2 দুইবার 1 এর পরে উপস্থিত হয়, যা অন্য যেকোনো সংখ্যার চেয়ে বেশি ঘন ঘন।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // সংখ্যা 1 একবার 1 এর পরে উপস্থিত হয়, যা সবচেয়ে ঘন ঘন।",
      "bg": "Напишете Swift функция `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` за да решите следния проблем:\n\nНамира целочислената стойност 'target', която най-често се появява веднага след зададената 'key' в масива 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Числото 2 се появява два пъти след 1, по-често от всяко друго число.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Числото 1 се появява веднъж след 1, което е най-често.",
      "zh": "编写一个 Swift 函数 `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` 来解决以下问题：\n\n查找在数组 'nums' 中指定 'key' 之后最频繁出现的整数 'target'。\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 数字 2 在 1 之后出现了两次，比其他任何数字都频繁。\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 数字 1 在 1 之后出现了一次，这是最频繁的。",
      "fr": "Écrire une fonction Swift `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` pour résoudre le problème suivant :\n\nTrouve l'entier 'target' qui apparaît le plus fréquemment immédiatement après le 'key' spécifié dans le tableau 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Le nombre 2 apparaît deux fois après 1, plus fréquemment que tout autre nombre.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Le nombre 1 apparaît une fois après 1, ce qui est le plus fréquent.",
      "de": "Schreiben Sie eine Swift-Funktion `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {`, um das folgende Problem zu lösen:\n\nFindet die ganze Zahl 'target', die am häufigsten unmittelbar nach dem angegebenen 'key' im Array 'nums' erscheint.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Die Zahl 2 erscheint zweimal nach 1, häufiger als jede andere Zahl.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Die Zahl 1 erscheint einmal nach 1, was am häufigsten ist.",
      "ha": "Rubuta aikin Swift `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` don warware matsalar mai zuwa:\n\nNemo adadin 'target' wanda yafi yawan bayyana nan take bayan 'key' da aka ayyana a cikin jerin 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Lambar 2 ta bayyana sau biyu bayan 1, fiye da kowace lamba.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Lambar 1 ta bayyana sau daya bayan 1, wanda shine mafi yawa.",
      "hi": "Swift फ़ंक्शन `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n\nऐसा पूर्णांक 'target' खोजें जो सरणी 'nums' में निर्दिष्ट 'key' के तुरंत बाद सबसे अधिक बार दिखाई देता है।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // संख्या 2, 1 के बाद दो बार दिखाई देती है, जो किसी अन्य संख्या से अधिक बार है।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // संख्या 1, 1 के बाद एक बार दिखाई देती है, जो सबसे अधिक बार है।",
      "hu": "Írj egy Swift függvényt `func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {` a következő probléma megoldására:\n\nMegkeresi azt az egész számot ('target'), amely a leggyakrabban jelenik meg közvetlenül a megadott 'key' után a 'nums' tömbben.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // A 2-es szám kétszer jelenik meg az 1-es után, gyakrabban, mint bármely más szám.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Az 1-es szám egyszer jelenik meg az 1-es után, ami a leggyakoribb."
    },
    "instruction_bertscore": {
      "sq": "0.9895274117903166",
      "hy": "0.9828448898811598",
      "bn": "0.9798016738133243",
      "bg": "0.9904860020091909",
      "zh": "0.9890425550302104",
      "fr": "0.9952716037794644",
      "de": "0.9901358166474264",
      "ha": "0.9758350251040576",
      "hi": "0.9717360885610217",
      "hu": "0.9856853043299587"
    },
    "level": "hard",
    "test": "func checkMostFrequentTargetAfterKey(_ mostFrequentTargetAfterKey: ([Int], Int) -> Int) {\nassert(mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1) == 2)\nassert(mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1) == 1)\nassert(mostFrequentTargetAfterKey([1, 2, 3, 1, 2, 3, 1, 2], 2) == 3)\nassert(mostFrequentTargetAfterKey([7, 7, 7, 8, 8, 9, 7, 9, 9], 7) == 7)\nassert(mostFrequentTargetAfterKey([1], 1) == 1)\nassert(mostFrequentTargetAfterKey([2, 2, 2, 2, 2, 3], 2) == 2)\n}\n\ncheckMostFrequentTargetAfterKey(mostFrequentTargetAfterKey)",
    "entry_point": "mostFrequentTargetAfterKey",
    "signature": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {",
    "docstring": {
      "en": "\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n",
      "sq": "Gjen numrin e plotë 'target' që shfaqet më shpesh menjëherë pas 'key' të specifikuar në vargun 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Numri 2 shfaqet dy herë pas 1, më shpesh se çdo numër tjetër.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Numri 1 shfaqet një herë pas 1, që është më i shpeshti.",
      "hy": "Գտնում է ամբողջ թիվ 'target'-ը, որը ամենահաճախն է հայտնվում նշված 'key'-ից անմիջապես հետո 'nums' զանգվածում:\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Թիվ 2-ը հայտնվում է երկու անգամ 1-ից հետո, ավելի հաճախ, քան որևէ այլ թիվ:\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Թիվ 1-ը հայտնվում է մեկ անգամ 1-ից հետո, որը ամենահաճախն է:",
      "bn": "Finds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\nনির্দিষ্ট 'key' এর পরে 'nums' অ্যারেতে যে পূর্ণসংখ্যা 'target' সবচেয়ে ঘন ঘন উপস্থিত হয় তা খুঁজে বের করে।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // সংখ্যা 2, 1 এর পরে দুবার উপস্থিত হয়, যা অন্য যেকোন সংখ্যার চেয়ে বেশি ঘন ঘন।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // সংখ্যা 1, 1 এর পরে একবার উপস্থিত হয়, যা সবচেয়ে ঘন ঘন।",
      "bg": "Намира целочисленото число 'target', което най-често се появява непосредствено след зададения 'key' в масива 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Числото 2 се появява два пъти след 1, по-често от всяко друго число.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Числото 1 се появява веднъж след 1, което е най-често.",
      "zh": "在数组 'nums' 中找到紧接在指定 'key' 之后最频繁出现的整数 'target'。\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 数字 2 在 1 之后出现了两次，比其他任何数字都频繁。\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 数字 1 在 1 之后出现了一次，这是最频繁的。",
      "fr": "Trouve l'entier 'target' qui apparaît le plus fréquemment immédiatement après le 'key' spécifié dans le tableau 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Le nombre 2 apparaît deux fois après 1, plus fréquemment que tout autre nombre.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Le nombre 1 apparaît une fois après 1, ce qui est le plus fréquent.",
      "de": "Findet die ganze Zahl 'target', die am häufigsten unmittelbar nach dem angegebenen 'key' im Array 'nums' erscheint.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Die Zahl 2 erscheint zweimal nach 1, häufiger als jede andere Zahl.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Die Zahl 1 erscheint einmal nach 1, was am häufigsten ist.",
      "ha": "Nemo adadin cikakken lamba 'target' wanda yafi yawan bayyana nan take bayan takamaiman 'key' a cikin jerin 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Lambar 2 ta bayyana sau biyu bayan 1, fiye da kowace lamba.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Lambar 1 ta bayyana sau daya bayan 1, wanda shine mafi yawa.",
      "hi": "Finds the integer 'target' जो सबसे अधिक बार निर्दिष्ट 'key' के तुरंत बाद array 'nums' में दिखाई देता है।\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // संख्या 2, 1 के बाद दो बार दिखाई देती है, जो किसी अन्य संख्या की तुलना में अधिक बार है।\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // संख्या 1, 1 के बाद एक बार दिखाई देती है, जो सबसे अधिक बार है।",
      "hu": "Megkeresi azt az egész számot ('target'), amely a leggyakrabban jelenik meg közvetlenül a megadott 'key' után a 'nums' tömbben.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // A 2-es szám kétszer jelenik meg az 1-es után, gyakrabban, mint bármely más szám.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Az 1-es szám egyszer jelenik meg az 1-es után, ami a leggyakoribb."
    },
    "docstring_bertscore": {
      "sq": "0.9920345244597389",
      "hy": "0.9842944944019524",
      "bn": "0.9183031256499694",
      "bg": "0.9866186684904417",
      "zh": "0.9920345244597389",
      "fr": "0.9920345244597389",
      "de": "0.9936988484224303",
      "ha": "0.9686757902804171",
      "hi": "0.989427500708656",
      "hu": "0.9802458113453183"
    }
  },
  {
    "task_id": "Swift/13",
    "prompt": {
      "en": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n*/",
      "sq": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nKthen një listë të renditur të të gjithë indekseve fqinjë të afërt K në vargun 'nums'.\nNjë indeks fqinj i afërt K i plotëson të paktën një indeks j të tillë që |i - j| <= k dhe nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Çdo indeks është brenda 2 hapave nga një '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indekset 1, 2, 3 janë brenda 1 hapi nga një '3'.\n*/",
      "hy": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nՎերադարձնում է 'nums' զանգվածում K մոտ հարևան ինդեքսների դասավորված ցուցակը։\nK մոտ հարևան ինդեքս i-ն բավարարում է առնվազն մեկ ինդեքս j, այնպես որ |i - j| <= k և nums[j] == key։\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Յուրաքանչյուր ինդեքս գտնվում է '2'-ից 2 քայլ հեռավորության վրա։\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Ինդեքսները 1, 2, 3 գտնվում են '3'-ից 1 քայլ հեռավորության վրա։\n*/",
      "bn": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nঅ্যারে 'nums'-এর মধ্যে সমস্ত K কাছাকাছি প্রতিবেশী সূচকের একটি সাজানো তালিকা প্রদান করে।\nএকটি K কাছাকাছি প্রতিবেশী সূচক i কমপক্ষে একটি সূচক j কে সন্তুষ্ট করে যাতে |i - j| <= k এবং nums[j] == key হয়।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // প্রতিটি সূচক একটি '2'-এর 2 ধাপের মধ্যে রয়েছে।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // সূচক 1, 2, 3 একটি '3'-এর 1 ধাপের মধ্যে রয়েছে।\n*/",
      "bg": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nВръща сортиран списък на всички индекси на K близки съседи в масива 'nums'.\nИндексът на K близък съсед i удовлетворява поне един индекс j, такъв че |i - j| <= k и nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Всеки индекс е в рамките на 2 стъпки от '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Индексите 1, 2, 3 са в рамките на 1 стъпка от '3'.\n*/",
      "zh": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\n返回数组 'nums' 中所有 K 近邻索引的排序列表。\n一个 K 近邻索引 i 满足至少一个索引 j 使得 |i - j| <= k 且 nums[j] == key。\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // 每个索引都在 '2' 的 2 步之内。\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // 索引 1, 2, 3 都在 '3' 的 1 步之内。\n*/",
      "fr": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nRenvoie une liste triée de tous les indices voisins proches K dans le tableau 'nums'.\nUn indice voisin proche K i satisfait au moins un indice j tel que |i - j| <= k et nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Chaque indice est à 2 pas d'un '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Les indices 1, 2, 3 sont à 1 pas d'un '3'.\n*/",
      "de": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nGibt eine sortierte Liste aller K nahen Nachbarindizes im Array 'nums' zurück.\nEin K naher Nachbarindex i erfüllt mindestens einen Index j, sodass |i - j| <= k und nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Jeder Index ist innerhalb von 2 Schritten von einer '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indizes 1, 2, 3 sind innerhalb von 1 Schritt von einer '3'.\n*/",
      "ha": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nYana dawowa da jerin dukkanin masu makwabtaka K kusa da aka tsara a cikin jerin 'nums'.\nWani maƙwabcin K kusa da index i yana gamsar da aƙalla ɗaya index j wanda |i - j| <= k kuma nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kowace alamar tana cikin matakai 2 na '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Alamomi 1, 2, 3 suna cikin mataki 1 na '3'.\n*/",
      "hi": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nसॉर्ट की गई सूची लौटाता है जिसमें 'nums' सरणी में सभी K निकटतम पड़ोसी सूचकांक होते हैं।\nएक K निकटतम पड़ोसी सूचकांक i कम से कम एक सूचकांक j को संतुष्ट करता है ताकि |i - j| <= k और nums[j] == key हो।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // प्रत्येक सूचकांक '2' के 2 कदम के भीतर है।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // सूचकांक 1, 2, 3 '3' के 1 कदम के भीतर हैं।\n*/",
      "hu": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nVisszaadja az összes K közeli szomszéd indexének rendezett listáját a 'nums' tömbben.\nEgy K közeli szomszéd index i kielégít legalább egy j indexet, amelyre |i - j| <= k és nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Minden index legfeljebb 2 lépésre van egy '2'-től.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Az 1, 2, 3 indexek legfeljebb 1 lépésre vannak egy '3'-tól.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9875212449418642",
      "hy": "0.9849622897429917",
      "bn": "0.9966671808366157",
      "bg": "0.9779844044572361",
      "zh": "0.9852630161398785",
      "fr": "0.9856247220637431",
      "de": "0.9855375233264687",
      "ha": "0.9598534232763715",
      "hi": "0.9835218222197267",
      "hu": "0.9629965504258676"
    },
    "canonical_solution": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}",
    "instruction": {
      "en": "Write a Swift function `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` to solve the following problem:\n\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n",
      "sq": "Shkruani një funksion Swift `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` për të zgjidhur problemin në vijim:\n\nKthen një listë të renditur të të gjithë indekseve fqinjë K të afërt në vargun 'nums'.\nNjë indeks fqinj K i afërt i plotëson të paktën një indeks j të tillë që |i - j| <= k dhe nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Çdo indeks është brenda 2 hapave nga një '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indekset 1, 2, 3 janë brenda 1 hapi nga një '3'.",
      "hy": "Գրեք Swift ֆունկցիա `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` հետևյալ խնդիրը լուծելու համար:\n\nՎերադարձնում է 'nums' զանգվածում բոլոր K մոտ հարևան ինդեքսների դասավորված ցուցակը:\nK մոտ հարևան ինդեքս i-ն բավարարում է առնվազն մեկ ինդեքս j, այնպես որ |i - j| <= k և nums[j] == key:\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Յուրաքանչյուր ինդեքս գտնվում է '2'-ից 2 քայլ հեռավորության վրա:\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Ինդեքսները 1, 2, 3 գտնվում են '3'-ից 1 քայլ հեռավորության վրա:",
      "bn": "একটি Swift ফাংশন `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএটি 'nums' অ্যারেতে সমস্ত K নিকটবর্তী প্রতিবেশী সূচকের একটি সাজানো তালিকা ফেরত দেয়।\nএকটি K নিকটবর্তী প্রতিবেশী সূচক i কমপক্ষে একটি সূচক j কে সন্তুষ্ট করে যাতে |i - j| <= k এবং nums[j] == key হয়।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // প্রতিটি সূচক একটি '2' এর 2 ধাপের মধ্যে রয়েছে।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // সূচক 1, 2, 3 একটি '3' এর 1 ধাপের মধ্যে রয়েছে।",
      "bg": "Напишете Swift функция `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` за решаване на следния проблем:\n\nВръща сортиран списък на всички K близки съседни индекси в масива 'nums'.\nK близък съседен индекс i удовлетворява поне един индекс j, такъв че |i - j| <= k и nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Всеки индекс е в рамките на 2 стъпки от '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Индекси 1, 2, 3 са в рамките на 1 стъпка от '3'.",
      "zh": "编写一个 Swift 函数 `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` 来解决以下问题：\n\n返回数组 'nums' 中所有 K 个近邻索引的排序列表。\n一个 K 近邻索引 i 满足至少一个索引 j 使得 |i - j| <= k 且 nums[j] == key。\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // 每个索引都在 '2' 的 2 步之内。\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // 索引 1, 2, 3 都在 '3' 的 1 步之内。",
      "fr": "Écrire une fonction Swift `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` pour résoudre le problème suivant :\n\nRenvoie une liste triée de tous les indices des voisins proches K dans le tableau 'nums'.\nUn indice voisin proche K i satisfait au moins un indice j tel que |i - j| <= k et nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Chaque indice est à 2 pas d'un '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Les indices 1, 2, 3 sont à 1 pas d'un '3'.",
      "de": "Schreiben Sie eine Swift-Funktion `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {`, um das folgende Problem zu lösen:\n\nGibt eine sortierte Liste aller K nahen Nachbarindizes im Array 'nums' zurück.\nEin K naher Nachbarindex i erfüllt mindestens einen Index j, so dass |i - j| <= k und nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Jeder Index ist innerhalb von 2 Schritten von einer '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indizes 1, 2, 3 sind innerhalb von 1 Schritt von einer '3'.",
      "ha": "Rubuta aikin Swift `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` don warware matsalar mai zuwa:\n\nDawo da jerin da aka tsara na duk K makwabta kusa da masu nuna adireshi a cikin jerin 'nums'.\nK makwabcin kusa da mai nuna adireshi i yana gamsar da aƙalla mai nuna adireshi j ɗaya wanda |i - j| <= k kuma nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kowane mai nuna adireshi yana cikin matakai 2 na '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Masu nuna adireshi 1, 2, 3 suna cikin mataki 1 na '3'.",
      "hi": "Swift फ़ंक्शन `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nसभी K निकटतम पड़ोसी सूचकांकों की एक क्रमबद्ध सूची लौटाता है जो 'nums' array में हैं।\nएक K निकटतम पड़ोसी सूचकांक i कम से कम एक सूचकांक j को संतुष्ट करता है ताकि |i - j| <= k और nums[j] == key हो।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // प्रत्येक सूचकांक '2' के 2 कदम के भीतर है।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // सूचकांक 1, 2, 3 '3' के 1 कदम के भीतर हैं।",
      "hu": "Írj egy Swift függvényt `func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {` a következő probléma megoldására:\n\nVisszaad egy rendezett listát az összes K közeli szomszéd indexről a 'nums' tömbben.\nEgy K közeli szomszéd index i kielégíti legalább egy j indexet úgy, hogy |i - j| <= k és nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Minden index legfeljebb 2 lépésre van egy '2'-től.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Az 1, 2, 3 indexek legfeljebb 1 lépésre vannak egy '3'-tól."
    },
    "instruction_bertscore": {
      "sq": "0.9854942219034032",
      "hy": "0.9856054549167826",
      "bn": "0.9854264889434703",
      "bg": "0.991124201423456",
      "zh": "0.9792296183159438",
      "fr": "0.9917880241568746",
      "de": "0.998599258552942",
      "ha": "0.9648279225390093",
      "hi": "0.9588495453306212",
      "hu": "0.966688096057401"
    },
    "level": "middle",
    "test": "func checkKCloseNeighbors(_ kCloseNeighbors: ([Int], Int, Int) -> [Int]) {\nassert(kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2) == [0, 1, 2, 3, 4, 5, 6])\nassert(kCloseNeighbors([1, 2, 3, 4, 5], 3, 1) == [1, 2, 3])\nassert(kCloseNeighbors([1, 1, 1, 1, 1], 1, 0) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([5, 4, 3, 2, 1], 3, 2) == [0,1, 2, 3, 4])\nassert(kCloseNeighbors([7, 7, 7, 7, 7], 7, 3) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([], 1, 1) == [])\nassert(kCloseNeighbors([1, 2, 3, 4, 5, 6], 4, 1) == [2, 3, 4])\n}\n\ncheckKCloseNeighbors(kCloseNeighbors)",
    "entry_point": "kCloseNeighbors",
    "signature": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {",
    "docstring": {
      "en": "\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n",
      "sq": "Kthen një listë të renditur të të gjithë indekseve fqinjë K të afërt në vargun 'nums'. Një indeks fqinj K i afërt i plotëson të paktën një indeks j të tillë që |i - j| <= k dhe nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Çdo indeks është brenda 2 hapave nga një '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indekset 1, 2, 3 janë brenda 1 hapi nga një '3'.",
      "hy": "Վերադարձնում է սորտավորված ցուցակ բոլոր K մոտ հարևան ինդեքսների 'nums' զանգվածում:\nK մոտ հարևան ինդեքս i-ն բավարարում է առնվազն մեկ ինդեքս j, այնպես որ |i - j| <= k և nums[j] == key:\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Յուրաքանչյուր ինդեքս գտնվում է '2'-ից 2 քայլ հեռավորության վրա:\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Ինդեքսները 1, 2, 3 գտնվում են '3'-ից 1 քայլ հեռավորության վրա:",
      "bn": "Returns a sorted list of all K close neighbor indices in the array 'nums'.  \nএকটি K নিকটবর্তী প্রতিবেশী সূচক i কমপক্ষে একটি সূচক j কে সন্তুষ্ট করে যাতে |i - j| <= k এবং nums[j] == key হয়।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // প্রতিটি সূচক একটি '2' এর 2 ধাপের মধ্যে রয়েছে।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // সূচক 1, 2, 3 একটি '3' এর 1 ধাপের মধ্যে রয়েছে।",
      "bg": "Връща сортиран списък от всички индекси на K близки съседи в масива 'nums'. \nИндекс i на K близък съсед удовлетворява поне един индекс j, такъв че |i - j| <= k и nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Всеки индекс е в рамките на 2 стъпки от '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Индексите 1, 2, 3 са в рамките на 1 стъпка от '3'.",
      "zh": "返回数组 'nums' 中所有 K 近邻索引的排序列表。\n一个 K 近邻索引 i 满足至少有一个索引 j 使得 |i - j| <= k 且 nums[j] == key。\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // 每个索引都在 '2' 的 2 步范围内。\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // 索引 1, 2, 3 在 '3' 的 1 步范围内。",
      "fr": "Renvoie une liste triée de tous les indices des K voisins proches dans le tableau 'nums'.\nUn indice i de K voisins proches satisfait au moins un indice j tel que |i - j| <= k et nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Chaque indice est à 2 pas d'un '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Les indices 1, 2, 3 sont à 1 pas d'un '3'.",
      "de": "Gibt eine sortierte Liste aller K nahen Nachbarindizes im Array 'nums' zurück.\nEin K naher Nachbarindex i erfüllt mindestens einen Index j, so dass |i - j| <= k und nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Jeder Index ist innerhalb von 2 Schritten von einer '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indizes 1, 2, 3 sind innerhalb von 1 Schritt von einer '3'.",
      "ha": "Yana mayar da jerin da aka tsara na dukkan alamun makwabta K kusa a cikin jerin 'nums'.\nAlamar makwabta K kusa i tana gamsar da aƙalla alamar j ɗaya irin wannan cewa |i - j| <= k kuma nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kowace alama tana cikin matakai 2 na '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Alamomi 1, 2, 3 suna cikin mataki 1 na '3'.",
      "hi": "सॉर्ट की गई सूची लौटाता है जिसमें 'nums' में सभी K निकटतम पड़ोसी सूचकांक होते हैं। एक K निकटतम पड़ोसी सूचकांक i कम से कम एक सूचकांक j को संतुष्ट करता है जिससे |i - j| <= k और nums[j] == key होता है।\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // प्रत्येक सूचकांक '2' से 2 कदम के भीतर है।\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // सूचकांक 1, 2, 3 '3' से 1 कदम के भीतर हैं।",
      "hu": "Visszaad egy rendezett listát az összes K közeli szomszéd indexről a 'nums' tömbben.\nEgy K közeli szomszéd index i kielégít legalább egy j indexet, amelyre |i - j| <= k és nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Minden index legfeljebb 2 lépésre van egy '2'-től.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Az 1, 2, 3 indexek legfeljebb 1 lépésre vannak egy '3'-tól."
    },
    "docstring_bertscore": {
      "sq": "0.9862434557006667",
      "hy": "0.9765576424302626",
      "bn": "1",
      "bg": "0.9802332976313131",
      "zh": "0.9535490936127052",
      "fr": "0.9556833770569251",
      "de": "0.9980524291139529",
      "ha": "0.9476052780906172",
      "hi": "0.9715402390053213",
      "hu": "0.9595320393198571"
    }
  },
  {
    "task_id": "Swift/14",
    "prompt": {
      "en": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n*/",
      "sq": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nPërcakton nëse vargu 'nums' mund të ndahet në çifte të tilla që secili çift përbëhet nga elemente të barabarta.\nÇdo element duhet të përkasë saktësisht në një çift.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Mund të ndahet në çifte (1,1) dhe (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nuk mund të formohen çifte me elemente të barabarta.\n*/",
      "hy": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nՍահմանում է՝ արդյոք 'nums' զանգվածը կարելի է բաժանել զույգերի, այնպես, որ յուրաքանչյուր զույգ բաղկացած լինի հավասար տարրերից:\nՅուրաքանչյուր տարր պետք է պատկանի հենց մեկ զույգի:\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Կարելի է բաժանել զույգերի (1,1) և (2,2):\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Չի կարող ձևավորել զույգեր հավասար տարրերով:\n*/",
      "bn": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nনির্ধারণ করে যে অ্যারে 'nums' কে এমনভাবে জোড়ায় ভাগ করা যায় কিনা যাতে প্রতিটি জোড়া সমান উপাদান নিয়ে গঠিত হয়।\nপ্রতিটি উপাদান অবশ্যই ঠিক একটি জোড়ার অন্তর্গত হতে হবে।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // জোড়ায় ভাগ করা যায় (1,1) এবং (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // সমান উপাদান সহ জোড়া তৈরি করা সম্ভব নয়।\n*/",
      "bg": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nОпределя дали масивът 'nums' може да бъде разделен на двойки, така че всяка двойка да се състои от равни елементи.\nВсеки елемент трябва да принадлежи точно на една двойка.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Може да бъде разделен на двойки (1,1) и (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Не може да се образуват двойки с равни елементи.\n*/",
      "zh": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\n确定数组 'nums' 是否可以分成若干对，使得每对由相等的元素组成。\n每个元素必须恰好属于一个对。\n>>> canFormPairs([1, 2, 2, 1])\nTrue // 可以分成对 (1,1) 和 (2,2)。\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // 无法形成具有相等元素的对。\n*/",
      "fr": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDétermine si le tableau 'nums' peut être divisé en paires de sorte que chaque paire soit constituée d'éléments égaux.\nChaque élément doit appartenir à exactement une paire.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Peut être divisé en paires (1,1) et (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Ne peut pas former de paires avec des éléments égaux.\n*/",
      "de": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nBestimmt, ob das Array 'nums' in Paare aufgeteilt werden kann, sodass jedes Paar aus gleichen Elementen besteht.\nJedes Element muss genau zu einem Paar gehören.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Kann in Paare (1,1) und (2,2) aufgeteilt werden.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Kann keine Paare mit gleichen Elementen bilden.\n*/",
      "ha": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nYana tantance ko za a iya raba jerin 'nums' zuwa ma'aurata inda kowace ma'aurata ta ƙunshi abubuwa masu daidaitawa.\nDole ne kowanne abu ya kasance cikin daidai ma'aurata guda.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Za a iya raba shi zuwa ma'aurata (1,1) da (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Ba za a iya samar da ma'aurata da abubuwa masu daidaitawa ba.\n*/",
      "hi": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nनिर्धारित करता है कि क्या 'nums' सरणी को जोड़ों में विभाजित किया जा सकता है ताकि प्रत्येक जोड़ा समान तत्वों से बना हो।\nप्रत्येक तत्व को ठीक एक जोड़े का हिस्सा होना चाहिए।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // जोड़ों में विभाजित किया जा सकता है (1,1) और (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // समान तत्वों के साथ जोड़े नहीं बना सकते।\n*/",
      "hu": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nMeghatározza, hogy a 'nums' tömb felosztható-e párokra úgy, hogy minden pár egyenlő elemekből álljon.\nMinden elemnek pontosan egy párhoz kell tartoznia.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Felosztható párokra (1,1) és (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nem lehet párokat alkotni egyenlő elemekkel.\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9977524972385903",
      "bn": "0.9915546334591586",
      "bg": "1",
      "zh": "0.9816141760402677",
      "fr": "0.9992130264303398",
      "de": "0.9931631422847792",
      "ha": "0.9728376926542411",
      "hi": "0.9828528350964012",
      "hu": "0.9939811021938808"
    },
    "canonical_solution": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}",
    "instruction": {
      "en": "Write a Swift function `func canFormPairs(_ nums: [Int]) -> Bool {` to solve the following problem:\n\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n",
      "sq": "Shkruani një funksion Swift `func canFormPairs(_ nums: [Int]) -> Bool {` për të zgjidhur problemin e mëposhtëm:\n\nPërcakton nëse vargu 'nums' mund të ndahet në çifte të tilla që secili çift përbëhet nga elemente të barabarta.\nÇdo element duhet të përkasë saktësisht në një çift.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Mund të ndahet në çifte (1,1) dhe (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nuk mund të formojë çifte me elemente të barabarta.",
      "hy": "Swift ֆունկցիա գրեք `func canFormPairs(_ nums: [Int]) -> Bool {` հետևյալ խնդիրը լուծելու համար:\n\nՈրոշում է՝ արդյոք 'nums' զանգվածը կարելի է բաժանել զույգերի այնպես, որ յուրաքանչյուր զույգ կազմված լինի հավասար տարրերից:\nՅուրաքանչյուր տարր պետք է պատկանի ճիշտ մեկ զույգի:\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Կարելի է բաժանել զույգերի (1,1) և (2,2):\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Չի կարող ձևավորել զույգեր հավասար տարրերով.",
      "bn": "একটি Swift ফাংশন `func canFormPairs(_ nums: [Int]) -> Bool {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nনির্ধারণ করে যে অ্যারে 'nums' কে এমনভাবে জোড়ায় বিভক্ত করা যায় কিনা যাতে প্রতিটি জোড়া সমান উপাদান নিয়ে গঠিত হয়।\nপ্রতিটি উপাদান অবশ্যই ঠিক একটি জোড়ার অন্তর্ভুক্ত হতে হবে।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // জোড়ায় বিভক্ত করা যায় (1,1) এবং (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // সমান উপাদান সহ জোড়া তৈরি করা যায় না।",
      "bg": "Напишете Swift функция `func canFormPairs(_ nums: [Int]) -> Bool {` за решаване на следния проблем:\n\nОпределя дали масивът 'nums' може да бъде разделен на двойки, така че всяка двойка да се състои от равни елементи.\nВсеки елемент трябва да принадлежи точно на една двойка.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Може да бъде разделен на двойки (1,1) и (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Не може да се образуват двойки с равни елементи.",
      "zh": "编写一个 Swift 函数 `func canFormPairs(_ nums: [Int]) -> Bool {` 来解决以下问题：\n\n确定数组 'nums' 是否可以被分成若干对，使得每对由相等的元素组成。  \n每个元素必须恰好属于一个对。  \n>>> canFormPairs([1, 2, 2, 1])  \nTrue // 可以分成对 (1,1) 和 (2,2)。  \n>>> canFormPairs([1, 2, 3, 4, 5, 6])  \nFalse // 无法形成具有相等元素的对。  ",
      "fr": "Écrire une fonction Swift `func canFormPairs(_ nums: [Int]) -> Bool {` pour résoudre le problème suivant :\n\nDétermine si le tableau 'nums' peut être divisé en paires telles que chaque paire soit constituée d'éléments égaux.\nChaque élément doit appartenir à exactement une paire.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Peut être divisé en paires (1,1) et (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Ne peut pas former de paires avec des éléments égaux.",
      "de": "Schreiben Sie eine Swift-Funktion `func canFormPairs(_ nums: [Int]) -> Bool {`, um das folgende Problem zu lösen:\n\nBestimmt, ob das Array 'nums' in Paare unterteilt werden kann, sodass jedes Paar aus gleichen Elementen besteht.\nJedes Element muss genau zu einem Paar gehören.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Kann in Paare (1,1) und (2,2) unterteilt werden.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Kann keine Paare mit gleichen Elementen bilden.",
      "ha": "Rubuta aikin Swift `func canFormPairs(_ nums: [Int]) -> Bool {` don warware matsalar mai zuwa:\n\nYana tantance ko za a iya raba jerin 'nums' zuwa ma'aurata inda kowace ma'aurata ta ƙunshi abubuwa masu daidaituwa.\nDole ne kowanne abu ya kasance a cikin daidai ma'aurata ɗaya.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Za a iya raba shi zuwa ma'aurata (1,1) da (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Ba za a iya ƙirƙirar ma'aurata tare da abubuwa masu daidaituwa ba.",
      "hi": "Swift फ़ंक्शन `func canFormPairs(_ nums: [Int]) -> Bool {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nनिर्धारित करता है कि क्या 'nums' array को जोड़ों में विभाजित किया जा सकता है ताकि प्रत्येक जोड़ी समान तत्वों से बनी हो।\nप्रत्येक तत्व को ठीक एक जोड़ी में शामिल होना चाहिए।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // जोड़ों में विभाजित किया जा सकता है (1,1) और (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // समान तत्वों के साथ जोड़े नहीं बना सकते।",
      "hu": "Írj egy Swift függvényt `func canFormPairs(_ nums: [Int]) -> Bool {` a következő probléma megoldására:\n\nMeghatározza, hogy a 'nums' tömb felosztható-e párokra úgy, hogy minden pár egyenlő elemekből álljon.\nMinden elemnek pontosan egy párhoz kell tartoznia.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Felosztható párokra (1,1) és (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nem lehet azonos elemekből álló párokat alkotni."
    },
    "instruction_bertscore": {
      "sq": "0.9848649608562846",
      "hy": "0.9819371490398304",
      "bn": "0.9854336396371876",
      "bg": "0.9924297989179983",
      "zh": "0.9911742562794769",
      "fr": "0.9915039827119947",
      "de": "0.9915039827119947",
      "ha": "0.9483684160145532",
      "hi": "0.9610114383978049",
      "hu": "0.9821379643550566"
    },
    "level": "easy",
    "test": "func checkCanFormPairs(_ canFormPairs: ([Int]) -> Bool) {\nassert(canFormPairs([1, 2, 2, 1]) == true)\nassert(canFormPairs([1, 2, 3, 4, 5, 6]) == false)\nassert(canFormPairs([3, 3, 3, 3, 3, 3]) == true)\nassert(canFormPairs([0, 0]) == true)\nassert(canFormPairs([1, 1, 2, 2, 2, 2, 3, 3]) == true)\nassert(canFormPairs([1, 2, 3, 4, 4, 3, 2, 1, 5]) == false)\nassert(canFormPairs([]) == true)\n}\n\ncheckCanFormPairs(canFormPairs)",
    "entry_point": "canFormPairs",
    "signature": "func canFormPairs(_ nums: [Int]) -> Bool {",
    "docstring": {
      "en": "\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n",
      "sq": "Përcakton nëse array 'nums' mund të ndahet në çifte të tilla që secili çift përbëhet nga elemente të barabarta. \nÇdo element duhet të përkasë saktësisht në një çift.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Mund të ndahet në çifte (1,1) dhe (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nuk mund të formohen çifte me elemente të barabarta.",
      "hy": "Սահմանում է՝ արդյոք 'nums' զանգվածը կարող է բաժանվել զույգերի, այնպես, որ յուրաքանչյուր զույգ բաղկացած լինի հավասար տարրերից:\nՅուրաքանչյուր տարր պետք է պատկանի միայն մեկ զույգի:\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Կարող է բաժանվել զույգերի (1,1) և (2,2):\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Չի կարող կազմել զույգեր հավասար տարրերով:",
      "bn": "নির্ধারণ করে যে অ্যারে 'nums' কে এমন জোড়ায় ভাগ করা যায় কিনা যেখানে প্রতিটি জোড়া সমান উপাদান নিয়ে গঠিত।\nপ্রতিটি উপাদানকে অবশ্যই ঠিক একটি জোড়ার অন্তর্ভুক্ত হতে হবে।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // জোড়ায় ভাগ করা যায় (1,1) এবং (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // সমান উপাদান সহ জোড়া তৈরি করা সম্ভব নয়।",
      "bg": "Определя дали масивът 'nums' може да бъде разделен на двойки, така че всяка двойка да се състои от равни елементи. Всеки елемент трябва да принадлежи точно на една двойка.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Може да бъде разделен на двойки (1,1) и (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Не може да се образуват двойки с равни елементи.",
      "zh": "确定数组 'nums' 是否可以分成对，使得每对由相等的元素组成。  \n每个元素必须恰好属于一个对。  \n>>> canFormPairs([1, 2, 2, 1])  \nTrue // 可以分成对 (1,1) 和 (2,2)。  \n>>> canFormPairs([1, 2, 3, 4, 5, 6])  \nFalse // 无法形成具有相等元素的对。  ",
      "fr": "Détermine si le tableau 'nums' peut être divisé en paires de sorte que chaque paire soit constituée d'éléments égaux.  \nChaque élément doit appartenir à exactement une paire.  \n>>> canFormPairs([1, 2, 2, 1])  \nTrue // Peut être divisé en paires (1,1) et (2,2).  \n>>> canFormPairs([1, 2, 3, 4, 5, 6])  \nFalse // Ne peut pas former de paires avec des éléments égaux.  ",
      "de": "Bestimmt, ob das Array 'nums' in Paare unterteilt werden kann, sodass jedes Paar aus gleichen Elementen besteht. Jedes Element muss genau zu einem Paar gehören.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Kann in Paare (1,1) und (2,2) unterteilt werden.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Kann keine Paare mit gleichen Elementen bilden.",
      "ha": "Yana tantance ko za a iya raba jerin 'nums' zuwa ma'aurata inda kowanne ma'aurata ya ƙunshi abubuwa masu daidaituwa.\nDole ne kowane abu ya kasance cikin daidai ma'aurata ɗaya.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Ana iya raba shi zuwa ma'aurata (1,1) da (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Ba za a iya ƙirƙirar ma'aurata tare da abubuwa masu daidaituwa ba.",
      "hi": "यह निर्धारित करता है कि 'nums' नामक array को इस तरह से जोड़ों में विभाजित किया जा सकता है कि प्रत्येक जोड़ा समान तत्वों से बना हो। प्रत्येक तत्व को ठीक एक जोड़े का हिस्सा होना चाहिए।\n>>> canFormPairs([1, 2, 2, 1])\nTrue // इसे जोड़ों में विभाजित किया जा सकता है (1,1) और (2,2)।\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // समान तत्वों के साथ जोड़े नहीं बना सकते।",
      "hu": "Meghatározza, hogy a 'nums' tömb felosztható-e párokra úgy, hogy minden pár egyenlő elemekből álljon.\nMinden elemnek pontosan egy párhoz kell tartoznia.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Felosztható párokra (1,1) és (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Nem lehet egyenlő elemekből álló párokat alkotni."
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9957006454024998",
      "bn": "0.9673783366314972",
      "bg": "0.9988106012783631",
      "zh": "0.9893373225156662",
      "fr": "0.9880867456366705",
      "de": "0.9914058593037635",
      "ha": "0.9535101620580223",
      "hi": "0.9622232823524988",
      "hu": "0.9881097867608706"
    }
  },
  {
    "task_id": "Swift/15",
    "prompt": {
      "en": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n*/",
      "sq": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nKthen dy lista: një me numra të plotë unikë në 'nums1' që nuk janë në 'nums2', dhe një tjetër me numra të plotë unikë në 'nums2' që nuk janë në 'nums1'.\nNumrat e plotë në secilën listë kthehen në rend rritës.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 është unik për nums1, 4 është unik për nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 janë unikë për nums1; 4, 5 janë unikë për nums2.\n*/",
      "hy": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nՎերադարձնում է երկու ցուցակներ՝ մեկը 'nums1'-ում եզակի ամբողջ թվերով, որոնք չկան 'nums2'-ում, և մյուսը՝ 'nums2'-ում եզակի ամբողջ թվերով, որոնք չկան 'nums1'-ում:\nԱմբողջ թվերը յուրաքանչյուր ցուցակում վերադարձվում են աճման կարգով:\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1-ը եզակի է nums1-ում, 4-ը եզակի է nums2-ում:\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2-ը եզակի են nums1-ում; 4, 5-ը եզակի են nums2-ում:\n*/",
      "bn": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nদুটি তালিকা প্রদান করে: একটি 'nums1' এ অনন্য পূর্ণসংখ্যাগুলি যা 'nums2' তে নেই, এবং আরেকটি 'nums2' এ অনন্য পূর্ণসংখ্যাগুলি যা 'nums1' তে নেই।\nপ্রত্যেক তালিকায় পূর্ণসংখ্যাগুলি ঊর্ধ্বক্রমে ফেরত দেওয়া হয়।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1 এর জন্য অনন্য, 4 nums2 এর জন্য অনন্য।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1 এর জন্য অনন্য; 4, 5 nums2 এর জন্য অনন্য।\n*/",
      "bg": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nВръща два списъка: един с уникални цели числа в 'nums1', които не са в 'nums2', и друг с уникални цели числа в 'nums2', които не са в 'nums1'.\nЦелите числа във всеки списък се връщат в нарастващ ред.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 е уникално за nums1, 4 е уникално за nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 са уникални за nums1; 4, 5 са уникални за nums2.\n*/",
      "zh": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\n返回两个列表：一个包含在 'nums1' 中但不在 'nums2' 中的唯一整数，另一个包含在 'nums2' 中但不在 'nums1' 中的唯一整数。\n每个列表中的整数按升序返回。\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 是 nums1 独有的，4 是 nums2 独有的。\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 是 nums1 独有的；4, 5 是 nums2 独有的。\n*/",
      "fr": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nRenvoie deux listes : une avec les entiers uniques dans 'nums1' qui ne sont pas dans 'nums2', et une autre avec les entiers uniques dans 'nums2' qui ne sont pas dans 'nums1'.\nLes entiers dans chaque liste sont renvoyés par ordre croissant.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 est unique à nums1, 4 est unique à nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sont uniques à nums1 ; 4, 5 sont uniques à nums2.\n*/",
      "de": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nGibt zwei Listen zurück: eine mit eindeutigen ganzen Zahlen in 'nums1', die nicht in 'nums2' sind, und eine andere mit eindeutigen ganzen Zahlen in 'nums2', die nicht in 'nums1' sind.\nDie ganzen Zahlen in jeder Liste werden in aufsteigender Reihenfolge zurückgegeben.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ist einzigartig in nums1, 4 ist einzigartig in nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sind einzigartig in nums1; 4, 5 sind einzigartig in nums2.\n*/",
      "ha": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nYana mayar da jerin guda biyu: ɗaya tare da lambobin da ba su maimaita kansu a 'nums1' waɗanda ba su cikin 'nums2', da wani tare da lambobin da ba su maimaita kansu a 'nums2' waɗanda ba su cikin 'nums1'.\nAna mayar da lambobin a cikin kowanne jeri a cikin tsari mai hauhawa.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 yana da musamman ga nums1, 4 yana da musamman ga nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 suna da musamman ga nums1; 4, 5 suna da musamman ga nums2.\n*/",
      "hi": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nदो सूचियाँ लौटाता है: एक 'nums1' में अद्वितीय पूर्णांकों के साथ जो 'nums2' में नहीं हैं, और दूसरी 'nums2' में अद्वितीय पूर्णांकों के साथ जो 'nums1' में नहीं हैं।\nप्रत्येक सूची में पूर्णांक आरोही क्रम में लौटाए जाते हैं।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1 के लिए अद्वितीय है, 4 nums2 के लिए अद्वितीय है।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1 के लिए अद्वितीय हैं; 4, 5 nums2 के लिए अद्वितीय हैं।\n*/",
      "hu": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nKét listát ad vissza: az egyik 'nums1'-ben található egyedi egész számokkal, amelyek nincsenek 'nums2'-ben, a másik pedig 'nums2'-ben található egyedi egész számokkal, amelyek nincsenek 'nums1'-ben.\nAz egyes listákban lévő egész számok növekvő sorrendben kerülnek visszaadásra.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 egyedi a nums1-ben, 4 egyedi a nums2-ben.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 egyedi a nums1-ben; 4, 5 egyedi a nums2-ben.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.98324989722809",
      "hy": "0.9751245242310957",
      "bn": "0.9734673509621217",
      "bg": "0.98324989722809",
      "zh": "0.9760060458621286",
      "fr": "0.9792999334708301",
      "de": "0.9777790206432461",
      "ha": "0.9697889149357366",
      "hi": "0.9848143101091207",
      "hu": "0.9721273904116603"
    },
    "canonical_solution": "let set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}",
    "instruction": {
      "en": "Write a Swift function `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` to solve the following problem:\n\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n",
      "sq": "Shkruani një funksion Swift `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` për të zgjidhur problemin e mëposhtëm:\n\nKthen dy lista: një me numra të plotë unikë në 'nums1' që nuk janë në 'nums2', dhe një tjetër me numra të plotë unikë në 'nums2' që nuk janë në 'nums1'.\nNumrat e plotë në secilën listë kthehen në rend rritës.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 është unik për nums1, 4 është unik për nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 janë unikë për nums1; 4, 5 janë unikë për nums2.",
      "hy": "Գրեք Swift ֆունկցիա `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` հետևյալ խնդիրը լուծելու համար:\n\nՎերադարձնում է երկու ցուցակներ. մեկը՝ 'nums1'-ում եզակի ամբողջ թվերով, որոնք չկան 'nums2'-ում, և մյուսը՝ 'nums2'-ում եզակի ամբողջ թվերով, որոնք չկան 'nums1'-ում:\nԱմբողջ թվերը յուրաքանչյուր ցուցակում վերադարձվում են աճման կարգով:\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1-ը եզակի է nums1-ում, 4-ը եզակի է nums2-ում:\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2-ը եզակի են nums1-ում; 4, 5-ը եզակի են nums2-ում:",
      "bn": "একটি Swift ফাংশন লিখুন `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nদুটি তালিকা ফেরত দেয়: একটি 'nums1' এ অনন্য পূর্ণসংখ্যাগুলি যা 'nums2' তে নেই, এবং অন্যটি 'nums2' এ অনন্য পূর্ণসংখ্যাগুলি যা 'nums1' তে নেই।\nপ্রত্যেক তালিকার পূর্ণসংখ্যাগুলি ঊর্ধ্বক্রমে ফেরত দেওয়া হয়।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 হল nums1 এর জন্য অনন্য, 4 হল nums2 এর জন্য অনন্য।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 হল nums1 এর জন্য অনন্য; 4, 5 হল nums2 এর জন্য অনন্য।",
      "bg": "Напишете Swift функция `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` за решаване на следния проблем:\n\nВръща два списъка: един с уникални цели числа в 'nums1', които не са в 'nums2', и друг с уникални цели числа в 'nums2', които не са в 'nums1'.\nЦелите числа във всеки списък се връщат във възходящ ред.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 е уникално за nums1, 4 е уникално за nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 са уникални за nums1; 4, 5 са уникални за nums2.",
      "zh": "编写一个 Swift 函数 `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` 来解决以下问题：\n\n返回两个列表：一个包含 'nums1' 中不在 'nums2' 中的唯一整数，另一个包含 'nums2' 中不在 'nums1' 中的唯一整数。\n每个列表中的整数按升序返回。\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 是 nums1 独有的，4 是 nums2 独有的。\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 是 nums1 独有的；4, 5 是 nums2 独有的。",
      "fr": "Écrire une fonction Swift `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` pour résoudre le problème suivant :\n\nRenvoie deux listes : une avec les entiers uniques dans 'nums1' qui ne sont pas dans 'nums2', et une autre avec les entiers uniques dans 'nums2' qui ne sont pas dans 'nums1'.\nLes entiers dans chaque liste sont retournés par ordre croissant.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 est unique à nums1, 4 est unique à nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sont uniques à nums1 ; 4, 5 sont uniques à nums2.",
      "de": "Schreiben Sie eine Swift-Funktion `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {`, um das folgende Problem zu lösen:\n\nGibt zwei Listen zurück: eine mit eindeutigen ganzen Zahlen in 'nums1', die nicht in 'nums2' sind, und eine andere mit eindeutigen ganzen Zahlen in 'nums2', die nicht in 'nums1' sind.\nDie ganzen Zahlen in jeder Liste werden in aufsteigender Reihenfolge zurückgegeben.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ist eindeutig für nums1, 4 ist eindeutig für nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sind eindeutig für nums1; 4, 5 sind eindeutig für nums2.",
      "ha": "Rubuta aikin Swift `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` don warware matsalar mai zuwa:\n\nMayar da jerin biyu: ɗaya tare da lambobin cikakkun lambobi a cikin 'nums1' waɗanda ba su cikin 'nums2', da kuma wani tare da lambobin cikakkun lambobi a cikin 'nums2' waɗanda ba su cikin 'nums1'.\nAna mayar da lambobin cikakkun lambobi a kowane jeri cikin tsari mai hawa.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ya bambanta ga nums1, 4 ya bambanta ga nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sun bambanta ga nums1; 4, 5 sun bambanta ga nums2.",
      "hi": "Swift फ़ंक्शन `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nदो सूचियाँ लौटाता है: एक 'nums1' में अद्वितीय पूर्णांकों के साथ जो 'nums2' में नहीं हैं, और दूसरी 'nums2' में अद्वितीय पूर्णांकों के साथ जो 'nums1' में नहीं हैं।\nप्रत्येक सूची में पूर्णांक आरोही क्रम में लौटाए जाते हैं।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1 में अद्वितीय है, 4 nums2 में अद्वितीय है।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1 में अद्वितीय हैं; 4, 5 nums2 में अद्वितीय हैं।",
      "hu": "Írj egy Swift függvényt `func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {` a következő probléma megoldására:\n\nKét listát ad vissza: az egyik a 'nums1'-ben lévő egyedi egész számokat tartalmazza, amelyek nincsenek benne a 'nums2'-ben, a másik pedig a 'nums2'-ben lévő egyedi egész számokat, amelyek nincsenek benne a 'nums1'-ben.\nAz egyes listákban lévő egész számok növekvő sorrendben vannak visszaadva.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 egyedi a nums1-ben, 4 egyedi a nums2-ben.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 egyedi a nums1-ben; 4, 5 egyedi a nums2-ben."
    },
    "instruction_bertscore": {
      "sq": "0.9761707104480065",
      "hy": "0.9717265543027319",
      "bn": "0.9772137185788208",
      "bg": "0.983284856175152",
      "zh": "0.9902103030403145",
      "fr": "0.978757871160986",
      "de": "0.983284856175152",
      "ha": "0.9738890432610587",
      "hi": "0.9601605058454514",
      "hu": "0.9716761021859491"
    },
    "level": "easy",
    "test": "func checkFindUniqueElements(_ findUniqueElements: ([Int], [Int]) -> [[Int]]) {\nassert(findUniqueElements([1, 2, 3], [2, 3, 4]) == [[1], [4]])\nassert(findUniqueElements( [1, 1, 2, 3], [3, 4, 4, 5]) == [[1, 2], [4, 5]])\nassert(findUniqueElements( [1, 2, 2], [1, 1, 1]) == [[2], []])\nassert(findUniqueElements( [], [1, 2, 3]) == [[], [1, 2, 3]])\nassert(findUniqueElements( [4, 5, 6], [4, 5, 6]) == [[], []])\nassert(findUniqueElements( [10], [10, 20]) == [[], [20]])\n}\n\ncheckFindUniqueElements(findUniqueElements)",
    "entry_point": "findUniqueElements",
    "signature": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {",
    "docstring": {
      "en": "\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n",
      "sq": "Kthen dy lista: një me numra të plotë unikë në 'nums1' që nuk janë në 'nums2', dhe një tjetër me numra të plotë unikë në 'nums2' që nuk janë në 'nums1'.\nNumrat e plotë në secilën listë kthehen në rend rritës.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 është unik për nums1, 4 është unik për nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 janë unikë për nums1; 4, 5 janë unikë për nums2.",
      "hy": "Վերադարձնում է երկու ցուցակներ. մեկը՝ 'nums1'-ում գտնվող եզակի ամբողջ թվերով, որոնք չկան 'nums2'-ում, և մյուսը՝ 'nums2'-ում գտնվող եզակի ամբողջ թվերով, որոնք չկան 'nums1'-ում:\nՅուրաքանչյուր ցուցակում թվերը վերադարձվում են աճման կարգով:\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1-ը եզակի է nums1-ում, 4-ը եզակի է nums2-ում:\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2-ը եզակի են nums1-ում; 4, 5-ը եզակի են nums2-ում:",
      "bn": "'nums1' এর মধ্যে অনন্য পূর্ণসংখ্যাগুলি যা 'nums2' তে নেই এবং 'nums2' এর মধ্যে অনন্য পূর্ণসংখ্যাগুলি যা 'nums1' তে নেই এমন দুটি তালিকা প্রদান করে। প্রতিটি তালিকার পূর্ণসংখ্যাগুলি ঊর্ধ্বক্রমে ফেরত দেওয়া হয়।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 হল nums1 এর জন্য অনন্য, 4 হল nums2 এর জন্য অনন্য।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 হল nums1 এর জন্য অনন্য; 4, 5 হল nums2 এর জন্য অনন্য।",
      "bg": "Връща два списъка: един с уникални цели числа в 'nums1', които не са в 'nums2', и друг с уникални цели числа в 'nums2', които не са в 'nums1'. Целите числа във всеки списък се връщат в нарастващ ред.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 е уникално за nums1, 4 е уникално за nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 са уникални за nums1; 4, 5 са уникални за nums2.",
      "zh": "返回两个列表：一个包含在 'nums1' 中但不在 'nums2' 中的唯一整数，另一个包含在 'nums2' 中但不在 'nums1' 中的唯一整数。\n每个列表中的整数按升序返回。\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 是 nums1 独有的，4 是 nums2 独有的。\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 是 nums1 独有的；4, 5 是 nums2 独有的。",
      "fr": "Renvoie deux listes : une avec des entiers uniques dans 'nums1' qui ne sont pas dans 'nums2', et une autre avec des entiers uniques dans 'nums2' qui ne sont pas dans 'nums1'.\nLes entiers dans chaque liste sont renvoyés par ordre croissant.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 est unique à nums1, 4 est unique à nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sont uniques à nums1 ; 4, 5 sont uniques à nums2.",
      "de": "Gibt zwei Listen zurück: eine mit eindeutigen ganzen Zahlen in 'nums1', die nicht in 'nums2' sind, und eine andere mit eindeutigen ganzen Zahlen in 'nums2', die nicht in 'nums1' sind. Die ganzen Zahlen in jeder Liste werden in aufsteigender Reihenfolge zurückgegeben.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ist eindeutig für nums1, 4 ist eindeutig für nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 sind eindeutig für nums1; 4, 5 sind eindeutig für nums2.",
      "ha": "Returns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.  \nYa dawo da jerin guda biyu: ɗaya tare da lambobin cikakke na musamman a cikin 'nums1' ba a cikin 'nums2' ba, kuma ɗaya tare da lambobin cikakke na musamman a cikin 'nums2' ba a cikin 'nums1' ba.  \n\nThe integers in each list are returned in ascending order.  \nAna dawo da lambobin cikakke a cikin kowane jeri a cikin tsari mai hawa.  \n\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])  \n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.  \n[[1], [4]] // 1 na musamman ne ga nums1, 4 na musamman ne ga nums2.  \n\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])  \n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.  \n[[1, 2], [4, 5]] // 1, 2 na musamman ne ga nums1; 4, 5 na musamman ne ga nums2.  ",
      "hi": "'nums1' में अद्वितीय पूर्णांक जो 'nums2' में नहीं हैं, और 'nums2' में अद्वितीय पूर्णांक जो 'nums1' में नहीं हैं, उनके साथ दो सूचियाँ लौटाता है। प्रत्येक सूची में पूर्णांक आरोही क्रम में लौटाए जाते हैं।\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1 के लिए अद्वितीय है, 4 nums2 के लिए अद्वितीय है।\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1 के लिए अद्वितीय हैं; 4, 5 nums2 के लिए अद्वितीय हैं।",
      "hu": "Két listát ad vissza: az egyik a 'nums1'-ben lévő egyedi egész számokkal, amelyek nincsenek a 'nums2'-ben, a másik pedig a 'nums2'-ben lévő egyedi egész számokkal, amelyek nincsenek a 'nums1'-ben.\nAz egyes listákban lévő egész számok növekvő sorrendben kerülnek visszaadásra.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 egyedi a nums1-ben, 4 egyedi a nums2-ben.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 egyediek a nums1-ben; 4, 5 egyediek a nums2-ben."
    },
    "docstring_bertscore": {
      "sq": "0.9807402023637142",
      "hy": "0.9677106452589685",
      "bn": "0.9518406737054241",
      "bg": "0.9807402023637142",
      "zh": "0.9721816165056829",
      "fr": "0.9807402023637142",
      "de": "0.9807402023637142",
      "ha": "0.999999801369619",
      "hi": "0.9511718852124796",
      "hu": "0.9720703834923033"
    }
  },
  {
    "task_id": "Swift/16",
    "prompt": {
      "en": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n*/",
      "sq": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nKthen numrin në vargun 'nums' që është më afër zeros.\nNëse ka disa numra të tillë, kthen numrin më të madh.\n>>> closestToZero([2, -1, 1])\n1 // 1 dhe -1 janë njësoj afër zeros, por 1 është më i madh.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 është më afër zeros.\n*/",
      "hy": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nՎերադարձնում է 'nums' զանգվածի այն թիվը, որը ամենամոտն է զրոյին:\nԵթե կան մի քանի այդպիսի թվեր, վերադարձնում է ամենամեծը:\n>>> closestToZero([2, -1, 1])\n1 // 1 և -1 հավասարապես մոտ են զրոյին, բայց 1-ը մեծ է:\n>>> closestToZero([-3, -2, -1])\n-1 // -1-ը ամենամոտն է զրոյին:\n*/",
      "bn": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nঅ্যারে 'nums' এর মধ্যে যে সংখ্যাটি শূন্যের সবচেয়ে কাছাকাছি, সেটি ফেরত দেয়।\nযদি একাধিক এমন সংখ্যা থাকে, তাহলে সবচেয়ে বড়টিকে ফেরত দেয়।\n>>> closestToZero([2, -1, 1])\n1 // 1 এবং -1 শূন্যের সমানভাবে কাছাকাছি, কিন্তু 1 বড়।\n>>> closestToZero([-3, -2, -1])\n-1 // -1 শূন্যের সবচেয়ে কাছাকাছি।\n*/",
      "bg": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nВръща числото в масива 'nums', което е най-близо до нула.\nАко има няколко такива числа, връща най-голямото от тях.\n>>> closestToZero([2, -1, 1])\n1 // 1 и -1 са еднакво близо до нула, но 1 е по-голямо.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 е най-близо до нула.\n*/",
      "zh": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\n返回数组 'nums' 中最接近零的数字。\n如果有多个这样的数字，返回较大的那个。\n>>> closestToZero([2, -1, 1])\n1 // 1 和 -1 都同样接近零，但 1 更大。\n>>> closestToZero([-3, -2, -1])\n-1 // -1 最接近零。\n*/",
      "fr": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nRenvoie le nombre dans le tableau 'nums' qui est le plus proche de zéro.\nS'il y a plusieurs de ces nombres, renvoie le plus grand.\n>>> closestToZero([2, -1, 1])\n1 // 1 et -1 sont également proches de zéro, mais 1 est plus grand.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 est le plus proche de zéro.\n*/",
      "de": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nGibt die Zahl im Array 'nums' zurück, die am nächsten bei Null liegt.\nWenn es mehrere solche Zahlen gibt, wird die größte zurückgegeben.\n>>> closestToZero([2, -1, 1])\n1 // 1 und -1 sind gleich nah an Null, aber 1 ist größer.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 ist am nächsten bei Null.\n*/",
      "ha": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nYana mayar da lambar da ke cikin jerin 'nums' wanda ya fi kusa da sifili.\nIdan akwai lambobi da yawa irin haka, yana mayar da mafi girma.\n>>> closestToZero([2, -1, 1])\n1 // 1 da -1 suna da kusanci da sifili, amma 1 ya fi girma.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 shi ne mafi kusa da sifili.\n*/",
      "hi": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nऐरे 'nums' में वह संख्या लौटाता है जो शून्य के सबसे करीब है।\nयदि ऐसी कई संख्याएँ हैं, तो सबसे बड़ी संख्या लौटाता है।\n>>> closestToZero([2, -1, 1])\n1 // 1 और -1 दोनों शून्य के समान रूप से करीब हैं, लेकिन 1 बड़ा है।\n>>> closestToZero([-3, -2, -1])\n-1 // -1 शून्य के सबसे करीब है।\n*/",
      "hu": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nVisszaadja a 'nums' tömbben lévő számot, amely a legközelebb van a nullához.\nHa több ilyen szám is van, a legnagyobbat adja vissza.\n>>> closestToZero([2, -1, 1])\n1 // 1 és -1 egyformán közel van a nullához, de 1 a nagyobb.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 van a legközelebb a nullához.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9952964325770939",
      "hy": "0.9914529347040688",
      "bn": "0.9960780431264661",
      "bg": "0.9927335047706007",
      "zh": "0.9894940418863027",
      "fr": "0.9918942914107283",
      "de": "0.9938126636307633",
      "ha": "0.9841071859526366",
      "hi": "0.9880285469350273",
      "hu": "0.9931677107835429"
    },
    "canonical_solution": "guard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}",
    "instruction": {
      "en": "Write a Swift function `func closestToZero(_ nums: [Int]) -> Int {` to solve the following problem:\n\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n",
      "sq": "Shkruani një funksion Swift `func closestToZero(_ nums: [Int]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nKthen numrin në vargun 'nums' që është më afër zeros.\nNëse ka disa të tillë, kthen më të madhin.\n>>> closestToZero([2, -1, 1])\n1 // 1 dhe -1 janë njësoj afër zeros, por 1 është më i madh.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 është më afër zeros.",
      "hy": "Գրեք Swift ֆունկցիա `func closestToZero(_ nums: [Int]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՎերադարձնում է 'nums' զանգվածում գտնվող այն թիվը, որը ամենամոտն է զրոյին:\nԵթե կան մի քանի այդպիսի թվեր, վերադարձնում է ամենամեծը:\n>>> closestToZero([2, -1, 1])\n1 // 1 և -1 թվերը նույնքան մոտ են զրոյին, բայց 1-ը մեծ է:\n>>> closestToZero([-3, -2, -1])\n-1 // -1 թիվը ամենամոտն է զրոյին:",
      "bn": "একটি Swift ফাংশন `func closestToZero(_ nums: [Int]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nঅ্যারে 'nums' এর মধ্যে যে সংখ্যা শূন্যের সবচেয়ে কাছাকাছি, তা ফেরত দেয়।\nযদি একাধিক এমন সংখ্যা থাকে, তবে সবচেয়ে বড়টিকে ফেরত দেয়।\n>>> closestToZero([2, -1, 1])\n1 // 1 এবং -1 শূন্যের সমানভাবে কাছাকাছি, কিন্তু 1 বড়।\n>>> closestToZero([-3, -2, -1])\n-1 // -1 শূন্যের সবচেয়ে কাছাকাছি।",
      "bg": "Напишете Swift функция `func closestToZero(_ nums: [Int]) -> Int {`, за да решите следния проблем:\n\nВръща числото в масива 'nums', което е най-близо до нула.\nАко има няколко такива числа, връща най-голямото от тях.\n>>> closestToZero([2, -1, 1])\n1 // 1 и -1 са еднакво близо до нула, но 1 е по-голямо.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 е най-близо до нула.",
      "zh": "编写一个 Swift 函数 `func closestToZero(_ nums: [Int]) -> Int {` 来解决以下问题：\n\n返回数组 'nums' 中最接近零的数字。\n如果有多个这样的数字，返回较大的那个。\n>>> closestToZero([2, -1, 1])\n1 // 1 和 -1 都同样接近零，但 1 更大。\n>>> closestToZero([-3, -2, -1])\n-1 // -1 最接近零。",
      "fr": "Écrivez une fonction Swift `func closestToZero(_ nums: [Int]) -> Int {` pour résoudre le problème suivant :\n\nRenvoie le nombre dans le tableau 'nums' qui est le plus proche de zéro.\nS'il y a plusieurs nombres de ce type, renvoie le plus grand.\n>>> closestToZero([2, -1, 1])\n1 // 1 et -1 sont également proches de zéro, mais 1 est plus grand.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 est le plus proche de zéro.",
      "de": "Schreiben Sie eine Swift-Funktion `func closestToZero(_ nums: [Int]) -> Int {`, um das folgende Problem zu lösen:\n\nGibt die Zahl im Array 'nums' zurück, die am nächsten bei Null liegt.\nWenn es mehrere solcher Zahlen gibt, wird die größte zurückgegeben.\n>>> closestToZero([2, -1, 1])\n1 // 1 und -1 sind gleich nah an Null, aber 1 ist größer.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 ist am nächsten bei Null.",
      "ha": "Rubuta wani aikin Swift `func closestToZero(_ nums: [Int]) -> Int {` domin warware matsalar mai zuwa:\n\nDawo da lambar a cikin jerin 'nums' wanda yake kusa da sifili.\nIdan akwai lambobi da dama irin haka, dawo da mafi girma.\n>>> closestToZero([2, -1, 1])\n1 // 1 da -1 suna da kusanci da sifili, amma 1 ya fi girma.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 yana kusa da sifili.",
      "hi": "Swift फ़ंक्शन `func closestToZero(_ nums: [Int]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nऐरे 'nums' में वह संख्या लौटाता है जो शून्य के सबसे करीब है।\nयदि ऐसी कई संख्याएँ हैं, तो सबसे बड़ी संख्या लौटाता है।\n>>> closestToZero([2, -1, 1])\n1 // 1 और -1 शून्य के समान रूप से करीब हैं, लेकिन 1 बड़ा है।\n>>> closestToZero([-3, -2, -1])\n-1 // -1 शून्य के सबसे करीब है।",
      "hu": "Írj egy Swift függvényt `func closestToZero(_ nums: [Int]) -> Int {` a következő probléma megoldására:\n\nVisszaadja a 'nums' tömbben lévő számot, amely a legközelebb van a nullához.\nHa több ilyen szám is van, a legnagyobbat adja vissza.\n>>> closestToZero([2, -1, 1])\n1 // 1 és -1 egyaránt közel van a nullához, de 1 a nagyobb.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 van a legközelebb a nullához."
    },
    "instruction_bertscore": {
      "sq": "0.996026001966635",
      "hy": "0.9802569346466563",
      "bn": "0.9987909368706407",
      "bg": "0.9918039145873574",
      "zh": "0.9907416393095828",
      "fr": "0.9916797705992106",
      "de": "0.9943108286263987",
      "ha": "0.9890455344859259",
      "hi": "0.9793342965267492",
      "hu": "0.9865588807457502"
    },
    "level": "easy",
    "test": "func checkClosestToZero(_ closestToZero: ([Int]) -> Int) {\nassert(closestToZero([2, -1, 1]) == 1)\nassert(closestToZero([-3, -2, -1]) == -1)\nassert(closestToZero([0, 10, 20]) == 0)\nassert(closestToZero([5, 6, 7]) == 5)\nassert(closestToZero([-5, 5]) == 5)\nassert(closestToZero([-10, -5, 0, 5, 10]) == 0)\nassert(closestToZero([]) == 0)\n}\n\ncheckClosestToZero(closestToZero)",
    "entry_point": "closestToZero",
    "signature": "func closestToZero(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n",
      "sq": "Kthen numrin në vargun 'nums' që është më afër zeros.  \nNëse ka disa numra të tillë, kthen më të madhin.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 dhe -1 janë njësoj afër zeros, por 1 është më i madh.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 është më afër zeros.  ",
      "hy": "Վերադարձնում է 'nums' զանգվածում զրոյին ամենամոտ թիվը:  \nԵթե կան մի քանի այդպիսի թվեր, վերադարձնում է ամենամեծը:  \n>>> closestToZero([2, -1, 1])  \n1 // 1 և -1 հավասարապես մոտ են զրոյին, բայց 1-ը մեծ է:  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1-ը ամենամոտն է զրոյին:  ",
      "bn": "Returns the number in the array 'nums' that is closest to zero.  \nঅ্যারে 'nums' এ শূন্যের সবচেয়ে কাছাকাছি যে সংখ্যাটি রয়েছে তা ফেরত দেয়।  \nIf there are multiple such numbers, returns the largest one.  \nযদি এমন একাধিক সংখ্যা থাকে, তবে সবচেয়ে বড়টিকে ফেরত দেয়।  \n>>> closestToZero([2, -1, 1])  \n1 // 1 এবং -1 উভয়ই শূন্যের সমান কাছাকাছি, কিন্তু 1 বড়।  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 শূন্যের সবচেয়ে কাছাকাছি।  ",
      "bg": "Връща числото в масива 'nums', което е най-близо до нула.  \nАко има няколко такива числа, връща най-голямото от тях.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 и -1 са еднакво близо до нула, но 1 е по-голямо.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 е най-близо до нула.  ",
      "zh": "返回数组 'nums' 中最接近零的数字。  \n如果有多个这样的数字，返回较大的那个。  \n>>> closestToZero([2, -1, 1])  \n1 // 1 和 -1 都同样接近零，但 1 更大。  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 最接近零。  ",
      "fr": "Retourne le nombre dans le tableau 'nums' qui est le plus proche de zéro.\nS'il y a plusieurs nombres tels, retourne le plus grand.\n>>> closestToZero([2, -1, 1])\n1 // 1 et -1 sont également proches de zéro, mais 1 est plus grand.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 est le plus proche de zéro.",
      "de": "Gibt die Zahl im Array 'nums' zurück, die am nächsten bei Null liegt.  \nWenn es mehrere solche Zahlen gibt, wird die größte zurückgegeben.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 und -1 sind gleich nah an Null, aber 1 ist größer.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 ist am nächsten bei Null.  ",
      "ha": "Yana mayar da adadin a cikin jerin 'nums' wanda ya fi kusa da sifili. Idan akwai adadi da yawa irin haka, yana mayar da mafi girma. \n\n>>> closestToZero([2, -1, 1])  \n1 // 1 da -1 suna daidai kusa da sifili, amma 1 ya fi girma.  \n\n>>> closestToZero([-3, -2, -1])  \n-1 // -1 shi ne mafi kusa da sifili.  ",
      "hi": "श्रेणी 'nums' में उस संख्या को लौटाता है जो शून्य के सबसे करीब है।  \nयदि ऐसी कई संख्याएँ हैं, तो सबसे बड़ी संख्या लौटाता है।  \n>>> closestToZero([2, -1, 1])  \n1 // 1 और -1 दोनों ही शून्य के बराबर करीब हैं, लेकिन 1 बड़ा है।  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 शून्य के सबसे करीब है।  ",
      "hu": "Visszaadja a 'nums' tömbben lévő számot, amely a legközelebb van a nullához.\nHa több ilyen szám is van, a legnagyobbat adja vissza.\n>>> closestToZero([2, -1, 1])\n1 // 1 és -1 egyaránt közel van a nullához, de 1 a nagyobb.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 van a legközelebb a nullához."
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9754325999520809",
      "bn": "0.9104073693734516",
      "bg": "0.9897030010471514",
      "zh": "0.9900178302010917",
      "fr": "0.9896823434875238",
      "de": "0.9921094081133891",
      "ha": "0.9761589912555255",
      "hi": "0.9490449510923581",
      "hu": "0.9846192550749445"
    }
  },
  {
    "task_id": "Swift/17",
    "prompt": {
      "en": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n*/",
      "sq": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nKthen një varg elementesh që shfaqen në të gjitha vargjet brenda vargut dy-dimensional 'nums'.\nÇdo varg në 'nums' përbëhet nga numra të plotë pozitivë të dallueshëm.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Vetëm '3' shfaqet në të gjitha vargjet.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Vetëm '2' shfaqet në të gjitha vargjet.\n*/",
      "hy": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nՎերադարձնում է այն տարրերի զանգվածը, որոնք հանդիպում են երկչափ զանգվածի 'nums' բոլոր զանգվածներում:\n'nums'-ի յուրաքանչյուր զանգված բաղկացած է տարբեր դրական ամբողջ թվերից:\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Միայն '3'-ը հանդիպում է բոլոր զանգվածներում:\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Միայն '2'-ը հանդիպում է բոլոր զանգվածներում:\n*/",
      "bn": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nদ্বি-মাত্রিক অ্যারে 'nums' এর মধ্যে উপস্থিত সমস্ত অ্যারের মধ্যে যে উপাদানগুলি উপস্থিত থাকে তাদের একটি অ্যারে প্রদান করে।\n'nums' এর প্রতিটি অ্যারে স্বতন্ত্র ধনাত্মক পূর্ণসংখ্যা নিয়ে গঠিত।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // শুধুমাত্র '3' সমস্ত অ্যারেতে উপস্থিত।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // শুধুমাত্র '2' সমস্ত অ্যারেতে উপস্থিত।\n*/",
      "bg": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nВръща масив от елементи, които се появяват във всички масиви в двумерния масив 'nums'.\nВсеки масив в 'nums' се състои от различни положителни цели числа.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Само '3' се появява във всички масиви.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Само '2' се появява във всички масиви.\n*/",
      "zh": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\n返回一个数组，其中包含在二维数组 'nums' 中所有数组中出现的元素。\n'nums' 中的每个数组由不同的正整数组成。\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // 只有 '3' 出现在所有数组中。\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // 只有 '2' 出现在所有数组中。\n*/",
      "fr": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nRetourne un tableau d'éléments qui apparaissent dans tous les tableaux au sein du tableau bidimensionnel 'nums'.\nChaque tableau dans 'nums' se compose d'entiers positifs distincts.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Seul '3' apparaît dans tous les tableaux.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Seul '2' apparaît dans tous les tableaux.\n*/",
      "de": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nGibt ein Array von Elementen zurück, die in allen Arrays innerhalb des zweidimensionalen Arrays 'nums' erscheinen.\nJedes Array in 'nums' besteht aus unterschiedlichen positiven ganzen Zahlen.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Nur '3' erscheint in allen Arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Nur '2' erscheint in allen Arrays.\n*/",
      "ha": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nYa dawo da wani jerin abubuwan da suka bayyana a dukkan jerin abubuwa a cikin jerin abubuwa biyu-biyu 'nums'.\nKowane jeri a cikin 'nums' yana dauke da lambobi masu kyau daban-daban.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sai dai '3' ya bayyana a dukkan jerin abubuwa.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sai dai '2' ya bayyana a dukkan jerin abubuwa.\n*/",
      "hi": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nसभी उप-समुच्चयों में उपस्थित तत्वों की एक सूची लौटाता है जो द्वि-आयामी सूची 'nums' के भीतर हैं।\n'nums' में प्रत्येक उप-समुच्चय में भिन्न सकारात्मक पूर्णांक होते हैं।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // केवल '3' सभी उप-समुच्चयों में उपस्थित है।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // केवल '2' सभी उप-समुच्चयों में उपस्थित है।\n*/",
      "hu": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nVisszaad egy tömböt azokról az elemekről, amelyek megjelennek az összes tömbben a 'nums' kétdimenziós tömbön belül.\nA 'nums' minden tömbje különálló pozitív egész számokból áll.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Csak a '3' jelenik meg minden tömbben.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Csak a '2' jelenik meg minden tömbben.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9942180682384555",
      "bn": "0.9823578481868622",
      "bg": "0.999999801369619",
      "zh": "0.9945420343899234",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9733408234094025",
      "hi": "0.9470767226466834",
      "hu": "0.9808623600480506"
    },
    "canonical_solution": "guard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}",
    "instruction": {
      "en": "Write a Swift function `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` to solve the following problem:\n\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n",
      "sq": "Shkruani një funksion Swift `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` për të zgjidhur problemin e mëposhtëm:\n\nKthen një varg elementesh që shfaqen në të gjitha vargjet brenda vargut dy-dimensional 'nums'.\nÇdo varg në 'nums' përbëhet nga numra të plotë pozitivë të dallueshëm.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Vetëm '3' shfaqet në të gjitha vargjet.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Vetëm '2' shfaqet në të gjitha vargjet.",
      "hy": "Swift ֆունկցիա `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` գրեք հետևյալ խնդիրը լուծելու համար:\n\nՎերադարձնում է տարրերի զանգված, որոնք հանդիպում են երկչափ զանգված 'nums'-ի բոլոր զանգվածներում:\n'nums'-ի յուրաքանչյուր զանգված բաղկացած է տարբեր դրական ամբողջ թվերից:\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Միայն '3'-ը հանդիպում է բոլոր զանգվածներում:\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Միայն '2'-ը հանդիպում է բոլոր զանգվածներում:",
      "bn": "একটি Swift ফাংশন `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি অ্যারে প্রদান করে যা 'nums' দ্বিমাত্রিক অ্যারের প্রতিটি অ্যারেতে উপস্থিত উপাদানগুলি ধারণ করে।\n'nums' এর প্রতিটি অ্যারে পৃথক ধনাত্মক পূর্ণসংখ্যা নিয়ে গঠিত।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // কেবলমাত্র '3' সব অ্যারেতে উপস্থিত।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // কেবলমাত্র '2' সব অ্যারেতে উপস্থিত।",
      "bg": "Напишете Swift функция `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` за решаване на следния проблем:\n\nВръща масив от елементи, които се появяват във всички масиви в двумерния масив 'nums'.\nВсеки масив в 'nums' се състои от различни положителни цели числа.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Само '3' се появява във всички масиви.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Само '2' се появява във всички масиви.",
      "zh": "编写一个 Swift 函数 `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` 来解决以下问题：\n\n返回一个数组，其中的元素出现在二维数组 'nums' 的所有数组中。\n'nums' 中的每个数组由不同的正整数组成。\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // 只有 '3' 出现在所有数组中。\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // 只有 '2' 出现在所有数组中。",
      "fr": "Écrire une fonction Swift `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` pour résoudre le problème suivant :\n\nRenvoie un tableau d'éléments qui apparaissent dans tous les tableaux au sein du tableau bidimensionnel 'nums'.\nChaque tableau dans 'nums' est composé d'entiers positifs distincts.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Seul '3' apparaît dans tous les tableaux.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Seul '2' apparaît dans tous les tableaux.",
      "de": "Schreiben Sie eine Swift-Funktion `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {`, um das folgende Problem zu lösen:\n\nGibt ein Array von Elementen zurück, die in allen Arrays innerhalb des zweidimensionalen Arrays 'nums' erscheinen.\nJedes Array in 'nums' besteht aus unterschiedlichen positiven ganzen Zahlen.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Nur '3' erscheint in allen Arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Nur '2' erscheint in allen Arrays.",
      "ha": "Rubuta aikin Swift `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` don warware matsalar mai zuwa:\n\nDawo da jerin abubuwan da suka bayyana a duk jerin cikin jerin biyu-dimensional 'nums'.\nKowane jeri a cikin 'nums' yana kunshe da lambobi masu kyau na musamman.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sai dai '3' kawai ya bayyana a duk jerin.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sai dai '2' kawai ya bayyana a duk jerin.",
      "hi": "Swift फ़ंक्शन `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nऐसे तत्वों की एक array लौटाता है जो द्वि-आयामी array 'nums' के भीतर सभी arrays में प्रकट होते हैं।\n'nums' में प्रत्येक array में विशिष्ट सकारात्मक पूर्णांक होते हैं।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // केवल '3' सभी arrays में प्रकट होता है।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // केवल '2' सभी arrays में प्रकट होता है।",
      "hu": "Írj egy Swift függvényt `func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {` a következő probléma megoldására:\n\nVisszaad egy tömböt azokkal az elemekkel, amelyek megjelennek az összes tömbben a 'nums' kétdimenziós tömbön belül.\nA 'nums'-ban lévő minden tömb különálló pozitív egész számokból áll.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Csak a '3' jelenik meg minden tömbben.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Csak a '2' jelenik meg minden tömbben."
    },
    "instruction_bertscore": {
      "sq": "0.998929580876603",
      "hy": "0.9830500750647688",
      "bn": "0.9693995993889082",
      "bg": "0.9956654878250567",
      "zh": "0.9887400409598942",
      "fr": "0.9952930558606162",
      "de": "1",
      "ha": "0.9817051487547817",
      "hi": "0.9858338798549728",
      "hu": "0.9796878586049913"
    },
    "level": "easy",
    "test": "func checkCommonElementsInAllArrays(_ commonElementsInAllArrays: ([[Int]]) -> [Int]) {\nassert(commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == [3])\nassert(commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]]) == [2])\nassert(commonElementsInAllArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [])\nassert(commonElementsInAllArrays([[10, 20], [20, 30], [20, 40]]) == [20])\nassert(commonElementsInAllArrays([[1]]) == [1])\nassert(commonElementsInAllArrays([]) == [])\nassert(commonElementsInAllArrays([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) == [4])\n}\n\ncheckCommonElementsInAllArrays(commonElementsInAllArrays)",
    "entry_point": "commonElementsInAllArrays",
    "signature": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {",
    "docstring": {
      "en": "\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n",
      "sq": "Kthen një varg elementesh që shfaqen në të gjitha vargjet brenda vargut dy-dimensional 'nums'. Çdo varg në 'nums' përbëhet nga numra të plotë pozitivë të dallueshëm.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Vetëm '3' shfaqet në të gjitha vargjet.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Vetëm '2' shfaqet në të gjitha vargjet.",
      "hy": "Վերադարձնում է տարրերի զանգված, որոնք հայտնվում են երկչափ զանգվածի 'nums' բոլոր զանգվածներում:  \n'nums'-ի յուրաքանչյուր զանգված բաղկացած է տարբեր դրական ամբողջ թվերից.  \n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])  \n[3] // Միայն '3'-ն է հայտնվում բոլոր զանգվածներում.  \n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])  \n[2] // Միայն '2'-ն է հայտնվում բոլոր զանգվածներում.  ",
      "bn": "Returns an array of elements that appear in all arrays within the two-dimensional array 'nums'.  \nপ্রত্যেকটি অ্যারে 'nums' এ পৃথক ধনাত্মক পূর্ণসংখ্যা নিয়ে গঠিত।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // শুধুমাত্র '3' সমস্ত অ্যারেতে উপস্থিত।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // শুধুমাত্র '2' সমস্ত অ্যারেতে উপস্থিত।",
      "bg": "Връща масив от елементи, които се появяват във всички масиви в двумерния масив 'nums'. Всеки масив в 'nums' се състои от различни положителни цели числа.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Само '3' се появява във всички масиви.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Само '2' се появява във всички масиви.",
      "zh": "返回一个包含在二维数组 'nums' 中所有数组中出现的元素的数组。\n'nums' 中的每个数组由不同的正整数组成。\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // 只有 '3' 出现在所有数组中。\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // 只有 '2' 出现在所有数组中。",
      "fr": "Renvoie un tableau d'éléments qui apparaissent dans tous les tableaux au sein du tableau bidimensionnel 'nums'.  \nChaque tableau dans 'nums' se compose d'entiers positifs distincts.  \n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])  \n[3] // Seul '3' apparaît dans tous les tableaux.  \n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])  \n[2] // Seul '2' apparaît dans tous les tableaux.  ",
      "de": "Gibt ein Array von Elementen zurück, die in allen Arrays innerhalb des zweidimensionalen Arrays 'nums' erscheinen.\nJedes Array in 'nums' besteht aus unterschiedlichen positiven ganzen Zahlen.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Nur '3' erscheint in allen Arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Nur '2' erscheint in allen Arrays.",
      "ha": "Yana dawo da jerin abubuwa da suka bayyana a dukkan jerin abubuwa cikin jerin abubuwa mai girma biyu 'nums'.\nKowane jeri a cikin 'nums' yana dauke da lambobi masu kyau daban-daban.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sai dai '3' ne kawai ya bayyana a dukkan jerin abubuwa.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sai dai '2' ne kawai ya bayyana a dukkan jerin abubuwa.",
      "hi": "सभी उप-ऐरे में उपस्थित तत्वों की एक सूची लौटाता है जो द्वि-आयामी ऐरे 'nums' के भीतर हैं। 'nums' में प्रत्येक ऐरे में भिन्न सकारात्मक पूर्णांक होते हैं।\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // केवल '3' सभी ऐरे में दिखाई देता है।\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // केवल '2' सभी ऐरे में दिखाई देता है।",
      "hu": "Visszaad egy tömböt azokról az elemekről, amelyek megjelennek az összes tömbben a 'nums' kétdimenziós tömbön belül.\nA 'nums' minden tömbje különálló pozitív egész számokból áll.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Csak a '3' jelenik meg az összes tömbben.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Csak a '2' jelenik meg az összes tömbben."
    },
    "docstring_bertscore": {
      "sq": "0.9942538217070417",
      "hy": "0.9922776480461256",
      "bn": "0.9900172343099486",
      "bg": "1",
      "zh": "0.9807902572197349",
      "fr": "1",
      "de": "1",
      "ha": "0.9626195499626634",
      "hi": "0.9598073410279714",
      "hu": "0.9903787416034321"
    }
  },
  {
    "task_id": "Swift/18",
    "prompt": {
      "en": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n*/",
      "sq": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nZbaton algoritmin e specifikuar në vargun 'nums' derisa të mbetet vetëm një numër.\nGjatësia e 'nums' është një fuqi e 2. Për indekset çift, merret minimumi i çifteve; për indekset tek, merret maksimumi.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Numri përfundimtar pas zbatimit të përsëritur të algoritmit.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Numri përfundimtar pas zbatimit të algoritmit.\n*/",
      "hy": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nԿատարում է նշված ալգորիթմը 'nums' զանգվածի վրա մինչև մնա միայն մեկ թիվ:\n'nums'-ի երկարությունը 2-ի աստիճան է: Զույգ ինդեքսների համար վերցնում է զույգերի նվազագույնը; կենտ ինդեքսների համար՝ առավելագույնը:\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Վերջնական թիվը, երբ ալգորիթմը բազմիցս կիրառվում է:\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Վերջնական թիվը ալգորիթմը կիրառելուց հետո:\n*/",
      "bn": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nঅ্যারে 'nums' এর উপর নির্দিষ্ট অ্যালগরিদমটি প্রয়োগ করে যতক্ষণ না শুধুমাত্র একটি সংখ্যা অবশিষ্ট থাকে।\n'nums' এর দৈর্ঘ্য 2 এর ঘাত। জোড় সংখ্যক সূচকের জন্য, জোড়ার মধ্যে সর্বনিম্নটি নিন; বিজোড় সূচকের জন্য, সর্বাধিকটি নিন।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // বারবার অ্যালগরিদম প্রয়োগের পর চূড়ান্ত সংখ্যা।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // অ্যালগরিদম প্রয়োগের পর চূড়ান্ত সংখ্যা।\n*/",
      "bg": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nИзпълнява специфицирания алгоритъм върху масива 'nums', докато остане само едно число.\nДължината на 'nums' е степен на 2. За четни индекси вземете минималната стойност от двойките; за нечетни индекси вземете максималната стойност.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Крайно число след многократно прилагане на алгоритъма.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Крайно число след прилагане на алгоритъма.\n*/",
      "zh": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\n对数组 'nums' 执行指定的算法，直到只剩下一个数字。\n'nums' 的长度是 2 的幂。对于偶数索引，取对中较小的；对于奇数索引，取对中较大的。\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // 重复应用算法后得到的最终数字。\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // 应用算法后得到的最终数字。\n*/",
      "fr": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nExécute l'algorithme spécifié sur le tableau 'nums' jusqu'à ce qu'il ne reste qu'un seul nombre.\nLa longueur de 'nums' est une puissance de 2. Pour les indices pairs, prenez le minimum des paires ; pour les indices impairs, prenez le maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Nombre final après avoir appliqué l'algorithme à plusieurs reprises.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Nombre final après avoir appliqué l'algorithme.\n*/",
      "de": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nFührt den angegebenen Algorithmus auf dem Array 'nums' aus, bis nur noch eine Zahl übrig ist.\nDie Länge von 'nums' ist eine Potenz von 2. Für gerade Indizes nehmen Sie das Minimum der Paare; für ungerade Indizes nehmen Sie das Maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Endgültige Zahl nach wiederholter Anwendung des Algorithmus.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Endgültige Zahl nach Anwendung des Algorithmus.\n*/",
      "ha": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nYana aiwatar da dabarar da aka kayyade akan jerin 'nums' har sai an bar lamba daya kawai.\nTsawon 'nums' yana da iko na 2. Don alamomi na ma'aurata, ɗauki mafi ƙarancin ma'aurata; don alamomi marasa ma'aurata, ɗauki mafi girma.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Lamba ta ƙarshe bayan an yi amfani da dabarar akai-akai.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Lamba ta ƙarshe bayan an yi amfani da dabarar.\n*/",
      "hi": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\n'nums' सरणी पर निर्दिष्ट एल्गोरिदम तब तक लागू करता है जब तक केवल एक संख्या नहीं बचती।\n'nums' की लंबाई 2 की घात है। सम सूचकांकों के लिए, जोड़ों का न्यूनतम लें; विषम सूचकांकों के लिए, अधिकतम लें।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // एल्गोरिदम को बार-बार लागू करने के बाद अंतिम संख्या।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // एल्गोरिदम को लागू करने के बाद अंतिम संख्या।\n*/",
      "hu": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nVégrehajtja a megadott algoritmust a 'nums' tömbön, amíg csak egy szám marad.\nA 'nums' hossza 2 hatványa. Páros indexeknél a párok minimumát veszi; páratlan indexeknél a maximumot.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // A végső szám az algoritmus ismételt alkalmazása után.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // A végső szám az algoritmus alkalmazása után.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9742573039874974",
      "hy": "0.9762392379294635",
      "bn": "0.9689516878796746",
      "bg": "0.9777452534784701",
      "zh": "0.9479773127942955",
      "fr": "0.9880084852665427",
      "de": "0.9789753714282191",
      "ha": "0.9862849694503031",
      "hi": "0.9880247729577877",
      "hu": "0.9642362026339063"
    },
    "canonical_solution": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}",
    "instruction": {
      "en": "Write a Swift function `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` to solve the following problem:\n\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n",
      "sq": "Shkruani një funksion Swift `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nZbaton algoritmin e specifikuar në vargun 'nums' derisa të mbetet vetëm një numër.\nGjatësia e 'nums' është një fuqi e 2. Për indekset çift, merrni minimumin e çifteve; për indekset tek, merrni maksimumin.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Numri përfundimtar pas zbatimit të përsëritur të algoritmit.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Numri përfundimtar pas zbatimit të algoritmit.",
      "hy": "Գրեք Swift ֆունկցիա `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nԿատարում է նշված ալգորիթմը 'nums' զանգվածի վրա մինչև մնա միայն մեկ թիվ։\n'nums'-ի երկարությունը 2-ի աստիճան է։ Զույգ ինդեքսների համար վերցրեք զույգերի նվազագույնը; կենտ ինդեքսների համար վերցրեք առավելագույնը։\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Վերջնական թիվը, երբ բազմիցս կիրառվում է ալգորիթմը։\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Վերջնական թիվը, երբ կիրառվում է ալգորիթմը։",
      "bn": "একটি Swift ফাংশন `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nঅ্যারে 'nums' এর উপর নির্দিষ্ট অ্যালগরিদমটি প্রয়োগ করে যতক্ষণ না শুধুমাত্র একটি সংখ্যা অবশিষ্ট থাকে।\n'nums' এর দৈর্ঘ্য 2 এর ঘাতাংশ। জোড় সংখ্যক সূচকের জন্য, জোড়ার মধ্যে সর্বনিম্নটি নিন; বিজোড় সংখ্যক সূচকের জন্য, সর্বাধিকটি নিন।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // বারবার অ্যালগরিদম প্রয়োগ করার পর চূড়ান্ত সংখ্যা।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // অ্যালগরিদম প্রয়োগ করার পর চূড়ান্ত সংখ্যা।",
      "bg": "Напишете Swift функция `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` за решаване на следния проблем:\n\nИзпълнява специфицирания алгоритъм върху масива 'nums', докато остане само едно число.\nДължината на 'nums' е степен на 2. За четни индекси, вземете минималното от двойките; за нечетни индекси, вземете максималното.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Крайно число след многократно прилагане на алгоритъма.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Крайно число след прилагане на алгоритъма.",
      "zh": "编写一个 Swift 函数 `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` 来解决以下问题：\n\n对数组 'nums' 执行指定算法，直到只剩下一个数字。\n'nums' 的长度是 2 的幂。对于偶数索引，取对中的最小值；对于奇数索引，取对中的最大值。\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // 反复应用算法后的最终数字。\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // 应用算法后的最终数字。",
      "fr": "Écrivez une fonction Swift `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` pour résoudre le problème suivant :\n\nEffectue l'algorithme spécifié sur le tableau 'nums' jusqu'à ce qu'il ne reste qu'un seul nombre.\nLa longueur de 'nums' est une puissance de 2. Pour les indices pairs, prenez le minimum des paires ; pour les indices impairs, prenez le maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Nombre final après avoir appliqué l'algorithme de manière répétée.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Nombre final après avoir appliqué l'algorithme.",
      "de": "Schreiben Sie eine Swift-Funktion `func performAlgorithmOnNums(_ nums: [Int]) -> Int {`, um das folgende Problem zu lösen:\n\nFührt den angegebenen Algorithmus auf dem Array 'nums' aus, bis nur noch eine Zahl übrig ist.\nDie Länge von 'nums' ist eine Potenz von 2. Für gerade Indizes nehmen Sie das Minimum der Paare; für ungerade Indizes nehmen Sie das Maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Endgültige Zahl nach wiederholter Anwendung des Algorithmus.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Endgültige Zahl nach Anwendung des Algorithmus.",
      "ha": "Rubuta aikin Swift `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` don warware matsalar mai zuwa:\n\nAiwatar da tsarin da aka fayyace akan jerin 'nums' har sai an bar lamba daya kawai.\nTsawon 'nums' yana da iko na 2. Don masu nuna alama na ma'aurata, ɗauki mafi ƙarancin ma'aurata; don masu nuna alama na marasa ma'aurata, ɗauki mafi girma.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Lamba ta ƙarshe bayan sake-sake aiwatar da tsarin.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Lamba ta ƙarshe bayan aiwatar da tsarin.",
      "hi": "Swift फ़ंक्शन `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n'nums' array पर निर्दिष्ट algorithm को तब तक लागू करता है जब तक केवल एक संख्या शेष नहीं रह जाती। 'nums' की लंबाई 2 की शक्ति है। सम सूचकांकों के लिए, जोड़ों का न्यूनतम लें; विषम सूचकांकों के लिए, अधिकतम लें।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // बार-बार algorithm लागू करने के बाद अंतिम संख्या।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // algorithm लागू करने के बाद अंतिम संख्या।",
      "hu": "Írj egy Swift függvényt `func performAlgorithmOnNums(_ nums: [Int]) -> Int {` a következő probléma megoldására:\n\nVégrehajtja a megadott algoritmust a 'nums' tömbön, amíg csak egy szám marad.\nA 'nums' hossza 2 hatványa. Páros indexek esetén a párok minimumát veszi; páratlan indexek esetén a maximumot.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // A végső szám az algoritmus ismételt alkalmazása után.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // A végső szám az algoritmus alkalmazása után."
    },
    "instruction_bertscore": {
      "sq": "0.9838054664038446",
      "hy": "0.97752258882133",
      "bn": "0.9773644790380263",
      "bg": "0.994807205948605",
      "zh": "0.9739778310413814",
      "fr": "0.9903241182486475",
      "de": "0.9865759629585191",
      "ha": "0.9534489839006636",
      "hi": "0.9723911715576746",
      "hu": "0.9685748860468514"
    },
    "level": "middle",
    "test": "func checkPerformAlgorithmOnNums(_ performAlgorithmOnNums: ([Int]) -> Int) {\nassert(performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8]) == 1)\nassert(performAlgorithmOnNums([10, 100, 30, 20]) == 10)\nassert(performAlgorithmOnNums([2, 4]) == 2)\nassert(performAlgorithmOnNums([7]) == 7)\n}\n\ncheckPerformAlgorithmOnNums(performAlgorithmOnNums)",
    "entry_point": "performAlgorithmOnNums",
    "signature": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n",
      "sq": "Kryen algoritmin e specifikuar në vargun 'nums' derisa të mbetet vetëm një numër.\nGjatësia e 'nums' është një fuqi e 2. Për indekset çift, merret minimumi i çifteve; për indekset tek, merret maksimumi.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Numri përfundimtar pas aplikimit të përsëritur të algoritmit.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Numri përfundimtar pas aplikimit të algoritmit.",
      "hy": "Կատարում է նշված ալգորիթմը 'nums' զանգվածի վրա, մինչև մնա միայն մեկ թիվ:\n'nums'-ի երկարությունը 2-ի աստիճան է: Զույգ ինդեքսների համար վերցրեք զույգերի նվազագույնը; կենտ ինդեքսների համար վերցրեք առավելագույնը:\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Վերջնական թիվը ալգորիթմը բազմիցս կիրառելուց հետո:\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Վերջնական թիվը ալգորիթմը կիրառելուց հետո:",
      "bn": "নির্দিষ্ট অ্যালগরিদমটি 'nums' অ্যারেতে প্রয়োগ করুন যতক্ষণ না শুধুমাত্র একটি সংখ্যা অবশিষ্ট থাকে। 'nums' এর দৈর্ঘ্য ২ এর ঘাত। জোড় ইনডেক্সের জন্য, জোড়াগুলির মধ্যে সর্বনিম্ন নিন; বিজোড় ইনডেক্সের জন্য, সর্বাধিক নিন।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // বারবার অ্যালগরিদম প্রয়োগ করার পর চূড়ান্ত সংখ্যা।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // অ্যালগরিদম প্রয়োগ করার পর চূড়ান্ত সংখ্যা।",
      "bg": "Изпълнява посочения алгоритъм върху масива 'nums', докато остане само едно число.\nДължината на 'nums' е степен на 2. За четни индекси вземете минималното от двойките; за нечетни индекси вземете максималното.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Крайно число след многократно прилагане на алгоритъма.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Крайно число след прилагане на алгоритъма.",
      "zh": "对数组 'nums' 执行指定的算法，直到只剩下一个数字。  \n'nums' 的长度是 2 的幂。对于偶数索引，取对的最小值；对于奇数索引，取对的最大值。\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // 反复应用算法后的最终数字。\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // 应用算法后的最终数字。",
      "fr": "Effectue l'algorithme spécifié sur le tableau 'nums' jusqu'à ce qu'il ne reste qu'un seul nombre.\nLa longueur de 'nums' est une puissance de 2. Pour les indices pairs, prenez le minimum des paires ; pour les indices impairs, prenez le maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Nombre final après avoir appliqué l'algorithme de manière répétée.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Nombre final après avoir appliqué l'algorithme.",
      "de": "Führt den angegebenen Algorithmus auf dem Array 'nums' aus, bis nur noch eine Zahl übrig ist. Die Länge von 'nums' ist eine Potenz von 2. Bei geraden Indizes wird das Minimum der Paare genommen; bei ungeraden Indizes das Maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Endgültige Zahl nach wiederholter Anwendung des Algorithmus.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Endgültige Zahl nach Anwendung des Algorithmus.",
      "ha": "Yana aiwatar da dabarar da aka fayyace akan jerin 'nums' har sai an bar lamba daya kawai.\nTsawon 'nums' iko ne na 2. Don alamomin ma'aurata, ɗauki mafi ƙaranci; don alamomin marasa ma'aurata, ɗauki mafi girma.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Lamba ta ƙarshe bayan sake-sake amfani da dabarar.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Lamba ta ƙarshe bayan amfani da dabarar.",
      "hi": "निर्दिष्ट एल्गोरिदम को 'nums' ऐरे पर तब तक लागू करता है जब तक केवल एक संख्या नहीं बचती।\n'nums' की लंबाई 2 की शक्ति है। सम सूचकांकों के लिए, जोड़ों का न्यूनतम लें; विषम सूचकांकों के लिए, अधिकतम लें।\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // एल्गोरिदम को बार-बार लागू करने के बाद अंतिम संख्या।\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // एल्गोरिदम को लागू करने के बाद अंतिम संख्या।",
      "hu": "Végrehajtja a megadott algoritmust a 'nums' tömbön, amíg csak egy szám marad. A 'nums' hossza 2 hatványa. Páros indexeknél a párok minimumát veszi; páratlan indexeknél a maximumot.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // A végső szám az algoritmus ismételt alkalmazása után.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // A végső szám az algoritmus alkalmazása után."
    },
    "docstring_bertscore": {
      "sq": "0.9735990429047479",
      "hy": "0.9829223557297634",
      "bn": "0.9694369419005427",
      "bg": "0.9837782540416428",
      "zh": "0.962128337030364",
      "fr": "0.9831897122226364",
      "de": "0.9623762277458956",
      "ha": "0.9527174282073121",
      "hi": "0.9810590041252751",
      "hu": "0.9541225395227529"
    }
  },
  {
    "task_id": "Swift/19",
    "prompt": {
      "en": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n*/",
      "sq": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nNumëron numrin e vargjeve në 'words' që janë parashtesa të vargut 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", dhe \"abc\" janë parashtesa të \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" dhe \"hell\" janë parashtesa të \"hello\".\n*/",
      "hy": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nՀաշվում է 'words' մեջ գտնվող այն տողերի քանակը, որոնք 's' տողի նախածանցներն են։\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" և \"abc\" նախածանցներն են \"abc\"-ի։\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" և \"hell\" նախածանցներն են \"hello\"-ի։\n*/",
      "bn": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\n'words' তালিকায় থাকা কতগুলি স্ট্রিং 's' স্ট্রিংয়ের উপসর্গ তা গণনা করে।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", এবং \"abc\" \"abc\" এর উপসর্গ।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" এবং \"hell\" \"hello\" এর উপসর্গ।\n*/",
      "bg": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nБрои броя на низовете в 'words', които са префикси на низа 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" и \"abc\" са префикси на \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" и \"hell\" са префикси на \"hello\".\n*/",
      "zh": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\n计算在 'words' 中作为字符串 's' 前缀的字符串数量。\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", 和 \"abc\" 是 \"abc\" 的前缀。\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" 和 \"hell\" 是 \"hello\" 的前缀。\n*/",
      "fr": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCompte le nombre de chaînes dans 'words' qui sont des préfixes de la chaîne 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", et \"abc\" sont des préfixes de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" et \"hell\" sont des préfixes de \"hello\".\n*/",
      "de": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nZählt die Anzahl der Zeichenfolgen in 'words', die Präfixe der Zeichenfolge 's' sind.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" und \"abc\" sind Präfixe von \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" und \"hell\" sind Präfixe von \"hello\".\n*/",
      "ha": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nYana ƙidayar adadin igiyoyi a cikin 'words' waɗanda suke farkon igiyar 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", da \"abc\" su ne farkon \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" da \"hell\" su ne farkon \"hello\".\n*/",
      "hi": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\n'words' में उन स्ट्रिंग्स की संख्या गिनता है जो स्ट्रिंग 's' के उपसर्ग हैं।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", और \"abc\" \"abc\" के उपसर्ग हैं।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" और \"hell\" \"hello\" के उपसर्ग हैं।\n*/",
      "hu": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nMegszámolja, hogy hány 'words' listában lévő string előtagja az 's' stringnek.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", és \"abc\" előtagjai az \"abc\"-nek.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" és \"hell\" előtagjai a \"hello\"-nak.\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9970497429504888",
      "bn": "0.9857315852087398",
      "bg": "0.9970497429504888",
      "zh": "0.9930103955217633",
      "fr": "0.999999801369619",
      "de": "0.9970497429504888",
      "ha": "0.999999801369619",
      "hi": "0.999999801369619",
      "hu": "0.9755708466972812"
    },
    "canonical_solution": "return words.filter { s.hasPrefix($0) }.count\n}",
    "instruction": {
      "en": "Write a Swift function `func countPrefixes(_ words: [String], _ s: String) -> Int {` to solve the following problem:\n\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n",
      "sq": "Shkruani një funksion Swift `func countPrefixes(_ words: [String], _ s: String) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nNumëron numrin e vargjeve në 'words' që janë parashtesa të vargut 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", dhe \"abc\" janë parashtesa të \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" dhe \"hell\" janë parashtesa të \"hello\".",
      "hy": "Գրեք Swift ֆունկցիա `func countPrefixes(_ words: [String], _ s: String) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է 'words' տողերի քանակը, որոնք 's' տողի նախածանցներն են:\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" և \"abc\" նախածանցներ են \"abc\"-ի համար։\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" և \"hell\" նախածանցներ են \"hello\"-ի համար։",
      "bn": "একটি Swift ফাংশন `func countPrefixes(_ words: [String], _ s: String) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n'words' এর মধ্যে কতগুলো স্ট্রিং 's' স্ট্রিংটির উপসর্গ তা গণনা করে।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", এবং \"abc\" হলো \"abc\" এর উপসর্গ।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" এবং \"hell\" হলো \"hello\" এর উপসর্গ।",
      "bg": "Напишете функция на Swift `func countPrefixes(_ words: [String], _ s: String) -> Int {`, за да решите следния проблем:\n\nБрои броя на низовете в 'words', които са префикси на низа 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" и \"abc\" са префикси на \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" и \"hell\" са префикси на \"hello\".",
      "zh": "编写一个 Swift 函数 `func countPrefixes(_ words: [String], _ s: String) -> Int {` 来解决以下问题：\n\n计算 'words' 中作为字符串 's' 前缀的字符串数量。\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\"、\"ab\" 和 \"abc\" 是 \"abc\" 的前缀。\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" 和 \"hell\" 是 \"hello\" 的前缀。",
      "fr": "Écrire une fonction Swift `func countPrefixes(_ words: [String], _ s: String) -> Int {` pour résoudre le problème suivant :\n\nCompte le nombre de chaînes dans 'words' qui sont des préfixes de la chaîne 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", et \"abc\" sont des préfixes de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" et \"hell\" sont des préfixes de \"hello\".",
      "de": "Schreiben Sie eine Swift-Funktion `func countPrefixes(_ words: [String], _ s: String) -> Int {`, um das folgende Problem zu lösen:\n\nZählt die Anzahl der Zeichenfolgen in 'words', die Präfixe der Zeichenfolge 's' sind.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" und \"abc\" sind Präfixe von \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" und \"hell\" sind Präfixe von \"hello\".",
      "ha": "Rubuta aikin Swift `func countPrefixes(_ words: [String], _ s: String) -> Int {` don warware matsalar mai zuwa:\n\nYana ƙidaya adadin igiyoyi a cikin 'words' waɗanda suke farkon igiyar 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", da \"abc\" su ne farkon \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" da \"hell\" su ne farkon \"hello\".",
      "hi": "Swift फ़ंक्शन `func countPrefixes(_ words: [String], _ s: String) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n\n'words' में उन स्ट्रिंग्स की संख्या गिनें जो स्ट्रिंग 's' के उपसर्ग हैं।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", और \"abc\" \"abc\" के उपसर्ग हैं।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" और \"hell\" \"hello\" के उपसर्ग हैं।",
      "hu": "Írj egy Swift függvényt `func countPrefixes(_ words: [String], _ s: String) -> Int {` a következő probléma megoldására:\n\nMegszámolja, hogy hány string van a 'words' listában, amelyek a 's' string előtagjai.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" és \"abc\" az \"abc\" előtagjai.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" és \"hell\" a \"hello\" előtagjai."
    },
    "instruction_bertscore": {
      "sq": "0.9960569883060765",
      "hy": "0.9959260908849744",
      "bn": "0.9796155571462946",
      "bg": "0.9932467656751949",
      "zh": "0.9960569883060765",
      "fr": "0.9960569883060765",
      "de": "0.9973081610762152",
      "ha": "0.9961620637776439",
      "hi": "0.9765387725440642",
      "hu": "0.975512846626019"
    },
    "level": "easy",
    "test": "func checkCountPrefixes(_ countPrefixes: ([String], String) -> Int) {\nassert(countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\") == 2)\nassert(countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\") == 2)\nassert(countPrefixes([\"app\", \"apple\", \"apricot\", \"ap\"], \"apple\") == 3)\nassert(countPrefixes([\"blue\", \"blues\", \"blueberry\"], \"blue\") == 1)\nassert(countPrefixes([\"no\", \"match\"], \"yes\") == 0)\nassert(countPrefixes([], \"empty\") == 0)\nassert(countPrefixes([\"full\", \"fullest\", \"ful\"], \"fullest\") == 3)\n}\n\ncheckCountPrefixes(countPrefixes)",
    "entry_point": "countPrefixes",
    "signature": "func countPrefixes(_ words: [String], _ s: String) -> Int {",
    "docstring": {
      "en": "\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n",
      "sq": "Numëron numrin e vargjeve në 'words' që janë parashtesa të vargut 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", dhe \"abc\" janë parashtesa të \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" dhe \"hell\" janë parashtesa të \"hello\".",
      "hy": "Հաշվում է 'words' ցուցակում գտնվող այն տողերի քանակը, որոնք 's' տողի նախածանցներն են:\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" և \"abc\" տողերը \"abc\" տողի նախածանցներ են:\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" և \"hell\" տողերը \"hello\" տողի նախածանցներ են:",
      "bn": "'words' এর মধ্যে কতগুলি স্ট্রিং 's' এর উপসর্গ তা গণনা করে।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", এবং \"abc\" হল \"abc\" এর উপসর্গ।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" এবং \"hell\" হল \"hello\" এর উপসর্গ।",
      "bg": "Брои броя на низовете в 'words', които са префикси на низа 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" и \"abc\" са префикси на \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" и \"hell\" са префикси на \"hello\".",
      "zh": "计算“words”中作为字符串“s”前缀的字符串数量。\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\"、\"ab\" 和 \"abc\" 是 \"abc\" 的前缀。\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" 和 \"hell\" 是 \"hello\" 的前缀。",
      "fr": "Compte le nombre de chaînes dans 'words' qui sont des préfixes de la chaîne 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" et \"abc\" sont des préfixes de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" et \"hell\" sont des préfixes de \"hello\".",
      "de": "Zählt die Anzahl der Zeichenfolgen in 'words', die Präfixe der Zeichenfolge 's' sind.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" und \"abc\" sind Präfixe von \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" und \"hell\" sind Präfixe von \"hello\".",
      "ha": "Yana ƙididdige adadin igiyoyin rubutu a cikin 'words' waɗanda suke farkon rubutun 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", da \"abc\" su ne farkon \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" da \"hell\" su ne farkon \"hello\".",
      "hi": "'words' में उन स्ट्रिंग्स की संख्या गिनता है जो स्ट्रिंग 's' के उपसर्ग हैं।\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", और \"abc\" \"abc\" के उपसर्ग हैं।\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" और \"hell\" \"hello\" के उपसर्ग हैं।",
      "hu": "Megszámolja a 'words' listában található azon sztringek számát, amelyek a 's' sztring előtagjai.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // Az \"a\", \"ab\" és \"abc\" az \"abc\" előtagjai.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // A \"hello\" és a \"hell\" a \"hello\" előtagjai."
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9537089910694383",
      "bn": "0.9577509206931172",
      "bg": "0.9963668517004909",
      "zh": "0.979396269205632",
      "fr": "0.9853367080112425",
      "de": "0.999999801369619",
      "ha": "0.9940957119237379",
      "hi": "0.999999801369619",
      "hu": "0.9840744119397657"
    }
  },
  {
    "task_id": "Swift/20",
    "prompt": {
      "en": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "sq": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nGjen dy numra në 'nums' shuma e të cilëve është e barabartë me 'target', dhe kthen indeksat e tyre.\nSupozon që çdo hyrje ka saktësisht një zgjidhje, dhe i njëjti element nuk mund të përdoret dy herë.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "hy": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nԳտնում է 'nums'-ում երկու թվեր, որոնց գումարը հավասար է 'target'-ին, և վերադարձնում է դրանց ինդեքսները:\nԵնթադրվում է, որ յուրաքանչյուր մուտք ունի միայն մեկ լուծում, և նույն տարրը չի կարող օգտագործվել երկու անգամ:\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "bn": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\n'nums' তালিকায় এমন দুটি সংখ্যা খুঁজে বের করে যাদের যোগফল 'target' এর সমান হয়, এবং তাদের সূচকগুলি ফেরত দেয়।\nধরা হয়েছে যে প্রতিটি ইনপুটের ঠিক একটি সমাধান আছে, এবং একই উপাদান দুবার ব্যবহার করা যাবে না।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "bg": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nНамира две числа в 'nums', чиято сума е равна на 'target', и връща техните индекси.\nПредполага се, че всеки вход има точно едно решение и един и същ елемент не може да се използва два пъти.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "zh": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\n在'nums'中找到两个数，其和等于'target'，并返回它们的索引。\n假设每个输入有且只有一个解决方案，并且同一个元素不能被使用两次。\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "fr": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nTrouve deux nombres dans 'nums' dont la somme est égale à 'target', et renvoie leurs indices.\nSuppose que chaque entrée a exactement une solution, et le même élément ne peut pas être utilisé deux fois.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "de": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFindet zwei Zahlen in 'nums', deren Summe 'target' entspricht, und gibt deren Indizes zurück.\nEs wird angenommen, dass jede Eingabe genau eine Lösung hat und dass dasselbe Element nicht zweimal verwendet werden kann.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "ha": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nNemi lambobi biyu a cikin 'nums' da jimlarsu ta yi daidai da 'target', kuma mayar da alamun su.\nAna tsammanin kowace shigarwa tana da madaidaicin mafita guda ɗaya, kuma ba za a iya amfani da abu ɗaya sau biyu ba.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "hi": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\n'nums' में दो संख्याएँ खोजें जिनका योग 'target' के बराबर है, और उनके सूचकांक लौटाएँ।\nयह मानता है कि प्रत्येक इनपुट का ठीक एक समाधान है, और वही तत्व दो बार उपयोग नहीं किया जा सकता।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "hu": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nMegkeresi azokat a számokat a 'nums' listában, amelyek összege megegyezik a 'target' értékkel, és visszaadja az indexeiket.\nFeltételezi, hogy minden bemenetnek pontosan egy megoldása van, és ugyanazt az elemet nem lehet kétszer használni.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9920265792444976",
      "hy": "0.9794032212689683",
      "bn": "0.9679396660883018",
      "bg": "0.9855254068732257",
      "zh": "0.9889345001029274",
      "fr": "0.9890044179970517",
      "de": "0.99168731855369",
      "ha": "0.9924387372851449",
      "hi": "0.9835543976022164",
      "hu": "0.9688299274561002"
    },
    "canonical_solution": "var numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}",
    "instruction": {
      "en": "Write a Swift function `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` to solve the following problem:\n\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n",
      "sq": "Shkruani një funksion Swift `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` për të zgjidhur problemin e mëposhtëm:\n\nGjen dy numra në 'nums' shuma e të cilëve është e barabartë me 'target', dhe kthen indeksat e tyre.\nSupozon se çdo hyrje ka saktësisht një zgjidhje, dhe i njëjti element nuk mund të përdoret dy herë.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hy": "Գրեք Swift ֆունկցիա `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` հետևյալ խնդիրը լուծելու համար:\n\nԳտնում է երկու թիվ 'nums'-ում, որոնց գումարը հավասար է 'target'-ին, և վերադարձնում է նրանց ինդեքսները:\nԵնթադրվում է, որ յուրաքանչյուր մուտք ունի ճիշտ մեկ լուծում, և նույն տարրը չի կարող օգտագործվել երկու անգամ:\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "bn": "একটি Swift ফাংশন `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\n'nums' এ দুটি সংখ্যা খুঁজে বের করে যাদের যোগফল 'target' এর সমান, এবং তাদের সূচকগুলি ফেরত দেয়।\nপ্রত্যেক ইনপুটের ঠিক একটি সমাধান আছে বলে ধরে নেয়, এবং একই উপাদান দুবার ব্যবহার করা যাবে না।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "bg": "Напишете Swift функция `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` за решаване на следния проблем:\n\nНамира две числа в 'nums', чиято сума е равна на 'target', и връща техните индекси.\nПредполага се, че всеки вход има точно едно решение и един и същ елемент не може да се използва два пъти.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "zh": "编写一个 Swift 函数 `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` 来解决以下问题：\n\n在 'nums' 中找到两个数，其和等于 'target'，并返回它们的索引。\n假设每个输入只有一个解决方案，并且同一个元素不能使用两次。\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "fr": "Écrire une fonction Swift `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` pour résoudre le problème suivant :\n\nTrouve deux nombres dans 'nums' dont la somme est égale à 'target', et retourne leurs indices.\nSuppose que chaque entrée a exactement une solution, et que le même élément ne peut pas être utilisé deux fois.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "de": "Schreiben Sie eine Swift-Funktion `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {`, um das folgende Problem zu lösen:\n\nFindet zwei Zahlen in 'nums', deren Summe 'target' entspricht, und gibt deren Indizes zurück.\nEs wird angenommen, dass jede Eingabe genau eine Lösung hat und dass dasselbe Element nicht zweimal verwendet werden kann.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "ha": "Rubuta aikin Swift `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` don warware matsalar mai zuwa:\n\nNemi lambobi biyu a cikin 'nums' da jimlarsu ta yi daidai da 'target', kuma dawo da alamun su.\nAna ɗauka cewa kowane shigarwa yana da mafita ɗaya kawai, kuma ba za a iya amfani da abu ɗaya sau biyu ba.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hi": "Swift फ़ंक्शन `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\n'nums' में दो संख्याएँ ढूँढें जिनका योग 'target' के बराबर हो, और उनके सूचकांक लौटाएँ।\nमान लें कि प्रत्येक इनपुट का ठीक एक समाधान है, और एक ही तत्व का दो बार उपयोग नहीं किया जा सकता।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hu": "Írj egy Swift függvényt `func twoSum(_ nums: [Int], _ target: Int) -> [Int] {` a következő probléma megoldásához:\n\nMegkeresi azokat a számokat a 'nums' listában, amelyek összege megegyezik a 'target' értékkel, és visszaadja az indexeiket.\nFeltételezi, hogy minden bemenetnek pontosan egy megoldása van, és ugyanazt az elemet nem lehet kétszer felhasználni.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6"
    },
    "instruction_bertscore": {
      "sq": "0.9899087821219036",
      "hy": "0.9831603149262432",
      "bn": "0.9899087821219036",
      "bg": "0.9867829358155575",
      "zh": "0.9792264402298473",
      "fr": "0.9899087821219036",
      "de": "0.9909448381893815",
      "ha": "0.9924591962143915",
      "hi": "0.9801331879192715",
      "hu": "0.9695831338609845"
    },
    "level": "easy",
    "test": "func checkTwoSum(_ twoSum: ([Int], Int) -> [Int]) {\nassert(twoSum([2, 7, 11, 15], 9) == [0, 1])\nassert(twoSum([3, 2, 4], 6) == [1, 2])\nassert(twoSum([3, 3], 6) == [0, 1])\nassert(twoSum([1, 5, 4, 7], 8) == [0, 3])\nassert(twoSum([1, 2, 3, 4], 7) == [2, 3])\nassert(twoSum([4, 4], 8) == [0, 1])\nassert(twoSum([-1, -2, -3, -4, -5], -8) == [2, 4])\n}\n\ncheckTwoSum(twoSum)",
    "entry_point": "twoSum",
    "signature": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {",
    "docstring": {
      "en": "\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n",
      "sq": "Gjen dy numra në 'nums' shuma e të cilëve është e barabartë me 'target', dhe kthen indeksat e tyre. Supozon se çdo hyrje ka saktësisht një zgjidhje, dhe i njëjti element nuk mund të përdoret dy herë.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hy": "Գտնում է 'nums'-ում երկու թվեր, որոնց գումարը հավասար է 'target'-ին, և վերադարձնում է նրանց ինդեքսները։ \nԵնթադրում է, որ յուրաքանչյուր մուտք ունի ճիշտ մեկ լուծում, և նույն տարրը չի կարող օգտագործվել երկու անգամ։\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "bn": "'nums' তালিকায় দুটি সংখ্যা খুঁজে বের করে যাদের যোগফল 'target' এর সমান, এবং তাদের সূচকগুলি ফেরত দেয়। \nধরা হয়েছে যে প্রতিটি ইনপুটের ঠিক একটি সমাধান আছে, এবং একই উপাদান দুবার ব্যবহার করা যাবে না।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "bg": "Намира две числа в 'nums', чиято сума е равна на 'target', и връща техните индекси. Предполага се, че всеки вход има точно едно решение и един и същ елемент не може да бъде използван два пъти.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "zh": "在“nums”中找到两个数，其和等于“target”，并返回它们的索引。  \n假设每个输入有且只有一个解决方案，并且同一元素不能使用两次。  \n>>> twoSum([2, 7, 11, 15], 9)  \n[0, 1] // nums[0] + nums[1] == 9  \n>>> twoSum([3, 2, 4], 6)  \n[1, 2] // nums[1] + nums[2] == 6  ",
      "fr": "Trouve deux nombres dans 'nums' dont la somme est égale à 'target', et retourne leurs indices.\nSuppose que chaque entrée a exactement une solution, et que le même élément ne peut pas être utilisé deux fois.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "de": "Findet zwei Zahlen in 'nums', deren Summe 'target' ergibt, und gibt deren Indizes zurück.\nGeht davon aus, dass jede Eingabe genau eine Lösung hat und dass dasselbe Element nicht zweimal verwendet werden kann.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "ha": "Nemi lambobi biyu a cikin 'nums' waɗanda jimlarsu ta yi daidai da 'target', kuma dawo da alamun su. \nAna ɗauka cewa kowace shigarwa tana da mafita ɗaya kawai, kuma ba za a iya amfani da abu ɗaya sau biyu ba.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hi": "'nums' में दो संख्याएँ खोजता है जिनका योग 'target' के बराबर होता है, और उनके सूचकांक लौटाता है। यह मानता है कि प्रत्येक इनपुट का ठीक एक समाधान है, और वही तत्व दो बार उपयोग नहीं किया जा सकता।\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "hu": "Két számot talál a 'nums' listában, amelyek összege megegyezik a 'target' értékkel, és visszaadja azok indexeit.\nFeltételezi, hogy minden bemenetnek pontosan egy megoldása van, és ugyanazt az elemet nem lehet kétszer használni.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6"
    },
    "docstring_bertscore": {
      "sq": "0.985032406267497",
      "hy": "0.9885811366550663",
      "bn": "0.9498567534596477",
      "bg": "0.9818471694772216",
      "zh": "0.9802342907832183",
      "fr": "0.9777885549015357",
      "de": "0.9851684680785059",
      "ha": "0.9866158876651072",
      "hi": "0.9678860358854224",
      "hu": "0.9560607747808914"
    }
  },
  {
    "task_id": "Swift/21",
    "prompt": {
      "en": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "sq": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nPërcakton koordinatat e kulmit të katërt të një drejtkëndëshi kur jepen koordinatat e tre kulmeve.\nAnët e drejtkëndëshit supozohet të jenë paralele me boshtet e koordinatave.\n\n- Parametrat:\n- vertex1: Një dyshe që përfaqëson koordinatat e kulmit të parë.\n- vertex2: Një dyshe që përfaqëson koordinatat e kulmit të dytë.\n- vertex3: Një dyshe që përfaqëson koordinatat e kulmit të tretë.\n\n- Kthen: Një dyshe që përfaqëson koordinatat e kulmit të katërt.\n\nShembull përdorimi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "hy": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nՍահմանում է ուղղանկյան չորրորդ գագաթի կոորդինատները, երբ տրված են երեք գագաթների կոորդինատները։\nԵնթադրվում է, որ ուղղանկյան կողմերը զուգահեռ են կոորդինատային առանցքներին։\n\n- Պարամետրեր:\n- vertex1: Կոորդինատների առաջին գագաթը ներկայացնող զույգ։\n- vertex2: Կոորդինատների երկրորդ գագաթը ներկայացնող զույգ։\n- vertex3: Կոորդինատների երրորդ գագաթը ներկայացնող զույգ։\n\n- Վերադարձնում է: Կոորդինատների չորրորդ գագաթը ներկայացնող զույգ։\n\nՕրինակ օգտագործում:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "bn": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nযখন তিনটি শীর্ষবিন্দুর স্থানাঙ্ক দেওয়া হয় তখন একটি আয়তক্ষেত্রের চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক নির্ধারণ করে।\nআয়তক্ষেত্রের বাহুগুলি স্থানাঙ্ক অক্ষের সাথে সমান্তরাল বলে ধরা হয়।\n\n- প্যারামিটার:\n- vertex1: প্রথম শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টাপল।\n- vertex2: দ্বিতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টাপল।\n- vertex3: তৃতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টাপল।\n\n- রিটার্নস: চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টাপল।\n\nউদাহরণ ব্যবহার:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "bg": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nОпределя координатите на четвъртия връх на правоъгълник, когато са дадени координатите на три върха.\nПредполага се, че страните на правоъгълника са успоредни на координатните оси.\n\n- Параметри:\n- vertex1: Кортеж, представляващ координатите на първия връх.\n- vertex2: Кортеж, представляващ координатите на втория връх.\n- vertex3: Кортеж, представляващ координатите на третия връх.\n\n- Връща: Кортеж, представляващ координатите на четвъртия връх.\n\nПример за използване:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "zh": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\n确定矩形的第四个顶点的坐标，给定三个顶点的坐标。\n矩形的边假定与坐标轴平行。\n\n- 参数:\n- vertex1: 表示第一个顶点坐标的元组。\n- vertex2: 表示第二个顶点坐标的元组。\n- vertex3: 表示第三个顶点坐标的元组。\n\n- 返回: 表示第四个顶点坐标的元组。\n\n示例用法:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "fr": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDétermine les coordonnées du quatrième sommet d'un rectangle lorsque les coordonnées de trois sommets sont données.\nLes côtés du rectangle sont supposés être parallèles aux axes de coordonnées.\n\n- Paramètres :\n- vertex1 : Un tuple représentant les coordonnées du premier sommet.\n- vertex2 : Un tuple représentant les coordonnées du deuxième sommet.\n- vertex3 : Un tuple représentant les coordonnées du troisième sommet.\n\n- Renvoie : Un tuple représentant les coordonnées du quatrième sommet.\n\nExemple d'utilisation :\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "de": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nBestimmt die Koordinaten des vierten Scheitelpunkts eines Rechtecks, wenn die Koordinaten von drei Scheitelpunkten gegeben sind.\nEs wird angenommen, dass die Seiten des Rechtecks parallel zu den Koordinatenachsen verlaufen.\n\n- Parameter:\n- vertex1: Ein Tupel, das die Koordinaten des ersten Scheitelpunkts darstellt.\n- vertex2: Ein Tupel, das die Koordinaten des zweiten Scheitelpunkts darstellt.\n- vertex3: Ein Tupel, das die Koordinaten des dritten Scheitelpunkts darstellt.\n\n- Rückgabe: Ein Tupel, das die Koordinaten des vierten Scheitelpunkts darstellt.\n\nBeispielverwendung:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "ha": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nYana tantance ko'odinet na kusurwar hudu na murabba'i idan an bayar da ko'odinet na kusurwa uku.\nAna tsammanin bangarorin murabba'in suna daidai da ginshiƙan ko'odinet.\n\n- Parameters:\n- vertex1: Wata tupla da ke wakiltar ko'odinet na kusurwa ta farko.\n- vertex2: Wata tupla da ke wakiltar ko'odinet na kusurwa ta biyu.\n- vertex3: Wata tupla da ke wakiltar ko'odinet na kusurwa ta uku.\n\n- Returns: Wata tupla da ke wakiltar ko'odinet na kusurwa ta hudu.\n\nMisalin amfani:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "hi": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nजब तीन शीर्षों के निर्देशांक दिए जाते हैं, तो आयत के चौथे शीर्ष के निर्देशांक निर्धारित करता है।\nआयत की भुजाएँ निर्देशांक अक्षों के समानांतर मानी जाती हैं।\n\n- पैरामीटर्स:\n- vertex1: पहले शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक ट्यूपल।\n- vertex2: दूसरे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक ट्यूपल।\n- vertex3: तीसरे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक ट्यूपल।\n\n- रिटर्न्स: चौथे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक ट्यूपल।\n\nउदाहरण उपयोग:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "hu": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nMeghatározza egy téglalap negyedik csúcsának koordinátáit, ha három csúcs koordinátái adottak.\nFeltételezzük, hogy a téglalap oldalai párhuzamosak a koordinátatengelyekkel.\n\n- Paraméterek:\n- vertex1: Egy tuple, amely az első csúcs koordinátáit reprezentálja.\n- vertex2: Egy tuple, amely a második csúcs koordinátáit reprezentálja.\n- vertex3: Egy tuple, amely a harmadik csúcs koordinátáit reprezentálja.\n\n- Visszatér: Egy tuple, amely a negyedik csúcs koordinátáit reprezentálja.\n\nPélda használat:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9740900572066661",
      "hy": "0.9677763919150911",
      "bn": "0.9824202181265073",
      "bg": "0.9824202181265073",
      "zh": "0.9913208455006806",
      "fr": "0.9884180611122367",
      "de": "0.9824202181265073",
      "ha": "0.982390423569352",
      "hi": "0.9884180611122367",
      "hu": "0.9808548120935713"
    },
    "canonical_solution": "var xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}",
    "instruction": {
      "en": "Write a Swift function `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` to solve the following problem:\n\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n",
      "sq": "Shkruani një funksion Swift `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` për të zgjidhur problemin e mëposhtëm:\n\nPërcakton koordinatat e kulmit të katërt të një drejtkëndëshi kur jepen koordinatat e tre kulmeve.\nAnët e drejtkëndëshit supozohet të jenë paralele me boshtet e koordinatave.\n\n- Parametrat:\n- vertex1: Një dyshe që përfaqëson koordinatat e kulmit të parë.\n- vertex2: Një dyshe që përfaqëson koordinatat e kulmit të dytë.\n- vertex3: Një dyshe që përfaqëson koordinatat e kulmit të tretë.\n\n- Kthen: Një dyshe që përfaqëson koordinatat e kulmit të katërt.\n\nShembull përdorimi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hy": "Գրեք Swift ֆունկցիա `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` հետևյալ խնդիրը լուծելու համար:\n\nՈրոշում է ուղղանկյան չորրորդ գագաթի կոորդինատները, երբ տրված են երեք գագաթների կոորդինատները:\nԵնթադրվում է, որ ուղղանկյան կողմերը զուգահեռ են կոորդինատային առանցքներին:\n\n- Պարամետրեր:\n- vertex1: Tuple, որը ներկայացնում է առաջին գագաթի կոորդինատները:\n- vertex2: Tuple, որը ներկայացնում է երկրորդ գագաթի կոորդինատները:\n- vertex3: Tuple, որը ներկայացնում է երրորդ գագաթի կոորդինատները:\n\n- Վերադարձնում է: Tuple, որը ներկայացնում է չորրորդ գագաթի կոորդինատները:\n\nՕրինակ օգտագործում:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "bn": "একটি Swift ফাংশন `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nযখন তিনটি শীর্ষবিন্দুর স্থানাঙ্ক দেওয়া হয় তখন একটি আয়তক্ষেত্রের চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক নির্ধারণ করে।\nআয়তক্ষেত্রের বাহুগুলি স্থানাংক অক্ষের সমান্তরাল বলে ধরা হয়।\n\n- প্যারামিটারসমূহ:\n- vertex1: প্রথম শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n- vertex2: দ্বিতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n- vertex3: তৃতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n\n- রিটার্নস: চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n\nউদাহরণ ব্যবহার:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "bg": "Напишете Swift функция `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` за решаване на следния проблем:\n\nОпределя координатите на четвъртия връх на правоъгълник, когато са дадени координатите на три върха.\nПредполага се, че страните на правоъгълника са успоредни на координатните оси.\n\n- Параметри:\n- vertex1: Кортеж, представляващ координатите на първия връх.\n- vertex2: Кортеж, представляващ координатите на втория връх.\n- vertex3: Кортеж, представляващ координатите на третия връх.\n\n- Връща: Кортеж, представляващ координатите на четвъртия връх.\n\nПример за използване:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "zh": "编写一个 Swift 函数 `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` 来解决以下问题：\n\n确定矩形的第四个顶点的坐标，给定三个顶点的坐标。\n假设矩形的边与坐标轴平行。\n\n- 参数：\n- vertex1: 表示第一个顶点坐标的元组。\n- vertex2: 表示第二个顶点坐标的元组。\n- vertex3: 表示第三个顶点坐标的元组。\n\n- 返回：表示第四个顶点坐标的元组。\n\n示例用法：\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "fr": "Écrire une fonction Swift `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` pour résoudre le problème suivant :\n\nDétermine les coordonnées du quatrième sommet d'un rectangle lorsque les coordonnées de trois sommets sont données.\nOn suppose que les côtés du rectangle sont parallèles aux axes de coordonnées.\n\n- Paramètres :\n- vertex1 : Un tuple représentant les coordonnées du premier sommet.\n- vertex2 : Un tuple représentant les coordonnées du deuxième sommet.\n- vertex3 : Un tuple représentant les coordonnées du troisième sommet.\n\n- Renvoie : Un tuple représentant les coordonnées du quatrième sommet.\n\nExemple d'utilisation :\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "de": "Schreiben Sie eine Swift-Funktion `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {`, um das folgende Problem zu lösen:\n\nBestimmt die Koordinaten des vierten Scheitelpunkts eines Rechtecks, wenn die Koordinaten von drei Scheitelpunkten gegeben sind. Es wird angenommen, dass die Seiten des Rechtecks parallel zu den Koordinatenachsen verlaufen.\n\n- Parameter:\n- vertex1: Ein Tupel, das die Koordinaten des ersten Scheitelpunkts darstellt.\n- vertex2: Ein Tupel, das die Koordinaten des zweiten Scheitelpunkts darstellt.\n- vertex3: Ein Tupel, das die Koordinaten des dritten Scheitelpunkts darstellt.\n\n- Rückgabe: Ein Tupel, das die Koordinaten des vierten Scheitelpunkts darstellt.\n\nBeispielverwendung:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "ha": "Rubuta aikin Swift `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` don warware matsalar mai zuwa:\n\nYana tantance kooridinet na kusurwar hudu na murabba'i idan an bayar da kooridinet na kusurwai uku.\nAna ɗauka cewa gefen murabba'in suna daidai da ginshiƙan kooridinet.\n\n- Sigogi:\n- vertex1: Wani tuple da ke wakiltar kooridinet na kusurwar farko.\n- vertex2: Wani tuple da ke wakiltar kooridinet na kusurwar biyu.\n- vertex3: Wani tuple da ke wakiltar kooridinet na kusurwar uku.\n\n- Komawa: Wani tuple da ke wakiltar kooridinet na kusurwar hudu.\n\nMisalin amfani:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hi": "Swift फ़ंक्शन `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nजब तीन शीर्षों के निर्देशांक दिए जाते हैं, तो आयत के चौथे शीर्ष के निर्देशांक निर्धारित करता है।\nमाना जाता है कि आयत की भुजाएँ निर्देशांक अक्षों के समानांतर हैं।\n\n- पैरामीटर्स:\n- vertex1: पहले शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक युग्म।\n- vertex2: दूसरे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक युग्म।\n- vertex3: तीसरे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक युग्म।\n\n- रिटर्न: चौथे शीर्ष के निर्देशांक का प्रतिनिधित्व करने वाला एक युग्म।\n\nउदाहरण उपयोग:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hu": "Írj egy Swift függvényt `func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {` a következő probléma megoldására:\n\nMeghatározza egy téglalap negyedik csúcsának koordinátáit, ha meg van adva három csúcs koordinátája.\nFeltételezzük, hogy a téglalap oldalai párhuzamosak a koordináta-tengelyekkel.\n\n- Paraméterek:\n- vertex1: Egy tuple, amely az első csúcs koordinátáit jelöli.\n- vertex2: Egy tuple, amely a második csúcs koordinátáit jelöli.\n- vertex3: Egy tuple, amely a harmadik csúcs koordinátáit jelöli.\n\n- Visszatérési érték: Egy tuple, amely a negyedik csúcs koordinátáit jelöli.\n\nPélda használat:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)"
    },
    "instruction_bertscore": {
      "sq": "0.9791630771382971",
      "hy": "0.9660725405065739",
      "bn": "0.9890024316932413",
      "bg": "0.9826689033635629",
      "zh": "0.986324298265748",
      "fr": "0.9826689033635629",
      "de": "0.9807886681766866",
      "ha": "0.9822551562798673",
      "hi": "0.9411388660360264",
      "hu": "0.9764992450982383"
    },
    "level": "hard",
    "test": "func check(_ findFourthVertex: ((Int, Int), (Int, Int), (Int, Int)) -> (Int, Int)) {\nassert(findFourthVertex((5, 5), (5, 7), (7, 5)) == (7, 7))\nassert(findFourthVertex((2, 3), (2, 5), (4, 5)) == (4, 3))\nassert(findFourthVertex((10, 10), (10, 20), (20, 10)) == (20, 20))\nassert(findFourthVertex((15, 15), (10, 15), (10, 10)) == (15, 10))\nassert(findFourthVertex((3, 4), (5, 4), (3, 2)) == (5, 2))\nassert(findFourthVertex((8, 9), (8, 12), (11, 12)) == (11, 9))\n}\n\ncheck(findFourthVertex)",
    "entry_point": "findFourthVertex",
    "signature": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {",
    "docstring": {
      "en": "\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n",
      "sq": "Përcakton koordinatat e kulmit të katërt të një drejtkëndëshi kur jepen koordinatat e tre kulmeve.\nAnët e drejtkëndëshit supozohet të jenë paralele me boshtet e koordinatave.\n\n- Parametra:\n- vertex1: Një dyshe që përfaqëson koordinatat e kulmit të parë.\n- vertex2: Një dyshe që përfaqëson koordinatat e kulmit të dytë.\n- vertex3: Një dyshe që përfaqëson koordinatat e kulmit të tretë.\n\n- Kthen: Një dyshe që përfaqëson koordinatat e kulmit të katërt.\n\nShembull përdorimi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hy": "Սահմանում է ուղղանկյան չորրորդ գագաթնակետի կոորդինատները, երբ տրված են երեք գագաթների կոորդինատները:\nԵնթադրվում է, որ ուղղանկյան կողմերը զուգահեռ են կոորդինատային առանցքներին:\n\n- Պարամետրեր:\n- vertex1: Կոորդինատների առաջին գագաթը ներկայացնող tuple:\n- vertex2: Կոորդինատների երկրորդ գագաթը ներկայացնող tuple:\n- vertex3: Կոորդինատների երրորդ գագաթը ներկայացնող tuple:\n\n- Վերադարձնում է: Կոորդինատների չորրորդ գագաթը ներկայացնող tuple:\n\nՕրինակ օգտագործում:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "bn": "চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক নির্ধারণ করে যখন তিনটি শীর্ষবিন্দুর স্থানাঙ্ক দেওয়া হয়। আয়তক্ষেত্রের পাশগুলি স্থানাঙ্ক অক্ষের সাথে সমান্তরাল বলে ধরা হয়।\n\n- পরামিতি:\n- vertex1: প্রথম শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n- vertex2: দ্বিতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n- vertex3: তৃতীয় শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n\n- রিটার্ন: চতুর্থ শীর্ষবিন্দুর স্থানাঙ্ক উপস্থাপনকারী একটি টিউপল।\n\nউদাহরণ ব্যবহার:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "bg": "Определя координатите на четвъртата връхна точка на правоъгълник, когато са дадени координатите на три върхови точки. Страните на правоъгълника се предполага, че са успоредни на координатните оси.\n\n- Параметри:\n- vertex1: Кортеж, представляващ координатите на първата връхна точка.\n- vertex2: Кортеж, представляващ координатите на втората връхна точка.\n- vertex3: Кортеж, представляващ координатите на третата връхна точка.\n\n- Връща: Кортеж, представляващ координатите на четвъртата връхна точка.\n\nПример за използване:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "zh": "确定矩形第四个顶点的坐标，当给定三个顶点的坐标时。\n假设矩形的边与坐标轴平行。\n\n- 参数：\n- vertex1: 表示第一个顶点坐标的元组。\n- vertex2: 表示第二个顶点坐标的元组。\n- vertex3: 表示第三个顶点坐标的元组。\n\n- 返回：表示第四个顶点坐标的元组。\n\n示例用法：\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "fr": "Détermine les coordonnées du quatrième sommet d'un rectangle lorsque les coordonnées de trois sommets sont données. Les côtés du rectangle sont supposés être parallèles aux axes de coordonnées.\n\n- Paramètres:\n- vertex1: Un tuple représentant les coordonnées du premier sommet.\n- vertex2: Un tuple représentant les coordonnées du deuxième sommet.\n- vertex3: Un tuple représentant les coordonnées du troisième sommet.\n\n- Retourne: Un tuple représentant les coordonnées du quatrième sommet.\n\nExemple d'utilisation :\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "de": "Bestimmt die Koordinaten des vierten Scheitelpunkts eines Rechtecks, wenn die Koordinaten von drei Scheitelpunkten gegeben sind. Es wird angenommen, dass die Seiten des Rechtecks parallel zu den Koordinatenachsen verlaufen.\n\n- Parameter:\n- vertex1: Ein Tupel, das die Koordinaten des ersten Scheitelpunkts darstellt.\n- vertex2: Ein Tupel, das die Koordinaten des zweiten Scheitelpunkts darstellt.\n- vertex3: Ein Tupel, das die Koordinaten des dritten Scheitelpunkts darstellt.\n\n- Rückgabewert: Ein Tupel, das die Koordinaten des vierten Scheitelpunkts darstellt.\n\nBeispielverwendung:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "ha": "Yana ƙayyade daidaitattun wuraren kusurwar ta huɗu na murabba'i lokacin da aka ba da daidaitattun wuraren kusurwoyi uku.\nAna ɗauka cewa gefen murabba'in suna daidai da ginshiƙan daidaitawa.\n\n- Sigogi:\n- vertex1: Wani tuple da ke wakiltar daidaitattun wuraren kusurwar farko.\n- vertex2: Wani tuple da ke wakiltar daidaitattun wuraren kusurwar na biyu.\n- vertex3: Wani tuple da ke wakiltar daidaitattun wuraren kusurwar na uku.\n\n- Komawa: Wani tuple da ke wakiltar daidaitattun wuraren kusurwar ta huɗu.\n\nMisalin amfani:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hi": "चौथे शीर्ष बिंदु के निर्देशांक निर्धारित करता है जब तीन शीर्ष बिंदुओं के निर्देशांक दिए जाते हैं। आयत की भुजाएँ समन्वय अक्षों के समानांतर मानी जाती हैं।\n\n- पैरामीटर्स:\n- vertex1: पहले शीर्ष बिंदु के निर्देशांक का प्रतिनिधित्व करने वाला एक टपल।\n- vertex2: दूसरे शीर्ष बिंदु के निर्देशांक का प्रतिनिधित्व करने वाला एक टपल।\n- vertex3: तीसरे शीर्ष बिंदु के निर्देशांक का प्रतिनिधित्व करने वाला एक टपल।\n\n- रिटर्न्स: चौथे शीर्ष बिंदु के निर्देशांक का प्रतिनिधित्व करने वाला एक टपल।\n\nउदाहरण उपयोग:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "hu": "Meghatározza egy téglalap negyedik csúcsának koordinátáit, ha három csúcs koordinátái adottak. A téglalap oldalai párhuzamosak a koordinátatengelyekkel.\n\n- Paraméterek:\n- vertex1: Egy tuple, amely az első csúcs koordinátáit képviseli.\n- vertex2: Egy tuple, amely a második csúcs koordinátáit képviseli.\n- vertex3: Egy tuple, amely a harmadik csúcs koordinátáit képviseli.\n\n- Visszatér: Egy tuple, amely a negyedik csúcs koordinátáit képviseli.\n\nPélda használat:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)"
    },
    "docstring_bertscore": {
      "sq": "0.9661754310439499",
      "hy": "0.9761244295692254",
      "bn": "0.9731334532916021",
      "bg": "0.9855279890681791",
      "zh": "0.9825169511220712",
      "fr": "0.9773984448331832",
      "de": "0.9716999378316733",
      "ha": "0.9763717243936139",
      "hi": "0.9846887757083067",
      "hu": "0.9840271379090795"
    }
  },
  {
    "task_id": "Swift/22",
    "prompt": {
      "en": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n*/",
      "sq": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nKjo funksion llogarit numrin e figurave të shahut që duhet të shtohen ose hiqen për të plotësuar një set standard shahu. Një set i plotë përbëhet nga 1 Mbret, 1 Mbretëreshë, 2 Topa, 2 Oficera, 2 Kalorës dhe 8 Ushtarë.\n\nHyrja është një varg me gjashtë numra të plotë që përfaqësojnë numrin e secilës figurë në rendin: Mbret, Mbretëreshë, Top, Oficer, Kalorës, Ushtar. Çdo numër është midis 0 dhe 10 përfshirë.\n\nFunksioni kthen një varg me gjashtë numra të plotë që tregojnë sa figura të secilit lloj duhet të shtohen (numër pozitiv) ose të hiqen (numër negativ) për të plotësuar setin.\n\nShembull:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti është tashmë i plotë\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Shto 1 Mbret, hiq 1 Mbretëreshë, shto 1 Top, shto 3 Ushtarë\n*/",
      "hy": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nԱյս ֆունկցիան հաշվարկում է շախմատի խաղաքարերի այն քանակը, որը պետք է ավելացնել կամ հեռացնել՝ ստանդարտ շախմատի հավաքածուն ամբողջացնելու համար: Ամբողջական հավաքածուն բաղկացած է 1 Թագավորից, 1 Թագուհուց, 2 Նավակներից, 2 Փիղերից, 2 Ձիերից և 8 Զինվորներից:\n\nՄուտքը վեց ամբողջ թվերի զանգված է, որը ներկայացնում է յուրաքանչյուր խաղաքարի քանակը հետևյալ հերթականությամբ՝ Թագավոր, Թագուհի, Նավակ, Փիղ, Ձի, Զինվոր: Յուրաքանչյուր թիվ գտնվում է 0-ից 10 միջակայքում ներառյալ:\n\nՖունկցիան վերադարձնում է վեց ամբողջ թվերի զանգված, որը ցույց է տալիս, թե քանի խաղաքար պետք է ավելացնել (դրական թիվ) կամ հեռացնել (բացասական թիվ) հավաքածուն ամբողջացնելու համար:\n\nՕրինակ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Հավաքածուն արդեն ամբողջական է\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ավելացնել 1 Թագավոր, հեռացնել 1 Թագուհի, ավելացնել 1 Նավակ, ավելացնել 3 Զինվոր\n*/",
      "bn": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nএই ফাংশনটি একটি সম্পূর্ণ দাবার সেট সম্পূর্ণ করতে কতগুলো দাবার গুটি যোগ বা বিয়োগ করতে হবে তা গণনা করে। একটি সম্পূর্ণ সেটে থাকে ১টি রাজা, ১টি রাণী, ২টি রুক, ২টি বিশপ, ২টি নাইট এবং ৮টি প্যাদ।\n\nইনপুটটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে যা প্রতিটি গুটির সংখ্যা নির্দেশ করে এই ক্রমে: রাজা, রাণী, রুক, বিশপ, নাইট, প্যাদ। প্রতিটি সংখ্যা ০ থেকে ১০ এর মধ্যে অন্তর্ভুক্ত।\n\nফাংশনটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে প্রদান করে যা নির্দেশ করে প্রতিটি ধরনের কতগুলো গুটি যোগ (ধনাত্মক সংখ্যা) বা বিয়োগ (ঋণাত্মক সংখ্যা) করতে হবে সেট সম্পূর্ণ করতে।\n\nউদাহরণ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // সেটটি ইতিমধ্যেই সম্পূর্ণ\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // ১টি রাজা যোগ করুন, ১টি রাণী বিয়োগ করুন, ১টি রুক যোগ করুন, ৩টি প্যাদ যোগ করুন\n*/",
      "bg": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nТази функция изчислява броя на шахматните фигури, които трябва да бъдат добавени или премахнати, за да се завърши стандартен шахматен комплект. Пълен комплект се състои от 1 Цар, 1 Царица, 2 Топа, 2 Офицера, 2 Коня и 8 Пешки.\n\nВходът е масив от шест цели числа, представляващи броя на всяка фигура в следния ред: Цар, Царица, Топ, Офицер, Кон, Пешка. Всяко число е между 0 и 10 включително.\n\nФункцията връща масив от шест цели числа, указващи колко фигури от всеки тип трябва да бъдат добавени (положително число) или премахнати (отрицателно число), за да се завърши комплектът.\n\nПример:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Комплектът вече е завършен\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Добавете 1 Цар, премахнете 1 Царица, добавете 1 Топ, добавете 3 Пешки\n*/",
      "zh": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\n此函数计算需要添加或移除多少棋子才能完成一个标准的国际象棋套装。一个完整的套装包括1个国王，1个皇后，2个车，2个象，2个马和8个兵。\n\n输入是一个包含六个整数的数组，表示每种棋子的数量，顺序为：国王，皇后，车，象，马，兵。每个数字在0到10之间（包括0和10）。\n\n函数返回一个包含六个整数的数组，指示需要添加（正数）或移除（负数）多少个每种类型的棋子以完成套装。\n\n例子:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // 套装已经完整\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 添加1个国王，移除1个皇后，添加1个车，添加3个兵\n*/",
      "fr": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nCette fonction calcule le nombre de pièces d'échecs qui doivent être ajoutées ou retirées pour compléter un jeu d'échecs standard. Un jeu complet se compose de 1 Roi, 1 Reine, 2 Tours, 2 Fous, 2 Cavaliers et 8 Pions.\n\nL'entrée est un tableau de six entiers représentant le nombre de chaque pièce dans l'ordre : Roi, Reine, Tour, Fou, Cavalier, Pion. Chaque nombre est compris entre 0 et 10 inclus.\n\nLa fonction renvoie un tableau de six entiers indiquant combien de pièces de chaque type doivent être ajoutées (nombre positif) ou retirées (nombre négatif) pour compléter le jeu.\n\nExemple :\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Le jeu est déjà complet\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ajouter 1 Roi, retirer 1 Reine, ajouter 1 Tour, ajouter 3 Pions\n*/",
      "de": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nDiese Funktion berechnet die Anzahl der Schachfiguren, die hinzugefügt oder entfernt werden müssen, um ein vollständiges Standardschachset zu vervollständigen. Ein vollständiges Set besteht aus 1 König, 1 Dame, 2 Türmen, 2 Läufern, 2 Springern und 8 Bauern.\n\nDie Eingabe ist ein Array von sechs ganzen Zahlen, das die Anzahl jeder Figur in der Reihenfolge: König, Dame, Turm, Läufer, Springer, Bauer darstellt. Jede Zahl liegt zwischen 0 und 10 einschließlich.\n\nDie Funktion gibt ein Array von sechs ganzen Zahlen zurück, das angibt, wie viele Figuren von jedem Typ hinzugefügt (positive Zahl) oder entfernt (negative Zahl) werden müssen, um das Set zu vervollständigen.\n\nBeispiel:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Das Set ist bereits vollständig\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 König hinzufügen, 1 Dame entfernen, 1 Turm hinzufügen, 3 Bauern hinzufügen\n*/",
      "ha": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nWannan aikin yana ƙididdige yawan ƙwallan catur da ake buƙatar ƙara ko cirewa don kammala saitin catur na al'ada. Cikakken saiti yana ƙunshe da Sarki 1, Sarauniya 1, Rook 2, Bishop 2, Knight 2, da Pawn 8.\n\nShigarwar shine jerin lambobi guda shida waɗanda ke wakiltar yawan kowane irin ƙwallo a tsari: Sarki, Sarauniya, Rook, Bishop, Knight, Pawn. Kowanne lamba yana tsakanin 0 da 10.\n\nAikin yana dawowa da jerin lambobi guda shida waɗanda ke nuna yawan ƙwallan kowane nau'i da ake buƙatar ƙara (lamba mai kyau) ko cirewa (lamba mara kyau) don kammala saitin.\n\nMisali:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Saitin ya riga ya cika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ƙara Sarki 1, cire Sarauniya 1, ƙara Rook 1, ƙara Pawn 3\n*/",
      "hi": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nयह फ़ंक्शन यह गणना करता है कि मानक शतरंज सेट को पूरा करने के लिए कितने शतरंज के टुकड़े जोड़े या हटाए जाने की आवश्यकता है। एक पूर्ण सेट में 1 राजा, 1 रानी, 2 हाथी, 2 ऊंट, 2 घोड़े, और 8 प्यादे होते हैं।\n\nइनपुट छह पूर्णांकों की एक श्रृंखला है जो क्रम में प्रत्येक टुकड़े की गिनती का प्रतिनिधित्व करती है: राजा, रानी, हाथी, ऊंट, घोड़ा, प्यादा। प्रत्येक संख्या 0 और 10 के बीच शामिल है।\n\nयह फ़ंक्शन छह पूर्णांकों की एक श्रृंखला लौटाता है जो यह दर्शाता है कि सेट को पूरा करने के लिए प्रत्येक प्रकार के कितने टुकड़े जोड़े (सकारात्मक संख्या) या हटाए (ऋणात्मक संख्या) जाने की आवश्यकता है।\n\nउदाहरण:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // सेट पहले से ही पूरा है\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 राजा जोड़ें, 1 रानी हटाएं, 1 हाथी जोड़ें, 3 प्यादे जोड़ें\n*/",
      "hu": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nEz a függvény kiszámítja, hogy hány sakkfigurát kell hozzáadni vagy eltávolítani ahhoz, hogy egy teljes szabványos sakk készletet kapjunk. Egy teljes készlet tartalmaz 1 Királyt, 1 Királynőt, 2 Bástyát, 2 Főt, 2 Lovagot és 8 Gyalogot.\n\nA bemenet egy hat egész számot tartalmazó tömb, amely az egyes figurák számát jelöli ebben a sorrendben: Király, Királynő, Bástya, Fő, Lovag, Gyalog. Minden szám 0 és 10 között van, beleértve.\n\nA függvény egy hat egész számot tartalmazó tömböt ad vissza, amely jelzi, hogy hány darabot kell hozzáadni (pozitív szám) vagy eltávolítani (negatív szám) az egyes típusokból a készlet teljessé tételéhez.\n\nPélda:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // A készlet már teljes\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Hozzáad 1 Királyt, eltávolít 1 Királynőt, hozzáad 1 Bástyát, hozzáad 3 Gyalogot\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9980560044608116",
      "hy": "0.9872306486944101",
      "bn": "0.9502621580673398",
      "bg": "0.9945396508253509",
      "zh": "0.9564081793173214",
      "fr": "0.9980560044608116",
      "de": "0.9664598697495919",
      "ha": "0.9798020710740863",
      "hi": "0.9518198175154154",
      "hu": "0.9817879776236732"
    },
    "canonical_solution": "let idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}",
    "instruction": {
      "en": "Write a Swift function `func adjustChessPieces(_ counts: [Int]) -> [Int] {` to solve the following problem:\n\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n",
      "sq": "Shkruani një funksion Swift `func adjustChessPieces(_ counts: [Int]) -> [Int] {` për të zgjidhur problemin e mëposhtëm:\n\nKy funksion llogarit numrin e figurave të shahut që duhet të shtohen ose hiqen për të plotësuar një set standard shahu. Një set i plotë përbëhet nga 1 Mbret, 1 Mbretëreshë, 2 Topa, 2 Oficerë, 2 Kalorës dhe 8 Ushtarë.\n\nHyrja është një varg me gjashtë numra të plotë që përfaqësojnë numrin e secilës figurë në rendin: Mbret, Mbretëreshë, Top, Oficer, Kalorës, Ushtar. Çdo numër është midis 0 dhe 10 përfshirë.\n\nFunksioni kthen një varg me gjashtë numra të plotë që tregojnë sa figura të secilit lloj duhet të shtohen (numër pozitiv) ose të hiqen (numër negativ) për të plotësuar setin.\n\nShembull:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti është tashmë i plotë\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Shtoni 1 Mbret, hiqni 1 Mbretëreshë, shtoni 1 Top, shtoni 3 Ushtarë",
      "hy": "Գրեք Swift ֆունկցիա `func adjustChessPieces(_ counts: [Int]) -> [Int] {` հետևյալ խնդիրը լուծելու համար:\n\nԱյս ֆունկցիան հաշվում է, թե քանի շախմատի խաղաքար պետք է ավելացնել կամ հեռացնել, որպեսզի ստացվի ստանդարտ շախմատի հավաքածու: Լրիվ հավաքածուն բաղկացած է 1 Արքայից, 1 Թագուհուց, 2 Նավակներից, 2 Փիղերից, 2 Ձիերից և 8 Զինվորներից:\n\nՄուտքը վեց ամբողջ թվերի զանգված է, որը ներկայացնում է յուրաքանչյուր խաղաքարի քանակը հետևյալ կարգով՝ Արքա, Թագուհի, Նավակ, Փիղ, Ձի, Զինվոր: Յուրաքանչյուր թիվ գտնվում է 0-ից 10 միջակայքում ներառյալ:\n\nՖունկցիան վերադարձնում է վեց ամբողջ թվերի զանգված, որը ցույց է տալիս, թե քանի խաղաքար պետք է ավելացնել (դրական թիվ) կամ հեռացնել (բացասական թիվ) հավաքածուն լրացնելու համար:\n\nՕրինակ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Հավաքածուն արդեն լրիվ է\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ավելացնել 1 Արքա, հեռացնել 1 Թագուհի, ավելացնել 1 Նավակ, ավելացնել 3 Զինվոր",
      "bn": "Swift ফাংশন `func adjustChessPieces(_ counts: [Int]) -> [Int] {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএই ফাংশনটি কতগুলো দাবার গুটি যোগ বা বাদ দিতে হবে তা গণনা করে একটি সম্পূর্ণ দাবার সেট সম্পূর্ণ করতে। একটি সম্পূর্ণ সেটে থাকে 1টি রাজা, 1টি রাণী, 2টি রুক, 2টি বিশপ, 2টি নাইট এবং 8টি পন।\n\nইনপুটটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে যা প্রতিটি গুটির সংখ্যা নির্দেশ করে নিম্নলিখিত ক্রমে: রাজা, রাণী, রুক, বিশপ, নাইট, পন। প্রতিটি সংখ্যা 0 থেকে 10 এর মধ্যে অন্তর্ভুক্ত।\n\nফাংশনটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে ফেরত দেয় যা নির্দেশ করে কতগুলো গুটির প্রকার যোগ করতে হবে (ধনাত্মক সংখ্যা) বা বাদ দিতে হবে (ঋণাত্মক সংখ্যা) সেটটি সম্পূর্ণ করতে।\n\nউদাহরণ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // সেটটি ইতিমধ্যে সম্পূর্ণ\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1টি রাজা যোগ করুন, 1টি রাণী বাদ দিন, 1টি রুক যোগ করুন, 3টি পন যোগ করুন",
      "bg": "Напишете функция на Swift `func adjustChessPieces(_ counts: [Int]) -> [Int] {`, за да решите следния проблем:\n\nТази функция изчислява броя на шахматните фигури, които трябва да бъдат добавени или премахнати, за да се завърши стандартен шахматен комплект. Пълен комплект се състои от 1 Цар, 1 Царица, 2 Топа, 2 Офицера, 2 Коня и 8 Пешки.\n\nВходът е масив от шест цели числа, представляващи броя на всяка фигура в следния ред: Цар, Царица, Топ, Офицер, Кон, Пешка. Всяко число е между 0 и 10 включително.\n\nФункцията връща масив от шест цели числа, указващи колко фигури от всеки тип трябва да бъдат добавени (положително число) или премахнати (отрицателно число), за да се завърши комплектът.\n\nПример:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Комплектът вече е завършен\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Добавете 1 Цар, премахнете 1 Царица, добавете 1 Топ, добавете 3 Пешки",
      "zh": "编写一个 Swift 函数 `func adjustChessPieces(_ counts: [Int]) -> [Int] {` 来解决以下问题：\n\n该函数计算需要添加或移除多少棋子以完成一副标准国际象棋棋子集。完整的棋子集包括 1 个国王，1 个王后，2 个车，2 个象，2 个马，和 8 个兵。\n\n输入是一个包含六个整数的数组，表示每种棋子的数量，顺序为：国王，王后，车，象，马，兵。每个数字在 0 到 10 之间（包括 0 和 10）。\n\n该函数返回一个包含六个整数的数组，表示为了完成棋子集需要添加（正数）或移除（负数）多少个每种类型的棋子。\n\n示例：\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // 棋子集已经完整\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 添加 1 个国王，移除 1 个王后，添加 1 个车，添加 3 个兵",
      "fr": "Écrire une fonction Swift `func adjustChessPieces(_ counts: [Int]) -> [Int] {` pour résoudre le problème suivant :\n\nCette fonction calcule le nombre de pièces d'échecs qui doivent être ajoutées ou retirées pour compléter un jeu d'échecs standard. Un jeu complet se compose de 1 Roi, 1 Reine, 2 Tours, 2 Fous, 2 Cavaliers et 8 Pions.\n\nL'entrée est un tableau de six entiers représentant le nombre de chaque pièce dans l'ordre : Roi, Reine, Tour, Fou, Cavalier, Pion. Chaque nombre est compris entre 0 et 10 inclus.\n\nLa fonction renvoie un tableau de six entiers indiquant combien de pièces de chaque type doivent être ajoutées (nombre positif) ou retirées (nombre négatif) pour compléter le jeu.\n\nExemple :\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Le jeu est déjà complet\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ajouter 1 Roi, retirer 1 Reine, ajouter 1 Tour, ajouter 3 Pions",
      "de": "Schreiben Sie eine Swift-Funktion `func adjustChessPieces(_ counts: [Int]) -> [Int] {`, um das folgende Problem zu lösen:\n\nDiese Funktion berechnet die Anzahl der Schachfiguren, die hinzugefügt oder entfernt werden müssen, um ein vollständiges Schachset zu vervollständigen. Ein vollständiges Set besteht aus 1 König, 1 Dame, 2 Türmen, 2 Läufern, 2 Springern und 8 Bauern.\n\nDie Eingabe ist ein Array von sechs ganzen Zahlen, das die Anzahl jeder Figur in der Reihenfolge: König, Dame, Turm, Läufer, Springer, Bauer darstellt. Jede Zahl liegt zwischen 0 und 10 einschließlich.\n\nDie Funktion gibt ein Array von sechs ganzen Zahlen zurück, das angibt, wie viele Figuren von jedem Typ hinzugefügt (positive Zahl) oder entfernt (negative Zahl) werden müssen, um das Set zu vervollständigen.\n\nBeispiel:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Das Set ist bereits vollständig\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 König hinzufügen, 1 Dame entfernen, 1 Turm hinzufügen, 3 Bauern hinzufügen",
      "ha": "Rubuta aikin Swift `func adjustChessPieces(_ counts: [Int]) -> [Int] {` don warware matsalar mai zuwa:\n\nWannan aikin yana ƙididdige yawan kayan wasan catur da ake buƙatar ƙara ko cirewa don kammala saitin catur na al'ada. Saitin cike ya ƙunshi Sarki 1, Sarauniya 1, Rooks 2, Bishops 2, Knights 2, da Pawns 8.\n\nShigarwar shi ne jerin lambobi guda shida da ke wakiltar adadin kowanne kayan a cikin tsari: Sarki, Sarauniya, Rook, Bishop, Knight, Pawn. Kowanne lamba yana tsakanin 0 da 10 ciki har da.\n\nAikin yana mayar da jerin lambobi guda shida da ke nuna yawan kayan kowanne nau'i da ake buƙatar ƙara (lamba mai kyau) ko cirewa (lamba mara kyau) don kammala saitin.\n\nMisali:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Saitin ya riga ya cika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ƙara Sarki 1, cire Sarauniya 1, ƙara Rook 1, ƙara Pawns 3",
      "hi": "Swift फ़ंक्शन `func adjustChessPieces(_ counts: [Int]) -> [Int] {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nयह फ़ंक्शन उन शतरंज के मोहरों की संख्या की गणना करता है जिन्हें एक मानक शतरंज सेट को पूरा करने के लिए जोड़ा या हटाया जाना चाहिए। एक पूर्ण सेट में 1 राजा, 1 रानी, 2 हाथी, 2 ऊंट, 2 घोड़े, और 8 प्यादे होते हैं।\n\nइनपुट छह पूर्णांकों की एक सूची है जो क्रम में प्रत्येक मोहरे की संख्या का प्रतिनिधित्व करती है: राजा, रानी, हाथी, ऊंट, घोड़ा, प्यादा। प्रत्येक संख्या 0 और 10 के बीच (समावेशी) होती है।\n\nफ़ंक्शन छह पूर्णांकों की एक सूची लौटाता है जो इंगित करती है कि सेट को पूरा करने के लिए प्रत्येक प्रकार के कितने मोहरे जोड़े (धनात्मक संख्या) या हटाए (ऋणात्मक संख्या) जाने की आवश्यकता है।\n\nउदाहरण:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // सेट पहले से ही पूर्ण है\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 राजा जोड़ें, 1 रानी हटाएं, 1 हाथी जोड़ें, 3 प्यादे जोड़ें",
      "hu": "Írj egy Swift függvényt `func adjustChessPieces(_ counts: [Int]) -> [Int] {` a következő probléma megoldására:\n\nEz a függvény kiszámítja, hogy hány sakkfigurát kell hozzáadni vagy eltávolítani ahhoz, hogy egy teljes sakk készletet kapjunk. Egy teljes készlet tartalmaz 1 királyt, 1 királynőt, 2 bástyát, 2 futót, 2 lovat és 8 gyalogot.\n\nA bemenet egy hat egész számot tartalmazó tömb, amely az egyes figurák számát jelöli a következő sorrendben: király, királynő, bástya, futó, ló, gyalog. Minden szám 0 és 10 között van, beleértve.\n\nA függvény visszatér egy hat egész számot tartalmazó tömbbel, amely jelzi, hogy hány darabot kell hozzáadni (pozitív szám) vagy eltávolítani (negatív szám) az egyes típusokból a készlet teljessé tételéhez.\n\nPélda:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // A készlet már teljes\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Adj hozzá 1 királyt, távolíts el 1 királynőt, adj hozzá 1 bástyát, adj hozzá 3 gyalogot"
    },
    "instruction_bertscore": {
      "sq": "0.9980548126785254",
      "hy": "0.9809878944488647",
      "bn": "0.949926869984153",
      "bg": "0.986819483805668",
      "zh": "0.9557270757407528",
      "fr": "0.9980548126785254",
      "de": "0.9620796725870105",
      "ha": "0.9850218788573022",
      "hi": "0.9465134068860684",
      "hu": "0.9472104008931198"
    },
    "level": "middle",
    "test": "func testAdjustChessPieces() {\nassert(adjustChessPieces([1, 1, 2, 2, 2, 8]) == [0, 0, 0, 0, 0, 0], \"Test Case 1 Failed\")\nassert(adjustChessPieces([0, 2, 1, 2, 2, 5]) == [1, -1, 1, 0, 0, 3], \"Test Case 2 Failed\")\nassert(adjustChessPieces([1, 0, 2, 1, 3, 8]) == [0, 1, 0, 1, -1, 0], \"Test Case 3 Failed\")\nassert(adjustChessPieces([0, 1, 0, 0, 0, 0]) == [1, 0, 2, 2, 2, 8], \"Test Case 4 Failed\")\nassert(adjustChessPieces([2, 2, 3, 3, 3, 10]) == [-1, -1, -1, -1, -1, -2], \"Test Case 5 Failed\")\n}\n\ntestAdjustChessPieces()",
    "entry_point": "adjustChessPieces",
    "signature": "func adjustChessPieces(_ counts: [Int]) -> [Int] {",
    "docstring": {
      "en": "\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n",
      "sq": "Kjo funksion llogarit numrin e figurave të shahut që duhet të shtohen ose të hiqen për të plotësuar një set standard shahu. Një set i plotë përbëhet nga 1 Mbret, 1 Mbretëreshë, 2 Kulla, 2 Oficerë, 2 Kalorës dhe 8 Ushtarë.\n\nHyrja është një varg me gjashtë numra të plotë që përfaqësojnë numrin e secilës figurë në rendin: Mbret, Mbretëreshë, Kullë, Oficer, Kalorës, Ushtar. Çdo numër është midis 0 dhe 10 përfshirë.\n\nFunksioni kthen një varg me gjashtë numra të plotë që tregon sa figura të secilit lloj duhet të shtohen (numër pozitiv) ose të hiqen (numër negativ) për të plotësuar setin.\n\nShembull:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti është tashmë i plotë\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Shto 1 Mbret, hiq 1 Mbretëreshë, shto 1 Kullë, shto 3 Ushtarë",
      "hy": "Այս ֆունկցիան հաշվում է, թե քանի շախմատի խաղաքար պետք է ավելացնել կամ հեռացնել՝ ստանդարտ շախմատի հավաքածուն լրացնելու համար։ Լրիվ հավաքածուն բաղկացած է 1 Թագավորից, 1 Թագուհուց, 2 Նավակներից, 2 Փիղերից, 2 Ձիերից և 8 Զինվորներից։\n\nՄուտքը վեց ամբողջ թվերի զանգված է, որը ներկայացնում է յուրաքանչյուր խաղաքարի քանակը հետևյալ կարգով՝ Թագավոր, Թագուհի, Նավակ, Փիղ, Ձի, Զինվոր։ Յուրաքանչյուր թիվ 0-ից 10 ներառյալ միջակայքում է։\n\nՖունկցիան վերադարձնում է վեց ամբողջ թվերի զանգված, որը ցույց է տալիս, թե քանի խաղաքար պետք է ավելացնել (դրական թիվ) կամ հեռացնել (բացասական թիվ) հավաքածուն լրացնելու համար։\n\nՕրինակ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Հավաքածուն արդեն լրիվ է\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ավելացնել 1 Թագավոր, հեռացնել 1 Թագուհի, ավելացնել 1 Նավակ, ավելացնել 3 Զինվոր",
      "bn": "এই ফাংশনটি একটি সম্পূর্ণ দাবার সেট সম্পূর্ণ করতে কতগুলি দাবার গুটি যোগ বা বিয়োগ করতে হবে তা গণনা করে। একটি সম্পূর্ণ সেটে ১টি রাজা, ১টি রাণী, ২টি রুক, ২টি বিশপ, ২টি নাইট এবং ৮টি পন থাকে।\n\nইনপুটটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে যা প্রতিটি গুটির সংখ্যা নির্দেশ করে নিম্নলিখিত ক্রমে: রাজা, রাণী, রুক, বিশপ, নাইট, পন। প্রতিটি সংখ্যা ০ থেকে ১০ এর মধ্যে অন্তর্ভুক্ত।\n\nফাংশনটি ছয়টি পূর্ণসংখ্যার একটি অ্যারে ফেরত দেয় যা নির্দেশ করে যে সম্পূর্ণ সেট করতে প্রতিটি প্রকারের কতগুলি গুটি যোগ (ধনাত্মক সংখ্যা) বা বিয়োগ (ঋণাত্মক সংখ্যা) করতে হবে।\n\nউদাহরণ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // সেটটি ইতিমধ্যে সম্পূর্ণ\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // ১টি রাজা যোগ, ১টি রাণী বিয়োগ, ১টি রুক যোগ, ৩টি পন যোগ",
      "bg": "Тази функция изчислява броя на шахматните фигури, които трябва да бъдат добавени или премахнати, за да се завърши стандартен шахматен комплект. Пълен комплект се състои от 1 Цар, 1 Царица, 2 Топа, 2 Офицера, 2 Коня и 8 Пионки.\n\nВходът е масив от шест цели числа, представляващи броя на всяка фигура в реда: Цар, Царица, Топ, Офицер, Кон, Пионка. Всяко число е между 0 и 10 включително.\n\nФункцията връща масив от шест цели числа, показващи колко фигури от всеки тип трябва да бъдат добавени (положително число) или премахнати (отрицателно число), за да се завърши комплектът.\n\nПример:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Комплектът вече е завършен\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Добавете 1 Цар, премахнете 1 Царица, добавете 1 Топ, добавете 3 Пионки",
      "zh": "该函数计算需要添加或移除多少棋子才能完成一副标准国际象棋棋子集。一个完整的棋子集由1个国王，1个皇后，2个车，2个象，2个马和8个兵组成。\n\n输入是一个包含六个整数的数组，表示每种棋子的数量，顺序为：国王，皇后，车，象，马，兵。每个数字在0到10之间（包括0和10）。\n\n该函数返回一个包含六个整数的数组，指示每种棋子需要添加（正数）或移除（负数）的数量以完成棋子集。\n\n示例：\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // 棋子集已经完整\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 添加1个国王，移除1个皇后，添加1个车，添加3个兵",
      "fr": "Cette fonction calcule le nombre de pièces d'échecs qu'il faut ajouter ou retirer pour compléter un jeu d'échecs standard. Un jeu complet se compose de 1 Roi, 1 Reine, 2 Tours, 2 Fous, 2 Cavaliers, et 8 Pions.\n\nL'entrée est un tableau de six entiers représentant le nombre de chaque pièce dans l'ordre : Roi, Reine, Tour, Fou, Cavalier, Pion. Chaque nombre est compris entre 0 et 10 inclus.\n\nLa fonction renvoie un tableau de six entiers indiquant combien de pièces de chaque type doivent être ajoutées (nombre positif) ou retirées (nombre négatif) pour compléter le jeu.\n\nExemple :\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Le jeu est déjà complet\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ajouter 1 Roi, retirer 1 Reine, ajouter 1 Tour, ajouter 3 Pions",
      "de": "Diese Funktion berechnet die Anzahl der Schachfiguren, die hinzugefügt oder entfernt werden müssen, um ein vollständiges Standardschachset zu vervollständigen. Ein vollständiges Set besteht aus 1 König, 1 Dame, 2 Türmen, 2 Läufern, 2 Springern und 8 Bauern.\n\nDie Eingabe ist ein Array von sechs ganzen Zahlen, das die Anzahl jeder Figur in der Reihenfolge: König, Dame, Turm, Läufer, Springer, Bauer darstellt. Jede Zahl liegt zwischen 0 und 10 einschließlich.\n\nDie Funktion gibt ein Array von sechs ganzen Zahlen zurück, das angibt, wie viele Figuren jeder Art hinzugefügt (positive Zahl) oder entfernt (negative Zahl) werden müssen, um das Set zu vervollständigen.\n\nBeispiel:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Das Set ist bereits vollständig\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Füge 1 König hinzu, entferne 1 Dame, füge 1 Turm hinzu, füge 3 Bauern hinzu",
      "ha": "Wannan aikin yana ƙididdige yawan kayan wasan catur da ake buƙatar ƙara ko cirewa don kammala saitin catur na al'ada. Saitin cike yana ƙunshe da Sarki 1, Sarauniya 1, Turawa 2, Bishof 2, Dawakai 2, da Masu Tafiya 8.\n\nShigarwar shi ne jerin lambobi guda shida da ke wakiltar adadin kowanne yanki a tsari: Sarki, Sarauniya, Turawa, Bishof, Dawakai, Masu Tafiya. Kowanne lamba yana tsakanin 0 da 10 ciki har da.\n\nAikin yana dawowa da jerin lambobi guda shida da ke nuna yawan kayan kowane nau'i da ake buƙatar ƙara (lamba mai kyau) ko cirewa (lamba mara kyau) don kammala saitin.\n\nMisali:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Saitin ya riga ya cika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ƙara Sarki 1, cire Sarauniya 1, ƙara Turawa 1, ƙara Masu Tafiya 3",
      "hi": "यह फ़ंक्शन उन शतरंज के मोहरों की संख्या की गणना करता है जिन्हें एक मानक शतरंज सेट को पूरा करने के लिए जोड़ा या हटाया जाना चाहिए। एक पूर्ण सेट में 1 राजा, 1 रानी, 2 हाथी, 2 ऊंट, 2 घोड़े, और 8 प्यादे होते हैं।\n\nइनपुट छह पूर्णांकों की एक सरणी है जो क्रम में प्रत्येक मोहरे की गिनती को दर्शाती है: राजा, रानी, हाथी, ऊंट, घोड़ा, प्यादा। प्रत्येक संख्या 0 और 10 के बीच (समावेशी) होती है।\n\nफ़ंक्शन छह पूर्णांकों की एक सरणी लौटाता है जो यह दर्शाती है कि सेट को पूरा करने के लिए प्रत्येक प्रकार के कितने मोहरे जोड़े (सकारात्मक संख्या) या हटाए (ऋणात्मक संख्या) जाने की आवश्यकता है।\n\nउदाहरण:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // सेट पहले से ही पूरा है\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 राजा जोड़ें, 1 रानी हटाएं, 1 हाथी जोड़ें, 3 प्यादे जोड़ें",
      "hu": "Ez a függvény kiszámítja, hogy hány sakkfigurát kell hozzáadni vagy eltávolítani ahhoz, hogy egy teljes szabványos sakk készletet kapjunk. Egy teljes készlet 1 Királyból, 1 Királynőből, 2 Bástyából, 2 Futóból, 2 Huszárból és 8 Gyalogból áll.\n\nA bemenet egy hat egész számot tartalmazó tömb, amely a figurák számát jelöli a következő sorrendben: Király, Királynő, Bástya, Futó, Huszár, Gyalog. Minden szám 0 és 10 között van, beleértve.\n\nA függvény egy hat egész számot tartalmazó tömböt ad vissza, amely jelzi, hogy hány darabot kell hozzáadni (pozitív szám) vagy eltávolítani (negatív szám) az egyes típusokból a készlet teljessé tételéhez.\n\nPélda:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // A készlet már teljes\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Adj hozzá 1 Királyt, távolíts el 1 Királynőt, adj hozzá 1 Bástyát, adj hozzá 3 Gyalogot"
    },
    "docstring_bertscore": {
      "sq": "0.9977505109347798",
      "hy": "0.9810117300945889",
      "bn": "0.9468518730553519",
      "bg": "0.9966421534086052",
      "zh": "0.9370866076325337",
      "fr": "0.9977505109347798",
      "de": "0.9638669487555624",
      "ha": "0.9708285463500732",
      "hi": "0.9605972940533472",
      "hu": "0.9828887871953685"
    }
  },
  {
    "task_id": "Swift/23",
    "prompt": {
      "en": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "sq": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nLlogarit numrin maksimal të pjesëve që një tabelë shahu drejtkëndore mund të ndahet me 'n' prerje të drejta,\nku të gjitha prerjet janë paralele me anët e drejtkëndëshit.\n\nFormula për llogaritjen e numrit maksimal të pjesëve është (n^2 + n + 2)/2.\n\n- Parametrat:\n- n: Numri i prerjeve që do të bëhen në tabelën e shahut.\n- Kthen: Numri maksimal i pjesëve që tabela e shahut mund të ndahet.\n\nShembuj:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "hy": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nՀաշվում է առավելագույն կտորների քանակը, որոնց կարելի է բաժանել ուղղանկյուն շախմատային տախտակը 'n' ուղիղ կտրվածքներով,\nորտեղ բոլոր կտրվածքները զուգահեռ են ուղղանկյան կողմերին։\n\nԱռավելագույն կտորների քանակը հաշվելու բանաձևն է (n^2 + n + 2)/2։\n\n- Պարամետրեր:\n- n: Կտրվածքների քանակը, որոնք պետք է արվեն շախմատային տախտակի վրա։\n- Վերադարձնում է: Առավելագույն կտորների քանակը, որոնց կարելի է բաժանել շախմատային տախտակը։\n\nՕրինակներ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "bn": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nএকটি আয়তাকার দাবার বোর্ডকে 'n' টি সরল কাটা দিয়ে সর্বাধিক কতগুলো টুকরোতে ভাগ করা যায় তা গণনা করে, \nযেখানে সমস্ত কাট আয়তক্ষেত্রের পাশের সমান্তরাল।\n\nটুকরোগুলোর সর্বাধিক সংখ্যা গণনা করার সূত্র হল (n^2 + n + 2)/2।\n\n- প্যারামিটারসমূহ:\n- n: দাবার বোর্ডে করা কাটের সংখ্যা।\n- রিটার্নস: দাবার বোর্ডকে সর্বাধিক কতগুলো টুকরোতে ভাগ করা যায়।\n\nউদাহরণ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "bg": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nИзчислява максималния брой парчета, на които правоъгълна шахматна дъска може да бъде разделена с 'n' прави разреза,\nкъдето всички разрези са успоредни на страните на правоъгълника.\n\nФормулата за изчисляване на максималния брой парчета е (n^2 + n + 2)/2.\n\n- Параметри:\n- n: Броят на разрезите, които трябва да бъдат направени на шахматната дъска.\n- Връща: Максималният брой парчета, на които шахматната дъска може да бъде разделена.\n\nПримери:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "zh": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\n计算可以通过 'n' 条直线将一个矩形棋盘分成的最大块数，其中所有的切割线都平行于矩形的边。\n\n计算最大块数的公式是 (n^2 + n + 2)/2。\n\n- 参数:\n- n: 在棋盘上进行的切割次数。\n- 返回值: 棋盘可以被分成的最大块数。\n\n示例:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "fr": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalcule le nombre maximum de morceaux qu'un échiquier rectangulaire peut être divisé avec 'n' coupes droites,\noù toutes les coupes sont parallèles aux côtés du rectangle.\n\nLa formule pour calculer le nombre maximum de morceaux est (n^2 + n + 2)/2.\n\n- Paramètres:\n- n: Le nombre de coupes à réaliser sur l'échiquier.\n- Retourne: Le nombre maximum de morceaux dans lesquels l'échiquier peut être divisé.\n\nExemples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "de": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nBerechnet die maximale Anzahl von Stücken, in die ein rechteckiges Schachbrett mit 'n' geraden Schnitten geteilt werden kann,\nwobei alle Schnitte parallel zu den Seiten des Rechtecks verlaufen.\n\nDie Formel zur Berechnung der maximalen Anzahl von Stücken ist (n^2 + n + 2)/2.\n\n- Parameter:\n- n: Die Anzahl der Schnitte, die auf dem Schachbrett gemacht werden sollen.\n- Rückgabewert: Die maximale Anzahl von Stücken, in die das Schachbrett geteilt werden kann.\n\nBeispiele:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "ha": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nYana ƙididdige yawan yankan da za a iya raba katangar catur a ciki tare da yankan madaidaici guda 'n', \ninda dukkan yankan suna daidai da gefen murabba'in.\n\nTsarin lissafin yawan yankan shine (n^2 + n + 2)/2.\n\n- Sigogi:\n- n: Yawan yankan da za a yi akan katangar catur.\n- Komawa: Yawan yankan da za a iya raba katangar catur a ciki.\n\nMisalai:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "hi": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nसीधे कटों के साथ एक आयताकार शतरंज बोर्ड को अधिकतम कितने टुकड़ों में विभाजित किया जा सकता है की गणना करता है, \nजहां सभी कट आयत के किनारों के समानांतर होते हैं।\n\nअधिकतम टुकड़ों की संख्या की गणना का सूत्र (n^2 + n + 2)/2 है।\n\n- पैरामीटर्स:\n- n: शतरंज बोर्ड पर किए जाने वाले कटों की संख्या।\n- रिटर्न्स: अधिकतम टुकड़ों की संख्या जिसमें शतरंज बोर्ड को विभाजित किया जा सकता है।\n\nउदाहरण:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "hu": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nKiszámítja, hogy egy téglalap alakú sakktáblát legfeljebb hány darabra lehet osztani 'n' egyenes vágással, \nahol minden vágás párhuzamos a téglalap oldalával.\n\nA maximális darabszám kiszámításának képlete: (n^2 + n + 2)/2.\n\n- Paraméterek:\n- n: A sakktáblán végrehajtandó vágások száma.\n- Visszatér: A maximális darabszám, amire a sakktábla osztható.\n\nPéldák:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9989508343273737",
      "hy": "0.9857272153403571",
      "bn": "0.9909513929919557",
      "bg": "0.9883074239900003",
      "zh": "0.9768494304600027",
      "fr": "0.992592874460828",
      "de": "0.9724352675022644",
      "ha": "0.9221736372548153",
      "hi": "0.9843828849215129",
      "hu": "0.9919129626665456"
    },
    "canonical_solution": "if n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}",
    "instruction": {
      "en": "Write a Swift function `func maxChessboardSlices(_ n: Int) -> Int {` to solve the following problem:\n\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n",
      "sq": "Shkruani një funksion Swift `func maxChessboardSlices(_ n: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nLlogarit numrin maksimal të pjesëve që një tabelë shahu drejtkëndore mund të ndahet me 'n' prerje të drejta, \nku të gjitha prerjet janë paralele me anët e drejtkëndëshit.\n\nFormula për llogaritjen e numrit maksimal të pjesëve është (n^2 + n + 2)/2.\n\n- Parametrat:\n- n: Numri i prerjeve që do të bëhen në tabelën e shahut.\n- Kthen: Numri maksimal i pjesëve që tabela e shahut mund të ndahet.\n\nShembuj:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hy": "Գրեք Swift ֆունկցիա `func maxChessboardSlices(_ n: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է առավելագույն կտորների քանակը, որով ուղղանկյուն շախմատային տախտակը կարող է բաժանվել 'n' ուղիղ կտրվածքներով, \nորտեղ բոլոր կտրվածքները զուգահեռ են ուղղանկյան կողմերին:\n\nԱռավելագույն կտորների քանակը հաշվարկելու բանաձևն է (n^2 + n + 2)/2:\n\n- Պարամետրեր:\n- n: Կտրվածքների քանակը, որոնք պետք է կատարվեն շախմատային տախտակի վրա:\n- Վերադարձնում է: Շախմատային տախտակը բաժանելու առավելագույն կտորների քանակը:\n\nՕրինակներ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "bn": "একটি Swift ফাংশন `func maxChessboardSlices(_ n: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি আয়তাকার দাবার বোর্ডকে 'n' টি সরল কাটা দিয়ে সর্বাধিক কতগুলো টুকরোতে ভাগ করা যায় তা গণনা করে, যেখানে সব কাটাগুলি আয়তক্ষেত্রের পার্শ্বগুলির সমান্তরাল।\n\nসর্বাধিক টুকরোর সংখ্যা গণনার সূত্র হল (n^2 + n + 2)/2।\n\n- প্যারামিটার:\n- n: দাবার বোর্ডে তৈরি করা কাটার সংখ্যা।\n- রিটার্নস: দাবার বোর্ডকে সর্বাধিক কতগুলো টুকরোতে ভাগ করা যায়।\n\nউদাহরণ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "bg": "Напишете Swift функция `func maxChessboardSlices(_ n: Int) -> Int {` за решаване на следния проблем:\n\nИзчислява максималния брой парчета, на които правоъгълна шахматна дъска може да бъде разделена с 'n' прави разреза, където всички разрези са успоредни на страните на правоъгълника.\n\nФормулата за изчисляване на максималния брой парчета е (n^2 + n + 2)/2.\n\n- Параметри:\n- n: Броят на разрезите, които трябва да бъдат направени на шахматната дъска.\n- Връща: Максималният брой парчета, на които шахматната дъска може да бъде разделена.\n\nПримери:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "zh": "编写一个 Swift 函数 `func maxChessboardSlices(_ n: Int) -> Int {` 来解决以下问题：\n\n计算一个矩形棋盘可以用 'n' 条直线切割成的最大块数，其中所有的切割线都与矩形的边平行。\n\n计算最大块数的公式是 (n^2 + n + 2)/2。\n\n- 参数：\n- n: 在棋盘上进行的切割次数。\n- 返回值：棋盘可以被分成的最大块数。\n\n示例：\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "fr": "Écrire une fonction Swift `func maxChessboardSlices(_ n: Int) -> Int {` pour résoudre le problème suivant :\n\nCalcule le nombre maximum de pièces qu'un échiquier rectangulaire peut être divisé en 'n' coupes droites, où toutes les coupes sont parallèles aux côtés du rectangle.\n\nLa formule pour calculer le nombre maximum de pièces est (n^2 + n + 2)/2.\n\n- Paramètres :\n- n : Le nombre de coupes à effectuer sur l'échiquier.\n- Retourne : Le nombre maximum de pièces dans lesquelles l'échiquier peut être divisé.\n\nExemples :\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "de": "Schreiben Sie eine Swift-Funktion `func maxChessboardSlices(_ n: Int) -> Int {`, um das folgende Problem zu lösen:\n\nBerechnet die maximale Anzahl von Teilen, in die ein rechteckiges Schachbrett mit 'n' geraden Schnitten unterteilt werden kann, wobei alle Schnitte parallel zu den Seiten des Rechtecks verlaufen.\n\nDie Formel zur Berechnung der maximalen Anzahl von Teilen ist (n^2 + n + 2)/2.\n\n- Parameter:\n- n: Die Anzahl der Schnitte, die auf dem Schachbrett gemacht werden sollen.\n- Rückgabe: Die maximale Anzahl von Teilen, in die das Schachbrett unterteilt werden kann.\n\nBeispiele:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "ha": "Rubuta aikin Swift `func maxChessboardSlices(_ n: Int) -> Int {` don warware matsalar mai zuwa:\n\nLissafa yawan yankan da za a iya raba katangar catur a ciki tare da 'n' yankan madaidaiciya, inda duk yankan suna daidai da gefen murabba'in.\n\nTsarin lissafin yawan yankan shine (n^2 + n + 2)/2.\n\n- Sigogi:\n- n: Yawan yankan da za a yi a kan katangar catur.\n- Komawa: Yawan yankan da katangar catur za a iya raba shi a ciki.\n\nMisalai:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hi": "Swift फ़ंक्शन `func maxChessboardSlices(_ n: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nयह गणना करता है कि अधिकतम कितने टुकड़ों में एक आयताकार शतरंज की बिसात को 'n' सीधे कट के साथ विभाजित किया जा सकता है, जहाँ सभी कट आयत के किनारों के समानांतर होते हैं।\n\nअधिकतम टुकड़ों की संख्या की गणना करने का सूत्र (n^2 + n + 2)/2 है।\n\n- पैरामीटर्स:\n- n: शतरंज की बिसात पर किए जाने वाले कट की संख्या।\n- रिटर्न करता है: अधिकतम टुकड़ों की संख्या जिसमें शतरंज की बिसात को विभाजित किया जा सकता है।\n\nउदाहरण:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hu": "Írj egy Swift függvényt `func maxChessboardSlices(_ n: Int) -> Int {` a következő probléma megoldására:\n\nKiszámítja, hogy egy téglalap alakú sakktábla hány darabra osztható fel 'n' egyenes vágással, ahol minden vágás párhuzamos a téglalap oldalával.\n\nA maximális darabszám kiszámításának képlete: (n^2 + n + 2)/2.\n\n- Paraméterek:\n- n: A sakktáblán végrehajtandó vágások száma.\n- Visszatér: A maximális darabszám, amire a sakktábla felosztható.\n\nPéldák:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9"
    },
    "instruction_bertscore": {
      "sq": "0.9986238887201903",
      "hy": "0.9927706486518542",
      "bn": "0.9906675501774568",
      "bg": "0.9907972558162726",
      "zh": "0.9753134217234599",
      "fr": "0.9933585945797174",
      "de": "0.9812731276760307",
      "ha": "0.9595076077829897",
      "hi": "0.9717142392191078",
      "hu": "0.9857812428039986"
    },
    "level": "easy",
    "test": "func testMaxChessboardSlices() {\nassert(maxChessboardSlices(0) == 1)\nassert(maxChessboardSlices(2) == 4)\nassert(maxChessboardSlices(4) == 9)\nassert(maxChessboardSlices(5) == 12)\nassert(maxChessboardSlices(6) == 16)\nassert(maxChessboardSlices(7) == 20)\n}\n\ntestMaxChessboardSlices()",
    "entry_point": "maxChessboardSlices",
    "signature": "func maxChessboardSlices(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n",
      "sq": "Llogarit numrin maksimal të pjesëve në të cilat një tabelë shahu drejtkëndore mund të ndahet me 'n' prerje të drejta, ku të gjitha prerjet janë paralele me anët e drejtkëndëshit.\n\nFormula për llogaritjen e numrit maksimal të pjesëve është (n^2 + n + 2)/2.\n\n- Parametrat:\n- n: Numri i prerjeve që do të bëhen në tabelën e shahut.\n- Kthen: Numri maksimal i pjesëve në të cilat tabela e shahut mund të ndahet.\n\nShembuj:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hy": "Հաշվում է առավելագույն կտորների քանակը, որ ուղղանկյուն շախմատային տախտակը կարող է բաժանվել 'n' ուղիղ կտրվածքներով, \nորտեղ բոլոր կտրվածքները զուգահեռ են ուղղանկյան կողմերին:\n\nԱռավելագույն կտորների քանակը հաշվելու բանաձևը (n^2 + n + 2)/2 է:\n\n- Պարամետրեր:\n- n: Կտրվածքների քանակը, որը պետք է արվի շախմատային տախտակի վրա:\n- Վերադարձնում է: Առավելագույն կտորների քանակը, որ շախմատային տախտակը կարող է բաժանվել:\n\nՕրինակներ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "bn": "আয়তাকার দাবার বোর্ডকে 'n' টি সরল কাটা দিয়ে সর্বাধিক কতগুলি টুকরোতে ভাগ করা যায় তা গণনা করে, যেখানে সমস্ত কাটাই আয়তক্ষেত্রের পার্শ্বের সমান্তরাল।\n\nসর্বাধিক টুকরো সংখ্যা গণনা করার সূত্র হল (n^2 + n + 2)/2।\n\n- প্যারামিটার:\n- n: দাবার বোর্ডে তৈরি করা কাটার সংখ্যা।\n- রিটার্নস: দাবার বোর্ডকে সর্বাধিক কতগুলি টুকরোতে ভাগ করা যেতে পারে।\n\nউদাহরণ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "bg": "Изчислява максималния брой парчета, на които правоъгълна шахматна дъска може да бъде разделена с 'n' прави разреза, където всички разрези са успоредни на страните на правоъгълника.\n\nФормулата за изчисляване на максималния брой парчета е (n^2 + n + 2)/2.\n\n- Параметри:\n- n: Броят на разрезите, които трябва да бъдат направени на шахматната дъска.\n- Връща: Максималният брой парчета, на които шахматната дъска може да бъде разделена.\n\nПримери:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "zh": "计算一个矩形棋盘可以用 'n' 条直线切割成的最大块数，其中所有切割线都与矩形的边平行。\n\n计算最大块数的公式是 (n^2 + n + 2)/2。\n\n- 参数:\n- n: 在棋盘上进行的切割次数。\n- 返回值: 棋盘可以被分成的最大块数。\n\n示例:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "fr": "Calcule le nombre maximum de morceaux qu'un échiquier rectangulaire peut être divisé avec 'n' coupes droites, où toutes les coupes sont parallèles aux côtés du rectangle.\n\nLa formule pour calculer le nombre maximum de morceaux est (n^2 + n + 2)/2.\n\n- Paramètres:\n- n: Le nombre de coupes à effectuer sur l'échiquier.\n- Retourne: Le nombre maximum de morceaux dans lesquels l'échiquier peut être divisé.\n\nExemples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "de": "Berechnet die maximale Anzahl von Teilen, in die ein rechteckiges Schachbrett mit 'n' geraden Schnitten unterteilt werden kann, wobei alle Schnitte parallel zu den Seiten des Rechtecks verlaufen.\n\nDie Formel zur Berechnung der maximalen Anzahl von Teilen ist (n^2 + n + 2)/2.\n\n- Parameter:\n- n: Die Anzahl der Schnitte, die auf dem Schachbrett gemacht werden sollen.\n- Rückgabewert: Die maximale Anzahl von Teilen, in die das Schachbrett unterteilt werden kann.\n\nBeispiele:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "ha": "Yana ƙididdige yawan yanki mafi girma da za a iya raba allon caturang na murabba'i zuwa tare da 'n' yanke madaidaici, inda duk yankan suna daidai da gefen murabba'in.\n\nTsarin don ƙididdige yawan yanki mafi girma shine (n^2 + n + 2)/2.\n\n- Sigogi:\n- n: Yawan yankan da za a yi akan allon caturang.\n- Komawa: Yawan yanki mafi girma da za a iya raba allon caturang zuwa.\n\nMisalai:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hi": "आयताकार शतरंज की बिसात को 'n' सीधे कट के साथ अधिकतम टुकड़ों में विभाजित करने की गणना करता है, जहाँ सभी कट आयत के किनारों के समानांतर होते हैं।\n\nअधिकतम टुकड़ों की संख्या की गणना करने का सूत्र (n^2 + n + 2)/2 है।\n\n- पैरामीटर्स:\n- n: शतरंज की बिसात पर किए जाने वाले कट की संख्या।\n- रिटर्न: अधिकतम टुकड़ों की संख्या जिसमें शतरंज की बिसात को विभाजित किया जा सकता है।\n\nउदाहरण:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "hu": "Kiszámítja, hogy egy téglalap alakú sakktábla legfeljebb hány darabra osztható 'n' egyenes vágással, ahol minden vágás párhuzamos a téglalap oldalával.\n\nA maximális darabszám kiszámításának képlete: (n^2 + n + 2)/2.\n\n- Paraméterek:\n- n: A sakktáblán végrehajtandó vágások száma.\n- Visszatér: A maximális darabszám, amire a sakktábla osztható.\n\nPéldák:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9"
    },
    "docstring_bertscore": {
      "sq": "0.9855460644328533",
      "hy": "0.9983708336147519",
      "bn": "0.9800654549593386",
      "bg": "0.9877214643659473",
      "zh": "0.9706585187439074",
      "fr": "0.9895834255577683",
      "de": "0.9639336885635902",
      "ha": "0.9551631640889947",
      "hi": "0.9825366155297937",
      "hu": "0.9906421254886844"
    }
  },
  {
    "task_id": "Swift/24",
    "prompt": {
      "en": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "sq": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nGjen fjalën më të vogël leksikografikisht në një matricë të dhënë karakteresh. \nMatrica përbëhet nga shkronja të vogla dhe '#'. Një fjalë përcaktohet si një sekuencë \nshkronjash ose horizontalisht nga e majta në të djathtë ose vertikalisht nga lart poshtë, \npa kaluar '#'. Fjala duhet të jetë të paktën 2 karaktere e gjatë dhe të kufizohet nga '#' \nose nga skaji i matricës në të dyja anët.\n\nShembull:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "hy": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nԳտնում է տրված մատրիցի մեջ լեքսիկոգրաֆիկորեն ամենափոքր բառը:\nՄատրիցը բաղկացած է փոքրատառերից և '#'-ից: Բառը սահմանվում է որպես տառերի հաջորդականություն \nկամ հորիզոնական ձախից աջ, կամ ուղղահայաց վերևից ներքև, առանց '#'-ը հատելու: Բառը պետք է լինի \nառնվազն 2 տառ երկարությամբ և սահմանափակված լինի '#' կամ մատրիցի եզրով երկու ծայրերից:\n\nՕրինակ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "bn": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nএকটি প্রদত্ত অক্ষরের ম্যাট্রিক্সে বর্ণানুক্রমিকভাবে সবচেয়ে ছোট শব্দটি খুঁজে বের করে। \nম্যাট্রিক্সটি ছোট হাতের অক্ষর এবং '#' নিয়ে গঠিত। একটি শব্দকে সংজ্ঞায়িত করা হয় \nযখন এটি বাম থেকে ডানে অনুভূমিকভাবে বা উপরে থেকে নিচে উল্লম্বভাবে অক্ষরের \nক্রম হিসেবে থাকে, '#' অতিক্রম না করে। শব্দটি কমপক্ষে ২ অক্ষরের দীর্ঘ হতে হবে \nএবং উভয় প্রান্তে '#' বা ম্যাট্রিক্সের প্রান্ত দ্বারা সীমাবদ্ধ হতে হবে।\n\nউদাহরণ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "bg": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nНамира лексикографски най-малката дума в дадена матрица от символи. \nМатрицата се състои от малки букви и '#'. Думата се дефинира като \nпоследователност от букви или хоризонтално отляво надясно, или вертикално \nотгоре надолу, без да пресича '#'. Думата трябва да бъде поне 2 символа \nдълга и да бъде ограничена от '#' или ръба на матрицата от двете страни.\n\nПример:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "zh": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\n在给定的字符矩阵中查找字典序最小的单词。\n矩阵由小写字母和 '#' 组成。单词定义为从左到右水平或从上到下垂直的字母序列，\n不能跨越 '#'。单词必须至少有 2 个字符长，并且在两端由 '#' 或矩阵的边界限制。\n\n示例:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "fr": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nTrouve le mot le plus petit lexicographiquement dans une matrice donnée de caractères. \nLa matrice se compose de lettres minuscules et de '#'. Un mot est défini comme une séquence \nde lettres soit horizontalement de gauche à droite, soit verticalement de haut en bas, \nsans traverser '#'. Le mot doit avoir au moins 2 caractères de long et être délimité par '#' \nou le bord de la matrice aux deux extrémités.\n\nExemple:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "de": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFindet das lexikographisch kleinste Wort in einer gegebenen Matrix von Zeichen.\nDie Matrix besteht aus Kleinbuchstaben und '#'. Ein Wort ist definiert als eine \nFolge von Buchstaben, entweder horizontal von links nach rechts oder vertikal von \noben nach unten, ohne '#' zu überschreiten. Das Wort muss mindestens 2 Zeichen lang \nsein und an beiden Enden von '#' oder dem Rand der Matrix begrenzt sein.\n\nBeispiel:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "ha": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nNemi kalma mafi ƙanƙanta a cikin tsari na haruffa. \nTsarin yana ƙunshe da ƙananan haruffa da '#'. Ana ayyana kalma a matsayin jerin \nharuffa ko dai a kwance daga hagu zuwa dama ko a tsaye daga sama zuwa ƙasa, \nba tare da ketare '#' ba. Kalmar dole ne ta zama aƙalla haruffa 2 tsawo kuma ta kasance \nta iyakance da '#' ko gefen matrix a duka ƙarshen.\n\nMisali:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "hi": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nदिए गए अक्षरों के मैट्रिक्स में शब्दकोश के अनुसार सबसे छोटा शब्द खोजता है। \nमैट्रिक्स में छोटे अक्षर और '#' होते हैं। एक शब्द को अक्षरों के अनुक्रम के रूप में \nपरिभाषित किया गया है जो या तो क्षैतिज रूप से बाएँ से दाएँ या ऊर्ध्वाधर रूप से ऊपर से नीचे तक होता है, \nबिना '#' को पार किए। शब्द कम से कम 2 अक्षरों का होना चाहिए और दोनों सिरों पर '#' \nया मैट्रिक्स के किनारे से सीमित होना चाहिए।\n\nउदाहरण:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "hu": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nMegtalálja a lexicoográfiailag legkisebb szót egy adott karaktermátrixban.\nA mátrix kisbetűkből és '#' karakterekből áll. Egy szó olyan betűsorozatként \nvan definiálva, amely vízszintesen balról jobbra vagy függőlegesen fentről lefelé \nhalad, anélkül, hogy '#' karakteren áthaladna. A szónak legalább 2 karakter hosszúnak \nkell lennie, és a mátrix szélén vagy '#' karakterrel kell határoltnak lennie mindkét végén.\n\nPélda:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9964155161438444",
      "hy": "0.9864563874691361",
      "bn": "0.9790591934490159",
      "bg": "0.9928697652119907",
      "zh": "0.9643204219154651",
      "fr": "0.9929299502174442",
      "de": "0.990839762717814",
      "ha": "0.9678113508621533",
      "hi": "0.9586062231138535",
      "hu": "0.9614865622692403"
    },
    "canonical_solution": "var smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}",
    "instruction": {
      "en": "Write a Swift function `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` to solve the following problem:\n\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n",
      "sq": "Shkruani një funksion Swift `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` për të zgjidhur problemin e mëposhtëm:\n\nGjen fjalën më të vogël leksikografikisht në një matricë të dhënë karakteresh. \nMatrica përbëhet nga shkronja të vogla dhe '#'. Një fjalë përcaktohet si një sekuencë \nshkronjash ose horizontalisht nga e majta në të djathtë ose vertikalisht nga lart poshtë, \npa kaluar '#'. Fjala duhet të jetë të paktën 2 karaktere e gjatë dhe të kufizohet nga '#' \nose skaji i matricës në të dyja anët.\n\nShembull:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hy": "Գրեք Swift ֆունկցիա `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` հետևյալ խնդիրը լուծելու համար:\n\nԳտնում է տրված սիմվոլների մատրիցայում լեքսիկոգրաֆիկորեն ամենափոքր բառը։ \nՄատրիցան բաղկացած է փոքրատառերից և '#'-ից։ Բառը սահմանվում է որպես \nտառերի հաջորդականություն, որը կա՛մ հորիզոնական է ձախից աջ, կա՛մ ուղղահայաց վերևից ներքև, \nառանց '#'-ը հատելու։ Բառը պետք է լինի առնվազն 2 տառ երկարությամբ և սահմանափակված լինի \n'#'-ով կամ մատրիցայի եզրով երկու կողմերից։\n\nՕրինակ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "bn": "একটি Swift ফাংশন `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nপ্রদত্ত অক্ষরের ম্যাট্রিক্সে লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম শব্দ খুঁজে বের করে। \nম্যাট্রিক্সটি ছোট হাতের অক্ষর এবং '#' নিয়ে গঠিত। একটি শব্দকে সংজ্ঞায়িত করা হয় \nবাম থেকে ডানে অনুভূমিকভাবে বা উপরে থেকে নিচে উল্লম্বভাবে অক্ষরের ধারাবাহিকতা হিসাবে, \n'#' অতিক্রম না করে। শব্দটি কমপক্ষে ২ অক্ষরের দীর্ঘ হতে হবে এবং উভয় প্রান্তে '#' \nবা ম্যাট্রিক্সের প্রান্ত দ্বারা সীমাবদ্ধ হতে হবে।\n\nউদাহরণ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "bg": "Напишете Swift функция `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` за решаване на следния проблем:\n\nНамира лексикографски най-малката дума в дадена матрица от символи. \nМатрицата се състои от малки букви и '#'. Думата се дефинира като последователност \nот букви, или хоризонтално отляво надясно, или вертикално отгоре надолу, \nбез да пресича '#'. Думата трябва да бъде поне 2 символа дълга и да бъде ограничена от '#' \nили края на матрицата от двете страни.\n\nПример:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "zh": "编写一个 Swift 函数 `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` 来解决以下问题：\n\n在给定的字符矩阵中找到字典序最小的单词。矩阵由小写字母和 '#' 组成。单词定义为从左到右水平或从上到下垂直的字母序列，不能跨越 '#'. 单词必须至少有 2 个字符长，并且在两端由 '#' 或矩阵边缘界定。\n\n示例：\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "fr": "Écrire une fonction Swift `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` pour résoudre le problème suivant :\n\nTrouve le mot le plus petit lexicographiquement dans une matrice donnée de caractères. \nLa matrice est composée de lettres minuscules et de '#'. Un mot est défini comme une séquence \nde lettres soit horizontalement de gauche à droite, soit verticalement de haut en bas, \nsans traverser '#'. Le mot doit comporter au moins 2 caractères et être délimité par '#' \nou le bord de la matrice aux deux extrémités.\n\nExemple :\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "de": "Schreiben Sie eine Swift-Funktion `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {`, um das folgende Problem zu lösen:\n\nFindet das lexikografisch kleinste Wort in einer gegebenen Matrix von Zeichen. \nDie Matrix besteht aus Kleinbuchstaben und '#'. Ein Wort wird definiert als eine \nFolge von Buchstaben entweder horizontal von links nach rechts oder vertikal von oben \nnach unten, ohne '#' zu überschreiten. Das Wort muss mindestens 2 Zeichen lang sein \nund an beiden Enden von '#' oder dem Rand der Matrix begrenzt sein.\n\nBeispiel:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "ha": "Rubuta aikin Swift `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` don warware matsalar mai zuwa:\n\nNemi kalma mafi ƙarancin lexicographically a cikin matrix na haruffa da aka bayar. Matrix ɗin yana ƙunshe da ƙananan haruffa da '#'. Ana ayyana kalma a matsayin jerin haruffa ko dai a kwance daga hagu zuwa dama ko a tsaye daga sama zuwa ƙasa, ba tare da ketare '#' ba. Kalmar dole ne ta kasance aƙalla haruffa 2 tsayi kuma a iyakance ta '#' ko gefen matrix a duka ƙarshen.\n\nMisali:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hi": "Swift फ़ंक्शन `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nदिए गए अक्षरों के मैट्रिक्स में शब्दकोशानुसार सबसे छोटा शब्द खोजें। \nमैट्रिक्स में छोटे अक्षर और '#' होते हैं। एक शब्द को अक्षरों के अनुक्रम के रूप में परिभाषित किया जाता है \nजो या तो क्षैतिज रूप से बाएँ से दाएँ या लंबवत रूप से ऊपर से नीचे तक होता है, \nबिना '#' को पार किए। शब्द कम से कम 2 अक्षरों का होना चाहिए और दोनों सिरों पर '#' \nया मैट्रिक्स के किनारे से सीमित होना चाहिए।\n\nउदाहरण:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hu": "Írj egy Swift függvényt `func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {` a következő probléma megoldására:\n\nMegkeresi a lexicoográfiailag legkisebb szót egy adott karaktermátrixban. \nA mátrix kisbetűkből és '#' karakterekből áll. Egy szó olyan betűsorozat, amely \nvízszintesen balról jobbra vagy függőlegesen fentről lefelé halad, anélkül, hogy átlépne '#'. \nA szónak legalább 2 karakter hosszúnak kell lennie, és mindkét végén '#' vagy a mátrix széle \nkell, hogy határolja.\n\nPélda:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\""
    },
    "instruction_bertscore": {
      "sq": "0.9904186663100201",
      "hy": "0.9776644109133888",
      "bn": "0.9880609236871359",
      "bg": "0.9909915163289247",
      "zh": "0.9765228821135814",
      "fr": "0.9831207874804173",
      "de": "0.994033341984093",
      "ha": "0.9804082909970049",
      "hi": "0.9683198446376026",
      "hu": "0.9789481590660174"
    },
    "level": "hard",
    "test": "func testFindSmallestWordInMatrix() {\nassert(findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]]) == \"abc\")\nassert(findSmallestWordInMatrix([[\"a\", \"#\", \"c\"], [\"#\", \"d\", \"e\"], [\"f\", \"g\", \"#\"]]) == \"ce\")\nassert(findSmallestWordInMatrix([[\"#\", \"a\", \"#\"], [\"#\", \"b\", \"c\"], [\"#\", \"#\", \"d\"]]) == \"ab\")\nassert(findSmallestWordInMatrix([[\"m\", \"n\", \"o\"], [\"#\", \"#\", \"#\"], [\"p\", \"q\", \"r\"]]) == \"mno\")\nassert(findSmallestWordInMatrix([[\"x\", \"y\", \"#\"], [\"#\", \"z\", \"a\"], [\"b\", \"c\", \"d\"]]) == \"ad\")\n}\n\ntestFindSmallestWordInMatrix()",
    "entry_point": "findSmallestWordInMatrix",
    "signature": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {",
    "docstring": {
      "en": "\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n",
      "sq": "Gjen fjalën më të vogël leksikografikisht në një matricë të dhënë karakteresh. \nMatrica përbëhet nga shkronja të vogla dhe '#'. Një fjalë përcaktohet si një sekuencë \nshkronjash ose horizontalisht nga e majta në të djathtë ose vertikalisht nga lart poshtë, \npa kaluar '#'. Fjala duhet të jetë të paktën 2 karaktere e gjatë dhe të kufizohet nga '#' \nose skaji i matricës në të dyja anët.\n\nShembull:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hy": "Գտնում է տրված մատրիցի մեջ լեքսիկոգրաֆիկորեն ամենափոքր բառը:\nՄատրիցը բաղկացած է փոքրատառերից և '#'-ից: Բառը սահմանվում է որպես տառերի հաջորդականություն՝ \nկամ հորիզոնական ձախից աջ, կամ ուղղահայաց վերևից ներքև, առանց '#' հատելու: Բառը պետք է լինի \nառնվազն 2 տառ երկարությամբ և սահմանափակված լինի '#' կամ մատրիցի եզրով երկու ծայրերում:\n\nՕրինակ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "bn": "Finds the lexicographically smallest word in a given matrix of characters. \nম্যাট্রিক্সের মধ্যে লেক্সিকোগ্রাফিক্যালি ক্ষুদ্রতম শব্দ খুঁজে বের করে। \nThe matrix consists of lowercase letters and '#'. \nম্যাট্রিক্সটি ছোট হাতের অক্ষর এবং '#' নিয়ে গঠিত। \nA word is defined as a sequence of letters either horizontally from left to right or vertically from top to bottom, without crossing '#'. \nএকটি শব্দকে বর্ণনা করা হয় বাম থেকে ডানে অনুভূমিকভাবে বা উপরে থেকে নিচে উল্লম্বভাবে অক্ষরের ক্রম হিসেবে, '#' অতিক্রম না করে। \nThe word must be at least 2 characters long and be bounded by '#' or the edge of the matrix on both ends.\nশব্দটি কমপক্ষে ২ অক্ষরের দীর্ঘ হতে হবে এবং উভয় প্রান্তে '#' বা ম্যাট্রিক্সের প্রান্ত দ্বারা সীমাবদ্ধ হতে হবে।\n\nউদাহরণ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "bg": "Намира лексикографски най-малката дума в дадена матрица от символи. \nМатрицата се състои от малки букви и '#'. Думата се дефинира като последователност \nот букви или хоризонтално отляво надясно, или вертикално отгоре надолу, \nбез да пресича '#'. Думата трябва да бъде поне 2 символа дълга и да бъде ограничена от '#' \nили края на матрицата и от двете страни.\n\nПример:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "zh": "在给定的字符矩阵中查找字典序最小的单词。矩阵由小写字母和 '#' 组成。单词定义为从左到右水平或从上到下垂直的字母序列，不跨越 '#'。单词必须至少有 2 个字符长，并且在两端由 '#' 或矩阵的边界限制。\n\n示例：\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "fr": "Trouve le mot le plus petit lexicographiquement dans une matrice donnée de caractères. La matrice se compose de lettres minuscules et de '#'. Un mot est défini comme une séquence de lettres soit horizontalement de gauche à droite, soit verticalement de haut en bas, sans traverser '#'. Le mot doit comporter au moins 2 caractères et être délimité par '#' ou le bord de la matrice aux deux extrémités.\n\nExemple :\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "de": "Findet das lexikographisch kleinste Wort in einer gegebenen Matrix von Zeichen. \nDie Matrix besteht aus Kleinbuchstaben und '#'. Ein Wort ist definiert als eine \nFolge von Buchstaben, entweder horizontal von links nach rechts oder vertikal von oben nach unten, \nohne '#' zu überschreiten. Das Wort muss mindestens 2 Zeichen lang sein und an beiden Enden \nvon '#' oder dem Rand der Matrix begrenzt sein.\n\nBeispiel:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "ha": "Yana nemo kalma mafi ƙanƙanta a cikin tsarin haruffa da aka bayar. \nTsarin yana ƙunshe da ƙananan haruffa da '#'. Ana ayyana kalma a matsayin jerin \nharuffa ko dai a kwance daga hagu zuwa dama ko a tsaye daga sama zuwa ƙasa, \nba tare da ketare '#' ba. Kalmar dole ne ta kasance aƙalla haruffa 2 tsayi kuma ta kasance \na iyakance da '#' ko gefen tsarin a duka ƙarshen.\n\nMisali:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hi": "दिए गए वर्णों के मैट्रिक्स में शब्दकोशानुसार सबसे छोटा शब्द खोजता है। \nमैट्रिक्स में छोटे अक्षर और '#' होते हैं। एक शब्द को अक्षरों की एक श्रृंखला के रूप में परिभाषित किया जाता है \nजो या तो क्षैतिज रूप से बाएं से दाएं या ऊर्ध्वाधर रूप से ऊपर से नीचे की ओर होती है, \nबिना '#' को पार किए। शब्द कम से कम 2 वर्ण लंबा होना चाहिए और दोनों सिरों पर '#' \nया मैट्रिक्स के किनारे से सीमित होना चाहिए।\n\nउदाहरण:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "hu": "Megkeresi a lexicoográfiailag legkisebb szót egy adott karaktermátrixban. \nA mátrix kisbetűkből és '#' jelekből áll. Egy szó egy betűsorozatként van definiálva, \namely vagy vízszintesen balról jobbra, vagy függőlegesen fentről lefelé halad, \nanélkül, hogy átlépné a '#'-t. A szónak legalább 2 karakter hosszúnak kell lennie, és \nmindkét végén '#' vagy a mátrix szélével kell határoltnak lennie.\n\nPélda:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\""
    },
    "docstring_bertscore": {
      "sq": "0.980090482387349",
      "hy": "0.9845548988314892",
      "bn": "0.9379790539345234",
      "bg": "0.9896610900367531",
      "zh": "0.9535528675899448",
      "fr": "0.9848290087573173",
      "de": "0.9921636342074116",
      "ha": "0.9555455275724869",
      "hi": "0.9683117007919801",
      "hu": "0.9675326724375614"
    }
  },
  {
    "task_id": "Swift/25",
    "prompt": {
      "en": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n*/",
      "sq": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nGjen numrin që mungon në një sekuencë që fillimisht ishte një progresion aritmetik.\n\nHyrja është një varg me tre numra të plotë, që përfaqësojnë numrat e mbetur të sekuencës pasi një numër është humbur. Funksioni kthen numrin që mungon. Sekuenca origjinale e katër numrave ishte në progresion aritmetik.\n\nShembuj:\n- Nëse hyrja është [3, 7, 5], funksioni kthen 1 ose 9, pasi sekuenca mund të ketë qenë [1, 3, 5, 7] ose [3, 5, 7, 9].\n- Nëse hyrja është [20, 14, 8], funksioni kthen 26 ose 2, pasi sekuenca mund të ketë qenë [2, 8, 14, 20] ose [8, 14, 20, 26].\n*/",
      "hy": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nԳտնում է բացակա թիվը հաջորդականության մեջ, որը սկզբնապես թվաբանական պրոգրեսիա էր:\n\nՄուտքը երեք ամբողջ թվերի զանգված է, որը ներկայացնում է հաջորդականության մնացած թվերը այն բանից հետո, երբ մեկ թիվ կորել է: Ֆունկցիան վերադարձնում է բացակա թիվը: Սկզբնական չորս թվերի հաջորդականությունը թվաբանական պրոգրեսիա էր:\n\nՕրինակներ:\n- Եթե մուտքը [3, 7, 5] է, ֆունկցիան վերադարձնում է 1 կամ 9, քանի որ հաջորդականությունը կարող էր լինել [1, 3, 5, 7] կամ [3, 5, 7, 9]:\n- Եթե մուտքը [20, 14, 8] է, ֆունկցիան վերադարձնում է 26 կամ 2, քանի որ հաջորդականությունը կարող էր լինել [2, 8, 14, 20] կամ [8, 14, 20, 26]:\n*/",
      "bn": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nএকটি ধারাবাহিক ক্রমে অনুপস্থিত সংখ্যা খুঁজে বের করে যা মূলত একটি গাণিতিক ক্রম ছিল।\n\nইনপুটটি তিনটি পূর্ণসংখ্যার একটি অ্যারে, যা একটি সংখ্যা হারানোর পর ক্রমের বাকি সংখ্যা প্রতিনিধিত্ব করে। ফাংশনটি অনুপস্থিত সংখ্যাটি ফেরত দেয়। চারটি সংখ্যার মূল ক্রমটি গাণিতিক ক্রমে ছিল।\n\nউদাহরণ:\n- যদি ইনপুট হয় [3, 7, 5], ফাংশনটি 1 বা 9 ফেরত দেয়, কারণ ক্রমটি হতে পারত [1, 3, 5, 7] বা [3, 5, 7, 9]।\n- যদি ইনপুট হয় [20, 14, 8], ফাংশনটি 26 বা 2 ফেরত দেয়, কারণ ক্রমটি হতে পারত [2, 8, 14, 20] বা [8, 14, 20, 26]।\n*/",
      "bg": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nНамира липсващото число в последователност, която първоначално е била аритметична прогресия.\n\nВходът е масив от три цели числа, представляващи останалите числа от последователността след като едно число е изгубено. Функцията връща липсващото число. Оригиналната последователност от четири числа е била в аритметична прогресия.\n\nПримери:\n- Ако входът е [3, 7, 5], функцията връща 1 или 9, тъй като последователността може да е била [1, 3, 5, 7] или [3, 5, 7, 9].\n- Ако входът е [20, 14, 8], функцията връща 26 или 2, тъй като последователността може да е била [2, 8, 14, 20] или [8, 14, 20, 26].\n*/",
      "zh": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\n在原本是等差数列的序列中找到缺失的数字。\n\n输入是一个包含三个整数的数组，表示序列中丢失一个数字后的剩余数字。函数返回缺失的数字。原始的四个数字的序列是等差数列。\n\n示例：\n- 如果输入是 [3, 7, 5]，函数返回 1 或 9，因为序列可能是 [1, 3, 5, 7] 或 [3, 5, 7, 9]。\n- 如果输入是 [20, 14, 8]，函数返回 26 或 2，因为序列可能是 [2, 8, 14, 20] 或 [8, 14, 20, 26]。\n*/",
      "fr": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nTrouve le nombre manquant dans une séquence qui était à l'origine une progression arithmétique.\n\nL'entrée est un tableau de trois entiers, représentant les nombres restants de la séquence après la perte d'un nombre. La fonction renvoie le nombre manquant. La séquence originale de quatre nombres était en progression arithmétique.\n\nExemples :\n- Si l'entrée est [3, 7, 5], la fonction renvoie 1 ou 9, car la séquence aurait pu être [1, 3, 5, 7] ou [3, 5, 7, 9].\n- Si l'entrée est [20, 14, 8], la fonction renvoie 26 ou 2, car la séquence aurait pu être [2, 8, 14, 20] ou [8, 14, 20, 26].\n*/",
      "de": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFindet die fehlende Zahl in einer Sequenz, die ursprünglich eine arithmetische Folge war.\n\nDie Eingabe ist ein Array von drei ganzen Zahlen, die die verbleibenden Zahlen der Sequenz darstellen, nachdem eine Zahl verloren gegangen ist. Die Funktion gibt die fehlende Zahl zurück. Die ursprüngliche Sequenz von vier Zahlen war in arithmetischer Folge.\n\nBeispiele:\n- Wenn die Eingabe [3, 7, 5] ist, gibt die Funktion 1 oder 9 zurück, da die Sequenz [1, 3, 5, 7] oder [3, 5, 7, 9] gewesen sein könnte.\n- Wenn die Eingabe [20, 14, 8] ist, gibt die Funktion 26 oder 2 zurück, da die Sequenz [2, 8, 14, 20] oder [8, 14, 20, 26] gewesen sein könnte.\n*/",
      "ha": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nNemo lambar da ta ɓace a cikin jerin lambobi wanda a asali ya kasance ci gaban lissafi.\n\nShigarwar ita ce jerin lambobi guda uku, wanda ke wakiltar sauran lambobin jerin bayan an rasa lamba ɗaya. Aikin yana dawo da lambar da ta ɓace. Asalin jerin lambobi guda huɗu yana cikin ci gaban lissafi.\n\nMisalai:\n- Idan shigarwar ita ce [3, 7, 5], aikin yana dawowa 1 ko 9, tunda jerin zai iya kasancewa [1, 3, 5, 7] ko [3, 5, 7, 9].\n- Idan shigarwar ita ce [20, 14, 8], aikin yana dawowa 26 ko 2, tunda jerin zai iya kasancewa [2, 8, 14, 20] ko [8, 14, 20, 26].\n*/",
      "hi": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nअनुक्रम में से गायब संख्या का पता लगाता है जो मूल रूप से एक अंकगणितीय प्रगति थी।\n\nइनपुट तीन पूर्णांकों की एक श्रृंखला है, जो एक संख्या खो जाने के बाद अनुक्रम के शेष संख्याओं का प्रतिनिधित्व करती है। फ़ंक्शन गायब संख्या को लौटाता है। चार संख्याओं का मूल अनुक्रम अंकगणितीय प्रगति में था।\n\nउदाहरण:\n- यदि इनपुट [3, 7, 5] है, तो फ़ंक्शन 1 या 9 लौटाता है, क्योंकि अनुक्रम [1, 3, 5, 7] या [3, 5, 7, 9] हो सकता था।\n- यदि इनपुट [20, 14, 8] है, तो फ़ंक्शन 26 या 2 लौटाता है, क्योंकि अनुक्रम [2, 8, 14, 20] या [8, 14, 20, 26] हो सकता था।\n*/",
      "hu": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nMegkeresi a hiányzó számot egy olyan sorozatban, amely eredetileg egy számtani sorozat volt.\n\nA bemenet egy három egész számot tartalmazó tömb, amely a sorozat megmaradt számait képviseli, miután egy szám elveszett. A függvény visszaadja a hiányzó számot. Az eredeti négy számot tartalmazó sorozat számtani sorozat volt.\n\nPéldák:\n- Ha a bemenet [3, 7, 5], a függvény visszaadja az 1-et vagy a 9-et, mivel a sorozat lehetett [1, 3, 5, 7] vagy [3, 5, 7, 9].\n- Ha a bemenet [20, 14, 8], a függvény visszaadja a 26-ot vagy a 2-t, mivel a sorozat lehetett [2, 8, 14, 20] vagy [8, 14, 20, 26].\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9928393747636923",
      "hy": "0.9933603822531468",
      "bn": "0.9945624933191699",
      "bg": "0.9983597103134139",
      "zh": "0.9693632500291789",
      "fr": "0.998673149054687",
      "de": "0.9957787071422466",
      "ha": "0.9759975047557441",
      "hi": "0.9879800811220548",
      "hu": "0.9888707397506152"
    },
    "canonical_solution": "let sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}",
    "instruction": {
      "en": "Write a Swift function `func findMissingNumber(in numbers: [Int]) -> Int {` to solve the following problem:\n\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n",
      "sq": "Shkruani një funksion Swift `func findMissingNumber(in numbers: [Int]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nGjen numrin që mungon në një sekuencë që fillimisht ishte një progresion aritmetik.\n\nHyrja është një varg me tre numra të plotë, që përfaqësojnë numrat e mbetur të sekuencës pasi një numër është humbur. Funksioni kthen numrin që mungon. Sekuenca origjinale prej katër numrash ishte në progresion aritmetik.\n\nShembuj:\n- Nëse hyrja është [3, 7, 5], funksioni kthen 1 ose 9, pasi sekuenca mund të ketë qenë [1, 3, 5, 7] ose [3, 5, 7, 9].\n- Nëse hyrja është [20, 14, 8], funksioni kthen 26 ose 2, pasi sekuenca mund të ketë qenë [2, 8, 14, 20] ose [8, 14, 20, 26].",
      "hy": "Swift ֆունկցիա `func findMissingNumber(in numbers: [Int]) -> Int {` գրեք հետևյալ խնդիրը լուծելու համար:\n\nԳտնում է բացակայող թիվը հաջորդականության մեջ, որը սկզբնապես թվաբանական պրոգրեսիա էր:\n\nՄուտքը երեք ամբողջ թվերի զանգված է, որը ներկայացնում է հաջորդականության մնացած թվերը, երբ մեկ թիվ կորել է: Ֆունկցիան վերադարձնում է բացակայող թիվը: Սկզբնական չորս թվերի հաջորդականությունը թվաբանական պրոգրեսիա էր:\n\nՕրինակներ:\n- Եթե մուտքը [3, 7, 5] է, ֆունկցիան վերադարձնում է 1 կամ 9, քանի որ հաջորդականությունը կարող էր լինել [1, 3, 5, 7] կամ [3, 5, 7, 9]:\n- Եթե մուտքը [20, 14, 8] է, ֆունկցիան վերադարձնում է 26 կամ 2, քանի որ հաջորդականությունը կարող էր լինել [2, 8, 14, 20] կամ [8, 14, 20, 26]:",
      "bn": "একটি Swift ফাংশন `func findMissingNumber(in numbers: [Int]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি ক্রমে হারিয়ে যাওয়া সংখ্যাটি খুঁজে বের করে যা মূলত একটি গাণিতিক প্রগতি ছিল।\n\nইনপুটটি তিনটি পূর্ণসংখ্যার একটি অ্যারে, যা ক্রমের অবশিষ্ট সংখ্যাগুলিকে উপস্থাপন করে যখন একটি সংখ্যা হারিয়ে যায়। ফাংশনটি হারিয়ে যাওয়া সংখ্যাটি ফেরত দেয়। চারটি সংখ্যার মূল ক্রমটি গাণিতিক প্রগতিতে ছিল।\n\nউদাহরণ:\n- যদি ইনপুট হয় [3, 7, 5], ফাংশনটি 1 বা 9 ফেরত দেয়, কারণ ক্রমটি [1, 3, 5, 7] বা [3, 5, 7, 9] হতে পারত।\n- যদি ইনপুট হয় [20, 14, 8], ফাংশনটি 26 বা 2 ফেরত দেয়, কারণ ক্রমটি [2, 8, 14, 20] বা [8, 14, 20, 26] হতে পারত।",
      "bg": "Напишете функция на Swift `func findMissingNumber(in numbers: [Int]) -> Int {`, за да решите следния проблем:\n\nНамира липсващото число в редица, която първоначално е била аритметична прогресия.\n\nВходът е масив от три цели числа, представляващи останалите числа от редицата след като едно число е изгубено. Функцията връща липсващото число. Оригиналната редица от четири числа е била в аритметична прогресия.\n\nПримери:\n- Ако входът е [3, 7, 5], функцията връща 1 или 9, тъй като редицата може да е била [1, 3, 5, 7] или [3, 5, 7, 9].\n- Ако входът е [20, 14, 8], функцията връща 26 или 2, тъй като редицата може да е била [2, 8, 14, 20] или [8, 14, 20, 26].",
      "zh": "编写一个 Swift 函数 `func findMissingNumber(in numbers: [Int]) -> Int {` 来解决以下问题：\n\n在一个原本是等差数列的序列中找到缺失的数字。\n\n输入是一个包含三个整数的数组，表示序列中剩余的数字，其中一个数字丢失。函数返回缺失的数字。原始的四个数字序列是等差数列。\n\n例子：\n- 如果输入是 [3, 7, 5]，函数返回 1 或 9，因为序列可能是 [1, 3, 5, 7] 或 [3, 5, 7, 9]。\n- 如果输入是 [20, 14, 8]，函数返回 26 或 2，因为序列可能是 [2, 8, 14, 20] 或 [8, 14, 20, 26]。",
      "fr": "Écrire une fonction Swift `func findMissingNumber(in numbers: [Int]) -> Int {` pour résoudre le problème suivant :\n\nTrouve le nombre manquant dans une séquence qui était à l'origine une progression arithmétique.\n\nL'entrée est un tableau de trois entiers, représentant les nombres restants de la séquence après qu'un nombre soit perdu. La fonction retourne le nombre manquant. La séquence originale de quatre nombres était en progression arithmétique.\n\nExemples :\n- Si l'entrée est [3, 7, 5], la fonction retourne 1 ou 9, puisque la séquence aurait pu être [1, 3, 5, 7] ou [3, 5, 7, 9].\n- Si l'entrée est [20, 14, 8], la fonction retourne 26 ou 2, puisque la séquence aurait pu être [2, 8, 14, 20] ou [8, 14, 20, 26].",
      "de": "Schreiben Sie eine Swift-Funktion `func findMissingNumber(in numbers: [Int]) -> Int {`, um das folgende Problem zu lösen:\n\nFindet die fehlende Zahl in einer Sequenz, die ursprünglich eine arithmetische Progression war.\n\nDie Eingabe ist ein Array von drei ganzen Zahlen, die die verbleibenden Zahlen der Sequenz darstellen, nachdem eine Zahl verloren gegangen ist. Die Funktion gibt die fehlende Zahl zurück. Die ursprüngliche Sequenz von vier Zahlen war in arithmetischer Progression.\n\nBeispiele:\n- Wenn die Eingabe [3, 7, 5] ist, gibt die Funktion 1 oder 9 zurück, da die Sequenz [1, 3, 5, 7] oder [3, 5, 7, 9] gewesen sein könnte.\n- Wenn die Eingabe [20, 14, 8] ist, gibt die Funktion 26 oder 2 zurück, da die Sequenz [2, 8, 14, 20] oder [8, 14, 20, 26] gewesen sein könnte.",
      "ha": "Rubuta aikin Swift `func findMissingNumber(in numbers: [Int]) -> Int {` don warware matsalar mai zuwa:\n\nNemo lambar da ta ɓace a cikin jerin da aka fara da ci gaba na lissafi.\n\nShigarwar ita ce jerin lambobi guda uku, wanda ke wakiltar sauran lambobin jerin bayan an rasa lamba ɗaya. Aikin yana dawowa da lambar da ta ɓace. Asalin jerin lambobi huɗu yana cikin ci gaba na lissafi.\n\nMisalai:\n- Idan shigarwar ita ce [3, 7, 5], aikin yana dawowa da 1 ko 9, tun da jerin zai iya kasancewa [1, 3, 5, 7] ko [3, 5, 7, 9].\n- Idan shigarwar ita ce [20, 14, 8], aikin yana dawowa da 26 ko 2, tun da jerin zai iya kasancewa [2, 8, 14, 20] ko [8, 14, 20, 26].",
      "hi": "Swift फ़ंक्शन `func findMissingNumber(in numbers: [Int]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nएक अनुक्रम में गायब संख्या को खोजें जो मूल रूप से एक अंकगणितीय प्रगति थी।\n\nइनपुट तीन पूर्णांकों की एक array है, जो उस अनुक्रम की शेष संख्याओं का प्रतिनिधित्व करती है जिसमें से एक संख्या खो गई है। फ़ंक्शन गायब संख्या को लौटाता है। चार संख्याओं का मूल अनुक्रम अंकगणितीय प्रगति में था।\n\nउदाहरण:\n- यदि इनपुट [3, 7, 5] है, तो फ़ंक्शन 1 या 9 लौटाता है, क्योंकि अनुक्रम [1, 3, 5, 7] या [3, 5, 7, 9] हो सकता था।\n- यदि इनपुट [20, 14, 8] है, तो फ़ंक्शन 26 या 2 लौटाता है, क्योंकि अनुक्रम [2, 8, 14, 20] या [8, 14, 20, 26] हो सकता था।",
      "hu": "Írj egy Swift függvényt `func findMissingNumber(in numbers: [Int]) -> Int {` a következő probléma megoldására:\n\nMegtalálja a hiányzó számot egy olyan sorozatban, amely eredetileg egy számtani sorozat volt.\n\nA bemenet egy három egész számot tartalmazó tömb, amely a sorozat megmaradt számait képviseli, miután egy szám elveszett. A függvény visszaadja a hiányzó számot. Az eredeti négy számot tartalmazó sorozat számtani sorozat volt.\n\nPéldák:\n- Ha a bemenet [3, 7, 5], a függvény 1-et vagy 9-et ad vissza, mivel a sorozat lehetett [1, 3, 5, 7] vagy [3, 5, 7, 9].\n- Ha a bemenet [20, 14, 8], a függvény 26-ot vagy 2-t ad vissza, mivel a sorozat lehetett [2, 8, 14, 20] vagy [8, 14, 20, 26]."
    },
    "instruction_bertscore": {
      "sq": "0.993213991662324",
      "hy": "0.9760064431228906",
      "bn": "0.9892000689223711",
      "bg": "0.9951383227937901",
      "zh": "0.9672285693241969",
      "fr": "0.9966516876668949",
      "de": "0.9917149281766537",
      "ha": "0.9703001895365204",
      "hi": "0.9766257726509575",
      "hu": "0.9857188728643536"
    },
    "level": "hard",
    "test": "func testFindMissingNumber() {\nassert(findMissingNumber(in: [3, 7, 5]) == 1 || findMissingNumber(in: [3, 7, 5]) == 9)\nassert(findMissingNumber(in: [20, 14, 8]) == 26 || findMissingNumber(in: [20, 14, 8]) == 2)\nassert(findMissingNumber(in: [12, 6, 18]) == 0 || findMissingNumber(in: [12, 6, 18]) == 24)\nassert(findMissingNumber(in: [-4, 0, -8]) == -12 || findMissingNumber(in: [-4, 0, -8]) == 4)\nassert(findMissingNumber(in: [15, 5, 10]) == 0 || findMissingNumber(in: [15, 5, 10]) == 20)\n}\n\ntestFindMissingNumber()",
    "entry_point": "findMissingNumber",
    "signature": "func findMissingNumber(in numbers: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n",
      "sq": "Gjen numrin që mungon në një sekuencë që fillimisht ishte një progresion aritmetik.\n\nHyrja është një varg me tre numra të plotë, që përfaqësojnë numrat e mbetur të sekuencës pasi një numër është humbur. Funksioni kthen numrin që mungon. Sekuenca origjinale e katër numrave ishte në progresion aritmetik.\n\nShembuj:\n- Nëse hyrja është [3, 7, 5], funksioni kthen 1 ose 9, pasi sekuenca mund të ketë qenë [1, 3, 5, 7] ose [3, 5, 7, 9].\n- Nëse hyrja është [20, 14, 8], funksioni kthen 26 ose 2, pasi sekuenca mund të ketë qenë [2, 8, 14, 20] ose [8, 14, 20, 26].",
      "hy": "Գտնում է բացակայող թիվը հաջորդականության մեջ, որը սկզբնապես թվաբանական պրոգրեսիա էր:\n\nՄուտքը երեք ամբողջ թվերի զանգված է, որը ներկայացնում է հաջորդականության մնացած թվերը այն բանից հետո, երբ մեկ թիվ կորել է: Ֆունկցիան վերադարձնում է բացակայող թիվը: Սկզբնական չորս թվերի հաջորդականությունը թվաբանական պրոգրեսիայի մեջ էր:\n\nՕրինակներ:\n- Եթե մուտքը [3, 7, 5] է, ֆունկցիան վերադարձնում է 1 կամ 9, քանի որ հաջորդականությունը կարող էր լինել [1, 3, 5, 7] կամ [3, 5, 7, 9]:\n- Եթե մուտքը [20, 14, 8] է, ֆունկցիան վերադարձնում է 26 կամ 2, քանի որ հաջորդականությունը կարող էր լինել [2, 8, 14, 20] կամ [8, 14, 20, 26]:",
      "bn": "একটি ধারাবাহিক ক্রমে অনুপস্থিত সংখ্যা খুঁজে বের করে যা মূলত একটি গাণিতিক ক্রমবিন্যাস ছিল।\n\nইনপুটটি তিনটি পূর্ণসংখ্যার একটি অ্যারে, যা একটি সংখ্যা হারানোর পরে ক্রমের অবশিষ্ট সংখ্যাগুলিকে উপস্থাপন করে। ফাংশনটি অনুপস্থিত সংখ্যাটি ফেরত দেয়। চারটি সংখ্যার মূল ক্রমটি একটি গাণিতিক ক্রমবিন্যাসে ছিল।\n\nউদাহরণ:\n- যদি ইনপুট হয় [3, 7, 5], ফাংশনটি 1 বা 9 ফেরত দেয়, যেহেতু ক্রমটি [1, 3, 5, 7] বা [3, 5, 7, 9] হতে পারত।\n- যদি ইনপুট হয় [20, 14, 8], ফাংশনটি 26 বা 2 ফেরত দেয়, যেহেতু ক্রমটি [2, 8, 14, 20] বা [8, 14, 20, 26] হতে পারত।",
      "bg": "Намира липсващото число в редица, която първоначално е била аритметична прогресия.\n\nВходът е масив от три цели числа, представляващи останалите числа от редицата след като едно число е изгубено. Функцията връща липсващото число. Оригиналната редица от четири числа е била в аритметична прогресия.\n\nПримери:\n- Ако входът е [3, 7, 5], функцията връща 1 или 9, тъй като редицата може да е била [1, 3, 5, 7] или [3, 5, 7, 9].\n- Ако входът е [20, 14, 8], функцията връща 26 или 2, тъй като редицата може да е била [2, 8, 14, 20] или [8, 14, 20, 26].",
      "zh": "找到原本是等差数列的序列中缺失的数字。\n\n输入是一个包含三个整数的数组，代表在一个数字丢失后序列中剩下的数字。函数返回缺失的数字。原始的四个数字的序列是等差数列。\n\n示例：\n- 如果输入是 [3, 7, 5]，函数返回 1 或 9，因为序列可能是 [1, 3, 5, 7] 或 [3, 5, 7, 9]。\n- 如果输入是 [20, 14, 8]，函数返回 26 或 2，因为序列可能是 [2, 8, 14, 20] 或 [8, 14, 20, 26]。",
      "fr": "Trouve le nombre manquant dans une séquence qui était à l'origine une progression arithmétique.\n\nL'entrée est un tableau de trois entiers, représentant les nombres restants de la séquence après qu'un nombre soit perdu. La fonction retourne le nombre manquant. La séquence originale de quatre nombres était en progression arithmétique.\n\nExemples :\n- Si l'entrée est [3, 7, 5], la fonction retourne 1 ou 9, car la séquence aurait pu être [1, 3, 5, 7] ou [3, 5, 7, 9].\n- Si l'entrée est [20, 14, 8], la fonction retourne 26 ou 2, car la séquence aurait pu être [2, 8, 14, 20] ou [8, 14, 20, 26].",
      "de": "Findet die fehlende Zahl in einer Sequenz, die ursprünglich eine arithmetische Progression war.\n\nDie Eingabe ist ein Array von drei ganzen Zahlen, das die verbleibenden Zahlen der Sequenz darstellt, nachdem eine Zahl verloren gegangen ist. Die Funktion gibt die fehlende Zahl zurück. Die ursprüngliche Sequenz von vier Zahlen war in arithmetischer Progression.\n\nBeispiele:\n- Wenn die Eingabe [3, 7, 5] ist, gibt die Funktion 1 oder 9 zurück, da die Sequenz [1, 3, 5, 7] oder [3, 5, 7, 9] gewesen sein könnte.\n- Wenn die Eingabe [20, 14, 8] ist, gibt die Funktion 26 oder 2 zurück, da die Sequenz [2, 8, 14, 20] oder [8, 14, 20, 26] gewesen sein könnte.",
      "ha": "Yana nemo lambar da ta ɓace a cikin jerin da aka fara da ci gaba na lissafi.\n\nShigarwar shine jerin lambobi guda uku, wanda ke wakiltar sauran lambobin jerin bayan an rasa lamba ɗaya. Aikin yana dawo da lambar da ta ɓace. Asalin jerin lambobi huɗu yana cikin ci gaba na lissafi.\n\nMisalai:\n- Idan shigarwar shine [3, 7, 5], aikin yana dawo da 1 ko 9, tunda jerin zai iya kasancewa [1, 3, 5, 7] ko [3, 5, 7, 9].\n- Idan shigarwar shine [20, 14, 8], aikin yana dawo da 26 ko 2, tunda jerin zai iya kasancewa [2, 8, 14, 20] ko [8, 14, 20, 26].",
      "hi": "गणितीय प्रगति में मूल रूप से एक अनुक्रम में गायब संख्या को खोजता है।\n\nइनपुट तीन पूर्णांकों की एक श्रृंखला है, जो उस अनुक्रम की शेष संख्याओं का प्रतिनिधित्व करती है जब एक संख्या खो जाती है। फ़ंक्शन गायब संख्या लौटाता है। चार संख्याओं का मूल अनुक्रम गणितीय प्रगति में था।\n\nउदाहरण:\n- यदि इनपुट [3, 7, 5] है, तो फ़ंक्शन 1 या 9 लौटाता है, क्योंकि अनुक्रम [1, 3, 5, 7] या [3, 5, 7, 9] हो सकता था।\n- यदि इनपुट [20, 14, 8] है, तो फ़ंक्शन 26 या 2 लौटाता है, क्योंकि अनुक्रम [2, 8, 14, 20] या [8, 14, 20, 26] हो सकता था।",
      "hu": "Megkeresi a hiányzó számot egy olyan sorozatban, amely eredetileg számtani sorozat volt.\n\nA bemenet egy három egész számot tartalmazó tömb, amely a sorozat megmaradt számait jelenti, miután egy szám elveszett. A függvény visszaadja a hiányzó számot. Az eredeti négy számot tartalmazó sorozat számtani sorozat volt.\n\nPéldák:\n- Ha a bemenet [3, 7, 5], a függvény 1 vagy 9-et ad vissza, mivel a sorozat lehetett [1, 3, 5, 7] vagy [3, 5, 7, 9].\n- Ha a bemenet [20, 14, 8], a függvény 26 vagy 2-t ad vissza, mivel a sorozat lehetett [2, 8, 14, 20] vagy [8, 14, 20, 26]."
    },
    "docstring_bertscore": {
      "sq": "0.9873101008468241",
      "hy": "0.9926542512485678",
      "bn": "0.9739657145881382",
      "bg": "0.9871345115899892",
      "zh": "0.9685862079785703",
      "fr": "0.9932576903461517",
      "de": "0.9949232060911293",
      "ha": "0.9690218044041798",
      "hi": "0.9704046691169448",
      "hu": "0.9826061361631558"
    }
  },
  {
    "task_id": "Swift/26",
    "prompt": {
      "en": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "sq": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nNumëroni numrin e herëve që nënat kujtohen për sjelljen e një fëmije.\nNjë nënë kujtohet nëse numri i porcioneve të ushqimit që një fëmijë ka marrë\n(përjashtuar atë aktual) është më i madh se numri total i porcioneve të ushqimit\ntë marra nga fëmijët e tjerë.\n\nShembull:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "hy": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nՀաշվել, թե քանի անգամ մայրերը հիշեցվում են երեխայի վարքի մասին։\nՄայրը հիշեցվում է, եթե երեխայի վերցրած սննդի չափաբաժինների քանակը\n(բացառությամբ ընթացիկի) ավելի մեծ է, քան մյուս երեխաների վերցրած\nսննդի չափաբաժինների ընդհանուր քանակը։\n\nՕրինակ:\nՄուտք: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nԵլք: 1\n*/",
      "bn": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nএকটি শিশুর আচরণের কথা মায়েদের কতবার মনে করিয়ে দেওয়া হয় তা গণনা করুন।\nযদি একটি শিশু যে পরিমাণ খাবার গ্রহণ করেছে (বর্তমানটি বাদ দিয়ে) \nতা অন্য শিশুদের দ্বারা গ্রহণ করা মোট খাবারের পরিমাণের চেয়ে বেশি হয়, \nতাহলে মায়েদের মনে করিয়ে দেওয়া হয়।\n\nউদাহরণ:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "bg": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nБройте колко пъти майките са напомнени за поведението на дете.\nМайката е напомнена, ако броят на порциите храна, които детето е взело\n(без да се включва текущата), е по-голям от общия брой порции храна,\nвзети от другите деца.\n\nПример:\nВход: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nИзход: 1\n*/",
      "zh": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\n计算妈妈们被提醒孩子行为的次数。\n如果一个孩子已经拿的食物份数（不包括当前的）大于其他孩子拿的食物总份数，则妈妈会被提醒。\n\n例子:\n输入: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\n输出: 1\n*/",
      "fr": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCompter le nombre de fois où les mères sont rappelées du comportement d'un enfant.\nUne mère est rappelée si le nombre de portions de nourriture qu'un enfant a prises\n(en excluant l'actuelle) est supérieur au nombre total de portions de nourriture\nprises par les autres enfants.\n\nExemple :\nEntrée : [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nSortie : 1\n*/",
      "de": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nZählt die Anzahl der Male, die die Mütter an das Verhalten eines Kindes erinnert werden.\nEine Mutter wird erinnert, wenn die Anzahl der Essensportionen, die ein Kind genommen hat\n(ohne die aktuelle) größer ist als die Gesamtanzahl der Essensportionen,\ndie von anderen Kindern genommen wurden.\n\nBeispiel:\nEingabe: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nAusgabe: 1\n*/",
      "ha": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nƘirga yawan lokutan da iyaye mata ke tunawa da halayyar yaro.\nAna tuna wa uwa idan adadin abincin da yaro ya ɗauka\n(banda wanda yake yanzu) ya fi adadin abincin da sauran yara suka ɗauka.\n\nMisali:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "hi": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nबच्चों के व्यवहार की याद दिलाने की घटनाओं की संख्या गिनें।\nएक माँ को याद दिलाया जाता है यदि किसी बच्चे द्वारा ली गई भोजन की मात्रा\n(वर्तमान को छोड़कर) अन्य बच्चों द्वारा ली गई कुल भोजन की मात्रा से अधिक है।\n\nउदाहरण:\nइनपुट: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nआउटपुट: 1\n*/",
      "hu": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nSzámolja meg, hányszor emlékeztetik az anyukákat egy gyermek viselkedésére.\nEgy anyuka akkor van emlékeztetve, ha egy gyermek által elvett ételadagok száma\n(a jelenlegi kivételével) nagyobb, mint a többi gyermek által elvett ételadagok teljes száma.\n\nPélda:\nBemenet: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nKimenet: 1\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9864685039223793",
      "hy": "0.9663261915031554",
      "bn": "0.9369080389199833",
      "bg": "0.9800753864783903",
      "zh": "0.9626040567929426",
      "fr": "0.9913887770909945",
      "de": "0.9919586476541836",
      "ha": "0.9613268634428883",
      "hi": "0.9493401158385759",
      "hu": "0.982077382088841"
    },
    "canonical_solution": "var foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}",
    "instruction": {
      "en": "Write a Swift function `func countUnfairReminders(_ children: [String]) -> Int {` to solve the following problem:\n\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n",
      "sq": "Shkruani një funksion Swift `func countUnfairReminders(_ children: [String]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nNumëroni sa herë nënat kujtohen për sjelljen e një fëmije. Një nënë kujtohet nëse numri i porcioneve të ushqimit që një fëmijë ka marrë (duke përjashtuar atë aktual) është më i madh se numri total i porcioneve të ushqimit të marra nga fëmijët e tjerë.\n\nShembull:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "hy": "Swift ֆունկցիա գրեք `func countUnfairReminders(_ children: [String]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվեք, թե քանի անգամ մայրերը հիշեցվում են երեխայի վարքի մասին:\nՄայրը հիշեցվում է, եթե երեխայի վերցրած սննդի բաժինների քանակը\n(բացառյալ ընթացիկը) մեծ է, քան մյուս երեխաների վերցրած սննդի բաժինների ընդհանուր քանակը:\n\nՕրինակ:\nՄուտք: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nԵլք: 1",
      "bn": "একটি Swift ফাংশন `func countUnfairReminders(_ children: [String]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nমায়েরা একটি শিশুর আচরণের কথা কতবার মনে করিয়ে দেয় তা গণনা করুন। \nএকজন মায়ের মনে পড়ে যদি কোনো শিশু যতবার খাবারের অংশ নিয়েছে (বর্তমানটি বাদ দিয়ে) তা অন্য শিশুদের দ্বারা নেওয়া মোট খাবারের অংশের চেয়ে বেশি হয়।\n\nউদাহরণ:\nইনপুট: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nআউটপুট: 1",
      "bg": "Напишете Swift функция `func countUnfairReminders(_ children: [String]) -> Int {` за решаване на следния проблем:\n\nПребройте броя пъти, когато майките са напомнени за поведението на дете.\nМайката е напомнена, ако броят на порциите храна, които детето е взело\n(без текущата), е по-голям от общия брой порции храна,\nвзети от другите деца.\n\nПример:\nВход: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nИзход: 1",
      "zh": "编写一个 Swift 函数 `func countUnfairReminders(_ children: [String]) -> Int {` 来解决以下问题：\n\n计算妈妈们被提醒孩子行为的次数。\n如果一个孩子已经拿的食物份数（不包括当前的）大于其他孩子拿的食物总份数，妈妈就会被提醒。\n\n示例：\n输入: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\n输出: 1",
      "fr": "Écrire une fonction Swift `func countUnfairReminders(_ children: [String]) -> Int {` pour résoudre le problème suivant :\n\nCompter le nombre de fois où les mamans sont rappelées du comportement d'un enfant. Une maman est rappelée si le nombre de portions de nourriture qu'un enfant a prises (à l'exclusion de la portion actuelle) est supérieur au nombre total de portions de nourriture prises par les autres enfants.\n\nExemple :\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "de": "Schreiben Sie eine Swift-Funktion `func countUnfairReminders(_ children: [String]) -> Int {`, um das folgende Problem zu lösen:\n\nZählen Sie die Anzahl der Male, die Mütter an das Verhalten eines Kindes erinnert werden.\nEine Mutter wird erinnert, wenn die Anzahl der Essensportionen, die ein Kind genommen hat\n(ohne die aktuelle), größer ist als die Gesamtanzahl der Essensportionen,\ndie von anderen Kindern genommen wurden.\n\nBeispiel:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "ha": "Rubuta aikin Swift `func countUnfairReminders(_ children: [String]) -> Int {` don warware matsalar mai zuwa:\n\nƘirga yawan lokutan da iyaye mata ke tunawa da halayyar yaro. \nAna tunatar da uwa idan yawan rabo na abinci da yaro ya ɗauka \n(banda wanda yake yanzu) ya fi jimlar yawan rabo na abinci \nda sauran yara suka ɗauka.\n\nMisali:\nShigarwa: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nFitarwa: 1",
      "hi": "Swift फ़ंक्शन `func countUnfairReminders(_ children: [String]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n\nमाँ को बच्चे के व्यवहार की याद दिलाने की संख्या गिनें।\nमाँ को याद दिलाया जाता है यदि किसी बच्चे द्वारा ली गई भोजन की मात्रा की संख्या\n(वर्तमान को छोड़कर) अन्य बच्चों द्वारा ली गई कुल भोजन की मात्रा से अधिक है।\n\nउदाहरण:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "hu": "Írj egy Swift függvényt `func countUnfairReminders(_ children: [String]) -> Int {` a következő probléma megoldására:\n\nSzámold meg, hányszor emlékeztetik az anyukákat egy gyermek viselkedésére.\nEgy anyuka akkor van emlékeztetve, ha az adott gyermek által elfogyasztott ételadagok száma\n(a jelenlegi kivételével) nagyobb, mint a többi gyermek által elfogyasztott ételadagok teljes száma.\n\nPélda:\nBemenet: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nKimenet: 1"
    },
    "instruction_bertscore": {
      "sq": "0.9818994092674338",
      "hy": "0.9661716570667103",
      "bn": "0.9541102244391287",
      "bg": "0.9914839210435102",
      "zh": "0.9535510799165156",
      "fr": "0.9868474906893938",
      "de": "0.9824420674684211",
      "ha": "0.9677650699833721",
      "hi": "0.9368144840105158",
      "hu": "0.9752903805992599"
    },
    "level": "middle",
    "test": "func testCountUnfairReminders() {\nassert(countUnfairReminders([\"mirko\", \"stanko\", \"stanko\", \"stanko\"]) == 1)\nassert(countUnfairReminders([\"a\", \"b\", \"b\", \"a\", \"a\", \"a\", \"c\", \"a\", \"b\", \"b\", \"c\", \"b\"]) == 0)\nassert(countUnfairReminders([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 10)\nassert(countUnfairReminders([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\"]) == 0)\nprint(\"All test cases pass.\")\n}\n\ntestCountUnfairReminders()",
    "entry_point": "countUnfairReminders",
    "signature": "func countUnfairReminders(_ children: [String]) -> Int {",
    "docstring": {
      "en": "\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n",
      "sq": "Numëroni sa herë kujtohen nënat për sjelljen e një fëmije. Një nënë kujtohet nëse numri i porcioneve të ushqimit që një fëmijë ka marrë (duke përjashtuar atë aktual) është më i madh se numri total i porcioneve të ushqimit të marra nga fëmijët e tjerë.\n\nShembull:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "hy": "Հաշվել, թե քանի անգամ մայրերը հիշեցվում են երեխայի վարքի մասին: Մայրերը հիշեցվում են, եթե երեխայի վերցրած սննդի բաժինների քանակը (բացառյալ ընթացիկը) ավելի մեծ է, քան մյուս երեխաների վերցրած սննդի բաժինների ընդհանուր քանակը:\n\nՕրինակ:\nՄուտքագրում: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nԵլք: 1",
      "bn": "Count the number of times the moms are reminded of a child's behavior.  \nএকজন মাকে মনে করিয়ে দেওয়া হয় যদি একটি শিশু যে পরিমাণ খাবার নিয়েছে (বর্তমানটি বাদ দিয়ে) অন্যান্য শিশুদের দ্বারা নেওয়া মোট খাবারের পরিমাণের চেয়ে বেশি হয়।\n\nউদাহরণ:  \nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nOutput: 1  ",
      "bg": "Бройте колко пъти майките са напомнени за поведението на дете. \nМайка е напомнена, ако броят на порциите храна, които едно дете е взело \n(без да се включва текущата), е по-голям от общия брой порции храна, \nвзети от другите деца.\n\nПример:\nВход: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nИзход: 1",
      "zh": "计算妈妈们被提醒孩子行为的次数。\n如果一个孩子已经拿取的食物份数（不包括当前的）大于其他孩子拿取的食物总份数，则妈妈会被提醒。\n\n示例：\n输入: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\n输出: 1",
      "fr": "Comptez le nombre de fois où les mamans sont rappelées du comportement d'un enfant.  \nUne maman est rappelée si le nombre de portions de nourriture qu'un enfant a prises  \n(en excluant l'actuelle) est supérieur au nombre total de portions de nourriture  \nprises par les autres enfants.\n\nExemple :  \nEntrée : [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nSortie : 1  ",
      "de": "Zähle, wie oft die Mütter an das Verhalten eines Kindes erinnert werden.\nEine Mutter wird erinnert, wenn die Anzahl der Essensportionen, die ein Kind genommen hat\n(die aktuelle ausgenommen) größer ist als die Gesamtanzahl der Essensportionen,\ndie von anderen Kindern genommen wurden.\n\nBeispiel:\nEingabe: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nAusgabe: 1",
      "ha": "Count adadin lokutan da aka tunatar da iyaye game da halayen yaro.  \nAna tunatar da uwa idan adadin sassan abinci da yaro ya dauka  \n(banda wanda yake ci a yanzu) ya fi jimillar sassan abinci  \nda sauran yara suka dauka.\n\nMisali:  \nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nOutput: 1  ",
      "hi": "Count करें कि कितनी बार माताओं को बच्चे के व्यवहार की याद दिलाई जाती है। \nएक माँ को याद दिलाया जाता है यदि एक बच्चे द्वारा ली गई भोजन की मात्रा की संख्या \n(वर्तमान को छोड़कर) अन्य बच्चों द्वारा ली गई कुल भोजन की मात्रा से अधिक है।\n\nउदाहरण:\nइनपुट: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nआउटपुट: 1",
      "hu": "Számolja meg, hányszor emlékeztetik az anyákat egy gyermek viselkedésére.\nEgy anya akkor van emlékeztetve, ha egy gyermek által elvett ételadagok száma\n(a jelenlegit kivéve) nagyobb, mint a többi gyermek által elvett ételadagok teljes száma.\n\nPélda:\nBemenet: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nKimenet: 1"
    },
    "docstring_bertscore": {
      "sq": "0.9704100321372328",
      "hy": "0.9628271187108448",
      "bn": "0.9698719424350092",
      "bg": "0.9768182454901803",
      "zh": "0.9520077218558745",
      "fr": "0.9900243850036659",
      "de": "0.9698161272979384",
      "ha": "0.9544059850764897",
      "hi": "0.9537713610090832",
      "hu": "0.9779289865809274"
    }
  },
  {
    "task_id": "Swift/27",
    "prompt": {
      "en": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "sq": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nLlogarit numrin e mollëve të plota të mbetura pas një periudhe të caktuar kohe.\nNgrënia e një molle kërkon një periudhë të caktuar kohe dhe mund të hash vetëm një mollë në të njëjtën kohë.\nFunksioni merr tre parametra:\n- m: numri total i mollëve.\n- t: koha që duhet për të ngrënë një mollë.\n- s: koha totale e kaluar.\nFunksioni kthen numrin e mollëve të plota që mbeten.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "hy": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nՀաշվել մնացած ամբողջ խնձորների քանակը որոշակի ժամանակ անց:\nԽնձոր ուտելը տևում է որոշակի ժամանակ, և դուք կարող եք ուտել միայն մեկ խնձոր միաժամանակ:\nՖունկցիան ընդունում է երեք պարամետրեր.\n- m: խնձորների ընդհանուր քանակը:\n- t: ժամանակը, որը տևում է մեկ խնձոր ուտելու համար:\n- s: անցած ընդհանուր ժամանակը:\nՖունկցիան վերադարձնում է մնացած ամբողջ խնձորների քանակը:\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "bn": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nএকটি নির্দিষ্ট সময় পর কতগুলি সম্পূর্ণ আপেল অবশিষ্ট থাকবে তা গণনা করুন।\nএকটি আপেল খেতে একটি নির্দিষ্ট সময় লাগে এবং আপনি একবারে শুধুমাত্র একটি আপেল খেতে পারেন।\nফাংশনটি তিনটি প্যারামিটার নেয়:\n- m: আপেলের মোট সংখ্যা।\n- t: একটি আপেল খেতে যে সময় লাগে।\n- s: মোট অতিবাহিত সময়।\nফাংশনটি অবশিষ্ট সম্পূর্ণ আপেলের সংখ্যা প্রদান করে।\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "bg": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nИзчислете броя на останалите цели ябълки след определено време.\nЯденето на ябълка отнема определено време и можете да ядете само една ябълка наведнъж.\nФункцията приема три параметъра:\n- m: общият брой ябълки.\n- t: времето, необходимо за изяждане на една ябълка.\n- s: общото изминало време.\nФункцията връща броя на останалите цели ябълки.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "zh": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\n计算在一定时间后剩余的完整苹果数量。\n吃一个苹果需要一定的时间，并且一次只能吃一个苹果。\n该函数接受三个参数：\n- m: 苹果的总数量。\n- t: 吃一个苹果所需的时间。\n- s: 已经过的总时间。\n该函数返回剩余的完整苹果数量。\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "fr": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalcule le nombre de pommes entières restantes après un certain temps.\nManger une pomme prend un certain temps et vous ne pouvez manger qu'une pomme à la fois.\nLa fonction prend trois paramètres :\n- m : le nombre total de pommes.\n- t : le temps qu'il faut pour manger une pomme.\n- s : le temps total écoulé.\nLa fonction renvoie le nombre de pommes entières qui restent.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "de": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nBerechne die Anzahl der verbleibenden ganzen Äpfel nach einer bestimmten Zeit.\nDas Essen eines Apfels dauert eine bestimmte Zeit und man kann nur einen Apfel auf einmal essen.\nDie Funktion nimmt drei Parameter:\n- m: die Gesamtanzahl der Äpfel.\n- t: die Zeit, die benötigt wird, um einen Apfel zu essen.\n- s: die insgesamt vergangene Zeit.\nDie Funktion gibt die Anzahl der verbleibenden ganzen Äpfel zurück.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "ha": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nƘididdige yawan cikakkun tuffa da suka rage bayan wani lokaci.\nCin tuffa ɗaya yana ɗaukar wani lokaci kuma za ka iya cin tuffa ɗaya kawai a lokaci guda.\nAikin yana ɗaukar sigogi uku:\n- m: jimlar yawan tuffa.\n- t: lokacin da ake ɗauka don cin tuffa ɗaya.\n- s: jimlar lokacin da ya wuce.\nAikin yana dawowa da yawan cikakkun tuffa da suka rage.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "hi": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nएक निश्चित समय के बाद बचे हुए पूरे सेबों की संख्या की गणना करें।\nएक सेब खाने में एक निश्चित समय लगता है और आप एक समय में केवल एक सेब ही खा सकते हैं।\nयह फ़ंक्शन तीन पैरामीटर लेता है:\n- m: सेबों की कुल संख्या।\n- t: एक सेब खाने में लगने वाला समय।\n- s: कुल बीता हुआ समय।\nयह फ़ंक्शन बचे हुए पूरे सेबों की संख्या लौटाता है।\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "hu": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nSzámítsd ki a megmaradt egész almák számát egy bizonyos idő elteltével.\nEgy alma elfogyasztása egy bizonyos időt vesz igénybe, és egyszerre csak egy almát lehet enni.\nA függvény három paramétert vesz fel:\n- m: az almák teljes száma.\n- t: az idő, amíg egy almát megeszel.\n- s: az eltelt teljes idő.\nA függvény visszaadja a megmaradt egész almák számát.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9771477732923172",
      "hy": "0.9737263649789912",
      "bn": "0.9593822720125568",
      "bg": "0.9700890454414803",
      "zh": "0.954971684401677",
      "fr": "0.9739347282486968",
      "de": "0.9706070734752194",
      "ha": "0.9579926538668366",
      "hi": "0.9477077713672312",
      "hu": "0.9719243901622427"
    },
    "canonical_solution": "let eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}",
    "instruction": {
      "en": "Write a Swift function `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` to solve the following problem:\n\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n",
      "sq": "Shkruani një funksion Swift `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nLlogaritni numrin e mollëve të plota që mbeten pas një periudhe të caktuar kohe.\nTë hash një mollë kërkon një periudhë të caktuar kohe dhe mund të hash vetëm një mollë në të njëjtën kohë.\nFunksioni merr tre parametra:\n- m: numri total i mollëve.\n- t: koha që duhet për të ngrënë një mollë.\n- s: koha totale e kaluar.\nFunksioni kthen numrin e mollëve të plota që mbeten.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n",
      "hy": "Գրեք Swift ֆունկցիա `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվեք մնացած ամբողջ խնձորների քանակը որոշակի ժամանակ անց:\nԽնձոր ուտելը տևում է որոշակի ժամանակ, և դուք կարող եք ուտել միայն մեկ խնձոր միաժամանակ:\nՖունկցիան ընդունում է երեք պարամետրեր՝\n- m: խնձորների ընդհանուր քանակը։\n- t: մեկ խնձոր ուտելու համար անհրաժեշտ ժամանակը։\n- s: անցած ընդհանուր ժամանակը։\nՖունկցիան վերադարձնում է մնացած ամբողջ խնձորների քանակը։\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "bn": "একটি Swift ফাংশন `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি নির্দিষ্ট সময় পর কতগুলি সম্পূর্ণ আপেল অবশিষ্ট থাকবে তা গণনা করুন।\nএকটি আপেল খেতে একটি নির্দিষ্ট সময় লাগে এবং আপনি এক সময়ে শুধুমাত্র একটি আপেল খেতে পারেন।\nফাংশনটি তিনটি প্যারামিটার গ্রহণ করে:\n- m: আপেলের মোট সংখ্যা।\n- t: একটি আপেল খেতে যে সময় লাগে।\n- s: মোট পেরিয়ে যাওয়া সময়।\nফাংশনটি অবশিষ্ট সম্পূর্ণ আপেলের সংখ্যা ফেরত দেয়।\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "bg": "Напишете функция на Swift `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` за решаване на следния проблем:\n\nИзчислете броя на останалите цели ябълки след определено количество време.\nЯденето на ябълка отнема определено количество време и можете да ядете само една ябълка наведнъж.\nФункцията приема три параметъра:\n- m: общият брой ябълки.\n- t: времето, необходимо за изяждане на една ябълка.\n- s: общото изминало време.\nФункцията връща броя на останалите цели ябълки.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "zh": "编写一个 Swift 函数 `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` 来解决以下问题：\n\n计算经过一段时间后剩余的完整苹果数量。 吃一个苹果需要一定的时间，并且一次只能吃一个苹果。 该函数接收三个参数：\n- m: 苹果总数。\n- t: 吃一个苹果所需的时间。\n- s: 总共经过的时间。\n该函数返回剩余的完整苹果数量。\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "fr": "Écrivez une fonction Swift `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` pour résoudre le problème suivant :\n\nCalculez le nombre de pommes entières restantes après un certain temps.\nManger une pomme prend un certain temps et vous ne pouvez manger qu'une pomme à la fois.\nLa fonction prend trois paramètres :\n- m : le nombre total de pommes.\n- t : le temps nécessaire pour manger une pomme.\n- s : le temps total écoulé.\nLa fonction renvoie le nombre de pommes entières qui restent.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "de": "Schreiben Sie eine Swift-Funktion `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {`, um das folgende Problem zu lösen:\n\nBerechnen Sie die Anzahl der verbleibenden ganzen Äpfel nach einer bestimmten Zeit.\nDas Essen eines Apfels dauert eine bestimmte Zeit und Sie können jeweils nur einen Apfel essen.\nDie Funktion nimmt drei Parameter:\n- m: die Gesamtanzahl der Äpfel.\n- t: die Zeit, die benötigt wird, um einen Apfel zu essen.\n- s: die insgesamt vergangene Zeit.\nDie Funktion gibt die Anzahl der verbleibenden ganzen Äpfel zurück.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n",
      "ha": "Rubuta aikin Swift `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` don warware matsalar mai zuwa:\n\nƘididdige adadin cikakkun tuffa da suka rage bayan wani lokaci.\nCin tuffa ɗaya yana ɗaukar wani lokaci kuma za ka iya cin tuffa ɗaya kawai a lokaci guda.\nAikin yana ɗaukar sigogi guda uku:\n- m: jimlar adadin tuffa.\n- t: lokacin da ake ɗauka don cin tuffa ɗaya.\n- s: jimlar lokacin da ya wuce.\nAikin yana dawo da adadin cikakkun tuffa da suka rage.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "hi": "Swift फ़ंक्शन `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nएक निश्चित समय के बाद बचे हुए पूरे सेबों की संख्या की गणना करें।\nएक सेब खाने में एक निश्चित समय लगता है और आप एक बार में केवल एक सेब खा सकते हैं।\nफ़ंक्शन तीन पैरामीटर लेता है:\n- m: सेबों की कुल संख्या।\n- t: एक सेब खाने में लगने वाला समय।\n- s: कुल बीता हुआ समय।\nफ़ंक्शन उन पूरे सेबों की संख्या लौटाता है जो बचे हैं।\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "hu": "Írj egy Swift függvényt `func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {` a következő probléma megoldására:\n\nSzámítsd ki a megmaradt teljes almák számát egy bizonyos idő elteltével.\nEgy alma elfogyasztása egy bizonyos időt vesz igénybe, és egyszerre csak egy almát lehet megenni.\nA függvény három paramétert vesz fel:\n- m: az almák teljes száma.\n- t: az idő, ami egy alma elfogyasztásához szükséges.\n- s: az eltelt összidő.\nA függvény visszaadja a megmaradt teljes almák számát.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0"
    },
    "instruction_bertscore": {
      "sq": "0.9779683153963723",
      "hy": "0.9774562462740644",
      "bn": "0.9615793226571836",
      "bg": "0.9781566169975934",
      "zh": "0.9526228801459395",
      "fr": "0.9737557622753844",
      "de": "0.9778616508817566",
      "ha": "0.9583493940311754",
      "hi": "0.9503354526779417",
      "hu": "0.9688078794838053"
    },
    "level": "easy",
    "test": "func check(_ remainingApples: (Int, Int, Int) -> Int) {\nassert(remainingApples(50, 10, 200) == 30)\nassert(remainingApples(100, 5, 1000) == 0)\nassert(remainingApples(75, 15, 300) == 55)\nassert(remainingApples(20, 20, 400) == 0)\nassert(remainingApples(30, 10, 300) == 0)\nassert(remainingApples(40, 15, 600) == 0)\nassert(remainingApples(60, 10, 600) == 0)\n}\n\ncheck(remainingApples)",
    "entry_point": "remainingApples",
    "signature": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {",
    "docstring": {
      "en": "\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n",
      "sq": "Llogarit numrin e mollëve të plota të mbetura pas një periudhe të caktuar kohe. \nTë ngrënit e një molle kërkon një kohë të caktuar dhe mund të hash vetëm një mollë në të njëjtën kohë. \nFunksioni merr tre parametra:\n- m: numri total i mollëve.\n- t: koha që duhet për të ngrënë një mollë.\n- s: koha totale e kaluar.\nFunksioni kthen numrin e mollëve të plota që mbeten.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "hy": "Հաշվել մնացած ամբողջական խնձորների քանակը որոշակի ժամանակ անց:\nԽնձոր ուտելը տևում է որոշակի ժամանակ, և դուք կարող եք ուտել միայն մեկ խնձոր միաժամանակ:\nՖունկցիան ընդունում է երեք պարամետրեր:\n- m: խնձորների ընդհանուր քանակը:\n- t: ժամանակը, որը պահանջվում է մեկ խնձոր ուտելու համար:\n- s: անցած ընդհանուր ժամանակը:\nՖունկցիան վերադարձնում է մնացած ամբողջական խնձորների քանակը:\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "bn": "পূর্ণ আপেলগুলির সংখ্যা গণনা করুন যা একটি নির্দিষ্ট সময় পর অবশিষ্ট থাকে। একটি আপেল খেতে একটি নির্দিষ্ট সময় লাগে এবং আপনি এক সময়ে শুধুমাত্র একটি আপেল খেতে পারেন। ফাংশনটি তিনটি প্যারামিটার নেয়:\n- m: আপেলের মোট সংখ্যা।\n- t: একটি আপেল খেতে যে সময় লাগে।\n- s: মোট সময় যা পেরিয়ে গেছে।\nফাংশনটি অবশিষ্ট পূর্ণ আপেলগুলির সংখ্যা ফেরত দেয়।\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "bg": "Изчислете броя на останалите цели ябълки след определено време. Яденето на една ябълка отнема определено време и можете да ядете само по една ябълка наведнъж. Функцията приема три параметъра:\n- m: общият брой ябълки.\n- t: времето, необходимо за изяждане на една ябълка.\n- s: общото изминало време.\nФункцията връща броя на целите ябълки, които остават.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "zh": "计算在经过一段时间后剩余的完整苹果数量。  \n吃一个苹果需要一定的时间，并且一次只能吃一个苹果。  \n该函数有三个参数：  \n- m: 苹果的总数。  \n- t: 吃一个苹果所需的时间。  \n- s: 已经过的总时间。  \n该函数返回剩余的完整苹果数量。  \n>>> remainingApples(50, 10, 200)  \n30  \n>>> remainingApples(100, 5, 1000)  \n0  ",
      "fr": "Calculer le nombre de pommes entières restantes après un certain temps.\nManger une pomme prend un certain temps et vous ne pouvez manger qu'une pomme à la fois.\nLa fonction prend trois paramètres :\n- m : le nombre total de pommes.\n- t : le temps qu'il faut pour manger une pomme.\n- s : le temps total écoulé.\nLa fonction renvoie le nombre de pommes entières qui restent.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "de": "Berechne die Anzahl der verbleibenden ganzen Äpfel nach einer bestimmten Zeit.\nDas Essen eines Apfels dauert eine bestimmte Zeit und man kann nur einen Apfel auf einmal essen.\nDie Funktion nimmt drei Parameter:\n- m: die Gesamtanzahl der Äpfel.\n- t: die Zeit, die benötigt wird, um einen Apfel zu essen.\n- s: die insgesamt vergangene Zeit.\nDie Funktion gibt die Anzahl der verbleibenden ganzen Äpfel zurück.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "ha": "Ƙididdige adadin cikakkun tuffa da suka rage bayan wani lokaci. \nCin tuffa yana ɗaukar wani lokaci kuma za ka iya cin tuffa ɗaya kawai a lokaci guda. \nAikin yana ɗaukar sigogi guda uku: \n- m: jimillar adadin tuffa. \n- t: lokacin da ake ɗauka don cin tuffa ɗaya. \n- s: jimillar lokacin da ya wuce. \nAikin yana dawowa da adadin cikakkun tuffa da suka rage.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "hi": "समय की एक निश्चित मात्रा के बाद बचे हुए पूरे सेबों की संख्या की गणना करें।  \nएक सेब खाने में एक निश्चित समय लगता है और आप एक समय में केवल एक सेब खा सकते हैं।  \nयह फ़ंक्शन तीन पैरामीटर लेता है:  \n- m: सेबों की कुल संख्या।  \n- t: एक सेब खाने में लगने वाला समय।  \n- s: कुल बीता हुआ समय।  \nयह फ़ंक्शन बचे हुए पूरे सेबों की संख्या लौटाता है।  \n>>> remainingApples(50, 10, 200)  \n30  \n>>> remainingApples(100, 5, 1000)  \n0  ",
      "hu": "Számítsa ki a megmaradt egész almák számát egy bizonyos idő elteltével.\nEgy alma elfogyasztása egy bizonyos időt vesz igénybe, és egyszerre csak egy almát lehet megenni.\nA függvény három paramétert vesz fel:\n- m: az almák teljes száma.\n- t: az idő, ami egy alma elfogyasztásához szükséges.\n- s: az eltelt teljes idő.\nA függvény visszaadja a megmaradt egész almák számát.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9688545576233485",
      "hy": "0.9743143109068545",
      "bn": "0.9477649769169693",
      "bg": "0.9664066368074745",
      "zh": "0.9441159381869774",
      "fr": "0.9727850556032669",
      "de": "0.9694359487486376",
      "ha": "0.9397041587938114",
      "hi": "0.9526336061865154",
      "hu": "0.9626251116133323"
    }
  },
  {
    "task_id": "Swift/28",
    "prompt": {
      "en": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "sq": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nKontrollon nëse numri i dhënë pëlqehet nga katër individë:\n- Personi A pëlqen numrin nëse është çift dhe midis 4 dhe 12 (përfshirë).\n- Personi U pëlqen numrin nëse është ose çift ose midis 4 dhe 12 (përfshirë).\n- Personi H pëlqen numrin nëse ka saktësisht një nga dy vetitë (çift ose midis 4 dhe 12).\n- Personi G pëlqen numrin nëse nuk ka të dyja vetitë (çift dhe midis 4 dhe 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "hy": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nՍտուգում է, արդյոք տրված ամբողջ թիվը դուր է գալիս չորս անձանց.\n- Անձ Ա-ն սիրում է թիվը, եթե այն զույգ է և գտնվում է 4-ից 12 (ներառյալ) միջակայքում:\n- Անձ Ու-ն սիրում է թիվը, եթե այն կամ զույգ է, կամ գտնվում է 4-ից 12 (ներառյալ) միջակայքում:\n- Անձ Հ-ն սիրում է թիվը, եթե այն ունի միայն մեկ հատկություն (զույգ կամ գտնվում է 4-ից 12 միջակայքում):\n- Անձ Գ-ն սիրում է թիվը, եթե այն չունի երկու հատկություններն էլ (զույգ և գտնվում է 4-ից 12 միջակայքում):\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "bn": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nযাচাই করে যে প্রদত্ত পূর্ণসংখ্যাটি চারজন ব্যক্তির দ্বারা পছন্দ করা হয় কিনা:\n- ব্যক্তি A পূর্ণসংখ্যাটি পছন্দ করে যদি এটি জোড় সংখ্যা হয় এবং 4 এবং 12 এর মধ্যে হয় (অন্তর্ভুক্ত)।\n- ব্যক্তি U পূর্ণসংখ্যাটি পছন্দ করে যদি এটি হয় জোড় সংখ্যা অথবা 4 এবং 12 এর মধ্যে হয় (অন্তর্ভুক্ত)।\n- ব্যক্তি H পূর্ণসংখ্যাটি পছন্দ করে যদি এটি ঠিক দুটি বৈশিষ্ট্যের একটিতে থাকে (জোড় সংখ্যা অথবা 4 এবং 12 এর মধ্যে)।\n- ব্যক্তি G পূর্ণসংখ্যাটি পছন্দ করে যদি এতে উভয় বৈশিষ্ট্য না থাকে (জোড় সংখ্যা এবং 4 এবং 12 এর মধ্যে)।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "bg": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nПроверява дали даденото цяло число се харесва от четиримата души:\n- Лице A харесва числото, ако е четно и е между 4 и 12 (включително).\n- Лице U харесва числото, ако е или четно, или между 4 и 12 (включително).\n- Лице H харесва числото, ако притежава точно едно от двете свойства (четно или между 4 и 12).\n- Лице G харесва числото, ако не притежава и двете свойства (четно и между 4 и 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "zh": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\n检查给定的整数是否被四个人喜欢：\n- 如果一个整数是偶数并且在4到12之间（包括4和12），那么A喜欢这个整数。\n- 如果一个整数是偶数或者在4到12之间（包括4和12），那么U喜欢这个整数。\n- 如果一个整数恰好具有两个属性之一（偶数或在4到12之间），那么H喜欢这个整数。\n- 如果一个整数不具有两个属性（偶数和在4到12之间），那么G喜欢这个整数。\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "fr": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nVérifie si l'entier donné est apprécié par les quatre individus :\n- La personne A aime l'entier s'il est à la fois pair et compris entre 4 et 12 (inclus).\n- La personne U aime l'entier s'il est soit pair, soit compris entre 4 et 12 (inclus).\n- La personne H aime l'entier s'il possède exactement l'une des deux propriétés (pair ou compris entre 4 et 12).\n- La personne G aime l'entier s'il ne possède pas les deux propriétés (pair et compris entre 4 et 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "de": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nPrüft, ob die gegebene ganze Zahl von den vier Personen gemocht wird:\n- Person A mag die Zahl, wenn sie sowohl gerade als auch zwischen 4 und 12 (einschließlich) ist.\n- Person U mag die Zahl, wenn sie entweder gerade oder zwischen 4 und 12 (einschließlich) ist.\n- Person H mag die Zahl, wenn sie genau eine der beiden Eigenschaften hat (gerade oder zwischen 4 und 12).\n- Person G mag die Zahl, wenn sie keine der beiden Eigenschaften hat (gerade und zwischen 4 und 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "ha": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nDuba idan mutanen hudu suna son lambar da aka bayar:\n- Mutum A yana son lambar idan tana daidai da lamba mai mafarin biyu kuma tana tsakanin 4 da 12 (ciki har da).\n- Mutum U yana son lambar idan tana daidai da lamba mai mafarin biyu ko kuma tana tsakanin 4 da 12 (ciki har da).\n- Mutum H yana son lambar idan tana daidai da daya daga cikin abubuwa biyu (mai mafarin biyu ko tsakanin 4 da 12).\n- Mutum G yana son lambar idan ba ta da duka abubuwan biyu (mai mafarin biyu da tsakanin 4 da 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "hi": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nजाँच करता है कि दिए गए पूर्णांक को चार व्यक्तियों द्वारा पसंद किया गया है या नहीं:\n- व्यक्ति A को पूर्णांक पसंद है यदि यह सम है और 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति U को पूर्णांक पसंद है यदि यह या तो सम है या 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति H को पूर्णांक पसंद है यदि यह ठीक दो गुणों में से एक है (सम या 4 और 12 के बीच)।\n- व्यक्ति G को पूर्णांक पसंद है यदि इसमें दोनों गुण नहीं हैं (सम और 4 और 12 के बीच)।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "hu": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nEllenőrzi, hogy a megadott egész számot kedvelik-e a négy személy:\n- A személy kedveli az egész számot, ha az páros és 4 és 12 között van (beleértve).\n- U személy kedveli az egész számot, ha az vagy páros, vagy 4 és 12 között van (beleértve).\n- H személy kedveli az egész számot, ha pontosan az egyik tulajdonsággal rendelkezik (páros vagy 4 és 12 között).\n- G személy kedveli az egész számot, ha nem rendelkezik mindkét tulajdonsággal (páros és 4 és 12 között).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9555248700128592",
      "hy": "0.9048729310666765",
      "bn": "0.9469766129346417",
      "bg": "0.9596665120878177",
      "zh": "0.9022589552522574",
      "fr": "0.9910884479548697",
      "de": "0.9685147010413978",
      "ha": "0.8886809796654745",
      "hi": "0.969432373401779",
      "hu": "0.97719246512805"
    },
    "canonical_solution": "let isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}",
    "instruction": {
      "en": "Write a Swift function `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` to solve the following problem:\n\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n",
      "sq": "Shkruani një funksion Swift `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` për të zgjidhur problemin e mëposhtëm:\n\nKontrollon nëse numri i dhënë pëlqehet nga katër individët:\n- Personi A pëlqen numrin nëse është çift dhe ndërmjet 4 dhe 12 (përfshirë).\n- Personi U pëlqen numrin nëse është ose çift ose ndërmjet 4 dhe 12 (përfshirë).\n- Personi H pëlqen numrin nëse ka saktësisht një nga dy vetitë (çift ose ndërmjet 4 dhe 12).\n- Personi G pëlqen numrin nëse nuk ka të dyja vetitë (çift dhe ndërmjet 4 dhe 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hy": "Գրեք Swift ֆունկցիա `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` հետևյալ խնդիրը լուծելու համար:\n\nՍտուգում է, արդյոք տրված ամբողջ թիվը հավանվում է չորս անձանց կողմից.\n- Անձ Ա-ն հավանում է թիվը, եթե այն զույգ է և գտնվում է 4-ից 12 (ներառյալ) միջակայքում:\n- Անձ Ու-ն հավանում է թիվը, եթե այն կամ զույգ է, կամ գտնվում է 4-ից 12 (ներառյալ) միջակայքում:\n- Անձ Հ-ն հավանում է թիվը, եթե այն ունի հենց մեկ հատկություն (զույգ կամ գտնվում է 4-ից 12):\n- Անձ Գ-ն հավանում է թիվը, եթե այն չունի երկու հատկություններն էլ (զույգ և գտնվում է 4-ից 12):\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "bn": "একটি Swift ফাংশন `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nদেওয়া পূর্ণসংখ্যাটি চার ব্যক্তির দ্বারা পছন্দ করা হয় কিনা তা পরীক্ষা করে:\n- ব্যক্তি A পূর্ণসংখ্যাটি পছন্দ করে যদি এটি উভয়ই জোড় সংখ্যা হয় এবং 4 এবং 12 (অন্তর্ভুক্ত) এর মধ্যে হয়।\n- ব্যক্তি U পূর্ণসংখ্যাটি পছন্দ করে যদি এটি হয় জোড় সংখ্যা অথবা 4 এবং 12 (অন্তর্ভুক্ত) এর মধ্যে হয়।\n- ব্যক্তি H পূর্ণসংখ্যাটি পছন্দ করে যদি এটি ঠিক দুটি বৈশিষ্ট্যের মধ্যে একটি থাকে (জোড় সংখ্যা অথবা 4 এবং 12 এর মধ্যে)।\n- ব্যক্তি G পূর্ণসংখ্যাটি পছন্দ করে যদি এটি উভয় বৈশিষ্ট্য (জোড় সংখ্যা এবং 4 এবং 12 এর মধ্যে) না থাকে।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "bg": "Напишете Swift функция `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` за решаване на следния проблем:\n\nПроверява дали даденото цяло число е харесвано от четиримата индивиди:\n- Лице A харесва числото, ако е четно и между 4 и 12 (включително).\n- Лице U харесва числото, ако е или четно, или между 4 и 12 (включително).\n- Лице H харесва числото, ако има точно едно от двете свойства (четно или между 4 и 12).\n- Лице G харесва числото, ако не притежава и двете свойства (четно и между 4 и 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "zh": "编写一个 Swift 函数 `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` 来解决以下问题：\n\n检查给定的整数是否被四个人喜欢：\n- 如果整数是偶数且在 4 到 12 之间（包括 4 和 12），A 人喜欢这个整数。\n- 如果整数是偶数或在 4 到 12 之间（包括 4 和 12），U 人喜欢这个整数。\n- 如果整数恰好具有两个属性之一（偶数或在 4 到 12 之间），H 人喜欢这个整数。\n- 如果整数不具有两个属性（偶数和在 4 到 12 之间），G 人喜欢这个整数。\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "fr": "Écrire une fonction Swift `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` pour résoudre le problème suivant :\n\nVérifie si l'entier donné est apprécié par les quatre individus :\n- La personne A aime l'entier s'il est à la fois pair et compris entre 4 et 12 (inclus).\n- La personne U aime l'entier s'il est soit pair, soit compris entre 4 et 12 (inclus).\n- La personne H aime l'entier s'il possède exactement l'une des deux propriétés (pair ou compris entre 4 et 12).\n- La personne G aime l'entier s'il ne possède pas les deux propriétés (pair et compris entre 4 et 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "de": "Schreiben Sie eine Swift-Funktion `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {`, um das folgende Problem zu lösen:\n\nÜberprüft, ob die gegebene ganze Zahl von den vier Personen gemocht wird:\n- Person A mag die ganze Zahl, wenn sie sowohl gerade als auch zwischen 4 und 12 (einschließlich) ist.\n- Person U mag die ganze Zahl, wenn sie entweder gerade oder zwischen 4 und 12 (einschließlich) ist.\n- Person H mag die ganze Zahl, wenn sie genau eine der beiden Eigenschaften hat (gerade oder zwischen 4 und 12).\n- Person G mag die ganze Zahl, wenn sie nicht beide Eigenschaften hat (gerade und zwischen 4 und 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "ha": "Rubuta aikin Swift `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` don warware matsalar mai zuwa:\n\nDuba idan lambar da aka bayar tana da farin jini ga mutane hudu:\n- Mutum A yana son lambar idan tana da ma'ana kuma tana tsakanin 4 da 12 (ciki har da su).\n- Mutum U yana son lambar idan tana da ma'ana ko kuma tana tsakanin 4 da 12 (ciki har da su).\n- Mutum H yana son lambar idan tana daidai ɗaya daga cikin siffofin biyu (ma'ana ko tsakanin 4 da 12).\n- Mutum G yana son lambar idan ba ta da duka siffofin biyu (ma'ana da tsakanin 4 da 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hi": "स्विफ्ट फ़ंक्शन `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nजांचें कि दिए गए पूर्णांक को चार व्यक्तियों द्वारा पसंद किया गया है या नहीं:\n- व्यक्ति A को पूर्णांक पसंद है यदि यह सम है और 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति U को पूर्णांक पसंद है यदि यह या तो सम है या 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति H को पूर्णांक पसंद है यदि इसमें ठीक-ठीक दो गुणों में से एक है (सम या 4 और 12 के बीच)।\n- व्यक्ति G को पूर्णांक पसंद है यदि इसमें दोनों गुण (सम और 4 और 12 के बीच) नहीं हैं।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hu": "Írjon egy Swift függvényt `func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {` a következő probléma megoldására:\n\nEllenőrzi, hogy a megadott egész számot kedveli-e a négy személy:\n- A személy akkor kedveli az egész számot, ha az páros és 4 és 12 között van (beleértve).\n- U személy akkor kedveli az egész számot, ha az páros vagy 4 és 12 között van (beleértve).\n- H személy akkor kedveli az egész számot, ha pontosan az egyik tulajdonsággal rendelkezik (páros vagy 4 és 12 között van).\n- G személy akkor kedveli az egész számot, ha nem rendelkezik mindkét tulajdonsággal (páros és 4 és 12 között van).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)"
    },
    "instruction_bertscore": {
      "sq": "0.9556921167936906",
      "hy": "0.9089239976878831",
      "bn": "0.9579455784665314",
      "bg": "0.9601507729567808",
      "zh": "0.9085712301311651",
      "fr": "0.989325007432042",
      "de": "0.9888471027352721",
      "ha": "0.9481683952208511",
      "hi": "0.9701859770674254",
      "hu": "0.9547905334941732"
    },
    "level": "hard",
    "test": "func testCheckLikes(_ checkLikes: (Int) -> (Int, Int, Int, Int)) {\nassert(checkLikes(12) == (0, 1, 1, 0))\nassert(checkLikes(5) == (0, 1, 1, 0))\nassert(checkLikes(6) == (1, 1, 0, 0))\nassert(checkLikes(3) == (0, 0, 0, 1))\nassert(checkLikes(13) == (0, 0, 0, 1))\nassert(checkLikes(4) == (0, 1, 1, 0))\nassert(checkLikes(11) == (0, 1, 1, 0))\nassert(checkLikes(7) == (0, 1, 1, 0))\nassert(checkLikes(2) == (0, 1, 1, 0))\n}\n\ntestCheckLikes(checkLikes)",
    "entry_point": "checkLikes",
    "signature": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {",
    "docstring": {
      "en": "\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n",
      "sq": "Kontrollon nëse numri i dhënë i plotë pëlqehet nga katër individë:\n- Personi A pëlqen numrin e plotë nëse është si çift ashtu edhe midis 4 dhe 12 (përfshirë).\n- Personi U pëlqen numrin e plotë nëse është ose çift ose midis 4 dhe 12 (përfshirë).\n- Personi H pëlqen numrin e plotë nëse ka saktësisht një nga dy vetitë (çift ose midis 4 dhe 12).\n- Personi G pëlqen numrin e plotë nëse nuk ka të dyja vetitë (çift dhe midis 4 dhe 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hy": "Ստուգում է, արդյոք տրված ամբողջ թիվը հավանվում է չորս անձանց կողմից.\n- Անձ A-ն հավանում է թիվը, եթե այն զույգ է և գտնվում է 4-ից 12 (ներառյալ) միջակայքում:\n- Անձ U-ն հավանում է թիվը, եթե այն կամ զույգ է, կամ գտնվում է 4-ից 12 (ներառյալ) միջակայքում:\n- Անձ H-ն հավանում է թիվը, եթե այն ունի միայն մեկ հատկություն (զույգ կամ գտնվում է 4-ից 12 միջակայքում):\n- Անձ G-ն հավանում է թիվը, եթե այն չունի երկու հատկությունները (զույգ և գտնվում է 4-ից 12 միջակայքում):\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "bn": "Checks if the given integer is liked by the four individuals:\n- ব্যক্তি A পূর্ণসংখ্যাটি পছন্দ করে যদি এটি উভয়ই জোড় হয় এবং 4 এবং 12 এর মধ্যে হয় (অন্তর্ভুক্ত)।\n- ব্যক্তি U পূর্ণসংখ্যাটি পছন্দ করে যদি এটি হয় জোড় অথবা 4 এবং 12 এর মধ্যে (অন্তর্ভুক্ত)।\n- ব্যক্তি H পূর্ণসংখ্যাটি পছন্দ করে যদি এটি ঠিক দুটি বৈশিষ্ট্যের একটি হয় (জোড় অথবা 4 এবং 12 এর মধ্যে)।\n- ব্যক্তি G পূর্ণসংখ্যাটি পছন্দ করে যদি এটি উভয় বৈশিষ্ট্য না থাকে (জোড় এবং 4 এবং 12 এর মধ্যে)।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "bg": "Проверява дали даденото цяло число е харесвано от четиримата души:\n- Лице A харесва числото, ако е както четно, така и между 4 и 12 (включително).\n- Лице U харесва числото, ако е или четно, или между 4 и 12 (включително).\n- Лице H харесва числото, ако има точно едно от двете свойства (четно или между 4 и 12).\n- Лице G харесва числото, ако няма и двете свойства (четно и между 4 и 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "zh": "检查给定的整数是否被四个人喜欢：\n- 如果整数是偶数且在4到12之间（包括4和12），A喜欢这个整数。\n- 如果整数是偶数或在4到12之间（包括4和12），U喜欢这个整数。\n- 如果整数恰好具有两个属性之一（偶数或在4到12之间），H喜欢这个整数。\n- 如果整数不具有这两个属性（偶数和在4到12之间），G喜欢这个整数。\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "fr": "Vérifie si l'entier donné est apprécié par les quatre individus :\n- La personne A aime l'entier s'il est à la fois pair et compris entre 4 et 12 (inclus).\n- La personne U aime l'entier s'il est soit pair, soit compris entre 4 et 12 (inclus).\n- La personne H aime l'entier s'il possède exactement l'une des deux propriétés (pair ou compris entre 4 et 12).\n- La personne G aime l'entier s'il ne possède pas les deux propriétés (pair et compris entre 4 et 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "de": "Prüft, ob die gegebene ganze Zahl von den vier Personen gemocht wird:\n- Person A mag die ganze Zahl, wenn sie sowohl gerade als auch zwischen 4 und 12 (einschließlich) ist.\n- Person U mag die ganze Zahl, wenn sie entweder gerade oder zwischen 4 und 12 (einschließlich) ist.\n- Person H mag die ganze Zahl, wenn sie genau eine der beiden Eigenschaften hat (gerade oder zwischen 4 und 12).\n- Person G mag die ganze Zahl, wenn sie nicht beide Eigenschaften hat (gerade und zwischen 4 und 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "ha": "Yana duba idan lambar cikakken adadi da aka bayar tana da farin jini ga mutanen nan hudu:\n- Mutum A yana son lambar idan tana da ma'ana kuma tana tsakanin 4 da 12 (ciki har da).\n- Mutum U yana son lambar idan tana da ma'ana ko kuma tana tsakanin 4 da 12 (ciki har da).\n- Mutum H yana son lambar idan tana da ɗaya kawai daga cikin kaddarorin biyu (ma'ana ko tsakanin 4 da 12).\n- Mutum G yana son lambar idan ba ta da duka kaddarorin biyu (ma'ana da tsakanin 4 da 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hi": "दिए गए पूर्णांक की जाँच करता है कि क्या यह चार व्यक्तियों को पसंद है:\n- व्यक्ति A को पूर्णांक पसंद है यदि यह सम है और 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति U को पूर्णांक पसंद है यदि यह या तो सम है या 4 और 12 के बीच (समावेशी) है।\n- व्यक्ति H को पूर्णांक पसंद है यदि यह ठीक दो गुणों में से एक है (सम या 4 और 12 के बीच)।\n- व्यक्ति G को पूर्णांक पसंद है यदि इसमें दोनों गुण नहीं हैं (सम और 4 और 12 के बीच)।\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "hu": "Ellenőrzi, hogy a megadott egész szám tetszik-e a négy személynek:\n- A személynek tetszik az egész szám, ha páros és 4 és 12 között van (beleértve).\n- U személynek tetszik az egész szám, ha páros vagy 4 és 12 között van (beleértve).\n- H személynek tetszik az egész szám, ha pontosan az egyik tulajdonsággal rendelkezik (páros vagy 4 és 12 között).\n- G személynek tetszik az egész szám, ha nem rendelkezik mindkét tulajdonsággal (páros és 4 és 12 között).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9751108187348043",
      "hy": "0.8975621412623064",
      "bn": "0.9869418401203854",
      "bg": "0.9564258574212334",
      "zh": "0.868443523293735",
      "fr": "0.9831899108530174",
      "de": "0.9883449651320159",
      "ha": "0.9253978055997736",
      "hi": "0.9639634831207454",
      "hu": "0.9451128640693914"
    }
  },
  {
    "task_id": "Swift/29",
    "prompt": {
      "en": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "sq": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nPërcaktoni nëse një vit i dhënë është vit i brishtë.\nNjë vit i brishtë është i ndashëm saktësisht me 4 përveç viteve në fund të shekullit të cilat duhet të jenë të ndashme me 400.\nKjo do të thotë që viti 2000 ishte vit i brishtë, megjithëse 1900 nuk ishte.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "hy": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nՍահմանել՝ արդյոք տրված տարին նահանջ տարի է:\nՆահանջ տարին ճիշտ բաժանվում է 4-ի, բացառությամբ դարավերջի տարիների, որոնք պետք է բաժանվեն 400-ի:\nՍա նշանակում է, որ 2000 թվականը նահանջ տարի էր, չնայած 1900-ը չէր:\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "bn": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nএকটি প্রদত্ত বছর লিপ ইয়ার কিনা তা নির্ধারণ করুন।\nএকটি লিপ ইয়ার ঠিক ৪ দ্বারা বিভাজ্য হয়, তবে শতাব্দীর শেষের বছরগুলো অবশ্যই ৪০০ দ্বারা বিভাজ্য হতে হবে।\nএর মানে হল যে ২০০০ সাল একটি লিপ ইয়ার ছিল, যদিও ১৯০০ সাল ছিল না।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "bg": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nОпределете дали дадена година е високосна.\nВисокосна година е точно делима на 4, с изключение на годините в края на века, които трябва да са делими на 400.\nТова означава, че годината 2000 беше високосна, въпреки че 1900 не беше.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "zh": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\n确定给定的年份是否为闰年。\n闰年能被4整除，但世纪末的年份必须能被400整除。\n这意味着2000年是闰年，而1900年不是。\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "fr": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDétermine si une année donnée est une année bissextile.\nUne année bissextile est exactement divisible par 4, sauf pour les années de fin de siècle qui doivent être divisibles par 400.\nCela signifie que l'année 2000 était une année bissextile, bien que 1900 ne l'était pas.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "de": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nBestimmen, ob ein gegebenes Jahr ein Schaltjahr ist.\nEin Schaltjahr ist genau durch 4 teilbar, außer bei Jahrhundertjahren, die durch 400 teilbar sein müssen.\nDas bedeutet, dass das Jahr 2000 ein Schaltjahr war, obwohl 1900 keines war.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "ha": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nGano ko shekara da aka bayar shekara ce mai tsallakewa.\nShekara mai tsallakewa ita ce wadda za a iya rabawa da 4 ba tare da saura ba, sai dai shekarun ƙarshen ƙarni waɗanda dole ne a raba su da 400.\nWannan yana nufin cewa shekarar 2000 shekara ce mai tsallakewa, ko da yake shekarar 1900 ba ta kasance ba.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "hi": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nयह निर्धारित करें कि दिया गया वर्ष लीप वर्ष है या नहीं।\nएक लीप वर्ष वह होता है जो 4 से पूरी तरह विभाज्य होता है, सिवाय शताब्दी के अंत वाले वर्षों के जिन्हें 400 से विभाज्य होना चाहिए।\nइसका मतलब है कि वर्ष 2000 एक लीप वर्ष था, हालांकि 1900 नहीं था।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "hu": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nHatározza meg, hogy egy adott év szökőév-e.\nEgy szökőév pontosan osztható 4-gyel, kivéve az évszázad végi éveket, amelyeknek oszthatónak kell lenniük 400-zal.\nEz azt jelenti, hogy a 2000-es év szökőév volt, bár az 1900-as nem volt az.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9883531089776383",
      "bn": "0.9839409323237103",
      "bg": "0.9939181363630928",
      "zh": "0.9694808392147515",
      "fr": "0.9913941401112825",
      "de": "0.9799013862646038",
      "ha": "0.9657459921601524",
      "hi": "0.9712510331705344",
      "hu": "0.9939181363630928"
    },
    "canonical_solution": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}",
    "instruction": {
      "en": "Write a Swift function `func isLeapYear(_ year: Int) -> Int {` to solve the following problem:\n\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n",
      "sq": "Shkruani një funksion Swift `func isLeapYear(_ year: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nPërcaktoni nëse një vit i dhënë është vit i brishtë.\nNjë vit i brishtë është saktësisht i pjesëtueshëm me 4 përveç viteve në fund të shekullit të cilët duhet të jenë të pjesëtueshëm me 400.\nKjo do të thotë që viti 2000 ishte vit i brishtë, megjithëse 1900 nuk ishte.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "hy": "Գրեք Swift ֆունկցիա `func isLeapYear(_ year: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՍահմանել, արդյոք տրված տարին նահանջ տարի է:\nՆահանջ տարին ամբողջությամբ բաժանվում է 4-ի, բացառությամբ դարավերջի տարիների, որոնք պետք է բաժանվեն 400-ի:\nՍա նշանակում է, որ 2000 թվականը նահանջ տարի էր, թեև 1900 թվականը չէր:\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "bn": "একটি Swift ফাংশন `func isLeapYear(_ year: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nনির্ধারণ করুন একটি প্রদত্ত বছর লিপ ইয়ার কিনা।\nএকটি লিপ ইয়ার ঠিক ৪ দ্বারা বিভাজ্য হয়, তবে শতাব্দীর শেষের বছরগুলির জন্য ৪০০ দ্বারা বিভাজ্য হতে হবে।\nএর মানে হল যে ২০০০ সালটি একটি লিপ ইয়ার ছিল, যদিও ১৯০০ সালটি ছিল না।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "bg": "Напишете Swift функция `func isLeapYear(_ year: Int) -> Int {`, за да решите следния проблем:\n\nОпределете дали дадена година е високосна.\nВисокосна година е точно делима на 4, с изключение на годините в края на века, които трябва да са делими на 400.\nТова означава, че годината 2000 беше високосна, въпреки че 1900 не беше.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "zh": "编写一个 Swift 函数 `func isLeapYear(_ year: Int) -> Int {` 来解决以下问题：\n\n确定给定年份是否为闰年。  \n闰年是可以被4整除的年份，但世纪末的年份必须能被400整除。  \n这意味着2000年是闰年，而1900年不是。  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "fr": "Écrire une fonction Swift `func isLeapYear(_ year: Int) -> Int {` pour résoudre le problème suivant :\n\nDéterminer si une année donnée est une année bissextile.  \nUne année bissextile est exactement divisible par 4, sauf pour les années de fin de siècle qui doivent être divisibles par 400.  \nCela signifie que l'année 2000 était une année bissextile, bien que 1900 ne l'était pas.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "de": "Schreiben Sie eine Swift-Funktion `func isLeapYear(_ year: Int) -> Int {`, um das folgende Problem zu lösen:\n\nBestimmen Sie, ob ein gegebenes Jahr ein Schaltjahr ist.  \nEin Schaltjahr ist genau durch 4 teilbar, außer bei Jahrhundertjahren, die durch 400 teilbar sein müssen.  \nDas bedeutet, dass das Jahr 2000 ein Schaltjahr war, obwohl 1900 keines war.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "ha": "Rubuta aikin Swift `func isLeapYear(_ year: Int) -> Int {` don warware matsalar mai zuwa:\n\nGano ko shekara da aka bayar shekara ce ta tsalle.\nShekara ta tsalle tana rabuwa da 4 ba tare da saura ba sai dai shekarun ƙarshen ƙarni waɗanda dole ne su rabu da 400.\nWannan yana nufin cewa shekarar 2000 shekara ce ta tsalle, duk da cewa 1900 ba ta kasance ba.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "hi": "एक Swift फ़ंक्शन `func isLeapYear(_ year: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nनिर्धारित करें कि दिया गया वर्ष एक लीप वर्ष है या नहीं।\nएक लीप वर्ष 4 से पूरी तरह विभाज्य होता है, सिवाय शताब्दी के अंत वाले वर्षों के जो 400 से विभाज्य होने चाहिए।\nइसका मतलब है कि वर्ष 2000 एक लीप वर्ष था, हालांकि 1900 नहीं था।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "hu": "Írj egy Swift függvényt `func isLeapYear(_ year: Int) -> Int {` a következő probléma megoldására:\n\nHatározd meg, hogy egy adott év szökőév-e.\nEgy szökőév pontosan osztható 4-gyel, kivéve az évszázad végét jelentő éveket, amelyeknek oszthatónak kell lenniük 400-zal.\nEz azt jelenti, hogy a 2000-es év szökőév volt, bár az 1900-as nem.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9899177204890501",
      "bn": "0.974761427894564",
      "bg": "0.9937135470706269",
      "zh": "0.9691715717114802",
      "fr": "0.9973103460104066",
      "de": "0.9785860558813908",
      "ha": "0.9811956618274271",
      "hi": "0.9824351154050849",
      "hu": "0.9921183464805357"
    },
    "level": "easy",
    "test": "func check(_ isLeapYear: (Int) -> Int) {\nassert(isLeapYear(1926) == 0)\nassert(isLeapYear(1900) == 0)\nassert(isLeapYear(2000) == 1)\nassert(isLeapYear(1996) == 1)\nassert(isLeapYear(2020) == 1)\nassert(isLeapYear(2021) == 0)\nassert(isLeapYear(2022) == 0)\nassert(isLeapYear(2023) == 0)\nassert(isLeapYear(2024) == 1)\n}\n\ncheck(isLeapYear)",
    "entry_point": "isLeapYear",
    "signature": "func isLeapYear(_ year: Int) -> Int {",
    "docstring": {
      "en": "\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n",
      "sq": "Përcaktoni nëse një vit i dhënë është vit i brishtë.\nNjë vit i brishtë është i ndashëm saktësisht me 4 përveç viteve në fund të shekullit të cilat duhet të jenë të ndashëm me 400.\nKjo do të thotë që viti 2000 ishte vit i brishtë, megjithëse 1900 nuk ishte.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "hy": "Սահմանել, արդյոք տրված տարին նահանջ տարի է:\nՆահանջ տարին ճշգրիտ բաժանվում է 4-ի, բացառությամբ դարավերջի տարիների, որոնք պետք է բաժանվեն 400-ի:\nՍա նշանակում է, որ 2000 թվականը նահանջ տարի էր, չնայած 1900 թվականը չէր:\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "bn": "একটি প্রদত্ত বছর অধিবর্ষ কিনা তা নির্ধারণ করুন। \nএকটি অধিবর্ষ ঠিক ৪ দ্বারা বিভাজ্য হয়, তবে শতাব্দীর শেষের বছরগুলির জন্য ৪০০ দ্বারা বিভাজ্য হতে হবে। \nএর অর্থ হল ২০০০ বছরটি অধিবর্ষ ছিল, যদিও ১৯০০ ছিল না।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "bg": "Определете дали дадена година е високосна.\nВисокосна година е тази, която се дели точно на 4, с изключение на годините в края на века, които трябва да се делят на 400.\nТова означава, че годината 2000 беше високосна, въпреки че 1900 не беше.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "zh": "确定给定年份是否为闰年。  \n闰年可以被4整除，但世纪末年份必须能被400整除。  \n这意味着2000年是闰年，而1900年不是。  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "fr": "Déterminer si une année donnée est une année bissextile.  \nUne année bissextile est exactement divisible par 4, sauf pour les années de fin de siècle qui doivent être divisibles par 400.  \nCela signifie que l'année 2000 était une année bissextile, bien que 1900 ne l'était pas.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "de": "Bestimmen Sie, ob ein gegebenes Jahr ein Schaltjahr ist.\nEin Schaltjahr ist genau durch 4 teilbar, außer bei Jahrhundertjahren, die durch 400 teilbar sein müssen.\nDas bedeutet, dass das Jahr 2000 ein Schaltjahr war, obwohl 1900 keines war.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "ha": "Kunna ko shekara da aka bayar shekara ce mai tsallakewa.  \nShekara mai tsallakewa tana rabuwa daidai da 4 sai dai shekarun ƙarshen ƙarni waɗanda dole ne su rabu da 400.  \nWannan yana nufin cewa shekarar 2000 shekara ce mai tsallakewa, ko da yake 1900 ba ta kasance ba.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "hi": "यह निर्धारित करें कि दिया गया वर्ष लीप वर्ष है या नहीं।\nएक लीप वर्ष 4 से पूरी तरह विभाज्य होता है, सिवाय शताब्दी के अंत वाले वर्षों के, जिन्हें 400 से विभाज्य होना चाहिए।\nइसका मतलब है कि वर्ष 2000 एक लीप वर्ष था, हालांकि 1900 नहीं था।\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "hu": "Határozza meg, hogy egy adott év szökőév-e.\nEgy szökőév pontosan osztható 4-gyel, kivéve az évszázad végi éveket, amelyeknek oszthatónak kell lenniük 400-zal.\nEz azt jelenti, hogy a 2000-es év szökőév volt, bár az 1900-as nem volt az.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9919272640539801",
      "bn": "0.9740890640547609",
      "bg": "0.9819238408043011",
      "zh": "0.9707830599928162",
      "fr": "0.998291977353481",
      "de": "0.9844001657646629",
      "ha": "0.9877852247182596",
      "hi": "0.9718191160602943",
      "hu": "0.9952422064830713"
    }
  },
  {
    "task_id": "Swift/30",
    "prompt": {
      "en": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/",
      "sq": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nLlogarit numrin e ditëve në një muaj të caktuar të një viti të caktuar.\nMerr parasysh nëse viti është vit i brishtë apo jo.\n\n- Parametrat:\n- year: Viti për të cilin do të llogaritet numri i ditëve.\n- month: Muaji për të cilin do të llogaritet numri i ditëve.\n\n- Kthen: Numrin e ditëve në muajin e dhënë të vitit të dhënë.\n\nShembuj:\ndaysInMonth(1926, 8) // Kthen 31\ndaysInMonth(2000, 2) // Kthen 29\n*/",
      "hy": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nՀաշվում է օրերի քանակը տրված տարվա տրված ամսում:\nՀաշվի է առնում՝ տարին նահանջ տարի է, թե ոչ:\n\n- Պարամետրեր:\n- year: Տարին, որի համար պետք է հաշվել օրերի քանակը:\n- month: Ամիսը, որի համար պետք է հաշվել օրերի քանակը:\n\n- Վերադարձնում է: Օրերի քանակը տրված տարվա տրված ամսում:\n\nՕրինակներ:\ndaysInMonth(1926, 8) // Վերադարձնում է 31\ndaysInMonth(2000, 2) // Վերադարձնում է 29\n*/",
      "bn": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nএকটি প্রদত্ত বছরের একটি নির্দিষ্ট মাসের দিনগুলির সংখ্যা গণনা করে।\nবছরটি অধিবর্ষ কিনা তা বিবেচনা করে।\n\n- প্যারামিটারসমূহ:\n- year: যে বছরের জন্য দিনগুলির সংখ্যা গণনা করতে হবে।\n- month: যে মাসের জন্য দিনগুলির সংখ্যা গণনা করতে হবে।\n\n- রিটার্নস: প্রদত্ত বছরের প্রদত্ত মাসের দিনগুলির সংখ্যা।\n\nউদাহরণসমূহ:\ndaysInMonth(1926, 8) // 31 রিটার্ন করে\ndaysInMonth(2000, 2) // 29 রিটার্ন করে\n*/",
      "bg": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nИзчислява броя на дните в даден месец от дадена година.\nВзема предвид дали годината е високосна или не.\n\n- Параметри:\n- year: Годината, за която да се изчисли броят на дните.\n- month: Месецът, за който да се изчисли броят на дните.\n\n- Връща: Броят на дните в дадения месец от дадената година.\n\nПримери:\ndaysInMonth(1926, 8) // Връща 31\ndaysInMonth(2000, 2) // Връща 29\n*/",
      "zh": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\n计算给定年份中给定月份的天数。\n考虑到年份是否为闰年。\n\n- 参数:\n- year: 要计算天数的年份。\n- month: 要计算天数的月份。\n\n- 返回: 给定年份中给定月份的天数。\n\n示例:\ndaysInMonth(1926, 8) // 返回 31\ndaysInMonth(2000, 2) // 返回 29\n*/",
      "fr": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalcule le nombre de jours dans un mois donné d'une année donnée.\nPrend en compte si l'année est bissextile ou non.\n\n- Paramètres :\n- year : L'année pour laquelle calculer le nombre de jours.\n- month : Le mois pour lequel calculer le nombre de jours.\n\n- Retourne : Le nombre de jours dans le mois donné de l'année donnée.\n\nExemples :\ndaysInMonth(1926, 8) // Retourne 31\ndaysInMonth(2000, 2) // Retourne 29\n*/",
      "de": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nBerechnet die Anzahl der Tage in einem bestimmten Monat eines bestimmten Jahres.\nBerücksichtigt, ob das Jahr ein Schaltjahr ist oder nicht.\n\n- Parameter:\n- year: Das Jahr, für das die Anzahl der Tage berechnet werden soll.\n- month: Der Monat, für den die Anzahl der Tage berechnet werden soll.\n\n- Rückgabe: Die Anzahl der Tage im angegebenen Monat des angegebenen Jahres.\n\nBeispiele:\ndaysInMonth(1926, 8) // Gibt 31 zurück\ndaysInMonth(2000, 2) // Gibt 29 zurück\n*/",
      "ha": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nYana lissafin yawan kwanaki a wata na wani shekara da aka bayar.\nYana la'akari da ko shekarar shekara mai tsallakewa ce ko a'a.\n\n- Sigogi:\n- year: Shekarar da za a lissafa yawan kwanaki.\n- month: Watan da za a lissafa yawan kwanaki.\n\n- Komawa: Yawan kwanaki a watan da aka bayar na shekarar da aka bayar.\n\nMisalai:\ndaysInMonth(1926, 8) // Yana dawowa 31\ndaysInMonth(2000, 2) // Yana dawowa 29\n*/",
      "hi": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nकिसी दिए गए वर्ष के किसी दिए गए महीने में दिनों की संख्या की गणना करता है।\nयह ध्यान में रखता है कि वर्ष लीप वर्ष है या नहीं।\n\n- पैरामीटर्स:\n- year: वर्ष जिसके लिए दिनों की संख्या की गणना करनी है।\n- month: महीने जिसके लिए दिनों की संख्या की गणना करनी है।\n\n- रिटर्न्स: दिए गए वर्ष के दिए गए महीने में दिनों की संख्या।\n\nउदाहरण:\ndaysInMonth(1926, 8) // 31 लौटाता है\ndaysInMonth(2000, 2) // 29 लौटाता है\n*/",
      "hu": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nKiszámítja a napok számát egy adott év adott hónapjában.\nFigyelembe veszi, hogy az év szökőév-e vagy sem.\n\n- Paraméterek:\n- year: Az év, amelyre a napok számát ki kell számítani.\n- month: A hónap, amelyre a napok számát ki kell számítani.\n\n- Visszatér: A napok száma az adott év adott hónapjában.\n\nPéldák:\ndaysInMonth(1926, 8) // Visszatér 31\ndaysInMonth(2000, 2) // Visszatér 29\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9765697588835056",
      "hy": "0.9765461218681625",
      "bn": "0.9621865357320073",
      "bg": "1",
      "zh": "0.9827481568855958",
      "fr": "1",
      "de": "0.9571166938864728",
      "ha": "0.9906671529166947",
      "hi": "0.9737639061210068",
      "hu": "0.9765461218681625"
    },
    "canonical_solution": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "instruction": {
      "en": "Write a Swift function `func daysInMonth(_ year: Int, _ month: Int) -> Int {` to solve the following problem:\n\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n",
      "sq": "Shkruani një funksion Swift `func daysInMonth(_ year: Int, _ month: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nLlogarit numrin e ditëve në një muaj të caktuar të një viti të caktuar. Merr parasysh nëse viti është vit i brishtë apo jo.\n\n- Parametrat:\n- year: Viti për të cilin do të llogaritet numri i ditëve.\n- month: Muaji për të cilin do të llogaritet numri i ditëve.\n\n- Kthen: Numri i ditëve në muajin e dhënë të vitit të dhënë.\n\nShembuj:\ndaysInMonth(1926, 8) // Kthen 31\ndaysInMonth(2000, 2) // Kthen 29",
      "hy": "Գրեք Swift ֆունկցիա `func daysInMonth(_ year: Int, _ month: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է օրերի քանակը տրված տարվա տրված ամսում:\nՀաշվի է առնում, արդյոք տարին նահանջ տարի է, թե ոչ:\n\n- Պարամետրեր:\n- year: Տարին, որի համար պետք է հաշվել օրերի քանակը:\n- month: Ամիսը, որի համար պետք է հաշվել օրերի քանակը:\n\n- Վերադարձնում է: Օրերի քանակը տրված տարվա տրված ամսում:\n\nՕրինակներ:\ndaysInMonth(1926, 8) // Վերադարձնում է 31\ndaysInMonth(2000, 2) // Վերադարձնում է 29",
      "bn": "একটি Swift ফাংশন `func daysInMonth(_ year: Int, _ month: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি প্রদত্ত বছরের একটি নির্দিষ্ট মাসে দিনের সংখ্যা গণনা করে।\nবছরটি অধিবর্ষ কিনা তা বিবেচনা করে।\n\n- প্যারামিটারসমূহ:\n- year: যে বছরের জন্য দিনের সংখ্যা গণনা করতে হবে।\n- month: যে মাসের জন্য দিনের সংখ্যা গণনা করতে হবে।\n\n- রিটার্নস: প্রদত্ত বছরের প্রদত্ত মাসে দিনের সংখ্যা।\n\nউদাহরণসমূহ:\ndaysInMonth(1926, 8) // 31 রিটার্ন করে\ndaysInMonth(2000, 2) // 29 রিটার্ন করে",
      "bg": "Напишете Swift функция `func daysInMonth(_ year: Int, _ month: Int) -> Int {`, за да решите следния проблем:\n\nИзчислява броя на дните в даден месец на дадена година. Взема предвид дали годината е високосна или не.\n\n- Параметри:\n- year: Годината, за която да се изчисли броят на дните.\n- month: Месецът, за който да се изчисли броят на дните.\n\n- Връща: Броят на дните в дадения месец на дадената година.\n\nПримери:\ndaysInMonth(1926, 8) // Връща 31\ndaysInMonth(2000, 2) // Връща 29",
      "zh": "编写一个 Swift 函数 `func daysInMonth(_ year: Int, _ month: Int) -> Int {` 来解决以下问题：\n\n计算给定年份中给定月份的天数。\n考虑到年份是否为闰年。\n\n- 参数：\n- year: 要计算天数的年份。\n- month: 要计算天数的月份。\n\n- 返回值：给定年份中给定月份的天数。\n\n示例：\ndaysInMonth(1926, 8) // 返回 31\ndaysInMonth(2000, 2) // 返回 29",
      "fr": "Écrire une fonction Swift `func daysInMonth(_ year: Int, _ month: Int) -> Int {` pour résoudre le problème suivant :\n\nCalcule le nombre de jours dans un mois donné d'une année donnée. Prend en compte si l'année est bissextile ou non.\n\n- Paramètres :\n- year: L'année pour laquelle calculer le nombre de jours.\n- month: Le mois pour lequel calculer le nombre de jours.\n\n- Renvoie : Le nombre de jours dans le mois donné de l'année donnée.\n\nExemples :\ndaysInMonth(1926, 8) // Renvoie 31\ndaysInMonth(2000, 2) // Renvoie 29",
      "de": "Schreiben Sie eine Swift-Funktion `func daysInMonth(_ year: Int, _ month: Int) -> Int {`, um das folgende Problem zu lösen:\n\nBerechnet die Anzahl der Tage in einem gegebenen Monat eines gegebenen Jahres.\nBerücksichtigt, ob das Jahr ein Schaltjahr ist oder nicht.\n\n- Parameter:\n- year: Das Jahr, für das die Anzahl der Tage berechnet werden soll.\n- month: Der Monat, für den die Anzahl der Tage berechnet werden soll.\n\n- Rückgabe: Die Anzahl der Tage im gegebenen Monat des gegebenen Jahres.\n\nBeispiele:\ndaysInMonth(1926, 8) // Gibt 31 zurück\ndaysInMonth(2000, 2) // Gibt 29 zurück",
      "ha": "Rubuta aikin Swift `func daysInMonth(_ year: Int, _ month: Int) -> Int {` don warware matsalar mai zuwa:\n\nLissafa yawan kwanaki a wata da aka bayar na shekara da aka bayar.\nYana la'akari da ko shekarar shekara mai tsallakewa ce ko a'a.\n\n- Sigogi:\n- year: Shekarar da za a lissafa yawan kwanaki.\n- month: Watan da za a lissafa yawan kwanaki.\n\n- Komawa: Yawan kwanaki a watan da aka bayar na shekarar da aka bayar.\n\nMisalai:\ndaysInMonth(1926, 8) // Yana dawowa 31\ndaysInMonth(2000, 2) // Yana dawowa 29",
      "hi": "Swift फ़ंक्शन `func daysInMonth(_ year: Int, _ month: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nदिए गए वर्ष के एक दिए गए महीने में दिनों की संख्या की गणना करता है। यह ध्यान में रखता है कि वर्ष लीप वर्ष है या नहीं।\n\n- पैरामीटर्स:\n- year: वह वर्ष जिसके लिए दिनों की संख्या की गणना करनी है।\n- month: वह महीना जिसके लिए दिनों की संख्या की गणना करनी है।\n\n- रिटर्न्स: दिए गए वर्ष के दिए गए महीने में दिनों की संख्या।\n\nउदाहरण:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29",
      "hu": "Írj egy Swift függvényt `func daysInMonth(_ year: Int, _ month: Int) -> Int {` a következő probléma megoldására:\n\nKiszámítja a napok számát egy adott év adott hónapjában.\nFigyelembe veszi, hogy az év szökőév-e vagy sem.\n\n- Paraméterek:\n- year: Az év, amelyre a napok számát ki kell számítani.\n- month: A hónap, amelyre a napok számát ki kell számítani.\n\n- Visszatérési érték: A napok száma az adott év adott hónapjában.\n\nPéldák:\ndaysInMonth(1926, 8) // Visszatér 31\ndaysInMonth(2000, 2) // Visszatér 29"
    },
    "instruction_bertscore": {
      "sq": "0.976207258438117",
      "hy": "0.9742114203694784",
      "bn": "0.9630251532007366",
      "bg": "0.998445518638021",
      "zh": "0.9828619720939288",
      "fr": "0.9981865046211514",
      "de": "0.9749425788020678",
      "ha": "0.9824718620255762",
      "hi": "0.9670682746067017",
      "hu": "0.974254920422925"
    },
    "level": "easy",
    "test": "func testDaysInMonth() {\n// Non-leap years\nassert(daysInMonth(1926, 8) == 31)\nassert(daysInMonth(1999, 12) == 31)\n\n// Leap years\nassert(daysInMonth(2000, 2) == 29)\nassert(daysInMonth(2020, 2) == 29)\n\n// Months with 30 days\nassert(daysInMonth(2022, 4) == 30)\nassert(daysInMonth(2022, 6) == 30)\n\n// Months with 31 days\nassert(daysInMonth(2022, 1) == 31)\nassert(daysInMonth(2022, 3) == 31)\n}\n\ntestDaysInMonth()",
    "entry_point": "daysInMonth",
    "signature": "func daysInMonth(_ year: Int, _ month: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n",
      "sq": "Llogarit numrin e ditëve në një muaj të caktuar të një viti të caktuar. Merr parasysh nëse viti është vit i brishtë apo jo.\n\n- Parametrat:\n- year: Viti për të cilin do të llogaritet numri i ditëve.\n- month: Muaji për të cilin do të llogaritet numri i ditëve.\n\n- Kthen: Numri i ditëve në muajin e dhënë të vitit të dhënë.\n\nShembuj:\ndaysInMonth(1926, 8) // Kthen 31\ndaysInMonth(2000, 2) // Kthen 29",
      "hy": "Հաշվում է օրերի քանակը տրված տարվա տրված ամսում։ Հաշվի է առնում՝ արդյոք տարին նահանջ տարի է, թե ոչ։\n\n- Պարամետրեր:\n- year: Տարին, որի համար պետք է հաշվել օրերի քանակը։\n- month: Ամիսը, որի համար պետք է հաշվել օրերի քանակը։\n\n- Վերադարձնում է: Օրերի քանակը տրված տարվա տրված ամսում։\n\nՕրինակներ:\ndaysInMonth(1926, 8) // Վերադարձնում է 31\ndaysInMonth(2000, 2) // Վերադարձնում է 29",
      "bn": "একটি প্রদত্ত বছরের একটি প্রদত্ত মাসে দিনের সংখ্যা গণনা করে। \nবছরটি লিপ ইয়ার কিনা তা বিবেচনায় নেয়।\n\n- প্যারামিটারসমূহ:\n- year: যে বছরের জন্য দিনের সংখ্যা গণনা করতে হবে।\n- month: যে মাসের জন্য দিনের সংখ্যা গণনা করতে হবে।\n\n- রিটার্ন: প্রদত্ত বছরের প্রদত্ত মাসে দিনের সংখ্যা।\n\nউদাহরণ:\ndaysInMonth(1926, 8) // 31 রিটার্ন করে\ndaysInMonth(2000, 2) // 29 রিটার্ন করে",
      "bg": "Изчислява броя на дните в даден месец на дадена година. Взема предвид дали годината е високосна или не.\n\n- Параметри:\n- year: Годината, за която да се изчисли броят на дните.\n- month: Месецът, за който да се изчисли броят на дните.\n\n- Връща: Броят на дните в дадения месец на дадената година.\n\nПримери:\ndaysInMonth(1926, 8) // Връща 31\ndaysInMonth(2000, 2) // Връща 29",
      "zh": "计算给定年份中给定月份的天数。\n考虑到年份是否为闰年。\n\n- 参数:\n- year: 要计算天数的年份。\n- month: 要计算天数的月份。\n\n- 返回: 给定年份中给定月份的天数。\n\n示例:\ndaysInMonth(1926, 8) // 返回 31\ndaysInMonth(2000, 2) // 返回 29",
      "fr": "Calcule le nombre de jours dans un mois donné d'une année donnée.  \nPrend en compte si l'année est bissextile ou non.\n\n- Paramètres:\n- year: L'année pour laquelle calculer le nombre de jours.\n- month: Le mois pour lequel calculer le nombre de jours.\n\n- Renvoie: Le nombre de jours dans le mois donné de l'année donnée.\n\nExemples:\ndaysInMonth(1926, 8) // Renvoie 31\ndaysInMonth(2000, 2) // Renvoie 29",
      "de": "Berechnet die Anzahl der Tage in einem gegebenen Monat eines gegebenen Jahres.\nBerücksichtigt, ob das Jahr ein Schaltjahr ist oder nicht.\n\n- Parameter:\n- year: Das Jahr, für das die Anzahl der Tage berechnet werden soll.\n- month: Der Monat, für den die Anzahl der Tage berechnet werden soll.\n\n- Rückgabewert: Die Anzahl der Tage im angegebenen Monat des angegebenen Jahres.\n\nBeispiele:\ndaysInMonth(1926, 8) // Gibt 31 zurück\ndaysInMonth(2000, 2) // Gibt 29 zurück",
      "ha": "Calculates the number of days in a given month of a given year.  \nYana ɗaukar la'akari ko shekarar shekara ce mai tsallakewa ko a'a.\n\n- Parameters:  \n- year: Shekarar da za a ƙididdige yawan kwanaki.  \n- month: Watan da za a ƙididdige yawan kwanaki.  \n\n- Returns: Yawan kwanaki a cikin watan da aka bayar na shekarar da aka bayar.  \n\nExamples:  \ndaysInMonth(1926, 8) // Returns 31  \ndaysInMonth(2000, 2) // Returns 29  ",
      "hi": "दिए गए वर्ष के किसी दिए गए महीने में दिनों की संख्या की गणना करता है। यह ध्यान में रखता है कि वर्ष लीप वर्ष है या नहीं।\n\n- पैरामीटर्स:\n- year: वह वर्ष जिसके लिए दिनों की संख्या की गणना करनी है।\n- month: वह महीना जिसके लिए दिनों की संख्या की गणना करनी है।\n\n- रिटर्न्स: दिए गए वर्ष के दिए गए महीने में दिनों की संख्या।\n\nउदाहरण:\ndaysInMonth(1926, 8) // 31 लौटाता है\ndaysInMonth(2000, 2) // 29 लौटाता है",
      "hu": "Kiszámítja a napok számát egy adott év adott hónapjában. Figyelembe veszi, hogy az év szökőév-e vagy sem.\n\n- Paraméterek:\n- year: Az év, amelyre a napok számát ki kell számítani.\n- month: A hónap, amelyre a napok számát ki kell számítani.\n\n- Visszatérési érték: A napok száma az adott év adott hónapjában.\n\nPéldák:\ndaysInMonth(1926, 8) // Visszaadja: 31\ndaysInMonth(2000, 2) // Visszaadja: 29"
    },
    "docstring_bertscore": {
      "sq": "0.9663899518554676",
      "hy": "0.9722304795794174",
      "bn": "0.5602142610240833",
      "bg": "1",
      "zh": "0.9562498709036366",
      "fr": "0.9970616607733509",
      "de": "0.9524361675877667",
      "ha": "0.9958077071778777",
      "hi": "0.9636728868732913",
      "hu": "0.9570424061239657"
    }
  },
  {
    "task_id": "Swift/31",
    "prompt": {
      "en": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "sq": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nGjen numrin minimal të rrotullimeve 180-gradëshe të nevojshme për të riorganizuar vagonët e trenit në rend rritës.\n\nFunksioni merr një varg të numrave të plotë që përfaqëson rendin fillestar të vagonëve të trenit dhe kthen numrin minimal të rrotullimeve të kërkuara për t'i renditur ato në rend rritës.\n\nShembuj rastesh:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "hy": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nԳտնում է նվազագույն 180 աստիճան պտույտների քանակը, որը պահանջվում է գնացքի վագոնները աճման կարգով դասավորելու համար։\n\nՖունկցիան ընդունում է ամբողջ թվերի զանգված, որը ներկայացնում է գնացքի վագոնների սկզբնական կարգը, և վերադարձնում է նվազագույն պտույտների քանակը, որը պահանջվում է դրանք աճման կարգով դասավորելու համար։\n\nՕրինակներ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "bn": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nএকটি ট্রেনের গাড়িগুলোকে ঊর্ধ্বক্রমে সাজানোর জন্য প্রয়োজনীয় ১৮০-ডিগ্রি ঘূর্ণনের সর্বনিম্ন সংখ্যা খুঁজে বের করে।\n\nএই ফাংশনটি ট্রেনের গাড়িগুলোর প্রাথমিক ক্রমকে উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে নেয় এবং তাদের ঊর্ধ্বক্রমে সাজানোর জন্য প্রয়োজনীয় সর্বনিম্ন ঘূর্ণনের সংখ্যা প্রদান করে।\n\nউদাহরণ কেসসমূহ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "bg": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nНамира минималния брой 180-градусови завъртания, необходими за пренареждане на вагоните на влака в нарастващ ред.\n\nФункцията приема масив от цели числа, представляващи началния ред на вагоните на влака, и връща минималния брой завъртания, необходими за подреждането им в нарастващ ред.\n\nПримерни случаи:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "zh": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\n找到将火车车厢重新排列为升序所需的最小180度旋转次数。\n\n该函数接受一个整数数组，表示火车车厢的初始顺序，并返回将它们按升序排列所需的最小旋转次数。\n\n示例案例：\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "fr": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nTrouve le nombre minimum de rotations de 180 degrés nécessaires pour réorganiser les wagons d'un train dans l'ordre croissant.\n\nLa fonction prend un tableau d'entiers représentant l'ordre initial des wagons de train et renvoie le nombre minimum de rotations nécessaires pour les ordonner dans l'ordre croissant.\n\nExemples de cas :\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "de": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFindet die minimale Anzahl von 180-Grad-Drehungen, die erforderlich sind, um die Waggons eines Zuges in aufsteigender Reihenfolge anzuordnen.\n\nDie Funktion nimmt ein Array von ganzen Zahlen, das die anfängliche Reihenfolge der Waggons darstellt, und gibt die minimale Anzahl von Drehungen zurück, die erforderlich sind, um sie in aufsteigender Reihenfolge anzuordnen.\n\nBeispielhafte Fälle:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "ha": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nNemo adadin juyawa 180-digiri mafi ƙaranci da ake buƙata don sake tsara motocin jirgin ƙasa cikin tsari mai ƙaruwa.\n\nAikin yana ɗaukar jerin lambobi na lambobi waɗanda ke wakiltar tsari na farko na motocin jirgin ƙasa, kuma yana dawowa da adadin juyawa mafi ƙaranci da ake buƙata don tsara su cikin tsari mai ƙaruwa.\n\nMisalan lamura:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "hi": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nएक ट्रेन की गाड़ियों को आरोही क्रम में पुनर्व्यवस्थित करने के लिए आवश्यक न्यूनतम 180-डिग्री घुमावों की संख्या खोजें।\n\nयह फ़ंक्शन ट्रेन की गाड़ियों के प्रारंभिक क्रम का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी लेता है, और उन्हें आरोही क्रम में क्रमबद्ध करने के लिए आवश्यक न्यूनतम घुमावों की संख्या लौटाता है।\n\nउदाहरण मामले:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "hu": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nMegtalálja a minimális számú 180 fokos forgatást, amely szükséges ahhoz, hogy a vonatkocsikat növekvő sorrendbe rendezzük.\n\nA függvény egy egész számokból álló tömböt vesz át, amely a vonatkocsik kezdeti sorrendjét képviseli, és visszaadja a minimális forgatások számát, amely szükséges ahhoz, hogy azokat növekvő sorrendbe rendezzük.\n\nPélda esetek:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9639809625942765",
      "hy": "0.9714544306807141",
      "bn": "0.9738316390809397",
      "bg": "0.9862865584933513",
      "zh": "0.9772200747510138",
      "fr": "0.9882565746124553",
      "de": "0.9759583745706802",
      "ha": "0.9396149737527267",
      "hi": "0.9572702351710127",
      "hu": "0.9783238637784247"
    },
    "canonical_solution": "var cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}",
    "instruction": {
      "en": "Write a Swift function `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` to solve the following problem:\n\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n",
      "sq": "Shkruani një funksion Swift `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nGjen numrin minimal të rrotullimeve 180-gradëshe të nevojshme për të riorganizuar vagonët e trenit në rend rritës.\n\nFunksioni merr një varg të numrave të plotë që përfaqësojnë rendin fillestar të vagonëve të trenit dhe kthen numrin minimal të rrotullimeve të kërkuara për t'i renditur ato në rend rritës.\n\nShembuj rastesh:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hy": "Գրեք Swift ֆունկցիա `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nԳտնում է նվազագույն 180 աստիճան պտույտների քանակը, որը անհրաժեշտ է գնացքի վագոնները աճման կարգով դասավորելու համար:\n\nՖունկցիան ընդունում է ամբողջ թվերի զանգված, որը ներկայացնում է գնացքի վագոնների նախնական կարգը և վերադարձնում է նվազագույն պտույտների քանակը, որը պահանջվում է դրանք աճման կարգով դասավորելու համար:\n\nՕրինակներ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "bn": "একটি Swift ফাংশন `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি ট্রেনের গাড়িগুলিকে ঊর্ধ্বক্রমে সাজানোর জন্য প্রয়োজনীয় সর্বনিম্ন ১৮০-ডিগ্রি ঘূর্ণনের সংখ্যা খুঁজে বের করে।\n\nফাংশনটি একটি পূর্ণসংখ্যার অ্যারে নেয় যা ট্রেনের গাড়িগুলির প্রাথমিক ক্রমকে উপস্থাপন করে এবং সেগুলিকে ঊর্ধ্বক্রমে সাজাতে প্রয়োজনীয় সর্বনিম্ন ঘূর্ণনের সংখ্যা ফেরত দেয়।\n\nউদাহরণ কেস:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "bg": "Напишете Swift функция `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` за решаване на следния проблем:\n\nНамира минималния брой завъртания на 180 градуса, необходими за пренареждане на вагоните на влак в нарастващ ред.\n\nФункцията приема масив от цели числа, представляващи началния ред на вагоните на влака, и връща минималния брой завъртания, необходими за подреждането им в нарастващ ред.\n\nПримерни случаи:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "zh": "编写一个 Swift 函数 `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` 来解决以下问题：\n\n找到将火车车厢重新排列为升序所需的最小180度旋转次数。\n\n该函数接受一个整数数组，表示火车车厢的初始顺序，并返回将它们按升序排列所需的最小旋转次数。\n\n示例案例：\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "fr": "Écrire une fonction Swift `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` pour résoudre le problème suivant :\n\nTrouve le nombre minimum de rotations de 180 degrés nécessaires pour réorganiser les wagons d'un train dans l'ordre croissant.\n\nLa fonction prend un tableau d'entiers représentant l'ordre initial des wagons de train et renvoie le nombre minimum de rotations nécessaires pour les ordonner dans l'ordre croissant.\n\nExemples de cas :\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "de": "Schreiben Sie eine Swift-Funktion `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {`, um das folgende Problem zu lösen:\n\nFindet die minimale Anzahl von 180-Grad-Drehungen, die erforderlich sind, um die Waggons eines Zuges in aufsteigender Reihenfolge neu anzuordnen.\n\nDie Funktion nimmt ein Array von ganzen Zahlen, das die anfängliche Reihenfolge der Waggons darstellt, und gibt die minimale Anzahl von Drehungen zurück, die erforderlich sind, um sie in aufsteigender Reihenfolge zu ordnen.\n\nBeispielhafte Fälle:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "ha": "Rubuta aikin Swift `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` don warware matsalar mai zuwa:\n\nNemo mafi ƙarancin adadin juyawa na digiri 180 da ake buƙata don sake tsara motocin jirgin a cikin tsari mai hawa.\n\nAikin yana ɗaukar jerin lambobi masu nuni da tsari na farko na motocin jirgin, kuma yana mayar da mafi ƙarancin adadin juyawa da ake buƙata don tsara su a cikin tsari mai hawa.\n\nMisalan lokuta:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hi": "Swift फ़ंक्शन `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nएक ट्रेन के डिब्बों को आरोही क्रम में पुनर्व्यवस्थित करने के लिए आवश्यक न्यूनतम 180-डिग्री घुमावों की संख्या खोजें।\n\nयह फ़ंक्शन ट्रेन के डिब्बों के प्रारंभिक क्रम का प्रतिनिधित्व करने वाले पूर्णांकों की एक array लेता है, और उन्हें आरोही क्रम में क्रमबद्ध करने के लिए आवश्यक न्यूनतम घुमावों की संख्या लौटाता है।\n\nउदाहरण मामले:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hu": "Írj egy Swift függvényt `func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {` a következő probléma megoldására:\n\nMegtalálja a minimális számú 180 fokos forgatást, amely szükséges ahhoz, hogy egy vonat kocsijait növekvő sorrendbe rendezzük.\n\nA függvény egy egész számokat tartalmazó tömböt vesz át, amely a vonatkocsik kezdeti sorrendjét képviseli, és visszaadja a növekvő sorrendbe állításhoz szükséges minimális forgatások számát.\n\nPélda esetek:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10"
    },
    "instruction_bertscore": {
      "sq": "0.9825237045550264",
      "hy": "0.9756085864696779",
      "bn": "0.9751203529930941",
      "bg": "0.9843362067819698",
      "zh": "0.9781339731341554",
      "fr": "0.9849326938162175",
      "de": "0.9780451853538328",
      "ha": "0.953194737012939",
      "hi": "0.9680725498132141",
      "hu": "0.9816723747419108"
    },
    "level": "middle",
    "test": "func check(_ minimumSwapsToOrder: ([Int]) -> Int) {\nassert(minimumSwapsToOrder([2, 3, 1]) == 2)\nassert(minimumSwapsToOrder([1, 4, 3, 2]) == 3)\nassert(minimumSwapsToOrder([5, 4, 3, 2, 1]) == 10)\nassert(minimumSwapsToOrder([1, 2, 3, 4, 5]) == 0)\nassert(minimumSwapsToOrder([3, 1, 2]) == 2)\nassert(minimumSwapsToOrder([4, 5, 1, 3, 2]) == 7)\nassert(minimumSwapsToOrder([1]) == 0)\n}\n\ncheck(minimumSwapsToOrder)",
    "entry_point": "minimumSwapsToOrder",
    "signature": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n",
      "sq": "Gjen numrin minimal të rotacioneve prej 180 gradësh të nevojshme për të riorganizuar vagonët e trenit në rend rritës.\n\nFunksioni merr një varg të numrave të plotë që përfaqësojnë rendin fillestar të vagonëve të trenit dhe kthen numrin minimal të rotacioneve të nevojshme për t'i renditur ato në rend rritës.\n\nRaste shembull:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hy": "Գտնում է 180 աստիճան պտույտների նվազագույն քանակը, որը անհրաժեշտ է գնացքի վագոնները վերադասավորելու աճման կարգով:\n\nՖունկցիան ընդունում է ամբողջ թվերի զանգված, որը ներկայացնում է գնացքի վագոնների նախնական կարգը, և վերադարձնում է պտույտների նվազագույն քանակը, որը անհրաժեշտ է դրանք աճման կարգով դասավորելու համար:\n\nՕրինակներ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "bn": "ট্রেনের গাড়িগুলিকে ঊর্ধ্বক্রমে পুনর্বিন্যাস করতে প্রয়োজনীয় ১৮০-ডিগ্রি ঘূর্ণনের সর্বনিম্ন সংখ্যা খুঁজে বের করে।\n\nফাংশনটি ট্রেনের গাড়ির প্রাথমিক ক্রমকে উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে নেয় এবং সেগুলিকে ঊর্ধ্বক্রমে সাজাতে প্রয়োজনীয় ঘূর্ণনের সর্বনিম্ন সংখ্যা প্রদান করে।\n\nউদাহরণ কেস:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "bg": "Намира минималния брой завъртания на 180 градуса, необходими за пренареждане на вагоните на влака в нарастващ ред.\n\nФункцията приема масив от цели числа, представляващи началния ред на вагоните на влака, и връща минималния брой завъртания, необходими за подреждането им в нарастващ ред.\n\nПримерни случаи:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "zh": "找到将火车车厢重新排列为升序所需的最小180度旋转次数。\n\n该函数接受一个整数数组，表示火车车厢的初始顺序，并返回将它们按升序排列所需的最小旋转次数。\n\n示例案例：\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "fr": "Trouve le nombre minimum de rotations de 180 degrés nécessaires pour réorganiser les wagons d'un train dans l'ordre croissant.\n\nLa fonction prend un tableau d'entiers représentant l'ordre initial des wagons de train et renvoie le nombre minimum de rotations nécessaires pour les ordonner dans l'ordre croissant.\n\nExemples de cas :\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "de": "Findet die minimale Anzahl von 180-Grad-Drehungen, die benötigt werden, um die Waggons eines Zuges in aufsteigender Reihenfolge anzuordnen.\n\nDie Funktion nimmt ein Array von ganzen Zahlen, das die anfängliche Reihenfolge der Zugwaggons darstellt, und gibt die minimale Anzahl von Drehungen zurück, die erforderlich sind, um sie in aufsteigender Reihenfolge zu ordnen.\n\nBeispielhafte Fälle:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "ha": "Yana nemo mafi ƙarancin adadin juyawar digiri 180 da ake buƙata don sake tsara motocin jirgin zuwa tsari mai hawa.\n\nAikin yana ɗaukar jerin lambobi masu nuna tsarin farko na motocin jirgin, kuma yana mayar da mafi ƙarancin adadin juyawa da ake buƙata don tsara su cikin tsari mai hawa.\n\nMisalan lokuta:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hi": "ट्रेन की गाड़ियों को आरोही क्रम में पुनर्व्यवस्थित करने के लिए आवश्यक न्यूनतम 180-डिग्री घुमावों की संख्या खोजता है।\n\nयह फ़ंक्शन ट्रेन की गाड़ियों के प्रारंभिक क्रम को दर्शाने वाले पूर्णांकों की एक सरणी लेता है, और उन्हें आरोही क्रम में क्रमबद्ध करने के लिए आवश्यक न्यूनतम घुमावों की संख्या लौटाता है।\n\nउदाहरण मामले:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "hu": "Megtalálja a minimális számú 180 fokos forgatást, amely szükséges ahhoz, hogy egy vonat kocsijait növekvő sorrendbe rendezzük.\n\nA függvény egy egész számokat tartalmazó tömböt vesz át, amely a vonatkocsik kezdeti sorrendjét jelképezi, és visszaadja a szükséges forgatások minimális számát, hogy azokat növekvő sorrendbe rendezzük.\n\nPélda esetek:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10"
    },
    "docstring_bertscore": {
      "sq": "0.9712945332239811",
      "hy": "0.9660572459672342",
      "bn": "0.9733531384930266",
      "bg": "0.9835112948095318",
      "zh": "0.9721534109915759",
      "fr": "0.9733531384930266",
      "de": "0.9839232542197982",
      "ha": "0.9603662869202035",
      "hi": "0.9782976445681281",
      "hu": "0.9568167620111101"
    }
  },
  {
    "task_id": "Swift/32",
    "prompt": {
      "en": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "sq": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nPërcakton nëse fjala e dhënë është një \"Fjalë me Fat.\" Një fjalë konsiderohet me fat nëse diferenca\nmidis frekuencave maksimale dhe minimale të karaktereve në fjalë është një numër i thjeshtë.\n\n- Parametrat:\n- word: Një varg që përfaqëson fjalën që do të kontrollohet. Supozohet vetëm shkronja të vogla dhe një gjatësi më pak se 100.\n\n- Kthen: Një tuple që përmban një boolean që tregon nëse fjala është me fat, dhe një numër të plotë që është diferenca\nmidis frekuencave maksimale dhe minimale nëse fjala është me fat, ose 0 përndryshe.\n\nShembuj:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "hy": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nՍահմանում է՝ արդյոք տրված բառը \"Հաջողակ բառ\" է։ Բառը համարվում է հաջողակ, եթե բառի մեջ\nառավելագույն և նվազագույն սիմվոլների հաճախականությունների տարբերությունը պարզ թիվ է։\n\n- Պարամետրեր:\n- word: Տող, որը ներկայացնում է ստուգվող բառը։ Ենթադրվում է, որ պարունակում է միայն փոքրատառեր և երկարությունը փոքր է 100-ից։\n\n- Վերադարձնում է: Կրկնակի, որը պարունակում է բուլյան արժեք, որը ցույց է տալիս՝ արդյոք բառը հաջողակ է, և ամբողջ թիվ, որը\nառավելագույն և նվազագույն հաճախականությունների տարբերությունն է, եթե բառը հաջողակ է, կամ 0՝ հակառակ դեպքում։\n\nՕրինակներ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "bn": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nপ্রদত্ত শব্দটি একটি \"লাকি ওয়ার্ড\" কিনা তা নির্ধারণ করে। একটি শব্দকে লাকি বলা হয় যদি শব্দের মধ্যে সর্বাধিক এবং সর্বনিম্ন অক্ষরের ফ্রিকোয়েন্সির মধ্যে পার্থক্য একটি মৌলিক সংখ্যা হয়।\n\n- প্যারামিটার:\n- word: একটি স্ট্রিং যা যাচাই করার জন্য শব্দটি উপস্থাপন করে। শুধুমাত্র ছোট হাতের অক্ষর এবং দৈর্ঘ্য 100 এর কম ধরে নেয়।\n\n- রিটার্ন: একটি টিউপল যা একটি বুলিয়ান ধারণ করে যা নির্দেশ করে যে শব্দটি লাকি কিনা, এবং একটি পূর্ণসংখ্যা যা সর্বাধিক এবং সর্বনিম্ন ফ্রিকোয়েন্সির মধ্যে পার্থক্য যদি শব্দটি লাকি হয়, অথবা অন্যথায় 0।\n\nউদাহরণ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "bg": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nОпределя дали дадената дума е \"Късметлийска дума\". Една дума се счита за късметлийска, ако разликата\nмежду максималната и минималната честота на символите в думата е просто число.\n\n- Параметри:\n- word: Низ, представляващ думата, която ще бъде проверена. Предполага се, че съдържа само малки букви и дължина по-малка от 100.\n\n- Връща: Кортеж, съдържащ булева стойност, указваща дали думата е късметлийска, и цяло число, което е разликата\nмежду максималната и минималната честота, ако думата е късметлийска, или 0 в противен случай.\n\nПримери:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "zh": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\n确定给定的单词是否为“幸运单词”。如果单词中字符频率的最大值和最小值之间的差是一个质数，则该单词被认为是幸运的。\n\n- 参数:\n- word: 一个字符串，表示要检查的单词。假设只有小写字母且长度小于100。\n\n- 返回: 一个包含布尔值的元组，指示单词是否幸运，以及如果单词幸运则为最大和最小频率之间的差的整数，否则为0。\n\n示例:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "fr": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDétermine si le mot donné est un \"mot chanceux\". Un mot est considéré comme chanceux si la différence\nentre les fréquences des caractères maximum et minimum dans le mot est un nombre premier.\n\n- Paramètres:\n- word: Une chaîne de caractères représentant le mot à vérifier. Suppose uniquement des lettres minuscules et une longueur inférieure à 100.\n\n- Renvoie: Un tuple contenant un booléen indiquant si le mot est chanceux, et un entier qui est la différence\nentre les fréquences max et min si le mot est chanceux, ou 0 sinon.\n\nExemples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "de": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nBestimmt, ob das gegebene Wort ein \"Glückswort\" ist. Ein Wort wird als glücklich angesehen, wenn die Differenz\nzwischen der maximalen und minimalen Zeichenhäufigkeit im Wort eine Primzahl ist.\n\n- Parameter:\n- word: Ein String, der das zu überprüfende Wort darstellt. Geht davon aus, dass nur Kleinbuchstaben verwendet werden und die Länge weniger als 100 beträgt.\n\n- Rückgabewert: Ein Tupel, das einen Booleschen Wert enthält, der angibt, ob das Wort glücklich ist, und eine Ganzzahl, die die Differenz\nzwischen den maximalen und minimalen Häufigkeiten ist, wenn das Wort glücklich ist, oder 0 andernfalls.\n\nBeispiele:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "ha": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nYana tantance idan kalmar da aka bayar tana da \"Kalmar Sa'a.\" Ana ɗaukar kalma tana da sa'a idan bambanci\ntsakanin mafi girma da mafi ƙarancin yawan haruffa a cikin kalmar lamba ce mai firam.\n\n- Sigogi:\n- word: Wani kirtani da ke wakiltar kalmar da za a bincika. Ana ɗauka kawai haruffa ƙanana da tsawo kasa da 100.\n\n- Yana dawowa: Wani tuple da ke dauke da boolean da ke nuna idan kalmar tana da sa'a, da kuma integer wanda shine bambanci\ntsakanin mafi girma da mafi ƙarancin yawan idan kalmar tana da sa'a, ko 0 idan ba haka ba.\n\nMisalai:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "hi": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nयह निर्धारित करता है कि दिया गया शब्द \"Lucky Word\" है या नहीं। एक शब्द को भाग्यशाली माना जाता है यदि शब्द में अधिकतम और न्यूनतम वर्ण आवृत्तियों के बीच का अंतर एक अभाज्य संख्या है।\n\n- पैरामीटर्स:\n- word: एक स्ट्रिंग जो जाँच किए जाने वाले शब्द का प्रतिनिधित्व करती है। केवल छोटे अक्षरों और 100 से कम लंबाई को मानता है।\n\n- रिटर्न्स: एक ट्यूपल जिसमें एक बूलियन शामिल है जो यह इंगित करता है कि शब्द भाग्यशाली है या नहीं, और एक पूर्णांक जो अधिकतम और न्यूनतम आवृत्तियों के बीच का अंतर है यदि शब्द भाग्यशाली है, या अन्यथा 0 है।\n\nउदाहरण:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "hu": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nMeghatározza, hogy a megadott szó \"Szerencsés Szó\"-e. Egy szó akkor tekinthető szerencsésnek, ha a szóban\na maximális és minimális karaktergyakoriságok közötti különbség prímszám.\n\n- Paraméterek:\n- word: Egy string, amely a vizsgálandó szót képviseli. Feltételezzük, hogy csak kisbetűket tartalmaz, és hossza kevesebb mint 100.\n\n- Visszatér: Egy tuple, amely egy logikai értéket tartalmaz, jelezve, hogy a szó szerencsés-e, és egy egész számot, amely a\nmaximális és minimális gyakoriság közötti különbség, ha a szó szerencsés, vagy 0 egyébként.\n\nPéldák:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9890707605443173",
      "hy": "0.970804313443587",
      "bn": "0.9749076198550056",
      "bg": "0.9706914913871592",
      "zh": "0.9715424239395126",
      "fr": "0.9931937313634586",
      "de": "0.9642663944518236",
      "ha": "0.9641770107803579",
      "hi": "0.9716248555476421",
      "hu": "0.9695094419896205"
    },
    "canonical_solution": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}",
    "instruction": {
      "en": "Write a Swift function `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` to solve the following problem:\n\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n",
      "sq": "Shkruani një funksion Swift `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` për të zgjidhur problemin e mëposhtëm:\n\nPërcakton nëse fjala e dhënë është një \"Fjalë me Fat.\" Një fjalë konsiderohet me fat nëse diferenca\nmidis frekuencave maksimale dhe minimale të karaktereve në fjalë është një numër i thjeshtë.\n\n- Parametrat:\n- word: Një varg që përfaqëson fjalën që do të kontrollohet. Supozohet vetëm shkronja të vogla dhe një gjatësi më pak se 100.\n\n- Kthen: Një tuple që përmban një boolean që tregon nëse fjala është me fat, dhe një numër i plotë që është diferenca\nmidis frekuencave maksimale dhe minimale nëse fjala është me fat, ose 0 përndryshe.\n\nShembuj:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hy": "Գրեք Swift ֆունկցիա `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` հետևյալ խնդիրը լուծելու համար:\n\nՍահմանում է, արդյոք տրված բառը \"Lucky Word\" է։ Բառը համարվում է հաջողակ, եթե բառի մեջ առավելագույն և նվազագույն սիմվոլների հաճախականությունների տարբերությունը պարզ թիվ է։\n\n- Պարամետրեր:\n- word: Տող, որը ներկայացնում է ստուգվող բառը։ Ենթադրվում է, որ պարունակում է միայն փոքրատառեր և ունի 100-ից պակաս երկարություն։\n\n- Վերադարձնում է: Զույգ, որը պարունակում է բուլյան արժեք, որը ցույց է տալիս՝ արդյոք բառը հաջողակ է, և ամբողջ թիվ, որը առավելագույն և նվազագույն հաճախականությունների տարբերությունն է, եթե բառը հաջողակ է, կամ 0՝ հակառակ դեպքում։\n\nՕրինակներ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "bn": "একটি Swift ফাংশন লিখুন `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nপ্রদত্ত শব্দটি \"লাকি ওয়ার্ড\" কিনা তা নির্ধারণ করে। একটি শব্দকে লাকি মনে করা হয় যদি শব্দের মধ্যে সর্বাধিক এবং সর্বনিম্ন অক্ষরের ফ্রিকোয়েন্সির মধ্যে পার্থক্য একটি মৌলিক সংখ্যা হয়।\n\n- প্যারামিটারসমূহ:\n- word: একটি স্ট্রিং যা চেক করার জন্য শব্দটি উপস্থাপন করে। শুধুমাত্র ছোট হাতের অক্ষর এবং দৈর্ঘ্য ১০০ এর কম ধরে নেওয়া হয়।\n\n- রিটার্নস: একটি টিউপল যা একটি বুলিয়ান নির্দেশ করে যে শব্দটি লাকি কিনা, এবং একটি পূর্ণসংখ্যা যা সর্বাধিক এবং সর্বনিম্ন ফ্রিকোয়েন্সির মধ্যে পার্থক্য যদি শব্দটি লাকি হয়, অথবা অন্যথায় 0।\n\nউদাহরণসমূহ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "bg": "Напишете Swift функция `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` за решаване на следния проблем:\n\nОпределя дали дадена дума е \"Щастлива дума\". Една дума се счита за щастлива, ако разликата\nмежду максималната и минималната честота на символите в думата е просто число.\n\n- Параметри:\n- word: Низ, представляващ думата, която ще се провери. Предполага се, че съдържа само малки букви и дължина по-малка от 100.\n\n- Връща: Кортеж, съдържащ булева стойност, указваща дали думата е щастлива, и цяло число, което е разликата\nмежду максималната и минималната честота, ако думата е щастлива, или 0 в противен случай.\n\nПримери:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "zh": "编写一个 Swift 函数 `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` 来解决以下问题：\n\n确定给定的单词是否为“幸运单词”。如果单词中字符出现频率的最大值和最小值之间的差是一个质数，则该单词被认为是幸运的。\n\n- 参数：\n- word: 一个字符串，表示要检查的单词。假设只有小写字母且长度小于 100。\n\n- 返回：一个包含布尔值的元组，指示单词是否幸运，以及一个整数，表示如果单词是幸运的，则为最大和最小频率之间的差，否则为 0。\n\n示例：\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "fr": "Écrire une fonction Swift `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` pour résoudre le problème suivant :\n\nDétermine si le mot donné est un \"mot chanceux\". Un mot est considéré comme chanceux si la différence\nentre les fréquences maximales et minimales des caractères dans le mot est un nombre premier.\n\n- Paramètres :\n- word : Une chaîne représentant le mot à vérifier. Suppose uniquement des lettres minuscules et une longueur inférieure à 100.\n\n- Renvoie : Un tuple contenant un booléen indiquant si le mot est chanceux, et un entier qui est la différence\nentre les fréquences max et min si le mot est chanceux, ou 0 sinon.\n\nExemples :\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "de": "Schreiben Sie eine Swift-Funktion `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {`, um das folgende Problem zu lösen:\n\nBestimmt, ob das gegebene Wort ein \"Glückswort\" ist. Ein Wort wird als glücklich betrachtet, wenn die Differenz zwischen den maximalen und minimalen Zeichenfrequenzen im Wort eine Primzahl ist.\n\n- Parameter:\n- word: Ein String, der das zu überprüfende Wort darstellt. Es wird angenommen, dass nur Kleinbuchstaben und eine Länge von weniger als 100 vorhanden sind.\n\n- Rückgabe: Ein Tupel, das einen Booleschen Wert enthält, der angibt, ob das Wort glücklich ist, und eine ganze Zahl, die die Differenz zwischen den maximalen und minimalen Frequenzen ist, wenn das Wort glücklich ist, oder 0 andernfalls.\n\nBeispiele:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "ha": "Rubuta aikin Swift `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` don warware matsalar mai zuwa:\n\nYana tantance idan kalmar da aka bayar kalma ce \"Lucky Word.\" Ana ɗaukar kalma a matsayin mai sa'a idan bambancin\ntsakanin mafi girma da mafi ƙarancin yawan maimaitawar haruffa a cikin kalmar lamba ce mai lamba.\n\n- Sigogi:\n- word: Wani kirtani da ke wakiltar kalmar da za a bincika. Ana ɗauka kawai haruffa ƙanana da tsawon kasa da 100.\n\n- Komawa: Wani tuple da ke ɗauke da boolean da ke nuna idan kalmar mai sa'a ce, da kuma wani cikakken lamba wanda shine bambanci\ntsakanin mafi girma da mafi ƙarancin maimaitawa idan kalmar mai sa'a ce, ko 0 idan ba haka ba.\n\nMisalai:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hi": "स्विफ्ट फ़ंक्शन `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nयह निर्धारित करता है कि दिया गया शब्द \"Lucky Word\" है या नहीं। एक शब्द को भाग्यशाली माना जाता है यदि शब्द में अधिकतम और न्यूनतम वर्ण आवृत्तियों के बीच का अंतर एक अभाज्य संख्या है।\n\n- पैरामीटर्स:\n- word: एक स्ट्रिंग जो जाँच किए जाने वाले शब्द का प्रतिनिधित्व करती है। केवल छोटे अक्षरों और 100 से कम लंबाई को मानता है।\n\n- रिटर्न्स: एक ट्यूपल जिसमें एक बूलियन होता है जो यह दर्शाता है कि शब्द भाग्यशाली है या नहीं, और एक पूर्णांक जो अधिकतम और न्यूनतम आवृत्तियों के बीच का अंतर है यदि शब्द भाग्यशाली है, अन्यथा 0।\n\nउदाहरण:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hu": "Írj egy Swift függvényt `func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {` a következő probléma megoldására:\n\nMeghatározza, hogy a megadott szó \"Szerencsés Szó\"-e. Egy szót akkor tekintünk szerencsésnek, ha a szóban a maximális és minimális karaktergyakoriság közötti különbség prímszám.\n\n- Paraméterek:\n- word: Egy string, amely a vizsgálandó szót képviseli. Feltételezi, hogy csak kisbetűket tartalmaz és hossza kevesebb mint 100.\n\n- Visszatérési érték: Egy tuple, amely tartalmaz egy logikai értéket, amely jelzi, hogy a szó szerencsés-e, és egy egész számot, amely a maximális és minimális gyakoriság közötti különbség, ha a szó szerencsés, vagy 0-t egyébként.\n\nPéldák:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)"
    },
    "instruction_bertscore": {
      "sq": "0.9859004210326195",
      "hy": "0.9735907004287444",
      "bn": "0.9764003271684829",
      "bg": "0.9676037821139718",
      "zh": "0.966107698084017",
      "fr": "0.9849726185228055",
      "de": "0.964450524815043",
      "ha": "0.9591975457581943",
      "hi": "0.9531955315344631",
      "hu": "0.9694562090475032"
    },
    "level": "hard",
    "test": "func testIsLuckyWord() {\nassert(isLuckyWord(\"hello\") == (false, 0))\nassert(isLuckyWord(\"swift\") == (false, 0))\nassert(isLuckyWord(\"programming\") == (false, 0))\nassert(isLuckyWord(\"apple\") == (false, 0))\nassert(isLuckyWord(\"banana\") == (true, 2))\nassert(isLuckyWord(\"challenge\") == (false, 0))\nassert(isLuckyWord(\"developer\") == (true, 2))\n}\n\ntestIsLuckyWord()",
    "entry_point": "isLuckyWord",
    "signature": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {",
    "docstring": {
      "en": "\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n",
      "sq": "Përcakton nëse fjala e dhënë është një \"Fjalë me Fat.\" Një fjalë konsiderohet me fat nëse diferenca\nmidis frekuencave maksimale dhe minimale të karaktereve në fjalë është një numër i thjeshtë.\n\n- Parametrat:\n- word: Një varg që përfaqëson fjalën që do të kontrollohet. Supozohet vetëm shkronja të vogla dhe një gjatësi më pak se 100.\n\n- Kthen: Një dyshe që përmban një vlerë boolean që tregon nëse fjala është me fat, dhe një numër i plotë që është diferenca\nmidis frekuencave maksimale dhe minimale nëse fjala është me fat, ose 0 përndryshe.\n\nShembuj:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hy": "Սահմանում է՝ արդյոք տրված բառը \"Բախտավոր Բառ\" է։ Բառը համարվում է բախտավոր, եթե բառի մեջ առավելագույն և նվազագույն սիմվոլների հաճախականությունների տարբերությունը պարզ թիվ է։\n\n- Պարամետրեր:\n- word: Տող, որը ներկայացնում է ստուգվող բառը։ Ենթադրվում է, որ պարունակում է միայն փոքրատառեր և ունի 100-ից պակաս երկարություն։\n\n- Վերադարձնում է: Կորտեժ, որը պարունակում է բուլյան արժեք, որը ցույց է տալիս՝ արդյոք բառը բախտավոր է, և ամբողջ թիվ, որը առավելագույն և նվազագույն հաճախականությունների տարբերությունն է, եթե բառը բախտավոր է, կամ 0՝ հակառակ դեպքում։\n\nՕրինակներ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "bn": "প্রদত্ত শব্দটি \"লাকি ওয়ার্ড\" কিনা তা নির্ধারণ করে। একটি শব্দকে লাকি মনে করা হয় যদি শব্দের মধ্যে সর্বাধিক এবং সর্বনিম্ন অক্ষরের ফ্রিকোয়েন্সির মধ্যে পার্থক্য একটি মৌলিক সংখ্যা হয়।\n\n- প্যারামিটারসমূহ:\n- word: একটি স্ট্রিং যা যাচাই করার জন্য শব্দটি উপস্থাপন করে। শুধুমাত্র ছোট হাতের অক্ষর এবং দৈর্ঘ্য ১০০ এর কম ধরে নেয়া হয়।\n\n- রিটার্নস: একটি টিউপল যা একটি বুলিয়ান ধারণ করে যা নির্দেশ করে শব্দটি লাকি কিনা, এবং একটি পূর্ণসংখ্যা যা সর্বাধিক এবং সর্বনিম্ন ফ্রিকোয়েন্সির মধ্যে পার্থক্য যদি শব্দটি লাকি হয়, অথবা অন্যথায় 0।\n\nউদাহরণসমূহ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "bg": "Определя дали дадената дума е \"Щастлива дума.\" Една дума се счита за щастлива, ако разликата между максималната и минималната честота на символите в думата е просто число.\n\n- Параметри:\n- word: Низ, представляващ думата, която трябва да бъде проверена. Приема се, че съдържа само малки букви и дължина по-малка от 100.\n\n- Връща: Кортеж, съдържащ булева стойност, указваща дали думата е щастлива, и цяло число, което е разликата между максималната и минималната честота, ако думата е щастлива, или 0 в противен случай.\n\nПримери:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "zh": "确定给定的单词是否为“幸运单词”。如果单词中字符频率的最大值与最小值之间的差是一个质数，则该单词被认为是幸运的。\n\n- 参数:\n- word: 一个字符串，表示要检查的单词。假设只有小写字母且长度小于100。\n\n- 返回: 一个包含布尔值和整数的元组，布尔值表示单词是否幸运，整数表示如果单词是幸运的，则为最大和最小频率之间的差，否则为0。\n\n示例:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "fr": "Détermine si le mot donné est un \"mot chanceux\". Un mot est considéré comme chanceux si la différence entre les fréquences maximales et minimales des caractères dans le mot est un nombre premier.\n\n- Paramètres :\n- word : Une chaîne de caractères représentant le mot à vérifier. Suppose uniquement des lettres minuscules et une longueur inférieure à 100.\n\n- Renvoie : Un tuple contenant un booléen indiquant si le mot est chanceux, et un entier qui est la différence entre les fréquences max et min si le mot est chanceux, ou 0 sinon.\n\nExemples :\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "de": "Bestimmt, ob das gegebene Wort ein \"Glückswort\" ist. Ein Wort wird als glücklich angesehen, wenn die Differenz zwischen den maximalen und minimalen Zeichenfrequenzen im Wort eine Primzahl ist.\n\n- Parameter:\n- word: Ein String, der das zu überprüfende Wort darstellt. Geht davon aus, dass nur Kleinbuchstaben und eine Länge von weniger als 100 verwendet werden.\n\n- Rückgabewert: Ein Tupel, das einen booleschen Wert enthält, der angibt, ob das Wort glücklich ist, und eine ganze Zahl, die die Differenz zwischen den maximalen und minimalen Frequenzen darstellt, wenn das Wort glücklich ist, oder 0 andernfalls.\n\nBeispiele:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "ha": "Determines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Sigogi:\n- word: Wani kirtani da ke wakiltar kalmar da za a duba. Yana ɗauka kawai ƙananan haruffa da tsawo ƙasa da 100.\n\n- Komawa: Wani tuple da ke ɗauke da boolean da ke nuna idan kalmar tana da sa'a, da kuma cikakken lamba wanda shine bambanci\ntsakanin mafi girma da mafi ƙarancin mitoci idan kalmar tana da sa'a, ko 0 in ba haka ba.\n\nMisalai:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hi": "यह निर्धारित करता है कि दिया गया शब्द \"लकी वर्ड\" है या नहीं। एक शब्द को लकी माना जाता है यदि शब्द में अधिकतम और न्यूनतम वर्ण आवृत्तियों के बीच का अंतर एक अभाज्य संख्या है।\n\n- पैरामीटर्स:\n- word: एक स्ट्रिंग जो जांचे जाने वाले शब्द का प्रतिनिधित्व करती है। केवल छोटे अक्षरों और 100 से कम लंबाई को मानता है।\n\n- रिटर्न्स: एक ट्यूपल जिसमें एक बूलियन होता है जो यह इंगित करता है कि शब्द लकी है या नहीं, और एक पूर्णांक जो अधिकतम और न्यूनतम आवृत्तियों के बीच का अंतर होता है यदि शब्द लकी है, अन्यथा 0।\n\nउदाहरण:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "hu": "Meghatározza, hogy a megadott szó \"Szerencsés Szó\"-e. Egy szó akkor tekinthető szerencsésnek, ha a szóban a maximális és minimális karaktergyakoriság közötti különbség prímszám.\n\n- Paraméterek:\n- word: Egy string, amely a vizsgálandó szót jelöli. Feltételezzük, hogy csak kisbetűket tartalmaz, és hossza kevesebb mint 100.\n\n- Visszatér: Egy tuple, amely tartalmaz egy logikai értéket, amely jelzi, hogy a szó szerencsés-e, és egy egész számot, amely a maximális és minimális gyakoriság közötti különbség, ha a szó szerencsés, vagy 0 egyébként.\n\nPéldák:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)"
    },
    "docstring_bertscore": {
      "sq": "0.9842051107304868",
      "hy": "0.9650015254920338",
      "bn": "0.9610622877753499",
      "bg": "0.9673102064108022",
      "zh": "0.9493571980513449",
      "fr": "0.9794638035351839",
      "de": "0.9670035211024843",
      "ha": "0.987958629040903",
      "hi": "0.9600919783639944",
      "hu": "0.9583225789297356"
    }
  },
  {
    "task_id": "Swift/33",
    "prompt": {
      "en": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n*/",
      "sq": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nGjen shumën maksimale të një nënvargu të pandërprerë në një varg të numrave të plotë.\n\n- Parametrat:\n- nums: Një varg i numrave të plotë.\n\n- Kthen: Shuma maksimale e çdo nënvargu të pandërprerë.\n\nShembuj:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ka shumën 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] është shuma më e madhe në varg\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ka shumën 7\n*/",
      "hy": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nԳտնում է ամբողջ թվերի զանգվածում հարակից ենթազանգվածի առավելագույն գումարը:\n\n- Պարամետրեր:\n- nums: Ամբողջ թվերի զանգված:\n\n- Վերադարձնում է: Ցանկացած հարակից ենթազանգվածի առավելագույն գումարը:\n\nՕրինակներ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] գումարվում է 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] զանգվածում ամենամեծ գումարն է\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] գումարվում է 7\n*/",
      "bn": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nএকটি পূর্ণসংখ্যার অ্যারেতে একটি সন্নিহিত উপঅ্যারের সর্বাধিক যোগফল খুঁজে বের করে।\n\n- প্যারামিটারসমূহ:\n- nums: পূর্ণসংখ্যার একটি অ্যারে।\n\n- রিটার্নস: যেকোনো সন্নিহিত উপঅ্যারের সর্বাধিক যোগফল।\n\nউদাহরণ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] এর যোগফল 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] অ্যারেতে সর্বাধিক যোগফল\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] এর যোগফল 7\n*/",
      "bg": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nНамира максималната сума на непрекъснат подмасив в масив от цели числа.\n\n- Параметри:\n- nums: Масив от цели числа.\n\n- Връща: Максималната сума на който и да е непрекъснат подмасив.\n\nПримери:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] сумира до 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] е най-голямата сума в масива\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] сумира до 7\n*/",
      "zh": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\n找到整数数组中连续子数组的最大和。\n\n- 参数：\n- nums: 整数数组。\n\n- 返回：任何连续子数组的最大和。\n\n示例：\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] 的和为 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] 是数组中的最大和\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] 的和为 7\n*/",
      "fr": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nTrouve la somme maximale d'un sous-tableau contigu dans un tableau d'entiers.\n\n- Paramètres :\n- nums : Un tableau d'entiers.\n\n- Renvoie : La somme maximale de tout sous-tableau contigu.\n\nExemples :\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] somme à 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] est la plus grande somme dans le tableau\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] somme à 7\n*/",
      "de": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFindet die maximale Summe eines zusammenhängenden Teilarrays in einem Array von ganzen Zahlen.\n\n- Parameter:\n- nums: Ein Array von ganzen Zahlen.\n\n- Rückgabewert: Die maximale Summe eines beliebigen zusammenhängenden Teilarrays.\n\nBeispiele:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ergibt die Summe 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ist die größte Summe im Array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ergibt die Summe 7\n*/",
      "ha": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nNemi mafi girman jimillar wani jere mai ci gaba a cikin jerin lambobi.\n\n- Sigogi:\n- nums: Jerin lambobi.\n\n- Komawa: Mafi girman jimillar duk wani jere mai ci gaba.\n\nMisalai:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] yana da jimillar 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] shine mafi girman jimilla a cikin jerin\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] yana da jimillar 7\n*/",
      "hi": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nएक पूर्णांकों की सूची में एक निरंतर उप-सरणी का अधिकतम योग खोजता है।\n\n- पैरामीटर्स:\n- nums: पूर्णांकों की एक सूची।\n\n- रिटर्न करता है: किसी भी निरंतर उप-सरणी का अधिकतम योग।\n\nउदाहरण:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] का योग 9 है\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] सूची में सबसे बड़ा योग है\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] का योग 7 है\n*/",
      "hu": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nMegkeresi a maximális összeget egy összefüggő részhalmazban egy egész számokat tartalmazó tömbben.\n\n- Paraméterek:\n- nums: Egy egész számokat tartalmazó tömb.\n\n- Visszatér: Bármely összefüggő részhalmaz maximális összege.\n\nPéldák:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] összege 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] a legnagyobb összeg a tömbben\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] összege 7\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9833214041652625",
      "hy": "0.999999801369619",
      "bn": "0.9611274385403292",
      "bg": "0.9887994314438237",
      "zh": "0.9539433749190595",
      "fr": "0.9979463604904802",
      "de": "0.9671622267769312",
      "ha": "0.958034366246854",
      "hi": "0.9472590653364734",
      "hu": "0.970025086458787"
    },
    "canonical_solution": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}",
    "instruction": {
      "en": "Write a Swift function `func maxSubArraySum(_ nums: [Int]) -> Int {` to solve the following problem:\n\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n",
      "sq": "Shkruani një funksion Swift `func maxSubArraySum(_ nums: [Int]) -> Int {` për të zgjidhur problemin në vijim:\n\nGjen shumën maksimale të një nënvargu të pandërprerë në një varg të numrave të plotë.\n\n- Parametrat:\n- nums: Një varg i numrave të plotë.\n\n- Kthen: Shuma maksimale e çdo nënvargu të pandërprerë.\n\nShembuj:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ka shumën 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] është shuma më e madhe në varg\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ka shumën 7",
      "hy": "Գրեք Swift ֆունկցիա `func maxSubArraySum(_ nums: [Int]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nԳտնում է ամբողջ թվերի զանգվածում ամենամեծ գումարը հարակից ենթազանգվածի:\n\n- Պարամետրեր:\n- nums: Ամբողջ թվերի զանգված:\n\n- Վերադարձնում է: Ցանկացած հարակից ենթազանգվածի ամենամեծ գումարը:\n\nՕրինակներ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] գումարվում է 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ամենամեծ գումարն է զանգվածում\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] գումարվում է 7",
      "bn": "একটি Swift ফাংশন `func maxSubArraySum(_ nums: [Int]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি পূর্ণসংখ্যার অ্যারের মধ্যে একটি সন্নিহিত উপঅ্যারের সর্বাধিক যোগফল খুঁজে বের করে।\n\n- প্যারামিটারসমূহ:\n- nums: পূর্ণসংখ্যার একটি অ্যারে।\n\n- রিটার্নস: যেকোনো সন্নিহিত উপঅ্যারের সর্বাধিক যোগফল।\n\nউদাহরণসমূহ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] এর যোগফল 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] অ্যারের মধ্যে সর্বাধিক যোগফল\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] এর যোগফল 7",
      "bg": "Напишете Swift функция `func maxSubArraySum(_ nums: [Int]) -> Int {`, за да решите следния проблем:\n\nНамира максималната сума на непрекъснат подмасив в масив от цели числа.\n\n- Параметри:\n- nums: Масив от цели числа.\n\n- Връща: Максималната сума на който и да е непрекъснат подмасив.\n\nПримери:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] сумира до 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] е най-голямата сума в масива\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] сумира до 7",
      "zh": "编写一个 Swift 函数 `func maxSubArraySum(_ nums: [Int]) -> Int {` 来解决以下问题：\n\n找到整数数组中连续子数组的最大和。\n\n- 参数：\n- nums: 一个整数数组。\n\n- 返回值：任何连续子数组的最大和。\n\n示例：\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] 的和为 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] 是数组中最大的和\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] 的和为 7",
      "fr": "Écrire une fonction Swift `func maxSubArraySum(_ nums: [Int]) -> Int {` pour résoudre le problème suivant :\n\nTrouve la somme maximale d'un sous-tableau contigu dans un tableau d'entiers.\n\n- Paramètres :\n- nums : Un tableau d'entiers.\n\n- Renvoie : La somme maximale de tout sous-tableau contigu.\n\nExemples :\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] somme à 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] est la plus grande somme dans le tableau\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] somme à 7",
      "de": "Schreiben Sie eine Swift-Funktion `func maxSubArraySum(_ nums: [Int]) -> Int {`, um das folgende Problem zu lösen:\n\nFindet die maximale Summe eines zusammenhängenden Teilarrays in einem Array von ganzen Zahlen.\n\n- Parameter:\n- nums: Ein Array von ganzen Zahlen.\n\n- Rückgabe: Die maximale Summe eines beliebigen zusammenhängenden Teilarrays.\n\nBeispiele:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ergibt in der Summe 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ist die größte Summe im Array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ergibt in der Summe 7",
      "ha": "Rubuta aikin Swift `func maxSubArraySum(_ nums: [Int]) -> Int {` don warware matsalar mai zuwa:\n\nNemi mafi girman jimlar wani jere na lambobi masu jere a cikin jerin lambobi.\n\n- Sigogi:\n- nums: Jerin lambobi.\n\n- Komawa: Mafi girman jimlar duk wani jere na lambobi masu jere.\n\nMisalai:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ya tara zuwa 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] shine mafi girman jimla a cikin jerin\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ya tara zuwa 7",
      "hi": "Swift फ़ंक्शन `func maxSubArraySum(_ nums: [Int]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nएक पूर्णांक की array में एक निरंतर उप-array का अधिकतम योग खोजें।\n\n- पैरामीटर्स:\n- nums: पूर्णांकों की एक array।\n\n- रिटर्न करता है: किसी भी निरंतर उप-array का अधिकतम योग।\n\nउदाहरण:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] का योग 9 है\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] array में सबसे बड़ा योग है\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] का योग 7 है",
      "hu": "Írj egy Swift függvényt `func maxSubArraySum(_ nums: [Int]) -> Int {` a következő probléma megoldására:\n\nMegtalálja a maximális összegét egy összefüggő rész tömbnek egy egész számokat tartalmazó tömbben.\n\n- Paraméterek:\n- nums: Egy egész számokat tartalmazó tömb.\n\n- Visszatér: Bármely összefüggő rész tömb maximális összege.\n\nPéldák:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] összege 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] a legnagyobb összeg a tömbben\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] összege 7"
    },
    "instruction_bertscore": {
      "sq": "0.9830180955734222",
      "hy": "0.9944745000603715",
      "bn": "0.9567696866108049",
      "bg": "0.9825173483828333",
      "zh": "0.9645015728229689",
      "fr": "0.9960408992452127",
      "de": "0.9954277272589579",
      "ha": "0.9682241047939437",
      "hi": "0.9415075240232271",
      "hu": "0.9715416294179885"
    },
    "level": "easy",
    "test": "func check(_ maxSubArraySum: ([Int]) -> Int) {\nassert(maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9)\nassert(maxSubArraySum([-2, -3, -1]) == -1)\nassert(maxSubArraySum([5, -3, 5]) == 7)\nassert(maxSubArraySum([-1, -2, -3, -4]) == -1)\nassert(maxSubArraySum([2, 3, -2, 5, -3]) == 8)\nassert(maxSubArraySum([10, -11, 12]) == 12)\nassert(maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6)\n}\n\ncheck(maxSubArraySum)",
    "entry_point": "maxSubArraySum",
    "signature": "func maxSubArraySum(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n",
      "sq": "Gjen shumën maksimale të një nënvargu të pandërprerë në një varg të numrave të plotë.\n\n- Parametra:\n- nums: Një varg i numrave të plotë.\n\n- Kthen: Shuma maksimale e çdo nënvargu të pandërprerë.\n\nShembuj:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] ka shumën 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] është shuma më e madhe në varg\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] ka shumën 7",
      "hy": "Գտնում է ամբողջ թվերի զանգվածում հարակից ենթազանգվածի առավելագույն գումարը։\n\n- Պարամետրեր:\n- nums: Ամբողջ թվերի զանգված։\n\n- Վերադարձնում է: Ցանկացած հարակից ենթազանգվածի առավելագույն գումարը։\n\nՕրինակներ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] գումարվում է 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ամենամեծ գումարն է զանգվածում\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] գումարվում է 7",
      "bn": "একটি পূর্ণসংখ্যার অ্যারের মধ্যে ধারাবাহিক উপঅ্যারের সর্বাধিক যোগফল খুঁজে বের করে।\n\n- প্যারামিটারসমূহ:\n- nums: পূর্ণসংখ্যার একটি অ্যারে।\n\n- রিটার্ন করে: যেকোনো ধারাবাহিক উপঅ্যারের সর্বাধিক যোগফল।\n\nউদাহরণসমূহ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] এর যোগফল 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] অ্যারের সর্বাধিক যোগফল\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] এর যোগফল 7",
      "bg": "Намира максималната сума на непрекъснат подмасив в масив от цели числа.\n\n- Параметри:\n- nums: Масив от цели числа.\n\n- Връща: Максималната сума на който и да е непрекъснат подмасив.\n\nПримери:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] се сумира до 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] е най-голямата сума в масива\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] се сумира до 7",
      "zh": "找到整数数组中连续子数组的最大和。\n\n- 参数：\n- nums: 整数数组。\n\n- 返回：任何连续子数组的最大和。\n\n示例：\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] 的和为 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] 是数组中的最大和\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] 的和为 7",
      "fr": "Trouve la somme maximale d'un sous-tableau contigu dans un tableau d'entiers.\n\n- Paramètres:\n- nums: Un tableau d'entiers.\n\n- Retourne: La somme maximale de tout sous-tableau contigu.\n\nExemples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] somme à 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] est la plus grande somme dans le tableau\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] somme à 7",
      "de": "Findet die maximale Summe eines zusammenhängenden Teilarrays in einem Array von ganzen Zahlen.\n\n- Parameter:\n- nums: Ein Array von ganzen Zahlen.\n\n- Rückgabewert: Die maximale Summe eines beliebigen zusammenhängenden Teilarrays.\n\nBeispiele:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] summiert sich zu 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ist die größte Summe im Array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] summiert sich zu 7",
      "ha": "Nemo mafi girman jimillar wani jere mai ci gaba a cikin wani jeri na lambobi.\n\n- Sigogi:\n- nums: Wani jeri na lambobi.\n\n- Komawa: Mafi girman jimillar duk wani jere mai ci gaba.\n\nMisalai:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] yana da jimillar 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] shine mafi girman jimilla a cikin jerin\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] yana da jimillar 7",
      "hi": "किसी पूर्णांक के सरणी में एक सतत उप-सरणी का अधिकतम योग खोजता है।\n\n- पैरामीटर:\n- nums: पूर्णांकों की एक सरणी।\n\n- रिटर्न करता है: किसी भी सतत उप-सरणी का अधिकतम योग।\n\nउदाहरण:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] का योग 9 होता है\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] सरणी में सबसे बड़ा योग है\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] का योग 7 होता है",
      "hu": "Megkeresi a maximális összegű szomszédos rész tömböt egy egész számokat tartalmazó tömbben.\n\n- Paraméterek:\n- nums: Egész számokat tartalmazó tömb.\n\n- Visszatér: Bármely szomszédos rész tömb maximális összege.\n\nPéldák:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] összege 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] a legnagyobb összeg a tömbben\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] összege 7"
    },
    "docstring_bertscore": {
      "sq": "0.9784966722099251",
      "hy": "0.9927662787834715",
      "bn": "0.9542732999819584",
      "bg": "0.9947527812242014",
      "zh": "0.9514742006524147",
      "fr": "0.9923217439907154",
      "de": "0.9939882528875981",
      "ha": "0.9537661966191763",
      "hi": "0.9539680050863077",
      "hu": "0.9705550323153882"
    }
  },
  {
    "task_id": "Swift/34",
    "prompt": {
      "en": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "sq": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nKonverton një numër nga një bazë në një tjetër. Bazat mund të variojnë nga 2 deri në 16.\n\n- Parametrat:\n- fromBase: Baza e numrit hyrës (midis 2 dhe 16 përfshirë).\n- number: Numri në formatin string që do të konvertohet. Për baza më të mëdha se 10, \npërdor shkronjat e mëdha A deri në F.\n- toBase: Baza në të cilën numri do të konvertohet (midis 2 dhe 16 përfshirë).\n\n- Kthen: Një string që përfaqëson numrin e konvertuar në bazën e re.\n\nShembuj:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "hy": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nՓոխակերպում է թիվը մեկ հիմքից մյուսը: Հիմքերը կարող են լինել 2-ից 16:\n\n- Պարամետրեր:\n- fromBase: Մուտքային թվի հիմքը (2-ից 16 ներառյալ):\n- number: Փոխարկվող թիվը տողի ձևաչափով: 10-ից մեծ հիմքերի համար օգտագործվում են մեծատառեր A-ից F:\n- toBase: Հիմքը, որին պետք է փոխակերպել թիվը (2-ից 16 ներառյալ):\n\n- Վերադարձնում է: Տող, որը ներկայացնում է փոխակերպված թիվը նոր հիմքով:\n\nՕրինակներ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "bn": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nএকটি সংখ্যা একটি ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে।\n\n- Parameters:\n- fromBase: ইনপুট সংখ্যার ভিত্তি (2 থেকে 16 এর মধ্যে অন্তর্ভুক্ত)।\n- number: স্ট্রিং ফরম্যাটে রূপান্তর করার জন্য সংখ্যা। 10 এর চেয়ে বড় ভিত্তির জন্য, \nএটি বড় হাতের অক্ষর A থেকে F ব্যবহার করে।\n- toBase: যে ভিত্তিতে সংখ্যাটি রূপান্তর করা হবে (2 থেকে 16 এর মধ্যে অন্তর্ভুক্ত)।\n\n- Returns: নতুন ভিত্তিতে রূপান্তরিত সংখ্যাকে প্রতিনিধিত্বকারী একটি স্ট্রিং।\n\nউদাহরণ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "bg": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nПреобразува число от една бройна система в друга. Бройните системи могат да бъдат в диапазона от 2 до 16.\n\n- Параметри:\n- fromBase: Бройната система на входното число (между 2 и 16 включително).\n- number: Числото във формат на низ, което трябва да бъде преобразувано. За бройни системи по-големи от 10, \nизползва главни букви от A до F.\n- toBase: Бройната система, в която числото трябва да бъде преобразувано (между 2 и 16 включително).\n\n- Връща: Низ, представляващ преобразуваното число в новата бройна система.\n\nПримери:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "zh": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\n将一个数字从一个进制转换为另一个进制。进制范围可以是2到16。\n\n- 参数:\n- fromBase: 输入数字的进制（在2到16之间，包括2和16）。\n- number: 要转换的数字，以字符串格式表示。对于大于10的进制，使用大写字母A到F。\n- toBase: 要转换到的进制（在2到16之间，包括2和16）。\n\n- 返回: 一个字符串，表示在新进制中转换后的数字。\n\n示例:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "fr": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConvertit un nombre d'une base à une autre. Les bases peuvent varier de 2 à 16.\n\n- Paramètres :\n- fromBase : La base du nombre d'entrée (entre 2 et 16 inclus).\n- number : Le nombre au format chaîne à convertir. Pour les bases supérieures à 10,\nil utilise les lettres majuscules A à F.\n- toBase : La base vers laquelle le nombre doit être converti (entre 2 et 16 inclus).\n\n- Renvoie : Une chaîne représentant le nombre converti dans la nouvelle base.\n\nExemples :\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "de": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nKonvertiert eine Zahl von einer Basis in eine andere. Die Basen können von 2 bis 16 reichen.\n\n- Parameter:\n- fromBase: Die Basis der Eingabezahl (zwischen 2 und 16 einschließlich).\n- number: Die Zahl im String-Format, die konvertiert werden soll. Für Basen größer als 10 \nwerden Großbuchstaben A bis F verwendet.\n- toBase: Die Basis, in die die Zahl konvertiert werden soll (zwischen 2 und 16 einschließlich).\n\n- Rückgabe: Ein String, der die konvertierte Zahl in der neuen Basis darstellt.\n\nBeispiele:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "ha": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nYana canza lamba daga wata tushe zuwa wata. Tushen na iya zama daga 2 zuwa 16.\n\n- Sigogi:\n- fromBase: Tushen lambar shigarwa (tsakanin 2 da 16 har da su).\n- number: Lambar a cikin tsarin rubutu da za a canza. Don tushen da suka fi 10, \nyana amfani da manyan haruffa A zuwa F.\n- toBase: Tushen da za a canza lambar zuwa gare shi (tsakanin 2 da 16 har da su).\n\n- Komawa: Wani rubutu da ke wakiltar lambar da aka canza a cikin sabon tushe.\n\nMisalai:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "hi": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nएक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है। आधार 2 से 16 तक हो सकते हैं।\n\n- पैरामीटर्स:\n- fromBase: इनपुट संख्या का आधार (2 से 16 के बीच शामिल)।\n- number: स्ट्रिंग प्रारूप में संख्या जिसे परिवर्तित किया जाना है। 10 से अधिक के आधारों के लिए, \nयह अपरकेस अक्षरों A से F का उपयोग करता है।\n- toBase: आधार जिसमें संख्या को परिवर्तित किया जाना है (2 से 16 के बीच शामिल)।\n\n- रिटर्न्स: एक स्ट्रिंग जो नए आधार में परिवर्तित संख्या का प्रतिनिधित्व करती है।\n\nउदाहरण:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "hu": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nÁtalakít egy számot egyik számrendszerből a másikba. Az alapok 2 és 16 között lehetnek.\n\n- Paraméterek:\n- fromBase: A bemeneti szám alapja (2 és 16 között, beleértve).\n- number: A szám string formátumban, amelyet át kell alakítani. 10-nél nagyobb alapok esetén \nnagybetűs A-tól F-ig terjedő betűket használ.\n- toBase: Az alap, amelyre a számot át kell alakítani (2 és 16 között, beleértve).\n\n- Visszatér: Egy string, amely az átalakított számot reprezentálja az új számrendszerben.\n\nPéldák:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9893436786878593",
      "hy": "0.9714147046045072",
      "bn": "0.979481084378334",
      "bg": "0.9358040512621913",
      "zh": "0.9667129248550304",
      "fr": "0.9910453451621851",
      "de": "0.9895989187274891",
      "ha": "0.9853819957381185",
      "hi": "0.9823697660097244",
      "hu": "0.9592160183836306"
    },
    "canonical_solution": "let decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}",
    "instruction": {
      "en": "Write a Swift function `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` to solve the following problem:\n\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n",
      "sq": "Shkruani një funksion Swift `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` për të zgjidhur problemin e mëposhtëm:\n\nKonverton një numër nga një bazë në një tjetër. Bazat mund të variojnë nga 2 deri në 16.\n\n- Parametrat:\n- fromBase: Baza e numrit hyrës (midis 2 dhe 16 përfshirë).\n- number: Numri në formatin string që do të konvertohet. Për bazat më të mëdha se 10, \npërdor shkronjat e mëdha A deri në F.\n- toBase: Baza në të cilën numri do të konvertohet (midis 2 dhe 16 përfshirë).\n\n- Kthen: Një string që përfaqëson numrin e konvertuar në bazën e re.\n\nShembuj:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hy": "Գրեք Swift ֆունկցիա `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` հետևյալ խնդիրը լուծելու համար:\n\nՓոխակերպում է թիվը մի հիմքից մյուսը: Հիմքերը կարող են տատանվել 2-ից մինչև 16:\n\n- Պարամետրեր:\n- fromBase: Մուտքային թվի հիմքը (2-ից 16 ներառյալ):\n- number: Փոխակերպվող թիվը տողային ձևաչափով: 10-ից մեծ հիմքերի համար օգտագործվում են մեծատառեր A-ից F:\n- toBase: Հիմքը, դեպի որը պետք է փոխակերպվի թիվը (2-ից 16 ներառյալ):\n\n- Վերադարձնում է: Տող, որը ներկայացնում է փոխակերպված թիվը նոր հիմքում:\n\nՕրինակներ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "bn": "Swift ফাংশন `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে।\n\n- প্যারামিটারসমূহ:\n- fromBase: ইনপুট সংখ্যার ভিত্তি (2 এবং 16 এর মধ্যে অন্তর্ভুক্ত)।\n- number: স্ট্রিং ফরম্যাটে রূপান্তর করার জন্য সংখ্যা। 10 এর চেয়ে বড় ভিত্তির জন্য, এটি বড় হাতের অক্ষর A থেকে F ব্যবহার করে।\n- toBase: যে ভিত্তিতে সংখ্যাটি রূপান্তরিত হবে (2 এবং 16 এর মধ্যে অন্তর্ভুক্ত)।\n\n- রিটার্ন: নতুন ভিত্তিতে রূপান্তরিত সংখ্যার একটি স্ট্রিং উপস্থাপনা।\n\nউদাহরণসমূহ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "bg": "Напишете Swift функция `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {`, за да решите следния проблем:\n\nКонвертира число от една бройна система в друга. Бройните системи могат да бъдат в диапазона от 2 до 16.\n\n- Параметри:\n- fromBase: Бройната система на входното число (между 2 и 16 включително).\n- number: Числото във формат на низ, което трябва да бъде конвертирано. За бройни системи по-големи от 10, се използват главни букви от A до F.\n- toBase: Бройната система, в която числото трябва да бъде конвертирано (между 2 и 16 включително).\n\n- Връща: Низ, представляващ конвертираното число в новата бройна система.\n\nПримери:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "zh": "编写一个 Swift 函数 `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` 来解决以下问题：\n\n将一个数字从一个进制转换为另一个进制。进制可以从 2 到 16。\n\n- 参数：\n- fromBase: 输入数字的进制（介于 2 到 16 之间，包括 2 和 16）。\n- number: 要转换的字符串格式的数字。对于大于 10 的进制，使用大写字母 A 到 F。\n- toBase: 要转换到的进制（介于 2 到 16 之间，包括 2 和 16）。\n\n- 返回值：一个字符串，表示在新进制中转换后的数字。\n\n示例：\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "fr": "Écrire une fonction Swift `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` pour résoudre le problème suivant :\n\nConvertit un nombre d'une base à une autre. Les bases peuvent aller de 2 à 16.\n\n- Paramètres :\n- fromBase: La base du nombre d'entrée (entre 2 et 16 inclus).\n- number: Le nombre au format chaîne à convertir. Pour les bases supérieures à 10, \nil utilise les lettres majuscules de A à F.\n- toBase: La base vers laquelle le nombre doit être converti (entre 2 et 16 inclus).\n\n- Renvoie : Une chaîne représentant le nombre converti dans la nouvelle base.\n\nExemples :\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "de": "Schreiben Sie eine Swift-Funktion `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {`, um das folgende Problem zu lösen:\n\nKonvertiert eine Zahl von einer Basis in eine andere. Die Basen können von 2 bis 16 reichen.\n\n- Parameter:\n- fromBase: Die Basis der Eingabezahlen (zwischen 2 und 16 einschließlich).\n- number: Die Zahl im String-Format, die konvertiert werden soll. Für Basen größer als 10 werden Großbuchstaben A bis F verwendet.\n- toBase: Die Basis, in die die Zahl konvertiert werden soll (zwischen 2 und 16 einschließlich).\n\n- Rückgabe: Ein String, der die konvertierte Zahl in der neuen Basis darstellt.\n\nBeispiele:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "ha": "Rubuta aikin Swift `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` don warware matsalar mai zuwa:\n\nYana canza lamba daga wata tushe zuwa wata. Tushen na iya zama daga 2 zuwa 16.\n\n- Sigogi:\n- fromBase: Tushen lambar shigarwa (daga 2 zuwa 16 ciki har da).\n- number: Lambar a cikin tsarin rubutu da za a canza. Don tushen da suka fi 10, yana amfani da manyan haruffa A zuwa F.\n- toBase: Tushen da za a canza lambar zuwa (daga 2 zuwa 16 ciki har da).\n\n- Yana Mayarwa: Rubutu da ke wakiltar lambar da aka canza a cikin sabon tushe.\n\nMisalai:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hi": "Swift फ़ंक्शन `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n\nएक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है। आधार 2 से 16 तक हो सकते हैं।\n\n- पैरामीटर्स:\n- fromBase: इनपुट संख्या का आधार (2 और 16 के बीच शामिल)।\n- number: स्ट्रिंग प्रारूप में संख्या जिसे परिवर्तित किया जाना है। 10 से बड़े आधारों के लिए, यह अपरकेस अक्षर A से F का उपयोग करता है।\n- toBase: वह आधार जिसमें संख्या को परिवर्तित किया जाना है (2 और 16 के बीच शामिल)।\n\n- रिटर्न करता है: एक स्ट्रिंग जो नए आधार में परिवर्तित संख्या का प्रतिनिधित्व करती है।\n\nउदाहरण:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hu": "Írj egy Swift függvényt `func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {` a következő probléma megoldására:\n\nÁtalakít egy számot egyik számrendszerből a másikba. A számrendszerek 2 és 16 közöttiek lehetnek.\n\n- Paraméterek:\n- fromBase: A bemeneti szám számrendszere (2 és 16 között, beleértve).\n- number: A szám string formátumban, amelyet át kell alakítani. 10-nél nagyobb számrendszerek esetén a nagybetűs A-tól F-ig terjedő betűket használja.\n- toBase: Az a számrendszer, amelybe a számot át kell alakítani (2 és 16 között, beleértve).\n\n- Visszatér: Egy string, amely az átalakított számot reprezentálja az új számrendszerben.\n\nPéldák:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\""
    },
    "instruction_bertscore": {
      "sq": "0.9895796515805287",
      "hy": "0.9752953463587858",
      "bn": "0.973878714481245",
      "bg": "0.9406256051314322",
      "zh": "0.9732202547681144",
      "fr": "0.9884287871528126",
      "de": "0.9880573483402774",
      "ha": "0.9791863168928782",
      "hi": "0.9726088704552889",
      "hu": "0.9377706906648178"
    },
    "level": "easy",
    "test": "func check(_ convertNumber: (Int, String, Int) -> String) {\nassert(convertNumber(10, \"255\", 2) == \"11111111\")\nassert(convertNumber(2, \"1010\", 10) == \"10\")\nassert(convertNumber(8, \"175\", 16) == \"7D\")\nassert(convertNumber(16, \"1A\", 10) == \"26\")\nassert(convertNumber(2, \"1111\", 16) == \"F\")\nassert(convertNumber(16, \"FF\", 8) == \"377\")\nassert(convertNumber(10, \"1000\", 16) == \"3E8\")\n}\n\ncheck(convertNumber)",
    "entry_point": "convertNumber",
    "signature": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {",
    "docstring": {
      "en": "\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n",
      "sq": "Konverton një numër nga një bazë në një tjetër. Bazat mund të variojnë nga 2 deri në 16.\n\n- Parametrat:\n- fromBase: Baza e numrit hyrës (midis 2 dhe 16 përfshirë).\n- number: Numri në formatin e vargut që do të konvertohet. Për baza më të mëdha se 10, \npërdor shkronjat e mëdha A deri në F.\n- toBase: Baza në të cilën numri do të konvertohet (midis 2 dhe 16 përfshirë).\n\n- Kthen: Një varg që përfaqëson numrin e konvertuar në bazën e re.\n\nShembuj:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hy": "Վերածում է թիվը մեկ հիմքից մյուսը: Հիմքերը կարող են տատանվել 2-ից մինչև 16:\n\n- Պարամետրեր:\n- fromBase: Մուտքային թվի հիմքը (2-ից մինչև 16 ներառյալ):\n- number: Թիվը տողային ձևաչափով, որը պետք է վերածվի: 10-ից մեծ հիմքերի համար \nօգտագործվում են մեծատառեր A-ից F:\n- toBase: Հիմքը, որին պետք է վերածվի թիվը (2-ից մինչև 16 ներառյալ):\n\n- Վերադարձնում է: Տող, որը ներկայացնում է նոր հիմքում վերածված թիվը:\n\nՕրինակներ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "bn": "একটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে।\n\n- প্যারামিটারসমূহ:\n- fromBase: ইনপুট সংখ্যার ভিত্তি (2 এবং 16 অন্তর্ভুক্ত)।\n- number: স্ট্রিং ফরম্যাটে রূপান্তর করার জন্য সংখ্যা। 10-এর বেশি ভিত্তির জন্য, এটি বড় হাতের অক্ষর A থেকে F ব্যবহার করে।\n- toBase: যে ভিত্তিতে সংখ্যাটি রূপান্তরিত হবে (2 এবং 16 অন্তর্ভুক্ত)।\n\n- রিটার্ন: নতুন ভিত্তিতে রূপান্তরিত সংখ্যাটি একটি স্ট্রিং হিসেবে প্রদান করে।\n\nউদাহরণসমূহ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "bg": "Преобразува число от една база в друга. Базите могат да варират от 2 до 16.\n\n- Параметри:\n- fromBase: Базата на входното число (между 2 и 16 включително).\n- number: Числото във формат на низ, което трябва да бъде преобразувано. За бази по-големи от 10, се използват главни букви от A до F.\n- toBase: Базата, в която числото трябва да бъде преобразувано (между 2 и 16 включително).\n\n- Връща: Низ, представляващ преобразуваното число в новата база.\n\nПримери:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "zh": "将一个数字从一个进制转换为另一个进制。进制范围可以是2到16。\n\n- 参数：\n- fromBase: 输入数字的进制（介于2到16之间，包括2和16）。\n- number: 要转换的数字，字符串格式。对于大于10的进制，使用大写字母A到F。\n- toBase: 要转换到的进制（介于2到16之间，包括2和16）。\n\n- 返回值：一个字符串，表示在新进制中转换后的数字。\n\n示例：\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "fr": "Convertit un nombre d'une base à une autre. Les bases peuvent varier de 2 à 16.\n\n- Paramètres :\n- fromBase: La base du nombre d'entrée (entre 2 et 16 inclus).\n- number: Le nombre au format chaîne à convertir. Pour les bases supérieures à 10, \nil utilise les lettres majuscules A à F.\n- toBase: La base vers laquelle le nombre doit être converti (entre 2 et 16 inclus).\n\n- Renvoie : Une chaîne représentant le nombre converti dans la nouvelle base.\n\nExemples :\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "de": "Konvertiert eine Zahl von einer Basis in eine andere. Die Basen können von 2 bis 16 reichen.\n\n- Parameter:\n- fromBase: Die Basis der Eingabezahl (zwischen 2 und 16 einschließlich).\n- number: Die Zahl im String-Format, die konvertiert werden soll. Für Basen größer als 10 werden Großbuchstaben A bis F verwendet.\n- toBase: Die Basis, in die die Zahl konvertiert werden soll (zwischen 2 und 16 einschließlich).\n\n- Rückgabewert: Ein String, der die konvertierte Zahl in der neuen Basis darstellt.\n\nBeispiele:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "ha": "Yana canza lamba daga wata tushe zuwa wata. Tushen na iya zama daga 2 zuwa 16.\n\n- Sigogi:\n- fromBase: Tushen lambar shigarwa (daga 2 zuwa 16 ciki har da).\n- number: Lambar a cikin tsarin kirtani da za a canza. Don tushe mafi girma fiye da 10, yana amfani da manyan haruffa A zuwa F.\n- toBase: Tushen da za a canza lambar zuwa (daga 2 zuwa 16 ciki har da).\n\n- Komawa: Kirtani da ke wakiltar lambar da aka canza a cikin sabon tushe.\n\nMisalai:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hi": "एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है। आधार 2 से 16 तक हो सकते हैं।\n\n- पैरामीटर्स:\n- fromBase: इनपुट संख्या का आधार (2 और 16 के बीच समावेशी)।\n- number: स्ट्रिंग प्रारूप में संख्या जिसे परिवर्तित किया जाना है। 10 से अधिक के आधारों के लिए, यह अपरकेस अक्षरों A से F का उपयोग करता है।\n- toBase: वह आधार जिसमें संख्या को परिवर्तित किया जाना है (2 और 16 के बीच समावेशी)।\n\n- रिटर्न्स: एक स्ट्रिंग जो नए आधार में परिवर्तित संख्या को दर्शाती है।\n\nउदाहरण:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "hu": "Átalakít egy számot egyik számrendszerből a másikba. A számrendszerek 2-től 16-ig terjedhetnek.\n\n- Paraméterek:\n- fromBase: A bemeneti szám számrendszere (2 és 16 között, beleértve).\n- number: A szám string formátumban, amelyet át kell alakítani. 10-nél nagyobb számrendszerek esetén nagybetűs A-tól F-ig terjedő betűket használ.\n- toBase: Az a számrendszer, amelybe a számot át kell alakítani (2 és 16 között, beleértve).\n\n- Visszatérési érték: Egy string, amely az átalakított számot reprezentálja az új számrendszerben.\n\nPéldák:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\""
    },
    "docstring_bertscore": {
      "sq": "0.9864494354057999",
      "hy": "0.9739400912689847",
      "bn": "0.955950534919417",
      "bg": "0.9801310029850802",
      "zh": "0.9634589619529168",
      "fr": "0.9898916999091345",
      "de": "0.9866840178858022",
      "ha": "0.9748237978342089",
      "hi": "0.9665532260286783",
      "hu": "0.9269798965847165"
    }
  },
  {
    "task_id": "Swift/35",
    "prompt": {
      "en": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "sq": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nGjen numrin e k-të më të vogël unik nga një listë e dhënë me numra të plotë. Nëse dy numra janë të njëjtë,\nata konsiderohen si një numër unik. Nëse numri i k-të më i vogël unik nuk ekziston, kthen \"NO RESULT\".\n\n- Parametrat:\n- numbers: Një varg me numra të plotë.\n- k: Rendi i numrit më të vogël unik për të gjetur.\n\n- Kthen: Një varg që përfaqëson numrin e k-të më të vogël unik ose \"NO RESULT\" nëse nuk ekziston.\n\nShembuj:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "hy": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nԳտնում է տրված ամբողջ թվերի ցանկից k-րդ փոքր եզակի թիվը։ Եթե երկու թիվ նույնն են,\nնրանք համարվում են որպես մեկ եզակի թիվ։ Եթե k-րդ փոքր եզակի թիվը գոյություն չունի, վերադարձնում է \"NO RESULT\"։\n\n- Պարամետրեր:\n- numbers: Ամբողջ թվերի զանգված։\n- k: Փոքր եզակի թիվի կարգը, որը պետք է գտնել։\n\n- Վերադարձնում է: Տողի տեսքով k-րդ փոքր եզակի թիվը կամ \"NO RESULT\", եթե այն գոյություն չունի։\n\nՕրինակներ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "bn": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nএকটি প্রদত্ত পূর্ণসংখ্যার তালিকা থেকে k-তম ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করে। যদি দুটি সংখ্যা একই হয়,\nতাহলে তাদের একটি অনন্য সংখ্যা হিসেবে গণ্য করা হয়। যদি k-তম ক্ষুদ্রতম অনন্য সংখ্যা বিদ্যমান না থাকে, তাহলে \"NO RESULT\" প্রদান করে।\n\n- Parameters:\n- numbers: পূর্ণসংখ্যার একটি অ্যারে।\n- k: খুঁজে বের করার জন্য ক্ষুদ্রতম অনন্য সংখ্যার ক্রম।\n\n- Returns: একটি স্ট্রিং যা k-তম ক্ষুদ্রতম অনন্য সংখ্যা বা \"NO RESULT\" নির্দেশ করে যদি এটি বিদ্যমান না থাকে।\n\nউদাহরণ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "bg": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nНамира k-тото най-малко уникално число от даден списък с цели числа. Ако две числа са еднакви,\nте се считат за едно уникално число. Ако k-тото най-малко уникално число не съществува, връща \"NO RESULT\".\n\n- Параметри:\n- numbers: Масив от цели числа.\n- k: Поредността на най-малкото уникално число, което да се намери.\n\n- Връща: Низ, представляващ k-тото най-малко уникално число или \"NO RESULT\", ако не съществува.\n\nПримери:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "zh": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\n查找给定整数列表中的第k个最小唯一数字。如果两个数字相同，它们被视为一个唯一数字。如果第k个最小唯一数字不存在，则返回 \"NO RESULT\"。\n\n- 参数:\n- numbers: 整数数组。\n- k: 要查找的第k个最小唯一数字的顺序。\n\n- 返回: 一个字符串，表示第k个最小唯一数字，如果不存在则返回 \"NO RESULT\"。\n\n示例:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "fr": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nTrouve le k-ième plus petit nombre unique d'une liste donnée d'entiers. Si deux nombres sont identiques,\nils sont considérés comme un seul nombre unique. Si le k-ième plus petit nombre unique n'existe pas, retourne \"NO RESULT\".\n\n- Paramètres :\n- numbers: Un tableau d'entiers.\n- k: L'ordre du plus petit nombre unique à trouver.\n\n- Retourne : Une chaîne de caractères représentant le k-ième plus petit nombre unique ou \"NO RESULT\" s'il n'existe pas.\n\nExemples :\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "de": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFindet die k-kleinste eindeutige Zahl aus einer gegebenen Liste von ganzen Zahlen. Wenn zwei Zahlen gleich sind,\nwerden sie als eine eindeutige Zahl betrachtet. Wenn die k-kleinste eindeutige Zahl nicht existiert, wird \"NO RESULT\" zurückgegeben.\n\n- Parameter:\n- numbers: Ein Array von ganzen Zahlen.\n- k: Die Reihenfolge der kleinsten eindeutigen Zahl, die gefunden werden soll.\n\n- Rückgabewert: Ein String, der die k-kleinste eindeutige Zahl darstellt oder \"NO RESULT\", wenn sie nicht existiert.\n\nBeispiele:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "ha": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nNemo lamba ta k mafi ƙanƙanta daga jerin lambobin cikakku. Idan lambobi biyu suna daidai,\nana ɗaukar su a matsayin lamba guda. Idan lamba ta k mafi ƙanƙanta ba ta wanzu, yana dawowa da \"NO RESULT\".\n\n- Parameters:\n- numbers: Jerin lambobin cikakku.\n- k: Tsari na lamba mafi ƙanƙanta da za a nema.\n\n- Returns: Wani String da ke wakiltar lamba ta k mafi ƙanƙanta ko \"NO RESULT\" idan ba ta wanzu ba.\n\nMisalai:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "hi": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nदिए गए पूर्णांकों की सूची से kवां सबसे छोटा अद्वितीय संख्या खोजता है। यदि दो संख्याएँ समान हैं,\nतो उन्हें एक अद्वितीय संख्या के रूप में माना जाता है। यदि kवां सबसे छोटा अद्वितीय संख्या मौजूद नहीं है, तो \"NO RESULT\" लौटाता है।\n\n- Parameters:\n- numbers: पूर्णांकों की एक सूची।\n- k: खोजने के लिए सबसे छोटे अद्वितीय संख्या का क्रम।\n\n- Returns: एक स्ट्रिंग जो kवां सबसे छोटा अद्वितीय संख्या या \"NO RESULT\" का प्रतिनिधित्व करता है यदि यह मौजूद नहीं है।\n\nउदाहरण:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "hu": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nMegkeresi a megadott egész számok listájából a k-adik legkisebb egyedi számot. Ha két szám megegyezik,\nazokat egy egyedi számnak tekintjük. Ha a k-adik legkisebb egyedi szám nem létezik, \"NO RESULT\"-ot ad vissza.\n\n- Paraméterek:\n- numbers: Egész számok tömbje.\n- k: A legkisebb egyedi szám sorszáma, amelyet meg kell találni.\n\n- Visszatér: Egy String, amely a k-adik legkisebb egyedi számot vagy \"NO RESULT\"-ot jelenti, ha nem létezik.\n\nPéldák:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9800684344150541",
      "hy": "0.9770049580483531",
      "bn": "0.9676284122812201",
      "bg": "0.983767925261829",
      "zh": "0.9696184900688086",
      "fr": "0.976497457424809",
      "de": "0.9686434135283084",
      "ha": "0.9627496528622412",
      "hi": "0.9765298341769176",
      "hu": "0.9757361071743021"
    },
    "canonical_solution": "let uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}",
    "instruction": {
      "en": "Write a Swift function `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` to solve the following problem:\n\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n",
      "sq": "Shkruani një funksion Swift `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` për të zgjidhur problemin e mëposhtëm:\n\nGjen numrin e kth më të vogël unik nga një listë e dhënë e numrave të plotë. Nëse dy numra janë të njëjtë, ata konsiderohen si një numër unik. Nëse numri i kth më i vogël unik nuk ekziston, kthen \"NO RESULT\".\n\n- Parametrat:\n- numbers: Një varg i numrave të plotë.\n- k: Rendi i numrit më të vogël unik për të gjetur.\n\n- Kthen: Një varg që përfaqëson numrin e kth më të vogël unik ose \"NO RESULT\" nëse nuk ekziston.\n\nShembuj:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hy": "Գրեք Swift ֆունկցիա `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` հետևյալ խնդիրը լուծելու համար:\n\nԳտնում է տրված ամբողջ թվերի ցուցակից k-րդ փոքրագույն եզակի թիվը։ Եթե երկու թիվ նույնն են, դրանք համարվում են որպես մեկ եզակի թիվ։ Եթե k-րդ փոքրագույն եզակի թիվը գոյություն չունի, վերադարձնում է \"NO RESULT\"։\n\n- Պարամետրեր:\n- numbers: Ամբողջ թվերի զանգված։\n- k: Փոքրագույն եզակի թիվը գտնելու կարգը։\n\n- Վերադարձնում է: Տող, որը ներկայացնում է k-րդ փոքրագույն եզակի թիվը կամ \"NO RESULT\", եթե այն գոյություն չունի։\n\nՕրինակներ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "bn": "একটি Swift ফাংশন `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nপ্রদত্ত পূর্ণসংখ্যার তালিকা থেকে kth ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করে। যদি দুটি সংখ্যা একই হয়, তাহলে তারা একটি অনন্য সংখ্যা হিসেবে বিবেচিত হয়। যদি kth ক্ষুদ্রতম অনন্য সংখ্যা বিদ্যমান না থাকে, তাহলে \"NO RESULT\" ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- numbers: পূর্ণসংখ্যার একটি অ্যারে।\n- k: ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করার ক্রম।\n\n- রিটার্নস: একটি স্ট্রিং যা kth ক্ষুদ্রতম অনন্য সংখ্যা বা \"NO RESULT\" প্রতিনিধিত্ব করে যদি এটি বিদ্যমান না থাকে।\n\nউদাহরণসমূহ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "bg": "Напишете функция на Swift `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {`, за да решите следния проблем:\n\nНамира k-тото най-малко уникално число от даден списък с цели числа. Ако две числа са еднакви, те се считат за едно уникално число. Ако k-тото най-малко уникално число не съществува, връща \"NO RESULT\".\n\n- Параметри:\n- numbers: Масив от цели числа.\n- k: Поредността на най-малкото уникално число, което трябва да се намери.\n\n- Връща: Низ, представляващ k-тото най-малко уникално число или \"NO RESULT\", ако не съществува.\n\nПримери:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "zh": "编写一个 Swift 函数 `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` 来解决以下问题：\n\n查找给定整数列表中的第 k 小的唯一数字。如果两个数字相同，它们被视为一个唯一数字。如果第 k 小的唯一数字不存在，则返回 \"NO RESULT\"。\n\n- 参数：\n- numbers: 一个整数数组。\n- k: 要查找的第 k 小的唯一数字的顺序。\n\n- 返回值：一个字符串，表示第 k 小的唯一数字，如果不存在则返回 \"NO RESULT\"。\n\n示例：\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "fr": "Écrire une fonction Swift `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` pour résoudre le problème suivant :\n\nTrouve le k-ième plus petit nombre unique d'une liste donnée d'entiers. Si deux nombres sont identiques, ils sont considérés comme un seul nombre unique. Si le k-ième plus petit nombre unique n'existe pas, retourne \"NO RESULT\".\n\n- Paramètres :\n- numbers: Un tableau d'entiers.\n- k: L'ordre du plus petit nombre unique à trouver.\n\n- Renvoie : Une chaîne de caractères représentant le k-ième plus petit nombre unique ou \"NO RESULT\" s'il n'existe pas.\n\nExemples :\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "de": "Schreiben Sie eine Swift-Funktion `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {`, um das folgende Problem zu lösen:\n\nFindet die k-kleinste eindeutige Zahl aus einer gegebenen Liste von ganzen Zahlen. Wenn zwei Zahlen gleich sind, werden sie als eine eindeutige Zahl betrachtet. Wenn die k-kleinste eindeutige Zahl nicht existiert, wird \"NO RESULT\" zurückgegeben.\n\n- Parameter:\n- numbers: Ein Array von ganzen Zahlen.\n- k: Die Ordnung der kleinsten eindeutigen Zahl, die gefunden werden soll.\n\n- Rückgabe: Ein String, der die k-kleinste eindeutige Zahl darstellt oder \"NO RESULT\", wenn sie nicht existiert.\n\nBeispiele:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "ha": "Rubuta aikin Swift `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` don warware matsalar mai zuwa:\n\nNemo k na ƙananan lambobi na musamman daga jerin lambobin lambobi da aka bayar. Idan lambobi biyu iri ɗaya ne, ana ɗaukar su a matsayin lamba ɗaya ta musamman. Idan k na ƙananan lamba ta musamman bai wanzu ba, yana dawowa da \"NO RESULT\".\n\n- Sigogi:\n- numbers: Jeri na lambobin lambobi.\n- k: Tsarin ƙananan lamba ta musamman da za a nema.\n\n- Yana dawowa: Wani String da ke wakiltar k na ƙananan lamba ta musamman ko \"NO RESULT\" idan bai wanzu ba.\n\nMisalai:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hi": "Swift फ़ंक्शन `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n\nदिए गए पूर्णांकों की सूची से kवाँ सबसे छोटा अद्वितीय संख्या खोजें। यदि दो संख्याएँ समान हैं, तो उन्हें एक अद्वितीय संख्या माना जाता है। यदि kवाँ सबसे छोटा अद्वितीय संख्या मौजूद नहीं है, तो \"NO RESULT\" लौटाता है।\n\n- पैरामीटर्स:\n- numbers: पूर्णांकों की एक array।\n- k: सबसे छोटा अद्वितीय संख्या खोजने के लिए क्रम।\n\n- रिटर्न्स: एक String जो kवाँ सबसे छोटा अद्वितीय संख्या या \"NO RESULT\" का प्रतिनिधित्व करता है यदि यह मौजूद नहीं है।\n\nउदाहरण:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hu": "Írj egy Swift függvényt `func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {` a következő probléma megoldására:\n\nMegtalálja a k-adik legkisebb egyedi számot egy adott egész számokat tartalmazó listából. Ha két szám megegyezik, akkor egy egyedi számnak számítanak. Ha a k-adik legkisebb egyedi szám nem létezik, akkor \"NO RESULT\" értéket ad vissza.\n\n- Paraméterek:\n- numbers: Egy egész számokat tartalmazó tömb.\n- k: A legkisebb egyedi szám sorszáma, amelyet meg kell találni.\n\n- Visszatérési érték: Egy String, amely a k-adik legkisebb egyedi számot vagy \"NO RESULT\" értéket képviseli, ha nem létezik.\n\nPéldák:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\""
    },
    "instruction_bertscore": {
      "sq": "0.9944097465561541",
      "hy": "0.982151471220967",
      "bn": "0.9858098455788676",
      "bg": "0.974351057527346",
      "zh": "0.9709580533585079",
      "fr": "0.9818175735504474",
      "de": "0.9697406477531452",
      "ha": "0.9729086037002705",
      "hi": "0.9626805294896411",
      "hu": "0.9755237712969759"
    },
    "level": "easy",
    "test": "func testKthUniqueSmallestNumber() {\nassert(kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2) == \"3\")\nassert(kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4) == \"4\")\nassert(kthUniqueSmallestNumber([10, 20, 30], 4) == \"NO RESULT\")\nassert(kthUniqueSmallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == \"7\")\nassert(kthUniqueSmallestNumber([12, 15, 12, 18, 20, 22, 15, 18], 3) == \"18\")\nassert(kthUniqueSmallestNumber([3, 3, 3, 3, 3], 1) == \"3\")\nassert(kthUniqueSmallestNumber([40, 30, 20, 10], 2) == \"20\")\n}\n\ntestKthUniqueSmallestNumber()",
    "entry_point": "kthUniqueSmallestNumber",
    "signature": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {",
    "docstring": {
      "en": "\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n",
      "sq": "Gjen numrin e kth më të vogël unik nga një listë e dhënë e numrave të plotë. Nëse dy numra janë të njëjtë, ata konsiderohen si një numër unik. Nëse numri i kth më i vogël unik nuk ekziston, kthen \"NO RESULT\".\n\n- Parametrat:\n- numbers: Një varg i numrave të plotë.\n- k: Rendi i numrit më të vogël unik për të gjetur.\n\n- Kthen: Një varg që përfaqëson numrin e kth më të vogël unik ose \"NO RESULT\" nëse nuk ekziston.\n\nShembuj:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hy": "Տրվում է ամբողջ թվերի ցուցակ, գտնել k-րդ փոքր եզակի թիվը: Եթե երկու թիվ նույնն են, դրանք համարվում են որպես մեկ եզակի թիվ: Եթե k-րդ փոքր եզակի թիվը գոյություն չունի, վերադարձնում է \"NO RESULT\":\n\n- Պարամետրեր:\n- numbers: Ամբողջ թվերի զանգված:\n- k: Փոքր եզակի թիվը գտնելու կարգը:\n\n- Վերադարձնում է: Տող, որը ներկայացնում է k-րդ փոքր եզակի թիվը կամ \"NO RESULT\", եթե այն գոյություն չունի:\n\nՕրինակներ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "bn": "Finds the kth smallest unique number from a given list of integers. If two numbers are the same, they are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- প্যারামিটারসমূহ:\n- numbers: পূর্ণসংখ্যার একটি অ্যারে।\n- k: খুঁজে বের করার জন্য ক্ষুদ্রতম অনন্য সংখ্যার ক্রম।\n\n- রিটার্ন: একটি স্ট্রিং যা kth ক্ষুদ্রতম অনন্য সংখ্যা বা \"NO RESULT\" প্রতিনিধিত্ব করে যদি এটি বিদ্যমান না থাকে।\n\nউদাহরণসমূহ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "bg": "Намира k-тото най-малко уникално число от даден списък с цели числа. Ако две числа са еднакви, те се считат за едно уникално число. Ако k-тото най-малко уникално число не съществува, връща \"NO RESULT\".\n\n- Параметри:\n- numbers: Масив от цели числа.\n- k: Поредността на най-малкото уникално число, което да бъде намерено.\n\n- Връща: Низ, представляващ k-тото най-малко уникално число или \"NO RESULT\", ако не съществува.\n\nПримери:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "zh": "从给定的整数列表中找到第k小的唯一数字。如果两个数字相同，它们被视为一个唯一数字。如果不存在第k小的唯一数字，则返回“NO RESULT”。\n\n- 参数：\n- numbers: 整数数组。\n- k: 要查找的第k小的唯一数字的顺序。\n\n- 返回：一个字符串，表示第k小的唯一数字，如果不存在则返回“NO RESULT”。\n\n示例：\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "fr": "Trouve le k-ième plus petit nombre unique d'une liste donnée d'entiers. Si deux nombres sont identiques, ils sont considérés comme un seul nombre unique. Si le k-ième plus petit nombre unique n'existe pas, retourne \"AUCUN RÉSULTAT\".\n\n- Paramètres:\n- numbers: Un tableau d'entiers.\n- k: L'ordre du plus petit nombre unique à trouver.\n\n- Retourne: Une chaîne de caractères représentant le k-ième plus petit nombre unique ou \"AUCUN RÉSULTAT\" s'il n'existe pas.\n\nExemples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"AUCUN RÉSULTAT\"",
      "de": "Findet die k-kleinste eindeutige Zahl aus einer gegebenen Liste von ganzen Zahlen. Wenn zwei Zahlen gleich sind, werden sie als eine eindeutige Zahl betrachtet. Wenn die k-kleinste eindeutige Zahl nicht existiert, wird \"NO RESULT\" zurückgegeben.\n\n- Parameter:\n- numbers: Ein Array von ganzen Zahlen.\n- k: Die Reihenfolge der kleinsten eindeutigen Zahl, die gefunden werden soll.\n\n- Rückgabe: Ein String, der die k-kleinste eindeutige Zahl darstellt oder \"NO RESULT\", wenn sie nicht existiert.\n\nBeispiele:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "ha": "Nemo lamba ta k na ƙanana masu maimaita kansu daga jerin lambobin cikakke da aka bayar. Idan lambobi biyu suna daidai, ana ɗaukar su a matsayin lamba guda ɗaya mai maimaita kanta. Idan lamba ta k na ƙanana masu maimaita kanta ba ta wanzu, yana mayar da \"NO RESULT\".\n\n- Sigogi:\n- numbers: Wani tsararren lambobi cikakke.\n- k: Matsayin lamba ta ƙanana masu maimaita kanta da za a nema.\n\n- Mayarwa: Wani String da ke wakiltar lamba ta k na ƙanana masu maimaita kanta ko \"NO RESULT\" idan ba ta wanzu.\n\nMisalai:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hi": "दिए गए पूर्णांकों की सूची से kth सबसे छोटा अद्वितीय संख्या खोजता है। यदि दो संख्याएँ समान हैं, तो उन्हें एक अद्वितीय संख्या के रूप में माना जाता है। यदि kth सबसे छोटा अद्वितीय संख्या मौजूद नहीं है, तो \"NO RESULT\" लौटाता है।\n\n- पैरामीटर्स:\n- numbers: पूर्णांकों की एक श्रृंखला।\n- k: खोजने के लिए सबसे छोटे अद्वितीय संख्या का क्रम।\n\n- रिटर्न करता है: एक स्ट्रिंग जो kth सबसे छोटे अद्वितीय संख्या का प्रतिनिधित्व करती है या \"NO RESULT\" यदि यह मौजूद नहीं है।\n\nउदाहरण:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "hu": "Megkeresi a megadott egész számok listájából a k-adik legkisebb egyedi számot. Ha két szám megegyezik, akkor azokat egy egyedi számnak tekintjük. Ha a k-adik legkisebb egyedi szám nem létezik, \"NO RESULT\"-ot ad vissza.\n\n- Paraméterek:\n- numbers: Egész számok tömbje.\n- k: A keresendő legkisebb egyedi szám sorszáma.\n\n- Visszatérési érték: Egy String, amely a k-adik legkisebb egyedi számot vagy \"NO RESULT\"-ot jelenti, ha nem létezik.\n\nPéldák:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\""
    },
    "docstring_bertscore": {
      "sq": "0.9927845527785266",
      "hy": "0.964490846782393",
      "bn": "0.9974201886111189",
      "bg": "0.9781697266027416",
      "zh": "0.968071953922071",
      "fr": "0.9783689528749197",
      "de": "0.9679541661061174",
      "ha": "0.9670358978545931",
      "hi": "0.9887243491597925",
      "hu": "0.9651828750299186"
    }
  },
  {
    "task_id": "Swift/36",
    "prompt": {
      "en": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "sq": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nGjen distancën më të shkurtër midis çdo dy pikave në një grup pikash të dhëna në një plan 2D.\n\n- Parametrat:\n- points: Një varg treshesh, ku çdo treshe përfaqëson koordinatat x dhe y të një pike.\n\n- Kthen: Distanca më e shkurtër midis çdo dy pikave, e rrumbullakosur në katër vende dhjetore.\n\nShembull Përdorimi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "hy": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nԳտնում է ամենակարճ հեռավորությունը ցանկացած երկու կետի միջև տրված կետերի հավաքածուում 2D հարթության վրա:\n\n- Պարամետրեր:\n- points: Թվերի զանգված, որտեղ յուրաքանչյուր զույգ ներկայացնում է կետի x և y կոորդինատները:\n\n- Վերադարձնում է: Ամենակարճ հեռավորությունը ցանկացած երկու կետի միջև, կլորացված չորս տասնորդական թվանշանի:\n\nՕրինակ օգտագործում:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "bn": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nদ্বি-মাত্রিক সমতলে প্রদত্ত বিন্দুগুলির একটি সেটের মধ্যে যেকোনো দুটি বিন্দুর মধ্যে সবচেয়ে ছোট দূরত্ব খুঁজে বের করে।\n\n- প্যারামিটার:\n- points: একটি টাপল এর অ্যারে, যেখানে প্রতিটি টাপল একটি বিন্দুর x এবং y কোঅর্ডিনেট উপস্থাপন করে।\n\n- রিটার্নস: যেকোনো দুটি বিন্দুর মধ্যে সবচেয়ে ছোট দূরত্ব, চার দশমিক স্থান পর্যন্ত রাউন্ড করা।\n\nউদাহরণ ব্যবহার:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "bg": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nНамира най-краткото разстояние между две точки в даден набор от точки в двумерна равнина.\n\n- Параметри:\n- points: Масив от кортежи, където всеки кортеж представлява x и y координатите на точка.\n\n- Връща: Най-краткото разстояние между две точки, закръглено до четири десетични знака.\n\nПример за използване:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "zh": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\n在二维平面中，找到给定点集中的任意两点之间的最短距离。\n\n- 参数:\n- points: 一个元组数组，每个元组表示一个点的x和y坐标。\n\n- 返回值: 任意两点之间的最短距离，四舍五入到小数点后四位。\n\n示例用法:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "fr": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nTrouve la distance la plus courte entre deux points quelconques dans un ensemble donné de points dans un plan 2D.\n\n- Paramètres :\n- points : Un tableau de tuples, où chaque tuple représente les coordonnées x et y d'un point.\n\n- Retourne : La distance la plus courte entre deux points quelconques, arrondie à quatre décimales.\n\nExemple d'utilisation :\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "de": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFindet die kürzeste Entfernung zwischen zwei beliebigen Punkten in einer gegebenen Menge von Punkten in einer 2D-Ebene.\n\n- Parameter:\n- points: Ein Array von Tupeln, wobei jedes Tupel die x- und y-Koordinaten eines Punktes darstellt.\n\n- Rückgabewert: Die kürzeste Entfernung zwischen zwei beliebigen Punkten, gerundet auf vier Dezimalstellen.\n\nBeispielverwendung:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "ha": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nNemi mafi kankantar nesa tsakanin kowanne maki biyu a cikin wani saitin maki a cikin faifan 2D.\n\n- Parameters:\n- points: Jeri na tuples, inda kowanne tuple ke wakiltar x da y daidaitattun wani maki.\n\n- Returns: Mafi kankantar nesa tsakanin kowanne maki biyu, an zagaye zuwa wurare hudu na goma.\n\nMisalin Amfani:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "hi": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nदिए गए बिंदुओं के सेट में किसी भी दो बिंदुओं के बीच की सबसे छोटी दूरी खोजता है, जो 2D प्लेन में होते हैं।\n\n- पैरामीटर्स:\n- points: ट्यूपल्स की एक array, जहाँ प्रत्येक ट्यूपल एक बिंदु के x और y निर्देशांक का प्रतिनिधित्व करता है।\n\n- रिटर्न्स: किसी भी दो बिंदुओं के बीच की सबसे छोटी दूरी, चार दशमलव स्थानों तक गोल की गई।\n\nउदाहरण उपयोग:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "hu": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nMegtalálja a legrövidebb távolságot bármely két pont között egy adott pontkészletben egy 2D síkon.\n\n- Paraméterek:\n- points: Egy tömb, ahol minden elem egy pár, amely egy pont x és y koordinátáit reprezentálja.\n\n- Visszatérési érték: A legrövidebb távolság bármely két pont között, négy tizedesjegyre kerekítve.\n\nPélda használat:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9801212700964095",
      "bn": "0.9924149016394207",
      "bg": "0.9822923001611208",
      "zh": "0.9720654177327774",
      "fr": "0.9950600624236623",
      "de": "0.9872229021095498",
      "ha": "0.9846128989027514",
      "hi": "0.9842269600724005",
      "hu": "0.978416624166368"
    },
    "canonical_solution": "guard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}",
    "instruction": {
      "en": "Write a Swift function `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` to solve the following problem:\n\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n",
      "sq": "Shkruani një funksion Swift `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` për të zgjidhur problemin e mëposhtëm:\n\nGjen distancën më të shkurtër midis çdo dy pikave në një grup të dhënë pikash në një plan 2D.\n\n- Parametrat:\n- points: Një varg me tufa, ku çdo tufë përfaqëson koordinatat x dhe y të një pike.\n\n- Kthen: Distanca më e shkurtër midis çdo dy pikave, e rrumbullakosur në katër vende dhjetore.\n\nShembull i Përdorimit:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hy": "Swift ֆունկցիա գրեք `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` հետևյալ խնդիրը լուծելու համար:\n\nԳտնում է ամենակարճ հեռավորությունը ցանկացած երկու կետի միջև տրված կետերի հավաքածուում 2D հարթությունում:\n\n- Պարամետրեր:\n- points: Թյուպլերի զանգված, որտեղ յուրաքանչյուր թյուպլը ներկայացնում է կետի x և y կոորդինատները:\n\n- Վերադարձնում է: Ամենակարճ հեռավորությունը ցանկացած երկու կետի միջև, կլորացված մինչև չորս տասնորդական թվանշան:\n\nՕրինակ օգտագործում:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "bn": "Swift ফাংশন `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nদেওয়া পয়েন্টগুলির একটি সেটে 2D প্লেনে যেকোনো দুটি পয়েন্টের মধ্যে সবচেয়ে কম দূরত্ব খুঁজে বের করে।\n\n- প্যারামিটারসমূহ:\n- points: একটি টুপলের অ্যারে, যেখানে প্রতিটি টুপল একটি পয়েন্টের x এবং y কোঅর্ডিনেট উপস্থাপন করে।\n\n- রিটার্নস: যেকোনো দুটি পয়েন্টের মধ্যে সবচেয়ে কম দূরত্ব, চার দশমিক স্থান পর্যন্ত রাউন্ড করা।\n\nউদাহরণ ব্যবহার:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "bg": "Напишете Swift функция `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` за решаване на следния проблем:\n\nНамира най-краткото разстояние между две точки в даден набор от точки в 2D равнина.\n\n- Параметри:\n- points: Масив от кортежи, където всеки кортеж представлява x и y координатите на точка.\n\n- Връща: Най-краткото разстояние между две точки, закръглено до четири знака след десетичната запетая.\n\nПример за използване:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "zh": "编写一个 Swift 函数 `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` 来解决以下问题：\n\n在给定的二维平面点集中，找到任意两点之间的最短距离。\n\n- 参数：\n- points: 一个元组数组，其中每个元组表示一个点的 x 和 y 坐标。\n\n- 返回值：任意两点之间的最短距离，四舍五入到小数点后四位。\n\n示例用法：\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "fr": "Écrire une fonction Swift `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` pour résoudre le problème suivant :\n\nTrouve la distance la plus courte entre deux points quelconques dans un ensemble donné de points dans un plan 2D.\n\n- Paramètres :\n- points : Un tableau de tuples, où chaque tuple représente les coordonnées x et y d'un point.\n\n- Renvoie : La distance la plus courte entre deux points, arrondie à quatre décimales.\n\nExemple d'utilisation :\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "de": "Schreiben Sie eine Swift-Funktion `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {`, um das folgende Problem zu lösen:\n\nFindet die kürzeste Entfernung zwischen zwei beliebigen Punkten in einer gegebenen Menge von Punkten in einer 2D-Ebene.\n\n- Parameter:\n- points: Ein Array von Tupeln, wobei jedes Tupel die x- und y-Koordinaten eines Punktes darstellt.\n\n- Rückgabe: Die kürzeste Entfernung zwischen zwei beliebigen Punkten, gerundet auf vier Dezimalstellen.\n\nBeispielverwendung:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "ha": "Rubuta aikin Swift `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` don warware matsalar mai zuwa:\n\nNemo mafi gajeren nesa tsakanin kowanne maki biyu a cikin saitin maki da aka bayar a cikin faifan 2D.\n\n- Sigogi:\n- points: Jerin tuples, inda kowanne tuple ke wakiltar x da y daidaitattun wani maki.\n\n- Komawa: Mafi gajeren nesa tsakanin kowanne maki biyu, an zagaye zuwa wurare hudu na goma.\n\nMisalin Amfani:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hi": "Swift फ़ंक्शन `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nदिए गए बिंदुओं के सेट में किसी भी दो बिंदुओं के बीच सबसे छोटी दूरी खोजें, जो 2D प्लेन में स्थित हैं।\n\n- पैरामीटर्स:\n- points: ट्यूपल्स की एक array, जहाँ प्रत्येक ट्यूपल एक बिंदु के x और y निर्देशांक का प्रतिनिधित्व करता है।\n\n- रिटर्न्स: किसी भी दो बिंदुओं के बीच सबसे छोटी दूरी, चार दशमलव स्थानों तक गोल की गई।\n\nउदाहरण उपयोग:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hu": "Írj egy Swift függvényt `func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {` a következő probléma megoldására:\n\nMegtalálja a legrövidebb távolságot bármely két pont között egy adott pontkészletben egy 2D síkon.\n\n- Paraméterek:\n- points: Egy tömb tuple-ökből, ahol minden tuple egy pont x és y koordinátáit képviseli.\n\n- Visszatér: A legrövidebb távolság bármely két pont között, négy tizedesjegyre kerekítve.\n\nPélda használat:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142"
    },
    "instruction_bertscore": {
      "sq": "0.9989738754515738",
      "hy": "0.9823423550171415",
      "bn": "0.977978246915424",
      "bg": "0.9850919953818075",
      "zh": "0.9841318161198849",
      "fr": "0.9903334538765561",
      "de": "0.9927019225400161",
      "ha": "0.9884971160038886",
      "hi": "0.9804613253087412",
      "hu": "0.9982764841837602"
    },
    "level": "hard",
    "test": "func check(_ findShortestDistanceAmongPoints: ([(Double, Double)]) -> Double) {\nassert(findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]) == 1.0000)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)]) == 1.4142)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (5.0, 5.0), (1.0, 6.0), (2.0, 1.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(2.0, 3.0), (4.0, 4.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(1.5, 1.5), (3.5, 3.5), (5.5, 5.5)]) == 2.8284)\n}\n\ncheck(findShortestDistanceAmongPoints)",
    "entry_point": "findShortestDistanceAmongPoints",
    "signature": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {",
    "docstring": {
      "en": "\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n",
      "sq": "Gjen distancën më të shkurtër midis çdo dy pikave në një grup të dhënë pikash në një plan 2D.\n\n- Parametra:\n- points: Një varg me tufa, ku secila tufë përfaqëson koordinatat x dhe y të një pike.\n\n- Kthen: Distanca më e shkurtër midis çdo dy pikave, e rrumbullakosur në katër vende dhjetore.\n\nShembull Përdorimi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hy": "Գտնում է ամենակարճ հեռավորությունը ցանկացած երկու կետերի միջև տրված կետերի հավաքածուում 2D հարթությունում:\n\n- Պարամետրեր:\n- points: Կրկնորդների զանգված, որտեղ յուրաքանչյուր կրկնորդ ներկայացնում է կետի x և y կոորդինատները:\n\n- Վերադարձնում է: Ամենակարճ հեռավորությունը ցանկացած երկու կետերի միջև, կլորացված մինչև չորս տասնորդական տեղ:\n\nՕրինակային օգտագործում:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "bn": "যেকোনো দুটি বিন্দুর মধ্যে সবচেয়ে ছোট দূরত্ব নির্ণয় করে একটি নির্দিষ্ট 2D প্লেনে বিন্দুগুলির সেটে।\n\n- প্যারামিটারসমূহ:\n- points: টুপলের একটি অ্যারে, যেখানে প্রতিটি টুপল একটি বিন্দুর x এবং y কোঅর্ডিনেট উপস্থাপন করে।\n\n- রিটার্ন করে: যেকোনো দুটি বিন্দুর মধ্যে সবচেয়ে ছোট দূরত্ব, চার দশমিক স্থান পর্যন্ত রাউন্ড করা।\n\nউদাহরণ ব্যবহার:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "bg": "Намира най-късото разстояние между две точки в даден набор от точки в 2D равнина.\n\n- Параметри:\n- points: Масив от кортежи, където всеки кортеж представлява x и y координатите на точка.\n\n- Връща: Най-късото разстояние между две точки, закръглено до четири десетични знака.\n\nПример за използване:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "zh": "在给定的二维平面点集中，找到任意两点之间的最短距离。\n\n- 参数：\n- points: 一个元组数组，其中每个元组表示一个点的 x 和 y 坐标。\n\n- 返回值：任意两点之间的最短距离，四舍五入到小数点后四位。\n\n示例用法：\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "fr": "Trouve la distance la plus courte entre deux points quelconques dans un ensemble donné de points dans un plan 2D.\n\n- Paramètres :\n- points : Un tableau de tuples, où chaque tuple représente les coordonnées x et y d'un point.\n\n- Retourne : La distance la plus courte entre deux points quelconques, arrondie à quatre décimales.\n\nExemple d'utilisation :\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "de": "Findet die kürzeste Entfernung zwischen zwei beliebigen Punkten in einer gegebenen Menge von Punkten in einer 2D-Ebene.\n\n- Parameter:\n- points: Ein Array von Tupeln, wobei jedes Tupel die x- und y-Koordinaten eines Punktes darstellt.\n\n- Rückgabewert: Die kürzeste Entfernung zwischen zwei beliebigen Punkten, gerundet auf vier Dezimalstellen.\n\nBeispielverwendung:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "ha": "Nemo mafi gajeren nesa tsakanin kowane maki biyu a cikin saitin maki da aka bayar a cikin filin 2D.\n\n- Sigogi:\n- points: Jeren tuples, inda kowane tuple ke wakiltar x da y daidaitattun maki.\n\n- Komawa: Mafi gajeren nesa tsakanin kowane maki biyu, an zagaye zuwa wurare hudu na goma.\n\nMisalin Amfani:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hi": "दिए गए बिंदुओं के सेट में किसी भी दो बिंदुओं के बीच की सबसे छोटी दूरी खोजता है।\n\n- पैरामीटर्स:\n- points: ट्यूपल्स की एक array, जहाँ प्रत्येक ट्यूपल एक बिंदु के x और y निर्देशांक का प्रतिनिधित्व करता है।\n\n- रिटर्न करता है: किसी भी दो बिंदुओं के बीच की सबसे छोटी दूरी, चार दशमलव स्थानों तक गोल की गई।\n\nउदाहरण उपयोग:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "hu": "Megtalálja a legrövidebb távolságot bármely két pont között egy adott pontkészletben egy 2D síkban.\n\n- Paraméterek:\n- points: Egy tömb, amelyben minden egyes elem egy x és y koordinátát tartalmazó pontot képvisel.\n\n- Visszatérési érték: A legrövidebb távolság bármely két pont között, négy tizedesjegyre kerekítve.\n\nPélda használat:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142"
    },
    "docstring_bertscore": {
      "sq": "0.9909905231770195",
      "hy": "0.9936110537940128",
      "bn": "0.9806746543379726",
      "bg": "0.988772417712003",
      "zh": "0.9678689536726534",
      "fr": "0.9873242036038776",
      "de": "0.9933860055723003",
      "ha": "0.9876314848033385",
      "hi": "0.9697140312820864",
      "hu": "0.9566215083465528"
    }
  },
  {
    "task_id": "Swift/37",
    "prompt": {
      "en": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "sq": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nNumëron numrin e mënyrave për të zgjedhur pjata nga një menu në mënyrë që kostoja totale\ntë përputhet saktësisht me një buxhet të dhënë. Çdo pjatë mund të zgjidhet vetëm një herë.\n\n- Parametrat:\n- dishes: Një varg me numra të plotë ku secili numër përfaqëson koston e një pjate.\n- budget: Një numër i plotë që përfaqëson buxhetin total për vaktin.\n- Kthen: Numri total i kombinimeve unike të pjatave që saktësisht arrijnë buxhetin.\n\n## Shembull:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "hy": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nՀաշվում է ուտեստների ընտրության եղանակների քանակը մենյուից այնպես, որ ընդհանուր արժեքը\nճշգրիտ համապատասխանի տրված բյուջեին։ Յուրաքանչյուր ուտեստ կարող է ընտրվել միայն մեկ անգամ։\n\n- Պարամետրեր:\n- dishes: Ամբողջ թվերի զանգված, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է ուտեստի արժեքը։\n- budget: Ամբողջ թիվ, որը ներկայացնում է ճաշի ընդհանուր բյուջեն։\n- Վերադարձնում է: Ուտեստների եզակի համակցությունների ընդհանուր քանակը, որոնք ճշգրիտ գումարվում են բյուջեին։\n\n## Օրինակ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "bn": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nখাবারের তালিকা থেকে খাবার বেছে নেওয়ার উপায়গুলির সংখ্যা গণনা করে যাতে মোট খরচ\nএকটি নির্দিষ্ট বাজেটের সাথে ঠিক মেলে। প্রতিটি খাবার শুধুমাত্র একবারই নির্বাচিত হতে পারে।\n\n- প্যারামিটার:\n- dishes: পূর্ণসংখ্যার একটি অ্যারে যেখানে প্রতিটি পূর্ণসংখ্যা একটি খাবারের খরচ উপস্থাপন করে।\n- budget: একটি পূর্ণসংখ্যা যা খাবারের জন্য মোট বাজেট উপস্থাপন করে।\n- রিটার্নস: খাবারের অনন্য সংমিশ্রণের মোট সংখ্যা যা ঠিক বাজেটের সমান হয়।\n\n## উদাহরণ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "bg": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nБрои броя на начините за избор на ястия от менюто така, че общата стойност\nда съвпада точно с даден бюджет. Всяко ястие може да бъде избрано само веднъж.\n\n- Параметри:\n- dishes: Масив от цели числа, където всяко число представлява цената на ястие.\n- budget: Цяло число, представляващо общия бюджет за храненето.\n- Връща: Общият брой уникални комбинации от ястия, които точно се равняват на бюджета.\n\n## Пример:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "zh": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\n计算从菜单中选择菜肴的方式数量，使得总成本正好符合给定的预算。每道菜只能选择一次。\n\n- 参数:\n- dishes: 一个整数数组，其中每个整数代表一道菜的成本。\n- budget: 一个整数，表示餐饮的总预算。\n- 返回: 总共有多少种独特的菜肴组合，其总和正好等于预算。\n\n## 示例:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "fr": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCompte le nombre de façons de choisir des plats dans un menu de sorte que le coût total\ncorresponde exactement à un budget donné. Chaque plat ne peut être sélectionné qu'une seule fois.\n\n- Paramètres:\n- dishes: Un tableau d'entiers où chaque entier représente le coût d'un plat.\n- budget: Un entier représentant le budget total pour le repas.\n- Retourne: Le nombre total de combinaisons uniques de plats qui totalisent exactement le budget.\n\n## Exemple:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "de": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nZählt die Anzahl der Möglichkeiten, Gerichte aus einem Menü auszuwählen, sodass die Gesamtkosten\ngenau einem vorgegebenen Budget entsprechen. Jedes Gericht kann nur einmal ausgewählt werden.\n\n- Parameter:\n- dishes: Ein Array von ganzen Zahlen, wobei jede Zahl die Kosten eines Gerichts darstellt.\n- budget: Eine ganze Zahl, die das Gesamtbudget für die Mahlzeit darstellt.\n- Rückgabewert: Die Gesamtanzahl der einzigartigen Kombinationen von Gerichten, die genau dem Budget entsprechen.\n\n## Beispiel:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "ha": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nYana ƙirga adadin hanyoyin zaɓar abinci daga menu ta yadda jimlar kuɗin\nya dace da kasafin kuɗi da aka bayar. Ana iya zaɓar kowanne abinci sau ɗaya kawai.\n\n- Sigogi:\n- dishes: Jeri na lambobi inda kowanne lamba ke wakiltar kuɗin abinci.\n- budget: Lamba da ke wakiltar jimlar kasafin kuɗi don abincin.\n- Returns: Jimlar adadin haɗuwa na musamman na abinci da suka dace da kasafin kuɗi.\n\n## Misali:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "hi": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nयह गणना करता है कि मेनू से व्यंजन चुनने के कितने तरीके हैं ताकि कुल लागत\nएक दिए गए बजट से बिल्कुल मेल खाती हो। प्रत्येक व्यंजन को केवल एक बार ही चुना जा सकता है।\n\n- Parameters:\n- dishes: पूर्णांकों की एक सूची जहां प्रत्येक पूर्णांक एक व्यंजन की लागत का प्रतिनिधित्व करता है।\n- budget: एक पूर्णांक जो भोजन के लिए कुल बजट का प्रतिनिधित्व करता है।\n- Returns: व्यंजनों के अद्वितीय संयोजनों की कुल संख्या जो बिल्कुल बजट के बराबर होती है।\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "hu": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nSzámolja meg, hányféleképpen lehet ételeket választani egy menüből úgy, hogy a teljes költség\npontosan megegyezzen egy adott költségvetéssel. Minden étel csak egyszer választható ki.\n\n- Paraméterek:\n- dishes: Egész számokat tartalmazó tömb, ahol minden egész szám egy étel költségét jelenti.\n- budget: Egy egész szám, amely az étkezés teljes költségvetését jelenti.\n- Visszatér: Az egyedi étel kombinációk teljes száma, amelyek pontosan a költségvetés összegét adják.\n\n## Példa:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9839099459842688",
      "hy": "0.9819476764500252",
      "bn": "0.9613467264809918",
      "bg": "0.9739104953422105",
      "zh": "0.9774127462206177",
      "fr": "0.988693362820351",
      "de": "0.9787052341100118",
      "ha": "0.9474197573147306",
      "hi": "0.9744456055887185",
      "hu": "0.9839264323058948"
    },
    "canonical_solution": "var dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}",
    "instruction": {
      "en": "Write a Swift function `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` to solve the following problem:\n\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n",
      "sq": "Shkruani një funksion Swift `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nNumëron numrin e mënyrave për të zgjedhur pjata nga një menu në mënyrë që kostoja totale\ntë përputhet saktësisht me një buxhet të dhënë. Çdo pjatë mund të zgjidhet vetëm një herë.\n\n- Parametrat:\n- dishes: Një varg i numrave të plotë ku secili numër përfaqëson koston e një pjate.\n- budget: Një numër i plotë që përfaqëson buxhetin total për vaktin.\n- Kthen: Numri total i kombinimeve unike të pjatave që saktësisht arrijnë buxhetin.\n\n## Shembull:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hy": "Գրեք Swift ֆունկցիա `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է եղանակների քանակը, որոնցով կարելի է ընտրել ուտեստներ մենյուից այնպես, որ ընդհանուր արժեքը\nճշգրիտ համապատասխանի տրված բյուջեին: Յուրաքանչյուր ուտեստ կարելի է ընտրել միայն մեկ անգամ:\n\n- Պարամետրեր:\n- dishes: Թվերի զանգված, որտեղ յուրաքանչյուր թիվ ներկայացնում է ուտեստի արժեքը:\n- budget: Թիվ, որը ներկայացնում է ճաշի ընդհանուր բյուջեն:\n- Վերադարձնում է: Ուտեստների եզակի համակցությունների ընդհանուր քանակը, որոնք ճշգրիտ գումարվում են բյուջեին:\n\n## Օրինակ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "bn": "একটি Swift ফাংশন `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি মেনু থেকে খাবার বাছাই করার উপায়গুলির সংখ্যা গণনা করে যাতে মোট খরচ একটি নির্দিষ্ট বাজেটের সাথে ঠিক মেলে। প্রতিটি খাবার শুধুমাত্র একবারই নির্বাচিত হতে পারে।\n\n- প্যারামিটারসমূহ:\n- dishes: পূর্ণসংখ্যার একটি অ্যারে যেখানে প্রতিটি পূর্ণসংখ্যা একটি খাবারের খরচ উপস্থাপন করে।\n- budget: একটি পূর্ণসংখ্যা যা খাবারের মোট বাজেটকে উপস্থাপন করে।\n- রিটার্নস: খাবারের মোট অনন্য সমন্বয়ের সংখ্যা যা ঠিক বাজেটের সমান হয়।\n\n## উদাহরণ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "bg": "Напишете Swift функция `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` за решаване на следния проблем:\n\nБрои броя на начините за избор на ястия от менюто така, че общата стойност\nда съвпада точно с даден бюджет. Всяко ястие може да бъде избрано само веднъж.\n\n- Параметри:\n- dishes: Масив от цели числа, където всяко число представлява цената на ястие.\n- budget: Цяло число, представляващо общия бюджет за храната.\n- Връща: Общият брой уникални комбинации от ястия, които точно съответстват на бюджета.\n\n## Пример:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "zh": "编写一个 Swift 函数 `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` 来解决以下问题：\n\n计算从菜单中选择菜品的方式数量，使得总费用恰好与给定预算匹配。每道菜只能选择一次。\n\n- 参数：\n- dishes: 一个整数数组，其中每个整数表示一道菜的费用。\n- budget: 一个整数，表示用餐的总预算。\n- 返回值：总共有多少种独特的菜品组合，其费用总和恰好等于预算。\n\n## 示例:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "fr": "Écrire une fonction Swift `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` pour résoudre le problème suivant :\n\nCompte le nombre de façons de choisir des plats dans un menu de sorte que le coût total corresponde exactement à un budget donné. Chaque plat ne peut être sélectionné qu'une seule fois.\n\n- Paramètres :\n- dishes: Un tableau d'entiers où chaque entier représente le coût d'un plat.\n- budget: Un entier représentant le budget total pour le repas.\n- Renvoie : Le nombre total de combinaisons uniques de plats qui s'additionnent exactement au budget.\n\n## Exemple :\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "de": "Schreiben Sie eine Swift-Funktion `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {`, um das folgende Problem zu lösen:\n\nZählt die Anzahl der Möglichkeiten, Gerichte aus einem Menü auszuwählen, sodass die Gesamtkosten\ngenau einem gegebenen Budget entsprechen. Jedes Gericht kann nur einmal ausgewählt werden.\n\n- Parameter:\n- dishes: Ein Array von ganzen Zahlen, wobei jede Zahl die Kosten eines Gerichts darstellt.\n- budget: Eine ganze Zahl, die das Gesamtbudget für das Essen darstellt.\n- Rückgabe: Die Gesamtanzahl der einzigartigen Kombinationen von Gerichten, die genau dem Budget entsprechen.\n\n## Beispiel:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "ha": "Rubuta aikin Swift `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` don warware matsalar mai zuwa:\n\nYana ƙididdige yawan hanyoyin zaɓar abinci daga menu ta yadda jimlar kuɗin\nya dace da kasafin kuɗi da aka bayar. Ana iya zaɓar kowanne abinci sau ɗaya kawai.\n\n- Sigogi:\n- dishes: Jerin lambobi inda kowanne lamba ke wakiltar farashin abinci.\n- budget: Lamba mai wakiltar jimlar kasafin kuɗi don abincin.\n- Returns: Jimlar yawan haɗin abinci na musamman da suka dace da kasafin kuɗi.\n\n## Misali:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hi": "Swift फ़ंक्शन `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nयह गणना करता है कि मेनू से व्यंजन चुनने के कितने तरीके हैं ताकि कुल लागत\nएक दिए गए बजट के साथ बिल्कुल मेल खाती हो। प्रत्येक व्यंजन को केवल एक बार ही चुना जा सकता है।\n\n- पैरामीटर्स:\n- dishes: पूर्णांकों की एक array जहाँ प्रत्येक पूर्णांक एक व्यंजन की लागत को दर्शाता है।\n- budget: एक पूर्णांक जो भोजन के लिए कुल बजट का प्रतिनिधित्व करता है।\n- Returns: व्यंजनों के अद्वितीय संयोजनों की कुल संख्या जो बजट के बराबर होती है।\n\n## उदाहरण:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hu": "Írj egy Swift függvényt `func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {` a következő probléma megoldására:\n\nSzámolja meg, hányféleképpen lehet választani ételeket egy menüből úgy, hogy a teljes költség pontosan megegyezzen egy adott költségvetéssel. Minden étel csak egyszer választható ki.\n\n- Paraméterek:\n- dishes: Egész számokat tartalmazó tömb, ahol minden egész szám egy étel költségét jelenti.\n- budget: Egy egész szám, amely az étkezés teljes költségvetését jelenti.\n- Visszatérési érték: Az ételek olyan egyedi kombinációinak teljes száma, amelyek pontosan a költségvetés összegét adják.\n\n## Példa:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]"
    },
    "instruction_bertscore": {
      "sq": "0.9815204225004192",
      "hy": "0.9691757429494819",
      "bn": "0.9758127785013817",
      "bg": "0.9744346809177616",
      "zh": "0.967006897818962",
      "fr": "0.9898845492154172",
      "de": "0.986227763900565",
      "ha": "0.9444706920475057",
      "hi": "0.9613723498001453",
      "hu": "0.9858275236827797"
    },
    "level": "easy",
    "test": "func check(_ countMealCombinations: ([Int], Int) -> Int) {\nassert(countMealCombinations([1, 2, 3], 4) == 1)\nassert(countMealCombinations([1, 1, 3, 4, 5], 5) == 4)\nassert(countMealCombinations([2, 2, 2, 2], 8) == 1)\nassert(countMealCombinations([1, 1, 1, 1, 1], 3) == 10)\nassert(countMealCombinations([5, 5, 5, 5, 5], 10) == 10)\nassert(countMealCombinations([10, 15, 20], 25) == 1)\nassert(countMealCombinations([1, 3, 4, 6], 9) == 1)\n}\n\ncheck(countMealCombinations)",
    "entry_point": "countMealCombinations",
    "signature": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {",
    "docstring": {
      "en": "\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n",
      "sq": "Numëron numrin e mënyrave për të zgjedhur pjata nga një menu në mënyrë që kostoja totale të përputhet saktësisht me një buxhet të caktuar. Çdo pjatë mund të zgjidhet vetëm një herë.\n\n- Parametrat:\n- dishes: Një varg me numra të plotë ku secili numër përfaqëson koston e një pjate.\n- budget: Një numër i plotë që përfaqëson buxhetin total për vaktin.\n- Kthen: Numri total i kombinimeve unike të pjatave që saktësisht arrijnë buxhetin.\n\n## Shembull:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hy": "Հաշվում է ուտեստների ընտրության եղանակների քանակը մենյուից այնպես, որ ընդհանուր արժեքը\nճշգրիտ համապատասխանի տրված բյուջեին։ Յուրաքանչյուր ուտեստ կարող է ընտրվել միայն մեկ անգամ։\n\n- Պարամետրեր:\n- dishes: Թվերի զանգված, որտեղ յուրաքանչյուր թիվ ներկայացնում է ուտեստի արժեքը։\n- budget: Թիվ, որը ներկայացնում է ճաշի ընդհանուր բյուջեն։\n- Վերադարձնում է: Ուտեստների եզակի համակցությունների ընդհանուր քանակը, որոնք ճշգրիտ գումարվում են բյուջեին։\n\n## Օրինակ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "bn": "খাবারের মেনু থেকে খাবার বাছাই করার উপায়গুলির সংখ্যা গণনা করে যাতে মোট খরচ একটি নির্দিষ্ট বাজেটের সাথে সঠিকভাবে মেলে। প্রতিটি খাবার শুধুমাত্র একবারই নির্বাচিত হতে পারে।\n\n- প্যারামিটার:\n- dishes: পূর্ণসংখ্যার একটি অ্যারে যেখানে প্রতিটি পূর্ণসংখ্যা একটি খাবারের খরচ উপস্থাপন করে।\n- budget: একটি পূর্ণসংখ্যা যা খাবারের জন্য মোট বাজেট উপস্থাপন করে।\n- রিটার্ন: খাবারের অনন্য সমন্বয়ের মোট সংখ্যা যা সঠিকভাবে বাজেটের সমান হয়।\n\n## উদাহরণ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "bg": "Брои броя начини за избор на ястия от меню, така че общата цена\nда съвпада точно с даден бюджет. Всяко ястие може да бъде избрано само веднъж.\n\n- Параметри:\n- dishes: Масив от цели числа, където всяко цяло число представлява цената на ястие.\n- budget: Цяло число, представляващо общия бюджет за храненето.\n- Връща: Общият брой уникални комбинации от ястия, които точно съответстват на бюджета.\n\n## Пример:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "zh": "计算从菜单中选择菜品的方式数量，使得总成本正好与给定预算匹配。每道菜只能选择一次。\n\n- 参数:\n- dishes: 一个整数数组，其中每个整数表示一道菜的成本。\n- budget: 一个整数，表示餐点的总预算。\n- 返回: 正好总和为预算的菜品独特组合的总数量。\n\n## 示例:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "fr": "Compte le nombre de façons de choisir des plats dans un menu de sorte que le coût total corresponde exactement à un budget donné. Chaque plat ne peut être sélectionné qu'une seule fois.\n\n- Paramètres:\n- dishes: Un tableau d'entiers où chaque entier représente le coût d'un plat.\n- budget: Un entier représentant le budget total pour le repas.\n- Retourne: Le nombre total de combinaisons uniques de plats qui totalisent exactement le budget.\n\n## Exemple:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "de": "Zählt die Anzahl der Möglichkeiten, Gerichte aus einem Menü auszuwählen, sodass die Gesamtkosten genau einem gegebenen Budget entsprechen. Jedes Gericht kann nur einmal ausgewählt werden.\n\n- Parameter:\n- dishes: Ein Array von ganzen Zahlen, wobei jede Zahl die Kosten eines Gerichts darstellt.\n- budget: Eine ganze Zahl, die das Gesamtbudget für die Mahlzeit darstellt.\n- Rückgabewert: Die Gesamtanzahl der eindeutigen Kombinationen von Gerichten, die genau dem Budget entsprechen.\n\n## Beispiel:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "ha": "Yana ƙididdige adadin hanyoyin zaɓar abinci daga menu ta yadda jimillar kuɗin\nya dace da kasafin kuɗi da aka bayar. Ana iya zaɓar kowanne abinci sau ɗaya kawai.\n\n- Sigogi:\n- dishes: Jeri na lambobi inda kowane lamba ke wakiltar farashin abinci.\n- budget: Lamba mai wakiltar jimillar kasafin kuɗi don abincin.\n- Returns: Jimillar adadin haɗin abinci na musamman waɗanda suka dace da kasafin kuɗi.\n\n## Misali:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hi": "दिए गए बजट से पूरी तरह मेल खाने वाली कुल लागत के साथ मेनू से व्यंजन चुनने के तरीकों की संख्या गिनता है। प्रत्येक व्यंजन को केवल एक बार ही चुना जा सकता है।\n\n- पैरामीटर्स:\n- dishes: पूर्णांकों की एक श्रृंखला जहां प्रत्येक पूर्णांक एक व्यंजन की लागत का प्रतिनिधित्व करता है।\n- budget: एक पूर्णांक जो भोजन के लिए कुल बजट का प्रतिनिधित्व करता है।\n- रिटर्न करता है: व्यंजनों के अद्वितीय संयोजनों की कुल संख्या जो बजट के साथ पूरी तरह मेल खाती है।\n\n## उदाहरण:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "hu": "Számolja meg, hányféleképpen lehet ételeket választani egy étlapról úgy, hogy a teljes költség pontosan megegyezzen egy adott költségvetéssel. Minden ételt csak egyszer lehet kiválasztani.\n\n- Paraméterek:\n- dishes: Egy egész számokat tartalmazó tömb, ahol minden egész szám egy étel költségét jelenti.\n- budget: Egy egész szám, amely az étkezés teljes költségvetését jelenti.\n- Visszatér: Az ételek azon egyedi kombinációinak teljes száma, amelyek pontosan összeadják a költségvetést.\n\n## Példa:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.9819822381363253",
      "hy": "0.9682556870245284",
      "bn": "0.9698751205211058",
      "bg": "0.9802982497659115",
      "zh": "0.9732891795103334",
      "fr": "0.9827255130221578",
      "de": "0.9777116849440752",
      "ha": "0.9215829105016176",
      "hi": "0.9655976152655195",
      "hu": "0.9850822624931368"
    }
  },
  {
    "task_id": "Swift/38",
    "prompt": {
      "en": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "sq": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nLlogarit kohën më të vonshme kur yyy mund të niset për në shkollë pa u vonuar. \nShkolla është 'distance' metra larg, dhe yyy ecën me një shpejtësi prej 'speed' metra për minutë. \nPër më tepër, yyy shpenzon 10 minuta shtesë për ndarjen e mbeturinave gjatë rrugës.\n\nShkolla kërkon mbërritjen deri në orën 08:00 të mëngjesit. Kjo funksion kthen kohën më të vonshme të nisjes në formatin HH:MM.\n\nShembuj:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "hy": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nՀաշվում է ամենաուշ ժամանակը, երբ yyy կարող է դուրս գալ դպրոց առանց ուշանալու։ \nԴպրոցը գտնվում է 'distance' մետր հեռավորության վրա, և yyy քայլում է 'speed' մետր րոպեում արագությամբ։ \nԲացի այդ, yyy ծախսում է լրացուցիչ 10 րոպե աղբի տեսակավորման համար ճանապարհին։\n\nԴպրոցը պահանջում է ժամանել մինչև 08:00։ Այս ֆունկցիան վերադարձնում է ամենաուշ դուրս գալու ժամը HH:MM ձևաչափով։\n\nՕրինակներ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "bn": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nস্কুলে দেরি না করে পৌঁছানোর জন্য yyy সর্বশেষ কখন রওনা দিতে পারে তা গণনা করে। \nস্কুলটি 'distance' মিটার দূরে এবং yyy 'speed' মিটার প্রতি মিনিটে হাঁটে। \nঅতিরিক্তভাবে, yyy পথে আবর্জনা বাছাইয়ের জন্য অতিরিক্ত 10 মিনিট ব্যয় করে।\n\nস্কুলে পৌঁছানোর সময় 08:00 AM এর মধ্যে হওয়া প্রয়োজন। এই ফাংশনটি HH:MM ফরম্যাটে সর্বশেষ রওনা দেওয়ার সময় প্রদান করে।\n\nউদাহরণ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "bg": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nИзчислява най-късното време, в което yyy може да тръгне за училище, без да закъснее.\nУчилището е на 'distance' метра разстояние, а yyy ходи със скорост 'speed' метра в минута.\nОсвен това, yyy прекарва допълнителни 10 минути за сортиране на боклук по пътя.\n\nУчилището изисква пристигане до 08:00 ч. Тази функция връща най-късното време за тръгване във формат HH:MM.\n\nПримери:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "zh": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\n计算yyy可以不迟到去上学的最晚出发时间。\n学校距离为'distance'米，yyy以'speed'米每分钟的速度行走。\n另外，yyy在路上花费额外的10分钟进行垃圾分类。\n\n学校要求在上午08:00之前到达。此函数返回最晚出发时间，格式为HH:MM。\n\n示例:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "fr": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalcule l'heure la plus tardive à laquelle yyy peut partir pour l'école sans être en retard. \nL'école est à 'distance' mètres, et yyy marche à une vitesse de 'speed' mètres par minute. \nDe plus, yyy passe 10 minutes supplémentaires pour le tri des déchets en chemin.\n\nL'école exige une arrivée avant 08:00 AM. Cette fonction renvoie l'heure de départ la plus tardive au format HH:MM.\n\nExemples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "de": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nBerechnet die späteste Zeit, zu der yyy zur Schule aufbrechen kann, ohne zu spät zu kommen. \nDie Schule ist 'distance' Meter entfernt, und yyy geht mit einer Geschwindigkeit von 'speed' Metern pro Minute. \nZusätzlich verbringt yyy 10 Minuten mit der Mülltrennung auf dem Weg.\n\nDie Schule erfordert die Ankunft bis 08:00 Uhr. Diese Funktion gibt die späteste Abfahrtszeit im HH:MM-Format zurück.\n\nBeispiele:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "ha": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nYana lissafin mafi ƙarancin lokacin da yyy zai iya fita zuwa makaranta ba tare da makara ba.\nMakarantar tana nesa da 'distance' mita, kuma yyy yana tafiya da saurin 'speed' mita a minti daya.\nBugu da kari, yyy yana shafe karin minti 10 don tsara shara a hanya.\n\nMakarantar tana buƙatar isowa kafin karfe 08:00 na safe. Wannan aikin yana dawowa da mafi ƙarancin lokacin fita a tsarin HH:MM.\n\nMisalai:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "hi": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nस्कूल के लिए yyy के बिना देर किए निकलने का सबसे देर का समय गणना करता है।\nस्कूल 'distance' मीटर दूर है, और yyy 'speed' मीटर प्रति मिनट की गति से चलता है।\nअतिरिक्त रूप से, yyy रास्ते में कचरा छांटने में 10 मिनट अतिरिक्त खर्च करता है।\n\nस्कूल में 08:00 AM तक पहुंचना आवश्यक है। यह फ़ंक्शन HH:MM प्रारूप में सबसे देर का प्रस्थान समय लौटाता है।\n\nउदाहरण:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "hu": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nKiszámítja a legkésőbbi időpontot, amikor yyy elindulhat az iskolába anélkül, hogy elkésne. \nAz iskola 'distance' méterre van, és yyy 'speed' méter per perc sebességgel sétál. \nEzenkívül yyy további 10 percet tölt szemétválogatással útközben.\n\nAz iskola megköveteli, hogy 08:00 órára érkezzen. Ez a függvény a legkésőbbi indulási időt adja vissza HH:MM formátumban.\n\nPéldák:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9799989137816919",
      "hy": "0.9825246977069316",
      "bn": "0.9502627539584829",
      "bg": "0.9845676111758754",
      "zh": "0.9734018029363802",
      "fr": "0.9833142534715452",
      "de": "0.9791598990522006",
      "ha": "0.9761011898146443",
      "hi": "0.9672279734330538",
      "hu": "0.9842297408977351"
    },
    "canonical_solution": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}",
    "instruction": {
      "en": "Write a Swift function `func latestDepartureTime(distance: Int, speed: Int) -> String {` to solve the following problem:\n\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n",
      "sq": "Shkruani një funksion Swift `func latestDepartureTime(distance: Int, speed: Int) -> String {` për të zgjidhur problemin e mëposhtëm:\n\nLlogarit kohën më të fundit kur yyy mund të niset për në shkollë pa u vonuar. \nShkolla është 'distance' metra larg, dhe yyy ecën me një shpejtësi prej 'speed' metra për minutë. \nPër më tepër, yyy shpenzon 10 minuta shtesë për ndarjen e mbeturinave gjatë rrugës.\n\nShkolla kërkon mbërritjen deri në orën 08:00 të mëngjesit. Ky funksion kthen kohën më të fundit të nisjes në formatin HH:MM.\n\nShembuj:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hy": "Գրեք Swift ֆունկցիա `func latestDepartureTime(distance: Int, speed: Int) -> String {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է ամենաուշ ժամանակը, երբ yyy կարող է դուրս գալ դպրոց առանց ուշանալու:\nԴպրոցը 'distance' մետր հեռավորության վրա է, և yyy քայլում է 'speed' մետր րոպեում արագությամբ:\nԲացի այդ, yyy ծախսում է լրացուցիչ 10 րոպե աղբի տեսակավորման համար ճանապարհին:\n\nԴպրոցը պահանջում է ժամանում 08:00-ից առաջ: Այս ֆունկցիան վերադարձնում է ամենաուշ դուրս գալու ժամը HH:MM ձևաչափով:\n\nՕրինակներ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "bn": "একটি Swift ফাংশন `func latestDepartureTime(distance: Int, speed: Int) -> String {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nগণনা করে কখন yyy স্কুলের জন্য দেরি না করে সর্বশেষ সময়ে রওনা হতে পারে। \nস্কুলটি 'distance' মিটার দূরে অবস্থিত, এবং yyy প্রতি মিনিটে 'speed' মিটার গতিতে হাঁটে। \nঅতিরিক্তভাবে, yyy পথে আবর্জনা বাছাইয়ের জন্য ১০ মিনিট অতিরিক্ত সময় ব্যয় করে।\n\nস্কুলে পৌঁছানোর সময় ০৮:০০ এএম এর মধ্যে হওয়া প্রয়োজন। এই ফাংশনটি সর্বশেষ রওনা হওয়ার সময় HH:MM ফরম্যাটে ফেরত দেয়।\n\nউদাহরণ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "bg": "Напишете Swift функция `func latestDepartureTime(distance: Int, speed: Int) -> String {` за решаване на следния проблем:\n\nИзчислява най-късното време, в което yyy може да тръгне за училище, без да закъснее. \nУчилището е на 'distance' метра разстояние, а yyy ходи със скорост 'speed' метра в минута. \nОсвен това, yyy прекарва допълнителни 10 минути за сортиране на боклука по пътя.\n\nУчилището изисква пристигане до 08:00 ч. Тази функция връща най-късното време за тръгване във формат HH:MM.\n\nПримери:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "zh": "编写一个 Swift 函数 `func latestDepartureTime(distance: Int, speed: Int) -> String {` 来解决以下问题：\n\n计算 yyy 可以不迟到去上学的最晚出发时间。学校距离为 'distance' 米，yyy 以 'speed' 米每分钟的速度行走。此外，yyy 在路上花费额外的 10 分钟进行垃圾分类。\n\n学校要求在上午 08:00 到达。此函数返回最晚出发时间，格式为 HH:MM。\n\n示例：\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "fr": "Écrire une fonction Swift `func latestDepartureTime(distance: Int, speed: Int) -> String {` pour résoudre le problème suivant :\n\nCalcule l'heure la plus tardive à laquelle yyy peut partir pour l'école sans être en retard. \nL'école est à 'distance' mètres, et yyy marche à une vitesse de 'speed' mètres par minute. \nDe plus, yyy passe 10 minutes supplémentaires pour le tri des déchets en chemin.\n\nL'école exige une arrivée avant 08:00 AM. Cette fonction retourne l'heure de départ la plus tardive au format HH:MM.\n\nExemples :\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "de": "Schreiben Sie eine Swift-Funktion `func latestDepartureTime(distance: Int, speed: Int) -> String {`, um das folgende Problem zu lösen:\n\nBerechnet die späteste Zeit, zu der yyy zur Schule aufbrechen kann, ohne zu spät zu kommen. \nDie Schule ist 'distance' Meter entfernt, und yyy geht mit einer Geschwindigkeit von 'speed' Metern pro Minute. \nZusätzlich verbringt yyy 10 Minuten mit der Mülltrennung auf dem Weg.\n\nDie Schule erfordert eine Ankunft bis 08:00 Uhr. Diese Funktion gibt die späteste Abfahrtszeit im HH:MM-Format zurück.\n\nBeispiele:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "ha": "Rubuta aikin Swift `func latestDepartureTime(distance: Int, speed: Int) -> String {` don warware matsalar mai zuwa:\n\nLissafi ne na lokacin mafi kusa da yyy zai iya tashi zuwa makaranta ba tare da yin latti ba. \nMakarantar tana da nisan 'distance' mita, kuma yyy yana tafiya da saurin 'speed' mita a minti daya. \nBugu da ƙari, yyy yana ƙara minti 10 don rarraba shara a hanya.\n\nMakaranta tana buƙatar isa kafin 08:00 na safe. Wannan aikin yana dawo da lokacin tashi mafi kusa a cikin tsarin HH:MM.\n\nMisalai:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hi": "Swift फ़ंक्शन `func latestDepartureTime(distance: Int, speed: Int) -> String {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nगणना करता है कि yyy स्कूल के लिए बिना देर किए सबसे देर से कब निकल सकता है। \nस्कूल 'distance' मीटर दूर है, और yyy 'speed' मीटर प्रति मिनट की गति से चलता है। \nइसके अतिरिक्त, yyy रास्ते में कचरा छांटने के लिए 10 मिनट अतिरिक्त खर्च करता है।\n\nस्कूल में 08:00 AM तक पहुंचना आवश्यक है। यह फ़ंक्शन HH:MM प्रारूप में सबसे देर से प्रस्थान का समय लौटाता है।\n\nउदाहरण:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hu": "Írj egy Swift függvényt `func latestDepartureTime(distance: Int, speed: Int) -> String {` a következő probléma megoldására:\n\nKiszámítja, hogy yyy legkésőbb mikor indulhat el az iskolába anélkül, hogy elkésne. \nAz iskola 'distance' méterre van, és yyy 'speed' méter/perc sebességgel sétál. \nEzenkívül yyy további 10 percet tölt a szemét válogatásával útközben.\n\nAz iskolába 08:00 órára kell megérkezni. Ez a függvény visszaadja a legkésőbbi indulási időt HH:MM formátumban.\n\nPéldák:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\""
    },
    "instruction_bertscore": {
      "sq": "0.9748089005556313",
      "hy": "0.9849616938518486",
      "bn": "0.9616013706294785",
      "bg": "0.9848341731472242",
      "zh": "0.9744104480112754",
      "fr": "0.9783073774567989",
      "de": "0.984383282182275",
      "ha": "0.9595820941758778",
      "hi": "0.9456646592679063",
      "hu": "0.9719361093547237"
    },
    "level": "hard",
    "test": "func check(_ latestDepartureTime: (Int, Int) -> String) {\nassert(latestDepartureTime(100, 10) == \"07:40\")\nassert(latestDepartureTime(50, 25) == \"07:48\")\nassert(latestDepartureTime(120, 60) == \"07:48\")\nassert(latestDepartureTime(80, 20) == \"07:46\")\nassert(latestDepartureTime(200, 40) == \"07:45\")\nassert(latestDepartureTime(90, 30) == \"07:47\")\n}\n\ncheck(latestDepartureTime)",
    "entry_point": "latestDepartureTime",
    "signature": "func latestDepartureTime(distance: Int, speed: Int) -> String {",
    "docstring": {
      "en": "\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n",
      "sq": "Llogarit kohën më të fundit kur yyy mund të niset për në shkollë pa u vonuar. \nShkolla është 'distance' metra larg dhe yyy ecën me një shpejtësi prej 'speed' metra për minutë. \nPër më tepër, yyy kalon 10 minuta shtesë për ndarjen e mbeturinave gjatë rrugës.\n\nShkolla kërkon mbërritjen deri në orën 08:00 të mëngjesit. Kjo funksion kthen kohën më të fundit të nisjes në formatin HH:MM.\n\nShembuj:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hy": "Հաշվում է ամենավերջին ժամանակը, երբ yyy-ն կարող է դուրս գալ դպրոց, առանց ուշանալու։ \nԴպրոցը գտնվում է 'distance' մետր հեռավորության վրա, և yyy-ն քայլում է 'speed' մետր րոպեում արագությամբ։ \nԲացի այդ, yyy-ն ծախսում է լրացուցիչ 10 րոպե աղբի տեսակավորման համար ճանապարհին։\n\nԴպրոցը պահանջում է ժամանել մինչև 08:00։ Այս ֆունկցիան վերադարձնում է ամենավերջին դուրս գալու ժամանակը HH:MM ձևաչափով։\n\nՕրինակներ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "bn": "স্কুলে দেরি না করে yyy কখন সর্বশেষ বের হতে পারে তা গণনা করে। \nস্কুলটি 'distance' মিটার দূরে, এবং yyy 'speed' মিটার প্রতি মিনিট গতিতে হাঁটে। \nঅতিরিক্তভাবে, yyy পথে আবর্জনা বাছাই করার জন্য ১০ মিনিট অতিরিক্ত সময় ব্যয় করে।\n\nস্কুলে পৌঁছানোর সময় ০৮:০০ AM এর মধ্যে হওয়া প্রয়োজন। এই ফাংশনটি HH:MM ফরম্যাটে সর্বশেষ প্রস্থানের সময় ফেরত দেয়।\n\nউদাহরণ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "bg": "Изчислява най-късното време, в което yyy може да тръгне за училище, без да закъснее. \nУчилището е на 'distance' метра разстояние, а yyy ходи със скорост 'speed' метра в минута. \nОсвен това, yyy прекарва допълнителни 10 минути за сортиране на боклука по пътя.\n\nУчилището изисква пристигане до 08:00 ч. Тази функция връща най-късното време на тръгване във формат HH:MM.\n\nПримери:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "zh": "计算yyy可以不迟到地离开去学校的最晚时间。  \n学校距离为'distance'米，yyy以'speed'米每分钟的速度行走。  \n此外，yyy在路上还需要额外花费10分钟进行垃圾分类。\n\n学校要求在上午08:00前到达。此函数返回最晚出发时间，格式为HH:MM。\n\n示例：\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "fr": "Calcule l'heure la plus tardive à laquelle yyy peut partir pour l'école sans être en retard. \nL'école est à 'distance' mètres, et yyy marche à une vitesse de 'speed' mètres par minute. \nDe plus, yyy passe 10 minutes supplémentaires pour le tri des déchets en chemin.\n\nL'école exige une arrivée avant 08:00. Cette fonction renvoie l'heure de départ la plus tardive au format HH:MM.\n\nExemples :\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "de": "Berechnet die späteste Zeit, zu der yyy zur Schule aufbrechen kann, ohne zu spät zu kommen. \nDie Schule ist 'distance' Meter entfernt, und yyy geht mit einer Geschwindigkeit von 'speed' Metern pro Minute. \nZusätzlich verbringt yyy 10 Minuten mit der Mülltrennung auf dem Weg.\n\nDie Schule erfordert eine Ankunft bis 08:00 Uhr. Diese Funktion gibt die späteste Abfahrtszeit im HH:MM-Format zurück.\n\nBeispiele:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "ha": "Yana lissafin mafi ƙarancin lokaci da yyy zai iya fita zuwa makaranta ba tare da makara ba. \nMakarantar tana da nisan 'distance' mita, kuma yyy yana tafiya da gudun 'speed' mita a minti daya. \nBugu da ƙari, yyy yana ɗaukar ƙarin mintuna 10 don rarraba shara a hanya.\n\nMakarantar tana buƙatar isowa kafin 08:00 na safe. Wannan aikin yana mayar da mafi ƙarancin lokacin fita a tsarin HH:MM.\n\nMisalai:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hi": "स्कूल के लिए yyy के देर न होने के लिए सबसे देर से निकलने का समय गणना करता है। \nस्कूल 'distance' मीटर दूर है, और yyy 'speed' मीटर प्रति मिनट की गति से चलता है। \nइसके अतिरिक्त, yyy रास्ते में कचरा छांटने में 10 मिनट अतिरिक्त खर्च करता है।\n\nस्कूल में 08:00 AM तक पहुंचने की आवश्यकता होती है। यह फ़ंक्शन HH:MM प्रारूप में सबसे देर से प्रस्थान का समय लौटाता है।\n\nउदाहरण:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "hu": "Kiszámítja, hogy yyy legkésőbb mikor indulhat el az iskolába anélkül, hogy elkésne. \nAz iskola 'distance' méterre van, és yyy 'speed' méter/perc sebességgel sétál. \nEzenkívül yyy további 10 percet tölt szemétválogatással útközben.\n\nAz iskolába 08:00 óráig kell megérkezni. Ez a függvény a legkésőbbi indulási időt adja vissza HH:MM formátumban.\n\nPéldák:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\""
    },
    "docstring_bertscore": {
      "sq": "0.9706577242223832",
      "hy": "0.982270649449588",
      "bn": "0.9475844219006085",
      "bg": "0.9813446346132033",
      "zh": "0.9743303999677183",
      "fr": "0.9681275704287609",
      "de": "0.9813809839729327",
      "ha": "0.9637265170761707",
      "hi": "0.9556561646947233",
      "hu": "0.9724163976160661"
    }
  },
  {
    "task_id": "Swift/39",
    "prompt": {
      "en": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "sq": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nLlogarit rezultatin përfundimtar për një garues duke hequr pikët më të larta dhe më të ulëta nga\nvargu i dhënë i pikëve dhe pastaj llogarit mesataren e pikëve të mbetura.\nRezultati është i rrumbullakosur në dy vende dhjetore.\n\n- Parametrat:\n- scores: Një varg i `Double` që përfaqëson pikët e dhëna nga secili gjyqtar.\n\n- Kthen: Një `Double` që përfaqëson rezultatin përfundimtar të garuesit, i rrumbullakosur në dy vende dhjetore.\n\nShembuj:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "hy": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nՀաշվում է մասնակիցի վերջնական միավորը՝ հեռացնելով ամենաբարձր և ամենացածր միավորները\nտրված միավորների զանգվածից, այնուհետև հաշվում է մնացած միավորների միջին արժեքը։\nԱրդյունքը կլորացվում է մինչև երկու տասնորդական նշան:\n\n- Պարամետրեր:\n- scores: `Double`-ի զանգված, որը ներկայացնում է յուրաքանչյուր դատավորի տված միավորները։\n\n- Վերադարձնում է: `Double`, որը ներկայացնում է մասնակիցի վերջնական միավորը, կլորացված մինչև երկու տասնորդական նշան:\n\nՕրինակներ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "bn": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nএকজন প্রতিযোগীর জন্য চূড়ান্ত স্কোর গণনা করে সর্বোচ্চ এবং সর্বনিম্ন স্কোরগুলি সরিয়ে দিয়ে \nপ্রদত্ত স্কোরের অ্যারে থেকে এবং তারপর অবশিষ্ট স্কোরগুলির গড় গণনা করে। \nফলাফলটি দুই দশমিক স্থান পর্যন্ত রাউন্ড করা হয়।\n\n- প্যারামিটার:\n- scores: প্রতিটি বিচারকের দেওয়া স্কোরের প্রতিনিধিত্বকারী `Double` এর একটি অ্যারে।\n\n- রিটার্নস: প্রতিযোগীর চূড়ান্ত স্কোরের প্রতিনিধিত্বকারী একটি `Double`, যা দুই দশমিক স্থান পর্যন্ত রাউন্ড করা হয়।\n\nউদাহরণ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "bg": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nИзчислява крайната оценка за участник, като премахва най-високата и най-ниската оценка от\nдадения масив от оценки и след това изчислява средната стойност на останалите оценки.\nРезултатът се закръгля до два знака след десетичната запетая.\n\n- Параметри:\n- scores: Масив от `Double`, представляващ оценките, дадени от всеки съдия.\n\n- Връща: `Double`, представляващ крайната оценка на участника, закръглена до два знака след десетичната запетая.\n\nПримери:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "zh": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\n计算参赛者的最终得分，通过从给定的分数数组中去掉最高分和最低分，然后计算剩余分数的平均值。\n结果四舍五入到小数点后两位。\n\n- 参数:\n- scores: 一个 `Double` 数组，表示每位评委给出的分数。\n\n- 返回: 一个 `Double`，表示参赛者的最终得分，四舍五入到小数点后两位。\n\n示例:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "fr": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalcule le score final pour un concurrent en supprimant les scores les plus élevés et les plus bas du\ntableau de scores donné, puis en calculant la moyenne des scores restants.\nLe résultat est arrondi à deux décimales.\n\n- Paramètres:\n- scores: Un tableau de `Double` représentant les scores donnés par chaque juge.\n\n- Retourne: Un `Double` représentant le score final du concurrent, arrondi à deux décimales.\n\nExemples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "de": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nBerechnet die Endpunktzahl für einen Teilnehmer, indem die höchsten und niedrigsten Punktzahlen aus dem\ngegebenen Array von Punktzahlen entfernt und dann der Durchschnitt der verbleibenden Punktzahlen berechnet wird.\nDas Ergebnis wird auf zwei Dezimalstellen gerundet.\n\n- Parameter:\n- scores: Ein Array von `Double`, das die von jedem Juror vergebenen Punktzahlen darstellt.\n\n- Rückgabewert: Ein `Double`, das die Endpunktzahl des Teilnehmers darstellt, gerundet auf zwei Dezimalstellen.\n\nBeispiele:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "ha": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nYana lissafin maki na ƙarshe ga mai fafatawa ta hanyar cire mafi girma da mafi ƙanƙanta maki daga\njerin maki da aka bayar sannan kuma lissafin matsakaicin sauran maki.\nSakamakon yana zagaye zuwa wurare biyu na goma.\n\n- Sigogi:\n- scores: Jerin `Double` wanda ke wakiltar maki da kowane alkalin ya bayar.\n\n- Komawa: `Double` wanda ke wakiltar maki na ƙarshe na mai fafatawa, an zagaye zuwa wurare biyu na goma.\n\nMisalai:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "hi": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nप्रतियोगी के लिए अंतिम स्कोर की गणना करता है, जिसमें दिए गए स्कोर की सूची से सबसे उच्च और सबसे निम्न स्कोर को हटा दिया जाता है और फिर शेष स्कोर का औसत निकाला जाता है।\nपरिणाम को दो दशमलव स्थानों तक गोल किया जाता है।\n\n- पैरामीटर्स:\n- scores: `Double` की एक array जो प्रत्येक जज द्वारा दिए गए स्कोर का प्रतिनिधित्व करती है।\n\n- रिटर्न्स: एक `Double` जो प्रतियोगी के अंतिम स्कोर का प्रतिनिधित्व करता है, दो दशमलव स्थानों तक गोल किया गया।\n\nउदाहरण:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "hu": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nKiszámítja a versenyző végső pontszámát azáltal, hogy eltávolítja a legmagasabb és legalacsonyabb pontszámokat a\nmegadott pontszámok tömbjéből, majd kiszámítja a megmaradt pontszámok átlagát.\nAz eredmény két tizedesjegyre van kerekítve.\n\n- Paraméterek:\n- scores: Egy `Double` tömb, amely az egyes bírók által adott pontszámokat tartalmazza.\n\n- Visszatérési érték: Egy `Double`, amely a versenyző végső pontszámát képviseli, két tizedesjegyre kerekítve.\n\nPéldák:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9882714718910329",
      "hy": "0.984092288674059",
      "bn": "0.9939604446342531",
      "bg": "0.9784178159486542",
      "zh": "0.9858585100222211",
      "fr": "0.9851724406861266",
      "de": "0.976788053672263",
      "ha": "0.9915651608693534",
      "hi": "0.9741254134144903",
      "hu": "0.9751549146793941"
    },
    "canonical_solution": "guard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}",
    "instruction": {
      "en": "Write a Swift function `func calculateFinalScore(_ scores: [Double]) -> Double {` to solve the following problem:\n\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n",
      "sq": "Shkruani një funksion Swift `func calculateFinalScore(_ scores: [Double]) -> Double {` për të zgjidhur problemin e mëposhtëm:\n\nLlogarit rezultatin përfundimtar për një garues duke hequr rezultatet më të larta dhe më të ulëta nga\nvargu i dhënë i rezultateve dhe pastaj duke llogaritur mesataren e rezultateve të mbetura.\nRezultati rrumbullakoset në dy vende dhjetore.\n\n- Parametrat:\n- scores: Një varg i `Double` që përfaqëson rezultatet e dhëna nga secili gjyqtar.\n\n- Kthen: Një `Double` që përfaqëson rezultatin përfundimtar të garuesit, i rrumbullakosur në dy vende dhjetore.\n\nShembuj:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hy": "Swift ֆունկցիա `func calculateFinalScore(_ scores: [Double]) -> Double {` գրեք հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է մասնակիցի վերջնական միավորը՝ հեռացնելով ամենաբարձր և ամենացածր միավորները տրված միավորների զանգվածից, ապա հաշվում է մնացած միավորների միջին արժեքը:\nԱրդյունքը կլորացվում է մինչև երկու տասնորդական նշան:\n\n- Պարամետրեր:\n- scores: `Double` տիպի զանգված, որը ներկայացնում է յուրաքանչյուր դատավորի կողմից տրված միավորները:\n\n- Վերադարձնում է: `Double`, որը ներկայացնում է մասնակիցի վերջնական միավորը, կլորացված մինչև երկու տասնորդական նշան:\n\nՕրինակներ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "bn": "একটি Swift ফাংশন `func calculateFinalScore(_ scores: [Double]) -> Double {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকজন প্রতিযোগীর চূড়ান্ত স্কোর গণনা করে প্রদত্ত স্কোরের অ্যারের মধ্যে থেকে সর্বোচ্চ এবং সর্বনিম্ন স্কোরগুলি সরিয়ে ফেলে এবং তারপর অবশিষ্ট স্কোরগুলির গড় গণনা করে। ফলাফলটি দুই দশমিক স্থানে রাউন্ড করা হয়।\n\n- প্যারামিটারসমূহ:\n- scores: প্রতিটি বিচারকের দেওয়া স্কোরগুলিকে উপস্থাপনকারী `Double` এর একটি অ্যারে।\n\n- রিটার্নস: প্রতিযোগীর চূড়ান্ত স্কোরকে উপস্থাপনকারী একটি `Double`, যা দুই দশমিক স্থানে রাউন্ড করা হয়।\n\nউদাহরণসমূহ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "bg": "Напишете Swift функция `func calculateFinalScore(_ scores: [Double]) -> Double {`, за да решите следния проблем:\n\nИзчислява крайния резултат за състезател, като премахва най-високите и най-ниските оценки от дадения масив от оценки и след това изчислява средната стойност на останалите оценки. Резултатът се закръглява до два знака след десетичната запетая.\n\n- Параметри:\n- scores: Масив от `Double`, представляващ оценките, дадени от всеки съдия.\n\n- Връща: `Double`, представляващ крайния резултат на състезателя, закръглен до два знака след десетичната запетая.\n\nПримери:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "zh": "编写一个 Swift 函数 `func calculateFinalScore(_ scores: [Double]) -> Double {` 来解决以下问题：\n\n计算选手的最终得分，通过从给定的分数数组中移除最高和最低分，然后计算剩余分数的平均值。\n结果四舍五入到小数点后两位。\n\n- 参数：\n- scores: 一个 `Double` 数组，表示每位裁判给出的分数。\n\n- 返回：一个 `Double`，表示选手的最终得分，四舍五入到小数点后两位。\n\n示例：\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "fr": "Écrire une fonction Swift `func calculateFinalScore(_ scores: [Double]) -> Double {` pour résoudre le problème suivant :\n\nCalcule le score final pour un concurrent en supprimant les scores les plus élevés et les plus bas de\nle tableau de scores donné, puis en calculant la moyenne des scores restants.\nLe résultat est arrondi à deux décimales.\n\n- Paramètres :\n- scores: Un tableau de `Double` représentant les scores donnés par chaque juge.\n\n- Renvoie : Un `Double` représentant le score final du concurrent, arrondi à deux décimales.\n\nExemples :\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "de": "Schreiben Sie eine Swift-Funktion `func calculateFinalScore(_ scores: [Double]) -> Double {`, um das folgende Problem zu lösen:\n\nBerechnet die Endpunktzahl für einen Teilnehmer, indem die höchsten und niedrigsten Punktzahlen aus dem angegebenen Array von Punktzahlen entfernt und dann der Durchschnitt der verbleibenden Punktzahlen berechnet wird. Das Ergebnis wird auf zwei Dezimalstellen gerundet.\n\n- Parameter:\n- scores: Ein Array von `Double`, das die von jedem Juror vergebenen Punktzahlen darstellt.\n\n- Rückgabewert: Ein `Double`, das die Endpunktzahl des Teilnehmers darstellt, gerundet auf zwei Dezimalstellen.\n\nBeispiele:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "ha": "Rubuta aikin Swift `func calculateFinalScore(_ scores: [Double]) -> Double {` don warware matsalar mai zuwa:\n\nYana ƙididdige maki na ƙarshe ga mai fafatawa ta hanyar cire mafi girma da mafi ƙanƙanta maki daga jerin maki da aka bayar sannan kuma yana ƙididdige matsakaicin sauran maki. \nSakamakon yana zagaye zuwa wurare biyu na goma.\n\n- Sigogi:\n- scores: Jerin `Double` da ke wakiltar maki da kowane alkalin ya bayar.\n\n- Returns: `Double` da ke wakiltar maki na ƙarshe na mai fafatawa, an zagaye zuwa wurare biyu na goma.\n\nMisalai:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hi": "Swift फ़ंक्शन `func calculateFinalScore(_ scores: [Double]) -> Double {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nप्रतियोगी के लिए अंतिम स्कोर की गणना करता है, जिसमें दिए गए स्कोर की सूची से सबसे उच्च और सबसे निम्न स्कोर को हटा दिया जाता है और फिर बचे हुए स्कोर का औसत निकाला जाता है। \nपरिणाम को दो दशमलव स्थानों तक गोल किया जाता है।\n\n- पैरामीटर्स:\n- scores: प्रत्येक जज द्वारा दिए गए स्कोर का प्रतिनिधित्व करने वाला `Double` का एक array।\n\n- रिटर्न्स: प्रतियोगी के अंतिम स्कोर का प्रतिनिधित्व करने वाला `Double`, जो दो दशमलव स्थानों तक गोल किया गया है।\n\nउदाहरण:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hu": "Írj egy Swift függvényt `func calculateFinalScore(_ scores: [Double]) -> Double {` a következő probléma megoldására:\n\nKiszámítja egy versenyző végső pontszámát úgy, hogy eltávolítja a legmagasabb és legalacsonyabb pontszámokat a megadott pontszámok tömbjéből, majd kiszámítja a fennmaradó pontszámok átlagát. \nAz eredményt két tizedesjegyre kerekíti.\n\n- Paraméterek:\n- scores: Egy `Double` típusú tömb, amely az egyes bírák által adott pontszámokat tartalmazza.\n\n- Visszatérési érték: Egy `Double`, amely a versenyző végső pontszámát jelenti, két tizedesjegyre kerekítve.\n\nPéldák:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00"
    },
    "instruction_bertscore": {
      "sq": "0.9888083698109703",
      "hy": "0.9585535860628792",
      "bn": "0.9900984741357919",
      "bg": "0.9788635425236966",
      "zh": "0.9774443284512022",
      "fr": "0.9824106838682175",
      "de": "0.9756491070674089",
      "ha": "0.9782032951371366",
      "hi": "0.9511462618933262",
      "hu": "0.972563781358794"
    },
    "level": "middle",
    "test": "func testCalculateFinalScore() {\nassert(calculateFinalScore([10.0, 8.5, 9.0, 9.5, 10.0]) == 9.50)\nassert(calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5]) == 7.00)\nassert(calculateFinalScore([5.0, 5.5, 6.0, 5.5, 5.0]) == 5.33)\nassert(calculateFinalScore([]) == 0.0)\n}\n\ntestCalculateFinalScore()",
    "entry_point": "calculateFinalScore",
    "signature": "func calculateFinalScore(_ scores: [Double]) -> Double {",
    "docstring": {
      "en": "\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n",
      "sq": "Llogarit rezultatin përfundimtar për një garues duke hequr pikët më të larta dhe më të ulëta nga\nvargu i dhënë i pikëve dhe pastaj duke llogaritur mesataren e pikëve të mbetura.\nRezultati është i rrumbullakosur në dy vende dhjetore.\n\n- Parametrat:\n- scores: Një varg i `Double` që përfaqëson pikët e dhëna nga secili gjyqtar.\n\n- Kthen: Një `Double` që përfaqëson rezultatin përfundimtar të garuesit, i rrumbullakosur në dy vende dhjetore.\n\nShembuj:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hy": "Հաշվում է մասնակիցի վերջնական միավորը՝ հեռացնելով ամենաբարձր և ամենացածր միավորները տրված միավորների զանգվածից, այնուհետև հաշվում է մնացած միավորների միջին արժեքը: \nԱրդյունքը կլորացվում է մինչև երկու տասնորդական թիվ:\n\n- Պարամետրեր:\n- scores: `Double`-ների զանգված, որը ներկայացնում է յուրաքանչյուր դատավորի կողմից տրված միավորները:\n\n- Վերադարձնում է: `Double`, որը ներկայացնում է մասնակիցի վերջնական միավորը, կլորացված մինչև երկու տասնորդական թիվ:\n\nՕրինակներ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "bn": "প্রতিযোগীর চূড়ান্ত স্কোর গণনা করে সর্বোচ্চ এবং সর্বনিম্ন স্কোরগুলি সরিয়ে দিয়ে প্রদত্ত স্কোরের অ্যারের মধ্যে থেকে এবং তারপর অবশিষ্ট স্কোরগুলির গড় গণনা করে। ফলাফলটি দুই দশমিক স্থান পর্যন্ত গোল করা হয়।\n\n- প্যারামিটারসমূহ:\n- scores: প্রতিটি বিচারকের দেওয়া স্কোরগুলি উপস্থাপনকারী `Double` এর একটি অ্যারে।\n\n- রিটার্নস: প্রতিযোগীর চূড়ান্ত স্কোর উপস্থাপনকারী একটি `Double`, যা দুই দশমিক স্থান পর্যন্ত গোল করা হয়।\n\nউদাহরণ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "bg": "Изчислява крайния резултат за състезател чрез премахване на най-високата и най-ниската оценка от дадения масив от оценки и след това изчислява средната стойност на останалите оценки. Резултатът се закръглява до два знака след десетичната запетая.\n\n- Параметри:\n- scores: Масив от `Double`, представляващ оценките, дадени от всеки съдия.\n\n- Връща: `Double`, представляващ крайния резултат на състезателя, закръглен до два знака след десетичната запетая.\n\nПримери:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "zh": "计算参赛者的最终得分，方法是从给定的分数数组中去掉最高分和最低分，然后计算剩余分数的平均值。结果四舍五入到小数点后两位。\n\n- 参数:\n- scores: 一个 `Double` 数组，表示每位评委给出的分数。\n\n- 返回: 一个 `Double`，表示参赛者的最终得分，四舍五入到小数点后两位。\n\n示例:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "fr": "Calcule le score final pour un concurrent en supprimant les scores les plus élevés et les plus bas du tableau de scores donné, puis en calculant la moyenne des scores restants. Le résultat est arrondi à deux décimales.\n\n- Paramètres:\n- scores: Un tableau de `Double` représentant les scores donnés par chaque juge.\n\n- Retourne: Un `Double` représentant le score final du concurrent, arrondi à deux décimales.\n\nExemples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "de": "Berechnet die Endpunktzahl für einen Teilnehmer, indem die höchsten und niedrigsten Punktzahlen aus dem gegebenen Array von Punktzahlen entfernt werden und dann der Durchschnitt der verbleibenden Punktzahlen berechnet wird. Das Ergebnis wird auf zwei Dezimalstellen gerundet.\n\n- Parameter:\n- scores: Ein Array von `Double`, das die von jedem Richter vergebenen Punktzahlen darstellt.\n\n- Rückgabewert: Ein `Double`, das die endgültige Punktzahl des Teilnehmers darstellt, gerundet auf zwei Dezimalstellen.\n\nBeispiele:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "ha": "Calculates the final score for a contestant by removing the highest and lowest scores from the given array of scores and then calculating the average of the remaining scores. The result is rounded to two decimal places.\n\n- Sigogi:\n- scores: Wani tsararren `Double` da ke wakiltar maki da kowane alkalin ya bayar.\n\n- Komawa: Wani `Double` da ke wakiltar maki na ƙarshe na mai fafatawa, an zagaye zuwa wurare biyu na goma.\n\nMisalai:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hi": "प्रतियोगी के लिए अंतिम स्कोर की गणना करता है, जिसमें दिए गए स्कोर के समूह से सबसे उच्च और सबसे निम्न स्कोर को हटा दिया जाता है और फिर शेष स्कोर का औसत निकाला जाता है। परिणाम को दो दशमलव स्थानों तक गोल किया जाता है।\n\n- पैरामीटर्स:\n- scores: `Double` का एक समूह जो प्रत्येक जज द्वारा दिए गए स्कोर को दर्शाता है।\n\n- रिटर्न्स: `Double` जो प्रतियोगी का अंतिम स्कोर दर्शाता है, दो दशमलव स्थानों तक गोल किया गया।\n\nउदाहरण:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "hu": "Kiszámítja a versenyző végső pontszámát úgy, hogy eltávolítja a legmagasabb és legalacsonyabb pontszámokat a megadott pontszámok tömbjéből, majd kiszámítja a megmaradt pontszámok átlagát. Az eredményt két tizedesjegyre kerekíti.\n\n- Paraméterek:\n- scores: A pontszámokat tartalmazó `Double` tömb, amelyet minden bíró adott.\n\n- Visszatérési érték: Egy `Double`, amely a versenyző végső pontszámát jelöli, két tizedesjegyre kerekítve.\n\nPéldák:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00"
    },
    "docstring_bertscore": {
      "sq": "0.992666566332192",
      "hy": "0.9595105872387053",
      "bn": "0.9832026231974036",
      "bg": "0.9720566779960119",
      "zh": "0.9767644166569198",
      "fr": "0.9822128480087068",
      "de": "0.982379101637633",
      "ha": "1",
      "hi": "0.9602494922561551",
      "hu": "0.9692186471117854"
    }
  },
  {
    "task_id": "Swift/40",
    "prompt": {
      "en": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "sq": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nLlogarit ndryshimin minimal absolut midis thartësisë totale dhe hidhësisë totale të një kombinimi të përbërësve. Thartësia totale është prodhimi i thartësisë së secilit përbërës të përdorur, dhe hidhësia totale është shuma e hidhësisë së secilit përbërës të përdorur. Të paktën një përbërës duhet të përdoret.\n\n- Parametrat:\n- ingredients: Një varg tuplesh, ku secili tuple përmban thartësinë dhe hidhësinë e një përbërësi.\n\n- Kthen: Ndryshimin minimal absolut midis thartësisë totale dhe hidhësisë totale.\n\nShembull:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "hy": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nՀաշվում է բաղադրիչների համակցության ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը։ Ընդհանուր թթվությունը օգտագործված յուրաքանչյուր բաղադրիչի թթվության արտադրյալն է, իսկ ընդհանուր դառնությունը օգտագործված յուրաքանչյուր բաղադրիչի դառնության գումարն է։ Պետք է օգտագործվի առնվազն մեկ բաղադրիչ։\n\n- Պարամետրեր:\n- ingredients: Թվերի զանգված, որտեղ յուրաքանչյուր զույգ պարունակում է բաղադրիչի թթվությունն ու դառնությունը։\n\n- Վերադարձնում է: Ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը։\n\nՕրինակ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "bn": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nউপাদানগুলির একটি সংমিশ্রণের মোট টকতা এবং মোট তিক্ততার মধ্যে সর্বনিম্ন পরম পার্থক্য গণনা করে। মোট টকতা হল ব্যবহৃত প্রতিটি উপাদানের টকতার গুণফল, এবং মোট তিক্ততা হল ব্যবহৃত প্রতিটি উপাদানের তিক্ততার যোগফল। অন্তত একটি উপাদান ব্যবহার করতে হবে।\n\n- প্যারামিটারসমূহ:\n- ingredients: একটি টুপলের অ্যারে, যেখানে প্রতিটি টুপলে একটি উপাদানের টকতা এবং তিক্ততা থাকে।\n\n- রিটার্নস: মোট টকতা এবং মোট তিক্ততার মধ্যে সর্বনিম্ন পরম পার্থক্য।\n\nউদাহরণ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "bg": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nИзчислява минималната абсолютна разлика между общата киселинност и общата горчивина на комбинация от съставки. Общата киселинност е произведението от киселинността на всяка използвана съставка, а общата горчивина е сумата от горчивината на всяка използвана съставка. Трябва да се използва поне една съставка.\n\n- Параметри:\n- ingredients: Масив от кортежи, където всеки кортеж съдържа киселинността и горчивината на съставка.\n\n- Връща: Минималната абсолютна разлика между общата киселинност и общата горчивина.\n\nПример:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "zh": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\n计算一种成分组合的总酸度和总苦味之间的最小绝对差。总酸度是所用每种成分的酸度的乘积，总苦味是所用每种成分的苦味的总和。必须使用至少一种成分。\n\n- 参数:\n- ingredients: 一个元组数组，其中每个元组包含一种成分的酸度和苦味。\n\n- 返回值: 总酸度和总苦味之间的最小绝对差。\n\n示例:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "fr": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalcule la différence absolue minimale entre l'acidité totale et l'amertume totale d'une combinaison d'ingrédients. L'acidité totale est le produit de l'acidité de chaque ingrédient utilisé, et l'amertume totale est la somme de l'amertume de chaque ingrédient utilisé. Au moins un ingrédient doit être utilisé.\n\n- Paramètres:\n- ingredients: Un tableau de tuples, où chaque tuple contient l'acidité et l'amertume d'un ingrédient.\n\n- Retours: La différence absolue minimale entre l'acidité totale et l'amertume totale.\n\nExemple:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "de": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nBerechnet den minimalen absoluten Unterschied zwischen der gesamten Säure und der gesamten Bitterkeit einer Kombination von Zutaten. Die gesamte Säure ist das Produkt der Säure jeder verwendeten Zutat, und die gesamte Bitterkeit ist die Summe der Bitterkeit jeder verwendeten Zutat. Es muss mindestens eine Zutat verwendet werden.\n\n- Parameter:\n- ingredients: Ein Array von Tupeln, wobei jedes Tupel die Säure und Bitterkeit einer Zutat enthält.\n\n- Rückgabewert: Der minimale absolute Unterschied zwischen der gesamten Säure und der gesamten Bitterkeit.\n\nBeispiel:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "ha": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nYana ƙididdige mafi ƙarancin bambanci tsakanin jimillar ɗaci da jimillar ɗanɗano na haɗin kayan abinci. Jimillar ɗaci ita ce samfurin ɗaci na kowane sinadari da aka yi amfani da shi, kuma jimillar ɗanɗano ita ce jimillar ɗanɗano na kowane sinadari da aka yi amfani da shi. Aƙalla dole a yi amfani da sinadari ɗaya.\n\n- Parameters:\n- ingredients: Jerin tuples, inda kowanne tuple ya ƙunshi ɗaci da ɗanɗano na sinadari.\n\n- Returns: Mafi ƙarancin bambanci tsakanin jimillar ɗaci da jimillar ɗanɗano.\n\nMisali:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "hi": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nसामग्री के संयोजन की कुल खट्टापन और कुल कड़वाहट के बीच न्यूनतम पूर्ण अंतर की गणना करता है। कुल खट्टापन उपयोग की गई प्रत्येक सामग्री की खट्टापन का गुणनफल है, और कुल कड़वाहट उपयोग की गई प्रत्येक सामग्री की कड़वाहट का योग है। कम से कम एक सामग्री का उपयोग किया जाना चाहिए।\n\n- पैरामीटर्स:\n- ingredients: ट्यूपल्स की एक श्रृंखला, जहां प्रत्येक ट्यूपल में एक सामग्री की खट्टापन और कड़वाहट होती है।\n\n- रिटर्न्स: कुल खट्टापन और कुल कड़वाहट के बीच न्यूनतम पूर्ण अंतर।\n\nउदाहरण:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "hu": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nKiszámítja a minimális abszolút különbséget az összes savanyúság és az összes keserűség között egy összetevők kombinációjában. Az összes savanyúság az egyes felhasznált összetevők savanyúságának szorzata, és az összes keserűség az egyes felhasznált összetevők keserűségének összege. Legalább egy összetevőt fel kell használni.\n\n- Paraméterek:\n- ingredients: Egy tömb, amely párokat tartalmaz, ahol minden pár egy összetevő savanyúságát és keserűségét tartalmazza.\n\n- Visszatér: Az összes savanyúság és az összes keserűség közötti minimális abszolút különbség.\n\nPélda:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/"
    },
    "prompt_bertscore": {
      "sq": "0.9931945258849827",
      "hy": "0.9887328902661771",
      "bn": "0.997324250137079",
      "bg": "0.9954094532639027",
      "zh": "0.9964081668197461",
      "fr": "0.9917161199589399",
      "de": "0.9813734360184534",
      "ha": "0.9666924659257837",
      "hi": "0.9924248331584725",
      "hu": "0.9796513106148809"
    },
    "canonical_solution": "var minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}",
    "instruction": {
      "en": "Write a Swift function `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` to solve the following problem:\n\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n",
      "sq": "Shkruani një funksion Swift `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` për të zgjidhur problemin e mëposhtëm:\n\nLlogarit ndryshimin minimal absolut midis thartësisë totale dhe hidhësisë totale të një kombinimi përbërësish. Thartësia totale është produkti i thartësisë së secilit përbërës të përdorur, dhe hidhësia totale është shuma e hidhësisë së secilit përbërës të përdorur. Të paktën një përbërës duhet të përdoret.\n\n- Parametrat:\n- ingredients: Një varg tuplesh, ku secili tuple përmban thartësinë dhe hidhësinë e një përbërësi.\n\n- Kthen: Ndryshimi minimal absolut midis thartësisë totale dhe hidhësisë totale.\n\nShembull:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hy": "Գրեք Swift ֆունկցիա `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվում է բաղադրիչների համադրության ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը: Ընդհանուր թթվությունը օգտագործված յուրաքանչյուր բաղադրիչի թթվության արտադրյալն է, իսկ ընդհանուր դառնությունը օգտագործված յուրաքանչյուր բաղադրիչի դառնության գումարն է: Առնվազն մեկ բաղադրիչ պետք է օգտագործվի:\n\n- Պարամետրեր:\n- ingredients: Թվերի զանգված, որտեղ յուրաքանչյուր զույգ պարունակում է բաղադրիչի թթվությունն ու դառնությունը:\n\n- Վերադարձնում է: Ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը:\n\nՕրինակ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "bn": "একটি Swift ফাংশন `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nউপাদানগুলির একটি সংমিশ্রণের মোট টকতা এবং মোট তিক্ততার মধ্যে সর্বনিম্ন পার্থক্য গণনা করে। মোট টকতা হল ব্যবহৃত প্রতিটি উপাদানের টকতার গুণফল, এবং মোট তিক্ততা হল ব্যবহৃত প্রতিটি উপাদানের তিক্ততার যোগফল। অন্তত একটি উপাদান ব্যবহার করতে হবে।\n\n- প্যারামিটার:\n- ingredients: একটি টুপলের অ্যারে, যেখানে প্রতিটি টুপলে একটি উপাদানের টকতা এবং তিক্ততা থাকে।\n\n- রিটার্ন: মোট টকতা এবং মোট তিক্ততার মধ্যে সর্বনিম্ন পার্থক্য।\n\nউদাহরণ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "bg": "Напишете Swift функция `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {`, за да решите следния проблем:\n\nИзчислява минималната абсолютна разлика между общата киселинност и общата горчивина на комбинация от съставки. Общата киселинност е произведението от киселинността на всяка използвана съставка, а общата горчивина е сумата от горчивината на всяка използвана съставка. Трябва да се използва поне една съставка.\n\n- Параметри:\n- ingredients: Масив от кортежи, където всеки кортеж съдържа киселинността и горчивината на съставка.\n\n- Връща: Минималната абсолютна разлика между общата киселинност и общата горчивина.\n\nПример:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "zh": "编写一个 Swift 函数 `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` 来解决以下问题：\n\n计算一种成分组合的总酸度和总苦度之间的最小绝对差。总酸度是所用每种成分的酸度的乘积，总苦度是所用每种成分的苦度的总和。至少必须使用一种成分。\n\n- 参数：\n- ingredients: 一个元组数组，其中每个元组包含一种成分的酸度和苦度。\n\n- 返回值：总酸度和总苦度之间的最小绝对差。\n\n示例：\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "fr": "Écrire une fonction Swift `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` pour résoudre le problème suivant :\n\nCalcule la différence absolue minimale entre l'acidité totale et l'amertume totale d'une combinaison d'ingrédients. L'acidité totale est le produit de l'acidité de chaque ingrédient utilisé, et l'amertume totale est la somme de l'amertume de chaque ingrédient utilisé. Au moins un ingrédient doit être utilisé.\n\n- Paramètres :\n- ingredients: Un tableau de tuples, où chaque tuple contient l'acidité et l'amertume d'un ingrédient.\n\n- Renvoie : La différence absolue minimale entre l'acidité totale et l'amertume totale.\n\nExemple :\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "de": "Schreiben Sie eine Swift-Funktion `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {`, um das folgende Problem zu lösen:\n\nBerechnet die minimale absolute Differenz zwischen der gesamten Säure und der gesamten Bitterkeit einer Kombination von Zutaten. Die gesamte Säure ist das Produkt der Säure jeder verwendeten Zutat, und die gesamte Bitterkeit ist die Summe der Bitterkeit jeder verwendeten Zutat. Es muss mindestens eine Zutat verwendet werden.\n\n- Parameter:\n- ingredients: Ein Array von Tupeln, wobei jedes Tupel die Säure und Bitterkeit einer Zutat enthält.\n\n- Rückgabewert: Die minimale absolute Differenz zwischen der gesamten Säure und der gesamten Bitterkeit.\n\nBeispiel:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "ha": "Rubuta aikin Swift `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` don warware matsalar mai zuwa:\n\nLissafi mafi ƙarancin bambanci tsakanin jimillar ɗaci da jimillar zaki na haɗin kayan abinci. Jimillar ɗaci ita ce samfurin ɗacin kowanne sinadari da aka yi amfani da shi, kuma jimillar zaki ita ce jimillar zakin kowanne sinadari da aka yi amfani da shi. Aƙalla dole a yi amfani da sinadari ɗaya.\n\n- Sigogi:\n- ingredients: Jeren tuples, inda kowanne tuple ya ƙunshi ɗaci da zaki na sinadari.\n\n- Komawa: Mafi ƙarancin bambanci tsakanin jimillar ɗaci da jimillar zaki.\n\nMisali:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hi": "Swift फ़ंक्शन `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nसामग्री के संयोजन की कुल खटास और कुल कड़वाहट के बीच न्यूनतम परिमाणात्मक अंतर की गणना करता है। कुल खटास प्रत्येक उपयोग की गई सामग्री की खटास का गुणनफल है, और कुल कड़वाहट प्रत्येक उपयोग की गई सामग्री की कड़वाहट का योग है। कम से कम एक सामग्री का उपयोग किया जाना चाहिए।\n\n- पैरामीटर्स:\n- ingredients: ट्यूपल्स की एक सरणी, जहाँ प्रत्येक ट्यूपल में एक सामग्री की खटास और कड़वाहट होती है।\n\n- रिटर्न करता है: कुल खटास और कुल कड़वाहट के बीच न्यूनतम परिमाणात्मक अंतर।\n\nउदाहरण:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hu": "Írj egy Swift függvényt `func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {` a következő probléma megoldására:\n\nKiszámítja az összetevők kombinációjának teljes savanyúsága és teljes keserűsége közötti minimális abszolút különbséget. A teljes savanyúság az egyes felhasznált összetevők savanyúságának szorzata, és a teljes keserűség az egyes felhasznált összetevők keserűségének összege. Legalább egy összetevőt használni kell.\n\n- Paraméterek:\n- ingredients: Egy tömb, amelyben minden elem egy összetevő savanyúságát és keserűségét tartalmazó pár.\n\n- Visszatérési érték: A teljes savanyúság és a teljes keserűség közötti minimális abszolút különbség.\n\nPélda:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1"
    },
    "instruction_bertscore": {
      "sq": "0.9915413252236293",
      "hy": "0.9897391517764997",
      "bn": "0.9879461153268978",
      "bg": "0.9870973677087357",
      "zh": "0.9933655466430537",
      "fr": "0.9907245570968138",
      "de": "0.9806553871910122",
      "ha": "0.9757823880530834",
      "hi": "0.987690875287268",
      "hu": "0.9762569160333757"
    },
    "level": "hard",
    "test": "func testMinimumTasteDifference() {\nassert(minimumTasteDifference([(3, 10)]) == 7)\nassert(minimumTasteDifference([(3, 8), (5, 8)]) == 1)\nassert(minimumTasteDifference([(1, 2), (2, 3), (3, 4)]) == 1)\nassert(minimumTasteDifference([(2, 4), (3, 6)]) == 2)\nassert(minimumTasteDifference([(1, 3), (2, 5), (4, 1)]) == 0)\n}\n\ntestMinimumTasteDifference()",
    "entry_point": "minimumTasteDifference",
    "signature": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {",
    "docstring": {
      "en": "\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n",
      "sq": "Llogarit diferencën minimale absolute midis thartësisë totale dhe hidhësisë totale të një kombinimi përbërësish. Thartësia totale është prodhimi i thartësisë së secilit përbërës të përdorur, dhe hidhësia totale është shuma e hidhësisë së secilit përbërës të përdorur. Të paktën një përbërës duhet të përdoret.\n\n- Parametra:\n- ingredients: Një varg tuplesh, ku secili tuple përmban thartësinë dhe hidhësinë e një përbërësi.\n\n- Kthen: Diferenca minimale absolute midis thartësisë totale dhe hidhësisë totale.\n\nShembull:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hy": "Հաշվում է բաղադրիչների համադրության ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը։ Ընդհանուր թթվությունը օգտագործված յուրաքանչյուր բաղադրիչի թթվության արտադրյալն է, իսկ ընդհանուր դառնությունը օգտագործված յուրաքանչյուր բաղադրիչի դառնության գումարն է։ Պետք է օգտագործվի առնվազն մեկ բաղադրիչ։\n\n- Պարամետրեր:\n- ingredients: Թվերի զանգված, որտեղ յուրաքանչյուր թուփլը պարունակում է բաղադրիչի թթվությունն ու դառնությունը։\n\n- Վերադարձնում է: Ընդհանուր թթվության և ընդհանուր դառնության միջև նվազագույն բացարձակ տարբերությունը։\n\nՕրինակ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "bn": "মোট টকত্ব এবং মোট তিক্ততার মধ্যে সর্বনিম্ন পরম পার্থক্য গণনা করে। মোট টকত্ব হল ব্যবহৃত প্রতিটি উপাদানের টকত্বের গুণফল, এবং মোট তিক্ততা হল ব্যবহৃত প্রতিটি উপাদানের তিক্ততার যোগফল। অন্তত একটি উপাদান ব্যবহার করতে হবে।\n\n- প্যারামিটারসমূহ:\n- ingredients: একটি টুপলের অ্যারে, যেখানে প্রতিটি টুপলে একটি উপাদানের টকত্ব এবং তিক্ততা থাকে।\n\n- রিটার্নস: মোট টকত্ব এবং মোট তিক্ততার মধ্যে সর্বনিম্ন পরম পার্থক্য।\n\nউদাহরণ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "bg": "Изчислява минималната абсолютна разлика между общата киселинност и общата горчивина на комбинация от съставки. Общата киселинност е произведението от киселинността на всяка използвана съставка, а общата горчивина е сумата от горчивината на всяка използвана съставка. Трябва да се използва поне една съставка.\n\n- Параметри:\n- ingredients: Масив от кортежи, където всеки кортеж съдържа киселинността и горчивината на съставка.\n\n- Връща: Минималната абсолютна разлика между общата киселинност и общата горчивина.\n\nПример:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "zh": "计算一种成分组合的总酸度和总苦度之间的最小绝对差。总酸度是所用每种成分的酸度的乘积，而总苦度是所用每种成分的苦度的总和。必须使用至少一种成分。\n\n- 参数:\n- ingredients: 一个元组数组，其中每个元组包含一种成分的酸度和苦度。\n\n- 返回值: 总酸度和总苦度之间的最小绝对差。\n\n示例:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "fr": "Calcule la différence absolue minimale entre l'acidité totale et l'amertume totale d'une combinaison d'ingrédients. L'acidité totale est le produit de l'acidité de chaque ingrédient utilisé, et l'amertume totale est la somme de l'amertume de chaque ingrédient utilisé. Au moins un ingrédient doit être utilisé.\n\n- Paramètres:\n- ingredients: Un tableau de tuples, où chaque tuple contient l'acidité et l'amertume d'un ingrédient.\n\n- Retourne: La différence absolue minimale entre l'acidité totale et l'amertume totale.\n\nExemple:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "de": "Berechnet den minimalen absoluten Unterschied zwischen der gesamten Säure und der gesamten Bitterkeit einer Kombination von Zutaten. Die gesamte Säure ist das Produkt der Säure jeder verwendeten Zutat, und die gesamte Bitterkeit ist die Summe der Bitterkeit jeder verwendeten Zutat. Es muss mindestens eine Zutat verwendet werden.\n\n- Parameter:\n- ingredients: Ein Array von Tupeln, wobei jedes Tupel die Säure und Bitterkeit einer Zutat enthält.\n\n- Rückgabewert: Der minimale absolute Unterschied zwischen der gesamten Säure und der gesamten Bitterkeit.\n\nBeispiel:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "ha": "Yana lissafin mafi ƙarancin bambanci tsakanin jimillar ɗaci da jimillar ɗanɗano na haɗin kayan abinci. Jimillar ɗaci ita ce samfurin ɗacin kowanne sinadari da aka yi amfani da shi, kuma jimillar ɗanɗano ita ce jumlar ɗanɗanon kowanne sinadari da aka yi amfani da shi. Aƙalla dole a yi amfani da sinadari ɗaya.\n\n- Sigogi:\n- ingredients: Jerin tuples, inda kowanne tuple ya ƙunshi ɗaci da ɗanɗano na sinadari.\n\n- Komawa: Mafi ƙarancin bambanci tsakanin jimillar ɗaci da jimillar ɗanɗano.\n\nMisali:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hi": "कुल खट्टापन और कुल कड़वाहट के बीच न्यूनतम निरपेक्ष अंतर की गणना करता है। कुल खट्टापन उपयोग किए गए प्रत्येक सामग्री के खट्टेपन का गुणनफल है, और कुल कड़वाहट उपयोग किए गए प्रत्येक सामग्री की कड़वाहट का योग है। कम से कम एक सामग्री का उपयोग किया जाना चाहिए।\n\n- पैरामीटर्स:\n- ingredients: ट्यूपल्स की एक श्रृंखला, जहाँ प्रत्येक ट्यूपल में एक सामग्री का खट्टापन और कड़वाहट होती है।\n\n- रिटर्न्स: कुल खट्टापन और कुल कड़वाहट के बीच न्यूनतम निरपेक्ष अंतर।\n\nउदाहरण:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "hu": "Kiszámítja az összetevők kombinációjának összes savanyúsága és összes keserűsége közötti minimális abszolút különbséget. Az összes savanyúság az egyes felhasznált összetevők savanyúságának szorzata, és az összes keserűség az egyes felhasznált összetevők keserűségének összege. Legalább egy összetevőt fel kell használni.\n\n- Paraméterek:\n- ingredients: Egy tömb, amely tuple-öket tartalmaz, ahol minden tuple egy összetevő savanyúságát és keserűségét tartalmazza.\n\n- Visszatérési érték: Az összes savanyúság és összes keserűség közötti minimális abszolút különbség.\n\nPélda:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1"
    },
    "docstring_bertscore": {
      "sq": "0.9916205787456622",
      "hy": "0.9945052877694319",
      "bn": "0.9716703419048991",
      "bg": "0.9584423530494997",
      "zh": "0.9614480279753196",
      "fr": "0.959520320127376",
      "de": "0.9777283698960821",
      "ha": "0.9458084676637756",
      "hi": "0.9729610421208638",
      "hu": "0.989068774240507"
    }
  },
  {
    "task_id": "Swift/41",
    "prompt": {
      "en": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calculates the product of the sum of the first two integers and the third integer.\n\n    This function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n    - Parameters:\n        - a: The first integer.\n        - b: The second integer.\n        - c: The third integer.\n\n    - Returns: An integer that is the product of (a+b) and c.\n\n    ### Example:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n    */",
      "sq": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Llogarit produktin e shumës së dy numrave të parë dhe numrit të tretë.\n\n    Kjo funksion merr tre numra të plotë si input dhe llogarit produktin e shumës së dy numrave të parë (a dhe b) dhe numrit të tretë (c), duke llogaritur në mënyrë efektive (a+b)*c.\n\n    - Parametrat:\n        - a: Numri i parë i plotë.\n        - b: Numri i dytë i plotë.\n        - c: Numri i tretë i plotë.\n\n    - Kthen: Një numër i plotë që është produkti i (a+b) dhe c.\n\n    ### Shembull:\n    calculateProductOfSumAndValue(1, 2, 3) // Kthen 9 sepse (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Kthen -9 sepse (-1-2)*-3 = 9\n    */",
      "hy": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Հաշվարկում է առաջին երկու ամբողջ թվերի գումարի և երրորդ թվի արտադրյալը։\n\n    Այս ֆունկցիան ընդունում է երեք ամբողջ թիվ որպես մուտք և հաշվում է առաջին երկու ամբողջ թվերի (a և b) գումարի և երրորդ ամբողջ թվի (c) արտադրյալը, փաստորեն հաշվարկելով (a+b)*c։\n\n    - Պարամետրեր:\n        - a: Առաջին ամբողջ թիվը։\n        - b: Երկրորդ ամբողջ թիվը։\n        - c: Երրորդ ամբողջ թիվը։\n\n    - Վերադարձնում է: Ամբողջ թիվ, որը (a+b) և c արտադրյալն է։\n\n    ### Օրինակ:\n    calculateProductOfSumAndValue(1, 2, 3) // Վերադարձնում է 9, որովհետև (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Վերադարձնում է -9, որովհետև (-1-2)*-3 = 9\n    */",
      "bn": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    প্রথম দুটি পূর্ণসংখ্যার যোগফল এবং তৃতীয় পূর্ণসংখ্যার গুণফল হিসাব করে।\n\n    এই ফাংশনটি ইনপুট হিসেবে তিনটি পূর্ণসংখ্যা গ্রহণ করে এবং প্রথম দুটি পূর্ণসংখ্যার (a এবং b) যোগফল এবং তৃতীয় পূর্ণসংখ্যার (c) গুণফল হিসাব করে, কার্যকরভাবে (a+b)*c হিসাব করে।\n\n    - প্যারামিটারসমূহ:\n        - a: প্রথম পূর্ণসংখ্যা।\n        - b: দ্বিতীয় পূর্ণসংখ্যা।\n        - c: তৃতীয় পূর্ণসংখ্যা।\n\n    - রিটার্নস: একটি পূর্ণসংখ্যা যা (a+b) এবং c এর গুণফল।\n\n    ### উদাহরণ:\n    calculateProductOfSumAndValue(1, 2, 3) // 9 রিটার্ন করে কারণ (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // -9 রিটার্ন করে কারণ (-1-2)*-3 = 9\n    */",
      "bg": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Изчислява произведението на сумата от първите две цели числа и третото цяло число.\n\n    Тази функция приема три цели числа като вход и изчислява произведението на сумата от първите две цели числа (a и b) и третото цяло число (c), ефективно изчислявайки (a+b)*c.\n\n    - Параметри:\n        - a: Първото цяло число.\n        - b: Второто цяло число.\n        - c: Третото цяло число.\n\n    - Връща: Цяло число, което е произведението на (a+b) и c.\n\n    ### Пример:\n    calculateProductOfSumAndValue(1, 2, 3) // Връща 9, защото (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Връща -9, защото (-1-2)*-3 = 9\n    */",
      "zh": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    计算前两个整数的和与第三个整数的乘积。\n\n    此函数接受三个整数作为输入，并计算前两个整数（a 和 b）的和与第三个整数（c）的乘积，实际上计算的是 (a+b)*c。\n\n    - 参数:\n        - a: 第一个整数。\n        - b: 第二个整数。\n        - c: 第三个整数。\n\n    - 返回: 一个整数，是 (a+b) 和 c 的乘积。\n\n    ### 示例:\n    calculateProductOfSumAndValue(1, 2, 3) // 返回 9 因为 (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // 返回 -9 因为 (-1-2)*-3 = 9\n    */",
      "fr": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calcule le produit de la somme des deux premiers entiers et du troisième entier.\n\n    Cette fonction prend trois entiers en entrée et calcule le produit de la somme des deux premiers entiers (a et b) et du troisième entier (c), calculant effectivement (a+b)*c.\n\n    - Paramètres :\n        - a : Le premier entier.\n        - b : Le deuxième entier.\n        - c : Le troisième entier.\n\n    - Retourne : Un entier qui est le produit de (a+b) et c.\n\n    ### Exemple :\n    calculateProductOfSumAndValue(1, 2, 3) // Retourne 9 parce que (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Retourne -9 parce que (-1-2)*-3 = 9\n    */",
      "de": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Berechnet das Produkt der Summe der ersten beiden Ganzzahlen und der dritten Ganzzahl.\n\n    Diese Funktion nimmt drei Ganzzahlen als Eingabe und berechnet das Produkt der Summe der ersten beiden Ganzzahlen (a und b) und der dritten Ganzzahl (c), indem sie (a+b)*c berechnet.\n\n    - Parameter:\n        - a: Die erste Ganzzahl.\n        - b: Die zweite Ganzzahl.\n        - c: Die dritte Ganzzahl.\n\n    - Rückgabe: Eine Ganzzahl, die das Produkt von (a+b) und c ist.\n\n    ### Beispiel:\n    calculateProductOfSumAndValue(1, 2, 3) // Gibt 9 zurück, weil (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Gibt -9 zurück, weil (-1-2)*-3 = 9\n    */",
      "ha": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Yana lissafin samfurin jimillar lambobin farko biyu da lamba ta uku.\n\n    Wannan aikin yana karɓar lambobi guda uku a matsayin shigarwa kuma yana lissafin samfurin jimillar lambobin farko biyu (a da b) da lamba ta uku (c), yana lissafin (a+b)*c.\n\n    - Sigogi:\n        - a: Lamba ta farko.\n        - b: Lamba ta biyu.\n        - c: Lamba ta uku.\n\n    - Yana dawowa: Lamba ce wadda ita ce samfurin (a+b) da c.\n\n    ### Misali:\n    calculateProductOfSumAndValue(1, 2, 3) // Yana dawowa 9 saboda (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Yana dawowa -9 saboda (-1-2)*-3 = 9\n    */",
      "hi": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    पहले दो पूर्णांकों के योग और तीसरे पूर्णांक के गुणनफल की गणना करता है।\n\n    यह फ़ंक्शन इनपुट के रूप में तीन पूर्णांक लेता है और पहले दो पूर्णांकों (a और b) के योग और तीसरे पूर्णांक (c) के गुणनफल की गणना करता है, प्रभावी रूप से (a+b)*c की गणना करता है।\n\n    - Parameters:\n        - a: पहला पूर्णांक।\n        - b: दूसरा पूर्णांक।\n        - c: तीसरा पूर्णांक।\n\n    - Returns: एक पूर्णांक जो (a+b) और c का गुणनफल है।\n\n    ### Example:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 क्योंकि (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 क्योंकि (-1-2)*-3 = 9\n    */",
      "hu": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Kiszámítja az első két egész szám összegének és a harmadik egész számnak a szorzatát.\n\n    Ez a függvény három egész számot vesz be bemenetként, és kiszámítja az első két egész szám (a és b) összegének és a harmadik egész számnak (c) a szorzatát, lényegében kiszámítva (a+b)*c.\n\n    - Paraméterek:\n        - a: Az első egész szám.\n        - b: A második egész szám.\n        - c: A harmadik egész szám.\n\n    - Visszatér: Egy egész szám, amely (a+b) és c szorzata.\n\n    ### Példa:\n    calculateProductOfSumAndValue(1, 2, 3) // 9-et ad vissza, mert (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // -9-et ad vissza, mert (-1-2)*-3 = 9\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9856455782537518",
      "hy": "0.9913252153690634",
      "bn": "0.9918035173265953",
      "bg": "0.9921976000025685",
      "zh": "0.989729021627067",
      "fr": "0.9948123703385118",
      "de": "0.9871809910991515",
      "ha": "0.964558579742326",
      "hi": "0.9939433624214842",
      "hu": "0.9903463648513234"
    },
    "canonical_solution": "    return (a + b) * c\n}",
    "instruction": {
      "en": "Write a Swift function `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` to solve the following problem:\nCalculates the product of the sum of the first two integers and the third integer.\n\nThis function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n- Parameters:\n- a: The first integer.\n- b: The second integer.\n- c: The third integer.\n\n- Returns: An integer that is the product of (a+b) and c.\n\n### Example:\ncalculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n",
      "sq": "Shkruani një funksion Swift `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\nLlogarit produktin e shumës së dy numrave të parë dhe numrit të tretë.\n\nKy funksion merr tre numra të plotë si hyrje dhe llogarit produktin e shumës së dy numrave të parë (a dhe b) dhe numrit të tretë (c), duke llogaritur në mënyrë efektive (a+b)*c.\n\n- Parametrat:\n- a: Numri i parë i plotë.\n- b: Numri i dytë i plotë.\n- c: Numri i tretë i plotë.\n\n- Kthen: Një numër i plotë që është produkti i (a+b) dhe c.\n\n### Shembull:\ncalculateProductOfSumAndValue(1, 2, 3) // Kthen 9 sepse (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Kthen -9 sepse (-1-2)*-3 = 9",
      "hy": "Գրեք Swift ֆունկցիա `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է առաջին երկու ամբողջ թվերի գումարի և երրորդ ամբողջ թվի արտադրյալը:\n\nԱյս ֆունկցիան ընդունում է երեք ամբողջ թիվ որպես մուտք և հաշվարկում է առաջին երկու ամբողջ թվերի (a և b) գումարի և երրորդ ամբողջ թվի (c) արտադրյալը, փաստացի հաշվարկելով (a+b)*c։\n\n- Պարամետրեր:\n- a: Առաջին ամբողջ թիվը։\n- b: Երկրորդ ամբողջ թիվը։\n- c: Երրորդ ամբողջ թիվը։\n\n- Վերադարձնում է: Ամբողջ թիվ, որը (a+b) և c արտադրյալն է։\n\n### Օրինակ:\ncalculateProductOfSumAndValue(1, 2, 3) // Վերադարձնում է 9, որովհետև (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Վերադարձնում է -9, որովհետև (-1-2)*-3 = 9",
      "bn": "একটি Swift ফাংশন `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রথম দুটি পূর্ণসংখ্যার যোগফল এবং তৃতীয় পূর্ণসংখ্যার গুণফল গণনা করে।\n\nএই ফাংশনটি তিনটি পূর্ণসংখ্যা ইনপুট হিসেবে গ্রহণ করে এবং প্রথম দুটি পূর্ণসংখ্যার (a এবং b) যোগফল এবং তৃতীয় পূর্ণসংখ্যার (c) গুণফল গণনা করে, কার্যত (a+b)*c হিসাব করে।\n\n- প্যারামিটারসমূহ:\n- a: প্রথম পূর্ণসংখ্যা।\n- b: দ্বিতীয় পূর্ণসংখ্যা।\n- c: তৃতীয় পূর্ণসংখ্যা।\n\n- রিটার্নস: একটি পূর্ণসংখ্যা যা (a+b) এবং c এর গুণফল।\n\n### উদাহরণ:\ncalculateProductOfSumAndValue(1, 2, 3) // 9 রিটার্ন করে কারণ (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9 রিটার্ন করে কারণ (-1-2)*-3 = 9",
      "bg": "Напишете функция на Swift `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` за решаване на следния проблем:\nИзчислява произведението на сумата от първите два цели числа и третото цяло число.\n\nТази функция приема три цели числа като вход и изчислява произведението на сумата от първите две цели числа (a и b) и третото цяло число (c), ефективно изчислявайки (a+b)*c.\n\n- Параметри:\n- a: Първото цяло число.\n- b: Второто цяло число.\n- c: Третото цяло число.\n\n- Връща: Цяло число, което е произведението на (a+b) и c.\n\n### Пример:\ncalculateProductOfSumAndValue(1, 2, 3) // Връща 9, защото (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Връща -9, защото (-1-2)*-3 = 9",
      "zh": "编写一个 Swift 函数 `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` 来解决以下问题：\n计算前两个整数之和与第三个整数的乘积。\n\n此函数接受三个整数作为输入，并计算前两个整数（a 和 b）之和与第三个整数（c）的乘积，有效地计算 (a+b)*c。\n\n- 参数：\n- a: 第一个整数。\n- b: 第二个整数。\n- c: 第三个整数。\n\n- 返回值：一个整数，是 (a+b) 和 c 的乘积。\n\n### 示例：\ncalculateProductOfSumAndValue(1, 2, 3) // 返回 9 因为 (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // 返回 -9 因为 (-1-2)*-3 = 9",
      "fr": "Écrire une fonction Swift `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` pour résoudre le problème suivant :\nCalcule le produit de la somme des deux premiers entiers et du troisième entier.\n\nCette fonction prend trois entiers en entrée et calcule le produit de la somme des deux premiers entiers (a et b) et du troisième entier (c), calculant ainsi (a+b)*c.\n\n- Paramètres :\n- a : Le premier entier.\n- b : Le deuxième entier.\n- c : Le troisième entier.\n\n- Retourne : Un entier qui est le produit de (a+b) et c.\n\n### Exemple :\ncalculateProductOfSumAndValue(1, 2, 3) // Retourne 9 car (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Retourne -9 car (-1-2)*-3 = 9",
      "de": "Schreiben Sie eine Swift-Funktion `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {`, um das folgende Problem zu lösen:\nBerechnet das Produkt der Summe der ersten beiden Ganzzahlen und der dritten Ganzzahl.\n\nDiese Funktion nimmt drei Ganzzahlen als Eingabe und berechnet das Produkt der Summe der ersten beiden Ganzzahlen (a und b) und der dritten Ganzzahl (c), indem sie effektiv (a+b)*c berechnet.\n\n- Parameter:\n- a: Die erste Ganzzahl.\n- b: Die zweite Ganzzahl.\n- c: Die dritte Ganzzahl.\n\n- Rückgabe: Eine Ganzzahl, die das Produkt von (a+b) und c ist.\n\n### Beispiel:\ncalculateProductOfSumAndValue(1, 2, 3) // Gibt 9 zurück, weil (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Gibt -9 zurück, weil (-1-2)*-3 = 9",
      "ha": "Rubuta aikin Swift `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` don warware matsalar mai zuwa:\nYana ƙididdige samfurin jimlar lambobin farko biyu da lamba ta uku.\n\nWannan aikin yana ɗaukar lambobi guda uku a matsayin shigarwa kuma yana lissafin samfurin jimlar lambobin farko biyu (a da b) da lamba ta uku (c), yana ƙididdige (a+b)*c.\n\n- Sigogi:\n- a: Lamba ta farko.\n- b: Lamba ta biyu.\n- c: Lamba ta uku.\n\n- Komawa: Lamba ce da take samfurin (a+b) da c.\n\n### Misali:\ncalculateProductOfSumAndValue(1, 2, 3) // Yana dawowa 9 saboda (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Yana dawowa -9 saboda (-1-2)*-3 = 9",
      "hi": "Swift फ़ंक्शन `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nपहले दो पूर्णांकों के योग और तीसरे पूर्णांक का गुणनफल गणना करता है।\n\nयह फ़ंक्शन तीन पूर्णांकों को इनपुट के रूप में लेता है और पहले दो पूर्णांकों (a और b) के योग और तीसरे पूर्णांक (c) का गुणनफल गणना करता है, प्रभावी रूप से (a+b)*c की गणना करता है।\n\n- पैरामीटर्स:\n- a: पहला पूर्णांक।\n- b: दूसरा पूर्णांक।\n- c: तीसरा पूर्णांक।\n\n- रिटर्न करता है: एक पूर्णांक जो (a+b) और c का गुणनफल है।\n\n### उदाहरण:\ncalculateProductOfSumAndValue(1, 2, 3) // 9 रिटर्न करता है क्योंकि (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9 रिटर्न करता है क्योंकि (-1-2)*-3 = 9",
      "hu": "Írj egy Swift függvényt `func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {` a következő probléma megoldására:\nKiszámítja az első két egész szám összegének és a harmadik egész számnak a szorzatát.\n\nEz a függvény három egész számot vesz be bemenetként, és kiszámítja az első két egész szám (a és b) összegének és a harmadik egész számnak (c) a szorzatát, lényegében kiszámítva (a+b)*c.\n\n- Paraméterek:\n- a: Az első egész szám.\n- b: A második egész szám.\n- c: A harmadik egész szám.\n\n- Visszatér: Egy egész szám, amely (a+b) és c szorzata.\n\n### Példa:\ncalculateProductOfSumAndValue(1, 2, 3) // 9-et ad vissza, mert (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9-et ad vissza, mert (-1-2)*-3 = 9"
    },
    "instruction_bertscore": {
      "sq": "0.9856785508970035",
      "hy": "0.9947372880544806",
      "bn": "0.9926548471397109",
      "bg": "0.9906077624327653",
      "zh": "0.9879647865827151",
      "fr": "0.9916771884042571",
      "de": "0.9933119164401742",
      "ha": "0.9660864446332463",
      "hi": "0.9845318577072891",
      "hu": "0.9938436499702047"
    },
    "level": "easy",
    "test": "func testCalculateProductOfSumAndValue() {\n    assert(calculateProductOfSumAndValue(1, 2, 3) == 9, \"Test Case 1 Failed\")\n    assert(calculateProductOfSumAndValue(-1, 2, 3) == 3, \"Test Case 2 Failed\")\n    assert(calculateProductOfSumAndValue(-1, -2, -3) == 9, \"Test Case 3 Failed\")\n    assert(calculateProductOfSumAndValue(0, 0, 1) == 0, \"Test Case 4 Failed\")\n    assert(calculateProductOfSumAndValue(10, 20, 30) == 900, \"Test Case 5 Failed\")\n    assert(calculateProductOfSumAndValue(-5, 5, 0) == 0, \"Test Case 6 Failed\")\n    assert(calculateProductOfSumAndValue(100, 200, -1) == -300, \"Test Case 7 Failed\")\n}\n\ntestCalculateProductOfSumAndValue()",
    "entry_point": "calculateProductOfSumAndValue",
    "signature": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the product of the sum of the first two integers and the third integer.\n\nThis function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n- Parameters:\n- a: The first integer.\n- b: The second integer.\n- c: The third integer.\n\n- Returns: An integer that is the product of (a+b) and c.\n\n### Example:\ncalculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n",
      "sq": "Llogarit produktin e shumës së dy numrave të parë të plotë dhe numrit të tretë të plotë.\n\nKjo funksion merr tre numra të plotë si input dhe llogarit produktin e shumës së dy numrave të parë të plotë (a dhe b) dhe numrit të tretë të plotë (c), duke llogaritur në mënyrë efektive (a+b)*c.\n\n- Parametrat:\n- a: Numri i parë i plotë.\n- b: Numri i dytë i plotë.\n- c: Numri i tretë i plotë.\n\n- Kthen: Një numër i plotë që është produkti i (a+b) dhe c.\n\n### Shembull:\ncalculateProductOfSumAndValue(1, 2, 3) // Kthen 9 sepse (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Kthen -9 sepse (-1-2)*-3 = 9",
      "hy": "Հաշվում է առաջին երկու ամբողջ թվերի գումարի և երրորդ ամբողջ թվի արտադրյալը։\n\nԱյս ֆունկցիան ընդունում է երեք ամբողջ թիվ որպես մուտք և հաշվարկում է առաջին երկու ամբողջ թվերի (a և b) գումարի և երրորդ ամբողջ թվի (c) արտադրյալը՝ փաստորեն հաշվարկելով (a+b)*c։\n\n- Պարամետրեր:\n- a: Առաջին ամբողջ թիվը։\n- b: Երկրորդ ամբողջ թիվը։\n- c: Երրորդ ամբողջ թիվը։\n\n- Վերադարձնում է: Ամբողջ թիվ, որը (a+b) և c արտադրյալն է։\n\n### Օրինակ:\ncalculateProductOfSumAndValue(1, 2, 3) // Վերադարձնում է 9, որովհետև (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Վերադարձնում է -9, որովհետև (-1-2)*-3 = 9",
      "bn": "প্রথম দুটি পূর্ণসংখ্যার যোগফল এবং তৃতীয় পূর্ণসংখ্যার গুণফল গণনা করে।\n\nএই ফাংশনটি তিনটি পূর্ণসংখ্যা ইনপুট হিসাবে গ্রহণ করে এবং প্রথম দুটি পূর্ণসংখ্যার (a এবং b) যোগফল এবং তৃতীয় পূর্ণসংখ্যার (c) গুণফল গণনা করে, কার্যকরভাবে (a+b)*c হিসাব করে।\n\n- প্যারামিটারসমূহ:\n- a: প্রথম পূর্ণসংখ্যা।\n- b: দ্বিতীয় পূর্ণসংখ্যা।\n- c: তৃতীয় পূর্ণসংখ্যা।\n\n- রিটার্নস: একটি পূর্ণসংখ্যা যা (a+b) এবং c এর গুণফল।\n\n### উদাহরণ:\ncalculateProductOfSumAndValue(1, 2, 3) // 9 রিটার্ন করে কারণ (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9 রিটার্ন করে কারণ (-1-2)*-3 = 9",
      "bg": "Изчислява произведението на сумата от първите две цели числа и третото цяло число.\n\nТази функция приема три цели числа като вход и изчислява произведението на сумата от първите две цели числа (a и b) и третото цяло число (c), ефективно изчислявайки (a+b)*c.\n\n- Параметри:\n- a: Първото цяло число.\n- b: Второто цяло число.\n- c: Третото цяло число.\n\n- Връща: Цяло число, което е произведението на (a+b) и c.\n\n### Пример:\ncalculateProductOfSumAndValue(1, 2, 3) // Връща 9, защото (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Връща -9, защото (-1-2)*-3 = 9",
      "zh": "计算前两个整数的和与第三个整数的乘积。\n\n此函数接受三个整数作为输入，并计算前两个整数（a 和 b）的和与第三个整数（c）的乘积，实际上计算的是 (a+b)*c。\n\n- 参数:\n- a: 第一个整数。\n- b: 第二个整数。\n- c: 第三个整数。\n\n- 返回: 一个整数，是 (a+b) 和 c 的乘积。\n\n### 示例:\ncalculateProductOfSumAndValue(1, 2, 3) // 返回 9 因为 (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // 返回 -9 因为 (-1-2)*-3 = 9",
      "fr": "Calcule le produit de la somme des deux premiers entiers et du troisième entier.\n\nCette fonction prend trois entiers en entrée et calcule le produit de la somme des deux premiers entiers (a et b) et du troisième entier (c), calculant effectivement (a+b)*c.\n\n- Paramètres:\n- a: Le premier entier.\n- b: Le deuxième entier.\n- c: Le troisième entier.\n\n- Retourne: Un entier qui est le produit de (a+b) et c.\n\n### Exemple:\ncalculateProductOfSumAndValue(1, 2, 3) // Retourne 9 parce que (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Retourne -9 parce que (-1-2)*-3 = 9",
      "de": "Berechnet das Produkt der Summe der ersten beiden Ganzzahlen und der dritten Ganzzahl.\n\nDiese Funktion nimmt drei Ganzzahlen als Eingabe und berechnet das Produkt der Summe der ersten beiden Ganzzahlen (a und b) und der dritten Ganzzahl (c), indem sie effektiv (a+b)*c berechnet.\n\n- Parameter:\n- a: Die erste Ganzzahl.\n- b: Die zweite Ganzzahl.\n- c: Die dritte Ganzzahl.\n\n- Rückgabewert: Eine Ganzzahl, die das Produkt von (a+b) und c ist.\n\n### Beispiel:\ncalculateProductOfSumAndValue(1, 2, 3) // Gibt 9 zurück, weil (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Gibt -9 zurück, weil (-1-2)*-3 = 9",
      "ha": "Yana ƙididdige samfurin jimillar lambobi biyu na farko da lamba ta uku.\n\nWannan aikin yana ɗaukar lambobi guda uku a matsayin shigarwa kuma yana ƙididdige samfurin jimillar lambobi biyu na farko (a da b) da lamba ta uku (c), yana ƙididdige (a+b)*c.\n\n- Sigogi:\n- a: Lamba ta farko.\n- b: Lamba ta biyu.\n- c: Lamba ta uku.\n\n- Komawa: Lamba ce wadda ita ce samfurin (a+b) da c.\n\n### Misali:\ncalculateProductOfSumAndValue(1, 2, 3) // Yana dawowa 9 saboda (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Yana dawowa -9 saboda (-1-2)*-3 = 9",
      "hi": "पहले दो पूर्णांकों के योग और तीसरे पूर्णांक के गुणनफल की गणना करता है।\n\nयह फ़ंक्शन तीन पूर्णांकों को इनपुट के रूप में लेता है और पहले दो पूर्णांकों (a और b) के योग और तीसरे पूर्णांक (c) के गुणनफल की गणना करता है, प्रभावी रूप से (a+b)*c की गणना करता है।\n\n- पैरामीटर्स:\n- a: पहला पूर्णांक।\n- b: दूसरा पूर्णांक।\n- c: तीसरा पूर्णांक।\n\n- रिटर्न करता है: एक पूर्णांक जो (a+b) और c का गुणनफल है।\n\n### उदाहरण:\ncalculateProductOfSumAndValue(1, 2, 3) // 9 लौटाता है क्योंकि (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9 लौटाता है क्योंकि (-1-2)*-3 = 9",
      "hu": "Kiszámítja az első két egész szám összegének és a harmadik egész számnak a szorzatát.\n\nEz a függvény három egész számot vesz be bemenetként, és kiszámítja az első két egész szám (a és b) összegének és a harmadik egész számnak (c) a szorzatát, lényegében kiszámítva (a+b)*c.\n\n- Paraméterek:\n- a: Az első egész szám.\n- b: A második egész szám.\n- c: A harmadik egész szám.\n\n- Visszatér: Egy egész szám, amely (a+b) és c szorzata.\n\n### Példa:\ncalculateProductOfSumAndValue(1, 2, 3) // 9-et ad vissza, mert (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9-et ad vissza, mert (-1-2)*-3 = 9"
    },
    "docstring_bertscore": {
      "sq": "0.9936809716881371",
      "hy": "0.9988094094960769",
      "bn": "0.9777551849975218",
      "bg": "0.987736560274906",
      "zh": "0.9756816824498986",
      "fr": "0.9924981277690743",
      "de": "0.987075716997203",
      "ha": "0.9579100236283261",
      "hi": "0.9709221012595406",
      "hu": "0.9926798745677212"
    }
  },
  {
    "task_id": "Swift/42",
    "prompt": {
      "en": "func asciiCode(of character: Character) -> Int {\n    /**\n    Returns the ASCII code of the given character.\n\n    This function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n    - Parameter character: A `Character` value representing a visible character (excluding space).\n\n    - Returns: An `Int` representing the ASCII code of the given character.\n\n    ### Example:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "sq": "func asciiCode(of character: Character) -> Int {\n    /**\n    Kthen kodin ASCII të karakterit të dhënë.\n\n    Kjo funksion merr një karakter të vetëm (përjashtuar hapësirën) si hyrje dhe kthen kodin e tij ASCII si një numër të plotë. Vlera ASCII përcaktohet bazuar në përfaqësimin e karakterit në tabelën ASCII.\n\n    - Parametri karakter: Një vlerë `Character` që përfaqëson një karakter të dukshëm (përjashtuar hapësirën).\n\n    - Kthen: Një `Int` që përfaqëson kodin ASCII të karakterit të dhënë.\n\n    ### Shembull:\n    asciiCode(of: \"A\") // Kthen 65\n    asciiCode(of: \"a\") // Kthen 97\n    */",
      "hy": "func asciiCode(of character: Character) -> Int {\n    /**\n    Վերադարձնում է տրված սիմվոլի ASCII կոդը։\n\n    Այս ֆունկցիան ընդունում է մեկ սիմվոլ (բացառությամբ բացատ) որպես մուտք և վերադարձնում է դրա ASCII կոդը որպես ամբողջ թիվ։ ASCII արժեքը որոշվում է սիմվոլի ներկայացմամբ ASCII աղյուսակում։\n\n    - Պարամետր character: `Character` արժեք, որը ներկայացնում է տեսանելի սիմվոլ (բացառությամբ բացատ)։\n\n    - Վերադարձնում է: `Int`, որը ներկայացնում է տրված սիմվոլի ASCII կոդը։\n\n    ### Օրինակ:\n    asciiCode(of: \"A\") // Վերադարձնում է 65\n    asciiCode(of: \"a\") // Վերադարձնում է 97\n    */",
      "bn": "func asciiCode(of character: Character) -> Int {\n    /**\n    প্রদত্ত অক্ষরের ASCII কোড প্রদান করে।\n\n    এই ফাংশনটি একটি একক অক্ষর (স্পেস বাদে) ইনপুট হিসেবে গ্রহণ করে এবং এর ASCII কোড একটি পূর্ণসংখ্যা হিসেবে প্রদান করে। ASCII মানটি ASCII টেবিলে অক্ষরের উপস্থাপনার উপর ভিত্তি করে নির্ধারিত হয়।\n\n    - Parameter character: একটি `Character` মান যা একটি দৃশ্যমান অক্ষরকে উপস্থাপন করে (স্পেস বাদে)।\n\n    - Returns: একটি `Int` যা প্রদত্ত অক্ষরের ASCII কোড উপস্থাপন করে।\n\n    ### উদাহরণ:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "bg": "func asciiCode(of character: Character) -> Int {\n    /**\n    Връща ASCII кода на дадения символ.\n\n    Тази функция приема един символ (без интервал) като вход и връща неговия ASCII код като цяло число. ASCII стойността се определя въз основа на представянето на символа в ASCII таблицата.\n\n    - Параметър character: Стойност от тип `Character`, представляваща видим символ (без интервал).\n\n    - Връща: `Int`, представляващ ASCII кода на дадения символ.\n\n    ### Пример:\n    asciiCode(of: \"A\") // Връща 65\n    asciiCode(of: \"a\") // Връща 97\n    */",
      "zh": "func asciiCode(of character: Character) -> Int {\n    /**\n    返回给定字符的ASCII码。\n\n    此函数接受一个字符（不包括空格）作为输入，并返回其ASCII码作为整数。ASCII值是根据字符在ASCII表中的表示确定的。\n\n    - 参数 character: 一个`Character`值，表示一个可见字符（不包括空格）。\n\n    - 返回: 一个`Int`，表示给定字符的ASCII码。\n\n    ### 示例:\n    asciiCode(of: \"A\") // 返回 65\n    asciiCode(of: \"a\") // 返回 97\n    */",
      "fr": "func asciiCode(of character: Character) -> Int {\n    /**\n    Renvoie le code ASCII du caractère donné.\n\n    Cette fonction prend un seul caractère (à l'exclusion de l'espace) en entrée et renvoie son code ASCII en tant qu'entier. La valeur ASCII est déterminée en fonction de la représentation du caractère dans la table ASCII.\n\n    - Paramètre character: Une valeur `Character` représentant un caractère visible (à l'exclusion de l'espace).\n\n    - Renvoie: Un `Int` représentant le code ASCII du caractère donné.\n\n    ### Exemple:\n    asciiCode(of: \"A\") // Renvoie 65\n    asciiCode(of: \"a\") // Renvoie 97\n    */",
      "de": "func asciiCode(of character: Character) -> Int {\n    /**\n    Gibt den ASCII-Code des angegebenen Zeichens zurück.\n\n    Diese Funktion nimmt ein einzelnes Zeichen (ohne Leerzeichen) als Eingabe und gibt dessen ASCII-Code als Ganzzahl zurück. Der ASCII-Wert wird basierend auf der Darstellung des Zeichens in der ASCII-Tabelle bestimmt.\n\n    - Parameter character: Ein `Character`-Wert, der ein sichtbares Zeichen darstellt (ohne Leerzeichen).\n\n    - Rückgabe: Ein `Int`, der den ASCII-Code des angegebenen Zeichens darstellt.\n\n    ### Beispiel:\n    asciiCode(of: \"A\") // Gibt 65 zurück\n    asciiCode(of: \"a\") // Gibt 97 zurück\n    */",
      "ha": "func asciiCode(of character: Character) -> Int {\n    /**\n    Yana dawo da lambar ASCII na harafin da aka bayar.\n\n    Wannan aikin yana karɓar harafi guda ɗaya (ban da sarari) azaman shigarwa kuma yana dawo da lambar ASCII ɗinsa azaman cikakken lamba. Ana ƙayyade ƙimar ASCII bisa wakilcin harafin a cikin teburin ASCII.\n\n    - Ma'auni harafi: Ƙimar `Character` da ke wakiltar harafi mai gani (ban da sarari).\n\n    - Yana dawowa: `Int` da ke wakiltar lambar ASCII na harafin da aka bayar.\n\n    ### Misali:\n    asciiCode(of: \"A\") // Yana dawowa 65\n    asciiCode(of: \"a\") // Yana dawowa 97\n    */",
      "hi": "func asciiCode(of character: Character) -> Int {\n    /**\n    दिए गए वर्ण का ASCII कोड लौटाता है।\n\n    यह फ़ंक्शन एकल वर्ण (स्पेस को छोड़कर) को इनपुट के रूप में लेता है और उसके ASCII कोड को पूर्णांक के रूप में लौटाता है। ASCII मान वर्ण की ASCII तालिका में प्रस्तुति के आधार पर निर्धारित किया जाता है।\n\n    - Parameter character: एक `Character` मान जो एक दृश्यमान वर्ण का प्रतिनिधित्व करता है (स्पेस को छोड़कर)।\n\n    - Returns: एक `Int` जो दिए गए वर्ण का ASCII कोड दर्शाता है।\n\n    ### Example:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "hu": "func asciiCode(of character: Character) -> Int {\n    /**\n    Visszaadja a megadott karakter ASCII kódját.\n\n    Ez a függvény egyetlen karaktert (kivéve a szóközt) vesz be bemenetként, és visszaadja annak ASCII kódját egész számként. Az ASCII érték a karakter ASCII táblázatbeli ábrázolása alapján kerül meghatározásra.\n\n    - Parameter character: Egy `Character` érték, amely egy látható karaktert képvisel (kivéve a szóközt).\n\n    - Returns: Egy `Int`, amely a megadott karakter ASCII kódját képviseli.\n\n    ### Példa:\n    asciiCode(of: \"A\") // Visszaadja 65\n    asciiCode(of: \"a\") // Visszaadja 97\n    */"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9836086236962389",
      "bn": "0.985065974801892",
      "bg": "0.9712949304847431",
      "zh": "0.9922099150861927",
      "fr": "1",
      "de": "0.9717468146015975",
      "ha": "0.9983990391288589",
      "hi": "0.9968672016303177",
      "hu": "1"
    },
    "canonical_solution": "    return Int(character.asciiValue!)\n}",
    "instruction": {
      "en": "Write a Swift function `func asciiCode(of character: Character) -> Int {` to solve the following problem:\nReturns the ASCII code of the given character.\n\nThis function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n- Parameter character: A `Character` value representing a visible character (excluding space).\n\n- Returns: An `Int` representing the ASCII code of the given character.\n\n### Example:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97\n",
      "sq": "Shkruani një funksion Swift `func asciiCode(of character: Character) -> Int {` për të zgjidhur problemin e mëposhtëm:\nKthen kodin ASCII të karakterit të dhënë.\n\nKy funksion merr një karakter të vetëm (përjashtuar hapësirën) si hyrje dhe kthen kodin e tij ASCII si një numër i plotë. Vlera ASCII përcaktohet bazuar në përfaqësimin e karakterit në tabelën ASCII.\n\n- Parametri character: Një vlerë `Character` që përfaqëson një karakter të dukshëm (përjashtuar hapësirën).\n\n- Kthen: Një `Int` që përfaqëson kodin ASCII të karakterit të dhënë.\n\n### Shembull:\nasciiCode(of: \"A\") // Kthen 65\nasciiCode(of: \"a\") // Kthen 97",
      "hy": "Swift ֆունկցիա գրեք `func asciiCode(of character: Character) -> Int {` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնում է տրված սիմվոլի ASCII կոդը։\n\nԱյս ֆունկցիան ընդունում է մեկ սիմվոլ (բացառությամբ բացատ) որպես մուտք և վերադարձնում է դրա ASCII կոդը որպես ամբողջ թիվ։ ASCII արժեքը որոշվում է սիմվոլի ներկայացմամբ ASCII աղյուսակում։\n\n- Պարամետր character: `Character` արժեք, որը ներկայացնում է տեսանելի սիմվոլ (բացառությամբ բացատ)։\n\n- Վերադարձնում է: `Int`, որը ներկայացնում է տրված սիմվոլի ASCII կոդը։\n\n### Օրինակ:\nasciiCode(of: \"A\") // Վերադարձնում է 65\nasciiCode(of: \"a\") // Վերադարձնում է 97",
      "bn": "একটি Swift ফাংশন `func asciiCode(of character: Character) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত অক্ষরের ASCII কোড প্রদান করে।\n\nএই ফাংশনটি একটি একক অক্ষর (স্পেস বাদে) ইনপুট হিসেবে গ্রহণ করে এবং এর ASCII কোড একটি পূর্ণসংখ্যা হিসেবে প্রদান করে। ASCII মান নির্ধারিত হয় অক্ষরের ASCII টেবিলে উপস্থাপনার উপর ভিত্তি করে।\n\n- প্যারামিটার character: একটি `Character` মান যা একটি দৃশ্যমান অক্ষরকে উপস্থাপন করে (স্পেস বাদে)।\n\n- রিটার্নস: একটি `Int` যা প্রদত্ত অক্ষরের ASCII কোড উপস্থাপন করে।\n\n### উদাহরণ:\nasciiCode(of: \"A\") // 65 প্রদান করে\nasciiCode(of: \"a\") // 97 প্রদান করে",
      "bg": "Напишете Swift функция `func asciiCode(of character: Character) -> Int {` за решаване на следния проблем:\nВръща ASCII кода на дадения символ.\n\nТази функция приема един символ (без интервал) като вход и връща неговия ASCII код като цяло число. ASCII стойността се определя въз основа на представянето на символа в ASCII таблицата.\n\n- Параметър character: `Character` стойност, представляваща видим символ (без интервал).\n\n- Връща: `Int`, представляващ ASCII кода на дадения символ.\n\n### Пример:\nasciiCode(of: \"A\") // Връща 65\nasciiCode(of: \"a\") // Връща 97",
      "zh": "编写一个 Swift 函数 `func asciiCode(of character: Character) -> Int {` 来解决以下问题：\n返回给定字符的 ASCII 码。\n\n此函数接受一个单字符（不包括空格）作为输入，并返回其 ASCII 码作为整数。ASCII 值是根据字符在 ASCII 表中的表示来确定的。\n\n- 参数 character: 一个 `Character` 值，表示一个可见字符（不包括空格）。\n\n- 返回: 一个 `Int`，表示给定字符的 ASCII 码。\n\n### 示例:\nasciiCode(of: \"A\") // 返回 65\nasciiCode(of: \"a\") // 返回 97",
      "fr": "Écrire une fonction Swift `func asciiCode(of character: Character) -> Int {` pour résoudre le problème suivant :\nRenvoie le code ASCII du caractère donné.\n\nCette fonction prend un seul caractère (à l'exclusion de l'espace) en entrée et renvoie son code ASCII sous forme d'entier. La valeur ASCII est déterminée en fonction de la représentation du caractère dans la table ASCII.\n\n- Paramètre character : Une valeur `Character` représentant un caractère visible (à l'exclusion de l'espace).\n\n- Renvoie : Un `Int` représentant le code ASCII du caractère donné.\n\n### Exemple :\nasciiCode(of: \"A\") // Renvoie 65\nasciiCode(of: \"a\") // Renvoie 97",
      "de": "Schreiben Sie eine Swift-Funktion `func asciiCode(of character: Character) -> Int {`, um das folgende Problem zu lösen:\nGibt den ASCII-Code des angegebenen Zeichens zurück.\n\nDiese Funktion nimmt ein einzelnes Zeichen (ohne Leerzeichen) als Eingabe und gibt dessen ASCII-Code als Ganzzahl zurück. Der ASCII-Wert wird basierend auf der Darstellung des Zeichens in der ASCII-Tabelle bestimmt.\n\n- Parameter character: Ein `Character`-Wert, der ein sichtbares Zeichen (ohne Leerzeichen) darstellt.\n\n- Rückgabe: Ein `Int`, der den ASCII-Code des angegebenen Zeichens darstellt.\n\n### Beispiel:\nasciiCode(of: \"A\") // Gibt 65 zurück\nasciiCode(of: \"a\") // Gibt 97 zurück",
      "ha": "Rubuta aikin Swift `func asciiCode(of character: Character) -> Int {` don magance matsalar mai zuwa:\nDawo da lambar ASCII na harafin da aka bayar.\n\nWannan aikin yana karɓar harafi guda ɗaya (ban da sarari) a matsayin shigarwa kuma yana dawo da lambar ASCII a matsayin cikakken lamba. Ana ƙayyade ƙimar ASCII bisa wakilcin harafin a cikin teburin ASCII.\n\n- Ma'aunin harafi: Darajar `Character` da ke wakiltar harafi mai gani (ban da sarari).\n\n- Dawo da: `Int` da ke wakiltar lambar ASCII na harafin da aka bayar.\n\n### Misali:\nasciiCode(of: \"A\") // Dawo da 65\nasciiCode(of: \"a\") // Dawo da 97",
      "hi": "Swift फ़ंक्शन `func asciiCode(of character: Character) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर का ASCII कोड लौटाता है।\n\nयह फ़ंक्शन एकल अक्षर (स्पेस को छोड़कर) को इनपुट के रूप में लेता है और उसके ASCII कोड को पूर्णांक के रूप में लौटाता है। ASCII मान ASCII तालिका में अक्षर के प्रतिनिधित्व के आधार पर निर्धारित किया जाता है।\n\n- पैरामीटर character: एक `Character` मान जो एक दृश्य अक्षर का प्रतिनिधित्व करता है (स्पेस को छोड़कर)।\n\n- रिटर्न्स: एक `Int` जो दिए गए अक्षर के ASCII कोड का प्रतिनिधित्व करता है।\n\n### उदाहरण:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97",
      "hu": "Írj egy Swift függvényt `func asciiCode(of character: Character) -> Int {` a következő probléma megoldására:\nVisszaadja a megadott karakter ASCII kódját.\n\nEz a függvény egyetlen karaktert (kivéve a szóközt) vesz be bemenetként, és visszaadja annak ASCII kódját egész számként. Az ASCII értéket a karakter ASCII táblázatbeli ábrázolása alapján határozza meg.\n\n- Paraméter karakter: Egy `Character` érték, amely egy látható karaktert képvisel (kivéve a szóközt).\n\n- Visszatér: Egy `Int`, amely a megadott karakter ASCII kódját képviseli.\n\n### Példa:\nasciiCode(of: \"A\") // Visszaadja 65\nasciiCode(of: \"a\") // Visszaadja 97"
    },
    "instruction_bertscore": {
      "sq": "0.998787361523782",
      "hy": "0.9710474370299736",
      "bn": "0.9893804253083507",
      "bg": "0.9844885562842235",
      "zh": "0.9958404811907484",
      "fr": "0.998787361523782",
      "de": "0.9766454370586799",
      "ha": "0.9854036464496513",
      "hi": "0.9834582604977955",
      "hu": "0.999999801369619"
    },
    "level": "easy",
    "test": "func testAsciiCode() {\n    assert(asciiCode(of: \"A\") == 65, \"Test Case 1 Failed\")\n    assert(asciiCode(of: \"a\") == 97, \"Test Case 2 Failed\")\n    assert(asciiCode(of: \"0\") == 48, \"Test Case 3 Failed\")\n    assert(asciiCode(of: \"#\") == 35, \"Test Case 4 Failed\")\n    assert(asciiCode(of: \"Z\") == 90, \"Test Case 5 Failed\")\n    assert(asciiCode(of: \"z\") == 122, \"Test Case 6 Failed\")\n}\n\ntestAsciiCode()",
    "entry_point": "asciiCode",
    "signature": "func asciiCode(of character: Character) -> Int {",
    "docstring": {
      "en": "\nReturns the ASCII code of the given character.\n\nThis function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n- Parameter character: A `Character` value representing a visible character (excluding space).\n\n- Returns: An `Int` representing the ASCII code of the given character.\n\n### Example:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97\n",
      "sq": "Kthen kodin ASCII të karakterit të dhënë.\n\nKjo funksion merr një karakter të vetëm (përjashto hapësirën) si hyrje dhe kthen kodin e tij ASCII si një numër i plotë. Vlera ASCII përcaktohet bazuar në përfaqësimin e karakterit në tabelën ASCII.\n\n- Parametri karakter: Një vlerë `Character` që përfaqëson një karakter të dukshëm (përjashto hapësirën).\n\n- Kthen: Një `Int` që përfaqëson kodin ASCII të karakterit të dhënë.\n\n### Shembull:\nasciiCode(of: \"A\") // Kthen 65\nasciiCode(of: \"a\") // Kthen 97",
      "hy": "Վերադարձնում է տրված նշանի ASCII կոդը։\n\nԱյս ֆունկցիան ընդունում է մեկ նշան (բացառությամբ բացատ) որպես մուտք և վերադարձնում է դրա ASCII կոդը որպես ամբողջ թիվ։ ASCII արժեքը որոշվում է նշանի ներկայացմամբ ASCII աղյուսակում։\n\n- Պարամետր character: `Character` արժեք, որը ներկայացնում է տեսանելի նշան (բացառությամբ բացատ)։\n\n- Վերադարձնում է: `Int`, որը ներկայացնում է տրված նշանի ASCII կոդը։\n\n### Օրինակ:\nasciiCode(of: \"A\") // Վերադարձնում է 65\nasciiCode(of: \"a\") // Վերադարձնում է 97",
      "bn": "প্রদত্ত অক্ষরের ASCII কোড প্রদান করে।\n\nএই ফাংশনটি একটি একক অক্ষর (স্পেস বাদে) ইনপুট হিসাবে গ্রহণ করে এবং এর ASCII কোডটি একটি পূর্ণসংখ্যা হিসাবে প্রদান করে। ASCII মানটি ASCII টেবিলে অক্ষরের উপস্থাপনার উপর ভিত্তি করে নির্ধারিত হয়।\n\n- প্যারামিটার character: একটি `Character` মান যা একটি দৃশ্যমান অক্ষরকে উপস্থাপন করে (স্পেস বাদে)।\n\n- রিটার্নস: একটি `Int` যা প্রদত্ত অক্ষরের ASCII কোডকে উপস্থাপন করে।\n\n### উদাহরণ:\nasciiCode(of: \"A\") // 65 প্রদান করে\nasciiCode(of: \"a\") // 97 প্রদান করে",
      "bg": "Връща ASCII кода на дадения символ.\n\nТази функция приема един символ (без интервал) като вход и връща неговия ASCII код като цяло число. ASCII стойността се определя въз основа на представянето на символа в ASCII таблицата.\n\n- Параметър character: Стойност от тип `Character`, представляваща видим символ (без интервал).\n\n- Връща: `Int`, представляващ ASCII кода на дадения символ.\n\n### Пример:\nasciiCode(of: \"A\") // Връща 65\nasciiCode(of: \"a\") // Връща 97",
      "zh": "返回给定字符的ASCII码。\n\n此函数接受一个单个字符（不包括空格）作为输入，并返回其ASCII码作为整数。ASCII值是根据字符在ASCII表中的表示来确定的。\n\n- 参数 character: 一个 `Character` 值，表示一个可见字符（不包括空格）。\n\n- 返回: 一个 `Int`，表示给定字符的ASCII码。\n\n### 示例:\nasciiCode(of: \"A\") // 返回 65\nasciiCode(of: \"a\") // 返回 97",
      "fr": "Retourne le code ASCII du caractère donné.\n\nCette fonction prend un seul caractère (à l'exclusion de l'espace) en entrée et retourne son code ASCII sous forme d'entier. La valeur ASCII est déterminée en fonction de la représentation du caractère dans la table ASCII.\n\n- Paramètre character: Une valeur `Character` représentant un caractère visible (à l'exclusion de l'espace).\n\n- Retourne: Un `Int` représentant le code ASCII du caractère donné.\n\n### Exemple:\nasciiCode(of: \"A\") // Retourne 65\nasciiCode(of: \"a\") // Retourne 97",
      "de": "Gibt den ASCII-Code des angegebenen Zeichens zurück.\n\nDiese Funktion nimmt ein einzelnes Zeichen (ohne Leerzeichen) als Eingabe und gibt dessen ASCII-Code als Ganzzahl zurück. Der ASCII-Wert wird basierend auf der Darstellung des Zeichens in der ASCII-Tabelle bestimmt.\n\n- Parameter character: Ein `Character`-Wert, der ein sichtbares Zeichen (ohne Leerzeichen) darstellt.\n\n- Rückgabe: Ein `Int`, der den ASCII-Code des angegebenen Zeichens darstellt.\n\n### Beispiel:\nasciiCode(of: \"A\") // Gibt 65 zurück\nasciiCode(of: \"a\") // Gibt 97 zurück",
      "ha": "Yana dawo da lambar ASCII na harafin da aka bayar.\n\nWannan aikin yana ɗaukar harafi guda ɗaya (ban da sarari) azaman shigarwa kuma yana dawo da lambar ASCII ɗinsa azaman cikakken lamba. Ana ƙayyade ƙimar ASCII bisa wakilcin harafin a cikin teburin ASCII.\n\n- Ma'auni character: Ƙimar `Character` da ke wakiltar harafi mai gani (ban da sarari).\n\n- Yana dawowa: `Int` da ke wakiltar lambar ASCII na harafin da aka bayar.\n\n### Misali:\nasciiCode(of: \"A\") // Yana dawowa 65\nasciiCode(of: \"a\") // Yana dawowa 97",
      "hi": "दिए गए वर्ण का ASCII कोड लौटाता है।\n\nयह फ़ंक्शन एकल वर्ण (स्पेस को छोड़कर) को इनपुट के रूप में लेता है और उसके ASCII कोड को पूर्णांक के रूप में लौटाता है। ASCII मान ASCII तालिका में वर्ण के प्रतिनिधित्व के आधार पर निर्धारित होता है।\n\n- पैरामीटर character: एक `Character` मान जो एक दृश्य वर्ण का प्रतिनिधित्व करता है (स्पेस को छोड़कर)।\n\n- रिटर्न: एक `Int` जो दिए गए वर्ण के ASCII कोड का प्रतिनिधित्व करता है।\n\n### उदाहरण:\nasciiCode(of: \"A\") // 65 लौटाता है\nasciiCode(of: \"a\") // 97 लौटाता है",
      "hu": "Visszaadja a megadott karakter ASCII kódját.\n\nEz a függvény egyetlen karaktert (kivéve a szóközt) vesz be bemenetként, és visszaadja annak ASCII kódját egész számként. Az ASCII értéket a karakter ASCII táblázatbeli ábrázolása alapján határozzák meg.\n\n- Paraméter karakter: Egy `Character` érték, amely egy látható karaktert képvisel (kivéve a szóközt).\n\n- Visszatér: Egy `Int`, amely a megadott karakter ASCII kódját képviseli.\n\n### Példa:\nasciiCode(of: \"A\") // Visszaadja 65\nasciiCode(of: \"a\") // Visszaadja 97"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9824458414456607",
      "bn": "0.9949361170658966",
      "bg": "0.9729000625938861",
      "zh": "0.8899035496607443",
      "fr": "1",
      "de": "0.9717926982196166",
      "ha": "0.9907978517074157",
      "hi": "0.7644581352573986",
      "hu": "0.9910056190859782"
    }
  },
  {
    "task_id": "Swift/43",
    "prompt": {
      "en": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Returns the character corresponding to the given ASCII code.\n\n    This function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n    - Parameter code: An `Int` value representing the ASCII code.\n\n    - Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n    ### Example:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "sq": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Kthen karakterin që korrespondon me kodin e dhënë ASCII.\n\n    Kjo funksion merr një numër të plotë që përfaqëson një kod ASCII dhe kthen karakterin përkatës. Funksioni siguron që kodi i hyrjes të jetë brenda intervalit të karaktereve të printueshme ASCII (më i madh se 0 dhe më i vogël se 128).\n\n    - Parametri code: Një vlerë `Int` që përfaqëson kodin ASCII.\n\n    - Kthen: Një `Character?` që përfaqëson karakterin përkatës nëse kodi është brenda intervalit të printueshëm ASCII; përndryshe, `nil`.\n\n    ### Shembull:\n    characterForAsciiCode(65) // Kthen \"A\"\n    characterForAsciiCode(97) // Kthen \"a\"\n    */",
      "hy": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Վերադարձնում է տրված ASCII կոդին համապատասխանող սիմվոլը։\n\n    Այս ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ASCII կոդը և վերադարձնում է համապատասխան սիմվոլը։ Ֆունկցիան ապահովում է, որ մուտքային կոդը գտնվում է տպվող ASCII սիմվոլների տիրույթում (ավելի մեծ քան 0 և ավելի փոքր քան 128)։\n\n    - Պարամետր code: `Int` արժեք, որը ներկայացնում է ASCII կոդը։\n\n    - Վերադարձնում է: `Character?`, որը ներկայացնում է համապատասխան սիմվոլը, եթե կոդը գտնվում է տպվող ASCII տիրույթում; հակառակ դեպքում՝ `nil`։\n\n    ### Օրինակ:\n    characterForAsciiCode(65) // Վերադարձնում է \"A\"\n    characterForAsciiCode(97) // Վերադարձնում է \"a\"\n    */",
      "bn": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    প্রদত্ত ASCII কোডের সাথে সম্পর্কিত অক্ষরটি ফেরত দেয়।\n\n    এই ফাংশনটি একটি পূর্ণসংখ্যা নেয় যা একটি ASCII কোডকে উপস্থাপন করে এবং সংশ্লিষ্ট অক্ষরটি ফেরত দেয়। ফাংশনটি নিশ্চিত করে যে ইনপুট কোডটি প্রিন্টেবল ASCII অক্ষরের সীমার মধ্যে রয়েছে (0 এর বেশি এবং 128 এর কম)।\n\n    - Parameter code: একটি `Int` মান যা ASCII কোডকে উপস্থাপন করে।\n\n    - Returns: একটি `Character?` যা প্রিন্টেবল ASCII সীমার মধ্যে কোড থাকলে সংশ্লিষ্ট অক্ষরটি উপস্থাপন করে; অন্যথায়, `nil`।\n\n    ### উদাহরণ:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "bg": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Връща символа, съответстващ на дадения ASCII код.\n\n    Тази функция приема цяло число, представляващо ASCII код, и връща съответния символ. Функцията гарантира, че входният код е в диапазона на печатните ASCII символи (по-голям от 0 и по-малък от 128).\n\n    - Параметър code: Стойност `Int`, представляваща ASCII кода.\n\n    - Връща: `Character?`, представляващ съответния символ, ако кодът е в диапазона на печатните ASCII символи; в противен случай, `nil`.\n\n    ### Пример:\n    characterForAsciiCode(65) // Връща \"A\"\n    characterForAsciiCode(97) // Връща \"a\"\n    */",
      "zh": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    返回与给定ASCII码对应的字符。\n\n    此函数接受一个表示ASCII码的整数，并返回对应的字符。函数确保输入的代码在可打印的ASCII字符范围内（大于0且小于128）。\n\n    - 参数 code: 表示ASCII码的`Int`值。\n\n    - 返回: 如果代码在可打印的ASCII范围内，则返回对应的`Character?`；否则返回`nil`。\n\n    ### 示例:\n    characterForAsciiCode(65) // 返回 \"A\"\n    characterForAsciiCode(97) // 返回 \"a\"\n    */",
      "fr": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Renvoie le caractère correspondant au code ASCII donné.\n\n    Cette fonction prend un entier représentant un code ASCII et renvoie le caractère correspondant. La fonction s'assure que le code d'entrée est dans la plage des caractères ASCII imprimables (supérieur à 0 et inférieur à 128).\n\n    - Paramètre code: Une valeur `Int` représentant le code ASCII.\n\n    - Renvoie: Un `Character?` représentant le caractère correspondant si le code est dans la plage des caractères ASCII imprimables; sinon, `nil`.\n\n    ### Exemple:\n    characterForAsciiCode(65) // Renvoie \"A\"\n    characterForAsciiCode(97) // Renvoie \"a\"\n    */",
      "de": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Gibt das Zeichen zurück, das dem angegebenen ASCII-Code entspricht.\n\n    Diese Funktion nimmt eine ganze Zahl, die einen ASCII-Code darstellt, und gibt das entsprechende Zeichen zurück. Die Funktion stellt sicher, dass der Eingabecode innerhalb des Bereichs der druckbaren ASCII-Zeichen liegt (größer als 0 und kleiner als 128).\n\n    - Parameter code: Ein `Int`-Wert, der den ASCII-Code darstellt.\n\n    - Rückgabe: Ein `Character?`, der das entsprechende Zeichen darstellt, wenn der Code innerhalb des druckbaren ASCII-Bereichs liegt; andernfalls `nil`.\n\n    ### Beispiel:\n    characterForAsciiCode(65) // Gibt \"A\" zurück\n    characterForAsciiCode(97) // Gibt \"a\" zurück\n    */",
      "ha": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Yana dawo da harafin da ya dace da lambar ASCII da aka bayar.\n\n    Wannan aikin yana daukar lamba mai wakiltar lambar ASCII kuma yana dawo da harafin da ya dace. Aikin yana tabbatar da cewa lambar da aka shigar tana cikin kewayon haruffan ASCII masu iya bugawa (fiye da 0 kuma kasa da 128).\n\n    - Ma'auni code: Darajar `Int` da ke wakiltar lambar ASCII.\n\n    - Yana dawowa: `Character?` da ke wakiltar harafin da ya dace idan lambar tana cikin kewayon ASCII mai iya bugawa; in ba haka ba, `nil`.\n\n    ### Misali:\n    characterForAsciiCode(65) // Yana dawowa \"A\"\n    characterForAsciiCode(97) // Yana dawowa \"a\"\n    */",
      "hi": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    दिए गए ASCII कोड के अनुरूप वर्ण लौटाता है।\n\n    यह फ़ंक्शन एक पूर्णांक लेता है जो एक ASCII कोड का प्रतिनिधित्व करता है और संबंधित वर्ण लौटाता है। यह फ़ंक्शन सुनिश्चित करता है कि इनपुट कोड प्रिंट करने योग्य ASCII वर्णों की सीमा के भीतर है (0 से अधिक और 128 से कम)।\n\n    - Parameter code: एक `Int` मान जो ASCII कोड का प्रतिनिधित्व करता है।\n\n    - Returns: एक `Character?` जो प्रिंट करने योग्य ASCII सीमा के भीतर कोड होने पर संबंधित वर्ण का प्रतिनिधित्व करता है; अन्यथा, `nil`।\n\n    ### उदाहरण:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "hu": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Visszaadja a megadott ASCII kódnak megfelelő karaktert.\n\n    Ez a függvény egy egész számot vesz át, amely egy ASCII kódot képvisel, és visszaadja a megfelelő karaktert. A függvény biztosítja, hogy a bemeneti kód a nyomtatható ASCII karakterek tartományán belül legyen (nagyobb mint 0 és kisebb mint 128).\n\n    - Parameter code: Egy `Int` érték, amely az ASCII kódot képviseli.\n\n    - Returns: Egy `Character?`, amely a megfelelő karaktert képviseli, ha a kód a nyomtatható ASCII tartományon belül van; ellenkező esetben `nil`.\n\n    ### Példa:\n    characterForAsciiCode(65) // Visszaadja \"A\"\n    characterForAsciiCode(97) // Visszaadja \"a\"\n    */"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9874104091892467",
      "bn": "0.9938726500058358",
      "bg": "0.9891609387373071",
      "zh": "0.9778898563958635",
      "fr": "0.9937407594328286",
      "de": "0.9917624008377212",
      "ha": "0.9810798603152838",
      "hi": "0.9849342828592658",
      "hu": "1"
    },
    "canonical_solution": "    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}",
    "instruction": {
      "en": "Write a Swift function `func characterForAsciiCode(_ code: Int) -> Character? {` to solve the following problem:\nReturns the character corresponding to the given ASCII code.\n\nThis function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n- Parameter code: An `Int` value representing the ASCII code.\n\n- Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n### Example:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"\n",
      "sq": "Shkruani një funksion Swift `func characterForAsciiCode(_ code: Int) -> Character? {` për të zgjidhur problemin e mëposhtëm:\nKthen karakterin që korrespondon me kodin e dhënë ASCII.\n\nKy funksion merr një numër të plotë që përfaqëson një kod ASCII dhe kthen karakterin përkatës. Funksioni siguron që kodi i hyrjes të jetë brenda intervalit të karaktereve të printueshme ASCII (më i madh se 0 dhe më i vogël se 128).\n\n- Parametri code: Një vlerë `Int` që përfaqëson kodin ASCII.\n\n- Kthen: Një `Character?` që përfaqëson karakterin përkatës nëse kodi është brenda intervalit të karaktereve të printueshme ASCII; përndryshe, `nil`.\n\n### Shembull:\ncharacterForAsciiCode(65) // Kthen \"A\"\ncharacterForAsciiCode(97) // Kthen \"a\"",
      "hy": "Գրեք Swift ֆունկցիա `func characterForAsciiCode(_ code: Int) -> Character? {` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնում է տրված ASCII կոդին համապատասխանող սիմվոլը։\n\nԱյս ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ASCII կոդը և վերադարձնում է համապատասխան սիմվոլը։ Ֆունկցիան ապահովում է, որ մուտքային կոդը գտնվում է տպվող ASCII սիմվոլների տիրույթում (մեծ է 0-ից և փոքր է 128-ից)։\n\n- Պարամետր code: `Int` արժեք, որը ներկայացնում է ASCII կոդը։\n\n- Վերադարձնում է: `Character?`, որը ներկայացնում է համապատասխան սիմվոլը, եթե կոդը գտնվում է տպվող ASCII տիրույթում; հակառակ դեպքում՝ `nil`։\n\n### Օրինակ:\ncharacterForAsciiCode(65) // Վերադարձնում է \"A\"\ncharacterForAsciiCode(97) // Վերադարձնում է \"a\"",
      "bn": "একটি Swift ফাংশন `func characterForAsciiCode(_ code: Int) -> Character? {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত ASCII কোডের সাথে সম্পর্কিত অক্ষরটি ফেরত দেয়।\n\nএই ফাংশনটি একটি পূর্ণসংখ্যা নেয় যা একটি ASCII কোডকে উপস্থাপন করে এবং সংশ্লিষ্ট অক্ষরটি ফেরত দেয়। ফাংশনটি নিশ্চিত করে যে ইনপুট কোডটি মুদ্রণযোগ্য ASCII অক্ষরের সীমার মধ্যে রয়েছে (0 এর চেয়ে বড় এবং 128 এর চেয়ে কম)।\n\n- প্যারামিটার কোড: একটি `Int` মান যা ASCII কোডকে উপস্থাপন করে।\n\n- রিটার্নস: একটি `Character?` যা মুদ্রণযোগ্য ASCII সীমার মধ্যে কোড থাকলে সংশ্লিষ্ট অক্ষরটি উপস্থাপন করে; অন্যথায়, `nil`।\n\n### উদাহরণ:\ncharacterForAsciiCode(65) // \"A\" ফেরত দেয়\ncharacterForAsciiCode(97) // \"a\" ফেরত দেয়",
      "bg": "Напишете функция на Swift `func characterForAsciiCode(_ code: Int) -> Character? {` за решаване на следния проблем:\nВръща символа, съответстващ на дадения ASCII код.\n\nТази функция приема цяло число, представляващо ASCII код, и връща съответния символ. Функцията гарантира, че входният код е в рамките на диапазона на печатните ASCII символи (по-голям от 0 и по-малък от 128).\n\n- Параметър code: Стойност от тип `Int`, представляваща ASCII кода.\n\n- Връща: `Character?`, представляващ съответния символ, ако кодът е в рамките на печатния ASCII диапазон; в противен случай, `nil`.\n\n### Пример:\ncharacterForAsciiCode(65) // Връща \"A\"\ncharacterForAsciiCode(97) // Връща \"a\"",
      "zh": "编写一个 Swift 函数 `func characterForAsciiCode(_ code: Int) -> Character? {` 来解决以下问题：\n返回与给定 ASCII 代码对应的字符。\n\n此函数接受一个表示 ASCII 代码的整数，并返回相应的字符。函数确保输入代码在可打印的 ASCII 字符范围内（大于 0 且小于 128）。\n\n- 参数 code: 一个表示 ASCII 代码的 `Int` 值。\n\n- 返回: 如果代码在可打印的 ASCII 范围内，返回对应的 `Character?`；否则返回 `nil`。\n\n### 示例:\ncharacterForAsciiCode(65) // 返回 \"A\"\ncharacterForAsciiCode(97) // 返回 \"a\"",
      "fr": "Écrire une fonction Swift `func characterForAsciiCode(_ code: Int) -> Character? {` pour résoudre le problème suivant :\nRenvoie le caractère correspondant au code ASCII donné.\n\nCette fonction prend un entier représentant un code ASCII et renvoie le caractère correspondant. La fonction s'assure que le code d'entrée est dans la plage des caractères ASCII imprimables (supérieur à 0 et inférieur à 128).\n\n- Paramètre code : Une valeur `Int` représentant le code ASCII.\n\n- Renvoie : Un `Character?` représentant le caractère correspondant si le code est dans la plage des caractères imprimables ; sinon, `nil`.\n\n### Exemple :\ncharacterForAsciiCode(65) // Renvoie \"A\"\ncharacterForAsciiCode(97) // Renvoie \"a\"",
      "de": "Schreiben Sie eine Swift-Funktion `func characterForAsciiCode(_ code: Int) -> Character? {`, um das folgende Problem zu lösen:\nGibt das Zeichen zurück, das dem angegebenen ASCII-Code entspricht.\n\nDiese Funktion nimmt eine Ganzzahl, die einen ASCII-Code darstellt, und gibt das entsprechende Zeichen zurück. Die Funktion stellt sicher, dass der Eingabecode innerhalb des Bereichs der druckbaren ASCII-Zeichen liegt (größer als 0 und kleiner als 128).\n\n- Parameter code: Ein `Int`-Wert, der den ASCII-Code darstellt.\n\n- Rückgabe: Ein `Character?`, das das entsprechende Zeichen darstellt, wenn der Code innerhalb des druckbaren ASCII-Bereichs liegt; andernfalls `nil`.\n\n### Beispiel:\ncharacterForAsciiCode(65) // Gibt \"A\" zurück\ncharacterForAsciiCode(97) // Gibt \"a\" zurück",
      "ha": "Rubuta aikin Swift `func characterForAsciiCode(_ code: Int) -> Character? {` don warware matsalar mai zuwa:\nDawo da harafin da ya dace da lambar ASCII da aka bayar.\n\nWannan aikin yana karɓar lamba mai wakiltar lambar ASCII kuma yana dawo da harafin da ya dace. Aikin yana tabbatar da cewa lambar da aka shigar tana cikin kewayon haruffan ASCII masu bugawa (fiye da 0 kuma ƙasa da 128).\n\n- Ma'aunin code: Darajar `Int` mai wakiltar lambar ASCII.\n\n- Komawa: `Character?` mai wakiltar harafin da ya dace idan lambar tana cikin kewayon ASCII mai bugawa; in ba haka ba, `nil`.\n\n### Misali:\ncharacterForAsciiCode(65) // Yana dawowa \"A\"\ncharacterForAsciiCode(97) // Yana dawowa \"a\"",
      "hi": "Swift फ़ंक्शन `func characterForAsciiCode(_ code: Int) -> Character? {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए ASCII कोड के अनुरूप वर्ण लौटाता है।\n\nयह फ़ंक्शन एक पूर्णांक लेता है जो एक ASCII कोड का प्रतिनिधित्व करता है और संबंधित वर्ण लौटाता है। यह फ़ंक्शन सुनिश्चित करता है कि इनपुट कोड प्रिंट करने योग्य ASCII वर्णों की सीमा के भीतर है (0 से अधिक और 128 से कम)।\n\n- पैरामीटर code: एक `Int` मान जो ASCII कोड का प्रतिनिधित्व करता है।\n\n- रिटर्न्स: एक `Character?` जो प्रिंट करने योग्य ASCII रेंज के भीतर कोड होने पर संबंधित वर्ण का प्रतिनिधित्व करता है; अन्यथा, `nil`।\n\n### उदाहरण:\ncharacterForAsciiCode(65) // \"A\" लौटाता है\ncharacterForAsciiCode(97) // \"a\" लौटाता है",
      "hu": "Írj egy Swift függvényt `func characterForAsciiCode(_ code: Int) -> Character? {` a következő probléma megoldására:\nVisszaadja a megadott ASCII kódnak megfelelő karaktert.\n\nEz a függvény egy egész számot vesz át, amely egy ASCII kódot képvisel, és visszaadja a megfelelő karaktert. A függvény biztosítja, hogy a bemeneti kód a nyomtatható ASCII karakterek tartományán belül legyen (nagyobb mint 0 és kisebb mint 128).\n\n- Paraméter code: Egy `Int` érték, amely az ASCII kódot képviseli.\n\n- Visszatérési érték: Egy `Character?`, amely a megfelelő karaktert képviseli, ha a kód a nyomtatható ASCII tartományon belül van; ellenkező esetben `nil`.\n\n### Példa:\ncharacterForAsciiCode(65) // Visszaadja \"A\"\ncharacterForAsciiCode(97) // Visszaadja \"a\""
    },
    "instruction_bertscore": {
      "sq": "0.9951015761732986",
      "hy": "0.9931784368241189",
      "bn": "0.9949684938180052",
      "bg": "0.9818066488794904",
      "zh": "0.9783951720852162",
      "fr": "0.9929718612278425",
      "de": "0.9892868703988833",
      "ha": "0.982156834241255",
      "hi": "0.9747856608010502",
      "hu": "0.9879884235980583"
    },
    "level": "easy",
    "test": "func testCharacterForAsciiCode() {\n    assert(characterForAsciiCode(65) == \"A\", \"Test Case 1 Failed\")\n    assert(characterForAsciiCode(97) == \"a\", \"Test Case 2 Failed\")\n    assert(characterForAsciiCode(48) == \"0\", \"Test Case 3 Failed\")\n    assert(characterForAsciiCode(35) == \"#\", \"Test Case 4 Failed\")\n    assert(characterForAsciiCode(90) == \"Z\", \"Test Case 5 Failed\")\n    assert(characterForAsciiCode(122) == \"z\", \"Test Case 6 Failed\")\n}\n\ntestCharacterForAsciiCode()",
    "entry_point": "characterForAsciiCode",
    "signature": "func characterForAsciiCode(_ code: Int) -> Character? {",
    "docstring": {
      "en": "\nReturns the character corresponding to the given ASCII code.\n\nThis function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n- Parameter code: An `Int` value representing the ASCII code.\n\n- Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n### Example:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"\n",
      "sq": "Kthen karakterin që korrespondon me kodin e dhënë ASCII.\n\nKjo funksion merr një numër të plotë që përfaqëson një kod ASCII dhe kthen karakterin përkatës. Funksioni siguron që kodi i hyrjes është brenda intervalit të karaktereve të printueshme ASCII (më i madh se 0 dhe më i vogël se 128).\n\n- Parametri code: Një vlerë `Int` që përfaqëson kodin ASCII.\n\n- Kthen: Një `Character?` që përfaqëson karakterin përkatës nëse kodi është brenda intervalit të printueshëm ASCII; përndryshe, `nil`.\n\n### Shembull:\ncharacterForAsciiCode(65) // Kthen \"A\"\ncharacterForAsciiCode(97) // Kthen \"a\"",
      "hy": "Վերադարձնում է տրված ASCII կոդին համապատասխանող սիմվոլը։\n\nԱյս ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ASCII կոդը և վերադարձնում է համապատասխանող սիմվոլը։ Ֆունկցիան ապահովում է, որ մուտքային կոդը լինի տպվող ASCII սիմվոլների տիրույթում (ավելի մեծ քան 0 և ավելի փոքր քան 128)։\n\n- Պարամետր code: `Int` արժեք, որը ներկայացնում է ASCII կոդը։\n\n- Վերադարձնում է: `Character?`, որը ներկայացնում է համապատասխանող սիմվոլը, եթե կոդը գտնվում է տպվող ASCII տիրույթում; հակառակ դեպքում՝ `nil`։\n\n### Օրինակ:\ncharacterForAsciiCode(65) // Վերադարձնում է \"A\"\ncharacterForAsciiCode(97) // Վերադարձնում է \"a\"",
      "bn": "প্রদত্ত ASCII কোডের সাথে সম্পর্কিত অক্ষরটি ফেরত দেয়।\n\nএই ফাংশনটি একটি পূর্ণসংখ্যা গ্রহণ করে যা একটি ASCII কোডকে উপস্থাপন করে এবং সংশ্লিষ্ট অক্ষরটি ফেরত দেয়। ফাংশনটি নিশ্চিত করে যে ইনপুট কোডটি মুদ্রণযোগ্য ASCII অক্ষরের সীমার মধ্যে রয়েছে (0 এর চেয়ে বড় এবং 128 এর চেয়ে ছোট)।\n\n- প্যারামিটার কোড: একটি `Int` মান যা ASCII কোডকে উপস্থাপন করে।\n\n- রিটার্নস: একটি `Character?` যা মুদ্রণযোগ্য ASCII সীমার মধ্যে কোড থাকলে সংশ্লিষ্ট অক্ষরকে উপস্থাপন করে; অন্যথায়, `nil`।\n\n### উদাহরণ:\ncharacterForAsciiCode(65) // \"A\" ফেরত দেয়\ncharacterForAsciiCode(97) // \"a\" ফেরত দেয়",
      "bg": "Връща символа, съответстващ на дадения ASCII код.\n\nТази функция приема цяло число, представляващо ASCII код, и връща съответния символ. Функцията гарантира, че входният код е в диапазона на печатаемите ASCII символи (по-голям от 0 и по-малък от 128).\n\n- Параметър code: Стойност от тип `Int`, представляваща ASCII кода.\n\n- Връща: `Character?`, представляващ съответния символ, ако кодът е в диапазона на печатаемите ASCII символи; в противен случай, `nil`.\n\n### Пример:\ncharacterForAsciiCode(65) // Връща \"A\"\ncharacterForAsciiCode(97) // Връща \"a\"",
      "zh": "返回与给定 ASCII 代码对应的字符。\n\n此函数接受一个表示 ASCII 代码的整数，并返回相应的字符。该函数确保输入代码在可打印的 ASCII 字符范围内（大于 0 且小于 128）。\n\n- 参数 code: 一个表示 ASCII 代码的 `Int` 值。\n\n- 返回: 一个 `Character?`，如果代码在可打印 ASCII 范围内，则表示相应的字符；否则为 `nil`。\n\n### 示例:\ncharacterForAsciiCode(65) // 返回 \"A\"\ncharacterForAsciiCode(97) // 返回 \"a\"",
      "fr": "Retourne le caractère correspondant au code ASCII donné.\n\nCette fonction prend un entier représentant un code ASCII et retourne le caractère correspondant. La fonction s'assure que le code d'entrée est dans la plage des caractères ASCII imprimables (supérieur à 0 et inférieur à 128).\n\n- Paramètre code : Une valeur `Int` représentant le code ASCII.\n\n- Retourne : Un `Character?` représentant le caractère correspondant si le code est dans la plage des caractères ASCII imprimables ; sinon, `nil`.\n\n### Exemple :\ncharacterForAsciiCode(65) // Retourne \"A\"\ncharacterForAsciiCode(97) // Retourne \"a\"",
      "de": "Gibt das Zeichen zurück, das dem angegebenen ASCII-Code entspricht.\n\nDiese Funktion nimmt eine Ganzzahl, die einen ASCII-Code darstellt, und gibt das entsprechende Zeichen zurück. Die Funktion stellt sicher, dass der Eingabecode innerhalb des Bereichs der druckbaren ASCII-Zeichen liegt (größer als 0 und kleiner als 128).\n\n- Parameter code: Ein `Int`-Wert, der den ASCII-Code darstellt.\n\n- Rückgabe: Ein `Character?`, das das entsprechende Zeichen darstellt, wenn der Code innerhalb des druckbaren ASCII-Bereichs liegt; andernfalls `nil`.\n\n### Beispiel:\ncharacterForAsciiCode(65) // Gibt \"A\" zurück\ncharacterForAsciiCode(97) // Gibt \"a\" zurück",
      "ha": "Returns ɗin harafi da ya dace da lambar ASCII da aka bayar.\n\nWannan aikin yana ɗaukar lamba mai wakiltar lambar ASCII kuma yana mayar da harafin da ya dace. Aikin yana tabbatar da cewa lambar shigarwa tana cikin kewayon haruffan ASCII masu bugawa (fiye da 0 kuma ƙasa da 128).\n\n- Parameter code: Darajar `Int` da ke wakiltar lambar ASCII.\n\n- Returns: `Character?` da ke wakiltar harafin da ya dace idan lambar tana cikin kewayon haruffan ASCII masu bugawa; in ba haka ba, `nil`.\n\n### Misali:\ncharacterForAsciiCode(65) // Yana dawowa \"A\"\ncharacterForAsciiCode(97) // Yana dawowa \"a\"",
      "hi": "दिए गए ASCII कोड के अनुरूप वर्ण लौटाता है।\n\nयह फ़ंक्शन एक पूर्णांक लेता है जो एक ASCII कोड का प्रतिनिधित्व करता है और संबंधित वर्ण लौटाता है। यह फ़ंक्शन सुनिश्चित करता है कि इनपुट कोड प्रिंट करने योग्य ASCII वर्णों की सीमा के भीतर है (0 से अधिक और 128 से कम)।\n\n- पैरामीटर कोड: एक `Int` मान जो ASCII कोड का प्रतिनिधित्व करता है।\n\n- रिटर्न करता है: एक `Character?` जो संबंधित वर्ण का प्रतिनिधित्व करता है यदि कोड प्रिंट करने योग्य ASCII रेंज के भीतर है; अन्यथा, `nil`।\n\n### उदाहरण:\ncharacterForAsciiCode(65) // \"A\" लौटाता है\ncharacterForAsciiCode(97) // \"a\" लौटाता है",
      "hu": "Visszaadja a megadott ASCII kódnak megfelelő karaktert.\n\nEz a függvény egy egész számot vesz át, amely egy ASCII kódot képvisel, és visszaadja a megfelelő karaktert. A függvény biztosítja, hogy a bemeneti kód a nyomtatható ASCII karakterek tartományában legyen (nagyobb, mint 0 és kisebb, mint 128).\n\n- Paraméter code: Egy `Int` érték, amely az ASCII kódot képviseli.\n\n- Visszatérési érték: Egy `Character?`, amely a megfelelő karaktert képviseli, ha a kód a nyomtatható ASCII tartományban van; ellenkező esetben `nil`.\n\n### Példa:\ncharacterForAsciiCode(65) // Visszaadja \"A\"\ncharacterForAsciiCode(97) // Visszaadja \"a\""
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.988891993201386",
      "bg": "0.977425657195385",
      "zh": "0.9922140863241945",
      "fr": "0.9939322391201463",
      "de": "0.9883318555268675",
      "ha": "0.9777482329341857",
      "hi": "0.9860589280766854",
      "hu": "0.9807272913889469"
    }
  },
  {
    "task_id": "Swift/44",
    "prompt": {
      "en": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Converts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n    - Parameters:\n        - value: An integer value to be converted to boolean and back to integer.\n\n    - Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n    ### Example:\n    - `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n    - `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n    - `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n    */",
      "sq": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Konverton një numër të plotë në një boolean dhe pastaj përsëri në një numër të plotë, dhe kthen vlerën e rezultuar të numrit të plotë.\n\n    - Parametra:\n        - value: Një vlerë e plotë që do të konvertohet në boolean dhe përsëri në numër të plotë.\n\n    - Kthen: Një vlerë e plotë pas konvertimit. Vlera e kthyer është 1 nëse numri i plotë origjinal ishte jo-zero; përndryshe, është 0.\n\n    ### Shembull:\n    - `convertIntToBoolToInt(5)` kthen `1`, sepse çdo numër i plotë jo-zero konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.\n    - `convertIntToBoolToInt(0)` kthen `0`, sepse `0` konvertohet në `false`, i cili pastaj konvertohet përsëri në `0`.\n    - `convertIntToBoolToInt(-10)` kthen `1`, sepse çdo numër i plotë jo-zero, përfshirë numrat negativë, konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.\n    */",
      "hy": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Փոխակերպում է ամբողջ թիվը բուլյանի, ապա նորից ամբողջ թվի, և վերադարձնում է ստացված ամբողջ թվային արժեքը:\n\n    - Պարամետրեր:\n        - value: Ամբողջ թվային արժեք, որը պետք է փոխակերպվի բուլյանի և նորից ամբողջ թվի:\n\n    - Վերադարձնում է: Ամբողջ թվային արժեք փոխակերպումից հետո: Վերադարձվող արժեքը 1 է, եթե սկզբնական ամբողջ թիվը զրոյից տարբեր էր; հակառակ դեպքում՝ 0 է:\n\n    ### Օրինակ:\n    - `convertIntToBoolToInt(5)` վերադարձնում է `1`, քանի որ ցանկացած զրոյից տարբեր ամբողջ թիվ փոխակերպվում է `true`, որը հետո նորից փոխակերպվում է `1`:\n    - `convertIntToBoolToInt(0)` վերադարձնում է `0`, քանի որ `0`-ը փոխակերպվում է `false`, որը հետո նորից փոխակերպվում է `0`:\n    - `convertIntToBoolToInt(-10)` վերադարձնում է `1`, քանի որ ցանկացած զրոյից տարբեր ամբողջ թիվ, ներառյալ բացասական թվերը, փոխակերպվում է `true`, որը հետո նորից փոխակերպվում է `1`:\n    */",
      "bn": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে এবং তারপর আবার পূর্ণসংখ্যায় রূপান্তর করে, এবং ফলস্বরূপ পূর্ণসংখ্যার মান ফেরত দেয়।\n\n    - প্যারামিটার:\n        - value: একটি পূর্ণসংখ্যার মান যা বুলিয়ানে এবং তারপর পূর্ণসংখ্যায় রূপান্তরিত হবে।\n\n    - রিটার্নস: রূপান্তরের পর একটি পূর্ণসংখ্যার মান। যদি মূল পূর্ণসংখ্যাটি শূন্য না হয় তবে রিটার্ন মান 1 হয়; অন্যথায়, এটি 0 হয়।\n\n    ### উদাহরণ:\n    - `convertIntToBoolToInt(5)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য নয় এমন পূর্ণসংখ্যা `true` তে রূপান্তরিত হয়, যা পরে `1` তে রূপান্তরিত হয়।\n    - `convertIntToBoolToInt(0)` `0` ফেরত দেয়, কারণ `0` `false` তে রূপান্তরিত হয়, যা পরে `0` তে রূপান্তরিত হয়।\n    - `convertIntToBoolToInt(-10)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য নয় এমন পূর্ণসংখ্যা, যার মধ্যে ঋণাত্মক সংখ্যাও রয়েছে, `true` তে রূপান্তরিত হয়, যা পরে `1` তে রূপান্তরিত হয়।\n    */",
      "bg": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Преобразува цяло число в булева стойност и след това обратно в цяло число, и връща получената целочислена стойност.\n\n    - Параметри:\n        - value: Цяло число, което да бъде преобразувано в булева стойност и обратно в цяло число.\n\n    - Връща: Цяло число след преобразуването. Връщаната стойност е 1, ако оригиналното цяло число е било различно от нула; в противен случай е 0.\n\n    ### Пример:\n    - `convertIntToBoolToInt(5)` връща `1`, защото всяко различно от нула цяло число се преобразува в `true`, което след това се преобразува обратно в `1`.\n    - `convertIntToBoolToInt(0)` връща `0`, защото `0` се преобразува в `false`, което след това се преобразува обратно в `0`.\n    - `convertIntToBoolToInt(-10)` връща `1`, защото всяко различно от нула цяло число, включително отрицателните числа, се преобразува в `true`, което след това се преобразува обратно в `1`.\n    */",
      "zh": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    将整数转换为布尔值，然后再转换回整数，并返回转换后的整数值。\n\n    - 参数:\n        - value: 要转换为布尔值并再转换回整数的整数值。\n\n    - 返回: 转换后的整数值。如果原始整数为非零，则返回值为1；否则为0。\n\n    ### 示例:\n    - `convertIntToBoolToInt(5)` 返回 `1`，因为任何非零整数转换为 `true`，然后再转换回 `1`。\n    - `convertIntToBoolToInt(0)` 返回 `0`，因为 `0` 转换为 `false`，然后再转换回 `0`。\n    - `convertIntToBoolToInt(-10)` 返回 `1`，因为任何非零整数，包括负数，转换为 `true`，然后再转换回 `1`。\n    */",
      "fr": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Convertit un entier en booléen puis de nouveau en entier, et renvoie la valeur entière résultante.\n\n    - Paramètres :\n        - value : Une valeur entière à convertir en booléen puis de nouveau en entier.\n\n    - Renvoie : Une valeur entière après conversion. La valeur retournée est 1 si l'entier original était non nul ; sinon, elle est 0.\n\n    ### Exemple :\n    - `convertIntToBoolToInt(5)` renvoie `1`, car tout entier non nul se convertit en `true`, qui se convertit ensuite en `1`.\n    - `convertIntToBoolToInt(0)` renvoie `0`, car `0` se convertit en `false`, qui se convertit ensuite en `0`.\n    - `convertIntToBoolToInt(-10)` renvoie `1`, car tout entier non nul, y compris les nombres négatifs, se convertit en `true`, qui se convertit ensuite en `1`.\n    */",
      "de": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Konvertiert eine ganze Zahl in einen booleschen Wert und dann zurück in eine ganze Zahl und gibt den resultierenden ganzzahligen Wert zurück.\n\n    - Parameter:\n        - value: Ein ganzzahliger Wert, der in einen booleschen Wert und zurück in eine ganze Zahl konvertiert werden soll.\n\n    - Rückgabe: Ein ganzzahliger Wert nach der Konvertierung. Der Rückgabewert ist 1, wenn die ursprüngliche ganze Zahl ungleich null war; andernfalls ist er 0.\n\n    ### Beispiel:\n    - `convertIntToBoolToInt(5)` gibt `1` zurück, weil jede von null verschiedene ganze Zahl in `true` konvertiert wird, was dann zurück in `1` konvertiert wird.\n    - `convertIntToBoolToInt(0)` gibt `0` zurück, weil `0` in `false` konvertiert wird, was dann zurück in `0` konvertiert wird.\n    - `convertIntToBoolToInt(-10)` gibt `1` zurück, weil jede von null verschiedene ganze Zahl, einschließlich negativer Zahlen, in `true` konvertiert wird, was dann zurück in `1` konvertiert wird.\n    */",
      "ha": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Yana canza lamba mai cikakken adadi zuwa boolean sannan kuma ya koma lamba mai cikakken adadi, kuma yana mayar da darajar lambar da aka samu.\n\n    - Sigogi:\n        - value: Wata lamba mai cikakken adadi da za a canza zuwa boolean kuma a mayar da ita zuwa lamba mai cikakken adadi.\n\n    - Yana Mayarwa: Wata lamba mai cikakken adadi bayan canzawa. Darajar da aka mayar ita ce 1 idan asalin lambar mai cikakken adadi ba ta kasance sifili ba; in ba haka ba, ita ce 0.\n\n    ### Misali:\n    - `convertIntToBoolToInt(5)` yana mayar da `1`, domin duk wata lamba mai cikakken adadi da ba sifili ba tana canzawa zuwa `true`, wanda sannan ya koma `1`.\n    - `convertIntToBoolToInt(0)` yana mayar da `0`, domin `0` yana canzawa zuwa `false`, wanda sannan ya koma `0`.\n    - `convertIntToBoolToInt(-10)` yana mayar da `1`, domin duk wata lamba mai cikakken adadi da ba sifili ba, ciki har da lambobi marasa kyau, tana canzawa zuwa `true`, wanda sannan ya koma `1`.\n    */",
      "hi": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    एक पूर्णांक को एक बूलियन में बदलता है और फिर वापस एक पूर्णांक में बदलता है, और परिणामी पूर्णांक मान को लौटाता है।\n\n    - पैरामीटर्स:\n        - value: एक पूर्णांक मान जो बूलियन में और फिर पूर्णांक में परिवर्तित किया जाएगा।\n\n    - रिटर्न्स: परिवर्तन के बाद एक पूर्णांक मान। यदि मूल पूर्णांक शून्य नहीं था तो रिटर्न मान 1 होता है; अन्यथा, यह 0 होता है।\n\n    ### उदाहरण:\n    - `convertIntToBoolToInt(5)` `1` लौटाता है, क्योंकि कोई भी गैर-शून्य पूर्णांक `true` में बदलता है, जो फिर वापस `1` में बदलता है।\n    - `convertIntToBoolToInt(0)` `0` लौटाता है, क्योंकि `0` `false` में बदलता है, जो फिर वापस `0` में बदलता है।\n    - `convertIntToBoolToInt(-10)` `1` लौटाता है, क्योंकि कोई भी गैर-शून्य पूर्णांक, जिसमें ऋणात्मक संख्याएँ शामिल हैं, `true` में बदलता है, जो फिर वापस `1` में बदलता है।\n    */",
      "hu": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Egy egész számot logikai értékké, majd vissza egész számmá alakít, és visszaadja a kapott egész értéket.\n\n    - Paraméterek:\n        - value: Egy egész szám érték, amelyet logikai értékké, majd vissza egész számmá kell alakítani.\n\n    - Visszatér: Egy egész szám érték az átalakítás után. A visszatérési érték 1, ha az eredeti egész szám nem nulla volt; ellenkező esetben 0.\n\n    ### Példa:\n    - `convertIntToBoolToInt(5)` visszaadja `1`, mert bármely nem nulla egész szám `true`-vá alakul, amely aztán visszaalakul `1`-re.\n    - `convertIntToBoolToInt(0)` visszaadja `0`, mert `0` `false`-vá alakul, amely aztán visszaalakul `0`-ra.\n    - `convertIntToBoolToInt(-10)` visszaadja `1`, mert bármely nem nulla egész szám, beleértve a negatív számokat is, `true`-vá alakul, amely aztán visszaalakul `1`-re.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9869932853890735",
      "hy": "0.983984631007538",
      "bn": "0.9516084747899943",
      "bg": "0.9725854320703268",
      "zh": "0.9607496435556009",
      "fr": "0.9835984935468062",
      "de": "0.9675839190758683",
      "ha": "0.9741192558726782",
      "hi": "0.979133878472285",
      "hu": "0.9763298133832155"
    },
    "canonical_solution": "    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}",
    "instruction": {
      "en": "Write a Swift function `func convertIntToBoolToInt(_ value: Int) -> Int {` to solve the following problem:\nConverts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Parameters:\n- value: An integer value to be converted to boolean and back to integer.\n\n- Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n### Example:\n- `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n- `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n- `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n",
      "sq": "Shkruani një funksion Swift `func convertIntToBoolToInt(_ value: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\nKonverton një numër të plotë në një boolean dhe pastaj përsëri në një numër të plotë, dhe kthen vlerën rezultuese të numrit të plotë.\n\n- Parametrat:\n- value: Një vlerë e plotë që do të konvertohet në boolean dhe përsëri në numër të plotë.\n\n- Kthen: Një vlerë e plotë pas konvertimit. Vlera e kthimit është 1 nëse numri i plotë origjinal ishte jo-zero; përndryshe, është 0.\n\n### Shembull:\n- `convertIntToBoolToInt(5)` kthen `1`, sepse çdo numër i plotë jo-zero konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.\n- `convertIntToBoolToInt(0)` kthen `0`, sepse `0` konvertohet në `false`, i cili pastaj konvertohet përsëri në `0`.\n- `convertIntToBoolToInt(-10)` kthen `1`, sepse çdo numër i plotë jo-zero, duke përfshirë numrat negativë, konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.",
      "hy": "Գրեք Swift ֆունկցիա `func convertIntToBoolToInt(_ value: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է ամբողջ թիվը բուլյան արժեքի, ապա հետ վերածում ամբողջ թվի և վերադարձնում է ստացված ամբողջ թիվը:\n\n- Պարամետրեր:\n- value: Ամբողջ թիվ, որը պետք է փոխակերպել բուլյան արժեքի և հետ վերածել ամբողջ թվի:\n\n- Վերադարձնում է: Ամբողջ թիվ փոխակերպումից հետո: Վերադարձվող արժեքը 1 է, եթե սկզբնական ամբողջ թիվը զրոյից տարբեր է; հակառակ դեպքում՝ 0:\n\n### Օրինակ:\n- `convertIntToBoolToInt(5)` վերադարձնում է `1`, որովհետև ցանկացած զրոյից տարբեր ամբողջ թիվ փոխակերպվում է `true`, որը հետո վերածվում է `1`:\n- `convertIntToBoolToInt(0)` վերադարձնում է `0`, որովհետև `0` փոխակերպվում է `false`, որը հետո վերածվում է `0`:\n- `convertIntToBoolToInt(-10)` վերադարձնում է `1`, որովհետև ցանկացած զրոյից տարբեր ամբողջ թիվ, ներառյալ բացասական թվերը, փոխակերպվում է `true`, որը հետո վերածվում է `1`:",
      "bn": "একটি Swift ফাংশন `func convertIntToBoolToInt(_ value: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে এবং তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে, এবং ফলস্বরূপ পূর্ণসংখ্যার মানটি ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- value: একটি পূর্ণসংখ্যার মান যা বুলিয়ানে এবং তারপর পূর্ণসংখ্যায় রূপান্তরিত হবে।\n\n- রিটার্নস: রূপান্তরের পর একটি পূর্ণসংখ্যার মান। রিটার্ন মানটি 1 হয় যদি মূল পূর্ণসংখ্যাটি শূন্য না হয়; অন্যথায়, এটি 0 হয়।\n\n### উদাহরণ:\n- `convertIntToBoolToInt(5)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য নয় এমন পূর্ণসংখ্যা `true` তে রূপান্তরিত হয়, যা পরে `1` তে রূপান্তরিত হয়।\n- `convertIntToBoolToInt(0)` `0` ফেরত দেয়, কারণ `0` `false` তে রূপান্তরিত হয়, যা পরে `0` তে রূপান্তরিত হয়।\n- `convertIntToBoolToInt(-10)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য নয় এমন পূর্ণসংখ্যা, যার মধ্যে ঋণাত্মক সংখ্যাগুলোও অন্তর্ভুক্ত, `true` তে রূপান্তরিত হয়, যা পরে `1` তে রূপান্তরিত হয়।",
      "bg": "Напишете функция на Swift `func convertIntToBoolToInt(_ value: Int) -> Int {` за решаване на следния проблем:\nПреобразува цяло число в булева стойност и след това обратно в цяло число, и връща получената стойност като цяло число.\n\n- Параметри:\n- value: Цяло число, което трябва да бъде преобразувано в булева стойност и обратно в цяло число.\n\n- Връща: Цяло число след преобразуването. Връщаната стойност е 1, ако оригиналното цяло число е било различно от нула; в противен случай е 0.\n\n### Пример:\n- `convertIntToBoolToInt(5)` връща `1`, защото всяко число, различно от нула, се преобразува в `true`, което след това се преобразува обратно в `1`.\n- `convertIntToBoolToInt(0)` връща `0`, защото `0` се преобразува в `false`, което след това се преобразува обратно в `0`.\n- `convertIntToBoolToInt(-10)` връща `1`, защото всяко число, различно от нула, включително отрицателните числа, се преобразува в `true`, което след това се преобразува обратно в `1`.",
      "zh": "编写一个 Swift 函数 `func convertIntToBoolToInt(_ value: Int) -> Int {` 来解决以下问题：\n将整数转换为布尔值，然后再转换回整数，并返回转换后的整数值。\n\n- 参数：\n- value: 要转换为布尔值并再转换回整数的整数值。\n\n- 返回：转换后的整数值。如果原始整数为非零，则返回值为 1；否则为 0。\n\n### 示例：\n- `convertIntToBoolToInt(5)` 返回 `1`，因为任何非零整数转换为 `true`，然后再转换回 `1`。\n- `convertIntToBoolToInt(0)` 返回 `0`，因为 `0` 转换为 `false`，然后再转换回 `0`。\n- `convertIntToBoolToInt(-10)` 返回 `1`，因为任何非零整数，包括负数，转换为 `true`，然后再转换回 `1`。",
      "fr": "Écrire une fonction Swift `func convertIntToBoolToInt(_ value: Int) -> Int {` pour résoudre le problème suivant :\nConvertit un entier en booléen puis de nouveau en entier, et renvoie la valeur entière résultante.\n\n- Paramètres :\n- value : Une valeur entière à convertir en booléen puis de nouveau en entier.\n\n- Renvoie : Une valeur entière après conversion. La valeur renvoyée est 1 si l'entier original était non nul ; sinon, elle est 0.\n\n### Exemple :\n- `convertIntToBoolToInt(5)` renvoie `1`, car tout entier non nul se convertit en `true`, qui se convertit ensuite en `1`.\n- `convertIntToBoolToInt(0)` renvoie `0`, car `0` se convertit en `false`, qui se convertit ensuite en `0`.\n- `convertIntToBoolToInt(-10)` renvoie `1`, car tout entier non nul, y compris les nombres négatifs, se convertit en `true`, qui se convertit ensuite en `1`.",
      "de": "Schreiben Sie eine Swift-Funktion `func convertIntToBoolToInt(_ value: Int) -> Int {`, um das folgende Problem zu lösen:\nKonvertiert eine Ganzzahl in einen Booleschen Wert und dann zurück in eine Ganzzahl und gibt den resultierenden Ganzzahlwert zurück.\n\n- Parameter:\n- value: Ein Ganzzahlwert, der in einen Booleschen Wert und zurück in eine Ganzzahl konvertiert werden soll.\n\n- Rückgabewert: Ein Ganzzahlwert nach der Konvertierung. Der Rückgabewert ist 1, wenn die ursprüngliche Ganzzahl ungleich null war; andernfalls ist er 0.\n\n### Beispiel:\n- `convertIntToBoolToInt(5)` gibt `1` zurück, weil jede ungleich null Ganzzahl in `true` konvertiert wird, was dann zurück in `1` konvertiert wird.\n- `convertIntToBoolToInt(0)` gibt `0` zurück, weil `0` in `false` konvertiert wird, was dann zurück in `0` konvertiert wird.\n- `convertIntToBoolToInt(-10)` gibt `1` zurück, weil jede ungleich null Ganzzahl, einschließlich negativer Zahlen, in `true` konvertiert wird, was dann zurück in `1` konvertiert wird.",
      "ha": "Rubuta aikin Swift `func convertIntToBoolToInt(_ value: Int) -> Int {` don warware matsalar mai zuwa:\nYa canza lamba zuwa boolean sannan kuma ya mayar da ita zuwa lamba, kuma ya dawo da darajar lambar da aka samu.\n\n- Sigogi:\n- value: Wata darajar lamba da za a canza zuwa boolean sannan kuma a mayar da ita zuwa lamba.\n\n- Komawa: Wata darajar lamba bayan canji. Darajar dawowa ita ce 1 idan asalin lambar ba ta kasance sifili ba; in ba haka ba, ita ce 0.\n\n### Misali:\n- `convertIntToBoolToInt(5)` yana dawowa `1`, saboda kowace lamba da ba ta kasance sifili ba tana canzawa zuwa `true`, wadda a nan take tana canzawa zuwa `1`.\n- `convertIntToBoolToInt(0)` yana dawowa `0`, saboda `0` yana canzawa zuwa `false`, wadda a nan take tana canzawa zuwa `0`.\n- `convertIntToBoolToInt(-10)` yana dawowa `1`, saboda kowace lamba da ba ta kasance sifili ba, ciki har da lambobi marasa kyau, tana canzawa zuwa `true`, wadda a nan take tana canzawa zuwa `1`.",
      "hi": "Swift फ़ंक्शन `func convertIntToBoolToInt(_ value: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांक को बूलियन में परिवर्तित करता है और फिर वापस पूर्णांक में, और परिणामी पूर्णांक मान लौटाता है।\n\n- पैरामीटर्स:\n- value: एक पूर्णांक मान जिसे बूलियन और फिर वापस पूर्णांक में परिवर्तित किया जाना है।\n\n- रिटर्न्स: रूपांतरण के बाद का एक पूर्णांक मान। यदि मूल पूर्णांक शून्य नहीं था तो रिटर्न मान 1 है; अन्यथा, यह 0 है।\n\n### उदाहरण:\n- `convertIntToBoolToInt(5)` `1` लौटाता है, क्योंकि कोई भी शून्य से भिन्न पूर्णांक `true` में परिवर्तित होता है, जो फिर `1` में परिवर्तित होता है।\n- `convertIntToBoolToInt(0)` `0` लौटाता है, क्योंकि `0` `false` में परिवर्तित होता है, जो फिर `0` में परिवर्तित होता है।\n- `convertIntToBoolToInt(-10)` `1` लौटाता है, क्योंकि कोई भी शून्य से भिन्न पूर्णांक, जिसमें ऋणात्मक संख्याएँ भी शामिल हैं, `true` में परिवर्तित होता है, जो फिर `1` में परिवर्तित होता है।",
      "hu": "Írj egy Swift függvényt `func convertIntToBoolToInt(_ value: Int) -> Int {` a következő probléma megoldására:\nEgész számot átalakít logikai értékké, majd vissza egész számmá, és visszaadja a kapott egész értéket.\n\n- Paraméterek:\n- value: Egy egész szám, amelyet logikai értékké, majd vissza egész számmá kell alakítani.\n\n- Visszatérési érték: Egy egész szám az átalakítás után. A visszatérési érték 1, ha az eredeti egész szám nem nulla volt; különben 0.\n\n### Példa:\n- `convertIntToBoolToInt(5)` visszaadja `1`, mert bármely nem nulla egész szám `true`-vá alakul, ami aztán vissza `1`-é alakul.\n- `convertIntToBoolToInt(0)` visszaadja `0`, mert `0` `false`-vá alakul, ami aztán vissza `0`-á alakul.\n- `convertIntToBoolToInt(-10)` visszaadja `1`, mert bármely nem nulla egész szám, beleértve a negatív számokat is, `true`-vá alakul, ami aztán vissza `1`-é alakul."
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9679116592045759",
      "bn": "0.9768528071764804",
      "bg": "0.9695948530534655",
      "zh": "0.9553695410548899",
      "fr": "0.9839286172400862",
      "de": "0.9641225860559544",
      "ha": "0.9513059607196782",
      "hi": "0.9753610930149084",
      "hu": "0.9726225759515803"
    },
    "level": "easy",
    "test": "func testConvertIntToBoolToInt() {\n    assert(convertIntToBoolToInt(5) == 1, \"Conversion of 5 should return 1.\")\n    assert(convertIntToBoolToInt(0) == 0, \"Conversion of 0 should return 0.\")\n    assert(convertIntToBoolToInt(-10) == 1, \"Conversion of -10 should return 1.\")\n    assert(convertIntToBoolToInt(1) == 1, \"Conversion of 1 should return 1.\")\n    assert(convertIntToBoolToInt(-1) == 1, \"Conversion of -1 should return 1.\")\n    assert(convertIntToBoolToInt(100) == 1, \"Conversion of 100 should return 1.\")\n    assert(convertIntToBoolToInt(-100) == 1, \"Conversion of -100 should return 1.\")\n}\n\n// Call the test function to verify the functionality\ntestConvertIntToBoolToInt()",
    "entry_point": "convertIntToBoolToInt",
    "signature": "func convertIntToBoolToInt(_ value: Int) -> Int {",
    "docstring": {
      "en": "\nConverts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Parameters:\n- value: An integer value to be converted to boolean and back to integer.\n\n- Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n### Example:\n- `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n- `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n- `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n",
      "sq": "Konverton një numër të plotë në një vlerë boolean dhe pastaj përsëri në një numër të plotë, dhe kthen vlerën e numrit të plotë që rezulton.\n\n- Parametrat:\n- value: Një vlerë e plotë që do të konvertohet në boolean dhe përsëri në numër të plotë.\n\n- Kthen: Një vlerë e plotë pas konvertimit. Vlera e kthyer është 1 nëse numri i plotë origjinal ishte jo-zero; përndryshe, është 0.\n\n### Shembull:\n- `convertIntToBoolToInt(5)` kthen `1`, sepse çdo numër i plotë jo-zero konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.\n- `convertIntToBoolToInt(0)` kthen `0`, sepse `0` konvertohet në `false`, i cili pastaj konvertohet përsëri në `0`.\n- `convertIntToBoolToInt(-10)` kthen `1`, sepse çdo numër i plotë jo-zero, përfshirë numrat negativë, konvertohet në `true`, i cili pastaj konvertohet përsëri në `1`.",
      "hy": "Վերածում է ամբողջ թիվը բուլյան արժեքի, ապա նորից ամբողջ թվի և վերադարձնում է ստացված ամբողջ թվային արժեքը:\n\n- Պարամետրեր:\n- value: Ամբողջ թվային արժեք, որը պետք է վերածվի բուլյան արժեքի և նորից ամբողջ թվի:\n\n- Վերադարձնում է: Ամբողջ թվային արժեք վերածումից հետո: Վերադարձվող արժեքը 1 է, եթե սկզբնական ամբողջ թիվը զրոյից տարբեր էր; հակառակ դեպքում՝ 0:\n\n### Օրինակ:\n- `convertIntToBoolToInt(5)` վերադարձնում է `1`, քանի որ ցանկացած զրոյից տարբեր ամբողջ թիվ վերածվում է `true`, որը հետո վերածվում է `1`:\n- `convertIntToBoolToInt(0)` վերադարձնում է `0`, քանի որ `0` վերածվում է `false`, որը հետո վերածվում է `0`:\n- `convertIntToBoolToInt(-10)` վերադարձնում է `1`, քանի որ ցանկացած զրոյից տարբեր ամբողջ թիվ, ներառյալ բացասական թվերը, վերածվում է `true`, որը հետո վերածվում է `1`:",
      "bn": "একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে এবং তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে, এবং ফলস্বরূপ পূর্ণসংখ্যা মানটি ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- value: একটি পূর্ণসংখ্যা মান যা বুলিয়ানে এবং তারপর পূর্ণসংখ্যায় রূপান্তরিত হবে।\n\n- ফেরত দেয়: রূপান্তরের পর একটি পূর্ণসংখ্যা মান। যদি মূল পূর্ণসংখ্যাটি শূন্য-বহির্ভূত হয় তবে ফেরত মানটি 1; অন্যথায়, এটি 0।\n\n### উদাহরণ:\n- `convertIntToBoolToInt(5)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য-বহির্ভূত পূর্ণসংখ্যা `true` তে রূপান্তরিত হয়, যা তারপর `1` এ রূপান্তরিত হয়।\n- `convertIntToBoolToInt(0)` `0` ফেরত দেয়, কারণ `0` `false` তে রূপান্তরিত হয়, যা তারপর `0` এ রূপান্তরিত হয়।\n- `convertIntToBoolToInt(-10)` `1` ফেরত দেয়, কারণ যেকোনো শূন্য-বহির্ভূত পূর্ণসংখ্যা, যার মধ্যে ঋণাত্মক সংখ্যাও অন্তর্ভুক্ত, `true` তে রূপান্তরিত হয়, যা তারপর `1` এ রূপান্তরিত হয়।",
      "bg": "Преобразува цяло число в булева стойност и след това обратно в цяло число, и връща получената стойност на цяло число.\n\n- Параметри:\n- value: Цяло число, което да бъде преобразувано в булева стойност и обратно в цяло число.\n\n- Връща: Цяло число след преобразуването. Върнатата стойност е 1, ако оригиналното цяло число е било различно от нула; в противен случай е 0.\n\n### Пример:\n- `convertIntToBoolToInt(5)` връща `1`, защото всяко ненулево цяло число се преобразува в `true`, което след това се преобразува обратно в `1`.\n- `convertIntToBoolToInt(0)` връща `0`, защото `0` се преобразува в `false`, което след това се преобразува обратно в `0`.\n- `convertIntToBoolToInt(-10)` връща `1`, защото всяко ненулево цяло число, включително отрицателните числа, се преобразува в `true`, което след това се преобразува обратно в `1`.",
      "zh": "将整数转换为布尔值，然后再转换回整数，并返回结果整数值。\n\n- 参数：\n- value: 要转换为布尔值并再转换回整数的整数值。\n\n- 返回：转换后的整数值。如果原始整数为非零，则返回值为1；否则为0。\n\n### 示例：\n- `convertIntToBoolToInt(5)` 返回 `1`，因为任何非零整数转换为 `true`，然后再转换回 `1`。\n- `convertIntToBoolToInt(0)` 返回 `0`，因为 `0` 转换为 `false`，然后再转换回 `0`。\n- `convertIntToBoolToInt(-10)` 返回 `1`，因为任何非零整数，包括负数，转换为 `true`，然后再转换回 `1`。",
      "fr": "Convertit un entier en booléen, puis à nouveau en entier, et renvoie la valeur entière résultante.\n\n- Paramètres:\n- value: Une valeur entière à convertir en booléen, puis à nouveau en entier.\n\n- Renvoie: Une valeur entière après conversion. La valeur de retour est 1 si l'entier d'origine était non nul ; sinon, elle est 0.\n\n### Exemple:\n- `convertIntToBoolToInt(5)` renvoie `1`, car tout entier non nul se convertit en `true`, qui se convertit ensuite en `1`.\n- `convertIntToBoolToInt(0)` renvoie `0`, car `0` se convertit en `false`, qui se convertit ensuite en `0`.\n- `convertIntToBoolToInt(-10)` renvoie `1`, car tout entier non nul, y compris les nombres négatifs, se convertit en `true`, qui se convertit ensuite en `1`.",
      "de": "Konvertiert eine ganze Zahl in einen booleschen Wert und dann zurück in eine ganze Zahl und gibt den resultierenden ganzzahligen Wert zurück.\n\n- Parameter:\n- value: Ein ganzzahliger Wert, der in einen booleschen Wert und zurück in eine ganze Zahl konvertiert werden soll.\n\n- Rückgabewert: Ein ganzzahliger Wert nach der Konvertierung. Der Rückgabewert ist 1, wenn die ursprüngliche ganze Zahl ungleich null war; andernfalls ist er 0.\n\n### Beispiel:\n- `convertIntToBoolToInt(5)` gibt `1` zurück, weil jede ungleich null ganze Zahl in `true` konvertiert wird, was dann zurück in `1` konvertiert wird.\n- `convertIntToBoolToInt(0)` gibt `0` zurück, weil `0` in `false` konvertiert wird, was dann zurück in `0` konvertiert wird.\n- `convertIntToBoolToInt(-10)` gibt `1` zurück, weil jede ungleich null ganze Zahl, einschließlich negativer Zahlen, in `true` konvertiert wird, was dann zurück in `1` konvertiert wird.",
      "ha": "Converts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Sigogi:\n- value: Wani ƙimar integer da za a canza zuwa boolean sannan a mayar da shi zuwa integer.\n\n- Komawa: Wani ƙimar integer bayan canzawa. Ƙimar dawowa ita ce 1 idan ainihin integer ɗin ba sifili ba ne; in ba haka ba, yana da 0.\n\n### Misali:\n- `convertIntToBoolToInt(5)` yana dawowa `1`, saboda duk wani integer da ba sifili ba yana canzawa zuwa `true`, wanda ke canzawa zuwa `1`.\n- `convertIntToBoolToInt(0)` yana dawowa `0`, saboda `0` yana canzawa zuwa `false`, wanda ke canzawa zuwa `0`.\n- `convertIntToBoolToInt(-10)` yana dawowa `1`, saboda duk wani integer da ba sifili ba, ciki har da lambobi marasa kyau, yana canzawa zuwa `true`, wanda ke canzawa zuwa `1`.",
      "hi": "पूर्णांक को बूलियन में और फिर से पूर्णांक में परिवर्तित करता है, और परिणामी पूर्णांक मान लौटाता है।\n\n- पैरामीटर:\n- value: एक पूर्णांक मान जिसे बूलियन में और फिर से पूर्णांक में परिवर्तित किया जाना है।\n\n- रिटर्न: रूपांतरण के बाद एक पूर्णांक मान। यदि मूल पूर्णांक शून्य नहीं था तो रिटर्न मान 1 है; अन्यथा, यह 0 है।\n\n### उदाहरण:\n- `convertIntToBoolToInt(5)` `1` लौटाता है, क्योंकि कोई भी गैर-शून्य पूर्णांक `true` में परिवर्तित होता है, जो फिर से `1` में परिवर्तित होता है।\n- `convertIntToBoolToInt(0)` `0` लौटाता है, क्योंकि `0` `false` में परिवर्तित होता है, जो फिर से `0` में परिवर्तित होता है।\n- `convertIntToBoolToInt(-10)` `1` लौटाता है, क्योंकि कोई भी गैर-शून्य पूर्णांक, जिसमें ऋणात्मक संख्याएँ भी शामिल हैं, `true` में परिवर्तित होता है, जो फिर से `1` में परिवर्तित होता है।",
      "hu": "Egész számot logikai értékké, majd vissza egész számmá alakít, és visszaadja a kapott egész értéket.\n\n- Paraméterek:\n- value: Egy egész szám érték, amelyet logikai értékké, majd vissza egész számmá kell alakítani.\n\n- Visszatérési érték: Egy egész szám érték az átalakítás után. A visszatérési érték 1, ha az eredeti egész szám nem nulla volt; különben 0.\n\n### Példa:\n- `convertIntToBoolToInt(5)` visszaadja `1`, mert bármely nem nulla egész szám `true`-vá alakul, ami aztán visszaalakul `1`-re.\n- `convertIntToBoolToInt(0)` visszaadja `0`, mert `0` `false`-vá alakul, ami aztán visszaalakul `0`-ra.\n- `convertIntToBoolToInt(-10)` visszaadja `1`, mert bármely nem nulla egész szám, beleértve a negatív számokat is, `true`-vá alakul, ami aztán visszaalakul `1`-re."
    },
    "docstring_bertscore": {
      "sq": "0.9724934662039076",
      "hy": "0.9635600648168635",
      "bn": "0.9675761724910079",
      "bg": "0.9785506996735666",
      "zh": "0.9571699268285901",
      "fr": "0.9793569403901872",
      "de": "0.9607418969707405",
      "ha": "0.9753889012682532",
      "hi": "0.9758971964133215",
      "hu": "0.9731469601575125"
    }
  },
  {
    "task_id": "Swift/45",
    "prompt": {
      "en": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Reverses a three-digit number and returns the result.\n\n    - Parameters:\n        - number: A three-digit integer to be reversed.\n\n    - Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n    ### Examples:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Note: The function assumes the input is always a three-digit number.\n    */",
      "sq": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Kthen një numër me tre shifra dhe kthen rezultatin.\n\n    - Parametra:\n        - number: Një numër i plotë me tre shifra që do të kthehet.\n\n    - Kthen: Numrin e kthyer. Nëse numri i dhënë nuk është një numër i plotë me tre shifra, funksioni kthen -1 për të treguar një gabim.\n\n    ### Shembuj:\n    - `reverseThreeDigitNumber(123)` kthen `321`.\n    - `reverseThreeDigitNumber(456)` kthen `654`.\n    - `reverseThreeDigitNumber(789)` kthen `987`.\n    - `reverseThreeDigitNumber(100)` kthen `1`, pasi zerot para nuk përfaqësohen në numrat e plotë.\n    - `reverseThreeDigitNumber(905)` kthen `509`.\n\n    Shënim: Funksioni supozon që hyrja është gjithmonë një numër me tre shifra.\n    */",
      "hy": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Հակադարձում է եռանիշ թիվը և վերադարձնում արդյունքը։\n\n    - Պարամետրեր:\n        - number: Եռանիշ ամբողջ թիվ, որը պետք է հակադարձել։\n\n    - Վերադարձնում է: Հակադարձված ամբողջ թիվը։ Եթե մուտքային թիվը եռանիշ ամբողջ թիվ չէ, ֆունկցիան վերադարձնում է -1՝ սխալը ցույց տալու համար։\n\n    ### Օրինակներ:\n    - `reverseThreeDigitNumber(123)` վերադարձնում է `321`:\n    - `reverseThreeDigitNumber(456)` վերադարձնում է `654`:\n    - `reverseThreeDigitNumber(789)` վերադարձնում է `987`:\n    - `reverseThreeDigitNumber(100)` վերադարձնում է `1`, քանի որ առաջատար զրոները չեն ներկայացվում ամբողջ թվերով։\n    - `reverseThreeDigitNumber(905)` վերադարձնում է `509`։\n\n    Նշում: Ֆունկցիան ենթադրում է, որ մուտքը միշտ եռանիշ թիվ է։\n    */",
      "bn": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    একটি তিন অঙ্কের সংখ্যা উল্টে দেয় এবং ফলাফল প্রদান করে।\n\n    - প্যারামিটার:\n        - number: উল্টানোর জন্য একটি তিন অঙ্কের পূর্ণসংখ্যা।\n\n    - রিটার্নস: উল্টানো পূর্ণসংখ্যা। যদি ইনপুট সংখ্যা তিন অঙ্কের পূর্ণসংখ্যা না হয়, তাহলে ফাংশনটি একটি ত্রুটি নির্দেশ করার জন্য -1 প্রদান করে।\n\n    ### উদাহরণ:\n    - `reverseThreeDigitNumber(123)` রিটার্ন করে `321`।\n    - `reverseThreeDigitNumber(456)` রিটার্ন করে `654`।\n    - `reverseThreeDigitNumber(789)` রিটার্ন করে `987`।\n    - `reverseThreeDigitNumber(100)` রিটার্ন করে `1`, কারণ পূর্ণসংখ্যায় শূন্যের পূর্ববর্তী সংখ্যা প্রদর্শিত হয় না।\n    - `reverseThreeDigitNumber(905)` রিটার্ন করে `509`।\n\n    নোট: ফাংশনটি ধরে নেয় যে ইনপুট সর্বদা একটি তিন অঙ্কের সংখ্যা।\n    */",
      "bg": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Обръща трицифрено число и връща резултата.\n\n    - Параметри:\n        - number: Трицифрено цяло число, което да бъде обърнато.\n\n    - Връща: Обърнатото цяло число. Ако входното число не е трицифрено, функцията връща -1, за да посочи грешка.\n\n    ### Примери:\n    - `reverseThreeDigitNumber(123)` връща `321`.\n    - `reverseThreeDigitNumber(456)` връща `654`.\n    - `reverseThreeDigitNumber(789)` връща `987`.\n    - `reverseThreeDigitNumber(100)` връща `1`, тъй като водещите нули не се представят в цели числа.\n    - `reverseThreeDigitNumber(905)` връща `509`.\n\n    Забележка: Функцията предполага, че входът винаги е трицифрено число.\n    */",
      "zh": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    反转一个三位数并返回结果。\n\n    - 参数:\n        - number: 要反转的三位整数。\n\n    - 返回: 反转后的整数。如果输入的数字不是三位整数，函数返回 -1 以指示错误。\n\n    ### 示例:\n    - `reverseThreeDigitNumber(123)` 返回 `321`.\n    - `reverseThreeDigitNumber(456)` 返回 `654`.\n    - `reverseThreeDigitNumber(789)` 返回 `987`.\n    - `reverseThreeDigitNumber(100)` 返回 `1`, 因为整数中不表示前导零。\n    - `reverseThreeDigitNumber(905)` 返回 `509`.\n\n    注意: 函数假设输入始终是一个三位数。\n    */",
      "fr": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Inverse un nombre à trois chiffres et renvoie le résultat.\n\n    - Paramètres:\n        - number: Un entier à trois chiffres à inverser.\n\n    - Renvoie: L'entier inversé. Si le nombre d'entrée n'est pas un entier à trois chiffres, la fonction renvoie -1 pour indiquer une erreur.\n\n    ### Exemples:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, car les zéros en tête ne sont pas représentés dans les entiers.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Remarque: La fonction suppose que l'entrée est toujours un nombre à trois chiffres.\n    */",
      "de": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Kehrt eine dreistellige Zahl um und gibt das Ergebnis zurück.\n\n    - Parameter:\n        - number: Eine dreistellige Ganzzahl, die umgekehrt werden soll.\n\n    - Rückgabewert: Die umgekehrte Ganzzahl. Wenn die Eingabezahl keine dreistellige Ganzzahl ist, gibt die Funktion -1 zurück, um einen Fehler anzuzeigen.\n\n    ### Beispiele:\n    - `reverseThreeDigitNumber(123)` gibt `321` zurück.\n    - `reverseThreeDigitNumber(456)` gibt `654` zurück.\n    - `reverseThreeDigitNumber(789)` gibt `987` zurück.\n    - `reverseThreeDigitNumber(100)` gibt `1` zurück, da führende Nullen in Ganzzahlen nicht dargestellt werden.\n    - `reverseThreeDigitNumber(905)` gibt `509` zurück.\n\n    Hinweis: Die Funktion geht davon aus, dass die Eingabe immer eine dreistellige Zahl ist.\n    */",
      "ha": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Ya juya lamba mai tsawon uku kuma ya dawo da sakamakon.\n\n    - Ma'auni:\n        - number: Lamba mai tsawon uku da za a juyar.\n\n    - Komawa: Lambar da aka juyar. Idan lambar da aka shigar ba lamba mai tsawon uku ba ce, aikin zai dawo da -1 don nuna kuskure.\n\n    ### Misalai:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, kamar yadda ba a wakilta sifili na gaba a cikin lambobi.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Lura: Aikin yana ɗauka cewa shigarwar koyaushe lamba ce mai tsawon uku.\n    */",
      "hi": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    एक तीन-अंकीय संख्या को उलटता है और परिणाम लौटाता है।\n\n    - पैरामीटर्स:\n        - number: एक तीन-अंकीय पूर्णांक जिसे उलटना है।\n\n    - रिटर्न्स: उलटा पूर्णांक। यदि इनपुट संख्या तीन-अंकीय पूर्णांक नहीं है, तो यह फ़ंक्शन त्रुटि को इंगित करने के लिए -1 लौटाता है।\n\n    ### उदाहरण:\n    - `reverseThreeDigitNumber(123)` `321` लौटाता है।\n    - `reverseThreeDigitNumber(456)` `654` लौटाता है।\n    - `reverseThreeDigitNumber(789)` `987` लौटाता है।\n    - `reverseThreeDigitNumber(100)` `1` लौटाता है, क्योंकि अग्रणी शून्य पूर्णांकों में प्रदर्शित नहीं होते हैं।\n    - `reverseThreeDigitNumber(905)` `509` लौटाता है।\n\n    नोट: फ़ंक्शन मानता है कि इनपुट हमेशा एक तीन-अंकीय संख्या है।\n    */",
      "hu": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Megfordít egy háromjegyű számot, és visszaadja az eredményt.\n\n    - Paraméterek:\n        - number: Egy háromjegyű egész szám, amelyet meg kell fordítani.\n\n    - Visszatér: A megfordított egész szám. Ha a bemeneti szám nem háromjegyű egész szám, a függvény -1-et ad vissza, hogy jelezze a hibát.\n\n    ### Példák:\n    - `reverseThreeDigitNumber(123)` visszaadja `321`.\n    - `reverseThreeDigitNumber(456)` visszaadja `654`.\n    - `reverseThreeDigitNumber(789)` visszaadja `987`.\n    - `reverseThreeDigitNumber(100)` visszaadja `1`, mivel a vezető nullák nem jelennek meg az egész számokban.\n    - `reverseThreeDigitNumber(905)` visszaadja `509`.\n\n    Megjegyzés: A függvény feltételezi, hogy a bemenet mindig háromjegyű szám.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9949710760129588",
      "hy": "0.9990116152239704",
      "bn": "0.9880714510973309",
      "bg": "0.99275257328718",
      "zh": "0.9889448288827413",
      "fr": "0.9944133219030127",
      "de": "0.9874978065569021",
      "ha": "0.9868643742717819",
      "hi": "0.9940947187718328",
      "hu": "0.9868355728665318"
    },
    "canonical_solution": "    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}",
    "instruction": {
      "en": "Write a Swift function `func reverseThreeDigitNumber(_ number: Int) -> Int {` to solve the following problem:\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n",
      "sq": "Shkruani një funksion Swift `func reverseThreeDigitNumber(_ number: Int) -> Int {` për të zgjidhur problemin në vijim:\nKthen mbrapsht një numër me tre shifra dhe kthen rezultatin.\n\n- Parametrat:\n- number: Një numër i plotë me tre shifra që do të kthehet mbrapsht.\n\n- Kthen: Numrin e kthyer mbrapsht. Nëse numri i dhënë nuk është një numër i plotë me tre shifra, funksioni kthen -1 për të treguar një gabim.\n\n### Shembuj:\n- `reverseThreeDigitNumber(123)` kthen `321`.\n- `reverseThreeDigitNumber(456)` kthen `654`.\n- `reverseThreeDigitNumber(789)` kthen `987`.\n- `reverseThreeDigitNumber(100)` kthen `1`, pasi zerot para nuk përfaqësohen në numrat e plotë.\n- `reverseThreeDigitNumber(905)` kthen `509`.\n\nShënim: Funksioni supozon që hyrja është gjithmonë një numër me tre shifra.",
      "hy": "Swift ֆունկցիա գրեք `func reverseThreeDigitNumber(_ number: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\nԵռանիշ թիվը շրջում է և վերադարձնում արդյունքը:\n\n- Պարամետրեր:\n- number: Եռանիշ ամբողջ թիվ, որը պետք է շրջել:\n\n- Վերադարձնում է: Շրջված ամբողջ թիվը: Եթե մուտքային թիվը եռանիշ ամբողջ թիվ չէ, ֆունկցիան վերադարձնում է -1՝ սխալը նշելու համար:\n\n### Օրինակներ:\n- `reverseThreeDigitNumber(123)` վերադարձնում է `321`:\n- `reverseThreeDigitNumber(456)` վերադարձնում է `654`:\n- `reverseThreeDigitNumber(789)` վերադարձնում է `987`:\n- `reverseThreeDigitNumber(100)` վերադարձնում է `1`, քանի որ առաջատար զրոները չեն ներկայացվում ամբողջ թվերում:\n- `reverseThreeDigitNumber(905)` վերադարձնում է `509`:\n\nՆշում: Ֆունկցիան ենթադրում է, որ մուտքը միշտ եռանիշ թիվ է:",
      "bn": "একটি Swift ফাংশন লিখুন `func reverseThreeDigitNumber(_ number: Int) -> Int {` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি তিন-অঙ্কের সংখ্যা উল্টায় এবং ফলাফল ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- number: একটি তিন-অঙ্কের পূর্ণসংখ্যা যা উল্টানো হবে।\n\n- রিটার্নস: উল্টানো পূর্ণসংখ্যা। যদি ইনপুট সংখ্যা একটি তিন-অঙ্কের পূর্ণসংখ্যা না হয়, ফাংশনটি একটি ত্রুটি নির্দেশ করতে -1 ফেরত দেয়।\n\n### উদাহরণসমূহ:\n- `reverseThreeDigitNumber(123)` `321` ফেরত দেয়।\n- `reverseThreeDigitNumber(456)` `654` ফেরত দেয়।\n- `reverseThreeDigitNumber(789)` `987` ফেরত দেয়।\n- `reverseThreeDigitNumber(100)` `1` ফেরত দেয়, কারণ পূর্ণসংখ্যায় শূন্যের পূর্ববর্তী সংখ্যা প্রদর্শিত হয় না।\n- `reverseThreeDigitNumber(905)` `509` ফেরত দেয়।\n\nনোট: ফাংশনটি ধরে নেয় যে ইনপুট সর্বদা একটি তিন-অঙ্কের সংখ্যা।",
      "bg": "Напишете Swift функция `func reverseThreeDigitNumber(_ number: Int) -> Int {` за решаване на следния проблем:\nОбръща трицифрено число и връща резултата.\n\n- Параметри:\n- number: Трицифрено цяло число, което да бъде обърнато.\n\n- Връща: Обърнатото цяло число. Ако входното число не е трицифрено, функцията връща -1, за да посочи грешка.\n\n### Примери:\n- `reverseThreeDigitNumber(123)` връща `321`.\n- `reverseThreeDigitNumber(456)` връща `654`.\n- `reverseThreeDigitNumber(789)` връща `987`.\n- `reverseThreeDigitNumber(100)` връща `1`, тъй като водещите нули не се представят в цели числа.\n- `reverseThreeDigitNumber(905)` връща `509`.\n\nЗабележка: Функцията предполага, че входът винаги е трицифрено число.",
      "zh": "编写一个 Swift 函数 `func reverseThreeDigitNumber(_ number: Int) -> Int {` 来解决以下问题：\n反转一个三位数并返回结果。\n\n- 参数：\n- number: 要反转的三位整数。\n\n- 返回值：反转后的整数。如果输入的数字不是三位整数，函数返回 -1 以表示错误。\n\n### 示例：\n- `reverseThreeDigitNumber(123)` 返回 `321`。\n- `reverseThreeDigitNumber(456)` 返回 `654`。\n- `reverseThreeDigitNumber(789)` 返回 `987`。\n- `reverseThreeDigitNumber(100)` 返回 `1`，因为整数中不表示前导零。\n- `reverseThreeDigitNumber(905)` 返回 `509`。\n\n注意：该函数假设输入始终为三位数。",
      "fr": "Écrire une fonction Swift `func reverseThreeDigitNumber(_ number: Int) -> Int {` pour résoudre le problème suivant :\nInverse un nombre à trois chiffres et renvoie le résultat.\n\n- Paramètres :\n- number: Un entier à trois chiffres à inverser.\n\n- Renvoie : L'entier inversé. Si le nombre d'entrée n'est pas un entier à trois chiffres, la fonction renvoie -1 pour indiquer une erreur.\n\n### Exemples :\n- `reverseThreeDigitNumber(123)` renvoie `321`.\n- `reverseThreeDigitNumber(456)` renvoie `654`.\n- `reverseThreeDigitNumber(789)` renvoie `987`.\n- `reverseThreeDigitNumber(100)` renvoie `1`, car les zéros en tête ne sont pas représentés dans les entiers.\n- `reverseThreeDigitNumber(905)` renvoie `509`.\n\nRemarque : La fonction suppose que l'entrée est toujours un nombre à trois chiffres.",
      "de": "Schreiben Sie eine Swift-Funktion `func reverseThreeDigitNumber(_ number: Int) -> Int {`, um das folgende Problem zu lösen:\nKehrt eine dreistellige Zahl um und gibt das Ergebnis zurück.\n\n- Parameter:\n- number: Eine dreistellige ganze Zahl, die umgekehrt werden soll.\n\n- Rückgabewert: Die umgekehrte ganze Zahl. Wenn die Eingabeziffer keine dreistellige Zahl ist, gibt die Funktion -1 zurück, um einen Fehler anzuzeigen.\n\n### Beispiele:\n- `reverseThreeDigitNumber(123)` gibt `321` zurück.\n- `reverseThreeDigitNumber(456)` gibt `654` zurück.\n- `reverseThreeDigitNumber(789)` gibt `987` zurück.\n- `reverseThreeDigitNumber(100)` gibt `1` zurück, da führende Nullen in ganzen Zahlen nicht dargestellt werden.\n- `reverseThreeDigitNumber(905)` gibt `509` zurück.\n\nHinweis: Die Funktion geht davon aus, dass die Eingabe immer eine dreistellige Zahl ist.",
      "ha": "Rubuta aikin Swift `func reverseThreeDigitNumber(_ number: Int) -> Int {` don warware matsalar mai zuwa:\nJuya lambar mai tsawon uku zuwa baya kuma dawo da sakamakon.\n\n- Sigogi:\n- number: Lamba mai tsawon uku da za a juyar.\n\n- Komawa: Lambar da aka juyar. Idan lambar da aka shigar ba lamba mai tsawon uku ba ce, aikin yana dawowa -1 don nuna kuskure.\n\n### Misalai:\n- `reverseThreeDigitNumber(123)` yana dawowa `321`.\n- `reverseThreeDigitNumber(456)` yana dawowa `654`.\n- `reverseThreeDigitNumber(789)` yana dawowa `987`.\n- `reverseThreeDigitNumber(100)` yana dawowa `1`, saboda lambobin da ke gaba ba a wakilta su a lambobi.\n- `reverseThreeDigitNumber(905)` yana dawowa `509`.\n\nLura: Aikin yana ɗauka cewa shigarwar koyaushe lamba ce mai tsawon uku.",
      "hi": "Swift फ़ंक्शन `func reverseThreeDigitNumber(_ number: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक तीन-अंकीय संख्या को उलटता है और परिणाम लौटाता है।\n\n- पैरामीटर्स:\n- number: एक तीन-अंकीय पूर्णांक जिसे उलटना है।\n\n- रिटर्न्स: उलटी गई पूर्णांक। यदि इनपुट संख्या तीन-अंकीय पूर्णांक नहीं है, तो फ़ंक्शन त्रुटि को इंगित करने के लिए -1 लौटाता है।\n\n### उदाहरण:\n- `reverseThreeDigitNumber(123)` `321` लौटाता है।\n- `reverseThreeDigitNumber(456)` `654` लौटाता है।\n- `reverseThreeDigitNumber(789)` `987` लौटाता है।\n- `reverseThreeDigitNumber(100)` `1` लौटाता है, क्योंकि अग्रणी शून्य पूर्णांकों में प्रदर्शित नहीं होते हैं।\n- `reverseThreeDigitNumber(905)` `509` लौटाता है।\n\nनोट: फ़ंक्शन मानता है कि इनपुट हमेशा एक तीन-अंकीय संख्या है।",
      "hu": "Írj egy Swift függvényt `func reverseThreeDigitNumber(_ number: Int) -> Int {` a következő probléma megoldására:\nMegfordít egy háromjegyű számot és visszaadja az eredményt.\n\n- Paraméterek:\n- number: Egy háromjegyű egész szám, amelyet meg kell fordítani.\n\n- Visszatérési érték: A megfordított egész szám. Ha a bemeneti szám nem háromjegyű egész szám, a függvény -1-et ad vissza, hogy hibát jelezzen.\n\n### Példák:\n- `reverseThreeDigitNumber(123)` visszaadja `321`.\n- `reverseThreeDigitNumber(456)` visszaadja `654`.\n- `reverseThreeDigitNumber(789)` visszaadja `987`.\n- `reverseThreeDigitNumber(100)` visszaadja `1`, mivel a vezető nullák nem jelennek meg az egész számokban.\n- `reverseThreeDigitNumber(905)` visszaadja `509`.\n\nMegjegyzés: A függvény feltételezi, hogy a bemenet mindig háromjegyű szám."
    },
    "instruction_bertscore": {
      "sq": "0.9869041003479888",
      "hy": "0.9878130329716044",
      "bn": "0.9901429673411437",
      "bg": "0.9935359715099816",
      "zh": "0.9883018623393313",
      "fr": "0.9900569603861555",
      "de": "0.9820001148706184",
      "ha": "0.9801733112562405",
      "hi": "0.9843175355261524",
      "hu": "0.9844651178992614"
    },
    "level": "middle",
    "test": "func testReverseThreeDigitNumber() {\n    assert(reverseThreeDigitNumber(123) == 321, \"Reverse of 123 should be 321.\")\n    assert(reverseThreeDigitNumber(456) == 654, \"Reverse of 456 should be 654.\")\n    assert(reverseThreeDigitNumber(789) == 987, \"Reverse of 789 should be 987.\")\n    assert(reverseThreeDigitNumber(100) == 1, \"Reverse of 100 should be 1.\")\n    assert(reverseThreeDigitNumber(905) == 509, \"Reverse of 905 should be 509.\")\n    assert(reverseThreeDigitNumber(999) == 999, \"Reverse of 999 should be 999.\")\n    assert(reverseThreeDigitNumber(210) == 12, \"Reverse of 210 should be 12.\")\n}\n\n// Call the test function to verify the functionality\ntestReverseThreeDigitNumber()",
    "entry_point": "reverseThreeDigitNumber",
    "signature": "func reverseThreeDigitNumber(_ number: Int) -> Int {",
    "docstring": {
      "en": "\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n",
      "sq": "Kthen një numër tre-shifror dhe kthen rezultatin.\n\n- Parametra:\n- number: Një numër i plotë tre-shifror që do të kthehet.\n\n- Kthen: Numri i plotë i kthyer. Nëse numri i dhënë si hyrje nuk është një numër i plotë tre-shifror, funksioni kthen -1 për të treguar një gabim.\n\n### Shembuj:\n- `reverseThreeDigitNumber(123)` kthen `321`.\n- `reverseThreeDigitNumber(456)` kthen `654`.\n- `reverseThreeDigitNumber(789)` kthen `987`.\n- `reverseThreeDigitNumber(100)` kthen `1`, pasi zerot para nuk përfaqësohen në numrat e plotë.\n- `reverseThreeDigitNumber(905)` kthen `509`.\n\nShënim: Funksioni supozon që hyrja është gjithmonë një numër tre-shifror.",
      "hy": "Հակադարձում է երեքանիշ թիվը և վերադարձնում արդյունքը։\n\n- Պարամետրեր:\n- number: Երեքանիշ ամբողջ թիվ, որը պետք է հակադարձվի։\n\n- Վերադարձնում է: Հակադարձված ամբողջ թիվը։ Եթե մուտքային թիվը երեքանիշ ամբողջ թիվ չէ, ֆունկցիան վերադարձնում է -1՝ սխալը նշելու համար։\n\n### Օրինակներ:\n- `reverseThreeDigitNumber(123)` վերադարձնում է `321`։\n- `reverseThreeDigitNumber(456)` վերադարձնում է `654`։\n- `reverseThreeDigitNumber(789)` վերադարձնում է `987`։\n- `reverseThreeDigitNumber(100)` վերադարձնում է `1`, քանի որ առաջատար զրոները չեն ներկայացվում ամբողջ թվերում։\n- `reverseThreeDigitNumber(905)` վերադարձնում է `509`։\n\nՆշում: Ֆունկցիան ենթադրում է, որ մուտքը միշտ երեքանիշ թիվ է։",
      "bn": "একটি তিন অঙ্কের সংখ্যা উল্টায় এবং ফলাফল প্রদান করে।\n\n- প্যারামিটারসমূহ:\n- number: একটি তিন অঙ্কের পূর্ণসংখ্যা যা উল্টানো হবে।\n\n- রিটার্নস: উল্টানো পূর্ণসংখ্যা। যদি ইনপুট সংখ্যা তিন অঙ্কের পূর্ণসংখ্যা না হয়, তাহলে ফাংশনটি একটি ত্রুটি নির্দেশ করতে -1 প্রদান করে।\n\n### উদাহরণসমূহ:\n- `reverseThreeDigitNumber(123)` প্রদান করে `321`।\n- `reverseThreeDigitNumber(456)` প্রদান করে `654`।\n- `reverseThreeDigitNumber(789)` প্রদান করে `987`।\n- `reverseThreeDigitNumber(100)` প্রদান করে `1`, কারণ পূর্ণসংখ্যায় শূন্য দিয়ে শুরু হয় না।\n- `reverseThreeDigitNumber(905)` প্রদান করে `509`।\n\nদ্রষ্টব্য: ফাংশনটি ধরে নেয় যে ইনপুট সর্বদা একটি তিন অঙ্কের সংখ্যা।",
      "bg": "Обръща трицифрено число и връща резултата.\n\n- Параметри:\n- number: Трицифрено цяло число, което да бъде обърнато.\n\n- Връща: Обърнатото цяло число. Ако входното число не е трицифрено цяло число, функцията връща -1, за да посочи грешка.\n\n### Примери:\n- `reverseThreeDigitNumber(123)` връща `321`.\n- `reverseThreeDigitNumber(456)` връща `654`.\n- `reverseThreeDigitNumber(789)` връща `987`.\n- `reverseThreeDigitNumber(100)` връща `1`, тъй като водещите нули не се представят в цели числа.\n- `reverseThreeDigitNumber(905)` връща `509`.\n\nЗабележка: Функцията предполага, че входът винаги е трицифрено число.",
      "zh": "反转一个三位数并返回结果。\n\n- 参数：\n- number: 要反转的三位整数。\n\n- 返回值：反转后的整数。如果输入的数字不是三位整数，函数返回 -1 以表示错误。\n\n### 示例：\n- `reverseThreeDigitNumber(123)` 返回 `321`。\n- `reverseThreeDigitNumber(456)` 返回 `654`。\n- `reverseThreeDigitNumber(789)` 返回 `987`。\n- `reverseThreeDigitNumber(100)` 返回 `1`，因为整数中不表示前导零。\n- `reverseThreeDigitNumber(905)` 返回 `509`。\n\n注意：该函数假设输入始终是一个三位数。",
      "fr": "Inverse un nombre à trois chiffres et renvoie le résultat.\n\n- Paramètres:\n- number: Un entier à trois chiffres à inverser.\n\n- Renvoie: L'entier inversé. Si le nombre d'entrée n'est pas un entier à trois chiffres, la fonction renvoie -1 pour indiquer une erreur.\n\n### Exemples:\n- `reverseThreeDigitNumber(123)` renvoie `321`.\n- `reverseThreeDigitNumber(456)` renvoie `654`.\n- `reverseThreeDigitNumber(789)` renvoie `987`.\n- `reverseThreeDigitNumber(100)` renvoie `1`, car les zéros non significatifs ne sont pas représentés dans les entiers.\n- `reverseThreeDigitNumber(905)` renvoie `509`.\n\nRemarque: La fonction suppose que l'entrée est toujours un nombre à trois chiffres.",
      "de": "Kehrt eine dreistellige Zahl um und gibt das Ergebnis zurück.\n\n- Parameter:\n- number: Eine dreistellige ganze Zahl, die umgekehrt werden soll.\n\n- Rückgabewert: Die umgekehrte ganze Zahl. Wenn die Eingabezahl keine dreistellige ganze Zahl ist, gibt die Funktion -1 zurück, um einen Fehler anzuzeigen.\n\n### Beispiele:\n- `reverseThreeDigitNumber(123)` gibt `321` zurück.\n- `reverseThreeDigitNumber(456)` gibt `654` zurück.\n- `reverseThreeDigitNumber(789)` gibt `987` zurück.\n- `reverseThreeDigitNumber(100)` gibt `1` zurück, da führende Nullen in ganzen Zahlen nicht dargestellt werden.\n- `reverseThreeDigitNumber(905)` gibt `509` zurück.\n\nHinweis: Die Funktion geht davon aus, dass die Eingabe immer eine dreistellige Zahl ist.",
      "ha": "Reverses a three-digit number and returns the result.\n\n- Sigogi:\n- number: Lamba mai tsawon uku da za a juya.\n\n- Komawa: Lambar da aka juyar. Idan lambar da aka shigar ba lamba mai tsawon uku ba ce, aikin zai dawo da -1 don nuna kuskure.\n\n### Misalai:\n- `reverseThreeDigitNumber(123)` yana dawowa `321`.\n- `reverseThreeDigitNumber(456)` yana dawowa `654`.\n- `reverseThreeDigitNumber(789)` yana dawowa `987`.\n- `reverseThreeDigitNumber(100)` yana dawowa `1`, saboda lambobin da ke gaba ba a wakilta su a cikin lambobi.\n- `reverseThreeDigitNumber(905)` yana dawowa `509`.\n\nLura: Aikin yana ɗauka cewa shigarwar koyaushe lamba ce mai tsawon uku.",
      "hi": "तीन अंकों की संख्या को उलटता है और परिणाम लौटाता है।\n\n- पैरामीटर्स:\n- number: एक तीन अंकों की पूर्णांक संख्या जिसे उलटना है।\n\n- रिटर्न्स: उलटी की गई पूर्णांक संख्या। यदि इनपुट संख्या तीन अंकों की पूर्णांक संख्या नहीं है, तो यह फ़ंक्शन त्रुटि को इंगित करने के लिए -1 लौटाता है।\n\n### उदाहरण:\n- `reverseThreeDigitNumber(123)` `321` लौटाता है।\n- `reverseThreeDigitNumber(456)` `654` लौटाता है।\n- `reverseThreeDigitNumber(789)` `987` लौटाता है।\n- `reverseThreeDigitNumber(100)` `1` लौटाता है, क्योंकि पूर्णांकों में अग्रणी शून्य प्रदर्शित नहीं होते।\n- `reverseThreeDigitNumber(905)` `509` लौटाता है।\n\nनोट: फ़ंक्शन मानता है कि इनपुट हमेशा तीन अंकों की संख्या है।",
      "hu": "Megfordít egy háromjegyű számot és visszaadja az eredményt.\n\n- Paraméterek:\n- number: Egy háromjegyű egész szám, amelyet meg kell fordítani.\n\n- Visszatér: A megfordított egész szám. Ha a bemeneti szám nem háromjegyű egész szám, a függvény -1-et ad vissza, hogy hibát jelezzen.\n\n### Példák:\n- `reverseThreeDigitNumber(123)` visszaadja `321`.\n- `reverseThreeDigitNumber(456)` visszaadja `654`.\n- `reverseThreeDigitNumber(789)` visszaadja `987`.\n- `reverseThreeDigitNumber(100)` visszaadja `1`, mivel a vezető nullák nem jelennek meg az egész számokban.\n- `reverseThreeDigitNumber(905)` visszaadja `509`.\n\nMegjegyzés: A függvény feltételezi, hogy a bemenet mindig háromjegyű szám."
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9892332401960039",
      "bn": "0.9714053689765986",
      "bg": "0.998969505583191",
      "zh": "0.9843723575113181",
      "fr": "0.9872604432515654",
      "de": "0.9869638880926803",
      "ha": "0.9853943108217426",
      "hi": "0.9866409150931176",
      "hu": "0.9853806053254512"
    }
  },
  {
    "task_id": "Swift/46",
    "prompt": {
      "en": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calculates the nth term of an arithmetic sequence given its first two terms.\n\n    - Parameters:\n        - a1: The first term of the arithmetic sequence.\n        - a2: The second term of the arithmetic sequence.\n        - n: The position of the term in the sequence to be found (1-based index).\n\n    - Returns: The nth term of the arithmetic sequence.\n\n    ### Example:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\n    Note: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "sq": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Llogarit termin e n-të të një vargu aritmetik duke pasur parasysh dy termat e tij të parë.\n\n    - Parametrat:\n        - a1: Termi i parë i vargut aritmetik.\n        - a2: Termi i dytë i vargut aritmetik.\n        - n: Pozicioni i termit në varg që do të gjendet (indeksi që fillon nga 1).\n\n    - Kthen: Termi i n-të i vargut aritmetik.\n\n    ### Shembull:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` llogarit termin e 100-të të një vargu aritmetik që fillon me 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` llogarit termin e 20-të të një vargu aritmetik që fillon me 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` llogarit termin e 10-të të një vargu aritmetik që fillon me -3, 1.\n\n    Shënim: Funksioni supozon që vlerat e hyrjes për `a1`, `a2`, dhe `n` ndjekin kufizimet -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "hy": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով դրա առաջին երկու անդամները:\n\n    - Պարամետրեր:\n        - a1: Թվաբանական հաջորդականության առաջին անդամը:\n        - a2: Թվաբանական հաջորդականության երկրորդ անդամը:\n        - n: Հաջորդականության այն անդամի դիրքը, որը պետք է գտնվի (սկսած 1-ից):\n\n    - Վերադարձնում է: Թվաբանական հաջորդականության n-րդ անդամը:\n\n    ### Օրինակ:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` հաշվում է թվաբանական հաջորդականության 100-րդ անդամը, որը սկսվում է 1, 4-ով:\n    - `arithmeticSequenceLastTerm(5, 9, 20)` հաշվում է թվաբանական հաջորդականության 20-րդ անդամը, որը սկսվում է 5, 9-ով:\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` հաշվում է թվաբանական հաջորդականության 10-րդ անդամը, որը սկսվում է -3, 1-ով:\n\n    Նշում: Ֆունկցիան ենթադրում է, որ `a1`, `a2` և `n` մուտքային արժեքները համապատասխանում են սահմանափակումներին -100 <= a1,a2 <= 100, 0 < n <= 1000:\n    */",
      "bn": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    একটি গাণিতিক ধারা প্রদত্ত প্রথম দুটি পদ থেকে ধারার n তম পদটি গণনা করে।\n\n    - প্যারামিটার:\n        - a1: গাণিতিক ধারার প্রথম পদ।\n        - a2: গাণিতিক ধারার দ্বিতীয় পদ।\n        - n: ধারায় যে পদের অবস্থান খুঁজে বের করতে হবে (১-ভিত্তিক সূচক)।\n\n    - রিটার্নস: গাণিতিক ধারার n তম পদ।\n\n    ### উদাহরণ:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` গাণিতিক ধারার ১০০তম পদটি গণনা করে যা ১, ৪ দিয়ে শুরু হয়।\n    - `arithmeticSequenceLastTerm(5, 9, 20)` গাণিতিক ধারার ২০তম পদটি গণনা করে যা ৫, ৯ দিয়ে শুরু হয়।\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` গাণিতিক ধারার ১০তম পদটি গণনা করে যা -৩, ১ দিয়ে শুরু হয়।\n\n    দ্রষ্টব্য: ফাংশনটি ধরে নেয় যে `a1`, `a2`, এবং `n` এর ইনপুট মানগুলি -১০০ <= a1,a2 <= ১০০, ০ < n <= ১০০০ সীমাবদ্ধতাগুলি অনুসরণ করে।\n    */",
      "bg": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Изчислява n-тия член на аритметична прогресия, като се дават първите два члена.\n\n    - Параметри:\n        - a1: Първият член на аритметичната прогресия.\n        - a2: Вторият член на аритметичната прогресия.\n        - n: Позицията на члена в прогресията, който трябва да бъде намерен (индекс, започващ от 1).\n\n    - Връща: n-тия член на аритметичната прогресия.\n\n    ### Пример:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` изчислява 100-тия член на аритметична прогресия, започваща с 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` изчислява 20-тия член на аритметична прогресия, започваща с 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` изчислява 10-тия член на аритметична прогресия, започваща с -3, 1.\n\n    Забележка: Функцията предполага, че входните стойности за `a1`, `a2` и `n` следват ограниченията -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "zh": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    计算等差数列的第 n 项，给定其前两项。\n\n    - 参数:\n        - a1: 等差数列的第一项。\n        - a2: 等差数列的第二项。\n        - n: 要查找的项在数列中的位置（从1开始的索引）。\n\n    - 返回值: 等差数列的第 n 项。\n\n    ### 示例:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` 计算以 1, 4 开始的等差数列的第 100 项。\n    - `arithmeticSequenceLastTerm(5, 9, 20)` 计算以 5, 9 开始的等差数列的第 20 项。\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` 计算以 -3, 1 开始的等差数列的第 10 项。\n\n    注意: 该函数假设输入值 `a1`、`a2` 和 `n` 满足约束条件 -100 <= a1,a2 <= 100, 0 < n <= 1000。\n    */",
      "fr": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calcule le nième terme d'une suite arithmétique donnée ses deux premiers termes.\n\n    - Paramètres:\n        - a1: Le premier terme de la suite arithmétique.\n        - a2: Le deuxième terme de la suite arithmétique.\n        - n: La position du terme dans la suite à trouver (index basé sur 1).\n\n    - Retourne: Le nième terme de la suite arithmétique.\n\n    ### Exemple:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calcule le 100ème terme d'une suite arithmétique commençant par 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calcule le 20ème terme d'une suite arithmétique commençant par 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calcule le 10ème terme d'une suite arithmétique commençant par -3, 1.\n\n    Remarque: La fonction suppose que les valeurs d'entrée pour `a1`, `a2`, et `n` respectent les contraintes -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "de": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Berechnet das n-te Glied einer arithmetischen Folge, gegeben ihre ersten beiden Glieder.\n\n    - Parameter:\n        - a1: Das erste Glied der arithmetischen Folge.\n        - a2: Das zweite Glied der arithmetischen Folge.\n        - n: Die Position des zu findenden Glieds in der Folge (1-basierter Index).\n\n    - Rückgabe: Das n-te Glied der arithmetischen Folge.\n\n    ### Beispiel:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` berechnet das 100. Glied einer arithmetischen Folge, die mit 1, 4 beginnt.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` berechnet das 20. Glied einer arithmetischen Folge, die mit 5, 9 beginnt.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` berechnet das 10. Glied einer arithmetischen Folge, die mit -3, 1 beginnt.\n\n    Hinweis: Die Funktion geht davon aus, dass die Eingabewerte für `a1`, `a2` und `n` den Einschränkungen -100 <= a1,a2 <= 100, 0 < n <= 1000 entsprechen.\n    */",
      "ha": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Lissafin kalmar n ta jeri mai lissafi idan aka ba shi kalmomin farko guda biyu.\n\n    - Sigogi:\n        - a1: Kalmar farko ta jeri mai lissafi.\n        - a2: Kalma ta biyu ta jeri mai lissafi.\n        - n: Matsayin kalmar a cikin jerin da za a samu (1-inda aka fara kirga).\n\n    - Komawa: Kalmar n ta jeri mai lissafi.\n\n    ### Misali:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` yana lissafin kalma ta 100 ta jeri mai lissafi da ya fara da 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` yana lissafin kalma ta 20 ta jeri mai lissafi da ya fara da 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` yana lissafin kalma ta 10 ta jeri mai lissafi da ya fara da -3, 1.\n\n    Lura: Aikin yana ɗauka cewa ƙimar shigarwa don `a1`, `a2`, da `n` suna bin ƙuntatawa -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "hi": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    एक अंकगणितीय अनुक्रम के पहले दो पद दिए जाने पर उसका nवां पद गणना करता है।\n\n    - पैरामीटर्स:\n        - a1: अंकगणितीय अनुक्रम का पहला पद।\n        - a2: अंकगणितीय अनुक्रम का दूसरा पद।\n        - n: अनुक्रम में उस पद की स्थिति जिसे खोजा जाना है (1-आधारित अनुक्रमणिका)।\n\n    - रिटर्न करता है: अंकगणितीय अनुक्रम का nवां पद।\n\n    ### उदाहरण:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` एक अंकगणितीय अनुक्रम का 100वां पद गणना करता है जो 1, 4 से शुरू होता है।\n    - `arithmeticSequenceLastTerm(5, 9, 20)` एक अंकगणितीय अनुक्रम का 20वां पद गणना करता है जो 5, 9 से शुरू होता है।\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` एक अंकगणितीय अनुक्रम का 10वां पद गणना करता है जो -3, 1 से शुरू होता है।\n\n    नोट: यह फ़ंक्शन मानता है कि `a1`, `a2`, और `n` के लिए इनपुट मान निम्नलिखित बाधाओं का पालन करते हैं -100 <= a1,a2 <= 100, 0 < n <= 1000।\n    */",
      "hu": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Kiszámítja egy számtani sorozat n-edik tagját, ha adott az első két tagja.\n\n    - Paraméterek:\n        - a1: A számtani sorozat első tagja.\n        - a2: A számtani sorozat második tagja.\n        - n: A sorozatban keresett tag pozíciója (1-alapú index).\n\n    - Visszatérési érték: A számtani sorozat n-edik tagja.\n\n    ### Példa:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` kiszámítja a számtani sorozat 100. tagját, amely 1, 4-gyel kezdődik.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` kiszámítja a számtani sorozat 20. tagját, amely 5, 9-cel kezdődik.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` kiszámítja a számtani sorozat 10. tagját, amely -3, 1-gyel kezdődik.\n\n    Megjegyzés: A függvény feltételezi, hogy az `a1`, `a2` és `n` bemeneti értékei megfelelnek a következő korlátozásoknak: -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9849340842288847",
      "hy": "0.9785091859239303",
      "bn": "0.9830107462493239",
      "bg": "0.9791606935737247",
      "zh": "0.9793243650076975",
      "fr": "0.9934114302610728",
      "de": "0.9793571390205682",
      "ha": "0.9894131993212215",
      "hi": "0.9883423829370624",
      "hu": "0.9735386592689133"
    },
    "canonical_solution": "    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}",
    "instruction": {
      "en": "Write a Swift function `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` to solve the following problem:\nCalculates the nth term of an arithmetic sequence given its first two terms.\n\n- Parameters:\n- a1: The first term of the arithmetic sequence.\n- a2: The second term of the arithmetic sequence.\n- n: The position of the term in the sequence to be found (1-based index).\n\n- Returns: The nth term of the arithmetic sequence.\n\n### Example:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\nNote: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n",
      "sq": "Shkruani një funksion Swift `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\nLlogarit termin e n-të të një sekuence aritmetike duke pasur parasysh dy termat e saj të parë.\n\n- Parametrat:\n- a1: Termi i parë i sekuencës aritmetike.\n- a2: Termi i dytë i sekuencës aritmetike.\n- n: Pozicioni i termit në sekuencë që duhet gjetur (indeksi që fillon nga 1).\n\n- Kthen: Termi i n-të i sekuencës aritmetike.\n\n### Shembull:\n- `arithmeticSequenceLastTerm(1, 4, 100)` llogarit termin e 100-të të një sekuence aritmetike që fillon me 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` llogarit termin e 20-të të një sekuence aritmetike që fillon me 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` llogarit termin e 10-të të një sekuence aritmetike që fillon me -3, 1.\n\nShënim: Funksioni supozon që vlerat hyrëse për `a1`, `a2`, dhe `n` ndjekin kufizimet -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "hy": "Գրեք Swift ֆունկցիա `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է թվաբանական հաջորդականության n-րդ անդամը, եթե տրված են դրա առաջին երկու անդամները։\n\n- Պարամետրեր:\n- a1: Թվաբանական հաջորդականության առաջին անդամը։\n- a2: Թվաբանական հաջորդականության երկրորդ անդամը։\n- n: Հաջորդականության այն անդամի դիրքը, որը պետք է գտնվի (1-ից սկսվող ինդեքս)։\n\n- Վերադարձնում է: Թվաբանական հաջորդականության n-րդ անդամը։\n\n### Օրինակ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` հաշվում է թվաբանական հաջորդականության 100-րդ անդամը, որը սկսվում է 1, 4։\n- `arithmeticSequenceLastTerm(5, 9, 20)` հաշվում է թվաբանական հաջորդականության 20-րդ անդամը, որը սկսվում է 5, 9։\n- `arithmeticSequenceLastTerm(-3, 1, 10)` հաշվում է թվաբանական հաջորդականության 10-րդ անդամը, որը սկսվում է -3, 1։\n\nՆշում: Ֆունկցիան ենթադրում է, որ `a1`, `a2` և `n` մուտքային արժեքները համապատասխանում են սահմանափակումներին -100 <= a1,a2 <= 100, 0 < n <= 1000։",
      "bn": "Swift ফাংশন `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএর প্রথম দুটি পদ দেওয়া থাকলে একটি গাণিতিক ক্রমের n তম পদ গণনা করে।\n\n- প্যারামিটারসমূহ:\n- a1: গাণিতিক ক্রমের প্রথম পদ।\n- a2: গাণিতিক ক্রমের দ্বিতীয় পদ।\n- n: ক্রমের যে পদের অবস্থান খুঁজে বের করতে হবে (১-ভিত্তিক সূচক)।\n\n- রিটার্নস: গাণিতিক ক্রমের n তম পদ।\n\n### উদাহরণ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` গাণিতিক ক্রমের ১০০তম পদ গণনা করে যা ১, ৪ দিয়ে শুরু হয়।\n- `arithmeticSequenceLastTerm(5, 9, 20)` গাণিতিক ক্রমের ২০তম পদ গণনা করে যা ৫, ৯ দিয়ে শুরু হয়।\n- `arithmeticSequenceLastTerm(-3, 1, 10)` গাণিতিক ক্রমের ১০তম পদ গণনা করে যা -৩, ১ দিয়ে শুরু হয়।\n\nদ্রষ্টব্য: ফাংশনটি ধরে নেয় যে `a1`, `a2`, এবং `n` এর ইনপুট মানগুলি নিম্নলিখিত সীমাবদ্ধতাগুলি অনুসরণ করে -100 <= a1,a2 <= 100, 0 < n <= 1000।",
      "bg": "Напишете Swift функция `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` за решаване на следния проблем:\nИзчислява n-тия член на аритметична прогресия, като са дадени първите два члена.\n\n- Параметри:\n- a1: Първият член на аритметичната прогресия.\n- a2: Вторият член на аритметичната прогресия.\n- n: Позицията на члена в прогресията, който трябва да бъде намерен (индекс, започващ от 1).\n\n- Връща: n-тия член на аритметичната прогресия.\n\n### Пример:\n- `arithmeticSequenceLastTerm(1, 4, 100)` изчислява 100-тия член на аритметична прогресия, започваща с 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` изчислява 20-тия член на аритметична прогресия, започваща с 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` изчислява 10-тия член на аритметична прогресия, започваща с -3, 1.\n\nЗабележка: Функцията приема, че входните стойности за `a1`, `a2` и `n` следват ограниченията -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "zh": "编写一个 Swift 函数 `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` 来解决以下问题：\n计算给定其前两个项的等差数列的第 n 项。\n\n- 参数：\n- a1: 等差数列的第一项。\n- a2: 等差数列的第二项。\n- n: 要查找的数列中的项的位置（从1开始的索引）。\n\n- 返回值：等差数列的第 n 项。\n\n### 示例：\n- `arithmeticSequenceLastTerm(1, 4, 100)` 计算以 1, 4 开始的等差数列的第 100 项。\n- `arithmeticSequenceLastTerm(5, 9, 20)` 计算以 5, 9 开始的等差数列的第 20 项。\n- `arithmeticSequenceLastTerm(-3, 1, 10)` 计算以 -3, 1 开始的等差数列的第 10 项。\n\n注意：该函数假设 `a1`、`a2` 和 `n` 的输入值遵循约束条件 -100 <= a1,a2 <= 100, 0 < n <= 1000。",
      "fr": "Écrire une fonction Swift `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` pour résoudre le problème suivant :\nCalcule le nième terme d'une suite arithmétique donnée ses deux premiers termes.\n\n- Paramètres :\n- a1 : Le premier terme de la suite arithmétique.\n- a2 : Le deuxième terme de la suite arithmétique.\n- n : La position du terme dans la suite à trouver (index basé sur 1).\n\n- Renvoie : Le nième terme de la suite arithmétique.\n\n### Exemple :\n- `arithmeticSequenceLastTerm(1, 4, 100)` calcule le 100ème terme d'une suite arithmétique commençant par 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calcule le 20ème terme d'une suite arithmétique commençant par 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calcule le 10ème terme d'une suite arithmétique commençant par -3, 1.\n\nRemarque : La fonction suppose que les valeurs d'entrée pour `a1`, `a2` et `n` suivent les contraintes -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "de": "Schreiben Sie eine Swift-Funktion `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {`, um das folgende Problem zu lösen:\nBerechnet das n-te Glied einer arithmetischen Folge, gegeben durch ihre ersten beiden Glieder.\n\n- Parameter:\n- a1: Das erste Glied der arithmetischen Folge.\n- a2: Das zweite Glied der arithmetischen Folge.\n- n: Die Position des zu findenden Glieds in der Folge (1-basierter Index).\n\n- Rückgabewert: Das n-te Glied der arithmetischen Folge.\n\n### Beispiel:\n- `arithmeticSequenceLastTerm(1, 4, 100)` berechnet das 100. Glied einer arithmetischen Folge, beginnend mit 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` berechnet das 20. Glied einer arithmetischen Folge, beginnend mit 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` berechnet das 10. Glied einer arithmetischen Folge, beginnend mit -3, 1.\n\nHinweis: Die Funktion geht davon aus, dass die Eingabewerte für `a1`, `a2` und `n` den Einschränkungen -100 <= a1,a2 <= 100, 0 < n <= 1000 entsprechen.",
      "ha": "Rubuta aikin Swift `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` don warware matsalar mai zuwa:\nLissafa n na sharadi na jerin lissafi idan aka ba shi sharuddan farko guda biyu.\n\n- Sigogi:\n- a1: Sharadi na farko na jerin lissafi.\n- a2: Sharadi na biyu na jerin lissafi.\n- n: Matsayin sharadi a cikin jerin da za a samu (1-tushe index).\n\n- Komawa: n na sharadi na jerin lissafi.\n\n### Misali:\n- `arithmeticSequenceLastTerm(1, 4, 100)` yana lissafa sharadi na 100 na jerin lissafi da ya fara da 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` yana lissafa sharadi na 20 na jerin lissafi da ya fara da 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` yana lissafa sharadi na 10 na jerin lissafi da ya fara da -3, 1.\n\nLura: Aikin yana ɗauka cewa ƙimar shigarwa don `a1`, `a2`, da `n` suna bin ƙuntatawa -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "hi": "Swift फ़ंक्शन `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइसके पहले दो पद दिए जाने पर एक अंकगणितीय अनुक्रम के nवें पद की गणना करता है।\n\n- पैरामीटर्स:\n- a1: अंकगणितीय अनुक्रम का पहला पद।\n- a2: अंकगणितीय अनुक्रम का दूसरा पद।\n- n: अनुक्रम में जिस पद को खोजना है उसकी स्थिति (1-आधारित सूचकांक)।\n\n- रिटर्न करता है: अंकगणितीय अनुक्रम का nवाँ पद।\n\n### उदाहरण:\n- `arithmeticSequenceLastTerm(1, 4, 100)` एक अंकगणितीय अनुक्रम का 100वाँ पद गणना करता है जो 1, 4 से शुरू होता है।\n- `arithmeticSequenceLastTerm(5, 9, 20)` एक अंकगणितीय अनुक्रम का 20वाँ पद गणना करता है जो 5, 9 से शुरू होता है।\n- `arithmeticSequenceLastTerm(-3, 1, 10)` एक अंकगणितीय अनुक्रम का 10वाँ पद गणना करता है जो -3, 1 से शुरू होता है।\n\nनोट: फ़ंक्शन यह मानता है कि `a1`, `a2`, और `n` के लिए इनपुट मान निम्नलिखित बाधाओं का पालन करते हैं -100 <= a1,a2 <= 100, 0 < n <= 1000।",
      "hu": "Írj egy Swift függvényt `func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {` a következő probléma megoldására:\nKiszámítja egy számtani sorozat n-edik tagját, ha adott az első két tagja.\n\n- Paraméterek:\n- a1: A számtani sorozat első tagja.\n- a2: A számtani sorozat második tagja.\n- n: A sorozat azon tagjának pozíciója, amelyet meg kell találni (1-alapú index).\n\n- Visszatérési érték: A számtani sorozat n-edik tagja.\n\n### Példa:\n- `arithmeticSequenceLastTerm(1, 4, 100)` kiszámítja egy számtani sorozat 100. tagját, amely 1, 4-gyel kezdődik.\n- `arithmeticSequenceLastTerm(5, 9, 20)` kiszámítja egy számtani sorozat 20. tagját, amely 5, 9-cel kezdődik.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` kiszámítja egy számtani sorozat 10. tagját, amely -3, 1-gyel kezdődik.\n\nMegjegyzés: A függvény feltételezi, hogy az `a1`, `a2` és `n` bemeneti értékei megfelelnek a következő korlátozásoknak: -100 <= a1,a2 <= 100, 0 < n <= 1000."
    },
    "instruction_bertscore": {
      "sq": "0.9850794816678023",
      "hy": "0.9803858457639479",
      "bn": "0.979487043289765",
      "bg": "0.9807795311791591",
      "zh": "0.9808677230683386",
      "fr": "0.9942152874131209",
      "de": "0.9728847680545464",
      "ha": "0.9892876649204074",
      "hi": "0.9787556862267945",
      "hu": "0.9807662229436297"
    },
    "level": "easy",
    "test": "func testArithmeticSequenceLastTerm() {\n    assert(arithmeticSequenceLastTerm(1, 4, 100) == 298, \"The 100th term should be 298.\")\n    assert(arithmeticSequenceLastTerm(5, 9, 20) == 81, \"The 20th term should be 77.\")\n    assert(arithmeticSequenceLastTerm(-3, 1, 10) == 33, \"The 10th term should be 33.\")\n    assert(arithmeticSequenceLastTerm(0, 2, 50) == 98, \"The 50th term should be 98.\")\n    assert(arithmeticSequenceLastTerm(-100, -97, 1000) == 2897, \"The 1000th term should be 2897.\")\n    assert(arithmeticSequenceLastTerm(2, 5, 3) == 8, \"The 3rd term should be 8.\")\n}\n\n// Call the test function to verify the functionality\ntestArithmeticSequenceLastTerm()",
    "entry_point": "arithmeticSequenceLastTerm",
    "signature": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the nth term of an arithmetic sequence given its first two terms.\n\n- Parameters:\n- a1: The first term of the arithmetic sequence.\n- a2: The second term of the arithmetic sequence.\n- n: The position of the term in the sequence to be found (1-based index).\n\n- Returns: The nth term of the arithmetic sequence.\n\n### Example:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\nNote: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n",
      "sq": "Llogarit termin e n-të të një vargu aritmetik duke pasur parasysh dy termat e tij të parë.\n\n- Parametrat:\n- a1: Termi i parë i vargut aritmetik.\n- a2: Termi i dytë i vargut aritmetik.\n- n: Pozicioni i termit në varg që do të gjendet (indeksi i bazuar në 1).\n\n- Kthen: Termi i n-të i vargut aritmetik.\n\n### Shembull:\n- `arithmeticSequenceLastTerm(1, 4, 100)` llogarit termin e 100-të të një vargu aritmetik që fillon me 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` llogarit termin e 20-të të një vargu aritmetik që fillon me 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` llogarit termin e 10-të të një vargu aritmetik që fillon me -3, 1.\n\nShënim: Funksioni supozon që vlerat e hyrjes për `a1`, `a2`, dhe `n` ndjekin kufizimet -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "hy": "Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով դրա առաջին երկու անդամները։\n\n- Պարամետրեր:\n- a1: Թվաբանական հաջորդականության առաջին անդամը։\n- a2: Թվաբանական հաջորդականության երկրորդ անդամը։\n- n: Հաջորդականության այն անդամի դիրքը, որը պետք է գտնվի (1-ից սկսվող ինդեքս)։\n\n- Վերադարձնում է: Թվաբանական հաջորդականության n-րդ անդամը։\n\n### Օրինակ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` հաշվում է թվաբանական հաջորդականության 100-րդ անդամը, որը սկսվում է 1, 4։\n- `arithmeticSequenceLastTerm(5, 9, 20)` հաշվում է թվաբանական հաջորդականության 20-րդ անդամը, որը սկսվում է 5, 9։\n- `arithmeticSequenceLastTerm(-3, 1, 10)` հաշվում է թվաբանական հաջորդականության 10-րդ անդամը, որը սկսվում է -3, 1։\n\nՆշում: Ֆունկցիան ենթադրում է, որ `a1`, `a2` և `n` մուտքային արժեքները համապատասխանում են սահմանափակումներին -100 <= a1,a2 <= 100, 0 < n <= 1000։",
      "bn": "nth টার্ম গণনা করে একটি গাণিতিক ক্রমের প্রথম দুটি টার্ম দেওয়া হলে।\n\n- প্যারামিটারসমূহ:\n- a1: গাণিতিক ক্রমের প্রথম টার্ম।\n- a2: গাণিতিক ক্রমের দ্বিতীয় টার্ম।\n- n: ক্রমের যে টার্মটি খুঁজে বের করতে হবে তার অবস্থান (১-ভিত্তিক সূচক)।\n\n- রিটার্ন করে: গাণিতিক ক্রমের nth টার্ম।\n\n### উদাহরণ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` গাণিতিক ক্রমের 100তম টার্ম গণনা করে যা 1, 4 দিয়ে শুরু হয়।\n- `arithmeticSequenceLastTerm(5, 9, 20)` গাণিতিক ক্রমের 20তম টার্ম গণনা করে যা 5, 9 দিয়ে শুরু হয়।\n- `arithmeticSequenceLastTerm(-3, 1, 10)` গাণিতিক ক্রমের 10তম টার্ম গণনা করে যা -3, 1 দিয়ে শুরু হয়।\n\nদ্রষ্টব্য: ফাংশনটি ধরে নেয় যে `a1`, `a2`, এবং `n` এর ইনপুট মানগুলি সীমাবদ্ধতা অনুসরণ করে -100 <= a1,a2 <= 100, 0 < n <= 1000।",
      "bg": "Изчислява n-тия член на аритметична прогресия, като са дадени първите два члена.\n\n- Параметри:\n- a1: Първият член на аритметичната прогресия.\n- a2: Вторият член на аритметичната прогресия.\n- n: Позицията на члена в прогресията, който трябва да бъде намерен (индекс, започващ от 1).\n\n- Връща: n-тия член на аритметичната прогресия.\n\n### Пример:\n- `arithmeticSequenceLastTerm(1, 4, 100)` изчислява 100-тия член на аритметична прогресия, започваща с 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` изчислява 20-тия член на аритметична прогресия, започваща с 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` изчислява 10-тия член на аритметична прогресия, започваща с -3, 1.\n\nЗабележка: Функцията предполага, че входните стойности за `a1`, `a2` и `n` следват ограниченията -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "zh": "计算给定其前两个项的等差数列的第n项。\n\n- 参数：\n- a1: 等差数列的第一项。\n- a2: 等差数列的第二项。\n- n: 要查找的项在序列中的位置（从1开始的索引）。\n\n- 返回：等差数列的第n项。\n\n### 示例：\n- `arithmeticSequenceLastTerm(1, 4, 100)` 计算以1, 4开始的等差数列的第100项。\n- `arithmeticSequenceLastTerm(5, 9, 20)` 计算以5, 9开始的等差数列的第20项。\n- `arithmeticSequenceLastTerm(-3, 1, 10)` 计算以-3, 1开始的等差数列的第10项。\n\n注意：该函数假设输入值 `a1`、`a2` 和 `n` 满足约束条件 -100 <= a1,a2 <= 100, 0 < n <= 1000。",
      "fr": "Calcule le nième terme d'une suite arithmétique donnée ses deux premiers termes.\n\n- Paramètres :\n- a1 : Le premier terme de la suite arithmétique.\n- a2 : Le deuxième terme de la suite arithmétique.\n- n : La position du terme dans la suite à trouver (index basé sur 1).\n\n- Retourne : Le nième terme de la suite arithmétique.\n\n### Exemple :\n- `arithmeticSequenceLastTerm(1, 4, 100)` calcule le 100ème terme d'une suite arithmétique commençant par 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calcule le 20ème terme d'une suite arithmétique commençant par 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calcule le 10ème terme d'une suite arithmétique commençant par -3, 1.\n\nRemarque : La fonction suppose que les valeurs d'entrée pour `a1`, `a2`, et `n` respectent les contraintes -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "de": "Berechnet das n-te Glied einer arithmetischen Folge, gegeben durch ihre ersten beiden Glieder.\n\n- Parameter:\n- a1: Das erste Glied der arithmetischen Folge.\n- a2: Das zweite Glied der arithmetischen Folge.\n- n: Die Position des zu findenden Gliedes in der Folge (1-basierter Index).\n\n- Rückgabewert: Das n-te Glied der arithmetischen Folge.\n\n### Beispiel:\n- `arithmeticSequenceLastTerm(1, 4, 100)` berechnet das 100. Glied einer arithmetischen Folge, die mit 1, 4 beginnt.\n- `arithmeticSequenceLastTerm(5, 9, 20)` berechnet das 20. Glied einer arithmetischen Folge, die mit 5, 9 beginnt.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` berechnet das 10. Glied einer arithmetischen Folge, die mit -3, 1 beginnt.\n\nHinweis: Die Funktion geht davon aus, dass die Eingabewerte für `a1`, `a2` und `n` den Einschränkungen -100 <= a1,a2 <= 100, 0 < n <= 1000 folgen.",
      "ha": "Yana ƙididdige sharadi na nth na jerin lissafi idan aka ba da sharuddan farko biyu.\n\n- Sigogi:\n- a1: Sharadi na farko na jerin lissafi.\n- a2: Sharadi na biyu na jerin lissafi.\n- n: Matsayin sharadi a cikin jerin da za a samu (1-based index).\n\n- Komawa: Sharadi na nth na jerin lissafi.\n\n### Misali:\n- `arithmeticSequenceLastTerm(1, 4, 100)` yana ƙididdige sharadi na 100 na jerin lissafi da ke farawa da 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` yana ƙididdige sharadi na 20 na jerin lissafi da ke farawa da 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` yana ƙididdige sharadi na 10 na jerin lissafi da ke farawa da -3, 1.\n\nLura: Aikin yana ɗauka cewa ƙimar shigarwa don `a1`, `a2`, da `n` suna bin ƙuntatawa -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "hi": "गणितीय अनुक्रम के दिए गए पहले दो पदों के आधार पर अनुक्रम का nवां पद गणना करता है।\n\n- पैरामीटर्स:\n- a1: गणितीय अनुक्रम का पहला पद।\n- a2: गणितीय अनुक्रम का दूसरा पद।\n- n: अनुक्रम में उस पद की स्थिति जिसे खोजा जाना है (1-आधारित सूचकांक)।\n\n- रिटर्न करता है: गणितीय अनुक्रम का nवां पद।\n\n### उदाहरण:\n- `arithmeticSequenceLastTerm(1, 4, 100)` गणितीय अनुक्रम का 100वां पद गणना करता है जो 1, 4 से शुरू होता है।\n- `arithmeticSequenceLastTerm(5, 9, 20)` गणितीय अनुक्रम का 20वां पद गणना करता है जो 5, 9 से शुरू होता है।\n- `arithmeticSequenceLastTerm(-3, 1, 10)` गणितीय अनुक्रम का 10वां पद गणना करता है जो -3, 1 से शुरू होता है।\n\nनोट: यह फ़ंक्शन मानता है कि `a1`, `a2`, और `n` के लिए इनपुट मान निम्नलिखित बाधाओं का पालन करते हैं -100 <= a1,a2 <= 100, 0 < n <= 1000।",
      "hu": "Kiszámítja egy számtani sorozat n-edik tagját, ha adott az első két tagja.\n\n- Paraméterek:\n- a1: A számtani sorozat első tagja.\n- a2: A számtani sorozat második tagja.\n- n: A sorozatban keresett tag pozíciója (1-alapú index).\n\n- Visszatérési érték: A számtani sorozat n-edik tagja.\n\n### Példa:\n- `arithmeticSequenceLastTerm(1, 4, 100)` kiszámítja a számtani sorozat 100. tagját, amely 1, 4-el kezdődik.\n- `arithmeticSequenceLastTerm(5, 9, 20)` kiszámítja a számtani sorozat 20. tagját, amely 5, 9-el kezdődik.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` kiszámítja a számtani sorozat 10. tagját, amely -3, 1-el kezdődik.\n\nMegjegyzés: A függvény feltételezi, hogy az `a1`, `a2` és `n` bemeneti értékek megfelelnek a -100 <= a1,a2 <= 100, 0 < n <= 1000 korlátoknak."
    },
    "docstring_bertscore": {
      "sq": "0.9879725331675755",
      "hy": "0.979521207715303",
      "bn": "0.9725055826571508",
      "bg": "0.9458434266108378",
      "zh": "0.9831525683413829",
      "fr": "0.9919199147298818",
      "de": "0.9737609266652912",
      "ha": "0.9807545037511487",
      "hi": "0.9632716535036009",
      "hu": "0.9718945956050875"
    }
  },
  {
    "task_id": "Swift/47",
    "prompt": {
      "en": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calculates the product of two positive integers.\n\n    - Parameters:\n        - a: The first positive integer.\n        - b: The second positive integer.\n        - Both `a` and `b` should be in the range of 1 to 50,000.\n\n    - Returns: The product of `a` and `b` as an integer.\n\n    ### Example:\n    - `multiply(3, 4)` returns `12`.\n    - `multiply(10, 5)` returns `50`.\n    - `multiply(36, 18)` returns `648`.\n\n    Note: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n    */",
      "sq": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Llogarit produktin e dy numrave të plotë pozitivë.\n\n    - Parametra:\n        - a: Numri i parë i plotë pozitiv.\n        - b: Numri i dytë i plotë pozitiv.\n        - Të dy `a` dhe `b` duhet të jenë në intervalin nga 1 deri në 50,000.\n\n    - Kthen: Produktin e `a` dhe `b` si një numër i plotë.\n\n    ### Shembull:\n    - `multiply(3, 4)` kthen `12`.\n    - `multiply(10, 5)` kthen `50`.\n    - `multiply(36, 18)` kthen `648`.\n\n    Shënim: Funksioni trajton shumëzimin brenda intervalit të specifikuar, duke siguruar që nuk ka tejmbushje për vlerat deri në 50,000.\n    */",
      "hy": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Հաշվում է երկու դրական ամբողջ թվերի արտադրյալը։\n\n    - Պարամետրեր:\n        - a: Առաջին դրական ամբողջ թիվը։\n        - b: Երկրորդ դրական ամբողջ թիվը։\n        - Ե՛վ `a`, և՛ `b` պետք է լինեն 1-ից մինչև 50,000 միջակայքում։\n\n    - Վերադարձնում է: `a` և `b` արտադրյալը որպես ամբողջ թիվ։\n\n    ### Օրինակ:\n    - `multiply(3, 4)` վերադարձնում է `12`։\n    - `multiply(10, 5)` վերադարձնում է `50`։\n    - `multiply(36, 18)` վերադարձնում է `648`։\n\n    Նշում: Ֆունկցիան կատարում է բազմապատկում նշված միջակայքում՝ ապահովելով, որ մինչև 50,000 արժեքների համար չլինի արտահոսք։\n    */",
      "bn": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    দুটি ধনাত্মক পূর্ণসংখ্যার গুণফল গণনা করে।\n\n    - Parameters:\n        - a: প্রথম ধনাত্মক পূর্ণসংখ্যা।\n        - b: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা।\n        - উভয় `a` এবং `b` এর মান 1 থেকে 50,000 এর মধ্যে হওয়া উচিত।\n\n    - Returns: `a` এবং `b` এর গুণফল একটি পূর্ণসংখ্যা হিসেবে।\n\n    ### উদাহরণ:\n    - `multiply(3, 4)` এর ফলাফল `12`।\n    - `multiply(10, 5)` এর ফলাফল `50`।\n    - `multiply(36, 18)` এর ফলাফল `648`।\n\n    দ্রষ্টব্য: এই ফাংশন নির্দিষ্ট সীমার মধ্যে গুণফল পরিচালনা করে, 50,000 পর্যন্ত মানের জন্য কোনো ওভারফ্লো না হওয়া নিশ্চিত করে।\n    */",
      "bg": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Изчислява произведението на две положителни цели числа.\n\n    - Параметри:\n        - a: Първото положително цяло число.\n        - b: Второто положително цяло число.\n        - И двете `a` и `b` трябва да са в диапазона от 1 до 50,000.\n\n    - Връща: Произведението на `a` и `b` като цяло число.\n\n    ### Пример:\n    - `multiply(3, 4)` връща `12`.\n    - `multiply(10, 5)` връща `50`.\n    - `multiply(36, 18)` връща `648`.\n\n    Забележка: Функцията обработва умножение в рамките на специфицирания диапазон, като осигурява липса на преливане за стойности до 50,000.\n    */",
      "zh": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    计算两个正整数的乘积。\n\n    - 参数:\n        - a: 第一个正整数。\n        - b: 第二个正整数。\n        - `a` 和 `b` 都应在 1 到 50,000 的范围内。\n\n    - 返回: `a` 和 `b` 的乘积，作为一个整数。\n\n    ### 示例:\n    - `multiply(3, 4)` 返回 `12`。\n    - `multiply(10, 5)` 返回 `50`。\n    - `multiply(36, 18)` 返回 `648`。\n\n    注意: 该函数在指定范围内处理乘法，确保对于值高达 50,000 不会溢出。\n    */",
      "fr": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calcule le produit de deux entiers positifs.\n\n    - Paramètres:\n        - a: Le premier entier positif.\n        - b: Le deuxième entier positif.\n        - Les deux `a` et `b` doivent être dans la plage de 1 à 50,000.\n\n    - Retourne: Le produit de `a` et `b` en tant qu'entier.\n\n    ### Exemple:\n    - `multiply(3, 4)` retourne `12`.\n    - `multiply(10, 5)` retourne `50`.\n    - `multiply(36, 18)` retourne `648`.\n\n    Remarque: La fonction gère la multiplication dans la plage spécifiée, en s'assurant qu'il n'y a pas de dépassement pour des valeurs allant jusqu'à 50,000.\n    */",
      "de": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Berechnet das Produkt von zwei positiven ganzen Zahlen.\n\n    - Parameter:\n        - a: Die erste positive ganze Zahl.\n        - b: Die zweite positive ganze Zahl.\n        - Sowohl `a` als auch `b` sollten im Bereich von 1 bis 50.000 liegen.\n\n    - Rückgabewert: Das Produkt von `a` und `b` als ganze Zahl.\n\n    ### Beispiel:\n    - `multiply(3, 4)` gibt `12` zurück.\n    - `multiply(10, 5)` gibt `50` zurück.\n    - `multiply(36, 18)` gibt `648` zurück.\n\n    Hinweis: Die Funktion behandelt die Multiplikation innerhalb des angegebenen Bereichs und stellt sicher, dass es zu keinem Überlauf bei Werten bis zu 50.000 kommt.\n    */",
      "ha": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Lissafin samfurin lambobi guda biyu masu kyau.\n\n    - Sigogi:\n        - a: Lamba ta farko mai kyau.\n        - b: Lamba ta biyu mai kyau.\n        - Duk `a` da `b` ya kamata su kasance a cikin zangon 1 zuwa 50,000.\n\n    - Yana Mayar da: Samfurin `a` da `b` a matsayin lamba.\n\n    ### Misali:\n    - `multiply(3, 4)` yana mayar da `12`.\n    - `multiply(10, 5)` yana mayar da `50`.\n    - `multiply(36, 18)` yana mayar da `648`.\n\n    Lura: Aikin yana sarrafa ninkawa a cikin zangon da aka kayyade, yana tabbatar da babu cika iyaka ga ƙimomi har zuwa 50,000.\n    */",
      "hi": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    दो धनात्मक पूर्णांकों का गुणनफल गणना करता है।\n\n    - पैरामीटर्स:\n        - a: पहला धनात्मक पूर्णांक।\n        - b: दूसरा धनात्मक पूर्णांक।\n        - दोनों `a` और `b` की सीमा 1 से 50,000 के बीच होनी चाहिए।\n\n    - रिटर्न करता है: `a` और `b` का गुणनफल एक पूर्णांक के रूप में।\n\n    ### उदाहरण:\n    - `multiply(3, 4)` `12` लौटाता है।\n    - `multiply(10, 5)` `50` लौटाता है।\n    - `multiply(36, 18)` `648` लौटाता है।\n\n    नोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर गुणा संभालता है, यह सुनिश्चित करते हुए कि 50,000 तक के मानों के लिए कोई ओवरफ्लो नहीं होगा।\n    */",
      "hu": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Kiszámítja két pozitív egész szám szorzatát.\n\n    - Paraméterek:\n        - a: Az első pozitív egész szám.\n        - b: A második pozitív egész szám.\n        - Mind `a`, mind `b` az 1 és 50,000 közötti tartományban kell legyen.\n\n    - Visszatérési érték: `a` és `b` szorzata egész számként.\n\n    ### Példa:\n    - `multiply(3, 4)` visszaadja `12`.\n    - `multiply(10, 5)` visszaadja `50`.\n    - `multiply(36, 18)` visszaadja `648`.\n\n    Megjegyzés: A függvény kezeli a szorzást a megadott tartományon belül, biztosítva, hogy ne legyen túlcsordulás 50,000-ig terjedő értékek esetén.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9942544175981848",
      "hy": "0.992433374264857",
      "bn": "0.9600760879335116",
      "bg": "0.9942544175981848",
      "zh": "0.9924349633079053",
      "fr": "0.9944550342830301",
      "de": "0.9914263182330101",
      "ha": "0.9772236500978725",
      "hi": "0.9910795095877232",
      "hu": "0.9897244531283031"
    },
    "canonical_solution": "    return a * b\n}",
    "instruction": {
      "en": "Write a Swift function `func multiply(_ a: Int, _ b: Int) -> Int {` to solve the following problem:\nCalculates the product of two positive integers.\n\n- Parameters:\n- a: The first positive integer.\n- b: The second positive integer.\n- Both `a` and `b` should be in the range of 1 to 50,000.\n\n- Returns: The product of `a` and `b` as an integer.\n\n### Example:\n- `multiply(3, 4)` returns `12`.\n- `multiply(10, 5)` returns `50`.\n- `multiply(36, 18)` returns `648`.\n\nNote: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n",
      "sq": "Shkruani një funksion Swift `func multiply(_ a: Int, _ b: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\nLlogarit produktin e dy numrave të plotë pozitivë.\n\n- Parametrat:\n- a: Numri i parë pozitiv i plotë.\n- b: Numri i dytë pozitiv i plotë.\n- Të dy `a` dhe `b` duhet të jenë në intervalin nga 1 deri në 50,000.\n\n- Kthen: Produktin e `a` dhe `b` si një numër i plotë.\n\n### Shembull:\n- `multiply(3, 4)` kthen `12`.\n- `multiply(10, 5)` kthen `50`.\n- `multiply(36, 18)` kthen `648`.\n\nShënim: Funksioni trajton shumëzimin brenda intervalit të specifikuar, duke siguruar që nuk ka mbingarkesë për vlerat deri në 50,000.",
      "hy": "Գրեք Swift ֆունկցիա `func multiply(_ a: Int, _ b: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է երկու դրական ամբողջ թվերի արտադրյալը։\n\n- Պարամետրեր:\n- a: Առաջին դրական ամբողջ թիվը։\n- b: Երկրորդ դրական ամբողջ թիվը։\n- Ե՛վ `a`, և՛ `b` պետք է լինեն 1-ից մինչև 50,000 միջակայքում։\n\n- Վերադարձնում է: `a` և `b` արտադրյալը որպես ամբողջ թիվ։\n\n### Օրինակ:\n- `multiply(3, 4)` վերադարձնում է `12`։\n- `multiply(10, 5)` վերադարձնում է `50`։\n- `multiply(36, 18)` վերադարձնում է `648`։\n\nՆշում: Ֆունկցիան իրականացնում է բազմապատկումը նշված միջակայքում, ապահովելով, որ 50,000-ի արժեքների համար արտահոսք չի լինի։",
      "bn": "একটি Swift ফাংশন `func multiply(_ a: Int, _ b: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি ধনাত্মক পূর্ণসংখ্যার গুণফল গণনা করে।\n\n- প্যারামিটারসমূহ:\n- a: প্রথম ধনাত্মক পূর্ণসংখ্যা।\n- b: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা।\n- উভয় `a` এবং `b` 1 থেকে 50,000 এর মধ্যে থাকা উচিত।\n\n- রিটার্ন করে: `a` এবং `b` এর গুণফল একটি পূর্ণসংখ্যা হিসেবে।\n\n### উদাহরণ:\n- `multiply(3, 4)` রিটার্ন করে `12`।\n- `multiply(10, 5)` রিটার্ন করে `50`।\n- `multiply(36, 18)` রিটার্ন করে `648`।\n\nনোট: ফাংশনটি নির্দিষ্ট সীমার মধ্যে গুণফল পরিচালনা করে, 50,000 পর্যন্ত মানের জন্য কোনো ওভারফ্লো না হওয়া নিশ্চিত করে।",
      "bg": "Напишете Swift функция `func multiply(_ a: Int, _ b: Int) -> Int {` за решаване на следния проблем:\nИзчислява произведението на две положителни цели числа.\n\n- Параметри:\n- a: Първото положително цяло число.\n- b: Второто положително цяло число.\n- И `a`, и `b` трябва да бъдат в диапазона от 1 до 50,000.\n\n- Връща: Произведението на `a` и `b` като цяло число.\n\n### Пример:\n- `multiply(3, 4)` връща `12`.\n- `multiply(10, 5)` връща `50`.\n- `multiply(36, 18)` връща `648`.\n\nЗабележка: Функцията обработва умножение в рамките на посочения диапазон, осигурявайки липса на препълване за стойности до 50,000.",
      "zh": "编写一个 Swift 函数 `func multiply(_ a: Int, _ b: Int) -> Int {` 来解决以下问题：\n计算两个正整数的乘积。\n\n- 参数：\n- a: 第一个正整数。\n- b: 第二个正整数。\n- `a` 和 `b` 都应在 1 到 50,000 的范围内。\n\n- 返回：`a` 和 `b` 的乘积，作为一个整数。\n\n### 示例：\n- `multiply(3, 4)` 返回 `12`。\n- `multiply(10, 5)` 返回 `50`。\n- `multiply(36, 18)` 返回 `648`。\n\n注意：该函数在指定范围内处理乘法，确保对于值高达 50,000 不会溢出。",
      "fr": "Écrire une fonction Swift `func multiply(_ a: Int, _ b: Int) -> Int {` pour résoudre le problème suivant :\nCalcule le produit de deux entiers positifs.\n\n- Paramètres :\n- a : Le premier entier positif.\n- b : Le deuxième entier positif.\n- Les deux `a` et `b` doivent être dans la plage de 1 à 50 000.\n\n- Renvoie : Le produit de `a` et `b` en tant qu'entier.\n\n### Exemple :\n- `multiply(3, 4)` renvoie `12`.\n- `multiply(10, 5)` renvoie `50`.\n- `multiply(36, 18)` renvoie `648`.\n\nRemarque : La fonction gère la multiplication dans la plage spécifiée, en s'assurant qu'il n'y a pas de dépassement pour les valeurs allant jusqu'à 50 000.",
      "de": "Schreiben Sie eine Swift-Funktion `func multiply(_ a: Int, _ b: Int) -> Int {`, um das folgende Problem zu lösen:\nBerechnet das Produkt von zwei positiven ganzen Zahlen.\n\n- Parameter:\n- a: Die erste positive ganze Zahl.\n- b: Die zweite positive ganze Zahl.\n- Sowohl `a` als auch `b` sollten im Bereich von 1 bis 50.000 liegen.\n\n- Rückgabe: Das Produkt von `a` und `b` als ganze Zahl.\n\n### Beispiel:\n- `multiply(3, 4)` gibt `12` zurück.\n- `multiply(10, 5)` gibt `50` zurück.\n- `multiply(36, 18)` gibt `648` zurück.\n\nHinweis: Die Funktion behandelt die Multiplikation innerhalb des angegebenen Bereichs und stellt sicher, dass es bei Werten bis zu 50.000 nicht zu einem Überlauf kommt.",
      "ha": "Rubuta aikin Swift `func multiply(_ a: Int, _ b: Int) -> Int {` don magance matsalar mai zuwa:\nYana ƙididdige samfurin lambobi masu kyau guda biyu.\n\n- Sigogi:\n- a: Lamba ta farko mai kyau.\n- b: Lamba ta biyu mai kyau.\n- Duk `a` da `b` ya kamata su kasance a cikin zangon 1 zuwa 50,000.\n\n- Yana dawowa: Samfurin `a` da `b` azaman lamba.\n\n### Misali:\n- `multiply(3, 4)` yana dawowa `12`.\n- `multiply(10, 5)` yana dawowa `50`.\n- `multiply(36, 18)` yana dawowa `648`.\n\nLura: Aikin yana sarrafa ninkawa a cikin zangon da aka fayyace, yana tabbatar da babu cika don ƙimomi har zuwa 50,000.",
      "hi": "Swift फ़ंक्शन `func multiply(_ a: Int, _ b: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो सकारात्मक पूर्णांकों का गुणनफल गणना करता है।\n\n- पैरामीटर्स:\n- a: पहला सकारात्मक पूर्णांक।\n- b: दूसरा सकारात्मक पूर्णांक।\n- दोनों `a` और `b` 1 से 50,000 की सीमा में होने चाहिए।\n\n- रिटर्न करता है: `a` और `b` का गुणनफल एक पूर्णांक के रूप में।\n\n### उदाहरण:\n- `multiply(3, 4)` `12` लौटाता है।\n- `multiply(10, 5)` `50` लौटाता है।\n- `multiply(36, 18)` `648` लौटाता है।\n\nनोट: फ़ंक्शन निर्दिष्ट सीमा के भीतर गुणन को संभालता है, यह सुनिश्चित करते हुए कि 50,000 तक के मानों के लिए कोई ओवरफ्लो नहीं होता।",
      "hu": "Írj egy Swift függvényt `func multiply(_ a: Int, _ b: Int) -> Int {` a következő probléma megoldására:\nKiszámítja két pozitív egész szám szorzatát.\n\n- Paraméterek:\n- a: Az első pozitív egész szám.\n- b: A második pozitív egész szám.\n- Mindkettő, `a` és `b`, az 1 és 50,000 közötti tartományban kell legyen.\n\n- Visszatér: `a` és `b` szorzata egész számként.\n\n### Példa:\n- `multiply(3, 4)` visszatér `12`.\n- `multiply(10, 5)` visszatér `50`.\n- `multiply(36, 18)` visszatér `648`.\n\nMegjegyzés: A függvény kezeli a szorzást a megadott tartományon belül, biztosítva, hogy ne legyen túlcsordulás 50,000-ig terjedő értékek esetén."
    },
    "instruction_bertscore": {
      "sq": "0.9901765358755386",
      "hy": "0.9898249601011068",
      "bn": "0.9861860515205476",
      "bg": "0.9974938804824828",
      "zh": "0.9920778258828045",
      "fr": "0.9926963608893472",
      "de": "0.994483041166756",
      "ha": "0.979321981443125",
      "hi": "0.9860412499727732",
      "hu": "0.9911017561903991"
    },
    "level": "easy",
    "test": "func testMultiply() {\n    assert(multiply(3, 4) == 12, \"Product of 3 and 4 should be 12.\")\n    assert(multiply(10, 5) == 50, \"Product of 10 and 5 should be 50.\")\n    assert(multiply(36, 18) == 648, \"Product of 36 and 18 should be 648.\")\n    assert(multiply(1, 50000) == 50000, \"Product of 1 and 50000 should be 50000.\")\n    assert(multiply(123, 456) == 56088, \"Product of 123 and 456 should be 56088.\")\n    assert(multiply(500, 100) == 50000, \"Product of 500 and 100 should be 50000.\")\n}\n\n// Call the test function to verify the functionality\ntestMultiply()",
    "entry_point": "multiply",
    "signature": "func multiply(_ a: Int, _ b: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the product of two positive integers.\n\n- Parameters:\n- a: The first positive integer.\n- b: The second positive integer.\n- Both `a` and `b` should be in the range of 1 to 50,000.\n\n- Returns: The product of `a` and `b` as an integer.\n\n### Example:\n- `multiply(3, 4)` returns `12`.\n- `multiply(10, 5)` returns `50`.\n- `multiply(36, 18)` returns `648`.\n\nNote: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n",
      "sq": "Llogarit prodhimin e dy numrave të plotë pozitivë.\n\n- Parametrat:\n- a: Numri i parë i plotë pozitiv.\n- b: Numri i dytë i plotë pozitiv.\n- Të dy `a` dhe `b` duhet të jenë në intervalin nga 1 deri në 50,000.\n\n- Kthen: Prodhimi i `a` dhe `b` si një numër i plotë.\n\n### Shembull:\n- `multiply(3, 4)` kthen `12`.\n- `multiply(10, 5)` kthen `50`.\n- `multiply(36, 18)` kthen `648`.\n\nShënim: Funksioni trajton shumëzimin brenda intervalit të specifikuar, duke siguruar që nuk ka mbingarkesë për vlerat deri në 50,000.",
      "hy": "Հաշվում է երկու դրական ամբողջ թվերի արտադրյալը։\n\n- Պարամետրեր:\n- a: Առաջին դրական ամբողջ թիվը։\n- b: Երկրորդ դրական ամբողջ թիվը։\n- Ե՛վ `a`, և՛ `b` պետք է լինեն 1-ից մինչև 50,000 միջակայքում։\n\n- Վերադարձնում է: `a` և `b` արտադրյալը որպես ամբողջ թիվ։\n\n### Օրինակ:\n- `multiply(3, 4)` վերադարձնում է `12`։\n- `multiply(10, 5)` վերադարձնում է `50`։\n- `multiply(36, 18)` վերադարձնում է `648`։\n\nՆշում: Ֆունկցիան կատարում է բազմապատկում նշված միջակայքում՝ ապահովելով, որ չլինի գերազանցում մինչև 50,000 արժեքների համար։",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যার গুণফল গণনা করে।\n\n- প্যারামিটারসমূহ:\n- a: প্রথম ধনাত্মক পূর্ণসংখ্যা।\n- b: দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা।\n- উভয় `a` এবং `b` এর মান 1 থেকে 50,000 এর মধ্যে হওয়া উচিত।\n\n- রিটার্নস: `a` এবং `b` এর গুণফল একটি পূর্ণসংখ্যা হিসেবে।\n\n### উদাহরণ:\n- `multiply(3, 4)` রিটার্ন করে `12`।\n- `multiply(10, 5)` রিটার্ন করে `50`।\n- `multiply(36, 18)` রিটার্ন করে `648`।\n\nনোট: ফাংশনটি নির্দিষ্ট সীমার মধ্যে গুণফল পরিচালনা করে, 50,000 পর্যন্ত মানের জন্য কোন ওভারফ্লো না হওয়া নিশ্চিত করে।",
      "bg": "Изчислява произведението на две положителни цели числа.\n\n- Параметри:\n- a: Първото положително цяло число.\n- b: Второто положително цяло число.\n- И двете `a` и `b` трябва да бъдат в диапазона от 1 до 50,000.\n\n- Връща: Произведението на `a` и `b` като цяло число.\n\n### Пример:\n- `multiply(3, 4)` връща `12`.\n- `multiply(10, 5)` връща `50`.\n- `multiply(36, 18)` връща `648`.\n\nЗабележка: Функцията обработва умножение в рамките на специфицирания диапазон, осигурявайки липса на препълване за стойности до 50,000.",
      "zh": "计算两个正整数的乘积。\n\n- 参数：\n- a: 第一个正整数。\n- b: 第二个正整数。\n- `a` 和 `b` 都应该在 1 到 50,000 的范围内。\n\n- 返回：`a` 和 `b` 的乘积，返回一个整数。\n\n### 示例：\n- `multiply(3, 4)` 返回 `12`。\n- `multiply(10, 5)` 返回 `50`。\n- `multiply(36, 18)` 返回 `648`。\n\n注意：该函数在指定范围内处理乘法，确保对于值高达 50,000 不会溢出。",
      "fr": "Calcule le produit de deux entiers positifs.\n\n- Paramètres :\n- a : Le premier entier positif.\n- b : Le deuxième entier positif.\n- Les deux `a` et `b` doivent être dans la plage de 1 à 50 000.\n\n- Renvoie : Le produit de `a` et `b` en tant qu'entier.\n\n### Exemple :\n- `multiply(3, 4)` renvoie `12`.\n- `multiply(10, 5)` renvoie `50`.\n- `multiply(36, 18)` renvoie `648`.\n\nRemarque : La fonction gère la multiplication dans la plage spécifiée, en s'assurant qu'il n'y a pas de débordement pour des valeurs allant jusqu'à 50 000.",
      "de": "Berechnet das Produkt von zwei positiven ganzen Zahlen.\n\n- Parameter:\n- a: Die erste positive ganze Zahl.\n- b: Die zweite positive ganze Zahl.\n- Sowohl `a` als auch `b` sollten im Bereich von 1 bis 50.000 liegen.\n\n- Rückgabewert: Das Produkt von `a` und `b` als ganze Zahl.\n\n### Beispiel:\n- `multiply(3, 4)` gibt `12` zurück.\n- `multiply(10, 5)` gibt `50` zurück.\n- `multiply(36, 18)` gibt `648` zurück.\n\nHinweis: Die Funktion behandelt die Multiplikation innerhalb des angegebenen Bereichs und stellt sicher, dass es zu keinem Überlauf bei Werten bis zu 50.000 kommt.",
      "ha": "Calculates the product of two positive integers.\n\n- Sigogi:\n- a: Na farko lamba mai kyau.\n- b: Na biyu lamba mai kyau.\n- Duk `a` da `b` ya kamata su kasance a cikin kewayon 1 zuwa 50,000.\n\n- Komawa: Samfurin `a` da `b` a matsayin lamba.\n\n### Misali:\n- `multiply(3, 4)` yana dawowa `12`.\n- `multiply(10, 5)` yana dawowa `50`.\n- `multiply(36, 18)` yana dawowa `648`.\n\nLura: Aikin yana sarrafa ninkawa a cikin kewayon da aka kayyade, yana tabbatar da babu cika iyaka don ƙimomi har zuwa 50,000.",
      "hi": "दो सकारात्मक पूर्णांकों का गुणनफल गणना करता है।\n\n- पैरामीटर्स:\n- a: पहला सकारात्मक पूर्णांक।\n- b: दूसरा सकारात्मक पूर्णांक।\n- दोनों `a` और `b` को 1 से 50,000 की सीमा में होना चाहिए।\n\n- रिटर्न्स: `a` और `b` का गुणनफल एक पूर्णांक के रूप में।\n\n### उदाहरण:\n- `multiply(3, 4)` `12` लौटाता है।\n- `multiply(10, 5)` `50` लौटाता है।\n- `multiply(36, 18)` `648` लौटाता है।\n\nध्यान दें: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर गुणन को संभालता है, यह सुनिश्चित करते हुए कि 50,000 तक के मानों के लिए कोई ओवरफ्लो न हो।",
      "hu": "Kiszámítja két pozitív egész szám szorzatát.\n\n- Paraméterek:\n- a: Az első pozitív egész szám.\n- b: A második pozitív egész szám.\n- Mind az `a`, mind a `b` az 1 és 50,000 közötti tartományban kell legyen.\n\n- Visszatér: Az `a` és `b` szorzata egész számként.\n\n### Példa:\n- `multiply(3, 4)` visszaadja `12`.\n- `multiply(10, 5)` visszaadja `50`.\n- `multiply(36, 18)` visszaadja `648`.\n\nMegjegyzés: A függvény kezeli a szorzást a megadott tartományon belül, biztosítva, hogy ne legyen túlcsordulás 50,000-ig terjedő értékek esetén."
    },
    "docstring_bertscore": {
      "sq": "0.9896477818012237",
      "hy": "0.9892664114696367",
      "bn": "0.9858821470375643",
      "bg": "0.9939320404897652",
      "zh": "0.9852215023902422",
      "fr": "0.9920108874443958",
      "de": "0.9903261045524578",
      "ha": "0.9895135076636441",
      "hi": "0.9876706149884025",
      "hu": "0.9934851221324367"
    }
  },
  {
    "task_id": "Swift/48",
    "prompt": {
      "en": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calculates the power of 2 for a given non-negative integer.\n\n    - Parameters:\n        - n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n    - Returns: The result of 2 raised to the power of `n`.\n\n    ### Example:\n    - `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n    - `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n    - `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\n    Note: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n    */",
      "sq": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Llogarit fuqinë e 2 për një numër të plotë jo-negativ të dhënë.\n\n    - Parametrat:\n        - n: Një numër i plotë jo-negativ për të cilin llogaritet fuqia e 2. Vlera e `n` duhet të jetë në intervalin nga 0 deri në 30, përfshirë.\n\n    - Kthen: Rezultatin e 2 të ngritur në fuqinë e `n`.\n\n    ### Shembull:\n    - `powerOfTwo(3)` kthen `8`, pasi 2^3 = 8.\n    - `powerOfTwo(5)` kthen `32`, pasi 2^5 = 32.\n    - `powerOfTwo(10)` kthen `1024`, pasi 2^10 = 1024.\n\n    Shënim: Funksioni është projektuar për të trajtuar hyrjet brenda intervalit të specifikuar pa rezultuar në tejmbushje të numrit të plotë.\n    */",
      "hy": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Հաշվում է 2-ի աստիճանը տրված ոչ բացասական ամբողջ թվի համար։\n\n    - Պարամետրեր:\n        - n: Ոչ բացասական ամբողջ թիվ, որի համար հաշվվում է 2-ի աստիճանը։ `n`-ի արժեքը պետք է լինի 0-ից 30 միջակայքում, ներառյալ։\n\n    - Վերադարձնում է: 2-ի `n` աստիճանի արդյունքը։\n\n    ### Օրինակ:\n    - `powerOfTwo(3)` վերադարձնում է `8`, քանի որ 2^3 = 8։\n    - `powerOfTwo(5)` վերադարձնում է `32`, քանի որ 2^5 = 32։\n    - `powerOfTwo(10)` վերադարձնում է `1024`, քանի որ 2^10 = 1024։\n\n    Նշում: Ֆունկցիան նախատեսված է մուտքերը նշված միջակայքում մշակելու համար՝ առանց ամբողջ թվի գերազանցման։\n    */",
      "bn": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    প্রদত্ত একটি অ-ঋণাত্মক পূর্ণসংখ্যার জন্য 2 এর ঘাত নির্ণয় করে।\n\n    - প্যারামিটার:\n        - n: একটি অ-ঋণাত্মক পূর্ণসংখ্যা যার জন্য 2 এর ঘাত নির্ণয় করা হয়। `n` এর মান অবশ্যই 0 থেকে 30 এর মধ্যে থাকতে হবে, অন্তর্ভুক্ত।\n\n    - রিটার্নস: `n` এর ঘাত হিসেবে 2 এর ফলাফল প্রদান করে।\n\n    ### উদাহরণ:\n    - `powerOfTwo(3)` `8` প্রদান করে, কারণ 2^3 = 8।\n    - `powerOfTwo(5)` `32` প্রদান করে, কারণ 2^5 = 32।\n    - `powerOfTwo(10)` `1024` প্রদান করে, কারণ 2^10 = 1024।\n\n    নোট: ফাংশনটি নির্দিষ্ট পরিসরের মধ্যে ইনপুটগুলি পরিচালনা করার জন্য ডিজাইন করা হয়েছে যাতে পূর্ণসংখ্যার ওভারফ্লো না ঘটে।\n    */",
      "bg": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Изчислява степента на 2 за дадено неотрицателно цяло число.\n\n    - Параметри:\n        - n: Неотрицателно цяло число, за което се изчислява степента на 2. Стойността на `n` трябва да бъде в диапазона от 0 до 30, включително.\n\n    - Връща: Резултатът от 2, повдигнато на степен `n`.\n\n    ### Пример:\n    - `powerOfTwo(3)` връща `8`, тъй като 2^3 = 8.\n    - `powerOfTwo(5)` връща `32`, тъй като 2^5 = 32.\n    - `powerOfTwo(10)` връща `1024`, тъй като 2^10 = 1024.\n\n    Забележка: Функцията е проектирана да обработва входни данни в рамките на специфицирания диапазон без да води до препълване на целочисления тип.\n    */",
      "zh": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    计算给定非负整数的2的幂。\n\n    - 参数:\n        - n: 计算2的幂的非负整数。`n`的值必须在0到30之间（包括0和30）。\n\n    - 返回: 2的`n`次幂的结果。\n\n    ### 示例:\n    - `powerOfTwo(3)` 返回 `8`，因为 2^3 = 8。\n    - `powerOfTwo(5)` 返回 `32`，因为 2^5 = 32。\n    - `powerOfTwo(10)` 返回 `1024`，因为 2^10 = 1024。\n\n    注意: 该函数设计为处理指定范围内的输入而不会导致整数溢出。\n    */",
      "fr": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calcule la puissance de 2 pour un entier non négatif donné.\n\n    - Paramètres:\n        - n: Un entier non négatif pour lequel la puissance de 2 est calculée. La valeur de `n` doit être dans la plage de 0 à 30, inclus.\n\n    - Renvoie: Le résultat de 2 élevé à la puissance de `n`.\n\n    ### Exemple:\n    - `powerOfTwo(3)` renvoie `8`, car 2^3 = 8.\n    - `powerOfTwo(5)` renvoie `32`, car 2^5 = 32.\n    - `powerOfTwo(10)` renvoie `1024`, car 2^10 = 1024.\n\n    Remarque: La fonction est conçue pour gérer les entrées dans la plage spécifiée sans entraîner de dépassement d'entier.\n    */",
      "de": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Berechnet die Potenz von 2 für eine gegebene nicht-negative ganze Zahl.\n\n    - Parameter:\n        - n: Eine nicht-negative ganze Zahl, für die die Potenz von 2 berechnet wird. Der Wert von `n` muss im Bereich von 0 bis 30 liegen, einschließlich.\n\n    - Rückgabe: Das Ergebnis von 2 hoch `n`.\n\n    ### Beispiel:\n    - `powerOfTwo(3)` gibt `8` zurück, da 2^3 = 8.\n    - `powerOfTwo(5)` gibt `32` zurück, da 2^5 = 32.\n    - `powerOfTwo(10)` gibt `1024` zurück, da 2^10 = 1024.\n\n    Hinweis: Die Funktion ist so konzipiert, dass sie Eingaben innerhalb des angegebenen Bereichs ohne Ganzzahlüberlauf verarbeitet.\n    */",
      "ha": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Yana lissafin ƙarfin 2 don wani cikakken lamba mara kyau.\n\n    - Sigogi:\n        - n: Cikakken lamba mara kyau wanda za a lissafa ƙarfin 2. Darajar `n` dole ne ta kasance a cikin zangon 0 zuwa 30, ciki har da.\n\n    - Komawa: Sakamakon 2 da aka ɗaga zuwa ƙarfin `n`.\n\n    ### Misali:\n    - `powerOfTwo(3)` yana dawowa `8`, saboda 2^3 = 8.\n    - `powerOfTwo(5)` yana dawowa `32`, saboda 2^5 = 32.\n    - `powerOfTwo(10)` yana dawowa `1024`, saboda 2^10 = 1024.\n\n    Lura: An tsara aikin don sarrafa shigarwa a cikin zangon da aka fayyace ba tare da haifar da cika lambobi ba.\n    */",
      "hi": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    दिए गए गैर-ऋणात्मक पूर्णांक के लिए 2 की घात की गणना करता है।\n\n    - पैरामीटर्स:\n        - n: एक गैर-ऋणात्मक पूर्णांक जिसके लिए 2 की घात की गणना की जाती है। `n` का मान 0 से 30 के बीच होना चाहिए, दोनों शामिल।\n\n    - रिटर्न्स: `n` की घात के रूप में 2 का परिणाम।\n\n    ### उदाहरण:\n    - `powerOfTwo(3)` `8` लौटाता है, क्योंकि 2^3 = 8।\n    - `powerOfTwo(5)` `32` लौटाता है, क्योंकि 2^5 = 32।\n    - `powerOfTwo(10)` `1024` लौटाता है, क्योंकि 2^10 = 1024।\n\n    नोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर इनपुट को संभालने के लिए डिज़ाइन किया गया है, बिना पूर्णांक ओवरफ्लो के।\n    */",
      "hu": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Kiszámítja a 2 hatványát egy adott nem negatív egész számra.\n\n    - Paraméterek:\n        - n: Egy nem negatív egész szám, amelyre a 2 hatványát kiszámítjuk. Az `n` értékének 0 és 30 között kell lennie, beleértve.\n\n    - Visszatér: A 2 `n` hatványra emelésének eredménye.\n\n    ### Példa:\n    - `powerOfTwo(3)` visszaadja `8`, mivel 2^3 = 8.\n    - `powerOfTwo(5)` visszaadja `32`, mivel 2^5 = 32.\n    - `powerOfTwo(10)` visszaadja `1024`, mivel 2^10 = 1024.\n\n    Megjegyzés: A függvény úgy van tervezve, hogy a megadott tartományon belüli bemeneteket kezelje anélkül, hogy egész szám túlcsordulást eredményezne.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9868395454741524",
      "hy": "0.9800213590147488",
      "bn": "0.96148457596543",
      "bg": "0.9852622216183544",
      "zh": "0.968703399903381",
      "fr": "0.9858813525160401",
      "de": "0.9779643427887516",
      "ha": "0.9791118304999902",
      "hi": "0.9729763366602034",
      "hu": "0.9802946744190529"
    },
    "canonical_solution": "    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}",
    "instruction": {
      "en": "Write a Swift function `func powerOfTwo(_ n: Int) -> Int {` to solve the following problem:\nCalculates the power of 2 for a given non-negative integer.\n\n- Parameters:\n- n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n- Returns: The result of 2 raised to the power of `n`.\n\n### Example:\n- `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n- `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n- `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\nNote: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n",
      "sq": "Shkruani një funksion Swift `func powerOfTwo(_ n: Int) -> Int {` për të zgjidhur problemin e mëposhtëm:\nLlogarit fuqinë e 2 për një numër të dhënë jo-negativ.\n\n- Parametrat:\n- n: Një numër i plotë jo-negativ për të cilin llogaritet fuqia e 2. Vlera e `n` duhet të jetë në intervalin nga 0 deri në 30, përfshirë.\n\n- Kthen: Rezultatin e 2 ngritur në fuqinë e `n`.\n\n### Shembull:\n- `powerOfTwo(3)` kthen `8`, pasi 2^3 = 8.\n- `powerOfTwo(5)` kthen `32`, pasi 2^5 = 32.\n- `powerOfTwo(10)` kthen `1024`, pasi 2^10 = 1024.\n\nShënim: Funksioni është projektuar për të trajtuar hyrjet brenda intervalit të specifikuar pa rezultuar në tejmbushje të numrit të plotë.",
      "hy": "Գրեք Swift ֆունկցիա `func powerOfTwo(_ n: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է 2-ի աստիճանը տրված ոչ բացասական ամբողջ թվի համար։\n\n- Պարամետրեր:\n- n: Ոչ բացասական ամբողջ թիվ, որի համար հաշվարկվում է 2-ի աստիճանը։ `n`-ի արժեքը պետք է լինի 0-ից 30 միջակայքում, ներառյալ։\n\n- Վերադարձնում է: 2-ի `n` աստիճանի արդյունքը։\n\n### Օրինակ:\n- `powerOfTwo(3)` վերադարձնում է `8`, քանի որ 2^3 = 8։\n- `powerOfTwo(5)` վերադարձնում է `32`, քանի որ 2^5 = 32։\n- `powerOfTwo(10)` վերադարձնում է `1024`, քանի որ 2^10 = 1024։\n\nՆշում: Ֆունկցիան նախատեսված է մշակելու նշված միջակայքի ներսում գտնվող մուտքերը՝ առանց ամբողջ թվի գերազանցման։",
      "bn": "একটি Swift ফাংশন `func powerOfTwo(_ n: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অ-ঋণাত্মক পূর্ণসংখ্যার জন্য 2 এর ঘাত নির্ণয় করে।\n\n- প্যারামিটারসমূহ:\n- n: একটি অ-ঋণাত্মক পূর্ণসংখ্যা যার জন্য 2 এর ঘাত নির্ণয় করা হয়। `n` এর মান অবশ্যই 0 থেকে 30 এর মধ্যে হতে হবে, অন্তর্ভুক্ত।\n\n- রিটার্নস: `n` এর ঘাত হিসাবে 2 এর ফলাফল।\n\n### উদাহরণ:\n- `powerOfTwo(3)` `8` রিটার্ন করে, কারণ 2^3 = 8।\n- `powerOfTwo(5)` `32` রিটার্ন করে, কারণ 2^5 = 32।\n- `powerOfTwo(10)` `1024` রিটার্ন করে, কারণ 2^10 = 1024।\n\nনোট: ফাংশনটি নির্দিষ্ট পরিসরের মধ্যে ইনপুটগুলি পরিচালনা করার জন্য ডিজাইন করা হয়েছে যাতে পূর্ণসংখ্যার ওভারফ্লো না ঘটে।",
      "bg": "Напишете Swift функция `func powerOfTwo(_ n: Int) -> Int {` за решаване на следния проблем:\nИзчислява степента на 2 за дадено неотрицателно цяло число.\n\n- Параметри:\n- n: Неотрицателно цяло число, за което се изчислява степента на 2. Стойността на `n` трябва да бъде в диапазона от 0 до 30, включително.\n\n- Връща: Резултатът от 2, повдигнато на степен `n`.\n\n### Пример:\n- `powerOfTwo(3)` връща `8`, тъй като 2^3 = 8.\n- `powerOfTwo(5)` връща `32`, тъй като 2^5 = 32.\n- `powerOfTwo(10)` връща `1024`, тъй като 2^10 = 1024.\n\nЗабележка: Функцията е проектирана да обработва входове в рамките на посочения диапазон без да води до препълване на целочислената стойност.",
      "zh": "编写一个 Swift 函数 `func powerOfTwo(_ n: Int) -> Int {` 来解决以下问题：\n计算给定非负整数的2的幂。\n\n- 参数：\n- n: 计算2的幂的非负整数。`n` 的值必须在0到30之间，包括0和30。\n\n- 返回：2的`n`次幂的结果。\n\n### 示例：\n- `powerOfTwo(3)` 返回 `8`，因为 2^3 = 8。\n- `powerOfTwo(5)` 返回 `32`，因为 2^5 = 32。\n- `powerOfTwo(10)` 返回 `1024`，因为 2^10 = 1024。\n\n注意：该函数设计用于处理指定范围内的输入，而不会导致整数溢出。",
      "fr": "Écrire une fonction Swift `func powerOfTwo(_ n: Int) -> Int {` pour résoudre le problème suivant :\nCalcule la puissance de 2 pour un entier non négatif donné.\n\n- Paramètres :\n- n : Un entier non négatif pour lequel la puissance de 2 est calculée. La valeur de `n` doit être dans la plage de 0 à 30, inclus.\n\n- Renvoie : Le résultat de 2 élevé à la puissance de `n`.\n\n### Exemple :\n- `powerOfTwo(3)` renvoie `8`, car 2^3 = 8.\n- `powerOfTwo(5)` renvoie `32`, car 2^5 = 32.\n- `powerOfTwo(10)` renvoie `1024`, car 2^10 = 1024.\n\nRemarque : La fonction est conçue pour gérer les entrées dans la plage spécifiée sans entraîner de dépassement d'entier.",
      "de": "Schreiben Sie eine Swift-Funktion `func powerOfTwo(_ n: Int) -> Int {`, um das folgende Problem zu lösen:\nBerechnet die Potenz von 2 für eine gegebene nicht-negative ganze Zahl.\n\n- Parameter:\n- n: Eine nicht-negative ganze Zahl, für die die Potenz von 2 berechnet wird. Der Wert von `n` muss im Bereich von 0 bis 30 liegen, einschließlich.\n\n- Rückgabe: Das Ergebnis von 2 hoch `n`.\n\n### Beispiel:\n- `powerOfTwo(3)` gibt `8` zurück, da 2^3 = 8.\n- `powerOfTwo(5)` gibt `32` zurück, da 2^5 = 32.\n- `powerOfTwo(10)` gibt `1024` zurück, da 2^10 = 1024.\n\nHinweis: Die Funktion ist so konzipiert, dass sie Eingaben innerhalb des angegebenen Bereichs ohne ganzzahligen Überlauf verarbeitet.",
      "ha": "Rubuta aikin Swift `func powerOfTwo(_ n: Int) -> Int {` don warware matsalar mai zuwa:\nLissafa ikon 2 don wani baƙaƙen lamba mara kyau.\n\n- Sigogi:\n- n: Baƙaƙen lamba mara kyau wanda za a lissafa ikon 2. Darajar `n` dole ne ta kasance a cikin kewayon 0 zuwa 30, ciki har da.\n\n- Komawa: Sakamakon 2 da aka ɗaga zuwa ikon `n`.\n\n### Misali:\n- `powerOfTwo(3)` yana dawowa `8`, domin 2^3 = 8.\n- `powerOfTwo(5)` yana dawowa `32`, domin 2^5 = 32.\n- `powerOfTwo(10)` yana dawowa `1024`, domin 2^10 = 1024.\n\nLura: An tsara aikin don sarrafa shigarwa a cikin kewayon da aka ayyana ba tare da haifar da cikar lamba ba.",
      "hi": "Swift फ़ंक्शन `func powerOfTwo(_ n: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए गैर-ऋणात्मक पूर्णांक के लिए 2 की घात की गणना करता है।\n\n- पैरामीटर्स:\n- n: एक गैर-ऋणात्मक पूर्णांक जिसके लिए 2 की घात की गणना की जाती है। `n` का मान 0 से 30 की सीमा में होना चाहिए, समावेशी।\n\n- रिटर्न्स: `n` की घात के रूप में 2 का परिणाम।\n\n### उदाहरण:\n- `powerOfTwo(3)` `8` लौटाता है, क्योंकि 2^3 = 8।\n- `powerOfTwo(5)` `32` लौटाता है, क्योंकि 2^5 = 32।\n- `powerOfTwo(10)` `1024` लौटाता है, क्योंकि 2^10 = 1024।\n\nनोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर इनपुट को संभालने के लिए डिज़ाइन किया गया है, जिससे पूर्णांक ओवरफ्लो नहीं होगा।",
      "hu": "Írj egy Swift függvényt `func powerOfTwo(_ n: Int) -> Int {` a következő probléma megoldására:\nKiszámítja a 2 hatványát egy adott nem negatív egész számra.\n\n- Paraméterek:\n- n: Egy nem negatív egész szám, amelyre a 2 hatványát kiszámítjuk. Az `n` értékének 0 és 30 között kell lennie, beleértve.\n\n- Visszatérési érték: A 2 `n` hatványra emelésének eredménye.\n\n### Példa:\n- `powerOfTwo(3)` visszaadja `8`, mivel 2^3 = 8.\n- `powerOfTwo(5)` visszaadja `32`, mivel 2^5 = 32.\n- `powerOfTwo(10)` visszaadja `1024`, mivel 2^10 = 1024.\n\nMegjegyzés: A függvény úgy van tervezve, hogy a megadott tartományon belüli bemeneteket kezelje anélkül, hogy egész szám túlcsordulást eredményezne."
    },
    "instruction_bertscore": {
      "sq": "0.9839456994528551",
      "hy": "0.9790707140111159",
      "bn": "0.9668209797823133",
      "bg": "0.9859341881973954",
      "zh": "0.9679233783970569",
      "fr": "0.9874525188300262",
      "de": "0.980056317961811",
      "ha": "0.9805938117728914",
      "hi": "0.9660570473368532",
      "hu": "0.9804966815165653"
    },
    "level": "easy",
    "test": "func testPowerOfTwo() {\n    assert(powerOfTwo(3) == 8, \"2^3 should be 8.\")\n    assert(powerOfTwo(5) == 32, \"2^5 should be 32.\")\n    assert(powerOfTwo(10) == 1024, \"2^10 should be 1024.\")\n    assert(powerOfTwo(0) == 1, \"2^0 should be 1.\")\n    assert(powerOfTwo(15) == 32768, \"2^15 should be 32768.\")\n    assert(powerOfTwo(30) == 1073741824, \"2^30 should be 1073741824.\")\n}\n\n// Call the test function to verify the functionality\ntestPowerOfTwo()",
    "entry_point": "powerOfTwo",
    "signature": "func powerOfTwo(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the power of 2 for a given non-negative integer.\n\n- Parameters:\n- n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n- Returns: The result of 2 raised to the power of `n`.\n\n### Example:\n- `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n- `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n- `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\nNote: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n",
      "sq": "Llogarit fuqinë e 2 për një numër të plotë jo-negativ të dhënë.\n\n- Parametrat:\n- n: Një numër i plotë jo-negativ për të cilin llogaritet fuqia e 2. Vlera e `n` duhet të jetë në intervalin nga 0 deri në 30, përfshirë.\n\n- Kthen: Rezultatin e 2 ngritur në fuqinë e `n`.\n\n### Shembull:\n- `powerOfTwo(3)` kthen `8`, pasi 2^3 = 8.\n- `powerOfTwo(5)` kthen `32`, pasi 2^5 = 32.\n- `powerOfTwo(10)` kthen `1024`, pasi 2^10 = 1024.\n\nShënim: Funksioni është projektuar për të trajtuar hyrjet brenda intervalit të specifikuar pa rezultuar në tejmbushje të numrit të plotë.",
      "hy": "Հաշվում է 2-ի աստիճանը տրված ոչ բացասական ամբողջ թվի համար:\n\n- Պարամետրեր:\n- n: Ոչ բացասական ամբողջ թիվ, որի համար հաշվվում է 2-ի աստիճանը: `n`-ի արժեքը պետք է լինի 0-ից 30 միջակայքում, ներառյալ:\n\n- Վերադարձնում է: 2-ի `n` աստիճանի արդյունքը:\n\n### Օրինակ:\n- `powerOfTwo(3)` վերադարձնում է `8`, քանի որ 2^3 = 8:\n- `powerOfTwo(5)` վերադարձնում է `32`, քանի որ 2^5 = 32:\n- `powerOfTwo(10)` վերադարձնում է `1024`, քանի որ 2^10 = 1024:\n\nՆշում: Ֆունկցիան նախատեսված է մուտքային արժեքները նշված միջակայքում մշակելու համար՝ առանց ամբողջ թվի արտահոսքի առաջացման:",
      "bn": "2 এর ঘাত একটি প্রদত্ত অ-ঋণাত্মক পূর্ণসংখ্যার জন্য গণনা করে।\n\n- প্যারামিটারসমূহ:\n- n: একটি অ-ঋণাত্মক পূর্ণসংখ্যা যার জন্য 2 এর ঘাত গণনা করা হয়। `n` এর মান অবশ্যই 0 থেকে 30 এর মধ্যে হতে হবে, অন্তর্ভুক্ত।\n\n- রিটার্নস: `n` এর ঘাত হিসেবে 2 এর ফলাফল।\n\n### উদাহরণ:\n- `powerOfTwo(3)` `8` রিটার্ন করে, কারণ 2^3 = 8।\n- `powerOfTwo(5)` `32` রিটার্ন করে, কারণ 2^5 = 32।\n- `powerOfTwo(10)` `1024` রিটার্ন করে, কারণ 2^10 = 1024।\n\nদ্রষ্টব্য: ফাংশনটি নির্দিষ্ট পরিসরের মধ্যে ইনপুটগুলি পরিচালনা করার জন্য ডিজাইন করা হয়েছে যাতে পূর্ণসংখ্যার ওভারফ্লো না ঘটে।",
      "bg": "Изчислява степента на 2 за дадено неотрицателно цяло число.\n\n- Параметри:\n- n: Неотрицателно цяло число, за което се изчислява степента на 2. Стойността на `n` трябва да бъде в диапазона от 0 до 30, включително.\n\n- Връща: Резултатът от 2, повдигнато на степен `n`.\n\n### Пример:\n- `powerOfTwo(3)` връща `8`, тъй като 2^3 = 8.\n- `powerOfTwo(5)` връща `32`, тъй като 2^5 = 32.\n- `powerOfTwo(10)` връща `1024`, тъй като 2^10 = 1024.\n\nЗабележка: Функцията е проектирана да обработва входни данни в рамките на посочения диапазон без да води до препълване на цяло число.",
      "zh": "计算给定非负整数的2的幂。\n\n- 参数：\n- n: 计算2的幂的非负整数。`n`的值必须在0到30之间（包括0和30）。\n\n- 返回值：2的`n`次幂的结果。\n\n### 示例：\n- `powerOfTwo(3)` 返回 `8`，因为2^3 = 8。\n- `powerOfTwo(5)` 返回 `32`，因为2^5 = 32。\n- `powerOfTwo(10)` 返回 `1024`，因为2^10 = 1024。\n\n注意：该函数设计用于处理指定范围内的输入，不会导致整数溢出。",
      "fr": "Calcule la puissance de 2 pour un entier non négatif donné.\n\n- Paramètres :\n- n : Un entier non négatif pour lequel la puissance de 2 est calculée. La valeur de `n` doit être dans la plage de 0 à 30, inclus.\n\n- Renvoie : Le résultat de 2 élevé à la puissance de `n`.\n\n### Exemple :\n- `powerOfTwo(3)` renvoie `8`, car 2^3 = 8.\n- `powerOfTwo(5)` renvoie `32`, car 2^5 = 32.\n- `powerOfTwo(10)` renvoie `1024`, car 2^10 = 1024.\n\nRemarque : La fonction est conçue pour gérer les entrées dans la plage spécifiée sans entraîner de dépassement de capacité des entiers.",
      "de": "Berechnet die Potenz von 2 für eine gegebene nicht-negative ganze Zahl.\n\n- Parameter:\n- n: Eine nicht-negative ganze Zahl, für die die Potenz von 2 berechnet wird. Der Wert von `n` muss im Bereich von 0 bis 30 liegen, einschließlich.\n\n- Rückgabewert: Das Ergebnis von 2 hoch `n`.\n\n### Beispiel:\n- `powerOfTwo(3)` gibt `8` zurück, da 2^3 = 8.\n- `powerOfTwo(5)` gibt `32` zurück, da 2^5 = 32.\n- `powerOfTwo(10)` gibt `1024` zurück, da 2^10 = 1024.\n\nHinweis: Die Funktion ist so konzipiert, dass sie Eingaben innerhalb des angegebenen Bereichs ohne Ganzzahlüberlauf verarbeitet.",
      "ha": "Calculates the power of 2 for a given non-negative integer.\n\n- Sigogi:\n- n: Wani lamba maras tabbatacce wanda ake lissafin ikon 2. Dole ne darajar `n` ta kasance a cikin kewayon 0 zuwa 30, ciki har da.\n\n- Komawa: Sakamakon 2 da aka ɗaga zuwa ikon `n`.\n\n### Misali:\n- `powerOfTwo(3)` yana dawowa `8`, kamar yadda 2^3 = 8.\n- `powerOfTwo(5)` yana dawowa `32`, kamar yadda 2^5 = 32.\n- `powerOfTwo(10)` yana dawowa `1024`, kamar yadda 2^10 = 1024.\n\nLura: An tsara aikin don sarrafa shigarwa a cikin kewayon da aka kayyade ba tare da haifar da cunkoson lamba ba.",
      "hi": "2 की शक्ति की गणना एक दिए गए गैर-ऋणात्मक पूर्णांक के लिए करता है।\n\n- पैरामीटर्स:\n- n: एक गैर-ऋणात्मक पूर्णांक जिसके लिए 2 की शक्ति की गणना की जाती है। `n` का मान 0 से 30 की सीमा में होना चाहिए, समावेशी।\n\n- रिटर्न्स: `n` की शक्ति पर 2 उठाने का परिणाम।\n\n### उदाहरण:\n- `powerOfTwo(3)` `8` लौटाता है, क्योंकि 2^3 = 8।\n- `powerOfTwo(5)` `32` लौटाता है, क्योंकि 2^5 = 32।\n- `powerOfTwo(10)` `1024` लौटाता है, क्योंकि 2^10 = 1024।\n\nनोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर इनपुट को संभालने के लिए डिज़ाइन किया गया है, बिना पूर्णांक ओवरफ्लो के परिणामस्वरूप।",
      "hu": "Kiszámítja egy adott nem negatív egész szám 2 hatványát.\n\n- Paraméterek:\n- n: Egy nem negatív egész szám, amelynek kiszámítjuk a 2 hatványát. Az `n` értékének 0 és 30 között kell lennie, beleértve a szélső értékeket is.\n\n- Visszatér: A 2 `n` hatványra emelésének eredménye.\n\n### Példa:\n- `powerOfTwo(3)` visszaadja `8`, mivel 2^3 = 8.\n- `powerOfTwo(5)` visszaadja `32`, mivel 2^5 = 32.\n- `powerOfTwo(10)` visszaadja `1024`, mivel 2^10 = 1024.\n\nMegjegyzés: A függvény úgy van kialakítva, hogy a megadott tartományon belüli bemeneteket kezelje anélkül, hogy egész szám túlcsordulást eredményezne."
    },
    "docstring_bertscore": {
      "sq": "0.9812659769823134",
      "hy": "0.9735056866256614",
      "bn": "0.9714466840958538",
      "bg": "0.9820563272684513",
      "zh": "0.9489770195020442",
      "fr": "0.9823201084144656",
      "de": "0.9775692669608732",
      "ha": "0.9927390664212696",
      "hi": "0.9660461226658962",
      "hu": "0.9616283843612993"
    }
  },
  {
    "task_id": "Swift/49",
    "prompt": {
      "en": "func determineSign(_ n: Int) -> String {\n    /**\n    Determines if a given integer is positive, zero, or negative.\n\n    - Parameters:\n        - n: An integer value that can range from -10^9 to 10^9.\n\n    - Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n    ### Example:\n    - `determineSign(3)` returns `\"positive\"`.\n    - `determineSign(0)` returns `\"zero\"`.\n    - `determineSign(-5)` returns `\"negative\"`.\n\n    Note: This function accurately classifies any integer within the specified range into one of the three categories.\n    */",
      "sq": "func determineSign(_ n: Int) -> String {\n    /**\n    Përcakton nëse një numër i dhënë është pozitiv, zero, apo negativ.\n\n    - Parametrat:\n        - n: Një vlerë e plotë që mund të variojë nga -10^9 deri në 10^9.\n\n    - Kthen: Një varg që tregon nëse numri i plotë është `positive`, `zero`, apo `negative`.\n\n    ### Shembull:\n    - `determineSign(3)` kthen `\"positive\"`.\n    - `determineSign(0)` kthen `\"zero\"`.\n    - `determineSign(-5)` kthen `\"negative\"`.\n\n    Shënim: Kjo funksion përcakton saktësisht çdo numër të plotë brenda intervalit të specifikuar në një nga tre kategoritë.\n    */",
      "hy": "func determineSign(_ n: Int) -> String {\n    /**\n    Սահմանում է, արդյոք տրված ամբողջ թիվը դրական է, զրո, թե բացասական:\n\n    - Պարամետրեր:\n        - n: Ամբողջ թիվ, որը կարող է լինել -10^9-ից մինչև 10^9:\n\n    - Վերադարձնում է: Տող, որը ցույց է տալիս, արդյոք ամբողջ թիվը `դրական`, `զրո`, թե `բացասական` է:\n\n    ### Օրինակ:\n    - `determineSign(3)` վերադարձնում է `\"positive\"`.\n    - `determineSign(0)` վերադարձնում է `\"zero\"`.\n    - `determineSign(-5)` վերադարձնում է `\"negative\"`.\n\n    Նշում: Այս ֆունկցիան ճշգրիտ դասակարգում է նշված տիրույթի ցանկացած ամբողջ թիվ երեք կատեգորիաներից մեկում:\n    */",
      "bn": "func determineSign(_ n: Int) -> String {\n    /**\n    একটি প্রদত্ত পূর্ণসংখ্যা ধনাত্মক, শূন্য, বা ঋণাত্মক কিনা তা নির্ধারণ করে।\n\n    - প্যারামিটার:\n        - n: একটি পূর্ণসংখ্যা যা -10^9 থেকে 10^9 পর্যন্ত হতে পারে।\n\n    - রিটার্নস: একটি স্ট্রিং যা নির্দেশ করে যে পূর্ণসংখ্যাটি `ধনাত্মক`, `শূন্য`, বা `ঋণাত্মক`।\n\n    ### উদাহরণ:\n    - `determineSign(3)` রিটার্ন করে `\"positive\"`।\n    - `determineSign(0)` রিটার্ন করে `\"zero\"`।\n    - `determineSign(-5)` রিটার্ন করে `\"negative\"`।\n\n    নোট: এই ফাংশনটি নির্দিষ্ট সীমার মধ্যে যে কোনো পূর্ণসংখ্যাকে সঠিকভাবে তিনটি শ্রেণির একটিতে শ্রেণীবদ্ধ করে।\n    */",
      "bg": "func determineSign(_ n: Int) -> String {\n    /**\n    Определя дали дадено цяло число е положително, нула или отрицателно.\n\n    - Параметри:\n        - n: Цяло число, което може да варира от -10^9 до 10^9.\n\n    - Връща: Низ, който указва дали цялото число е `положително`, `нула` или `отрицателно`.\n\n    ### Пример:\n    - `determineSign(3)` връща `\"positive\"`.\n    - `determineSign(0)` връща `\"zero\"`.\n    - `determineSign(-5)` връща `\"negative\"`.\n\n    Забележка: Тази функция точно класифицира всяко цяло число в посочения диапазон в една от трите категории.\n    */",
      "zh": "func determineSign(_ n: Int) -> String {\n    /**\n    确定给定整数是正数、零还是负数。\n\n    - 参数:\n        - n: 一个整数值，范围可以从 -10^9 到 10^9。\n\n    - 返回: 一个字符串，指示整数是 `positive`、`zero` 还是 `negative`。\n\n    ### 示例:\n    - `determineSign(3)` 返回 `\"positive\"`。\n    - `determineSign(0)` 返回 `\"zero\"`。\n    - `determineSign(-5)` 返回 `\"negative\"`。\n\n    注意: 此函数可以将指定范围内的任何整数准确分类为三类之一。\n    */",
      "fr": "func determineSign(_ n: Int) -> String {\n    /**\n    Détermine si un entier donné est positif, nul ou négatif.\n\n    - Paramètres:\n        - n: Une valeur entière qui peut varier de -10^9 à 10^9.\n\n    - Retourne: Une chaîne de caractères qui indique si l'entier est `positif`, `nul`, ou `négatif`.\n\n    ### Exemple:\n    - `determineSign(3)` retourne `\"positive\"`.\n    - `determineSign(0)` retourne `\"zero\"`.\n    - `determineSign(-5)` retourne `\"negative\"`.\n\n    Remarque: Cette fonction classe avec précision tout entier dans la plage spécifiée dans l'une des trois catégories.\n    */",
      "de": "func determineSign(_ n: Int) -> String {\n    /**\n    Bestimmt, ob eine gegebene ganze Zahl positiv, null oder negativ ist.\n\n    - Parameter:\n        - n: Ein ganzzahliger Wert, der von -10^9 bis 10^9 reichen kann.\n\n    - Rückgabe: Ein String, der angibt, ob die ganze Zahl `positiv`, `null` oder `negativ` ist.\n\n    ### Beispiel:\n    - `determineSign(3)` gibt `\"positive\"` zurück.\n    - `determineSign(0)` gibt `\"zero\"` zurück.\n    - `determineSign(-5)` gibt `\"negative\"` zurück.\n\n    Hinweis: Diese Funktion klassifiziert jede ganze Zahl innerhalb des angegebenen Bereichs genau in eine der drei Kategorien.\n    */",
      "ha": "func determineSign(_ n: Int) -> String {\n    /**\n    Yana tantancewa idan wani cikakken lamba yana da kyau, sifili, ko mara kyau.\n\n    - Sigogi:\n        - n: Wani cikakken lamba wanda zai iya zama daga -10^9 zuwa 10^9.\n\n    - Yana Mayarwa: Wani kirtani wanda yake nuna idan cikakken lambar yana da `kyau`, `sifili`, ko `mara kyau`.\n\n    ### Misali:\n    - `determineSign(3)` yana mayar da `\"positive\"`.\n    - `determineSign(0)` yana mayar da `\"zero\"`.\n    - `determineSign(-5)` yana mayar da `\"negative\"`.\n\n    Lura: Wannan aikin yana tantance kowane cikakken lamba a cikin kewayon da aka fayyace zuwa ɗaya daga cikin rukuni uku.\n    */",
      "hi": "func determineSign(_ n: Int) -> String {\n    /**\n    यह निर्धारित करता है कि दिया गया पूर्णांक सकारात्मक, शून्य, या नकारात्मक है।\n\n    - पैरामीटर्स:\n        - n: एक पूर्णांक मान जो -10^9 से 10^9 तक हो सकता है।\n\n    - रिटर्न्स: एक स्ट्रिंग जो यह इंगित करती है कि पूर्णांक `सकारात्मक`, `शून्य`, या `नकारात्मक` है।\n\n    ### उदाहरण:\n    - `determineSign(3)` `\"positive\"` लौटाता है।\n    - `determineSign(0)` `\"zero\"` लौटाता है।\n    - `determineSign(-5)` `\"negative\"` लौटाता है।\n\n    ध्यान दें: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक को तीन श्रेणियों में से एक में सही ढंग से वर्गीकृत करता है।\n    */",
      "hu": "func determineSign(_ n: Int) -> String {\n    /**\n    Meghatározza, hogy egy adott egész szám pozitív, nulla vagy negatív.\n\n    - Paraméterek:\n        - n: Egy egész szám, amely -10^9 és 10^9 között lehet.\n\n    - Visszatér: Egy string, amely jelzi, hogy az egész szám `pozitív`, `nulla` vagy `negatív`.\n\n    ### Példa:\n    - `determineSign(3)` visszatér `\"positive\"`.\n    - `determineSign(0)` visszatér `\"zero\"`.\n    - `determineSign(-5)` visszatér `\"negative\"`.\n\n    Megjegyzés: Ez a függvény pontosan osztályozza a megadott tartományon belüli bármely egész számot a három kategória egyikébe.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9903141867295957",
      "hy": "0.992467538690395",
      "bn": "0.9881060127836309",
      "bg": "0.992467538690395",
      "zh": "0.9857846195204761",
      "fr": "0.9985803886667437",
      "de": "0.9873881625865708",
      "ha": "0.9820807588053186",
      "hi": "0.9932604711714862",
      "hu": "0.9883922391627021"
    },
    "canonical_solution": "    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}",
    "instruction": {
      "en": "Write a Swift function `func determineSign(_ n: Int) -> String {` to solve the following problem:\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n",
      "sq": "Shkruani një funksion Swift `func determineSign(_ n: Int) -> String {` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse një numër i dhënë është pozitiv, zero, apo negativ.\n\n- Parametrat:\n- n: Një vlerë e plotë që mund të variojë nga -10^9 deri në 10^9.\n\n- Kthen: Një varg që tregon nëse numri i plotë është `positive`, `zero`, apo `negative`.\n\n### Shembull:\n- `determineSign(3)` kthen `\"positive\"`.\n- `determineSign(0)` kthen `\"zero\"`.\n- `determineSign(-5)` kthen `\"negative\"`.\n\nShënim: Ky funksion klasifikon saktësisht çdo numër të plotë brenda intervalit të specifikuar në një nga tre kategoritë.",
      "hy": "Swift ֆունկցիա գրեք `func determineSign(_ n: Int) -> String {` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք տրված ամբողջ թիվը դրական է, զրո, թե բացասական:\n\n- Պարամետրեր:\n- n: Ամբողջ թիվ, որը կարող է տատանվել -10^9-ից մինչև 10^9:\n\n- Վերադարձնում է: Տող, որը ցույց է տալիս, արդյոք ամբողջ թիվը `positive`, `zero`, թե `negative` է:\n\n### Օրինակ:\n- `determineSign(3)` վերադարձնում է `\"positive\"`.\n- `determineSign(0)` վերադարձնում է `\"zero\"`.\n- `determineSign(-5)` վերադարձնում է `\"negative\"`.\n\nՆշում: Այս ֆունկցիան ճշգրիտ դասակարգում է նշված տիրույթում գտնվող ցանկացած ամբողջ թիվ երեք կատեգորիաներից մեկի մեջ:",
      "bn": "একটি Swift ফাংশন `func determineSign(_ n: Int) -> String {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত পূর্ণসংখ্যা ধনাত্মক, শূন্য, বা ঋণাত্মক কিনা তা নির্ধারণ করে।\n\n- প্যারামিটারসমূহ:\n- n: একটি পূর্ণসংখ্যার মান যা -10^9 থেকে 10^9 এর মধ্যে হতে পারে।\n\n- রিটার্নস: একটি স্ট্রিং যা নির্দেশ করে যে পূর্ণসংখ্যাটি `ধনাত্মক`, `শূন্য`, বা `ঋণাত্মক` কিনা।\n\n### উদাহরণ:\n- `determineSign(3)` রিটার্ন করে `\"positive\"`।\n- `determineSign(0)` রিটার্ন করে `\"zero\"`।\n- `determineSign(-5)` রিটার্ন করে `\"negative\"`।\n\nনোট: এই ফাংশনটি নির্দিষ্ট সীমার মধ্যে যে কোনো পূর্ণসংখ্যাকে সঠিকভাবে তিনটি শ্রেণীর একটিতে শ্রেণীবদ্ধ করে।",
      "bg": "Напишете Swift функция `func determineSign(_ n: Int) -> String {`, за да решите следния проблем:\nОпределя дали дадено цяло число е положително, нула или отрицателно.\n\n- Параметри:\n- n: Цяло число, което може да варира от -10^9 до 10^9.\n\n- Връща: Низ, който указва дали цялото число е `positive`, `zero` или `negative`.\n\n### Пример:\n- `determineSign(3)` връща `\"positive\"`.\n- `determineSign(0)` връща `\"zero\"`.\n- `determineSign(-5)` връща `\"negative\"`.\n\nЗабележка: Тази функция точно класифицира всяко цяло число в посочения диапазон в една от трите категории.",
      "zh": "编写一个 Swift 函数 `func determineSign(_ n: Int) -> String {` 来解决以下问题：\n确定给定整数是正数、零还是负数。\n\n- 参数：\n- n: 一个整数值，范围可以从 -10^9 到 10^9。\n\n- 返回：一个字符串，指示整数是 `positive`、`zero` 还是 `negative`。\n\n### 示例：\n- `determineSign(3)` 返回 `\"positive\"`。\n- `determineSign(0)` 返回 `\"zero\"`。\n- `determineSign(-5)` 返回 `\"negative\"`。\n\n注意：此函数可以准确地将指定范围内的任何整数分类为三个类别之一。",
      "fr": "Écrire une fonction Swift `func determineSign(_ n: Int) -> String {` pour résoudre le problème suivant :  \nDétermine si un entier donné est positif, nul ou négatif.\n\n- Paramètres :\n- n : Une valeur entière pouvant aller de -10^9 à 10^9.\n\n- Renvoie : Une chaîne de caractères indiquant si l'entier est `positive`, `zero`, ou `negative`.\n\n### Exemple :\n- `determineSign(3)` renvoie `\"positive\"`.\n- `determineSign(0)` renvoie `\"zero\"`.\n- `determineSign(-5)` renvoie `\"negative\"`.\n\nRemarque : Cette fonction classe avec précision tout entier dans la plage spécifiée dans l'une des trois catégories.",
      "de": "Schreiben Sie eine Swift-Funktion `func determineSign(_ n: Int) -> String {`, um das folgende Problem zu lösen:\nBestimmt, ob eine gegebene Ganzzahl positiv, null oder negativ ist.\n\n- Parameter:\n- n: Ein Ganzzahlwert, der von -10^9 bis 10^9 reichen kann.\n\n- Rückgabewert: Ein String, der angibt, ob die Ganzzahl `positive`, `zero` oder `negative` ist.\n\n### Beispiel:\n- `determineSign(3)` gibt `\"positive\"` zurück.\n- `determineSign(0)` gibt `\"zero\"` zurück.\n- `determineSign(-5)` gibt `\"negative\"` zurück.\n\nHinweis: Diese Funktion klassifiziert jede Ganzzahl innerhalb des angegebenen Bereichs genau in eine der drei Kategorien.",
      "ha": "Rubuta aikin Swift `func determineSign(_ n: Int) -> String {` don warware matsalar mai zuwa:\nYana tantance ko wani cikakken lamba yana da kyau, sifili, ko mara kyau.\n\n- Sigogi:\n- n: Wani cikakken lamba wanda zai iya kasancewa daga -10^9 zuwa 10^9.\n\n- Komawa: Wani rubutu wanda yake nuna ko cikakken lambar `positive`, `zero`, ko `negative`.\n\n### Misali:\n- `determineSign(3)` yana dawowa `\"positive\"`.\n- `determineSign(0)` yana dawowa `\"zero\"`.\n- `determineSign(-5)` yana dawowa `\"negative\"`.\n\nLura: Wannan aikin yana daidai wajen rarraba kowace cikakken lamba cikin daya daga cikin rukuni uku da aka bayyana.",
      "hi": "Swift फ़ंक्शन `func determineSign(_ n: Int) -> String {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि दिया गया पूर्णांक धनात्मक, शून्य, या ऋणात्मक है।\n\n- पैरामीटर्स:\n- n: एक पूर्णांक मान जो -10^9 से 10^9 तक हो सकता है।\n\n- रिटर्न्स: एक स्ट्रिंग जो यह इंगित करती है कि पूर्णांक `positive`, `zero`, या `negative` है।\n\n### उदाहरण:\n- `determineSign(3)` `\"positive\"` लौटाता है।\n- `determineSign(0)` `\"zero\"` लौटाता है।\n- `determineSign(-5)` `\"negative\"` लौटाता है।\n\nनोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक को तीन श्रेणियों में से एक में सही ढंग से वर्गीकृत करता है।",
      "hu": "Írj egy Swift függvényt `func determineSign(_ n: Int) -> String {` a következő probléma megoldására:\nMegállapítja, hogy egy adott egész szám pozitív, nulla vagy negatív.\n\n- Paraméterek:\n- n: Egy egész szám, amely -10^9 és 10^9 között lehet.\n\n- Visszatér: Egy sztring, amely jelzi, hogy az egész szám `positive`, `zero` vagy `negative`.\n\n### Példa:\n- `determineSign(3)` visszaadja `\"positive\"`.\n- `determineSign(0)` visszaadja `\"zero\"`.\n- `determineSign(-5)` visszaadja `\"negative\"`.\n\nMegjegyzés: Ez a függvény pontosan osztályozza a megadott tartományon belüli bármely egész számot a három kategória egyikébe."
    },
    "instruction_bertscore": {
      "sq": "0.9919433531148439",
      "hy": "0.9796338311413498",
      "bn": "0.9884291844135746",
      "bg": "0.9916561335838675",
      "zh": "0.979708913425381",
      "fr": "0.9821478958741083",
      "de": "0.9845338440110994",
      "ha": "0.9710140671259598",
      "hi": "0.9726851445216064",
      "hu": "0.9853100915401838"
    },
    "level": "easy",
    "test": "func testDetermineSign() {\n    assert(determineSign(3) == \"positive\", \"3 should be positive.\")\n    assert(determineSign(0) == \"zero\", \"0 should be zero.\")\n    assert(determineSign(-5) == \"negative\", \"-5 should be negative.\")\n    assert(determineSign(1000000000) == \"positive\", \"1000000000 should be positive.\")\n    assert(determineSign(-1000000000) == \"negative\", \"-1000000000 should be negative.\")\n    assert(determineSign(1) == \"positive\", \"1 should be positive.\")\n}\n\n// Call the test function to verify the functionality\ntestDetermineSign()",
    "entry_point": "determineSign",
    "signature": "func determineSign(_ n: Int) -> String {",
    "docstring": {
      "en": "\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n",
      "sq": "Përcakton nëse një numër i dhënë është pozitiv, zero, apo negativ.\n\n- Parametrat:\n- n: Një vlerë e plotë që mund të variojë nga -10^9 deri në 10^9.\n\n- Kthen: Një varg që tregon nëse numri është `pozitiv`, `zero`, apo `negativ`.\n\n### Shembull:\n- `determineSign(3)` kthen `\"pozitiv\"`.\n- `determineSign(0)` kthen `\"zero\"`.\n- `determineSign(-5)` kthen `\"negativ\"`.\n\nShënim: Kjo funksion klasifikon saktë çdo numër të plotë brenda diapazonit të specifikuar në njërën nga tre kategoritë.",
      "hy": "Պարզում է, արդյոք տրված ամբողջ թիվը դրական է, զրո, թե բացասական։\n\n- Պարամետրեր:\n- n: Ամբողջ թվային արժեք, որը կարող է լինել -10^9-ից մինչև 10^9։\n\n- Վերադարձնում է: Տող, որը ցույց է տալիս, արդյոք ամբողջ թիվը `դրական`, `զրո`, թե `բացասական` է։\n\n### Օրինակ:\n- `determineSign(3)` վերադարձնում է `\"positive\"`։\n- `determineSign(0)` վերադարձնում է `\"zero\"`։\n- `determineSign(-5)` վերադարձնում է `\"negative\"`։\n\nՆշում: Այս ֆունկցիան ճշգրիտ դասակարգում է նշված տիրույթի ցանկացած ամբողջ թիվ երեք կատեգորիաներից մեկում։",
      "bn": "নির্ধারণ করে একটি প্রদত্ত পূর্ণসংখ্যা ধনাত্মক, শূন্য, বা ঋণাত্মক কিনা।\n\n- প্যারামিটারসমূহ:\n- n: একটি পূর্ণসংখ্যার মান যা -10^9 থেকে 10^9 এর মধ্যে হতে পারে।\n\n- রিটার্নস: একটি স্ট্রিং যা নির্দেশ করে যে পূর্ণসংখ্যাটি `ধনাত্মক`, `শূন্য`, বা `ঋণাত্মক` কিনা।\n\n### উদাহরণ:\n- `determineSign(3)` রিটার্ন করে `\"positive\"`।\n- `determineSign(0)` রিটার্ন করে `\"zero\"`।\n- `determineSign(-5)` রিটার্ন করে `\"negative\"`।\n\nনোট: এই ফাংশনটি নির্দিষ্ট পরিসরের মধ্যে যেকোনো পূর্ণসংখ্যাকে সঠিকভাবে তিনটি শ্রেণির একটিতে শ্রেণীবদ্ধ করে।",
      "bg": "Определя дали дадено цяло число е положително, нула или отрицателно.\n\n- Параметри:\n- n: Цяло число, което може да варира от -10^9 до 10^9.\n\n- Връща: Низ, който указва дали цялото число е `положително`, `нула` или `отрицателно`.\n\n### Пример:\n- `determineSign(3)` връща `\"positive\"`.\n- `determineSign(0)` връща `\"zero\"`.\n- `determineSign(-5)` връща `\"negative\"`.\n\nЗабележка: Тази функция точно класифицира всяко цяло число в рамките на посочения диапазон в една от трите категории.",
      "zh": "确定给定的整数是正数、零还是负数。\n\n- 参数:\n- n: 一个整数值，范围可以从 -10^9 到 10^9。\n\n- 返回: 一个字符串，指示整数是 `positive`、`zero` 还是 `negative`。\n\n### 示例:\n- `determineSign(3)` 返回 `\"positive\"`。\n- `determineSign(0)` 返回 `\"zero\"`。\n- `determineSign(-5)` 返回 `\"negative\"`。\n\n注意: 此函数可以准确地将指定范围内的任何整数分类为三个类别之一。",
      "fr": "Détermine si un entier donné est positif, nul ou négatif.\n\n- Paramètres:\n- n: Une valeur entière qui peut varier de -10^9 à 10^9.\n\n- Renvoie: Une chaîne de caractères qui indique si l'entier est `positif`, `nul` ou `négatif`.\n\n### Exemple:\n- `determineSign(3)` renvoie `\"positive\"`.\n- `determineSign(0)` renvoie `\"zero\"`.\n- `determineSign(-5)` renvoie `\"negative\"`.\n\nRemarque: Cette fonction classe avec précision tout entier dans la plage spécifiée dans l'une des trois catégories.",
      "de": "Bestimmt, ob eine gegebene ganze Zahl positiv, null oder negativ ist.\n\n- Parameter:\n- n: Ein ganzzahliger Wert, der von -10^9 bis 10^9 reichen kann.\n\n- Rückgabewert: Ein String, der angibt, ob die ganze Zahl `positiv`, `null` oder `negativ` ist.\n\n### Beispiel:\n- `determineSign(3)` gibt `\"positive\"` zurück.\n- `determineSign(0)` gibt `\"zero\"` zurück.\n- `determineSign(-5)` gibt `\"negative\"` zurück.\n\nHinweis: Diese Funktion klassifiziert jede ganze Zahl innerhalb des angegebenen Bereichs genau in eine der drei Kategorien.",
      "ha": "Yana tantancewa idan wani lamba cikakke yana da kyau, sifili, ko mara kyau.\n\n- Sigogi:\n- n: Wani ƙimar lamba cikakke wanda zai iya kasancewa daga -10^9 zuwa 10^9.\n\n- Komawa: Wani igiya wanda ke nuna ko lambar cikakke tana da `kyau`, `sifili`, ko `mara kyau`.\n\n### Misali:\n- `determineSign(3)` yana dawowa `\"positive\"`.\n- `determineSign(0)` yana dawowa `\"zero\"`.\n- `determineSign(-5)` yana dawowa `\"negative\"`.\n\nLura: Wannan aikin yana daidai rarraba duk wani lamba cikakke a cikin kewayon da aka ayyana zuwa ɗaya daga cikin rukuni uku.",
      "hi": "निर्धारित करता है कि दिया गया पूर्णांक सकारात्मक, शून्य, या नकारात्मक है।\n\n- पैरामीटर्स:\n- n: एक पूर्णांक मान जो -10^9 से 10^9 तक हो सकता है।\n\n- रिटर्न्स: एक स्ट्रिंग जो यह संकेत करती है कि पूर्णांक `positive`, `zero`, या `negative` है।\n\n### उदाहरण:\n- `determineSign(3)` `\"positive\"` लौटाता है।\n- `determineSign(0)` `\"zero\"` लौटाता है।\n- `determineSign(-5)` `\"negative\"` लौटाता है।\n\nनोट: यह फ़ंक्शन निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक को तीन श्रेणियों में से एक में सही ढंग से वर्गीकृत करता है।",
      "hu": "Meghatározza, hogy egy adott egész szám pozitív, nulla vagy negatív.\n\n- Paraméterek:\n- n: Egy egész szám, amely -10^9 és 10^9 között lehet.\n\n- Visszatér: Egy sztring, amely jelzi, hogy az egész szám `positive`, `zero`, vagy `negative`.\n\n### Példa:\n- `determineSign(3)` visszatér `\"positive\"`.\n- `determineSign(0)` visszatér `\"zero\"`.\n- `determineSign(-5)` visszatér `\"negative\"`.\n\nMegjegyzés: Ez a függvény pontosan osztályozza a megadott tartományon belüli bármely egész számot a három kategória egyikébe."
    },
    "docstring_bertscore": {
      "sq": "0.9890256714478224",
      "hy": "0.9931381148567687",
      "bn": "0.978832754814636",
      "bg": "0.9914547223774981",
      "zh": "0.9739347282486968",
      "fr": "0.9912171604417803",
      "de": "0.9866415109842607",
      "ha": "0.97582012782548",
      "hi": "0.9885582941612473",
      "hu": "0.9816924364103954"
    }
  },
  {
    "task_id": "Swift/50",
    "prompt": {
      "en": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calculates and returns the absolute value of a given integer.\n\n    - Parameters:\n        - n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n    - Returns: The absolute value of `n`.\n\n    ### Example:\n    - `absoluteValue(-3)` returns `3`.\n    - `absoluteValue(5)` returns `5`.\n    - `absoluteValue(0)` returns `0`.\n    - `absoluteValue(-10000)` returns `10000`.\n\n    Note: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n    */",
      "sq": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Llogarit dhe kthen vlerën absolute të një numri të dhënë të plotë.\n\n    - Parametrat:\n        - n: Një numër i plotë për të cilin do të llogaritet vlera absolute. Vlera e `n` nuk duhet të kalojë vlerën absolute të 10000.\n\n    - Kthen: Vlera absolute e `n`.\n\n    ### Shembull:\n    - `absoluteValue(-3)` kthen `3`.\n    - `absoluteValue(5)` kthen `5`.\n    - `absoluteValue(0)` kthen `0`.\n    - `absoluteValue(-10000)` kthen `10000`.\n\n    Shënim: Kjo funksion siguron që vlera absolute të llogaritet saktë për çdo numër të plotë brenda kufirit të specifikuar.\n    */",
      "hy": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Հաշվում և վերադարձնում է տրված ամբողջ թվի բացարձակ արժեքը։\n\n    - Պարամետրեր:\n        - n: Ամբողջ թիվ, որի բացարձակ արժեքը պետք է հաշվարկվի։ `n`-ի արժեքը չպետք է գերազանցի 10000-ի բացարձակ արժեքը։\n\n    - Վերադարձնում է: `n`-ի բացարձակ արժեքը։\n\n    ### Օրինակ:\n    - `absoluteValue(-3)` վերադարձնում է `3`:\n    - `absoluteValue(5)` վերադարձնում է `5`:\n    - `absoluteValue(0)` վերադարձնում է `0`:\n    - `absoluteValue(-10000)` վերադարձնում է `10000`:\n\n    Նշում: Այս ֆունկցիան ապահովում է, որ բացարձակ արժեքը ճիշտ հաշվարկվի ցանկացած ամբողջ թվի համար նշված սահմաններում։\n    */",
      "bn": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    প্রদত্ত একটি পূর্ণসংখ্যার পরম মান গণনা করে এবং ফেরত দেয়।\n\n    - প্যারামিটার:\n        - n: একটি পূর্ণসংখ্যা যার পরম মান গণনা করা হবে। `n` এর মান অবশ্যই 10000 এর পরম মান অতিক্রম করা উচিত নয়।\n\n    - রিটার্নস: `n` এর পরম মান।\n\n    ### উদাহরণ:\n    - `absoluteValue(-3)` `3` ফেরত দেয়।\n    - `absoluteValue(5)` `5` ফেরত দেয়।\n    - `absoluteValue(0)` `0` ফেরত দেয়।\n    - `absoluteValue(-10000)` `10000` ফেরত দেয়।\n\n    নোট: এই ফাংশন নিশ্চিত করে যে নির্দিষ্ট সীমার মধ্যে যেকোনো পূর্ণসংখ্যার জন্য পরম মান সঠিকভাবে গণনা করা হয়।\n    */",
      "bg": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Изчислява и връща абсолютната стойност на дадено цяло число.\n\n    - Параметри:\n        - n: Цяло число, чиято абсолютна стойност трябва да бъде изчислена. Стойността на `n` не трябва да надвишава абсолютната стойност на 10000.\n\n    - Връща: Абсолютната стойност на `n`.\n\n    ### Пример:\n    - `absoluteValue(-3)` връща `3`.\n    - `absoluteValue(5)` връща `5`.\n    - `absoluteValue(0)` връща `0`.\n    - `absoluteValue(-10000)` връща `10000`.\n\n    Забележка: Тази функция гарантира, че абсолютната стойност е правилно изчислена за всяко цяло число в рамките на посочения лимит.\n    */",
      "zh": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    计算并返回给定整数的绝对值。\n\n    - 参数:\n        - n: 要计算其绝对值的整数。`n` 的值不能超过绝对值 10000。\n\n    - 返回: `n` 的绝对值。\n\n    ### 示例:\n    - `absoluteValue(-3)` 返回 `3`。\n    - `absoluteValue(5)` 返回 `5`。\n    - `absoluteValue(0)` 返回 `0`。\n    - `absoluteValue(-10000)` 返回 `10000`。\n\n    注意: 此函数确保在指定限制内的任何整数的绝对值都能被正确计算。\n    */",
      "fr": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calcule et renvoie la valeur absolue d'un entier donné.\n\n    - Paramètres:\n        - n: Un entier dont la valeur absolue doit être calculée. La valeur de `n` ne doit pas dépasser la valeur absolue de 10000.\n\n    - Renvoie: La valeur absolue de `n`.\n\n    ### Exemple:\n    - `absoluteValue(-3)` returns `3`.\n    - `absoluteValue(5)` returns `5`.\n    - `absoluteValue(0)` returns `0`.\n    - `absoluteValue(-10000)` returns `10000`.\n\n    Remarque: Cette fonction garantit que la valeur absolue est correctement calculée pour tout entier dans la limite spécifiée.\n    */",
      "de": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Berechnet und gibt den absoluten Wert einer gegebenen ganzen Zahl zurück.\n\n    - Parameter:\n        - n: Eine ganze Zahl, deren absoluter Wert berechnet werden soll. Der Wert von `n` darf den absoluten Wert von 10000 nicht überschreiten.\n\n    - Rückgabe: Der absolute Wert von `n`.\n\n    ### Beispiel:\n    - `absoluteValue(-3)` gibt `3` zurück.\n    - `absoluteValue(5)` gibt `5` zurück.\n    - `absoluteValue(0)` gibt `0` zurück.\n    - `absoluteValue(-10000)` gibt `10000` zurück.\n\n    Hinweis: Diese Funktion stellt sicher, dass der absolute Wert für jede ganze Zahl innerhalb des angegebenen Limits korrekt berechnet wird.\n    */",
      "ha": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Lissafi da dawowa da darajar cikakken adadi mara alamar kowane adadi aka bayar.\n\n    - Sigogi:\n        - n: Cikakken adadi wanda za a lissafa darajar sa mara alamar. Darajar `n` bai kamata ta wuce darajar cikakken adadi mara alamar 10000 ba.\n\n    - Dawowa: Darajar cikakken adadi mara alamar `n`.\n\n    ### Misali:\n    - `absoluteValue(-3)` yana dawowa `3`.\n    - `absoluteValue(5)` yana dawowa `5`.\n    - `absoluteValue(0)` yana dawowa `0`.\n    - `absoluteValue(-10000)` yana dawowa `10000`.\n\n    Lura: Wannan aikin yana tabbatar da cewa darajar mara alamar tana daidai lissafi ga kowane cikakken adadi a cikin iyakar da aka kayyade.\n    */",
      "hi": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    दिए गए पूर्णांक का परिमाण मान गणना करता है और लौटाता है।\n\n    - पैरामीटर्स:\n        - n: एक पूर्णांक जिसका परिमाण मान गणना किया जाना है। `n` का मान 10000 के परिमाण मान से अधिक नहीं होना चाहिए।\n\n    - रिटर्न्स: `n` का परिमाण मान।\n\n    ### उदाहरण:\n    - `absoluteValue(-3)` `3` लौटाता है।\n    - `absoluteValue(5)` `5` लौटाता है।\n    - `absoluteValue(0)` `0` लौटाता है।\n    - `absoluteValue(-10000)` `10000` लौटाता है।\n\n    नोट: यह फ़ंक्शन सुनिश्चित करता है कि निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक के लिए परिमाण मान सही ढंग से गणना किया गया है।\n    */",
      "hu": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Kiszámítja és visszaadja egy adott egész szám abszolút értékét.\n\n    - Paraméterek:\n        - n: Egy egész szám, amelynek az abszolút értékét kell kiszámítani. Az `n` értéke nem haladhatja meg az 10000 abszolút értékét.\n\n    - Visszatér: Az `n` abszolút értéke.\n\n    ### Példa:\n    - `absoluteValue(-3)` visszaadja `3`.\n    - `absoluteValue(5)` visszaadja `5`.\n    - `absoluteValue(0)` visszaadja `0`.\n    - `absoluteValue(-10000)` visszaadja `10000`.\n\n    Megjegyzés: Ez a függvény biztosítja, hogy az abszolút érték helyesen legyen kiszámítva bármely egész számra a megadott határon belül.\n    */"
    },
    "prompt_bertscore": {
      "sq": "0.9899548643703037",
      "hy": "0.9898762067394138",
      "bn": "0.9866993124251419",
      "bg": "0.9953445011293043",
      "zh": "0.9690941058628766",
      "fr": "1",
      "de": "0.9879488961522322",
      "ha": "0.9831321094121362",
      "hi": "0.9882406841819725",
      "hu": "0.9953445011293043"
    },
    "canonical_solution": "    return abs(n)\n}",
    "instruction": {
      "en": "Write a Swift function `func absoluteValue(_ n: Int) -> Int {` to solve the following problem:\nCalculates and returns the absolute value of a given integer.\n\n- Parameters:\n- n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n- Returns: The absolute value of `n`.\n\n### Example:\n- `absoluteValue(-3)` returns `3`.\n- `absoluteValue(5)` returns `5`.\n- `absoluteValue(0)` returns `0`.\n- `absoluteValue(-10000)` returns `10000`.\n\nNote: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n",
      "sq": "Shkruani një funksion Swift `func absoluteValue(_ n: Int) -> Int {` për të zgjidhur problemin në vijim:\nLlogarit dhe kthen vlerën absolute të një numri të plotë të dhënë.\n\n- Parametrat:\n- n: Një numër i plotë për të cilin do të llogaritet vlera absolute. Vlera e `n` nuk duhet të kalojë vlerën absolute të 10000.\n\n- Kthen: Vlera absolute e `n`.\n\n### Shembull:\n- `absoluteValue(-3)` kthen `3`.\n- `absoluteValue(5)` kthen `5`.\n- `absoluteValue(0)` kthen `0`.\n- `absoluteValue(-10000)` kthen `10000`.\n\nShënim: Ky funksion siguron që vlera absolute të llogaritet saktë për çdo numër të plotë brenda kufirit të specifikuar.",
      "hy": "Գրեք Swift ֆունկցիա `func absoluteValue(_ n: Int) -> Int {` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում և վերադարձնում է տրված ամբողջ թվի բացարձակ արժեքը։\n\n- Պարամետրեր:\n- n: Ամբողջ թիվ, որի բացարձակ արժեքը պետք է հաշվարկվի։ `n`-ի արժեքը չպետք է գերազանցի 10000-ի բացարձակ արժեքը։\n\n- Վերադարձնում է: `n`-ի բացարձակ արժեքը։\n\n### Օրինակ:\n- `absoluteValue(-3)` վերադարձնում է `3`:\n- `absoluteValue(5)` վերադարձնում է `5`:\n- `absoluteValue(0)` վերադարձնում է `0`:\n- `absoluteValue(-10000)` վերադարձնում է `10000`:\n\nՆշում: Այս ֆունկցիան ապահովում է, որ բացարձակ արժեքը ճիշտ հաշվարկվի ցանկացած ամբողջ թվի համար նշված սահմաններում։",
      "bn": "একটি Swift ফাংশন `func absoluteValue(_ n: Int) -> Int {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত পূর্ণসংখ্যার পরম মান গণনা করে এবং ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- n: একটি পূর্ণসংখ্যা যার পরম মান গণনা করা হবে। `n` এর মান অবশ্যই 10000 এর পরম মান অতিক্রম করতে পারবে না।\n\n- ফেরত দেয়: `n` এর পরম মান।\n\n### উদাহরণ:\n- `absoluteValue(-3)` ফেরত দেয় `3`।\n- `absoluteValue(5)` ফেরত দেয় `5`।\n- `absoluteValue(0)` ফেরত দেয় `0`।\n- `absoluteValue(-10000)` ফেরত দেয় `10000`।\n\nদ্রষ্টব্য: এই ফাংশন নিশ্চিত করে যে নির্দিষ্ট সীমার মধ্যে যেকোনো পূর্ণসংখ্যার জন্য পরম মান সঠিকভাবে গণনা করা হয়।",
      "bg": "Напишете Swift функция `func absoluteValue(_ n: Int) -> Int {` за решаване на следния проблем:\nИзчислява и връща абсолютната стойност на дадено цяло число.\n\n- Параметри:\n- n: Цяло число, чиято абсолютна стойност трябва да бъде изчислена. Стойността на `n` не трябва да надвишава абсолютната стойност на 10000.\n\n- Връща: Абсолютната стойност на `n`.\n\n### Пример:\n- `absoluteValue(-3)` връща `3`.\n- `absoluteValue(5)` връща `5`.\n- `absoluteValue(0)` връща `0`.\n- `absoluteValue(-10000)` връща `10000`.\n\nЗабележка: Тази функция гарантира, че абсолютната стойност е правилно изчислена за всяко цяло число в рамките на посочения лимит.",
      "zh": "编写一个 Swift 函数 `func absoluteValue(_ n: Int) -> Int {` 来解决以下问题：\n计算并返回给定整数的绝对值。\n\n- 参数：\n- n: 一个整数，其绝对值需要计算。`n` 的值不得超过绝对值 10000。\n\n- 返回：`n` 的绝对值。\n\n### 示例：\n- `absoluteValue(-3)` 返回 `3`。\n- `absoluteValue(5)` 返回 `5`。\n- `absoluteValue(0)` 返回 `0`。\n- `absoluteValue(-10000)` 返回 `10000`。\n\n注意：此函数确保在指定限制内正确计算任何整数的绝对值。",
      "fr": "Écrivez une fonction Swift `func absoluteValue(_ n: Int) -> Int {` pour résoudre le problème suivant :\nCalcule et retourne la valeur absolue d'un entier donné.\n\n- Paramètres :\n- n : Un entier dont la valeur absolue doit être calculée. La valeur de `n` ne doit pas dépasser la valeur absolue de 10000.\n\n- Renvoie : La valeur absolue de `n`.\n\n### Exemple :\n- `absoluteValue(-3)` retourne `3`.\n- `absoluteValue(5)` retourne `5`.\n- `absoluteValue(0)` retourne `0`.\n- `absoluteValue(-10000)` retourne `10000`.\n\nRemarque : Cette fonction garantit que la valeur absolue est correctement calculée pour tout entier dans la limite spécifiée.",
      "de": "Schreiben Sie eine Swift-Funktion `func absoluteValue(_ n: Int) -> Int {`, um das folgende Problem zu lösen:\nBerechnet und gibt den absoluten Wert einer gegebenen ganzen Zahl zurück.\n\n- Parameter:\n- n: Eine ganze Zahl, deren absoluter Wert berechnet werden soll. Der Wert von `n` darf den absoluten Wert von 10000 nicht überschreiten.\n\n- Rückgabewert: Der absolute Wert von `n`.\n\n### Beispiel:\n- `absoluteValue(-3)` gibt `3` zurück.\n- `absoluteValue(5)` gibt `5` zurück.\n- `absoluteValue(0)` gibt `0` zurück.\n- `absoluteValue(-10000)` gibt `10000` zurück.\n\nHinweis: Diese Funktion stellt sicher, dass der absolute Wert für jede ganze Zahl innerhalb des angegebenen Limits korrekt berechnet wird.",
      "ha": "Rubuta aikin Swift `func absoluteValue(_ n: Int) -> Int {` don warware matsalar mai zuwa:\nLissafa kuma dawo da darajar cikakken adadi na wani adadi.\n\n- Sigogi:\n- n: Wani cikakken adadi wanda za a lissafa darajar cikakken adadinsa. Darajar `n` bai kamata ta wuce cikakken adadi na 10000 ba.\n\n- Komawa: Darajar cikakken adadi na `n`.\n\n### Misali:\n- `absoluteValue(-3)` yana dawowa `3`.\n- `absoluteValue(5)` yana dawowa `5`.\n- `absoluteValue(0)` yana dawowa `0`.\n- `absoluteValue(-10000)` yana dawowa `10000`.\n\nLura: Wannan aikin yana tabbatar da cewa an lissafa darajar cikakken adadi daidai ga duk wani cikakken adadi a cikin iyakar da aka kayyade.",
      "hi": "Swift फ़ंक्शन `func absoluteValue(_ n: Int) -> Int {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक का परिमाण (absolute value) गणना करता है और लौटाता है।\n\n- पैरामीटर्स:\n- n: एक पूर्णांक जिसका परिमाण गणना किया जाना है। `n` का मान 10000 के परिमाण से अधिक नहीं होना चाहिए।\n\n- रिटर्न्स: `n` का परिमाण।\n\n### उदाहरण:\n- `absoluteValue(-3)` `3` लौटाता है।\n- `absoluteValue(5)` `5` लौटाता है।\n- `absoluteValue(0)` `0` लौटाता है।\n- `absoluteValue(-10000)` `10000` लौटाता है।\n\nध्यान दें: यह फ़ंक्शन सुनिश्चित करता है कि निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक के लिए परिमाण सही ढंग से गणना किया गया है।",
      "hu": "Írj egy Swift függvényt `func absoluteValue(_ n: Int) -> Int {` a következő probléma megoldására:\nKiszámítja és visszaadja egy adott egész szám abszolút értékét.\n\n- Paraméterek:\n- n: Egy egész szám, amelynek az abszolút értékét kell kiszámítani. Az `n` értéke nem haladhatja meg a 10000 abszolút értékét.\n\n- Visszatérési érték: `n` abszolút értéke.\n\n### Példa:\n- `absoluteValue(-3)` visszaadja `3`.\n- `absoluteValue(5)` visszaadja `5`.\n- `absoluteValue(0)` visszaadja `0`.\n- `absoluteValue(-10000)` visszaadja `10000`.\n\nMegjegyzés: Ez a függvény biztosítja, hogy az abszolút érték helyesen legyen kiszámítva bármely egész számra a megadott határon belül."
    },
    "instruction_bertscore": {
      "sq": "0.9873430734900759",
      "hy": "0.971425430645083",
      "bn": "0.9934316905599383",
      "bg": "0.9958827894619089",
      "zh": "0.9793468102407544",
      "fr": "0.9927484020491782",
      "de": "0.9940057323611291",
      "ha": "0.9799838178727333",
      "hi": "0.9734959537369907",
      "hu": "0.982658177322987"
    },
    "level": "easy",
    "test": "func testAbsoluteValue() {\n    assert(absoluteValue(-3) == 3, \"-3's absolute value should be 3.\")\n    assert(absoluteValue(5) == 5, \"5's absolute value should be 5.\")\n    assert(absoluteValue(0) == 0, \"0's absolute value should be 0.\")\n    assert(absoluteValue(-10000) == 10000, \"-10000's absolute value should be 10000.\")\n    assert(absoluteValue(10000) == 10000, \"10000's absolute value should be 10000.\")\n    assert(absoluteValue(-1) == 1, \"-1's absolute value should be 1.\")\n}\n\n// Call the test function to verify the functionality\ntestAbsoluteValue()",
    "entry_point": "absoluteValue",
    "signature": "func absoluteValue(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates and returns the absolute value of a given integer.\n\n- Parameters:\n- n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n- Returns: The absolute value of `n`.\n\n### Example:\n- `absoluteValue(-3)` returns `3`.\n- `absoluteValue(5)` returns `5`.\n- `absoluteValue(0)` returns `0`.\n- `absoluteValue(-10000)` returns `10000`.\n\nNote: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n",
      "sq": "Llogarit dhe kthen vlerën absolute të një numri të plotë të dhënë.\n\n- Parametrat:\n- n: Një numër i plotë për të cilin do të llogaritet vlera absolute. Vlera e `n` nuk duhet të kalojë vlerën absolute të 10000.\n\n- Kthen: Vlera absolute e `n`.\n\n### Shembull:\n- `absoluteValue(-3)` kthen `3`.\n- `absoluteValue(5)` kthen `5`.\n- `absoluteValue(0)` kthen `0`.\n- `absoluteValue(-10000)` kthen `10000`.\n\nShënim: Kjo funksion siguron që vlera absolute të llogaritet saktë për çdo numër të plotë brenda kufirit të specifikuar.",
      "hy": "Հաշվարկում և վերադարձնում է տրված ամբողջ թվի բացարձակ արժեքը։\n\n- Պարամետրեր:\n- n: Ամբողջ թիվ, որի բացարձակ արժեքը պետք է հաշվարկել։ `n`-ի արժեքը չպետք է գերազանցի 10000-ի բացարձակ արժեքը։\n\n- Վերադարձնում է: `n`-ի բացարձակ արժեքը։\n\n### Օրինակ:\n- `absoluteValue(-3)` վերադարձնում է `3`։\n- `absoluteValue(5)` վերադարձնում է `5`։\n- `absoluteValue(0)` վերադարձնում է `0`։\n- `absoluteValue(-10000)` վերադարձնում է `10000`։\n\nՆշում: Այս ֆունկցիան ապահովում է, որ բացարձակ արժեքը ճիշտ հաշվարկվի ցանկացած ամբողջ թվի համար նշված սահմաններում։",
      "bn": "গণনা করে এবং প্রদত্ত পূর্ণসংখ্যার মানের পরম মান ফেরত দেয়।\n\n- প্যারামিটারসমূহ:\n- n: একটি পূর্ণসংখ্যা যার পরম মান গণনা করা হবে। `n` এর মান অবশ্যই 10000 এর পরম মান অতিক্রম করতে পারবে না।\n\n- রিটার্নস: `n` এর পরম মান।\n\n### উদাহরণ:\n- `absoluteValue(-3)` ফেরত দেয় `3`।\n- `absoluteValue(5)` ফেরত দেয় `5`।\n- `absoluteValue(0)` ফেরত দেয় `0`।\n- `absoluteValue(-10000)` ফেরত দেয় `10000`।\n\nনোট: এই ফাংশন নিশ্চিত করে যে নির্দিষ্ট সীমার মধ্যে যেকোনো পূর্ণসংখ্যার জন্য পরম মান সঠিকভাবে গণনা করা হয়।",
      "bg": "Изчислява и връща абсолютната стойност на дадено цяло число.\n\n- Параметри:\n- n: Цяло число, чиято абсолютна стойност трябва да бъде изчислена. Стойността на `n` не трябва да надвишава абсолютната стойност на 10000.\n\n- Връща: Абсолютната стойност на `n`.\n\n### Пример:\n- `absoluteValue(-3)` връща `3`.\n- `absoluteValue(5)` връща `5`.\n- `absoluteValue(0)` връща `0`.\n- `absoluteValue(-10000)` връща `10000`.\n\nЗабележка: Тази функция гарантира, че абсолютната стойност е правилно изчислена за всяко цяло число в рамките на посочения лимит.",
      "zh": "计算并返回给定整数的绝对值。\n\n- 参数：\n- n: 要计算其绝对值的整数。`n` 的值不得超过绝对值 10000。\n\n- 返回：`n` 的绝对值。\n\n### 示例：\n- `absoluteValue(-3)` 返回 `3`。\n- `absoluteValue(5)` 返回 `5`。\n- `absoluteValue(0)` 返回 `0`。\n- `absoluteValue(-10000)` 返回 `10000`。\n\n注意：此函数确保在指定限制内正确计算任何整数的绝对值。",
      "fr": "Calcule et retourne la valeur absolue d'un entier donné.\n\n- Paramètres:\n- n: Un entier dont la valeur absolue doit être calculée. La valeur de `n` ne doit pas dépasser la valeur absolue de 10000.\n\n- Retourne: La valeur absolue de `n`.\n\n### Exemple:\n- `absoluteValue(-3)` retourne `3`.\n- `absoluteValue(5)` retourne `5`.\n- `absoluteValue(0)` retourne `0`.\n- `absoluteValue(-10000)` retourne `10000`.\n\nRemarque: Cette fonction garantit que la valeur absolue est correctement calculée pour tout entier dans la limite spécifiée.",
      "de": "Berechnet und gibt den absoluten Wert einer gegebenen ganzen Zahl zurück.\n\n- Parameter:\n- n: Eine ganze Zahl, deren absoluter Wert berechnet werden soll. Der Wert von `n` darf den absoluten Wert von 10000 nicht überschreiten.\n\n- Rückgabewert: Der absolute Wert von `n`.\n\n### Beispiel:\n- `absoluteValue(-3)` gibt `3` zurück.\n- `absoluteValue(5)` gibt `5` zurück.\n- `absoluteValue(0)` gibt `0` zurück.\n- `absoluteValue(-10000)` gibt `10000` zurück.\n\nHinweis: Diese Funktion stellt sicher, dass der absolute Wert für jede ganze Zahl innerhalb des angegebenen Limits korrekt berechnet wird.",
      "ha": "Calculates and returns the absolute value of a given integer.\n\n- Sigogi:\n- n: Wani cikakken lamba wanda za a ƙididdige ƙimar cikakken lambar sa. Darajar `n` bai kamata ta wuce cikakken lamba na 10000 ba.\n\n- Komawa: Cikakken darajar `n`.\n\n### Misali:\n- `absoluteValue(-3)` yana dawowa `3`.\n- `absoluteValue(5)` yana dawowa `5`.\n- `absoluteValue(0)` yana dawowa `0`.\n- `absoluteValue(-10000)` yana dawowa `10000`.\n\nLura: Wannan aikin yana tabbatar da cewa an ƙididdige cikakken darajar daidai ga kowane cikakken lamba a cikin iyaka da aka fayyace.",
      "hi": "दिए गए पूर्णांक का परिमाण मान गणना करता है और लौटाता है।\n\n- पैरामीटर्स:\n- n: एक पूर्णांक जिसका परिमाण मान गणना किया जाना है। `n` का मान 10000 के परिमाण मान से अधिक नहीं होना चाहिए।\n\n- रिटर्न्स: `n` का परिमाण मान।\n\n### उदाहरण:\n- `absoluteValue(-3)` `3` लौटाता है।\n- `absoluteValue(5)` `5` लौटाता है।\n- `absoluteValue(0)` `0` लौटाता है।\n- `absoluteValue(-10000)` `10000` लौटाता है।\n\nनोट: यह फ़ंक्शन सुनिश्चित करता है कि निर्दिष्ट सीमा के भीतर किसी भी पूर्णांक के लिए परिमाण मान सही ढंग से गणना किया गया है।",
      "hu": "Kiszámítja és visszaadja egy adott egész szám abszolút értékét.\n\n- Paraméterek:\n- n: Egy egész szám, amelynek abszolút értékét ki kell számítani. Az `n` értéke nem haladhatja meg a 10000 abszolút értékét.\n\n- Visszatér: Az `n` abszolút értéke.\n\n### Példa:\n- `absoluteValue(-3)` visszaadja `3`.\n- `absoluteValue(5)` visszaadja `5`.\n- `absoluteValue(0)` visszaadja `0`.\n- `absoluteValue(-10000)` visszaadja `10000`.\n\nMegjegyzés: Ez a függvény biztosítja, hogy az abszolút érték helyesen legyen kiszámítva bármely egész számra a megadott határon belül."
    },
    "docstring_bertscore": {
      "sq": "0.9876807451378352",
      "hy": "0.9890081919742914",
      "bn": "0.9905016938092926",
      "bg": "0.9952733914528938",
      "zh": "0.9764231696623019",
      "fr": "0.9949394937823741",
      "de": "0.9955147273658512",
      "ha": "0.9839786720961069",
      "hi": "0.9944943630984749",
      "hu": "0.9952733914528938"
    }
  }
]