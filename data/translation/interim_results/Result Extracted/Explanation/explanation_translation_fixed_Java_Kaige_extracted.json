[
  {
    "task_id": "Java/1",
    "prompt": {
      "en": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calculate the average account balance based on the closing balances from the past twelve months.\n         *\n         * @param closingBalances A list of closing balances from the past twelve months.\n         * @return The average account balance.\n         *\n         * Example:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "sq": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Llogarit mesataren e bilancit të llogarisë bazuar në bilancet përfundimtare nga dymbëdhjetë muajt e kaluar.\n         *\n         * @param closingBalances Një listë e bilanceve përfundimtare nga dymbëdhjetë muajt e kaluar.\n         * @return Mesatarja e bilancit të llogarisë.\n         *\n         * Shembull:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "hy": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Հաշվել միջին հաշվեկշիռը վերջին տասներկու ամիսների փակման մնացորդների հիման վրա։\n         *\n         * @param closingBalances Վերջին տասներկու ամիսների փակման մնացորդների ցուցակ։\n         * @return Միջին հաշվեկշիռը։\n         *\n         * Օրինակ:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Արդյունք: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "bn": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * গত বারো মাসের সমাপনী ব্যালেন্সের উপর ভিত্তি করে গড় অ্যাকাউন্ট ব্যালেন্স হিসাব করুন।\n         *\n         * @param closingBalances গত বারো মাসের সমাপনী ব্যালেন্সের একটি তালিকা।\n         * @return গড় অ্যাকাউন্ট ব্যালেন্স।\n         *\n         * উদাহরণ:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * আউটপুট: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "bg": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Изчисляване на средния баланс на сметката въз основа на крайните баланси от последните дванадесет месеца.\n         *\n         * @param closingBalances Списък с крайните баланси от последните дванадесет месеца.\n         * @return Средният баланс на сметката.\n         *\n         * Пример:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "zh": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * 根据过去十二个月的期末余额计算平均账户余额。\n         *\n         * @param closingBalances 过去十二个月的期末余额列表。\n         * @return 平均账户余额。\n         *\n         * 例子:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * 输出: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "fr": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Calculer le solde moyen du compte basé sur les soldes de clôture des douze derniers mois.\n         *\n         * @param closingBalances Une liste des soldes de clôture des douze derniers mois.\n         * @return Le solde moyen du compte.\n         *\n         * Exemple:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Sortie: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "de": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Berechne den durchschnittlichen Kontostand basierend auf den Schlussbilanzen der letzten zwölf Monate.\n         *\n         * @param closingBalances Eine Liste von Schlussbilanzen der letzten zwölf Monate.\n         * @return Der durchschnittliche Kontostand.\n         *\n         * Beispiel:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Ausgabe: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "ha": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Lissafa matsakaicin ma'aunin asusu bisa ga ma'aunin rufewa daga watanni goma sha biyu da suka gabata.\n         *\n         * @param closingBalances Jerin ma'aunin rufewa daga watanni goma sha biyu da suka gabata.\n         * @return Matsakaicin ma'aunin asusu.\n         *\n         * Misali:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Output: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "hi": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * पिछले बारह महीनों के समापन शेष के आधार पर औसत खाता शेष की गणना करें।\n         *\n         * @param closingBalances पिछले बारह महीनों के समापन शेष की सूची।\n         * @return औसत खाता शेष।\n         *\n         * उदाहरण:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * आउटपुट: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)",
      "hu": "import java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n     /**\n         * Számítsa ki az átlagos számlaegyenleget az elmúlt tizenkét hónap záró egyenlegei alapján.\n         *\n         * @param closingBalances Az elmúlt tizenkét hónap záró egyenlegeinek listája.\n         * @return Az átlagos számlaegyenleg.\n         *\n         * Példa:\n         * calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n         * Kimenet: 1581.42\n         */\n    public static double calculateAverageBalance(List<Double> closingBalances)"
    },
    "prompt_bertscore": {
      "sq": "0.9991274167361137",
      "hy": "0.9707610120205213",
      "bn": "0.9962137076767129",
      "bg": "0.9889476097080757",
      "zh": "0.9748518047179349",
      "fr": "0.9914749826763636",
      "de": "0.9964468997440479",
      "ha": "0.9861147432137561",
      "hi": "0.9804740376531274",
      "hu": "0.9883028554912364"
    },
    "canonical_solution": "    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }",
    "instruction": {
      "en": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static double calculateAverageBalance(List<Double> closingBalances)\n    {\n        double sum = 0.0;\n        for (double balance : closingBalances) {\n            sum += balance;\n        }\n        return sum / closingBalances.size();\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.8821843757929664",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9107035272715747",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75)) - 1581.42) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(100.0, 200.0, 300.0, 400.0, 500.0, 600.0, 700.0, 800.0, 900.0, 1000.0, 1100.0, 1200.0)) - 650.0) < 0.01;\n        assert Math.abs(calculateAverageBalance(Arrays.asList(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) - 6.5) < 0.01;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "calculateAverageBalance",
    "signature": "public static double calculateAverageBalance(List<Double> closingBalances)",
    "docstring": {
      "en": "Calculate the average account balance based on the closing balances from the past twelve months.\n\n@param closingBalances A list of closing balances from the past twelve months.\n@return The average account balance.\n\nExample:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "sq": "Llogaritni bilancin mesatar të llogarisë bazuar në bilancet përfundimtare nga dymbëdhjetë muajt e kaluar.\n\n@param closingBalances Një listë e bilanceve përfundimtare nga dymbëdhjetë muajt e kaluar.\n@return Bilanci mesatar i llogarisë.\n\nShembull:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "hy": "Հաշվարկել միջին հաշվի մնացորդը վերջին տասներկու ամիսների փակման մնացորդների հիման վրա։\n\n@param closingBalances Վերջին տասներկու ամիսների փակման մնացորդների ցուցակ։\n@return Միջին հաշվի մնացորդը։\n\nՕրինակ:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "bn": "গত বারো মাসের সমাপনী ব্যালেন্সের উপর ভিত্তি করে গড় অ্যাকাউন্ট ব্যালেন্স হিসাব করুন।\n\n@param closingBalances গত বারো মাসের সমাপনী ব্যালেন্সের একটি তালিকা।\n@return গড় অ্যাকাউন্ট ব্যালেন্স।\n\nউদাহরণ:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nআউটপুট: 1581.42",
      "bg": "Изчислява средния баланс на сметката въз основа на крайните салда от последните дванадесет месеца.\n\n@param closingBalances Списък с крайните салда от последните дванадесет месеца.\n@return Средният баланс на сметката.\n\nПример:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nИзход: 1581.42",
      "zh": "计算基于过去十二个月的期末余额的平均账户余额。\n\n@param closingBalances 过去十二个月的期末余额列表。\n@return 平均账户余额。\n\n示例：\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\n输出: 1581.42",
      "fr": "Calculer le solde moyen du compte basé sur les soldes de clôture des douze derniers mois.\n\n@param closingBalances Une liste de soldes de clôture des douze derniers mois.\n@return Le solde moyen du compte.\n\nExemple:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nSortie: 1581.42",
      "de": "Berechnen Sie den durchschnittlichen Kontostand basierend auf den Schlussbilanzen der letzten zwölf Monate.\n\n@param closingBalances Eine Liste von Schlussbilanzen der letzten zwölf Monate.\n@return Der durchschnittliche Kontostand.\n\nBeispiel:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nAusgabe: 1581.42",
      "ha": "Lissafa matsakaicin ma'auni na asusu bisa ga ma'aunin rufewa daga watanni goma sha biyu da suka gabata.\n\n@param closingBalances Jerin lambobi na rufe ma'auni daga watanni goma sha biyu da suka gabata.\n@return Matsakaicin ma'aunin asusu.\n\nMisali:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nOutput: 1581.42",
      "hi": "पिछले बारह महीनों के समापन संतुलनों के आधार पर औसत खाता शेष की गणना करें।\n\n@param closingBalances पिछले बारह महीनों के समापन संतुलनों की एक सूची।\n@return औसत खाता शेष।\n\nउदाहरण:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nआउटपुट: 1581.42",
      "hu": "Számítsa ki az átlagos számlaegyenleget az elmúlt tizenkét hónap záróegyenlegei alapján.\n\n@param closingBalances Az elmúlt tizenkét hónap záróegyenlegeinek listája.\n@return Az átlagos számlaegyenleg.\n\nPélda:\ncalculateAverageBalance(Arrays.asList(100.0, 489.12, 12454.12, 1234.10, 823.05, 109.20, 5.27, 1542.25, 839.18, 83.99, 1295.01, 1.75))\nKimenet: 1581.42"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9727008363217081",
      "bn": "0.98712120335446",
      "bg": "0.9853416737707683",
      "zh": "0.9715869171448644",
      "fr": "0.9942635545957125",
      "de": "0.993845239013253",
      "ha": "0.9776348149866146",
      "hi": "0.9825648210439006",
      "hu": "0.9846083304039875"
    }
  },
  {
    "task_id": "Java/2",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a positive integer Y indicating the start year, and a positive integer N,\n     * this function finds the Nth leap year after the start year Y.\n     *\n     * @param Y The start year.\n     * @param N The position of the leap year to find.\n     * @return The Nth leap year after the start year Y.\n     *\n     * Example:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një numër të plotë pozitiv Y që tregon vitin e fillimit, dhe një numër të plotë pozitiv N,\n     * kjo funksion gjen vitin e N-të i brishtë pas vitit të fillimit Y.\n     *\n     * @param Y Viti i fillimit.\n     * @param N Pozicioni i vitit të brishtë për të gjetur.\n     * @return Viti i N-të i brishtë pas vitit të fillimit Y.\n     *\n     * Shembull:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "hy": "class Solution {\n    /**\n     * Տրված է դրական ամբողջ թիվ Y, որը ցույց է տալիս մեկնարկային տարին, և դրական ամբողջ թիվ N,\n     * այս ֆունկցիան գտնում է N-րդ նահանջ տարին մեկնարկային տարուց Y հետո:\n     *\n     * @param Y Մեկնարկային տարին:\n     * @param N Գտնվող նահանջ տարվա դիրքը:\n     * @return N-րդ նահանջ տարին մեկնարկային տարուց Y հետո:\n     *\n     * Օրինակ:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "bn": "class Solution {\n    /**\n     * একটি ধনাত্মক পূর্ণসংখ্যা Y যা শুরু বছরের নির্দেশ করে, এবং একটি ধনাত্মক পূর্ণসংখ্যা N,\n     * এই ফাংশনটি শুরু বছর Y এর পরে N তম লিপ বছর খুঁজে বের করে।\n     *\n     * @param Y শুরু বছর।\n     * @param N খুঁজে বের করার জন্য লিপ বছরের অবস্থান।\n     * @return শুরু বছর Y এর পরে N তম লিপ বছর।\n     *\n     * উদাহরণ:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "bg": "class Solution {\n    /**\n     * Като се даде положително цяло число Y, указващо началната година, и положително цяло число N,\n     * тази функция намира N-тата високосна година след началната година Y.\n     *\n     * @param Y Началната година.\n     * @param N Позицията на високосната година, която да се намери.\n     * @return N-тата високосна година след началната година Y.\n     *\n     * Пример:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "zh": "class Solution {\n    /**\n     * 给定一个表示起始年份的正整数Y，以及一个正整数N，\n     * 此函数查找起始年份Y之后的第N个闰年。\n     *\n     * @param Y 起始年份。\n     * @param N 要查找的闰年的位置。\n     * @return 起始年份Y之后的第N个闰年。\n     *\n     * 示例:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "fr": "class Solution {\n    /**\n     * Étant donné un entier positif Y indiquant l'année de départ, et un entier positif N,\n     * cette fonction trouve la N-ième année bissextile après l'année de départ Y.\n     *\n     * @param Y L'année de départ.\n     * @param N La position de l'année bissextile à trouver.\n     * @return La N-ième année bissextile après l'année de départ Y.\n     *\n     * Exemple :\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "de": "class Solution {\n    /**\n     * Gegeben ist eine positive ganze Zahl Y, die das Startjahr angibt, und eine positive ganze Zahl N,\n     * diese Funktion findet das N-te Schaltjahr nach dem Startjahr Y.\n     *\n     * @param Y Das Startjahr.\n     * @param N Die Position des zu findenden Schaltjahres.\n     * @return Das N-te Schaltjahr nach dem Startjahr Y.\n     *\n     * Beispiel:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "ha": "class Solution {\n    /**\n     * An ba da wani lamba mai kyau Y wanda ke nuna shekarar farawa, da kuma wani lamba mai kyau N,\n     * wannan aikin yana nemo shekarar tsalle-tsalle ta N bayan shekarar farawa Y.\n     *\n     * @param Y Shekarar farawa.\n     * @param N Matsayin shekarar tsalle-tsalle da za a nema.\n     * @return Shekarar tsalle-tsalle ta N bayan shekarar farawa Y.\n     *\n     * Misali:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "hi": "class Solution {\n    /**\n     * दिए गए एक धनात्मक पूर्णांक Y जो प्रारंभ वर्ष को दर्शाता है, और एक धनात्मक पूर्णांक N,\n     * यह फ़ंक्शन प्रारंभ वर्ष Y के बाद Nवें लीप वर्ष को खोजता है।\n     *\n     * @param Y प्रारंभ वर्ष।\n     * @param N खोजने के लिए लीप वर्ष की स्थिति।\n     * @return प्रारंभ वर्ष Y के बाद Nवां लीप वर्ष।\n     *\n     * उदाहरण:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) ",
      "hu": "class Solution {\n    /**\n     * Adott egy pozitív egész szám Y, amely a kezdőévet jelöli, és egy pozitív egész szám N,\n     * ez a függvény megtalálja az N-edik szökőévet a kezdőév Y után.\n     *\n     * @param Y A kezdőév.\n     * @param N A megtalálandó szökőév pozíciója.\n     * @return Az N-edik szökőév a kezdőév Y után.\n     *\n     * Példa:\n     * findNthLeapYear(2000, 4) => 2008\n     * findNthLeapYear(1996, 10) => 2032\n     */\n    public static int findNthLeapYear(int Y, int N) "
    },
    "prompt_bertscore": {
      "sq": "0.9844307548433423",
      "hy": "0.974568160533817",
      "bn": "0.9635356332799963",
      "bg": "0.9844307548433423",
      "zh": "0.9853994752116495",
      "fr": "0.9844307548433423",
      "de": "0.9731950287097229",
      "ha": "0.9853994752116495",
      "hi": "0.9805298527901982",
      "hu": "0.9866788534958952"
    },
    "canonical_solution": "    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }",
    "instruction": {
      "en": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nՏվեք Java կոդի համառոտ բնութագրությունը (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\n请用最多500个字符的中文为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int findNthLeapYear(int Y, int N)\n    {\n    \n        int count = 0;\n        while (true) {\n            if ((Y % 4 == 0 && Y % 100 != 0) || (Y % 400 == 0)) {\n                count++;\n                if (count == N) {\n                    return Y;\n                }\n            }\n            Y++;\n        }\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386897534378662",
      "hy": "0.9070264816578568",
      "bn": "0.9097683754376624",
      "bg": "0.8400592418438494",
      "zh": "0.8770857325421819",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9107035272715747",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with the examples from the comment\n        assert findNthLeapYear(2000, 4) == 2012;\n        assert findNthLeapYear(1996, 10) == 2032;\n        assert findNthLeapYear(2000, 1) == 2000;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "findNthLeapYear",
    "signature": "public static int findNthLeapYear(int Y, int N)",
    "docstring": {
      "en": "Given a positive integer Y indicating the start year, and a positive integer N,\nthis function finds the Nth leap year after the start year Y.\n\n@param Y The start year.\n@param N The position of the leap year to find.\n@return The Nth leap year after the start year Y.\n\nExample:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "sq": "Duke pasur një numër të plotë pozitiv Y që tregon vitin e fillimit, dhe një numër të plotë pozitiv N, kjo funksion gjen vitin e N-të i brishtë pas vitit të fillimit Y.\n\n@param Y Viti i fillimit.\n@param N Pozicioni i vitit të brishtë për të gjetur.\n@return Viti i N-të i brishtë pas vitit të fillimit Y.\n\nShembull:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hy": "Տրված է դրական ամբողջ թիվ Y, որը ցույց է տալիս մեկնարկային տարին, և դրական ամբողջ թիվ N,  \nայս ֆունկցիան գտնում է N-րդ նահանջ տարին մեկնարկային տարուց Y հետո։\n\n@param Y Մեկնարկային տարին։\n@param N Նահանջ տարվա գտնվելու դիրքը։\n@return N-րդ նահանջ տարին մեկնարկային տարուց Y հետո։\n\nՕրինակ:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "bn": "প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যা Y যা শুরু বছরের নির্দেশ করে, এবং একটি ধনাত্মক পূর্ণসংখ্যা N, এই ফাংশনটি শুরু বছর Y এর পরবর্তী N তম অধিবর্ষ খুঁজে বের করে।\n\n@param Y শুরু বছর।\n@param N খুঁজে বের করার জন্য অধিবর্ষের অবস্থান।\n@return শুরু বছর Y এর পরবর্তী N তম অধিবর্ষ।\n\nউদাহরণ:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "bg": "Дадено е положително цяло число Y, указващо началната година, и положително цяло число N, тази функция намира N-тата високосна година след началната година Y.\n\n@param Y Началната година.\n@param N Позицията на високосната година, която да се намери.\n@return N-тата високосна година след началната година Y.\n\nПример:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "zh": "给定一个正整数 Y 表示起始年份，以及一个正整数 N，此函数查找起始年份 Y 之后的第 N 个闰年。\n\n@param Y 起始年份。\n@param N 要查找的闰年的位置。\n@return 起始年份 Y 之后的第 N 个闰年。\n\n示例：\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "fr": "Étant donné un entier positif Y indiquant l'année de départ, et un entier positif N, cette fonction trouve la Nième année bissextile après l'année de départ Y.\n\n@param Y L'année de départ.\n@param N La position de l'année bissextile à trouver.\n@return La Nième année bissextile après l'année de départ Y.\n\nExemple :\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "de": "Angenommen, eine positive Ganzzahl Y gibt das Startjahr an, und eine positive Ganzzahl N,\ndiese Funktion findet das N-te Schaltjahr nach dem Startjahr Y.\n\n@param Y Das Startjahr.\n@param N Die Position des zu findenden Schaltjahres.\n@return Das N-te Schaltjahr nach dem Startjahr Y.\n\nBeispiel:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "ha": "An ba da lamba mai kyau Y da ke nuna shekarar farawa, da kuma lamba mai kyau N, wannan aikin yana nemo shekarar tsalle-ta-tsalle ta N bayan shekarar farawa Y.\n\n@param Y Shekarar farawa.\n@param N Matsayin shekarar tsalle-ta-tsalle da za a nema.\n@return Shekarar tsalle-ta-tsalle ta N bayan shekarar farawa Y.\n\nMisali:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hi": "एक सकारात्मक पूर्णांक Y दिया गया है जो प्रारंभिक वर्ष को दर्शाता है, और एक सकारात्मक पूर्णांक N, यह फ़ंक्शन प्रारंभिक वर्ष Y के बाद Nवां लीप वर्ष खोजता है।\n\n@param Y प्रारंभिक वर्ष।\n@param N खोजने के लिए लीप वर्ष की स्थिति।\n@return प्रारंभिक वर्ष Y के बाद Nवां लीप वर्ष।\n\nउदाहरण:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032",
      "hu": "Adott egy pozitív egész szám Y, amely az induló évet jelzi, és egy pozitív egész szám N, ez a függvény megkeresi az N-edik szökőévet az induló év Y után.\n\n@param Y Az induló év.\n@param N A keresendő szökőév pozíciója.\n@return Az N-edik szökőév az induló év Y után.\n\nPélda:\nfindNthLeapYear(2000, 4) => 2008\nfindNthLeapYear(1996, 10) => 2032"
    },
    "docstring_bertscore": {
      "sq": "0.9818132036820646",
      "hy": "0.9674675216725819",
      "bn": "0.9625528101546357",
      "bg": "0.9747491128109398",
      "zh": "0.9796683928276498",
      "fr": "0.9945358768481113",
      "de": "0.9865394149684087",
      "ha": "0.9392580349580071",
      "hi": "0.9399530426612481",
      "hu": "0.9674675216725819"
    }
  },
  {
    "task_id": "Java/3",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Calculate the time needed to obtain the reverse seating order.\n     * For each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n     * \n     * @param N the number of people\n     * @return the time needed in minutes\n     * \n     * Example:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "sq": "class Solution {\n    /**\n     * Llogarit kohën e nevojshme për të marrë rendin e kundërt të uljes.\n     * Për secilin person, personi që fillimisht ishte në të majtë të tyre do të jetë në të djathtë, dhe personi që fillimisht ishte në të djathtë të tyre do të jetë në të majtë.\n     * \n     * @param N numri i njerëzve\n     * @return koha e nevojshme në minuta\n     * \n     * Shembull:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "hy": "class Solution {\n    /**\n     * Հաշվել ժամանակը, որը անհրաժեշտ է հակառակ նստեցման կարգը ստանալու համար։\n     * Յուրաքանչյուր անձի համար, այն անձը, ով սկզբում նրանց ձախում էր, կլինի նրանց աջում, իսկ այն անձը, ով սկզբում նրանց աջում էր, կլինի նրանց ձախում։\n     * \n     * @param N մարդկանց քանակը\n     * @return անհրաժեշտ ժամանակը րոպեներով\n     * \n     * Օրինակ:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "bn": "class Solution {\n    /**\n     * বিপরীত আসন বিন্যাস পেতে প্রয়োজনীয় সময় গণনা করুন।\n     * প্রতিটি ব্যক্তির জন্য, যে ব্যক্তি মূলত তাদের বাম পাশে ছিল সে তাদের ডান পাশে থাকবে, এবং যে ব্যক্তি মূলত তাদের ডান পাশে ছিল সে তাদের বাম পাশে থাকবে।\n     * \n     * @param N মানুষের সংখ্যা\n     * @return প্রয়োজনীয় সময় মিনিটে\n     * \n     * উদাহরণ:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "bg": "class Solution {\n    /**\n     * Изчислете времето, необходимо за получаване на обратния ред на сядане.\n     * За всеки човек, човекът, който първоначално е бил отляво, ще бъде отдясно, и човекът, който първоначално е бил отдясно, ще бъде отляво.\n     * \n     * @param N броят на хората\n     * @return времето, необходимо в минути\n     * \n     * Пример:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "zh": "class Solution {\n    /**\n     * 计算获得反向座位顺序所需的时间。\n     * 对于每个人，原本在他们左边的人将会在他们右边，原本在他们右边的人将会在他们左边。\n     * \n     * @param N 人数\n     * @return 所需时间（分钟）\n     * \n     * 示例:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "fr": "class Solution {\n    /**\n     * Calculer le temps nécessaire pour obtenir l'ordre de placement inverse.\n     * Pour chaque personne, la personne qui était à l'origine à sa gauche sera à sa droite, et la personne qui était à l'origine à sa droite sera à sa gauche.\n     * \n     * @param N le nombre de personnes\n     * @return le temps nécessaire en minutes\n     * \n     * Exemple:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "de": "class Solution {\n    /**\n     * Berechne die benötigte Zeit, um die umgekehrte Sitzordnung zu erhalten.\n     * Für jede Person wird die Person, die ursprünglich links von ihr war, rechts von ihr sein, und die Person, die ursprünglich rechts von ihr war, wird links von ihr sein.\n     * \n     * @param N die Anzahl der Personen\n     * @return die benötigte Zeit in Minuten\n     * \n     * Beispiel:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "ha": "class Solution {\n    /**\n     * Lissafa lokacin da ake buƙata don samun tsarin zama na baya.\n     * Ga kowane mutum, mutumin da ke a gefensu na hagu a baya zai kasance a gefensu na dama, kuma mutumin da ke a gefensu na dama a baya zai kasance a gefensu na hagu.\n     * \n     * @param N adadin mutanen\n     * @return lokacin da ake buƙata a cikin mintuna\n     * \n     * Misali:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "hi": "class Solution {\n    /**\n     * उल्टी बैठने की व्यवस्था प्राप्त करने के लिए आवश्यक समय की गणना करें।\n     * प्रत्येक व्यक्ति के लिए, जो व्यक्ति मूल रूप से उनके बाएँ था, वह उनके दाएँ होगा, और जो व्यक्ति मूल रूप से उनके दाएँ था, वह उनके बाएँ होगा।\n     * \n     * @param N लोगों की संख्या\n     * @return आवश्यक समय मिनटों में\n     * \n     * उदाहरण:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) ",
      "hu": "class Solution {\n    /**\n     * Számítsa ki a fordított ülésrend eléréséhez szükséges időt.\n     * Minden személy esetében az a személy, aki eredetileg a balján volt, a jobbján lesz, és az a személy, aki eredetileg a jobbján volt, a balján lesz.\n     * \n     * @param N a személyek száma\n     * @return a szükséges idő percekben\n     * \n     * Példa:\n     * >>> calculateTimeNeeded(4)\n     * 2\n     * >>> calculateTimeNeeded(5)\n     * 4\n     * >>> calculateTimeNeeded(6)\n     * 6\n     */\n    public static int calculateTimeNeeded(int N) "
    },
    "prompt_bertscore": {
      "sq": "0.9756401687002624",
      "hy": "0.9849422280745072",
      "bn": "0.9789608714104036",
      "bg": "0.9860293321499112",
      "zh": "0.9530114011712437",
      "fr": "0.9927229773604058",
      "de": "0.9883701911904073",
      "ha": "0.9327083967737626",
      "hi": "0.971851890073165",
      "hu": "0.9894473637467595"
    },
    "canonical_solution": "    {\n        return N / 2;\n    }",
    "instruction": {
      "en": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nՏվեք Java կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\n请用不超过500个字符的中文为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nGeben Sie eine prägnante Beschreibung der Java-Code-Funktionalität in natürlicher Sprache auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Java a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int calculateTimeNeeded(int N)\n    {\n        return N / 2;\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9465259206000736",
      "bn": "0.8954556660714315",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.8573833864169503",
      "ha": "0.9168968225522425",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert calculateTimeNeeded(7) == 3;\n        assert calculateTimeNeeded(8) == 4;\n        assert calculateTimeNeeded(9) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "calculateTimeNeeded",
    "signature": "public static int calculateTimeNeeded(int N)",
    "docstring": {
      "en": "Calculate the time needed to obtain the reverse seating order.\nFor each person, the person who was originally on their left will be on their right, and the person who was originally on their right will be on their left.\n\n@param N the number of people\n@return the time needed in minutes\n\nExample:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "sq": "Llogaritni kohën e nevojshme për të marrë rendin e kundërt të uljes. Për secilin person, personi që ishte fillimisht në të majtë të tij do të jetë në të djathtë, dhe personi që ishte fillimisht në të djathtë të tij do të jetë në të majtë.\n\n@param N numri i personave\n@return koha e nevojshme në minuta\n\nShembull:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "hy": "Հաշվարկել ժամանակը, որը անհրաժեշտ է հակառակ նստատեղերի կարգը ստանալու համար։\nՅուրաքանչյուր անձի համար, այն անձը, ով սկզբնապես նրանց ձախ կողմում էր, կլինի նրանց աջ կողմում, և այն անձը, ով սկզբնապես նրանց աջ կողմում էր, կլինի նրանց ձախ կողմում։\n\n@param N մարդկանց քանակը  \n@return անհրաժեշտ ժամանակը րոպեներով  \n\nՕրինակ:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6",
      "bn": "বিপরীত আসন বিন্যাস পেতে প্রয়োজনীয় সময় গণনা করুন।\nপ্রত্যেক ব্যক্তির জন্য, যে ব্যক্তি মূলত তাদের বাম দিকে ছিল সে তাদের ডান দিকে থাকবে, এবং যে ব্যক্তি মূলত তাদের ডান দিকে ছিল সে তাদের বাম দিকে থাকবে।\n\n@param N মানুষের সংখ্যা\n@return প্রয়োজনীয় সময় মিনিটে\n\nউদাহরণ:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "bg": "Изчислете времето, необходимо за получаване на обратния ред на сядане. За всеки човек, човекът, който първоначално е бил отляво, ще бъде отдясно, и човекът, който първоначално е бил отдясно, ще бъде отляво.\n\n@param N броят на хората\n@return времето, необходимо в минути\n\nПример:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "zh": "计算获得反向座次顺序所需的时间。\n对于每个人，原本在他们左边的人将会在他们的右边，而原本在他们右边的人将会在他们的左边。\n\n@param N 人数  \n@return 所需时间（分钟）\n\n示例：  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6  ",
      "fr": "Calculez le temps nécessaire pour obtenir l'ordre de placement inversé.\nPour chaque personne, la personne qui était à l'origine à sa gauche sera à sa droite, et la personne qui était à l'origine à sa droite sera à sa gauche.\n\n@param N le nombre de personnes  \n@return le temps nécessaire en minutes\n\nExemple :  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6",
      "de": "Berechne die benötigte Zeit, um die umgekehrte Sitzordnung zu erhalten.\nFür jede Person wird die Person, die ursprünglich links von ihr war, rechts von ihr sein, und die Person, die ursprünglich rechts von ihr war, wird links von ihr sein.\n\n@param N die Anzahl der Personen\n@return die benötigte Zeit in Minuten\n\nBeispiel:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "ha": "Ƙididdige lokacin da ake buƙata don samun tsarin zama na baya.\nGa kowane mutum, mutumin da ke a asalin gefen hagu zai kasance a gefen dama, kuma mutumin da ke a asalin gefen dama zai kasance a gefen hagu.\n\n@param N adadin mutanen\n@return lokacin da ake buƙata a cikin mintuna\n\nMisali:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6",
      "hi": "उलटी बैठने की व्यवस्था प्राप्त करने के लिए आवश्यक समय की गणना करें।\nप्रत्येक व्यक्ति के लिए, जो व्यक्ति मूल रूप से उनकी बाईं ओर था, वह उनकी दाईं ओर होगा, और जो व्यक्ति मूल रूप से उनकी दाईं ओर था, वह उनकी बाईं ओर होगा।\n\n@param N लोगों की संख्या  \n@return आवश्यक समय मिनटों में  \n\nउदाहरण:  \n>>> calculateTimeNeeded(4)  \n2  \n>>> calculateTimeNeeded(5)  \n4  \n>>> calculateTimeNeeded(6)  \n6  ",
      "hu": "Számítsa ki a szükséges időt a fordított ülésrend eléréséhez.\nMinden személy esetében az a személy, aki eredetileg a bal oldalukon volt, a jobb oldalukon lesz, és az a személy, aki eredetileg a jobb oldalukon volt, a bal oldalukon lesz.\n\n@param N a személyek száma  \n@return a szükséges idő percekben\n\nPélda:\n>>> calculateTimeNeeded(4)\n2\n>>> calculateTimeNeeded(5)\n4\n>>> calculateTimeNeeded(6)\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9493049582611327",
      "hy": "0.99155681839335",
      "bn": "0.9801010097975439",
      "bg": "0.9783602131381541",
      "zh": "0.9440299312319892",
      "fr": "0.9982447033227947",
      "de": "0.990441111543077",
      "ha": "0.9339550010451376",
      "hi": "0.9532106274434218",
      "hu": "0.9844476384257304"
    }
  },
  {
    "task_id": "Java/4",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Given an array of distinct integers, return all possible permutations of the array.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "sq": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Duke pasur një varg të numrave të plotë të dallueshëm, kthe të gjitha permutacionet e mundshme të vargut.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "hy": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Տրված է տարբեր ամբողջ թվերի զանգված, վերադարձնել զանգվածի բոլոր հնարավոր փոխատեղումները։\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "bn": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া হলে, অ্যারের সমস্ত সম্ভাব্য বিন্যাস ফেরত দিন।\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "bg": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Даден е масив от различни цели числа, върнете всички възможни пермутации на масива.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "zh": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * 给定一个由不同整数组成的数组，返回该数组所有可能的排列。\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "fr": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Étant donné un tableau d'entiers distincts, renvoie toutes les permutations possibles du tableau.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "de": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Gegeben ein Array von verschiedenen ganzen Zahlen, gebe alle möglichen Permutationen des Arrays zurück.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "ha": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * An ba da jerin lambobi na musamman, dawo da dukkan yiwuwar juyawa na jerin.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums)",
      "hi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * दिए गए भिन्न पूर्णांकों के एक एरे के सभी संभावित क्रमपरिवर्तन लौटाएं।\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) ",
      "hu": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n\n  /**\n   * Adott egy különböző egész számokat tartalmazó tömb, adja vissza a tömb összes lehetséges permutációját.\n   * >>> permute(new int[]{1,2,3})\n   * [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n   * >>> permute(new int[]{0,1})\n   * [[0,1],[1,0]]\n   * >>> permute(new int[]{1})\n   * [[1]]\n   */\n  public List<List<Integer>> permute(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "1",
      "zh": "0.9942236298891244",
      "fr": "1",
      "de": "1",
      "ha": "0.9866355520728296",
      "hi": "0.9735692483475926",
      "hu": "1"
    },
    "canonical_solution": "    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }",
    "instruction": {
      "en": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nՏվեք Java կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public List<List<Integer>> permute(int[] nums)\n    {\n        List<List<Integer>> result = new ArrayList<>();\n        // Start backtracking with an empty list as the current permutation\n        backtrack(result, new ArrayList<>(), nums);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> list, List<Integer> tempList, int [] nums){\n        if(tempList.size() == nums.length){\n            list.add(new ArrayList<>(tempList)); // Add a new list to avoid reference issues\n        } else {\n            for(int i = 0; i < nums.length; i++){\n                if(tempList.contains(nums[i])) continue; // Element already exists, skip\n                tempList.add(nums[i]);\n                backtrack(list, tempList, nums);\n                tempList.remove(tempList.size() - 1); // Remove the last element added for backtracking\n            }\n        }\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.8954556660714315",
      "bg": "0.8376140553201085",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution\n      .permute(new int[] { 4, 5, 6 })\n      .equals(\n        Arrays.asList(\n          Arrays.asList(4, 5, 6),\n          Arrays.asList(4, 6, 5),\n          Arrays.asList(5, 4, 6),\n          Arrays.asList(5, 6, 4),\n          Arrays.asList(6, 4, 5),\n          Arrays.asList(6, 5, 4)\n        )\n      );\n    assert solution\n      .permute(new int[] { 7, 8 })\n      .equals(Arrays.asList(Arrays.asList(7, 8), Arrays.asList(8, 7)));\n    assert solution\n      .permute(new int[] { 9 })\n      .equals(Collections.singletonList(Collections.singletonList(9)));\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "permute",
    "signature": "public List<List<Integer>> permute(int[] nums)",
    "docstring": {
      "en": "Given an array of distinct integers, return all possible permutations of the array.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "sq": "Duke pasur një varg me numra të plotë të dallueshëm, kthe të gjitha permutacionet e mundshme të vargut.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "hy": "Տրված է տարբեր ամբողջ թվերի զանգված, վերադարձնել զանգվածի բոլոր հնարավոր փոխատեղումները:\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "bn": "বিভিন্ন পূর্ণসংখ্যার একটি অ্যারে দেওয়া হলে, অ্যারের সমস্ত সম্ভাব্য বিন্যাসগুলি ফেরত দিন।  \n>>> permute(new int[]{1,2,3})  \n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]  \n>>> permute(new int[]{0,1})  \n[[0,1],[1,0]]  \n>>> permute(new int[]{1})  \n[[1]]  ",
      "bg": "Даден е масив от различни цели числа, върнете всички възможни пермутации на масива.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "zh": "给定一个不同整数的数组，返回该数组的所有可能排列。\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "fr": "Étant donné un tableau d'entiers distincts, retourner toutes les permutations possibles du tableau.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "de": "Angenommen, ein Array von verschiedenen ganzen Zahlen, geben Sie alle möglichen Permutationen des Arrays zurück.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "ha": "An ba da wani tsararren jerin lambobi na musamman, dawo da dukkan yiwuwar juyawar jerin.\n\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]",
      "hi": "दिए गए भिन्न पूर्णांकों के एक array के लिए, array के सभी संभावित क्रमचयों को लौटाएं।  \n>>> permute(new int[]{1,2,3})  \n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]  \n>>> permute(new int[]{0,1})  \n[[0,1],[1,0]]  \n>>> permute(new int[]{1})  \n[[1]]  ",
      "hu": "Adott egy tömb különböző egész számokkal, adja vissza a tömb összes lehetséges permutációját.\n>>> permute(new int[]{1,2,3})\n[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n>>> permute(new int[]{0,1})\n[[0,1],[1,0]]\n>>> permute(new int[]{1})\n[[1]]"
    },
    "docstring_bertscore": {
      "sq": "0.9863403873266118",
      "hy": "0.9915731060845949",
      "bn": "0.9716592186035611",
      "bg": "0.999999801369619",
      "zh": "0.9751517365932976",
      "fr": "0.999999801369619",
      "de": "0.9836306716685338",
      "ha": "0.9566302480833184",
      "hi": "0.9796689887187929",
      "hu": "0.9958617346415192"
    }
  },
  {
    "task_id": "Java/5",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n     * \n     * Example:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një numër vargjesh që dallojnë shkronjat e mëdha dhe të vogla, gjen vargun më të madh X, të tillë që ose X, ose inversi i tij mund të gjendet si një nënvarg i ndonjë prej vargjeve të dhëna.\n     * \n     * Shembull:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է մեծատառ/փոքրատառ զգայուն տողերի շարք, գտնում է ամենամեծ տողը X, այնպես, որ կա՛մ X, կա՛մ դրա հակադարձը կարող է գտնվել որպես ենթատող տրված տողերից որևէ մեկում:\n     * \n     * Օրինակ:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * কিছু কেস-সেনসিটিভ স্ট্রিং দেওয়া হলে, সবচেয়ে বড় স্ট্রিং X খুঁজে বের করে, যাতে হয় X, অথবা তার বিপরীত যেকোনো একটি প্রদত্ত স্ট্রিং-এর সাবস্ট্রিং হিসাবে পাওয়া যায়।\n     * \n     * উদাহরণ:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Като се даде брой низове, които са чувствителни към големината на буквите, намира най-големия низ X, така че или X, или неговият обратен низ да може да бъде намерен като подниз на който и да е от дадените низове.\n     * \n     * Пример:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定若干个区分大小写的字符串，找到最大的字符串X，使得X或其逆可以作为任何给定字符串的子串找到。\n     * \n     * 示例:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné un certain nombre de chaînes sensibles à la casse, trouve la plus grande chaîne X, telle que soit X, soit son inverse puisse être trouvée comme sous-chaîne de l'une des chaînes données.\n     * \n     * Exemple :\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben eine Anzahl von groß- und kleinschreibungssensitiven Zeichenfolgen, findet die größte Zeichenfolge X, so dass entweder X oder ihr Inverses als Teilzeichenfolge in einer der gegebenen Zeichenfolgen gefunden werden kann.\n     * \n     * Beispiel:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wasu jerin rubutu masu bambancin manyan baki da ƙananan baki, nemo mafi girman rubutu X, ta yadda ko dai X, ko kuma akasin sa za a iya samun sa a matsayin wani ɓangare na kowane daga cikin rubutun da aka bayar.\n     * \n     * Misali:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए केस-सेंसिटिव स्ट्रिंग्स की संख्या के आधार पर, सबसे बड़ा स्ट्रिंग X खोजता है, ऐसा कि या तो X, या उसका इनवर्स किसी भी दिए गए स्ट्रिंग्स के सबस्ट्रिंग के रूप में पाया जा सके।\n     * \n     * उदाहरण:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy számú kis- és nagybetűérzékeny karakterlánc, megkeresi a legnagyobb X karakterláncot, úgy hogy X vagy annak inverze bármelyik adott karakterlánc részkarakterláncaként megtalálható legyen.\n     * \n     * Példa:\n     * >>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n     * 2\n     * >>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n     * 2\n     */\n    public int findLargestSubstring(List<String> strings) "
    },
    "prompt_bertscore": {
      "sq": "0.9500456509520119",
      "hy": "0.9800803522379162",
      "bn": "0.9648054773059523",
      "bg": "0.9869885182599286",
      "zh": "0.964399079546355",
      "fr": "0.9841179119932124",
      "de": "0.9802565373858941",
      "ha": "0.9571822419122143",
      "hi": "0.9818255187656888",
      "hu": "0.9667701304047683"
    },
    "canonical_solution": "    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }",
    "instruction": {
      "en": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nՏվեք Java կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int findLargestSubstring(List<String> strings)\n    {\n        int maxLen = 0; // To keep track of the maximum length of substring found\n        if (strings == null || strings.isEmpty()) {\n            return maxLen;\n        }\n        \n        String firstString = strings.get(0);\n        \n        // Iterate over all possible substrings of the first string\n        for (int i = 0; i < firstString.length(); i++) {\n            for (int j = i + 1; j <= firstString.length(); j++) {\n                String substr = firstString.substring(i, j);\n                String inverse = new StringBuilder(substr).reverse().toString();\n                \n                boolean allContains = true; // Flag to check if all strings contain the substring or its inverse\n                \n                // Check for each string in the list\n                for (String str : strings) {\n                    if (!str.contains(substr) && !str.contains(inverse)) {\n                        allContains = false;\n                        break;\n                    }\n                }\n                \n                // Update maxLen if a larger valid substring is found\n                if (allContains) {\n                    maxLen = Math.max(maxLen, substr.length());\n                }\n            }\n        }\n        \n        return maxLen;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.8821843757929664",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"rose\", \"orchid\")) == 2;\n        assert solution.findLargestSubstring(Arrays.asList(\"hello\", \"world\")) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "findLargestSubstring",
    "signature": "public int findLargestSubstring(List<String> strings)",
    "docstring": {
      "en": "Given a number of case-sensitive strings, finds the largest string X, such that either X, or its inverse can be found as a substring of any of the given strings.\n\nExample:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "sq": "Duke pasur një numër vargjesh që janë të ndjeshme ndaj shkronjave të mëdha, gjen vargun më të madh X, në mënyrë të tillë që ose X, ose inversi i tij mund të gjendet si një nënvarg i ndonjërit prej vargjeve të dhëna.\n\nShembull:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "hy": "Տրված է մի քանի մեծատառ-փոքրատառ զգայուն տողեր, գտնում է ամենամեծ տողը X, այնպես, որ կամ X-ը, կամ նրա հակադարձը կարող է գտնվել որպես ենթատող տրված տողերից որևէ մեկում:\n\nՕրինակ:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "bn": "প্রদত্ত কেস-সংবেদনশীল স্ট্রিংগুলির মধ্যে, সবচেয়ে বড় স্ট্রিং X খুঁজে বের করে, যাতে X বা তার বিপরীত যেকোনো প্রদত্ত স্ট্রিংয়ের একটি সাবস্ট্রিং হিসাবে পাওয়া যায়।\n\nউদাহরণ:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "bg": "Даден е брой низове, чувствителни към малки и големи букви, намира най-големия низ X, така че или X, или неговият обратен низ да може да бъде намерен като подниз на някой от дадените низове.\n\nПример:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "zh": "给定若干区分大小写的字符串，找到最大的字符串X，使得X或其逆序可以作为任何给定字符串的子串。\n\n示例：\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "fr": "Étant donné un certain nombre de chaînes sensibles à la casse, trouve la plus grande chaîne X, telle que soit X, soit son inverse puisse être trouvé comme une sous-chaîne de l'une des chaînes données.\n\nExemple :\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "de": "Angenommen, es gibt eine Anzahl von groß- und kleinschreibungssensitiven Zeichenfolgen, findet die größte Zeichenfolge X, so dass entweder X oder ihr Inverses als Teilzeichenfolge in einer der gegebenen Zeichenfolgen gefunden werden kann.\n\nBeispiel:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "ha": "An ba da adadin igiyoyin haruffa masu bambancin manya da ƙanana, yana nemo babbar igiya X, ta yadda ko dai X, ko kuma akasin ta za a iya samun ta a matsayin wani ɓangare na kowane daga cikin igiyoyin da aka bayar.\n\nMisali:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "hi": "दिए गए केस-सेंसिटिव स्ट्रिंग्स में से सबसे बड़ा स्ट्रिंग X खोजता है, ऐसा कि या तो X, या उसका उल्टा किसी भी दिए गए स्ट्रिंग्स के सबस्ट्रिंग के रूप में पाया जा सके।\n\nउदाहरण:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2",
      "hu": "Adott egy számú kis- és nagybetű érzékeny karakterlánc, megkeresi a legnagyobb X karakterláncot, úgy, hogy vagy X, vagy annak inverze megtalálható bármelyik megadott karakterláncban.\n\nPélda:\n>>> findLargestSubstring(Arrays.asList(\"ABCD\", \"BCDFF\", \"BRCD\"))\n2\n>>> findLargestSubstring(Arrays.asList(\"rose\", \"orchid\"))\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9839089528323637",
      "hy": "0.9668901031549134",
      "bn": "0.9588849015384454",
      "bg": "0.9812550523113566",
      "zh": "0.9560029733400102",
      "fr": "0.9841989531886747",
      "de": "0.9706352789893262",
      "ha": "0.9532342644587649",
      "hi": "0.950547589924887",
      "hu": "0.9445133975794281"
    }
  },
  {
    "task_id": "Java/6",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n     * \n     * Parameters:\n     *     grid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n     * \n     * Returns:\n     *     int: The number of distinct oil deposits in the grid.\n     * \n     * Example:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "sq": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Duke pasur një rrjet që përfaqëson një tokë të ndarë në parcela katrore, përcaktoni numrin e depozitave të naftës të dallueshme.\n     * \n     * Parametrat:\n     *     grid (char[][]): Rrjeti që përfaqëson tokën. Çdo karakter është ose '*' për mungesën e naftës ose '@' për një xhep nafte.\n     * \n     * Kthen:\n     *     int: Numri i depozitave të naftës të dallueshme në rrjet.\n     * \n     * Shembull:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "hy": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Տրված է ցանց, որը ներկայացնում է հողը բաժանված քառակուսի հատվածների, որոշել տարբեր նավթի հանքավայրերի քանակը:\n     * \n     * Պարամետրեր:\n     *     grid (char[][]): Ցանցը, որը ներկայացնում է հողը: Յուրաքանչյուր նիշ կամ '*' է՝ նավթի բացակայության համար, կամ '@'՝ նավթի գրպանի համար:\n     * \n     * Վերադարձնում է:\n     *     int: Ցանցում տարբեր նավթի հանքավայրերի քանակը:\n     * \n     * Օրինակ:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "bn": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * একটি গ্রিড দেওয়া আছে যা বর্গাকার প্লটে বিভক্ত জমি উপস্থাপন করে, ভিন্ন তেলের আমানতের সংখ্যা নির্ধারণ করুন।\n     * \n     * প্যারামিটার:\n     *     grid (char[][]): জমি উপস্থাপনকারী গ্রিড। প্রতিটি চরিত্র হয় '*' তেলের অনুপস্থিতির জন্য বা '@' তেলের পকেটের জন্য।\n     * \n     * রিটার্নস:\n     *     int: গ্রিডে ভিন্ন তেলের আমানতের সংখ্যা।\n     * \n     * উদাহরণ:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "bg": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Дадена е мрежа, представляваща земя, разделена на квадратни парцели, определете броя на отделните нефтени находища.\n     * \n     * Параметри:\n     *     grid (char[][]): Мрежата, представляваща земята. Всеки символ е или '*' за отсъствие на нефт, или '@' за нефтено джобче.\n     * \n     * Връща:\n     *     int: Броят на отделните нефтени находища в мрежата.\n     * \n     * Пример:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "zh": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * 给定一个表示土地分成方块的网格，确定不同油藏的数量。\n     * \n     * 参数:\n     *     grid (char[][]): 表示土地的网格。每个字符要么是 '*' 表示没有油，要么是 '@' 表示一个油袋。\n     * \n     * 返回:\n     *     int: 网格中不同油藏的数量。\n     * \n     * 示例:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "fr": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Étant donné une grille représentant un terrain divisé en parcelles carrées, déterminer le nombre de gisements de pétrole distincts.\n     * \n     * Paramètres:\n     *     grid (char[][]): La grille représentant le terrain. Chaque caractère est soit '*' pour absence de pétrole, soit '@' pour une poche de pétrole.\n     * \n     * Renvoie:\n     *     int: Le nombre de gisements de pétrole distincts dans la grille.\n     * \n     * Exemple:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "de": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Gegeben ein Gitter, das ein in quadratische Parzellen unterteiltes Land darstellt, bestimmen Sie die Anzahl der unterschiedlichen Ölvorkommen.\n     * \n     * Parameter:\n     *     grid (char[][]): Das Gitter, das das Land darstellt. Jedes Zeichen ist entweder '*' für Abwesenheit von Öl oder '@' für eine Ölquelle.\n     * \n     * Rückgabe:\n     *     int: Die Anzahl der unterschiedlichen Ölvorkommen im Gitter.\n     * \n     * Beispiel:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "ha": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * An ba da grid wanda ke wakiltar ƙasa da aka raba zuwa filaye masu kusurwa huɗu, tantance adadin wuraren mai na daban-daban.\n     * \n     * Sigogi:\n     *     grid (char[][]): Grid ɗin da ke wakiltar ƙasar. Kowanne hali ko dai '*' don rashin mai ko '@' don aljihun mai.\n     * \n     * Komawa:\n     *     int: Adadin wuraren mai na daban-daban a cikin grid.\n     * \n     * Misali:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "hi": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * एक ग्रिड दिया गया है जो वर्गाकार भूखंडों में विभाजित भूमि का प्रतिनिधित्व करता है, यह निर्धारित करें कि कितने भिन्न तेल भंडार हैं।\n     * \n     * पैरामीटर्स:\n     *     grid (char[][]): भूमि का प्रतिनिधित्व करने वाला ग्रिड। प्रत्येक वर्ण या तो '*' है तेल की अनुपस्थिति के लिए या '@' है एक तेल के पॉकेट के लिए।\n     * \n     * रिटर्न करता है:\n     *     int: ग्रिड में भिन्न तेल भंडारों की संख्या।\n     * \n     * उदाहरण:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) ",
      "hu": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Egy négyzet alakú parcellákra osztott földterületet ábrázoló rács alapján határozza meg a különálló olajmezők számát.\n     * \n     * Paraméterek:\n     *     grid (char[][]): A földterületet ábrázoló rács. Minden karakter vagy '*' az olaj hiányára, vagy '@' egy olajzsebre utal.\n     * \n     * Visszatérési érték:\n     *     int: A különálló olajmezők száma a rácsban.\n     * \n     * Példa:\n     *     >>> countOilDeposits(new char[][] {{'*'}})\n     *     0\n     *     >>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n     *     1\n     *     >>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n     *     2\n     */\n    private static final int[] dx = {-1, 0, 1, 0, -1, -1, 1, 1};\n    private static final int[] dy = {0, 1, 0, -1, -1, 1, -1, 1};\n    public static int countOilDeposits(char[][] grid) "
    },
    "prompt_bertscore": {
      "sq": "0.9904111183555407",
      "hy": "0.9880136496564497",
      "bn": "0.9903654333679027",
      "bg": "0.9969031537292851",
      "zh": "0.9826804239256629",
      "fr": "0.9966725438569035",
      "de": "0.9942051572636882",
      "ha": "0.9927845527785266",
      "hi": "0.9902865771066319",
      "hu": "0.9543251425114085"
    },
    "canonical_solution": "    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }",
    "instruction": {
      "en": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nПредоставете кратко описание на Java кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\n请用最多500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nFournir une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Java cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int countOilDeposits(char[][] grid)\n    {\n\n  \n        int count = 0;\n        for (int i = 0; i < grid.length; i++) {\n            for (int j = 0; j < grid[0].length; j++) {\n                if (grid[i][j] == '@') {\n                    dfs(grid, i, j);\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n\n    private static void dfs(char[][] grid, int x, int y) {\n        if (x < 0 || y < 0 || x >= grid.length || y >= grid[0].length || grid[x][y] != '@') {\n            return;\n        }\n        grid[x][y] = '*';\n        for (int i = 0; i < 8; i++) {\n            dfs(grid, x + dx[i], y + dy[i]);\n        }\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9615433705582164",
      "bn": "0.9097683754376624",
      "bg": "0.899404239416024",
      "zh": "0.8770857325421819",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9168968225522425",
      "hi": "0.9113991308659588",
      "hu": "0.9407980163021705"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countOilDeposits(new char[][] {{'@', '@', '@'}, {'@', '*', '@'}, {'@', '@', '@'}}) == 1;\n        assert countOilDeposits(new char[][] {{'@', '*', '@'}, {'*', '*', '*'}, {'@', '*', '@'}}) == 4;\n        assert countOilDeposits(new char[][] {{'*', '*', '*', '*', '*'}, {'*', '@', '@', '@', '*'}, {'*', '@', '*', '@', '*'}, {'*', '@', '@', '@', '*'}, {'*', '*', '*', '*', '*'}}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countOilDeposits",
    "signature": "public static int countOilDeposits(char[][] grid)",
    "docstring": {
      "en": "Given a grid representing a land divided into square plots, determine the number of distinct oil deposits.\n\nParameters:\ngrid (char[][]): The grid representing the land. Each character is either '*' for absence of oil or '@' for an oil pocket.\n\nReturns:\nint: The number of distinct oil deposits in the grid.\n\nExample:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "sq": "Duke pasur një rrjet që përfaqëson një tokë të ndarë në parcela katrore, përcaktoni numrin e depozitave të veçanta të naftës.\n\nParametrat:\ngrid (char[][]): Rrjeti që përfaqëson tokën. Çdo karakter është ose '*' për mungesën e naftës ose '@' për një xhep nafte.\n\nKthen:\nint: Numri i depozitave të veçanta të naftës në rrjet.\n\nShembull:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "hy": "Տրված ցանցը, որը ներկայացնում է հողը բաժանված քառակուսի հողակտորների, որոշեք տարբեր նավթային հանքավայրերի քանակը:\n\nՊարամետրեր:\ngrid (char[][]): Ցանցը, որը ներկայացնում է հողը: Յուրաքանչյուր նշան կա՛մ '*' է՝ նավթի բացակայության համար, կա՛մ '@'՝ նավթի գրպանի համար:\n\nՎերադարձնում է:\nint: Ցանցում տարբեր նավթային հանքավայրերի քանակը:\n\nՕրինակ:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "bn": "একটি গ্রিড দেওয়া হয়েছে যা বর্গাকার প্লটগুলিতে বিভক্ত জমি উপস্থাপন করে, আলাদা তেল জমার সংখ্যা নির্ধারণ করুন।\n\nপ্যারামিটারসমূহ:\ngrid (char[][]): জমি উপস্থাপনকারী গ্রিড। প্রতিটি চরিত্র হয় '*' তেলের অনুপস্থিতির জন্য বা '@' তেলের পকেটের জন্য।\n\nরিটার্নস:\nint: গ্রিডে আলাদা তেল জমার সংখ্যা।\n\nউদাহরণ:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "bg": "Дадена е мрежа, представляваща земя, разделена на квадратни парцели, определете броя на различните нефтени находища.\n\nПараметри:\ngrid (char[][]): Мрежата, представляваща земята. Всеки символ е или '*' за отсъствие на нефт, или '@' за нефтено джобче.\n\nВръща:\nint: Броят на различните нефтени находища в мрежата.\n\nПример:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "zh": "给定一个表示土地分成正方形地块的网格，确定不同油藏的数量。\n\n参数：\ngrid (char[][]): 表示土地的网格。每个字符要么是 '*' 表示没有油，要么是 '@' 表示一个油囊。\n\n返回：\nint: 网格中不同油藏的数量。\n\n示例：\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "fr": "Étant donné une grille représentant un terrain divisé en parcelles carrées, déterminez le nombre de gisements de pétrole distincts.\n\nParamètres :\ngrid (char[][]) : La grille représentant le terrain. Chaque caractère est soit '*' pour l'absence de pétrole, soit '@' pour une poche de pétrole.\n\nRenvoie :\nint : Le nombre de gisements de pétrole distincts dans la grille.\n\nExemple :\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "de": "Gegeben ein Raster, das ein in quadratische Parzellen unterteiltes Land darstellt, bestimmen Sie die Anzahl der verschiedenen Ölvorkommen.\n\nParameter:\ngrid (char[][]): Das Raster, das das Land darstellt. Jedes Zeichen ist entweder '*' für das Fehlen von Öl oder '@' für eine Ölquelle.\n\nRückgabe:\nint: Die Anzahl der verschiedenen Ölvorkommen im Raster.\n\nBeispiel:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "ha": "An ba da wata grid da ke wakiltar ƙasa da aka raba zuwa filaye masu siffar murabba'i, a ƙayyade yawan wuraren mai masu bambanci.\n\nSigogi:\ngrid (char[][]): Grid ɗin da ke wakiltar ƙasar. Kowanne hali ko dai '*' don rashin mai ko '@' don aljihun mai.\n\nDawowa:\nint: Yawan wuraren mai masu bambanci a cikin grid ɗin.\n\nMisali:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "hi": "दिए गए ग्रिड में जो भूमि को वर्गाकार भूखंडों में विभाजित करता है, यह निर्धारित करें कि कितने विशिष्ट तेल भंडार हैं।\n\nपैरामीटर्स:\ngrid (char[][]): भूमि का प्रतिनिधित्व करने वाला ग्रिड। प्रत्येक चरित्र या तो '*' है तेल की अनुपस्थिति के लिए या '@' है तेल की जेब के लिए।\n\nवापसी:\nint: ग्रिड में विशिष्ट तेल भंडारों की संख्या।\n\nउदाहरण:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2",
      "hu": "Egy négyzet alakú parcellákra osztott földterületet ábrázoló rács alapján határozza meg a különálló olajlerakódások számát.\n\nParaméterek:\ngrid (char[][]): A földet ábrázoló rács. Minden karakter vagy '*' az olaj hiányára, vagy '@' egy olajzsebre utal.\n\nVisszatérési érték:\nint: A rácsban található különálló olajlerakódások száma.\n\nPélda:\n>>> countOilDeposits(new char[][] {{'*'}})\n0\n>>> countOilDeposits(new char[][] {{'*', '@', '*', '@', '*'}, {'*', '*', '@', '*', '*'}, {'*', '@', '*', '@', '*'}})\n1\n>>> countOilDeposits(new char[][] {{'@', '@', '*', '*', '*', '*', '@', '*'}})\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9938865541325083",
      "hy": "0.9887620889321891",
      "bn": "0.9836497401851132",
      "bg": "0.9961022760329524",
      "zh": "0.9887241505294114",
      "fr": "0.9947033222593237",
      "de": "0.9922371274483945",
      "ha": "0.9884283898920505",
      "hi": "0.9735607072412081",
      "hu": "0.9556096851855611"
    }
  },
  {
    "task_id": "Java/7",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n     *\n     * Example:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N the number of triangles\n     * @return the maximum number of regions\n     */\n    public static int maxRegions(int N) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur parasysh numrin e trekëndëshave N, përcaktoni numrin maksimal të rajoneve në të cilat mund të ndahet plani.\n     *\n     * Shembull:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N numri i trekëndëshave\n     * @return numri maksimal i rajoneve\n     */\n    public static int maxRegions(int N) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է եռանկյունների քանակը N, որոշեք հարթությունը բաժանելու առավելագույն շրջանների քանակը:\n     *\n     * Օրինակ:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N եռանկյունների քանակը\n     * @return առավելագույն շրջանների քանակը\n     */\n    public static int maxRegions(int N) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * প্রদত্ত ত্রিভুজের সংখ্যা N, নির্ধারণ করুন সমতলকে সর্বাধিক কতটি অঞ্চলে বিভক্ত করা যায়।\n     *\n     * উদাহরণ:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N ত্রিভুজের সংখ্যা\n     * @return সর্বাধিক অঞ্চলের সংখ্যা\n     */\n    public static int maxRegions(int N) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Даден е броят на триъгълниците N, определете максималния брой области, на които може да бъде разделена равнината.\n     *\n     * Пример:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N броят на триъгълниците\n     * @return максималният брой области\n     */\n    public static int maxRegions(int N) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定三角形的数量 N，确定平面可以分成的最大区域数。\n     *\n     * 示例:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N 三角形的数量\n     * @return 最大区域数\n     */\n    public static int maxRegions(int N) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné le nombre de triangles N, déterminez le nombre maximum de régions dans lesquelles le plan peut être divisé.\n     *\n     * Exemple:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N le nombre de triangles\n     * @return le nombre maximum de régions\n     */\n    public static int maxRegions(int N) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben die Anzahl der Dreiecke N, bestimme die maximale Anzahl von Regionen, in die die Ebene unterteilt werden kann.\n     *\n     * Beispiel:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N die Anzahl der Dreiecke\n     * @return die maximale Anzahl der Regionen\n     */\n    public static int maxRegions(int N) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * Idan aka ba da adadin alwatika N, tantance yawan yankunan da za a iya raba filin zuwa.\n     *\n     * Misali:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N adadin alwatika\n     * @return yawan yankunan da za a iya raba\n     */\n    public static int maxRegions(int N) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए त्रिभुजों की संख्या N के लिए, यह निर्धारित करें कि विमान को अधिकतम कितने क्षेत्रों में विभाजित किया जा सकता है।\n     *\n     * उदाहरण:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N त्रिभुजों की संख्या\n     * @return अधिकतम क्षेत्रों की संख्या\n     */\n    public static int maxRegions(int N) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott a háromszögek száma N, határozza meg a maximális számú régiót, amire a sík felosztható.\n     *\n     * Példa:\n     * >>> maxRegions(1)\n     * 2\n     * >>> maxRegions(2)\n     * 8\n     *\n     * @param N a háromszögek száma\n     * @return a maximális régiók száma\n     */\n    public static int maxRegions(int N) "
    },
    "prompt_bertscore": {
      "sq": "0.9923016823222308",
      "hy": "0.9632702630909337",
      "bn": "0.9796362147059222",
      "bg": "0.9923016823222308",
      "zh": "0.9796362147059222",
      "fr": "0.9888749109886169",
      "de": "0.9923016823222308",
      "ha": "0.947268202334001",
      "hi": "0.9587981000619331",
      "hu": "0.9923016823222308"
    },
    "canonical_solution": "    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }",
    "instruction": {
      "en": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nFournir une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int maxRegions(int N)\n    {\n        if (N <= 0) {\n            return 0;\n        }\n        return N * N + N + 1;\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.8954556660714315",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert maxRegions(3) == 13;\n        assert maxRegions(4) == 21;\n        assert maxRegions(5) == 31;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "maxRegions",
    "signature": "public static int maxRegions(int N)",
    "docstring": {
      "en": "Given the number of triangles N, determine the maximum number of regions the plane can be divided into.\n\nExample:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N the number of triangles\n@return the maximum number of regions",
      "sq": "Duke pasur parasysh numrin e trekëndëshave N, përcaktoni numrin maksimal të rajoneve në të cilat mund të ndahet plani.\n\nShembull:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N numri i trekëndëshave\n@return numri maksimal i rajoneve",
      "hy": "Տրված է եռանկյունների քանակը N, որոշեք հարթությունը բաժանելու առավելագույն շրջանների քանակը։\n\nՕրինակ:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N եռանկյունների քանակը\n@return առավելագույն շրջանների քանակը",
      "bn": "ত্রিভুজের সংখ্যা N দেওয়া হলে, সমতলকে সর্বাধিক কতটি অঞ্চলে ভাগ করা যেতে পারে তা নির্ধারণ করুন।\n\nউদাহরণ:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N ত্রিভুজের সংখ্যা\n@return সর্বাধিক অঞ্চলের সংখ্যা",
      "bg": "Даден е броят на триъгълниците N, определете максималния брой региони, на които равнината може да бъде разделена.\n\nПример:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N броят на триъгълниците\n@return максималният брой региони",
      "zh": "给定三角形的数量 N，确定平面可以被划分的最大区域数。\n\n示例：\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N 三角形的数量\n@return 最大的区域数",
      "fr": "Étant donné le nombre de triangles N, déterminez le nombre maximal de régions dans lesquelles le plan peut être divisé.\n\nExemple :\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N le nombre de triangles\n@return le nombre maximal de régions",
      "de": "Gegeben die Anzahl der Dreiecke N, bestimme die maximale Anzahl der Regionen, in die die Ebene unterteilt werden kann.\n\nBeispiel:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N die Anzahl der Dreiecke\n@return die maximale Anzahl der Regionen",
      "ha": "Idan aka ba da adadin alwatika N, tantance yawan yankuna mafi yawa da za a iya raba filin.\n\nMisali:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N yawan alwatika\n@return mafi yawan yankuna",
      "hi": "त्रिभुजों की संख्या N दी गई है, यह निर्धारित करें कि विमान को अधिकतम कितने क्षेत्रों में विभाजित किया जा सकता है।\n\nउदाहरण:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N त्रिभुजों की संख्या\n@return अधिकतम क्षेत्रों की संख्या",
      "hu": "Adott a háromszögek száma N, határozza meg, hogy a síkot legfeljebb hány régióra lehet felosztani.\n\nPélda:\n>>> maxRegions(1)\n2\n>>> maxRegions(2)\n8\n\n@param N a háromszögek száma\n@return a régiók maximális száma"
    },
    "docstring_bertscore": {
      "sq": "0.9578887701775555",
      "hy": "0.9840366721673691",
      "bn": "0.914178367157399",
      "bg": "0.9889132466521566",
      "zh": "0.9660524788380893",
      "fr": "0.9889132466521566",
      "de": "1",
      "ha": "0.9529001681578642",
      "hi": "0.9086363808961445",
      "hu": "0.9754697438333344"
    }
  },
  {
    "task_id": "Java/8",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Count the number of words in the given word list that have the given prefix.\n     * \n     * @param wordList: a list of words\n     * @param prefix: the prefix string\n     * @return the number of words with the given prefix\n     * \n     * Example:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "sq": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Numëron numrin e fjalëve në listën e dhënë të fjalëve që kanë parashtesën e dhënë.\n     * \n     * @param wordList: një listë fjalësh\n     * @param prefix: vargu i parashtesës\n     * @return numri i fjalëve me parashtesën e dhënë\n     * \n     * Shembull:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "hy": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Հաշվել տրված բառերի ցուցակում այն բառերի քանակը, որոնք ունեն տրված նախածանցը։\n     * \n     * @param wordList: բառերի ցուցակ\n     * @param prefix: նախածանցի տողը\n     * @return տրված նախածանցով բառերի քանակը\n     * \n     * Օրինակ:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "bn": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * প্রদত্ত শব্দ তালিকায় প্রদত্ত উপসর্গ সহ শব্দের সংখ্যা গণনা করুন।\n     * \n     * @param wordList: শব্দের একটি তালিকা\n     * @param prefix: উপসর্গ স্ট্রিং\n     * @return প্রদত্ত উপসর্গ সহ শব্দের সংখ্যা\n     * \n     * উদাহরণ:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "bg": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Пребройте броя на думите в дадения списък от думи, които имат дадения префикс.\n     * \n     * @param wordList: списък от думи\n     * @param prefix: префикс низ\n     * @return броя на думите с дадения префикс\n     * \n     * Пример:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "zh": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * 计算给定单词列表中具有给定前缀的单词数量。\n     * \n     * @param wordList: 单词列表\n     * @param prefix: 前缀字符串\n     * @return 具有给定前缀的单词数量\n     * \n     * 示例:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "fr": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Compter le nombre de mots dans la liste de mots donnée qui ont le préfixe donné.\n     * \n     * @param wordList: une liste de mots\n     * @param prefix: la chaîne de caractères préfixe\n     * @return le nombre de mots avec le préfixe donné\n     * \n     * Exemple:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "de": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Zählt die Anzahl der Wörter in der gegebenen Wortliste, die das gegebene Präfix haben.\n     * \n     * @param wordList: eine Liste von Wörtern\n     * @param prefix: der Präfix-String\n     * @return die Anzahl der Wörter mit dem gegebenen Präfix\n     * \n     * Beispiel:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "ha": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Ƙirga yawan kalmomin da ke cikin jerin kalmomin da aka bayar waɗanda ke da farkon da aka bayar.\n     * \n     * @param wordList: jerin kalmomi\n     * @param prefix: farkon kirtani\n     * @return yawan kalmomin da ke da farkon da aka bayar\n     * \n     * Misali:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "hi": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * दिए गए शब्द सूची में उन शब्दों की संख्या गिनें जिनके पास दिया गया उपसर्ग है।\n     * \n     * @param wordList: शब्दों की एक सूची\n     * @param prefix: उपसर्ग स्ट्रिंग\n     * @return दिए गए उपसर्ग वाले शब्दों की संख्या\n     * \n     * उदाहरण:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) ",
      "hu": "import java.util.*;\n\nclass Solution {\n\n    /**\n     * Számolja meg, hogy a megadott szavak listájában hány szó kezdődik a megadott előtaggal.\n     * \n     * @param wordList: egy szavak listája\n     * @param prefix: az előtag string\n     * @return a megadott előtaggal kezdődő szavak száma\n     * \n     * Példa:\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n     * 2\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n     * 3\n     * \n     * >>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n     * 1\n     */\n    public static int countPrefixWords(List<String> wordList, String prefix) "
    },
    "prompt_bertscore": {
      "sq": "0.988863787687279",
      "hy": "0.9779993017358137",
      "bn": "0.9782610965780177",
      "bg": "0.9862688803894392",
      "zh": "0.9717960749360942",
      "fr": "0.993931245968241",
      "de": "0.9944055753181523",
      "ha": "0.9862688803894392",
      "hi": "0.992290757651274",
      "hu": "0.9809366478105577"
    },
    "canonical_solution": "    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }",
    "instruction": {
      "en": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nনিচের জাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\n提供一段简洁的自然语言描述（文档字符串），用中文描述这段Java代码，字数不超过500个字符。",
      "fr": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nFournir une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nBayar da takaitaccen bayanin yanayi na lamba (docstring) na Java cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int countPrefixWords(List<String> wordList, String prefix)\n    {\n\n        int count = 0;\n        for (String word : wordList) {\n            if (word.startsWith(prefix)) {\n                count++;\n            }\n        }\n        return count;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9615433705582164",
      "bn": "0.8744207087198368",
      "bg": "0.8376140553201085",
      "zh": "0.9038358818472934",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8333987679069875",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countPrefixWords(Arrays.asList(\"apple\", \"ape\", \"april\", \"ant\", \"an\"), \"ap\") == 3;\n        assert countPrefixWords(Arrays.asList(\"cat\", \"cap\", \"cape\", \"camp\"), \"ca\") == 4;\n        assert countPrefixWords(Arrays.asList(\"dog\", \"dodge\", \"dot\", \"dough\"), \"do\") == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countPrefixWords",
    "signature": "public static int countPrefixWords(List<String> wordList, String prefix)",
    "docstring": {
      "en": "Count the number of words in the given word list that have the given prefix.\n\n@param wordList: a list of words\n@param prefix: the prefix string\n@return the number of words with the given prefix\n\nExample:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "sq": "Numëroni numrin e fjalëve në listën e dhënë të fjalëve që kanë parashtesën e dhënë.\n\n@param wordList: një listë fjalësh\n@param prefix: vargu i parashtesës\n@return numri i fjalëve me parashtesën e dhënë\n\nShembull:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hy": "Հաշվել տրված բառերի ցուցակում այն բառերի քանակը, որոնք ունեն տրված նախածանցը։\n\n@param wordList: բառերի ցուցակ\n@param prefix: նախածանցի տող\n@return տրված նախածանցով բառերի քանակը\n\nՕրինակ:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "bn": "প্রদত্ত শব্দ তালিকায় প্রদত্ত উপসর্গ সহ কতগুলি শব্দ রয়েছে তা গণনা করুন।\n\n@param wordList: শব্দের একটি তালিকা\n@param prefix: উপসর্গ স্ট্রিং\n@return প্রদত্ত উপসর্গ সহ শব্দের সংখ্যা\n\nউদাহরণ:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "bg": "Бройте броя на думите в дадения списък от думи, които имат дадения префикс.\n\n@param wordList: списък от думи\n@param prefix: префикс низ\n@return броят на думите с дадения префикс\n\nПример:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "zh": "计算给定单词列表中具有给定前缀的单词数量。\n\n@param wordList: 单词列表\n@param prefix: 前缀字符串\n@return 具有给定前缀的单词数量\n\n示例：\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "fr": "Compter le nombre de mots dans la liste de mots donnée qui ont le préfixe donné.\n\n@param wordList: une liste de mots\n@param prefix: la chaîne de caractères préfixe\n@return le nombre de mots avec le préfixe donné\n\nExemple :\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "de": "Zähle die Anzahl der Wörter in der gegebenen Wortliste, die das gegebene Präfix haben.\n\n@param wordList: eine Liste von Wörtern\n@param prefix: der Präfix-String\n@return die Anzahl der Wörter mit dem gegebenen Präfix\n\nBeispiel:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "ha": "Ƙididdige yawan kalmomin da ke cikin jerin kalmomin da aka bayar waɗanda ke da farkon da aka bayar.\n\n@param wordList: jerin kalmomi\n@param prefix: farkon kalma\n@return yawan kalmomin da ke da farkon da aka bayar\n\nMisali:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hi": "दिए गए शब्द सूची में उन शब्दों की संख्या गिनें जिनके पास दिया गया उपसर्ग है।\n\n@param wordList: शब्दों की एक सूची\n@param prefix: उपसर्ग स्ट्रिंग\n@return उन शब्दों की संख्या जिनके पास दिया गया उपसर्ग है\n\nउदाहरण:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1",
      "hu": "Számolja meg a megadott szólajstromban azon szavak számát, amelyek a megadott előtaggal rendelkeznek.\n\n@param wordList: szavak listája\n@param prefix: az előtag string\n@return azon szavak száma, amelyek a megadott előtaggal rendelkeznek\n\nPélda:\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"ba\")\n2\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"b\")\n3\n\n>>> countPrefixWords(Arrays.asList(\"banana\", \"band\", \"bee\", \"absolute\", \"acm\"), \"band\")\n1"
    },
    "docstring_bertscore": {
      "sq": "0.9933375397593278",
      "hy": "0.9734866181090821",
      "bn": "0.9757094907032435",
      "bg": "0.9756284495077813",
      "zh": "0.9644302645161774",
      "fr": "0.9933375397593278",
      "de": "0.999999801369619",
      "ha": "0.9819778682679425",
      "hi": "0.9892777334013557",
      "hu": "0.9772772803007519"
    }
  },
  {
    "task_id": "Java/9",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n   /**\n     * Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n     * \n     * Example:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "sq": "import java.util.*;\n\nclass Solution {\n   /**\n     * Duke pasur një listë numrash, përcaktoni sa elemente në listë janë dyfishi i ndonjë elementi tjetër në të njëjtën listë.\n     * \n     * Shembull:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "hy": "import java.util.*;\n\nclass Solution {\n   /**\n     * Տրված է թվերի ցուցակ, որոշեք, թե ցուցակի քանի տարր է երկու անգամ ավելի մեծ, քան ցուցակի որևէ այլ տարր։\n     * \n     * Օրինակ:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "bn": "import java.util.*;\n\nclass Solution {\n   /**\n     * প্রদত্ত সংখ্যার একটি তালিকা, নির্ধারণ করুন তালিকার কতগুলি আইটেম একই তালিকার অন্য কোনও আইটেমের দ্বিগুণ।\n     * \n     * উদাহরণ:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "bg": "import java.util.*;\n\nclass Solution {\n   /**\n     * Даден е списък от числа, определете колко елемента в списъка са два пъти по-големи от някой друг елемент в същия списък.\n     * \n     * Пример:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "zh": "import java.util.*;\n\nclass Solution {\n   /**\n     * 给定一个数字列表，确定列表中有多少项是列表中其他某项的两倍。\n     * \n     * 示例:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "fr": "import java.util.*;\n\nclass Solution {\n   /**\n     * Étant donné une liste de nombres, déterminez combien d'éléments dans la liste sont le double d'un autre élément dans la même liste.\n     * \n     * Exemple:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "de": "import java.util.*;\n\nclass Solution {\n   /**\n     * Gegeben eine Liste von Zahlen, bestimme, wie viele Elemente in der Liste doppelt so groß wie ein anderes Element in derselben Liste sind.\n     * \n     * Beispiel:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "ha": "import java.util.*;\n\nclass Solution {\n   /**\n     * An ba da jerin lambobi, tantance yawan abubuwan da ke cikin jerin da suke ninki biyu na wasu abubuwa a cikin wannan jerin.\n     * \n     * Misali:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "hi": "import java.util.*;\n\nclass Solution {\n   /**\n     * दिए गए संख्याओं की सूची में, यह निर्धारित करें कि सूची में कितने आइटम उसी सूची के किसी अन्य आइटम के दोगुने हैं।\n     * \n     * उदाहरण:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) ",
      "hu": "import java.util.*;\n\nclass Solution {\n   /**\n     * Adott egy számokból álló lista, határozza meg, hogy hány elem van a listában, amely kétszerese egy másik elemnek ugyanabban a listában.\n     * \n     * Példa:\n     * >>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n     * 3\n     * >>> countDoubles(new int[] {2, 4, 8, 10})\n     * 2\n     * >>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n     * 0\n     */\n    public static int countDoubles(int[] numbers) "
    },
    "prompt_bertscore": {
      "sq": "0.9892600552974435",
      "hy": "0.9718332188173476",
      "bn": "0.9895244323346011",
      "bg": "0.97149395812654",
      "zh": "0.9870119566448907",
      "fr": "0.9868161070891903",
      "de": "0.9778686029450928",
      "ha": "0.9747536813097036",
      "hi": "0.9797788313195053",
      "hu": "0.9868161070891903"
    },
    "canonical_solution": "    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }",
    "instruction": {
      "en": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nՏվեք Java կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int countDoubles(int[] numbers)\n    {\n     \n        Set<Integer> set = new HashSet<>();\n        int count = 0;\n        for (int num : numbers) {\n            if (set.contains(num * 2) || (num % 2 == 0 && set.contains(num / 2))) {\n                count++;\n            }\n            set.add(num);\n        }\n        return count;\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9357093045704378",
      "hy": "0.9242475370632005",
      "bn": "0.8954556660714315",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert countDoubles(new int[]{1, 2, 4, 8, 16}) == 4;\n        assert countDoubles(new int[]{5, 10, 20, 40, 80}) == 4;\n        assert countDoubles(new int[]{3, 6, 12, 24, 48}) == 4;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "countDoubles",
    "signature": "public static int countDoubles(int[] numbers)",
    "docstring": {
      "en": "Given a list of numbers, determine how many items in the list are twice some other item in the same list.\n\nExample:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "sq": "Duke pasur një listë numrash, përcaktoni sa artikuj në listë janë dyfishi i ndonjë artikulli tjetër në të njëjtën listë.\n\nShembull:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hy": "Տրված թվերի ցուցակի դեպքում որոշեք, թե քանի տարր ցուցակում կրկնակի են ցուցակի այլ տարրի։\n\nՕրինակ:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "bn": "একটি সংখ্যার তালিকা দেওয়া হয়েছে, তালিকায় কতগুলি আইটেম একই তালিকার অন্য কোনো আইটেমের দ্বিগুণ তা নির্ধারণ করুন।\n\nউদাহরণ:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "bg": "Даден е списък от числа, определете колко елемента в списъка са два пъти някой друг елемент в същия списък.\n\nПример:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "zh": "给定一个数字列表，确定列表中有多少项是列表中其他某项的两倍。\n\n示例：\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "fr": "Étant donné une liste de nombres, déterminez combien d'éléments dans la liste sont le double d'un autre élément dans la même liste.\n\nExemple :\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "de": "Gegeben eine Liste von Zahlen, bestimmen, wie viele Elemente in der Liste das Doppelte eines anderen Elements in derselben Liste sind.\n\nBeispiel:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "ha": "An ba da jerin lambobi, tantance yawan abubuwan da ke cikin jerin da suka ninka wasu abubuwa a cikin wannan jerin.\n\nMisali:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hi": "दिए गए संख्याओं की सूची में, यह निर्धारित करें कि सूची में कितनी वस्तुएं किसी अन्य वस्तु की दोगुनी हैं।\n\nउदाहरण:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0",
      "hu": "Adott egy számokból álló lista, határozza meg, hány elem van a listában, amely kétszerese a lista egy másik elemének.\n\nPélda:\n>>> countDoubles(new int[] {1, 4, 3, 2, 9, 7, 18, 22})\n3\n>>> countDoubles(new int[] {2, 4, 8, 10})\n2\n>>> countDoubles(new int[] {7, 5, 11, 13, 1, 3})\n0"
    },
    "docstring_bertscore": {
      "sq": "0.988191622477857",
      "hy": "0.9762096420026893",
      "bn": "0.9719166435773824",
      "bg": "0.9940349310271412",
      "zh": "0.9848582074233294",
      "fr": "0.9845284809908115",
      "de": "0.9845284809908115",
      "ha": "0.9707943819245353",
      "hi": "0.9592203882520133",
      "hu": "0.9726728294379822"
    }
  },
  {
    "task_id": "Java/10",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n     * \n     * Parameters:\n     * - n: the size of the n-teresting space\n     * - start: the starting n-tersection coordinates\n     * - end: the ending n-tersection coordinates\n     * - paths: paths between adjacent n-tersections in the n-teresting space\n     * \n     * Output:\n     * - If travel is possible, return \"can be travelled\"\n     * - If travel is not possible, return \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur madhësinë e hapësirës n-teresting, koordinatat e fillimit dhe mbarimit të n-tersections, dhe rrugët midis n-tersections ngjitur, përcaktoni nëse është e mundur të udhëtohet nga n-tersection fillestar në n-tersection përfundimtar.\n     * \n     * Parametrat:\n     * - n: madhësia e hapësirës n-teresting\n     * - start: koordinatat e fillimit të n-tersection\n     * - end: koordinatat e mbarimit të n-tersection\n     * - paths: rrugët midis n-tersections ngjitur në hapësirën n-teresting\n     * \n     * Dalja:\n     * - Nëse udhëtimi është i mundur, kthe \"mund të udhëtohet\"\n     * - Nëse udhëtimi nuk është i mundur, kthe \"nuk mund të udhëtohet\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է n-հետաքրքիր տարածքի չափը, մեկնարկային և վերջնական n-հատվածի կոորդինատները և հարակից n-հատվածների միջև ուղիները, որոշեք՝ արդյոք հնարավոր է ճանապարհորդել մեկնարկային n-հատվածից մինչև վերջնական n-հատվածը:\n     * \n     * Պարամետրեր:\n     * - n: n-հետաքրքիր տարածքի չափը\n     * - start: մեկնարկային n-հատվածի կոորդինատները\n     * - end: վերջնական n-հատվածի կոորդինատները\n     * - paths: n-հետաքրքիր տարածքում հարակից n-հատվածների միջև ուղիները\n     * \n     * Արդյունք:\n     * - Եթե ճանապարհորդությունը հնարավոր է, վերադարձնել \"can be travelled\"\n     * - Եթե ճանապարհորդությունը հնարավոր չէ, վերադարձնել \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * n-আকর্ষণীয় স্থানের আকার, শুরুর এবং শেষের n-সংযোগের স্থানাঙ্ক, এবং সংলগ্ন n-সংযোগগুলির মধ্যে পথগুলি দেওয়া হয়েছে, তাহলে এটি সম্ভব কিনা তা নির্ধারণ করুন যে শুরুর n-সংযোগ থেকে শেষের n-সংযোগে ভ্রমণ করা যাবে।\n     * \n     * প্যারামিটার:\n     * - n: n-আকর্ষণীয় স্থানের আকার\n     * - start: শুরুর n-সংযোগের স্থানাঙ্ক\n     * - end: শেষের n-সংযোগের স্থানাঙ্ক\n     * - paths: n-আকর্ষণীয় স্থানের সংলগ্ন n-সংযোগগুলির মধ্যে পথগুলি\n     * \n     * আউটপুট:\n     * - যদি ভ্রমণ সম্ভব হয়, তাহলে \"can be travelled\" রিটার্ন করুন\n     * - যদি ভ্রমণ সম্ভব না হয়, তাহলে \"cannot be travelled\" রিটার্ন করুন\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Като се има предвид размерът на n-интересното пространство, началните и крайните координати на n-терсекциите и пътищата между съседните n-терсекции, определете дали е възможно да се пътува от началната n-терсекция до крайната n-терсекция.\n     * \n     * Параметри:\n     * - n: размерът на n-интересното пространство\n     * - start: началните координати на n-терсекцията\n     * - end: крайните координати на n-терсекцията\n     * - paths: пътища между съседните n-терсекции в n-интересното пространство\n     * \n     * Изход:\n     * - Ако пътуването е възможно, върнете \"can be travelled\"\n     * - Ако пътуването не е възможно, върнете \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定n-有趣空间的大小，起始和结束n-交叉点坐标，以及相邻n-交叉点之间的路径，确定是否可以从起始n-交叉点到达结束n-交叉点。\n     * \n     * 参数:\n     * - n: n-有趣空间的大小\n     * - start: 起始n-交叉点坐标\n     * - end: 结束n-交叉点坐标\n     * - paths: n-有趣空间中相邻n-交叉点之间的路径\n     * \n     * 输出:\n     * - 如果可以旅行，返回 \"can be travelled\"\n     * - 如果无法旅行，返回 \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné la taille de l'espace n-teressant, les coordonnées de départ et d'arrivée de l'n-tersection, et les chemins entre les n-tersections adjacentes, déterminez s'il est possible de voyager de l'n-tersection de départ à l'n-tersection d'arrivée.\n     * \n     * Paramètres :\n     * - n : la taille de l'espace n-teressant\n     * - start : les coordonnées de l'n-tersection de départ\n     * - end : les coordonnées de l'n-tersection d'arrivée\n     * - paths : chemins entre les n-tersections adjacentes dans l'espace n-teressant\n     * \n     * Sortie :\n     * - Si le voyage est possible, retournez \"can be travelled\"\n     * - Si le voyage n'est pas possible, retournez \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben die Größe des n-teressanten Raums, die Start- und Endkoordinaten der n-tersection und die Wege zwischen benachbarten n-tersections, bestimmen Sie, ob es möglich ist, von der Start-n-tersection zur End-n-tersection zu reisen.\n     * \n     * Parameter:\n     * - n: die Größe des n-teressanten Raums\n     * - start: die Startkoordinaten der n-tersection\n     * - end: die Endkoordinaten der n-tersection\n     * - paths: Wege zwischen benachbarten n-tersections im n-teressanten Raum\n     * \n     * Ausgabe:\n     * - Wenn die Reise möglich ist, geben Sie \"can be travelled\" zurück\n     * - Wenn die Reise nicht möglich ist, geben Sie \"cannot be travelled\" zurück\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da girman sararin n-teresting, da farawa da ƙarewar haɗin n-tersection, da hanyoyi tsakanin haɗin n-tersections masu makwabtaka, tantance idan yana yiwuwa a yi tafiya daga farawa n-tersection zuwa ƙarewa n-tersection.\n     * \n     * Sigogi:\n     * - n: girman sararin n-teresting\n     * - start: farawa haɗin n-tersection\n     * - end: ƙarewa haɗin n-tersection\n     * - paths: hanyoyi tsakanin haɗin n-tersections masu makwabtaka a cikin sararin n-teresting\n     * \n     * Fitarwa:\n     * - Idan tafiya tana yiwuwa, dawo da \"can be travelled\"\n     * - Idan tafiya ba ta yiwu ba, dawo da \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * n-teresting अंतरिक्ष के आकार, प्रारंभिक और अंतिम n-tersection निर्देशांक, और निकटवर्ती n-tersections के बीच के मार्गों को देखते हुए, यह निर्धारित करें कि प्रारंभिक n-tersection से अंतिम n-tersection तक यात्रा करना संभव है या नहीं।\n     * \n     * पैरामीटर्स:\n     * - n: n-teresting अंतरिक्ष का आकार\n     * - start: प्रारंभिक n-tersection निर्देशांक\n     * - end: अंतिम n-tersection निर्देशांक\n     * - paths: n-teresting अंतरिक्ष में निकटवर्ती n-tersections के बीच के मार्ग\n     * \n     * आउटपुट:\n     * - यदि यात्रा संभव है, तो \"can be travelled\" लौटाएं\n     * - यदि यात्रा संभव नहीं है, तो \"cannot be travelled\" लौटाएं\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott az n-érdekes tér mérete, a kezdő és végső n-kereszteződés koordinátái, valamint az utak a szomszédos n-kereszteződések között, határozza meg, hogy lehetséges-e az utazás a kezdő n-kereszteződéstől a végső n-kereszteződésig.\n     * \n     * Paraméterek:\n     * - n: az n-érdekes tér mérete\n     * - start: a kezdő n-kereszteződés koordinátái\n     * - end: a végső n-kereszteződés koordinátái\n     * - paths: utak a szomszédos n-kereszteződések között az n-érdekes térben\n     * \n     * Kimenet:\n     * - Ha az utazás lehetséges, térjen vissza \"can be travelled\"\n     * - Ha az utazás nem lehetséges, térjen vissza \"cannot be travelled\"\n     */\n    public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths) "
    },
    "prompt_bertscore": {
      "sq": "0.9627496528622412",
      "hy": "0.909202676112475",
      "bn": "0.8841226110511049",
      "bg": "0.9310923399936628",
      "zh": "0.9228978436240685",
      "fr": "0.9688581329702072",
      "de": "0.9671761309036037",
      "ha": "0.964763963556316",
      "hi": "0.9719597463700669",
      "hu": "0.9289967894737448"
    },
    "canonical_solution": "    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }",
    "instruction": {
      "en": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Java կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\n请用中文为以下 Java 代码提供简洁的自然语言描述（文档注释），字数不超过500个字符。",
      "fr": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Java a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)\n    {\n\n        Map<String, List<String>> graph = new HashMap<>();\n        for (int[] path : paths) {\n            String from = path[0] + \",\" + path[1];\n            String to = path[2] + \",\" + path[3];\n            graph.putIfAbsent(from, new ArrayList<>());\n            graph.get(from).add(to);\n        }\n\n        String startNode = start[0] + \",\" + start[1];\n        String endNode = end[0] + \",\" + end[1];\n\n        Queue<String> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        queue.add(startNode);\n        visited.add(startNode);\n\n        while (!queue.isEmpty()) {\n            String node = queue.poll();\n            if (node.equals(endNode)) {\n                return \"can be travelled\";\n            }\n            if (graph.containsKey(node)) {\n                for (String neighbor : graph.get(node)) {\n                    if (!visited.contains(neighbor)) {\n                        queue.add(neighbor);\n                        visited.add(neighbor);\n                    }\n                }\n            }\n        }\n        return \"cannot be travelled\";\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9388401166363096",
      "bn": "0.9137427707317894",
      "bg": "0.8400592418438494",
      "zh": "0.8312340940144693",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9097145466044019",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 1, 2}, {1, 2, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}, {2, 1, 2, 2}}).equals(\"can be travelled\");\n        assert canTravelMaze(2, new int[]{0, 0}, new int[]{2, 2}, new int[][]{{0, 0, 0, 1}, {0, 1, 1, 1}, {1, 1, 2, 1}}).equals(\"cannot be travelled\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "canTravelMaze",
    "signature": "public static String canTravelMaze(int n, int[] start, int[] end, int[][] paths)",
    "docstring": {
      "en": "Given the size of the n-teresting space, the starting and ending n-tersection coordinates, and the paths between adjacent n-tersections, determine if it is possible to travel from the starting n-tersection to the ending n-tersection.\n\nParameters:\n- n: the size of the n-teresting space\n- start: the starting n-tersection coordinates\n- end: the ending n-tersection coordinates\n- paths: paths between adjacent n-tersections in the n-teresting space\n\nOutput:\n- If travel is possible, return \"can be travelled\"\n- If travel is not possible, return \"cannot be travelled\"",
      "sq": "Duke pasur parasysh madhësinë e hapësirës n-teresting, koordinatat e fillimit dhe mbarimit të n-tersections, dhe rrugët midis n-tersections ngjitur, përcaktoni nëse është e mundur të udhëtohet nga n-tersection fillestar në n-tersection përfundimtar.\n\nParametrat:\n- n: madhësia e hapësirës n-teresting\n- start: koordinatat e n-tersection fillestar\n- end: koordinatat e n-tersection përfundimtar\n- paths: rrugët midis n-tersections ngjitur në hapësirën n-teresting\n\nDalja:\n- Nëse udhëtimi është i mundur, kthe \"mund të udhëtohet\"\n- Nëse udhëtimi nuk është i mundur, kthe \"nuk mund të udhëtohet\"",
      "hy": "Տրված n-հետաքրքիր տարածքի չափը, մեկնարկային և վերջնական n-հատման կոորդինատները և հարակից n-հատումների միջև ուղիները, որոշեք, արդյոք հնարավոր է ճանապարհորդել մեկնարկային n-հատումից դեպի վերջնական n-հատում:\n\nՊարամետրեր:\n- n: n-հետաքրքիր տարածքի չափը\n- start: մեկնարկային n-հատման կոորդինատները\n- end: վերջնական n-հատման կոորդինատները\n- paths: n-հետաքրքիր տարածքում հարակից n-հատումների միջև ուղիներ\n\nԵլք:\n- Եթե ճանապարհորդությունը հնարավոր է, վերադարձնել \"կարելի է ճանապարհորդել\"\n- Եթե ճանապարհորդությունը հնարավոր չէ, վերադարձնել \"չի կարելի ճանապարհորդել\"",
      "bn": "n-আকর্ষণীয় স্থানের আকার, শুরুর এবং শেষের n-সংযোগের স্থানাঙ্ক, এবং সংলগ্ন n-সংযোগগুলির মধ্যে পথগুলি দেওয়া হয়েছে, তাহলে শুরুর n-সংযোগ থেকে শেষের n-সংযোগ পর্যন্ত ভ্রমণ করা সম্ভব কিনা তা নির্ধারণ করুন।\n\nপ্যারামিটারসমূহ:\n- n: n-আকর্ষণীয় স্থানের আকার\n- start: শুরুর n-সংযোগের স্থানাঙ্ক\n- end: শেষের n-সংযোগের স্থানাঙ্ক\n- paths: n-আকর্ষণীয় স্থানে সংলগ্ন n-সংযোগগুলির মধ্যে পথগুলি\n\nআউটপুট:\n- যদি ভ্রমণ সম্ভব হয়, তাহলে \"can be travelled\" ফেরত দিন\n- যদি ভ্রমণ সম্ভব না হয়, তাহলে \"cannot be travelled\" ফেরত দিন",
      "bg": "Като се има предвид размерът на n-интересното пространство, началните и крайните координати на n-терсекциите, както и пътищата между съседните n-терсекции, определете дали е възможно да се пътува от началната n-терсекция до крайната n-терсекция.\n\nПараметри:\n- n: размерът на n-интересното пространство\n- start: началните координати на n-терсекцията\n- end: крайните координати на n-терсекцията\n- paths: пътища между съседните n-терсекции в n-интересното пространство\n\nИзход:\n- Ако пътуването е възможно, върнете \"може да се пътува\"\n- Ако пътуването не е възможно, върнете \"не може да се пътува\"",
      "zh": "给定n趣空间的大小，起始和结束n交点坐标，以及相邻n交点之间的路径，确定是否可以从起始n交点到达结束n交点。\n\n参数：\n- n: n趣空间的大小\n- start: 起始n交点坐标\n- end: 结束n交点坐标\n- paths: n趣空间中相邻n交点之间的路径\n\n输出：\n- 如果可以旅行，返回“can be travelled”\n- 如果无法旅行，返回“cannot be travelled”",
      "fr": "Étant donné la taille de l'espace n-téressant, les coordonnées de départ et d'arrivée de l'n-tersection, et les chemins entre les n-tersections adjacentes, déterminez s'il est possible de voyager de l'n-tersection de départ à l'n-tersection d'arrivée.\n\nParamètres :\n- n : la taille de l'espace n-téressant\n- start : les coordonnées de l'n-tersection de départ\n- end : les coordonnées de l'n-tersection d'arrivée\n- paths : chemins entre les n-tersections adjacentes dans l'espace n-téressant\n\nSortie :\n- Si le voyage est possible, retournez \"can be travelled\"\n- Si le voyage n'est pas possible, retournez \"cannot be travelled\"",
      "de": "Angesichts der Größe des n-teressanten Raums, der Start- und Endkoordinaten der n-tersektion sowie der Pfade zwischen benachbarten n-tersektionen bestimmen, ob es möglich ist, von der Start-n-tersektion zur End-n-tersektion zu reisen.\n\nParameter:\n- n: die Größe des n-teressanten Raums\n- start: die Startkoordinaten der n-tersektion\n- end: die Endkoordinaten der n-tersektion\n- paths: Pfade zwischen benachbarten n-tersektionen im n-teressanten Raum\n\nAusgabe:\n- Wenn eine Reise möglich ist, gib \"can be travelled\" zurück\n- Wenn eine Reise nicht möglich ist, gib \"cannot be travelled\" zurück",
      "ha": "An ba da girman sararin n-teresting, da farawa da ƙarewar n-tersection da kuma hanyoyin da ke tsakanin n-tersections masu makwabtaka, tantance ko yana yiwuwa a yi tafiya daga farawa n-tersection zuwa ƙarewar n-tersection.\n\nSigogi:\n- n: girman sararin n-teresting\n- start: farawa n-tersection da ke da tsarawa\n- end: ƙarewar n-tersection da ke da tsarawa\n- paths: hanyoyi tsakanin n-tersections masu makwabtaka a cikin sararin n-teresting\n\nFitarwa:\n- Idan tafiya tana yiwuwa, dawo da \"ana iya tafiya\"\n- Idan tafiya ba ta yiwu ba, dawo da \"ba za a iya tafiya ba\"",
      "hi": "n-teresting space के आकार, प्रारंभिक और अंतिम n-tersection निर्देशांक, और आसन्न n-tersections के बीच के रास्तों को देखते हुए, यह निर्धारित करें कि क्या प्रारंभिक n-tersection से अंतिम n-tersection तक यात्रा करना संभव है।\n\nपैरामीटर्स:\n- n: n-teresting space का आकार\n- start: प्रारंभिक n-tersection निर्देशांक\n- end: अंतिम n-tersection निर्देशांक\n- paths: n-teresting space में आसन्न n-tersections के बीच के रास्ते\n\nआउटपुट:\n- यदि यात्रा संभव है, तो \"can be travelled\" लौटाएं\n- यदि यात्रा संभव नहीं है, तो \"cannot be travelled\" लौटाएं",
      "hu": "Az n-teresting tér mérete, a kezdő és végső n-tersection koordináták, valamint a szomszédos n-tersections közötti utak alapján határozza meg, hogy lehetséges-e az utazás a kezdő n-tersection-től a végső n-tersection-ig.\n\nParaméterek:\n- n: az n-teresting tér mérete\n- start: a kezdő n-tersection koordináták\n- end: a végső n-tersection koordináták\n- paths: utak a szomszédos n-tersections között az n-teresting térben\n\nKimenet:\n- Ha az utazás lehetséges, adja vissza, hogy \"lehetséges az utazás\"\n- Ha az utazás nem lehetséges, adja vissza, hogy \"nem lehetséges az utazás\""
    },
    "docstring_bertscore": {
      "sq": "0.9631165231760126",
      "hy": "0.881931320687528",
      "bn": "0.8363075112068624",
      "bg": "0.889184706311779",
      "zh": "0.8699451689743587",
      "fr": "0.9687232629414845",
      "de": "0.953269024775446",
      "ha": "0.9217084449024315",
      "hi": "0.9400229605553724",
      "hu": "0.9202725458779304"
    }
  },
  {
    "task_id": "Java/11",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * The approximate value is calculated by counting the number of common letters\n     * and dividing it by the sum of the lengths of the two words.\n     *\n     * @param word1 The first word.\n     * @param word2 The second word.\n     * @return The approximate value as a reduced fraction.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Vlera e përafërt llogaritet duke numëruar numrin e shkronjave të përbashkëta\n     * dhe duke e pjesëtuar atë me shumën e gjatësive të dy fjalëve.\n     *\n     * @param word1 Fjala e parë.\n     * @param word2 Fjala e dytë.\n     * @return Vlera e përafërt si një thyesë e reduktuar.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Մոտավոր արժեքը հաշվարկվում է ընդհանուր տառերի քանակը հաշվելով\n     * և այն բաժանելով երկու բառերի երկարությունների գումարի վրա:\n     *\n     * @param word1 Առաջին բառը:\n     * @param word2 Երկրորդ բառը:\n     * @return Մոտավոր արժեքը որպես կրճատված կոտորակ:\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * আনুমানিক মানটি সাধারণ অক্ষরগুলির সংখ্যা গণনা করে এবং এটি দুটি শব্দের দৈর্ঘ্যের\n     * যোগফল দ্বারা ভাগ করে গণনা করা হয়।\n     *\n     * @param word1 প্রথম শব্দ।\n     * @param word2 দ্বিতীয় শব্দ।\n     * @return আনুমানিক মান একটি হ্রাসপ্রাপ্ত ভগ্নাংশ হিসাবে।\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Приблизителната стойност се изчислява чрез преброяване на броя на общите букви\n     * и разделянето му на сбора от дължините на двете думи.\n     *\n     * @param word1 Първата дума.\n     * @param word2 Втората дума.\n     * @return Приблизителната стойност като съкратена дроб.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 通过计算公共字母的数量并将其除以两个单词长度的总和来计算近似值。\n     *\n     * @param word1 第一个单词。\n     * @param word2 第二个单词。\n     * @return 作为约分的近似值。\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * La valeur approximative est calculée en comptant le nombre de lettres communes\n     * et en le divisant par la somme des longueurs des deux mots.\n     *\n     * @param word1 Le premier mot.\n     * @param word2 Le deuxième mot.\n     * @return La valeur approximative sous forme de fraction réduite.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Der ungefähre Wert wird berechnet, indem die Anzahl der gemeinsamen Buchstaben\n     * gezählt und durch die Summe der Längen der beiden Wörter geteilt wird.\n     *\n     * @param word1 Das erste Wort.\n     * @param word2 Das zweite Wort.\n     * @return Der ungefähre Wert als gekürzter Bruch.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An kimanta ƙimar ta hanyar ƙididdige yawan haruffa masu kama\n     * kuma a raba shi da jimillar tsawon kalmomin biyu.\n     *\n     * @param word1 Kalma ta farko.\n     * @param word2 Kalma ta biyu.\n     * @return Kimanin ƙimar a matsayin ƙananan kason.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * अनुमानित मान की गणना सामान्य अक्षरों की संख्या गिनकर\n     * और इसे दोनों शब्दों की लंबाई के योग से विभाजित करके की जाती है।\n     *\n     * @param word1 पहला शब्द।\n     * @param word2 दूसरा शब्द।\n     * @return अनुमानित मान एक घटित भिन्न के रूप में।\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Az értéket úgy közelítjük, hogy megszámoljuk a közös betűk számát\n     * és elosztjuk a két szó hosszának összegével.\n     *\n     * @param word1 Az első szó.\n     * @param word2 A második szó.\n     * @return A közelítő érték egyszerűsített tört formájában.\n     *\n     * >>> appx(\"CAR\", \"CART\")\n     * \"appx(CAR, CART) = 6/7\"\n     * >>> appx(\"TURKEY\", \"CHICKEN\")\n     * \"appx(TURKEY, CHICKEN) = 4/13\"\n     * >>> appx(\"MONEY\", \"POVERTY\")\n     * \"appx(MONEY, POVERTY) = 1/3\"\n     * >>> appx(\"ROUGH\", \"PESKY\")\n     * \"appx(ROUGH, PESKY) = 0\"\n     * >>> appx(\"A\", \"A\")\n     * \"appx(A, A) = 1\"\n     */\n    public static String appx(String word1, String word2) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9921419834958788",
      "bn": "0.9891813976665538",
      "bg": "1",
      "zh": "0.9829173899702376",
      "fr": "0.990367221041332",
      "de": "0.9959330429483106",
      "ha": "0.9703740800382654",
      "hi": "0.9779710962217067",
      "hu": "0.9840013159595449"
    },
    "canonical_solution": "    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }",
    "instruction": {
      "en": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nՏվյալ Java կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\n将以下 Java 代码的功能简洁地用中文描述（文档字符串），字数不超过 500 个字符。",
      "fr": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static String appx(String word1, String word2)\n    {\n     \n        int common = 0;\n        for (char c : word1.toCharArray()) {\n            if (word2.indexOf(c) != -1) {\n                common++;\n            }\n        }\n        int total = word1.length() + word2.length();\n        return \"appx(\" + word1 + \", \" + word2 + \") = \" + common + \"/\" + total;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.8847604132046079",
      "bn": "0.8832736648025618",
      "bg": "0.8400592418438494",
      "zh": "0.8335705831865827",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9407980163021705"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert appx(\"DOG\", \"CAT\").equals(\"appx(DOG, CAT) = 0/6\");\n        assert appx(\"HELLO\", \"WORLD\").equals(\"appx(HELLO, WORLD) = 3/10\");\n        assert appx(\"JAVA\", \"PYTHON\").equals(\"appx(JAVA, PYTHON) = 0/10\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "appx",
    "signature": "public static String appx(String word1, String word2)",
    "docstring": {
      "en": "The approximate value is calculated by counting the number of common letters\nand dividing it by the sum of the lengths of the two words.\n\n@param word1 The first word.\n@param word2 The second word.\n@return The approximate value as a reduced fraction.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "sq": "Vlera e përafërt llogaritet duke numëruar numrin e shkronjave të përbashkëta dhe duke e pjesëtuar atë me shumën e gjatësive të dy fjalëve.\n\n@param word1 Fjala e parë.\n@param word2 Fjala e dytë.\n@return Vlera e përafërt si një thyesë e reduktuar.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hy": "Մոտավոր արժեքը հաշվարկվում է ընդհանուր տառերի քանակը հաշվելով\nև այն բաժանելով երկու բառերի երկարությունների գումարին։\n\n@param word1 Առաջին բառը։\n@param word2 Երկրորդ բառը։\n@return Մոտավոր արժեքը որպես կրճատված կոտորակ։\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "bn": "আনুমানিক মানটি সাধারণ অক্ষরের সংখ্যা গণনা করে এবং এটি দুটি শব্দের দৈর্ঘ্যের যোগফল দ্বারা ভাগ করে গণনা করা হয়।\n\n@param word1 প্রথম শব্দ।\n@param word2 দ্বিতীয় শব্দ।\n@return আনুমানিক মান একটি হ্রাসকৃত ভগ্নাংশ হিসেবে।\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "bg": "Приблизителната стойност се изчислява чрез броене на броя на общите букви и разделянето му на сумата от дължините на двете думи.\n\n@param word1 Първата дума.\n@param word2 Втората дума.\n@return Приблизителната стойност като съкратена дроб.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "zh": "通过计算共同字母的数量并将其除以两个单词长度之和来计算近似值。\n\n@param word1 第一个单词。\n@param word2 第二个单词。\n@return 作为约分分数的近似值。\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "fr": "La valeur approximative est calculée en comptant le nombre de lettres communes et en le divisant par la somme des longueurs des deux mots.\n\n@param word1 Le premier mot.\n@param word2 Le deuxième mot.\n@return La valeur approximative sous forme de fraction réduite.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "de": "Der ungefähre Wert wird berechnet, indem die Anzahl der gemeinsamen Buchstaben gezählt und durch die Summe der Längen der beiden Wörter geteilt wird.\n\n@param word1 Das erste Wort.\n@param word2 Das zweite Wort.\n@return Der ungefähre Wert als gekürzter Bruch.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "ha": "An kimanta darajar ta hanyar ƙididdige adadin haruffa masu kama da raba shi da jumlar tsawon kalmomin biyu.\n\n@param word1 Kalma ta farko.\n@param word2 Kalma ta biyu.\n@return Kimanta darajar a matsayin ƙananan rabon.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hi": "अनुमानित मान की गणना सामान्य अक्षरों की संख्या को गिनकर और उसे दो शब्दों की लंबाई के योग से विभाजित करके की जाती है।\n\n@param word1 पहला शब्द।\n@param word2 दूसरा शब्द।\n@return घटे हुए भिन्न के रूप में अनुमानित मान।\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\"",
      "hu": "Az hozzávetőleges értéket úgy számítjuk ki, hogy megszámoljuk a közös betűk számát, és elosztjuk a két szó hosszának összegével.\n\n@param word1 Az első szó.\n@param word2 A második szó.\n@return Az hozzávetőleges érték egyszerűsített tört formájában.\n\n>>> appx(\"CAR\", \"CART\")\n\"appx(CAR, CART) = 6/7\"\n>>> appx(\"TURKEY\", \"CHICKEN\")\n\"appx(TURKEY, CHICKEN) = 4/13\"\n>>> appx(\"MONEY\", \"POVERTY\")\n\"appx(MONEY, POVERTY) = 1/3\"\n>>> appx(\"ROUGH\", \"PESKY\")\n\"appx(ROUGH, PESKY) = 0\"\n>>> appx(\"A\", \"A\")\n\"appx(A, A) = 1\""
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9779371304265498",
      "bn": "0.9900460357151987",
      "bg": "0.999999801369619",
      "zh": "0.965504258986433",
      "fr": "0.999999801369619",
      "de": "0.9960283855312074",
      "ha": "0.9851430433897335",
      "hi": "0.9849408376618399",
      "hu": "0.9853559751582028"
    }
  },
  {
    "task_id": "Java/12",
    "prompt": {
      "en": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n     * \n     * Example:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "sq": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Duke pasur një datë në formatin \"MM dd yyyy\", kthe ditën e javës për datën.\n     * \n     * Shembull:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "hy": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Տրված ամսաթիվը \"MM dd yyyy\" ձևաչափով, վերադարձնել ամսաթվի շաբաթվա օրը։\n     * \n     * Օրինակ:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "bn": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * \"MM dd yyyy\" বিন্যাসে একটি তারিখ দেওয়া হলে, তারিখের সপ্তাহের দিনটি ফেরত দিন।\n     * \n     * উদাহরণ:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "bg": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Дадена е дата във формат \"MM dd yyyy\", върнете деня от седмицата на датата.\n     * \n     * Пример:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "zh": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * 给定一个格式为 \"MM dd yyyy\" 的日期，返回该日期的星期几。\n     * \n     * 示例:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "fr": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Étant donné une date au format \"MM dd yyyy\", retourne le jour de la semaine de la date.\n     * \n     * Exemple :\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "de": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Gegeben ein Datum im Format \"MM dd yyyy\", gib den Wochentag des Datums zurück.\n     * \n     * Beispiel:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "ha": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * An ba da wata rana a cikin tsarin \"MM dd yyyy\", dawo da ranar mako na ranar.\n     * \n     * Misali:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "hi": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * दिए गए दिनांक को \"MM dd yyyy\" प्रारूप में, दिनांक का सप्ताह का दिन लौटाएं।\n     * \n     * उदाहरण:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) ",
      "hu": "import java.util.*;\nimport java.text.SimpleDateFormat;\nimport java.text.ParseException;\n\nclass Solution {\n    /**\n     * Adott egy dátum \"MM dd yyyy\" formátumban, adja vissza a dátum napját.\n     * \n     * Példa:\n     * >>> convertDatesToWeekdays(\"11 15 1997\")\n     * \"November 15, 1997 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"01 01 2000\")\n     * \"January 1, 2000 is a Saturday\"\n     * >>> convertDatesToWeekdays(\"07 04 1998\")\n     * \"July 4, 1998 is a Saturday\"\n     */\n    public static String convertDatesToWeekdays(String date) "
    },
    "prompt_bertscore": {
      "sq": "0.9821890123629826",
      "hy": "0.9821890123629826",
      "bn": "0.9753283190020375",
      "bg": "0.9821890123629826",
      "zh": "0.9809465793296094",
      "fr": "0.9824462387064228",
      "de": "1",
      "ha": "0.9837699115656393",
      "hi": "0.9682920363842576",
      "hu": "0.9869039017176078"
    },
    "canonical_solution": "    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }",
    "instruction": {
      "en": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Java cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static String convertDatesToWeekdays(String date)\n    {\n        // Define the input and output date formats\n        SimpleDateFormat inputFormat = new SimpleDateFormat(\"MM dd yyyy\");\n        SimpleDateFormat outputDateFormat = new SimpleDateFormat(\"MMMM d, yyyy\");\n        SimpleDateFormat outputDayFormat = new SimpleDateFormat(\"EEEE\");\n\n        try {\n            // Parse the input date\n            Date dateObj = inputFormat.parse(date);\n\n            // Format the date to the specified output format\n            String formattedDate = outputDateFormat.format(dateObj);\n            String dayOfWeek = outputDayFormat.format(dateObj);\n\n            // Return the formatted string\n            // System.out.println(formattedDate + \" is a \" + dayOfWeek);\n            return formattedDate + \" is a \" + dayOfWeek;\n        } catch (ParseException e) {\n            // Handle the case where the input date format is invalid\n            e.printStackTrace();\n            return \"Invalid date format\";\n        }\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386897534378662",
      "hy": "0.9242475370632005",
      "bn": "0.8832736648025618",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9353706397707733",
      "hi": "0.8876048002610275",
      "hu": "0.9407980163021705"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        // Test the function with different test cases\n        assert convertDatesToWeekdays(\"02 05 2024\").equals(\"February 5, 2024 is a Monday\");\n        assert convertDatesToWeekdays(\"01 12 2023\").equals(\"January 12, 2023 is a Thursday\");\n        assert convertDatesToWeekdays(\"09 14 2013\").equals(\"September 14, 2013 is a Saturday\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "convertDatesToWeekdays",
    "signature": "public static String convertDatesToWeekdays(String date)",
    "docstring": {
      "en": "Given a date in the format \"MM dd yyyy\", return the weekday of the date.\n\nExample:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "sq": "Dhënë një datë në formatin \"MM dd yyyy\", kthe ditën e javës për atë datë.\n\nShembull:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 është një e Shtunë\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 është një e Shtunë\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 është një e Shtunë\"",
      "hy": "Տրված ամսաթիվը \"MM dd yyyy\" ձևաչափով, վերադարձնել ամսաթվի շաբաթվա օրը:\n\nՕրինակ:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "bn": "প্রদত্ত তারিখ \"MM dd yyyy\" বিন্যাসে থাকলে, তারিখের সপ্তাহের দিনটি ফেরত দিন।\n\nউদাহরণ:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "bg": "Дадена е дата във формат \"MM dd yyyy\", върнете деня от седмицата на датата.\n\nПример:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 е събота\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 е събота\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 е събота\"",
      "zh": "给定格式为“MM dd yyyy”的日期，返回该日期的星期几。\n\n例子：\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "fr": "Étant donné une date au format \"MM dd yyyy\", retourner le jour de la semaine de la date.\n\nExemple :\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "de": "Gegeben ein Datum im Format \"MM dd yyyy\", gib den Wochentag des Datums zurück.\n\nBeispiel:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "ha": "An ba da wata rana a cikin tsarin \"MM dd yyyy\", mayar da ranar mako na ranar.\n\nMisali:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 rana ce ta Asabar\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 rana ce ta Asabar\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 rana ce ta Asabar\"",
      "hi": "दिए गए दिनांक को \"MM dd yyyy\" प्रारूप में लेते हुए, उस दिनांक का सप्ताह का दिन लौटाएं।\n\nउदाहरण:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\"",
      "hu": "Adott egy dátum \"MM dd yyyy\" formátumban, adja vissza a dátum hét napját.\n\nPélda:\n>>> convertDatesToWeekdays(\"11 15 1997\")\n\"November 15, 1997 is a Saturday\"\n>>> convertDatesToWeekdays(\"01 01 2000\")\n\"January 1, 2000 is a Saturday\"\n>>> convertDatesToWeekdays(\"07 04 1998\")\n\"July 4, 1998 is a Saturday\""
    },
    "docstring_bertscore": {
      "sq": "0.9746347017114637",
      "hy": "0.9604119719078416",
      "bn": "0.972893905052074",
      "bg": "0.9678913989057103",
      "zh": "0.972893905052074",
      "fr": "0.974840681416597",
      "de": "1",
      "ha": "1",
      "hi": "0.9637173800786432",
      "hu": "0.9706094570397917"
    }
  },
  {
    "task_id": "Java/13",
    "prompt": {
      "en": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Given an array of integers nums and an integer target,\n     * find two numbers such that they add up to target and return their indices.\n     * You may assume that each input would have exactly one solution,\n     * and you may not use the same element twice.\n     * You can return the answer in any order.\n     *\n     * Example 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n     *\n     * Example 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Example 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "sq": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Duke pasur një varg të numrave të plotë nums dhe një numër të plotë target,\n     * gjeni dy numra të tillë që ata së bashku të japin target dhe ktheni indeksat e tyre.\n     * Ju mund të supozoni se secili input do të ketë saktësisht një zgjidhje,\n     * dhe nuk mund të përdorni të njëjtin element dy herë.\n     * Ju mund ta ktheni përgjigjen në çdo renditje.\n     *\n     * Shembull 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Shpjegim: Sepse nums[0] + nums[1] == 9, ne kthejmë [0, 1].\n     *\n     * Shembull 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Shembull 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "hy": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված nums և ամբողջ թիվ target,\n     * գտնել երկու թիվ, որոնք գումարվում են target-ի և վերադարձնել նրանց ինդեքսները։\n     * Կարող եք ենթադրել, որ յուրաքանչյուր մուտք կունենա հենց մեկ լուծում,\n     * և դուք չեք կարող օգտագործել նույն տարրը երկու անգամ։\n     * Կարող եք վերադարձնել պատասխանը ցանկացած կարգով։\n     *\n     * Օրինակ 1:\n     * Մուտք: nums = [2,7,11,15], target = 9\n     * Ելք: [0,1]\n     * Բացատրություն: Քանի որ nums[0] + nums[1] == 9, մենք վերադարձնում ենք [0, 1]։\n     *\n     * Օրինակ 2:\n     * Մուտք: nums = [3,2,4], target = 6\n     * Ելք: [1,2]\n     *\n     * Օրինակ 3:\n     * Մուտք: nums = [3,3], target = 6\n     * Ելք: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "bn": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * একটি পূর্ণসংখ্যার অ্যারে nums এবং একটি পূর্ণসংখ্যা target দেওয়া হলে,\n     * দুটি সংখ্যা খুঁজে বের করুন যাদের যোগফল target হয় এবং তাদের সূচকগুলি ফেরত দিন।\n     * আপনি ধরে নিতে পারেন যে প্রতিটি ইনপুটের ঠিক একটি সমাধান থাকবে,\n     * এবং আপনি একই উপাদান দুবার ব্যবহার করতে পারবেন না।\n     * আপনি যেকোনো ক্রমে উত্তর ফেরত দিতে পারেন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: nums = [2,7,11,15], target = 9\n     * আউটপুট: [0,1]\n     * ব্যাখ্যা: কারণ nums[0] + nums[1] == 9, আমরা [0, 1] ফেরত দিই।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: nums = [3,2,4], target = 6\n     * আউটপুট: [1,2]\n     *\n     * উদাহরণ 3:\n     * ইনপুট: nums = [3,3], target = 6\n     * আউটপুট: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "bg": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Даден е масив от цели числа nums и цяло число target,\n     * намерете две числа, така че тяхната сума да е равна на target и върнете техните индекси.\n     * Можете да приемете, че всяко входно множество ще има точно едно решение,\n     * и не можете да използвате един и същ елемент два пъти.\n     * Можете да върнете отговора в произволен ред.\n     *\n     * Пример 1:\n     * Вход: nums = [2,7,11,15], target = 9\n     * Изход: [0,1]\n     * Обяснение: Тъй като nums[0] + nums[1] == 9, връщаме [0, 1].\n     *\n     * Пример 2:\n     * Вход: nums = [3,2,4], target = 6\n     * Изход: [1,2]\n     *\n     * Пример 3:\n     * Вход: nums = [3,3], target = 6\n     * Изход: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "zh": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * 给定一个整数数组 nums 和一个整数 target，\n     * 找到两个数使得它们的和等于 target，并返回它们的索引。\n     * 你可以假设每种输入只会对应一个解决方案，\n     * 并且你不能重复使用相同的元素。\n     * 你可以以任意顺序返回答案。\n     *\n     * 示例 1:\n     * 输入: nums = [2,7,11,15], target = 9\n     * 输出: [0,1]\n     * 解释: 因为 nums[0] + nums[1] == 9，返回 [0, 1]。\n     *\n     * 示例 2:\n     * 输入: nums = [3,2,4], target = 6\n     * 输出: [1,2]\n     *\n     * 示例 3:\n     * 输入: nums = [3,3], target = 6\n     * 输出: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "fr": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Étant donné un tableau d'entiers nums et un entier target,\n     * trouver deux nombres tels qu'ils s'additionnent pour donner target et retourner leurs indices.\n     * Vous pouvez supposer que chaque entrée a exactement une solution,\n     * et vous ne pouvez pas utiliser le même élément deux fois.\n     * Vous pouvez retourner la réponse dans n'importe quel ordre.\n     *\n     * Exemple 1 :\n     * Entrée : nums = [2,7,11,15], target = 9\n     * Sortie : [0,1]\n     * Explication : Parce que nums[0] + nums[1] == 9, nous retournons [0, 1].\n     *\n     * Exemple 2 :\n     * Entrée : nums = [3,2,4], target = 6\n     * Sortie : [1,2]\n     *\n     * Exemple 3 :\n     * Entrée : nums = [3,3], target = 6\n     * Sortie : [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "de": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Gegeben ein Array von ganzen Zahlen nums und eine ganze Zahl target,\n     * finde zwei Zahlen, so dass sie zusammen target ergeben und gib ihre Indizes zurück.\n     * Du kannst davon ausgehen, dass jede Eingabe genau eine Lösung hat,\n     * und du darfst dasselbe Element nicht zweimal verwenden.\n     * Du kannst die Antwort in beliebiger Reihenfolge zurückgeben.\n     *\n     * Beispiel 1:\n     * Input: nums = [2,7,11,15], target = 9\n     * Output: [0,1]\n     * Erklärung: Da nums[0] + nums[1] == 9, geben wir [0, 1] zurück.\n     *\n     * Beispiel 2:\n     * Input: nums = [3,2,4], target = 6\n     * Output: [1,2]\n     *\n     * Beispiel 3:\n     * Input: nums = [3,3], target = 6\n     * Output: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "ha": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * An ba da jerin lambobi nums da wani lamba target,\n     * nemo lambobi biyu da idan aka hada su za su yi daidai da target kuma a dawo da alamun su.\n     * Za ka iya dauka cewa kowanne shigarwa zai kasance daidai da daya mafita,\n     * kuma ba za ka iya amfani da abu daya sau biyu ba.\n     * Za ka iya dawo da amsar a kowanne tsari.\n     *\n     * Misali 1:\n     * Shigarwa: nums = [2,7,11,15], target = 9\n     * Fitarwa: [0,1]\n     * Bayani: Domin nums[0] + nums[1] == 9, mun dawo da [0, 1].\n     *\n     * Misali 2:\n     * Shigarwa: nums = [3,2,4], target = 6\n     * Fitarwa: [1,2]\n     *\n     * Misali 3:\n     * Shigarwa: nums = [3,3], target = 6\n     * Fitarwa: [0,1]\n     */",
      "hi": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * दिए गए पूर्णांकों के एक array nums और एक पूर्णांक target के लिए,\n     * दो संख्याएँ खोजें ताकि वे target के बराबर हों और उनके सूचकांक लौटाएँ।\n     * आप मान सकते हैं कि प्रत्येक इनपुट में ठीक एक समाधान होगा,\n     * और आप एक ही तत्व का दो बार उपयोग नहीं कर सकते।\n     * आप उत्तर को किसी भी क्रम में लौटा सकते हैं।\n     *\n     * उदाहरण 1:\n     * इनपुट: nums = [2,7,11,15], target = 9\n     * आउटपुट: [0,1]\n     * व्याख्या: क्योंकि nums[0] + nums[1] == 9, हम [0, 1] लौटाते हैं।\n     *\n     * उदाहरण 2:\n     * इनपुट: nums = [3,2,4], target = 6\n     * आउटपुट: [1,2]\n     *\n     * उदाहरण 3:\n     * इनपुट: nums = [3,3], target = 6\n     * आउटपुट: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) ",
      "hu": "import java.util.Map;\nimport java.util.HashMap;\nimport java.util.Arrays;\n\nclass Solution {\n    /**\n     * Adott egy egész számokat tartalmazó tömb nums és egy egész szám target,\n     * találjon két számot úgy, hogy összegük a target legyen, és adja vissza az indexeiket.\n     * Feltételezheti, hogy minden bemenetnek pontosan egy megoldása van,\n     * és nem használhatja ugyanazt az elemet kétszer.\n     * A választ bármilyen sorrendben visszaadhatja.\n     *\n     * 1. példa:\n     * Bemenet: nums = [2,7,11,15], target = 9\n     * Kimenet: [0,1]\n     * Magyarázat: Mivel nums[0] + nums[1] == 9, visszaadjuk [0, 1].\n     *\n     * 2. példa:\n     * Bemenet: nums = [3,2,4], target = 6\n     * Kimenet: [1,2]\n     *\n     * 3. példa:\n     * Bemenet: nums = [3,3], target = 6\n     * Kimenet: [0,1]\n     */\n  public int[] twoSum(int[] nums, int target) "
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.9903916525781994",
      "zh": "0.9855071328781704",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.8989120333318196",
      "hi": "0.9861663871128252",
      "hu": "0.9843501109086422"
    },
    "canonical_solution": "  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }",
    "instruction": {
      "en": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nՏվեք Java կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերեն՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int[] twoSum(int[] nums, int target)\n  {\n\n    Map<Integer, Integer> map = new HashMap<>();\n    for (int i = 0; i < nums.length; i++) {\n      int complement = target - nums[i];\n      if (map.containsKey(complement)) {\n        return new int[] { map.get(complement), i };\n      }\n      map.put(nums[i], i);\n    }\n    throw new IllegalArgumentException(\"No two sum solution\");\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9465259206000736",
      "bn": "0.8723249595695377",
      "bg": "0.8376140553201085",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 3, 7, 9, 2 }, 11),\n      new int[] { 3, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 1, 5, 3, 7, 8 }, 9),\n      new int[] { 0, 4 }\n    );\n    assert Arrays.equals(\n      solution.twoSum(new int[] { 10, 20, 30, 40, 50 }, 90),\n      new int[] { 3, 4 }\n    );\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "twoSum",
    "signature": "public int[] twoSum(int[] nums, int target)",
    "docstring": {
      "en": "Given an array of integers nums and an integer target,\nfind two numbers such that they add up to target and return their indices.\nYou may assume that each input would have exactly one solution,\nand you may not use the same element twice.\nYou can return the answer in any order.\n\nExample 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n\nExample 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExample 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "sq": "Duke pasur një varg numrash të plotë nums dhe një numër të plotë target, gjeni dy numra të tillë që ata të shtohen deri në target dhe ktheni indeksat e tyre. Ju mund të supozoni se secili input do të ketë saktësisht një zgjidhje, dhe nuk mund të përdorni të njëjtin element dy herë. Ju mund ta ktheni përgjigjen në çdo renditje.\n\nShembulli 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nShpjegim: Sepse nums[0] + nums[1] == 9, ne kthejmë [0, 1].\n\nShembulli 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nShembulli 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "hy": "Տրված է ամբողջ թվերի զանգված nums և ամբողջ թիվ target, \nգտեք երկու թիվ, որոնք գումարվում են՝ կազմելով target և վերադարձեք դրանց ինդեքսները։ \nԿարող եք ենթադրել, որ յուրաքանչյուր մուտք կունենա ճիշտ մեկ լուծում, \nև չեք կարող օգտագործել նույն տարրը երկու անգամ։ \nԿարող եք վերադարձնել պատասխանը ցանկացած կարգով։\n\nՕրինակ 1:\nՄուտքագրում: nums = [2,7,11,15], target = 9\nԵլք: [0,1]\nԲացատրություն: Քանի որ nums[0] + nums[1] == 9, մենք վերադարձնում ենք [0, 1]։\n\nՕրինակ 2:\nՄուտքագրում: nums = [3,2,4], target = 6\nԵլք: [1,2]\n\nՕրինակ 3:\nՄուտքագրում: nums = [3,3], target = 6\nԵլք: [0,1]",
      "bn": "একটি পূর্ণসংখ্যার অ্যারের nums এবং একটি পূর্ণসংখ্যা target দেওয়া আছে, \nএমন দুটি সংখ্যা খুঁজুন যেগুলি একত্রে যোগ করলে target হয় এবং তাদের সূচকগুলি ফেরত দিন। \nআপনি ধরে নিতে পারেন যে প্রতিটি ইনপুটের ঠিক একটি সমাধান থাকবে, \nএবং আপনি একই উপাদান দুবার ব্যবহার করতে পারবেন না। \nআপনি যেকোনো ক্রমে উত্তর ফেরত দিতে পারেন।\n\nউদাহরণ ১:\nইনপুট: nums = [2,7,11,15], target = 9\nআউটপুট: [0,1]\nব্যাখ্যা: কারণ nums[0] + nums[1] == 9, আমরা [0, 1] ফেরত দিই।\n\nউদাহরণ ২:\nইনপুট: nums = [3,2,4], target = 6\nআউটপুট: [1,2]\n\nউদাহরণ ৩:\nইনপুট: nums = [3,3], target = 6\nআউটপুট: [0,1]",
      "bg": "Даден е масив от цели числа nums и цяло число target, намерете две числа, така че тяхната сума да е равна на target и върнете техните индекси. Може да приемете, че всяко входно множество ще има точно едно решение и не може да използвате един и същ елемент два пъти. Можете да върнете отговора в произволен ред.\n\nПример 1:\nВход: nums = [2,7,11,15], target = 9\nИзход: [0,1]\nОбяснение: Тъй като nums[0] + nums[1] == 9, връщаме [0, 1].\n\nПример 2:\nВход: nums = [3,2,4], target = 6\nИзход: [1,2]\n\nПример 3:\nВход: nums = [3,3], target = 6\nИзход: [0,1]",
      "zh": "给定一个整数数组 nums 和一个整数 target，找到两个数，使得它们的和等于 target，并返回它们的索引。  \n你可以假设每个输入只会有一个解决方案，并且你不能重复使用相同的元素。  \n你可以以任何顺序返回答案。\n\n示例 1:  \n输入: nums = [2,7,11,15], target = 9  \n输出: [0,1]  \n解释: 因为 nums[0] + nums[1] == 9，我们返回 [0, 1]。\n\n示例 2:  \n输入: nums = [3,2,4], target = 6  \n输出: [1,2]\n\n示例 3:  \n输入: nums = [3,3], target = 6  \n输出: [0,1]",
      "fr": "Étant donné un tableau d'entiers nums et un entier target, trouvez deux nombres tels qu'ils s'additionnent pour donner target et retournez leurs indices. Vous pouvez supposer que chaque entrée aurait exactement une solution, et vous ne pouvez pas utiliser le même élément deux fois. Vous pouvez retourner la réponse dans n'importe quel ordre.\n\nExemple 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nExplication: Parce que nums[0] + nums[1] == 9, nous retournons [0, 1].\n\nExemple 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nExemple 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "de": "Gegeben ein Array von ganzen Zahlen nums und eine ganze Zahl target, finde zwei Zahlen, so dass sie zusammen target ergeben und gib ihre Indizes zurück. Du kannst davon ausgehen, dass jede Eingabe genau eine Lösung hat, und du darfst dasselbe Element nicht zweimal verwenden. Du kannst die Antwort in beliebiger Reihenfolge zurückgeben.\n\nBeispiel 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nErklärung: Da nums[0] + nums[1] == 9, geben wir [0, 1] zurück.\n\nBeispiel 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nBeispiel 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "ha": "An ba da jerin lambobin cikakku nums da kuma wani cikakken lamba target, nemo lambobi biyu da za su haɗa su zama target kuma dawo da alamun su. Za ka iya ɗauka cewa kowace shigarwa za ta sami daidai mafita guda ɗaya, kuma ba za ka iya amfani da abu ɗaya sau biyu ba. Za ka iya dawo da amsar a kowane tsari.\n\nMisali na 1:\nInput: nums = [2,7,11,15], target = 9\nOutput: [0,1]\nBayani: Domin nums[0] + nums[1] == 9, mun dawo da [0, 1].\n\nMisali na 2:\nInput: nums = [3,2,4], target = 6\nOutput: [1,2]\n\nMisali na 3:\nInput: nums = [3,3], target = 6\nOutput: [0,1]",
      "hi": "दिए गए पूर्णांकों के एक array nums और एक पूर्णांक target के लिए, दो संख्याएँ खोजें जो target के लिए जोड़ती हैं और उनके सूचकांक लौटाएँ। आप मान सकते हैं कि प्रत्येक इनपुट में ठीक एक समाधान होगा, और आप एक ही तत्व का दो बार उपयोग नहीं कर सकते। आप उत्तर को किसी भी क्रम में लौटा सकते हैं।\n\nउदाहरण 1:\nइनपुट: nums = [2,7,11,15], target = 9\nआउटपुट: [0,1]\nव्याख्या: क्योंकि nums[0] + nums[1] == 9, हम [0, 1] लौटाते हैं।\n\nउदाहरण 2:\nइनपुट: nums = [3,2,4], target = 6\nआउटपुट: [1,2]\n\nउदाहरण 3:\nइनपुट: nums = [3,3], target = 6\nआउटपुट: [0,1]",
      "hu": "Adott egy egész számokat tartalmazó tömb, nums, és egy egész szám, target. Találj két számot, amelyek összege a target, és add vissza az indexeiket. Feltételezheted, hogy minden bemenetnek pontosan egy megoldása van, és nem használhatod ugyanazt az elemet kétszer. A választ bármilyen sorrendben visszaadhatod.\n\nPélda 1:\nBemenet: nums = [2,7,11,15], target = 9\nKimenet: [0,1]\nMagyarázat: Mivel nums[0] + nums[1] == 9, visszaadjuk [0, 1].\n\nPélda 2:\nBemenet: nums = [3,2,4], target = 6\nKimenet: [1,2]\n\nPélda 3:\nBemenet: nums = [3,3], target = 6\nKimenet: [0,1]"
    },
    "docstring_bertscore": {
      "sq": "0.9955097616063253",
      "hy": "0.9889539658802688",
      "bn": "1",
      "bg": "0.988402369312135",
      "zh": "0.9844402891016321",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.9586395930178673",
      "hu": "0.9737396732145205"
    }
  },
  {
    "task_id": "Java/14",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Search for the target value in the rotated sorted array.\n     * If the target value exists, return its index; otherwise, return -1.\n     * The array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\n     * The time complexity of the algorithm must be O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "sq": "class Solution {\n    /**\n     * Kërko për vlerën e synuar në vargun e rrotulluar dhe të renditur.\n     * Nëse vlera e synuar ekziston, kthe indeksin e saj; përndryshe, kthe -1.\n     * Vargu nums është rrotulluar në një pikë të panjohur k, ku 0 <= k < nums.length.\n     * Kompleksiteti kohor i algoritmit duhet të jetë O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "hy": "class Solution {\n    /**\n     * Որոնել թիրախային արժեքը պտտված դասավորված զանգվածում:\n     * Եթե թիրախային արժեքը գոյություն ունի, վերադարձնել դրա ինդեքսը, հակառակ դեպքում վերադարձնել -1:\n     * Զանգվածը nums պտտված է որոշ անհայտ պիվոտում k, որտեղ 0 <= k < nums.length:\n     * Ալգորիթմի ժամանակային բարդությունը պետք է լինի O(log n):\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "bn": "class Solution {\n    /**\n     * ঘোরানো সাজানো অ্যারেতে লক্ষ্য মানটি সন্ধান করুন।\n     * যদি লক্ষ্য মানটি থাকে, তবে এর সূচক ফেরত দিন; অন্যথায়, -1 ফেরত দিন।\n     * অ্যারে nums অজানা কোনো পিভট k তে ঘোরানো হয়েছে, যেখানে 0 <= k < nums.length।\n     * অ্যালগরিদমের সময় জটিলতা অবশ্যই O(log n) হতে হবে।\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "bg": "class Solution {\n    /**\n     * Търсене на целевата стойност в завъртения сортиран масив.\n     * Ако целевата стойност съществува, върнете нейния индекс; в противен случай върнете -1.\n     * Масивът nums е завъртян около някакъв неизвестен пивот k, където 0 <= k < nums.length.\n     * Времевата сложност на алгоритъма трябва да бъде O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "zh": "class Solution {\n    /**\n     * 在旋转排序数组中搜索目标值。\n     * 如果目标值存在，返回其索引；否则，返回-1。\n     * 数组 nums 在某个未知的轴 k 上进行了旋转，其中 0 <= k < nums.length。\n     * 算法的时间复杂度必须是 O(log n)。\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "fr": "class Solution {\n    /**\n     * Rechercher la valeur cible dans le tableau trié et pivoté.\n     * Si la valeur cible existe, retourner son index ; sinon, retourner -1.\n     * Le tableau nums est pivoté à un certain pivot inconnu k, où 0 <= k < nums.length.\n     * La complexité temporelle de l'algorithme doit être O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "de": "class Solution {\n    /**\n     * Suche nach dem Zielwert im gedrehten sortierten Array.\n     * Wenn der Zielwert existiert, gib seinen Index zurück; andernfalls gib -1 zurück.\n     * Das Array nums ist an einem unbekannten Drehpunkt k gedreht, wobei 0 <= k < nums.length.\n     * Die Zeitkomplexität des Algorithmus muss O(log n) sein.\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "ha": "class Solution {\n    /**\n     * Nema darajar da ake nema a cikin jujjuyawar jerin lambobi da aka tsara.\n     * Idan darajar da ake nema tana nan, dawo da matsayinta; in ba haka ba, dawo da -1.\n     * Jerin nums an jujjuya shi a wani wurin da ba a sani ba k, inda 0 <= k < nums.length.\n     * Wahalar lokaci na wannan dabarar dole ne ya zama O(log n).\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "hi": "class Solution {\n    /**\n     * घुमाए गए क्रमबद्ध array में लक्षित मान खोजें।\n     * यदि लक्षित मान मौजूद है, तो उसका सूचकांक लौटाएं; अन्यथा, -1 लौटाएं।\n     * array nums को किसी अज्ञात धुरी k पर घुमाया गया है, जहाँ 0 <= k < nums.length।\n     * एल्गोरिदम की समय जटिलता O(log n) होनी चाहिए।\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) ",
      "hu": "class Solution {\n    /**\n     * Keresse meg a célértéket a forgatott rendezett tömbben.\n     * Ha a célérték létezik, adja vissza az indexét; ellenkező esetben adja vissza -1-et.\n     * A nums tömb egy ismeretlen k elforgatási pontnál van elforgatva, ahol 0 <= k < nums.length.\n     * Az algoritmus időbeli komplexitása O(log n) kell legyen.\n     * \n     * >>> search(new int[]{4,5,6,7,0,1,2}, 0)\n     * 4\n     * >>> search(new int[]{4,5,6,7,0,1,2}, 3)\n     * -1\n     * >>> search(new int[]{1}, 0)\n     * -1\n     */\n    public int search(int[] nums, int target) "
    },
    "prompt_bertscore": {
      "sq": "0.9875583888231177",
      "hy": "0.9853835847811667",
      "bn": "0.9867591001698334",
      "bg": "0.9943654519811833",
      "zh": "0.9951556036369401",
      "fr": "0.9948409731133808",
      "de": "0.9986119708973282",
      "ha": "0.984354878037787",
      "hi": "0.99272953216298",
      "hu": "0.9847366456301361"
    },
    "canonical_solution": "    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }",
    "instruction": {
      "en": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nՏվեք Java կոդի համառոտ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Java a Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public int search(int[] nums, int target)\n    {\n\n        int start = 0, end = nums.length - 1;\n        while (start <= end) {\n            int mid = start + (end - start) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] >= nums[start]) {\n                if (target >= nums[start] && target < nums[mid]) end = mid - 1;\n                else start = mid + 1;\n            }\n            else {\n                if (target <= nums[end] && target > nums[mid]) start = mid + 1;\n                else end = mid - 1;\n            }\n        }\n        return -1;\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9357093045704378",
      "hy": "0.9070264816578568",
      "bn": "0.8821843757929664",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9353706397707733",
      "hi": "0.9113991308659588",
      "hu": "0.9217511504343541"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 6) == 2;\n        assert solution.search(new int[]{4,5,6,7,0,1,2}, 7) == 3;\n        assert solution.search(new int[]{1, 3}, 3) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "search",
    "signature": "public int search(int[] nums, int target)",
    "docstring": {
      "en": "Search for the target value in the rotated sorted array.\nIf the target value exists, return its index; otherwise, return -1.\nThe array nums is rotated at some unknown pivot k, where 0 <= k < nums.length.\nThe time complexity of the algorithm must be O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "sq": "Kërko vlerën e synuar në vargun e radhitur të rotuar.\nNëse vlera e synuar ekziston, kthe indeksin e saj; përndryshe, kthe -1.\nVargu nums është rotuar në një pivot të panjohur k, ku 0 <= k < nums.length.\nKompleksiteti kohor i algoritmit duhet të jetë O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "hy": "Փնտրեք նպատակային արժեքը պտտված դասավորված զանգվածում։  \nԵթե նպատակային արժեքը գոյություն ունի, վերադարձնել դրա ինդեքսը, հակառակ դեպքում՝ վերադարձնել -1։  \nԶանգվածը nums պտտված է ինչ-որ անհայտ կետում k, որտեղ 0 <= k < nums.length։  \nԱլգորիթմի ժամանակային բարդությունը պետք է լինի O(log n)։\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "bn": "ঘূর্ণিত সাজানো অ্যারেতে লক্ষ্য মানটি সন্ধান করুন।  \nযদি লক্ষ্য মানটি বিদ্যমান থাকে, তবে এর সূচক ফেরত দিন; অন্যথায়, -1 ফেরত দিন।  \nঅ্যারেটি nums অজানা পিভট k তে ঘূর্ণিত হয়, যেখানে 0 <= k < nums.length।  \nঅ্যালগরিদমের সময় জটিলতা অবশ্যই O(log n) হতে হবে।\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "bg": "Търсене на целевата стойност в завъртян сортиран масив.  \nАко целевата стойност съществува, върнете нейния индекс; в противен случай върнете -1.  \nМасивът nums е завъртян около някакъв неизвестен връх k, където 0 <= k < nums.length.  \nВремевата сложност на алгоритъма трябва да бъде O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "zh": "在旋转排序数组中搜索目标值。  \n如果目标值存在，返回其索引；否则，返回 -1。  \n数组 nums 在某个未知的枢轴 k 处旋转，其中 0 <= k < nums.length。  \n算法的时间复杂度必须是 O(log n)。\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "fr": "Rechercher la valeur cible dans le tableau trié pivoté.  \nSi la valeur cible existe, renvoyez son index ; sinon, renvoyez -1.  \nLe tableau nums est pivoté à un certain pivot inconnu k, où 0 <= k < nums.length.  \nLa complexité temporelle de l'algorithme doit être O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "de": "Suche nach dem Zielwert im gedrehten sortierten Array.\nWenn der Zielwert existiert, gib seinen Index zurück; andernfalls gib -1 zurück.\nDas Array nums wird an einem unbekannten Drehpunkt k gedreht, wobei 0 <= k < nums.length.\nDie Zeitkomplexität des Algorithmus muss O(log n) sein.\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "ha": "Nemo darajar da ake nufi a cikin jujjuyawar jerin da aka tsara.\nIdan darajar da ake nufi tana nan, dawo da alamarta; in ba haka ba, dawo da -1.\nJerin nums an jujjuya shi a wani matakin da ba a sani ba k, inda 0 <= k < nums.length.\nWannan algorithm dole ne ya kasance yana da rikitarwa na lokaci O(log n).\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "hi": "घुमाए गए क्रमबद्ध सरणी में लक्ष्य मान खोजें।  \nयदि लक्ष्य मान मौजूद है, तो उसका सूचकांक लौटाएं; अन्यथा, -1 लौटाएं।  \nसरणी nums को कुछ अज्ञात धुरी k पर घुमाया गया है, जहाँ 0 <= k < nums.length।  \nएल्गोरिदम की समय जटिलता O(log n) होनी चाहिए।\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1",
      "hu": "Keresd meg a célértéket az elforgatott rendezett tömbben.\nHa a célérték létezik, add vissza az indexét; ellenkező esetben add vissza -1-et.\nA nums tömb egy ismeretlen k csuklópontnál van elforgatva, ahol 0 <= k < nums.length.\nAz algoritmus időbonyolultsága O(log n) kell, hogy legyen.\n\n>>> search(new int[]{4,5,6,7,0,1,2}, 0)\n4\n>>> search(new int[]{4,5,6,7,0,1,2}, 3)\n-1\n>>> search(new int[]{1}, 0)\n-1"
    },
    "docstring_bertscore": {
      "sq": "0.9957203098102223",
      "hy": "0.9845050426058494",
      "bn": "0.9779164728669222",
      "bg": "0.9906621871571689",
      "zh": "0.9928268610496871",
      "fr": "1",
      "de": "0.9982969431130069",
      "ha": "0.9776312396397561",
      "hi": "0.982242642565862",
      "hu": "0.9780932539060432"
    }
  },
  {
    "task_id": "Java/15",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\n     * Return the mean with an error within 10^-5.\n     *\n     * Example 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Example 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Example 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Example 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Example 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "sq": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një varg të plotë arr, llogarit mesataren e elementeve të mbetura pasi të keni hequr 5% më të vogla dhe 5% më të mëdha të elementeve.\n     * Kthejeni mesataren me një gabim brenda 10^-5.\n     *\n     * Shembull 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Shembull 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Shembull 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Shembull 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Shembull 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "hy": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված arr, հաշվարկել մնացած տարրերի միջին արժեքը, հեռացնելուց հետո ամենափոքր 5% և ամենամեծ 5% տարրերը:\n     * Վերադարձնել միջինը 10^-5 սխալի սահմաններում:\n     *\n     * Օրինակ 1:\n     * Մուտք: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Ելք: 2.00000\n     *\n     * Օրինակ 2:\n     * Մուտք: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Ելք: 4.00000\n     *\n     * Օրինակ 3:\n     * Մուտք: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Ելք: 4.77778\n     *\n     * Օրինակ 4:\n     * Մուտք: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Ելք: 5.27778\n     *\n     * Օրինակ 5:\n     * Մուտք: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Ելք: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "bn": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * একটি পূর্ণসংখ্যার অ্যারে arr দেওয়া আছে, সবচেয়ে ছোট 5% এবং সবচেয়ে বড় 5% উপাদানগুলি সরানোর পর অবশিষ্ট উপাদানগুলির গড় হিসাব করুন।\n     * 10^-5 এর মধ্যে ত্রুটি সহ গড় ফেরত দিন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * আউটপুট: 2.00000\n     *\n     * উদাহরণ 2:\n     * ইনপুট: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * আউটপুট: 4.00000\n     *\n     * উদাহরণ 3:\n     * ইনপুট: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * আউটপুট: 4.77778\n     *\n     * উদাহরণ 4:\n     * ইনপুট: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * আউটপুট: 5.27778\n     *\n     * উদাহরণ 5:\n     * ইনপুট: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * আউটপুট: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "bg": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Като се даде масив от цели числа arr, изчислете средната стойност на останалите елементи след премахване на най-малките 5% и най-големите 5% от елементите.\n     * Върнете средната стойност с грешка в рамките на 10^-5.\n     *\n     * Пример 1:\n     * Вход: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Изход: 2.00000\n     *\n     * Пример 2:\n     * Вход: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Изход: 4.00000\n     *\n     * Пример 3:\n     * Вход: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Изход: 4.77778\n     *\n     * Пример 4:\n     * Вход: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Изход: 5.27778\n     *\n     * Пример 5:\n     * Вход: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Изход: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "zh": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个整数数组 arr，计算去掉最小的 5% 和最大的 5% 元素后的剩余元素的平均值。\n     * 返回误差在 10^-5 以内的平均值。\n     *\n     * 示例 1:\n     * 输入: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * 输出: 2.00000\n     *\n     * 示例 2:\n     * 输入: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * 输出: 4.00000\n     *\n     * 示例 3:\n     * 输入: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * 输出: 4.77778\n     *\n     * 示例 4:\n     * 输入: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * 输出: 5.27778\n     *\n     * 示例 5:\n     * 输入: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * 输出: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "fr": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné un tableau d'entiers arr, calculez la moyenne des éléments restants après avoir retiré les 5% les plus petits et les 5% les plus grands des éléments.\n     * Retournez la moyenne avec une erreur inférieure à 10^-5.\n     *\n     * Exemple 1 :\n     * Entrée : arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Sortie : 2.00000\n     *\n     * Exemple 2 :\n     * Entrée : arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Sortie : 4.00000\n     *\n     * Exemple 3 :\n     * Entrée : arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Sortie : 4.77778\n     *\n     * Exemple 4 :\n     * Entrée : arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Sortie : 5.27778\n     *\n     * Exemple 5 :\n     * Entrée : arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Sortie : 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "de": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben ein ganzzahliges Array arr, berechne den Mittelwert der verbleibenden Elemente, nachdem die kleinsten 5% und die größten 5% der Elemente entfernt wurden.\n     * Gib den Mittelwert mit einem Fehler innerhalb von 10^-5 zurück.\n     *\n     * Beispiel 1:\n     * Eingabe: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Ausgabe: 2.00000\n     *\n     * Beispiel 2:\n     * Eingabe: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Ausgabe: 4.00000\n     *\n     * Beispiel 3:\n     * Eingabe: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Ausgabe: 4.77778\n     *\n     * Beispiel 4:\n     * Eingabe: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Ausgabe: 5.27778\n     *\n     * Beispiel 5:\n     * Eingabe: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Ausgabe: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "ha": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani jerin lambobi na integer arr, a lissafta matsakaicin sauran abubuwan bayan cire ƙananan kashi 5% da manyan kashi 5% na abubuwan.\n     * Mayar da matsakaicin tare da kuskure a cikin 10^-5.\n     *\n     * Misali 1:\n     * Input: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Output: 2.00000\n     *\n     * Misali 2:\n     * Input: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Output: 4.00000\n     *\n     * Misali 3:\n     * Input: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Output: 4.77778\n     *\n     * Misali 4:\n     * Input: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Output: 5.27778\n     *\n     * Misali 5:\n     * Input: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Output: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "hi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए पूर्णांक सरणी arr में, सबसे छोटे 5% और सबसे बड़े 5% तत्वों को हटाने के बाद शेष तत्वों का औसत गणना करें।\n     * 10^-5 की त्रुटि के भीतर औसत लौटाएं।\n     *\n     * उदाहरण 1:\n     * इनपुट: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * आउटपुट: 2.00000\n     *\n     * उदाहरण 2:\n     * इनपुट: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * आउटपुट: 4.00000\n     *\n     * उदाहरण 3:\n     * इनपुट: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * आउटपुट: 4.77778\n     *\n     * उदाहरण 4:\n     * इनपुट: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * आउटपुट: 5.27778\n     *\n     * उदाहरण 5:\n     * इनपुट: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * आउटपुट: 5.29167\n     */\n  public double trimMean(int[] arr) ",
      "hu": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy egész számokat tartalmazó tömb, `arr`, számítsuk ki a maradék elemek átlagát, miután eltávolítottuk a legkisebb 5% és a legnagyobb 5% elemeket.\n     * Adjuk vissza az átlagot 10^-5 hibahatáron belül.\n     *\n     * Példa 1:\n     * Bemenet: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n     * Kimenet: 2.00000\n     *\n     * Példa 2:\n     * Bemenet: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n     * Kimenet: 4.00000\n     *\n     * Példa 3:\n     * Bemenet: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n     * Kimenet: 4.77778\n     *\n     * Példa 4:\n     * Bemenet: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n     * Kimenet: 5.27778\n     *\n     * Példa 5:\n     * Bemenet: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n     * Kimenet: 5.29167\n     */\n  public double trimMean(int[] arr) "
    },
    "prompt_bertscore": {
      "sq": "0.9875180668557676",
      "hy": "0.9374437450576344",
      "bn": "0.9891845757526503",
      "bg": "0.9595705736137778",
      "zh": "0.9599785604164235",
      "fr": "0.9395430695547922",
      "de": "0.9904842143357616",
      "ha": "0.9479014359887402",
      "hi": "0.9745298248702773",
      "hu": "0.9433760400176223"
    },
    "canonical_solution": "  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }",
    "instruction": {
      "en": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате максимум 500 знака.",
      "zh": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nBayar da takaitaccen bayanin yaren halitta (docstring) na lambar Java cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public double trimMean(int[] arr)\n  {\n\n    Arrays.sort(arr);\n    int n = arr.length;\n    int remove = (int) (n * 0.05);\n    double sum = 0;\n    for (int i = remove; i < n - remove; i++) {\n      sum += arr[i];\n    }\n    return sum / (n - 2 * remove);\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9615433705582164",
      "bn": "0.9238701393392342",
      "bg": "0.8459003654589423",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }) - 5.5\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 10, 20, 30, 40, 50, 60, 70, 80, 90, 100 }) -\n      55.0\n    ) <\n    1e-5;\n    assert Math.abs(\n      solution.trimMean(new int[] { 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 }) - 1.0\n    ) <\n    1e-5;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "trimMean",
    "signature": "public double trimMean(int[] arr)",
    "docstring": {
      "en": "Given an integer array arr, calculate the mean of the remaining elements after removing the smallest 5% and largest 5% of the elements.\nReturn the mean with an error within 10^-5.\n\nExample 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nExample 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nExample 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nExample 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nExample 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167",
      "sq": "Given një varg integerësh arr, llogarit mesataren e elementeve të mbetura pasi të keni hequr 5% më të vogla dhe 5% më të mëdha të elementeve.\nKthe mesataren me një gabim brenda 10^-5.\n\nShembull 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nShembull 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nShembull 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nShembull 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nShembull 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167",
      "hy": "Տրված է ամբողջ թվերի զանգված `arr`, հաշվարկել մնացած տարրերի միջին թվաբանականը՝ հեռացնելուց հետո ամենափոքր 5% և ամենամեծ 5% տարրերը: \nՎերադարձնել միջին թվաբանականը 10^-5 սխալով:\n\nՕրինակ 1:\nՄուտք: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nԵլք: 2.00000\n\nՕրինակ 2:\nՄուտք: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nԵլք: 4.00000\n\nՕրինակ 3:\nՄուտք: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nԵլք: 4.77778\n\nՕրինակ 4:\nՄուտք: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nԵլք: 5.27778\n\nՕրինակ 5:\nՄուտք: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nԵլք: 5.29167",
      "bn": "প্রদত্ত একটি পূর্ণসংখ্যার অ্যারে arr, অ্যারের সবচেয়ে ছোট ৫% এবং সবচেয়ে বড় ৫% উপাদানগুলি সরানোর পর অবশিষ্ট উপাদানগুলির গড় গণনা করুন। 10^-5 এর মধ্যে ত্রুটি সহ গড় ফেরত দিন।\n\nউদাহরণ 1:\nইনপুট: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nআউটপুট: 2.00000\n\nউদাহরণ 2:\nইনপুট: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nআউটপুট: 4.00000\n\nউদাহরণ 3:\nইনপুট: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nআউটপুট: 4.77778\n\nউদাহরণ 4:\nইনপুট: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nআউটপুট: 5.27778\n\nউদাহরণ 5:\nইনপুট: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nআউটপুট: 5.29167",
      "bg": "Даден е масив от цели числа arr, изчислете средната стойност на останалите елементи след премахване на най-малките 5% и най-големите 5% от елементите. Върнете средната стойност с грешка в рамките на 10^-5.\n\nПример 1:\nВход: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nИзход: 2.00000\n\nПример 2:\nВход: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nИзход: 4.00000\n\nПример 3:\nВход: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nИзход: 4.77778\n\nПример 4:\nВход: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nИзход: 5.27778\n\nПример 5:\nВход: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nИзход: 5.29167",
      "zh": "给定一个整数数组 `arr`，计算在去掉最小的 5% 和最大的 5% 的元素后的剩余元素的平均值。返回的平均值误差在 10^-5 以内。\n\n例子 1:\n输入: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\n输出: 2.00000\n\n例子 2:\n输入: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\n输出: 4.00000\n\n例子 3:\n输入: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\n输出: 4.77778\n\n例子 4:\n输入: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\n输出: 5.27778\n\n例子 5:\n输入: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\n输出: 5.29167",
      "fr": "Étant donné un tableau d'entiers `arr`, calculez la moyenne des éléments restants après avoir retiré les 5% les plus petits et les 5% les plus grands des éléments.  \nRetournez la moyenne avec une erreur inférieure à 10^-5.\n\nExemple 1 :  \nEntrée : `arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]`  \nSortie : `2.00000`\n\nExemple 2 :  \nEntrée : `arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]`  \nSortie : `4.00000`\n\nExemple 3 :  \nEntrée : `arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]`  \nSortie : `4.77778`\n\nExemple 4 :  \nEntrée : `arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]`  \nSortie : `5.27778`\n\nExemple 5 :  \nEntrée : `arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]`  \nSortie : `5.29167`",
      "de": "Gegeben ein Integer-Array arr, berechne den Mittelwert der verbleibenden Elemente, nachdem die kleinsten 5% und die größten 5% der Elemente entfernt wurden. Gib den Mittelwert mit einem Fehler innerhalb von 10^-5 zurück.\n\nBeispiel 1:\nInput: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nOutput: 2.00000\n\nBeispiel 2:\nInput: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nOutput: 4.00000\n\nBeispiel 3:\nInput: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nOutput: 4.77778\n\nBeispiel 4:\nInput: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nOutput: 5.27778\n\nBeispiel 5:\nInput: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nOutput: 5.29167",
      "ha": "An ba da jerin lambobi na integer arr, a lissafta matsakaicin sauran abubuwan bayan cire ƙananan kashi 5% da manyan kashi 5% na abubuwan. \nDawo da matsakaicin tare da kuskure a cikin 10^-5.\n\nMisali 1:\nShigar: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nFitarwa: 2.00000\n\nMisali 2:\nShigar: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nFitarwa: 4.00000\n\nMisali 3:\nShigar: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nFitarwa: 4.77778\n\nMisali 4:\nShigar: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nFitarwa: 5.27778\n\nMisali 5:\nShigar: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nFitarwa: 5.29167",
      "hi": "दिए गए पूर्णांक array arr के लिए, सबसे छोटे 5% और सबसे बड़े 5% तत्वों को हटाने के बाद शेष तत्वों का औसत गणना करें। 10^-5 की त्रुटि के भीतर औसत लौटाएं।\n\nउदाहरण 1:\nइनपुट: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nआउटपुट: 2.00000\n\nउदाहरण 2:\nइनपुट: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nआउटपुट: 4.00000\n\nउदाहरण 3:\nइनपुट: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nआउटपुट: 4.77778\n\nउदाहरण 4:\nइनपुट: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nआउटपुट: 5.27778\n\nउदाहरण 5:\nइनपुट: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nआउटपुट: 5.29167",
      "hu": "Adott egy egész számokat tartalmazó tömb, `arr`, számítsd ki a megmaradt elemek átlagát, miután eltávolítottad a legkisebb 5%-ot és a legnagyobb 5%-ot az elemek közül. \nAdd vissza az átlagot 10^-5 hibahatáron belül.\n\nPélda 1:\nBemenet: arr = [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,3]\nKimenet: 2.00000\n\nPélda 2:\nBemenet: arr = [6,2,7,5,1,2,0,3,10,2,5,0,5,5,0,8,7,6,8,0]\nKimenet: 4.00000\n\nPélda 3:\nBemenet: arr = [6,0,7,0,7,5,7,8,3,4,0,7,8,1,6,8,1,1,2,4,8,1,9,5,4,3,8,5,10,8,6,6,1,0,6,10,8,2,3,4]\nKimenet: 4.77778\n\nPélda 4:\nBemenet: arr = [9,7,8,7,7,8,4,4,6,8,8,7,6,8,8,9,2,6,0,0,1,10,8,6,3,3,5,1,10,9,0,7,10,0,10,4,1,10,6,9,3,6,0,0,2,7,0,6,7,2,9,7,7,3,0,1,6,1,10,3]\nKimenet: 5.27778\n\nPélda 5:\nBemenet: arr = [4,8,4,10,0,7,1,3,7,8,8,3,4,1,6,2,1,1,8,0,9,8,0,3,9,10,3,10,1,10,7,3,2,1,4,9,10,7,6,4,0,8,5,1,2,1,6,2,5,0,7,10,9,10,3,7,10,5,8,5,7,6,7,6,10,9,5,10,5,5,7,2,10,7,7,8,2,0,1,1]\nKimenet: 5.29167"
    },
    "docstring_bertscore": {
      "sq": "0.971914855903953",
      "hy": "0.9321881838058322",
      "bn": "0.9423787168744462",
      "bg": "0.9410500782557039",
      "zh": "0.9395673024612784",
      "fr": "0.9121946455420036",
      "de": "0.9879624030181426",
      "ha": "0.939274918540395",
      "hi": "0.9964157147742254",
      "hu": "0.9379659443293751"
    }
  },
  {
    "task_id": "Java/16",
    "prompt": {
      "en": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n     *\n     * @param arr the input integer array\n     * @param k the divisor\n     * @return true if it is possible, false otherwise\n     *\n     * Example:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "sq": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Kontrolloni nëse është e mundur të ndani vargun në n/2 çifte të tilla që shuma e secilit çift të jetë e pjestueshme me k.\n     *\n     * @param arr vargu hyrës i numrave të plotë\n     * @param k pjestuesi\n     * @return true nëse është e mundur, false përndryshe\n     *\n     * Shembull:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Shpjegim: Çiftet janë (1,9), (2,8), (3,7), (4,6), (5,10), dhe shuma e secilit çift është e pjestueshme me 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Shpjegim: Çiftet janë (1,6), (2,5), (3,4), dhe shuma e secilit çift është e pjestueshme me 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Shpjegim: Nuk është e mundur të ndani vargun në n/2 çifte të tilla që shuma e secilit çift të jetë e pjestueshme me 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "hy": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Ստուգել, արդյոք հնարավոր է զանգվածը բաժանել n/2 զույգերի այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի k-ի վրա:\n     *\n     * @param arr մուտքային ամբողջ թվերի զանգվածը\n     * @param k բաժանարարը\n     * @return true եթե հնարավոր է, false հակառակ դեպքում\n     *\n     * Օրինակ:\n     * Մուտք: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Ելք: true\n     * Բացատրություն: Զույգերն են (1,9), (2,8), (3,7), (4,6), (5,10), և յուրաքանչյուր զույգի գումարը բաժանվում է 5-ի վրա:\n     *\n     * Մուտք: arr = [1,2,3,4,5,6], k = 7\n     * Ելք: true\n     * Բացատրություն: Զույգերն են (1,6), (2,5), (3,4), և յուրաքանչյուր զույգի գումարը բաժանվում է 7-ի վրա:\n     *\n     * Մուտք: arr = [1,2,3,4,5,6], k = 10\n     * Ելք: false\n     * Բացատրություն: Անհնար է զանգվածը բաժանել n/2 զույգերի այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի 10-ի վրա:\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "bn": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * এটি পরীক্ষা করুন যে অ্যারেটিকে n/2 জোড়ায় ভাগ করা সম্ভব কিনা যাতে প্রতিটি জোড়ার যোগফল k দ্বারা বিভাজ্য হয়।\n     *\n     * @param arr ইনপুট পূর্ণসংখ্যার অ্যারে\n     * @param k বিভাজক\n     * @return সত্য যদি এটি সম্ভব হয়, অন্যথায় মিথ্যা\n     *\n     * উদাহরণ:\n     * ইনপুট: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * আউটপুট: true\n     * ব্যাখ্যা: জোড়াগুলি হল (1,9), (2,8), (3,7), (4,6), (5,10), এবং প্রতিটি জোড়ার যোগফল 5 দ্বারা বিভাজ্য।\n     *\n     * ইনপুট: arr = [1,2,3,4,5,6], k = 7\n     * আউটপুট: true\n     * ব্যাখ্যা: জোড়াগুলি হল (1,6), (2,5), (3,4), এবং প্রতিটি জোড়ার যোগফল 7 দ্বারা বিভাজ্য।\n     *\n     * ইনপুট: arr = [1,2,3,4,5,6], k = 10\n     * আউটপুট: false\n     * ব্যাখ্যা: এটি সম্ভব নয় যে অ্যারেটিকে n/2 জোড়ায় ভাগ করা যাতে প্রতিটি জোড়ার যোগফল 10 দ্বারা বিভাজ্য হয়।\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "bg": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Проверете дали е възможно да се раздели масивът на n/2 двойки, така че сумата на всяка двойка да е делима на k.\n     *\n     * @param arr входният масив от цели числа\n     * @param k делителят\n     * @return true ако е възможно, false в противен случай\n     *\n     * Пример:\n     * Вход: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Изход: true\n     * Обяснение: Двойките са (1,9), (2,8), (3,7), (4,6), (5,10), и сумата на всяка двойка е делима на 5.\n     *\n     * Вход: arr = [1,2,3,4,5,6], k = 7\n     * Изход: true\n     * Обяснение: Двойките са (1,6), (2,5), (3,4), и сумата на всяка двойка е делима на 7.\n     *\n     * Вход: arr = [1,2,3,4,5,6], k = 10\n     * Изход: false\n     * Обяснение: Не е възможно да се раздели масивът на n/2 двойки, така че сумата на всяка двойка да е делима на 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "zh": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * 检查是否可以将数组分成 n/2 对，使得每对的和都能被 k 整除。\n     *\n     * @param arr 输入的整数数组\n     * @param k 除数\n     * @return 如果可能则返回 true，否则返回 false\n     *\n     * 例子:\n     * 输入: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * 输出: true\n     * 解释: 这些对是 (1,9), (2,8), (3,7), (4,6), (5,10)，并且每对的和都能被 5 整除。\n     *\n     * 输入: arr = [1,2,3,4,5,6], k = 7\n     * 输出: true\n     * 解释: 这些对是 (1,6), (2,5), (3,4)，并且每对的和都能被 7 整除。\n     *\n     * 输入: arr = [1,2,3,4,5,6], k = 10\n     * 输出: false\n     * 解释: 不可能将数组分成 n/2 对，使得每对的和都能被 10 整除。\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "fr": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Vérifiez s'il est possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par k.\n     *\n     * @param arr le tableau d'entiers d'entrée\n     * @param k le diviseur\n     * @return true si c'est possible, false sinon\n     *\n     * Exemple:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Explication: Les paires sont (1,9), (2,8), (3,7), (4,6), (5,10), et la somme de chaque paire est divisible par 5.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Explication: Les paires sont (1,6), (2,5), (3,4), et la somme de chaque paire est divisible par 7.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Explication: Il n'est pas possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par 10.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "de": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Überprüfen, ob es möglich ist, das Array in n/2 Paare zu teilen, sodass die Summe jedes Paares durch k teilbar ist.\n     *\n     * @param arr das Eingabe-Integer-Array\n     * @param k der Divisor\n     * @return true, wenn es möglich ist, false andernfalls\n     *\n     * Beispiel:\n     * Input: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Output: true\n     * Erklärung: Die Paare sind (1,9), (2,8), (3,7), (4,6), (5,10), und die Summe jedes Paares ist durch 5 teilbar.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 7\n     * Output: true\n     * Erklärung: Die Paare sind (1,6), (2,5), (3,4), und die Summe jedes Paares ist durch 7 teilbar.\n     *\n     * Input: arr = [1,2,3,4,5,6], k = 10\n     * Output: false\n     * Erklärung: Es ist nicht möglich, das Array in n/2 Paare zu teilen, sodass die Summe jedes Paares durch 10 teilbar ist.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "ha": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Duba idan yana yiwuwa a raba jerin abubuwan cikin n/2 ma'aurata ta yadda jumlar kowanne ma'aurata za ta rabu da k.\n     *\n     * @param arr jerin lambobin da aka shigar\n     * @param k mai raba\n     * @return gaskiya idan yana yiwuwa, karya idan ba haka ba\n     *\n     * Misali:\n     * Shigarwa: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Fitarwa: gaskiya\n     * Bayani: Ma'auratan sune (1,9), (2,8), (3,7), (4,6), (5,10), kuma jumlar kowanne ma'aurata za ta rabu da 5.\n     *\n     * Shigarwa: arr = [1,2,3,4,5,6], k = 7\n     * Fitarwa: gaskiya\n     * Bayani: Ma'auratan sune (1,6), (2,5), (3,4), kuma jumlar kowanne ma'aurata za ta rabu da 7.\n     *\n     * Shigarwa: arr = [1,2,3,4,5,6], k = 10\n     * Fitarwa: karya\n     * Bayani: Ba zai yiwu a raba jerin abubuwan cikin n/2 ma'aurata ta yadda jumlar kowanne ma'aurata za ta rabu da 10 ba.\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "hi": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * जाँचें कि क्या यह संभव है कि सरणी को n/2 जोड़ों में विभाजित किया जाए ताकि प्रत्येक जोड़े का योग k से विभाज्य हो।\n     *\n     * @param arr इनपुट पूर्णांक सरणी\n     * @param k भाजक\n     * @return true अगर यह संभव है, अन्यथा false\n     *\n     * उदाहरण:\n     * इनपुट: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * आउटपुट: true\n     * व्याख्या: जोड़े हैं (1,9), (2,8), (3,7), (4,6), (5,10), और प्रत्येक जोड़े का योग 5 से विभाज्य है।\n     *\n     * इनपुट: arr = [1,2,3,4,5,6], k = 7\n     * आउटपुट: true\n     * व्याख्या: जोड़े हैं (1,6), (2,5), (3,4), और प्रत्येक जोड़े का योग 7 से विभाज्य है।\n     *\n     * इनपुट: arr = [1,2,3,4,5,6], k = 10\n     * आउटपुट: false\n     * व्याख्या: यह संभव नहीं है कि सरणी को n/2 जोड़ों में विभाजित किया जाए ताकि प्रत्येक जोड़े का योग 10 से विभाज्य हो।\n     */\n  public boolean canArrange(int[] arr, int k) ",
      "hu": "import java.lang.*;\nimport java.util.*;\n\nclass Solution {\n    /**\n     * Ellenőrizze, hogy lehetséges-e az tömböt n/2 párra osztani úgy, hogy minden pár összege osztható legyen k-val.\n     *\n     * @param arr a bemeneti egész számok tömbje\n     * @param k az osztó\n     * @return true, ha lehetséges, false egyébként\n     *\n     * Példa:\n     * Bemenet: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n     * Kimenet: true\n     * Magyarázat: A párok (1,9), (2,8), (3,7), (4,6), (5,10), és minden pár összege osztható 5-tel.\n     *\n     * Bemenet: arr = [1,2,3,4,5,6], k = 7\n     * Kimenet: true\n     * Magyarázat: A párok (1,6), (2,5), (3,4), és minden pár összege osztható 7-tel.\n     *\n     * Bemenet: arr = [1,2,3,4,5,6], k = 10\n     * Kimenet: false\n     * Magyarázat: Nem lehetséges az tömböt n/2 párra osztani úgy, hogy minden pár összege osztható legyen 10-zel.\n     */\n  public boolean canArrange(int[] arr, int k) "
    },
    "prompt_bertscore": {
      "sq": "0.9812159221262927",
      "hy": "0.9545297318038745",
      "bn": "0.9740964133788592",
      "bg": "0.9617936448383203",
      "zh": "0.9696443120183432",
      "fr": "0.9721559931865293",
      "de": "0.9597463615009937",
      "ha": "0.9486242519453262",
      "hi": "0.9864408942994154",
      "hu": "0.9528787160767125"
    },
    "canonical_solution": "  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "instruction": {
      "en": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nՏվեք Java կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n请用最多500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public boolean canArrange(int[] arr, int k)\n  {\n\n    int[] remainder = new int[k];\n    for (int num : arr) {\n      remainder[(num % k + k) % k]++;\n    }\n    if (remainder[0] % 2 != 0) {\n      return false;\n    }\n    for (int i = 1; i <= k / 2; i++) {\n      if (remainder[i] != remainder[k - i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9465259206000736",
      "bn": "0.8821843757929664",
      "bg": "0.8376140553201085",
      "zh": "0.8770857325421819",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.canArrange(new int[]{1,2,3,4,5,10,6,7,8,9}, 5) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 7) == true;\n    assert solution.canArrange(new int[]{1,2,3,4,5,6}, 10) == false;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "canArrange",
    "signature": "public boolean canArrange(int[] arr, int k)",
    "docstring": {
      "en": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr the input integer array\n@param k the divisor\n@return true if it is possible, false otherwise\n\nExample:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nExplanation: The pairs are (1,9), (2,8), (3,7), (4,6), (5,10), and the sum of each pair is divisible by 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nExplanation: The pairs are (1,6), (2,5), (3,4), and the sum of each pair is divisible by 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nExplanation: It is not possible to divide the array into n/2 pairs such that the sum of each pair is divisible by 10.",
      "sq": "Kontrolloni nëse është e mundur të ndani vargun në çifte n/2 të tilla që shuma e secilit çift të jetë e pjestueshme me k.\n\n@param arr vargu hyrës i numrave të plotë\n@param k pjestuesi\n@return true nëse është e mundur, false përndryshe\n\nShembull:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nShpjegim: Çiftet janë (1,9), (2,8), (3,7), (4,6), (5,10), dhe shuma e secilit çift është e pjestueshme me 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nShpjegim: Çiftet janë (1,6), (2,5), (3,4), dhe shuma e secilit çift është e pjestueshme me 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nShpjegim: Nuk është e mundur të ndani vargun në çifte n/2 të tilla që shuma e secilit çift të jetë e pjestueshme me 10.",
      "hy": "Ստուգել, արդյոք հնարավոր է զանգվածը բաժանել n/2 զույգերի այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի k-ի վրա։\n\n@param arr մուտքային ամբողջ թվերի զանգվածը\n@param k բաժանարարը\n@return true եթե հնարավոր է, false հակառակ դեպքում\n\nՕրինակ:\nՄուտք: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nԵլք: true\nԲացատրություն: Զույգերն են (1,9), (2,8), (3,7), (4,6), (5,10), և յուրաքանչյուր զույգի գումարը բաժանվում է 5-ի վրա։\n\nՄուտք: arr = [1,2,3,4,5,6], k = 7\nԵլք: true\nԲացատրություն: Զույգերն են (1,6), (2,5), (3,4), և յուրաքանչյուր զույգի գումարը բաժանվում է 7-ի վրա։\n\nՄուտք: arr = [1,2,3,4,5,6], k = 10\nԵլք: false\nԲացատրություն: Անհնար է զանգվածը բաժանել n/2 զույգերի այնպես, որ յուրաքանչյուր զույգի գումարը բաժանվի 10-ի վրա։",
      "bn": "অ্যারে n/2 জোড়ায় ভাগ করা সম্ভব কিনা তা পরীক্ষা করুন যাতে প্রতিটি জোড়ার যোগফল k দ্বারা বিভাজ্য হয়।\n\n@param arr ইনপুট পূর্ণসংখ্যার অ্যারে\n@param k বিভাজক\n@return সত্য যদি এটি সম্ভব হয়, অন্যথায় মিথ্যা\n\nউদাহরণ:\nইনপুট: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nআউটপুট: true\nব্যাখ্যা: জোড়াগুলি হল (1,9), (2,8), (3,7), (4,6), (5,10), এবং প্রতিটি জোড়ার যোগফল 5 দ্বারা বিভাজ্য।\n\nইনপুট: arr = [1,2,3,4,5,6], k = 7\nআউটপুট: true\nব্যাখ্যা: জোড়াগুলি হল (1,6), (2,5), (3,4), এবং প্রতিটি জোড়ার যোগফল 7 দ্বারা বিভাজ্য।\n\nইনপুট: arr = [1,2,3,4,5,6], k = 10\nআউটপুট: false\nব্যাখ্যা: অ্যারেটিকে n/2 জোড়ায় ভাগ করা সম্ভব নয় যাতে প্রতিটি জোড়ার যোগফল 10 দ্বারা বিভাজ্য হয়।",
      "bg": "Проверете дали е възможно да се раздели масивът на n/2 двойки, така че сумата на всяка двойка да е делима на k.\n\n@param arr входящият масив от цели числа\n@param k делителят\n@return true ако е възможно, false в противен случай\n\nПример:\nВход: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nИзход: true\nОбяснение: Двойките са (1,9), (2,8), (3,7), (4,6), (5,10), и сумата на всяка двойка е делима на 5.\n\nВход: arr = [1,2,3,4,5,6], k = 7\nИзход: true\nОбяснение: Двойките са (1,6), (2,5), (3,4), и сумата на всяка двойка е делима на 7.\n\nВход: arr = [1,2,3,4,5,6], k = 10\nИзход: false\nОбяснение: Не е възможно да се раздели масивът на n/2 двойки, така че сумата на всяка двойка да е делима на 10.",
      "zh": "检查是否可以将数组分成 n/2 对，使得每对的和都能被 k 整除。\n\n@param arr 输入的整数数组\n@param k 除数\n@return 如果可能返回 true，否则返回 false\n\n示例：\n输入: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\n输出: true\n解释: 这些对是 (1,9), (2,8), (3,7), (4,6), (5,10)，并且每对的和都能被 5 整除。\n\n输入: arr = [1,2,3,4,5,6], k = 7\n输出: true\n解释: 这些对是 (1,6), (2,5), (3,4)，并且每对的和都能被 7 整除。\n\n输入: arr = [1,2,3,4,5,6], k = 10\n输出: false\n解释: 不可能将数组分成 n/2 对，使得每对的和都能被 10 整除。",
      "fr": "Vérifiez s'il est possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par k.\n\n@param arr le tableau d'entiers d'entrée\n@param k le diviseur\n@return true si c'est possible, false sinon\n\nExemple :\nEntrée : arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nSortie : true\nExplication : Les paires sont (1,9), (2,8), (3,7), (4,6), (5,10), et la somme de chaque paire est divisible par 5.\n\nEntrée : arr = [1,2,3,4,5,6], k = 7\nSortie : true\nExplication : Les paires sont (1,6), (2,5), (3,4), et la somme de chaque paire est divisible par 7.\n\nEntrée : arr = [1,2,3,4,5,6], k = 10\nSortie : false\nExplication : Il n'est pas possible de diviser le tableau en n/2 paires de sorte que la somme de chaque paire soit divisible par 10.",
      "de": "Überprüfen, ob es möglich ist, das Array in n/2 Paare zu unterteilen, sodass die Summe jedes Paares durch k teilbar ist.\n\n@param arr das Eingabe-Integer-Array\n@param k der Divisor\n@return true, wenn es möglich ist, andernfalls false\n\nBeispiel:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nErklärung: Die Paare sind (1,9), (2,8), (3,7), (4,6), (5,10), und die Summe jedes Paares ist durch 5 teilbar.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nErklärung: Die Paare sind (1,6), (2,5), (3,4), und die Summe jedes Paares ist durch 7 teilbar.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nErklärung: Es ist nicht möglich, das Array in n/2 Paare zu unterteilen, sodass die Summe jedes Paares durch 10 teilbar ist.",
      "ha": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr jerin lambobin shigarwa\n@param k mai raba\n@return gaskiya idan zai yiwu, ƙarya in ba haka ba\n\nMisali:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nBayani: Ma'auratan sune (1,9), (2,8), (3,7), (4,6), (5,10), kuma jimillar kowanne ma'aurata ana iya rabawa da 5.\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nBayani: Ma'auratan sune (1,6), (2,5), (3,4), kuma jimillar kowanne ma'aurata ana iya rabawa da 7.\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nBayani: Ba zai yiwu a raba jerin zuwa n/2 ma'aurata ba ta yadda jimillar kowanne ma'aurata ana iya rabawa da 10.",
      "hi": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr इनपुट पूर्णांक ऐरे\n@param k भाजक\n@return true यदि यह संभव है, अन्यथा false\n\nउदाहरण:\nInput: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nOutput: true\nव्याख्या: युग्म हैं (1,9), (2,8), (3,7), (4,6), (5,10), और प्रत्येक युग्म का योग 5 से विभाज्य है।\n\nInput: arr = [1,2,3,4,5,6], k = 7\nOutput: true\nव्याख्या: युग्म हैं (1,6), (2,5), (3,4), और प्रत्येक युग्म का योग 7 से विभाज्य है।\n\nInput: arr = [1,2,3,4,5,6], k = 10\nOutput: false\nव्याख्या: यह संभव नहीं है कि ऐरे को n/2 युग्मों में विभाजित किया जा सके ताकि प्रत्येक युग्म का योग 10 से विभाज्य हो।",
      "hu": "Check if it is possible to divide the array into n/2 pairs such that the sum of each pair is divisible by k.\n\n@param arr a bemeneti egész szám tömb\n@param k az osztó\n@return true ha lehetséges, false különben\n\nPélda:\nBemenet: arr = [1,2,3,4,5,10,6,7,8,9], k = 5\nKimenet: true\nMagyarázat: A párok (1,9), (2,8), (3,7), (4,6), (5,10), és minden pár összege osztható 5-tel.\n\nBemenet: arr = [1,2,3,4,5,6], k = 7\nKimenet: true\nMagyarázat: A párok (1,6), (2,5), (3,4), és minden pár összege osztható 7-tel.\n\nBemenet: arr = [1,2,3,4,5,6], k = 10\nKimenet: false\nMagyarázat: Nem lehetséges a tömböt n/2 párra osztani úgy, hogy minden pár összege osztható legyen 10-zel."
    },
    "docstring_bertscore": {
      "sq": "0.977790541205346",
      "hy": "0.9835361236071613",
      "bn": "0.9685301942111185",
      "bg": "0.9919163393830231",
      "zh": "0.9638464898263158",
      "fr": "0.9956009329512203",
      "de": "0.9988324506202769",
      "ha": "0.9694947433414239",
      "hi": "0.9870155319917494",
      "hu": "0.9782132266561883"
    }
  },
  {
    "task_id": "Java/17",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\n   * Starting from node 0, return the minimum time required to collect all the apples and return to node 0.\n   *\n   * Example:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "sq": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Duke pasur një pemë me n nyje dhe lidhje, dhe një varg boolean hasApple që tregon nëse secila nyje ka një mollë.\n   * Duke filluar nga nyja 0, kthe kohën minimale të kërkuar për të mbledhur të gjitha mollët dhe për t'u kthyer në nyjën 0.\n   *\n   * Shembull:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "hy": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Տրված է n գագաթներով և կողերով ծառ, և boolean զանգված hasApple, որը ցույց է տալիս, թե արդյոք յուրաքանչյուր գագաթում խնձոր կա:\n   * Սկսելով գագաթ 0-ից, վերադարձնել նվազագույն ժամանակը, որը պահանջվում է բոլոր խնձորները հավաքելու և գագաթ 0 վերադառնալու համար:\n   *\n   * Օրինակ:\n   * Մուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Ելք: 8\n   *\n   * Մուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Ելք: 6\n   *\n   * Մուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Ելք: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple)",
      "bn": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * একটি গাছ দেওয়া হয়েছে যেখানে n টি নোড এবং এজ রয়েছে, এবং একটি বুলিয়ান অ্যারে hasApple প্রতিটি নোডে আপেল আছে কিনা তা নির্দেশ করে।\n   * নোড 0 থেকে শুরু করে, সমস্ত আপেল সংগ্রহ করতে এবং নোড 0 তে ফিরে আসতে প্রয়োজনীয় সর্বনিম্ন সময় ফেরত দিন।\n   *\n   * উদাহরণ:\n   * ইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * আউটপুট: 8\n   *\n   * ইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * আউটপুট: 6\n   *\n   * ইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * আউটপুট: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "bg": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Дадено е дърво с n възли и ръбове, и булев масив hasApple, който указва дали всеки възел има ябълка.\n   * Започвайки от възел 0, върнете минималното време, необходимо за събиране на всички ябълки и връщане до възел 0.\n   *\n   * Пример:\n   * Вход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Изход: 8\n   *\n   * Вход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Изход: 6\n   *\n   * Вход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Изход: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "zh": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * 给定一个有 n 个节点和边的树，以及一个布尔数组 hasApple 表示每个节点是否有苹果。\n   * 从节点 0 开始，返回收集所有苹果并返回到节点 0 所需的最短时间。\n   *\n   * 示例:\n   * 输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * 输出: 8\n   *\n   * 输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * 输出: 6\n   *\n   * 输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * 输出: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple)",
      "fr": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Étant donné un arbre avec n nœuds et arêtes, et un tableau booléen hasApple indiquant si chaque nœud a une pomme.\n   * En partant du nœud 0, retournez le temps minimum requis pour collecter toutes les pommes et revenir au nœud 0.\n   *\n   * Exemple:\n   * Entrée: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Sortie: 8\n   *\n   * Entrée: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Sortie: 6\n   *\n   * Entrée: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Sortie: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "de": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Gegeben ist ein Baum mit n Knoten und Kanten sowie ein boolesches Array hasApple, das angibt, ob jeder Knoten einen Apfel hat.\n   * Beginnend bei Knoten 0, gib die minimale Zeit zurück, die benötigt wird, um alle Äpfel zu sammeln und zu Knoten 0 zurückzukehren.\n   *\n   * Beispiel:\n   * Eingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Ausgabe: 8\n   *\n   * Eingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Ausgabe: 6\n   *\n   * Eingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Ausgabe: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) ",
      "ha": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * An ba da itace tare da nodes n da edges, da kuma boolean array hasApple wanda ke nuna idan kowanne node yana da apple.\n   * Fara daga node 0, dawo da lokacin mafi kankanta da ake bukata don tattara dukkan apples kuma a dawo zuwa node 0.\n   *\n   * Misali:\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Output: 8\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Output: 6\n   *\n   * Input: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Output: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple)",
      "hi": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * दिए गए n नोड्स और किनारों वाले एक पेड़ और एक boolean array hasApple जो दर्शाता है कि प्रत्येक नोड पर सेब है या नहीं।\n   * नोड 0 से शुरू करके, सभी सेब इकट्ठा करने और नोड 0 पर लौटने के लिए आवश्यक न्यूनतम समय लौटाएं।\n   *\n   * उदाहरण:\n   * इनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * आउटपुट: 8\n   *\n   * इनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * आउटपुट: 6\n   *\n   * इनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * आउटपुट: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple)",
      "hu": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Adott egy fa n csomóponttal és élekkel, valamint egy logikai tömb hasApple, amely jelzi, hogy az egyes csomópontokban van-e alma.\n   * A 0. csomópontból kiindulva térjen vissza a minimális idő, amely szükséges az összes alma összegyűjtéséhez és a 0. csomóponthoz való visszatéréshez.\n   *\n   * Példa:\n   * Bemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\n   * Kimenet: 8\n   *\n   * Bemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\n   * Kimenet: 6\n   *\n   * Bemenet: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\n   * Kimenet: 0\n   */\n  List<Set<Integer>> tree;\n  int[] res;\n\n  public int minTime(int n, int[][] edges, boolean[] hasApple) "
    },
    "prompt_bertscore": {
      "sq": "0.9957701660358621",
      "hy": "0.9786551792539909",
      "bn": "0.9840916927829158",
      "bg": "0.9953532408660698",
      "zh": "0.9921463533642616",
      "fr": "0.9963158036925649",
      "de": "0.9765733342303643",
      "ha": "0.9656760742660282",
      "hi": "0.9931355326618153",
      "hu": "0.9957701660358621"
    },
    "canonical_solution": "  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n",
    "instruction": {
      "en": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nՏվեք Java կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int minTime(int n, int[][] edges, boolean[] hasApple)\n  {\n    tree = new ArrayList<>();\n    res = new int[n];\n    Arrays.fill(res, -1);\n    for (int i = 0; i < n; ++i) tree.add(new HashSet<>());\n    for (int[] e : edges) {\n      tree.get(e[0]).add(e[1]);\n      tree.get(e[1]).add(e[0]);\n    }\n    return dfs(hasApple, 0, -1);\n  }\n\n  int dfs(boolean[] hasApple, int node, int parent) {\n    if (res[node] >= 0) return res[node];\n    int total = 0;\n    for (int child : tree.get(node)) {\n      if (child == parent) continue;\n      int childCost = dfs(hasApple, child, node);\n      if (childCost > 0 || hasApple[child]) total += childCost + 2;\n    }\n    return res[node] = total;\n  }\n\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9465259206000736",
      "bn": "0.8821843757929664",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, false, true, false, true, true, false }\n    ) ==\n    8;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { true, true, true, true, true, true, true }\n    ) ==\n    12;\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,true,false,false,true,false }\n    ) ==\n    6;\n\n    assert solution.minTime(\n      7,\n      new int[][] {\n        { 0, 1 },\n        { 0, 2 },\n        { 1, 4 },\n        { 1, 5 },\n        { 2, 3 },\n        { 2, 6 },\n      },\n      new boolean[] { false,false,false,false,false,false,false }\n    ) ==\n    0;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minTime",
    "signature": "public int minTime(int n, int[][] edges, boolean[] hasApple)",
    "docstring": {
      "en": "Given a tree with n nodes and edges, and a boolean array hasApple indicating if each node has an apple.\nStarting from node 0, return the minimum time required to collect all the apples and return to node 0.\n\nExample:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "sq": "Duke pasur një pemë me n nyje dhe lidhje, dhe një varg boolean hasApple që tregon nëse secila nyje ka një mollë.\nDuke filluar nga nyja 0, kthe kohën minimale të nevojshme për të mbledhur të gjitha mollët dhe për t'u kthyer në nyjen 0.\n\nShembull:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "hy": "Տրված է ծառ n գագաթներով և կողերով, և hasApple բուլյան զանգվածը, որը ցույց է տալիս, թե արդյոք յուրաքանչյուր գագաթում խնձոր կա:\nՍկսելով գագաթ 0-ից, վերադարձնել նվազագույն ժամանակը, որը պահանջվում է բոլոր խնձորները հավաքելու և վերադարձնելու համար գագաթ 0։\n\nՕրինակ:\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nԵլք: 8\n\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nԵլք: 6\n\nՄուտք: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nԵլք: 0",
      "bn": "একটি গাছের nটি নোড এবং এজ দেওয়া আছে, এবং একটি বুলিয়ান অ্যারে hasApple নির্দেশ করে প্রতিটি নোডে একটি আপেল আছে কিনা। \nনোড 0 থেকে শুরু করে, সমস্ত আপেল সংগ্রহ করতে এবং নোড 0-তে ফিরে আসতে প্রয়োজনীয় সর্বনিম্ন সময় ফেরত দিন।\n\nউদাহরণ:\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nআউটপুট: 8\n\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nআউটপুট: 6\n\nইনপুট: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nআউটপুট: 0",
      "bg": "Дадено е дърво с n възли и ребра, и булев масив hasApple, който указва дали всеки възел има ябълка.\nЗапочвайки от възел 0, върнете минималното време, необходимо за събиране на всички ябълки и връщане до възел 0.\n\nПример:\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nИзход: 8\n\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nИзход: 6\n\nВход: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nИзход: 0",
      "zh": "给定一个有 n 个节点和边的树，以及一个布尔数组 hasApple，表示每个节点是否有苹果。  \n从节点 0 开始，返回收集所有苹果并返回到节点 0 所需的最小时间。\n\n示例：  \n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]  \n输出: 8\n\n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]  \n输出: 6\n\n输入: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]  \n输出: 0",
      "fr": "Étant donné un arbre avec n nœuds et arêtes, et un tableau booléen hasApple indiquant si chaque nœud a une pomme. En partant du nœud 0, retournez le temps minimum nécessaire pour collecter toutes les pommes et revenir au nœud 0.\n\nExemple :\nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nSortie : 8\n\nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nSortie : 6\n\nEntrée : n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nSortie : 0",
      "de": "Gegeben ist ein Baum mit n Knoten und Kanten sowie ein boolesches Array hasApple, das angibt, ob jeder Knoten einen Apfel hat. Beginnend bei Knoten 0, gib die minimale Zeit zurück, die benötigt wird, um alle Äpfel zu sammeln und zu Knoten 0 zurückzukehren.\n\nBeispiel:\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nAusgabe: 8\n\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nAusgabe: 6\n\nEingabe: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nAusgabe: 0",
      "ha": "An ba da itace tare da nodes n da edges, da kuma boolean array hasApple yana nuna idan kowanne node yana da apple. Fara daga node 0, dawo da lokacin mafi ƙaranci da ake buƙata don tattara dukkan apples kuma a koma zuwa node 0.\n\nMisali:\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nOutput: 8\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nOutput: 6\n\nInput: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nOutput: 0",
      "hi": "दिए गए n नोड्स और किनारों वाले पेड़ और एक boolean array hasApple, जो इंगित करता है कि प्रत्येक नोड में सेब है या नहीं। \n\nनोड 0 से शुरू करते हुए, सभी सेब इकट्ठा करने और नोड 0 पर लौटने के लिए आवश्यक न्यूनतम समय लौटाएं।\n\nउदाहरण:\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nआउटपुट: 8\n\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nआउटपुट: 6\n\nइनपुट: n = 7, edges = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nआउटपुट: 0",
      "hu": "Adott egy fa n csomóponttal és élekkel, valamint egy logikai tömb hasApple, amely jelzi, hogy van-e alma az egyes csomópontokon. A 0. csomóponttól kezdve térj vissza a minimális idővel, amely szükséges az összes alma összegyűjtéséhez és a 0. csomóponthoz való visszatéréshez.\n\nPélda:\nBemenet: n = 7, élek = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,true,true,false]\nKimenet: 8\n\nBemenet: n = 7, élek = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,true,false,false,true,false]\nKimenet: 6\n\nBemenet: n = 7, élek = [[0,1],[0,2],[1,4],[1,5],[2,3],[2,6]], hasApple = [false,false,false,false,false,false,false]\nKimenet: 0"
    },
    "docstring_bertscore": {
      "sq": "0.9953452956508284",
      "hy": "0.9706203817107486",
      "bn": "0.9931714847607827",
      "bg": "0.9935151153199729",
      "zh": "0.9916285239609036",
      "fr": "1",
      "de": "0.9720328423502878",
      "ha": "0.9897192887383962",
      "hi": "0.967844124875024",
      "hu": "0.983250294488852"
    }
  },
  {
    "task_id": "Java/18",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a string s. You should re-order the string using the following algorithm:\n     * 1. Pick the smallest character from s and append it to the result.\n     * 2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n     * 3. Repeat step 2 until you cannot pick more characters.\n     * 4. Pick the largest character from s and append it to the result.\n     * 5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n     * 6. Repeat step 5 until you cannot pick more characters.\n     * 7. Repeat the steps from 1 to 6 until you pick all characters from s.\n     * In each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\n     * Return the result string after sorting s with this algorithm.\n     */\n    public String sortString(String s)",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një varg s. Ju duhet të riorganizoni vargun duke përdorur algoritmin e mëposhtëm:\n     * 1. Zgjidhni karakterin më të vogël nga s dhe shtojeni atë në rezultatin.\n     * 2. Zgjidhni karakterin më të vogël nga s që është më i madh se karakteri i fundit i shtuar në rezultat dhe shtojeni atë.\n     * 3. Përsëritni hapin 2 derisa të mos mund të zgjidhni më shumë karaktere.\n     * 4. Zgjidhni karakterin më të madh nga s dhe shtojeni atë në rezultatin.\n     * 5. Zgjidhni karakterin më të madh nga s që është më i vogël se karakteri i fundit i shtuar në rezultat dhe shtojeni atë.\n     * 6. Përsëritni hapin 5 derisa të mos mund të zgjidhni më shumë karaktere.\n     * 7. Përsëritni hapat nga 1 deri në 6 derisa të zgjidhni të gjithë karakteret nga s.\n     * Në secilin hap, nëse karakteri më i vogël ose më i madh shfaqet më shumë se një herë, ju mund të zgjidhni çdo shfaqje dhe ta shtoni atë në rezultat.\n     * Kthejeni vargun rezultat pas renditjes së s me këtë algoritëm.\n     */\n    public String sortString(String s)",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է s տողը։ Դուք պետք է վերադասավորեք տողը հետևյալ ալգորիթմի միջոցով.\n     * 1. Ընտրեք s-ի ամենափոքր սիմվոլը և կցեք այն արդյունքին։\n     * 2. Ընտրեք s-ի ամենափոքր սիմվոլը, որը մեծ է արդյունքին վերջին կցված սիմվոլից, և կցեք այն։\n     * 3. Կրկնեք 2-րդ քայլը, մինչև չկարողանաք ընտրել ավելի շատ սիմվոլներ։\n     * 4. Ընտրեք s-ի ամենամեծ սիմվոլը և կցեք այն արդյունքին։\n     * 5. Ընտրեք s-ի ամենամեծ սիմվոլը, որը փոքր է արդյունքին վերջին կցված սիմվոլից, և կցեք այն։\n     * 6. Կրկնեք 5-րդ քայլը, մինչև չկարողանաք ընտրել ավելի շատ սիմվոլներ։\n     * 7. Կրկնեք քայլերը 1-ից 6-ը, մինչև չընտրեք s-ի բոլոր սիմվոլները։\n     * Յուրաքանչյուր քայլում, եթե ամենափոքր կամ ամենամեծ սիմվոլը հայտնվում է մեկից ավելի անգամ, կարող եք ընտրել ցանկացած հանդիպում և կցել այն արդյունքին։\n     * Վերադարձնել արդյունքի տողը՝ s-ը այս ալգորիթմով դասավորելուց հետո։\n     */\n    public String sortString(String s)",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * একটি স্ট্রিং s দেওয়া আছে। আপনাকে নিম্নলিখিত অ্যালগরিদম ব্যবহার করে স্ট্রিংটি পুনরায় সাজাতে হবে:\n     * 1. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n     * 2. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে বড় এবং এটি যোগ করুন।\n     * 3. আপনি আর অক্ষর বেছে নিতে না পারা পর্যন্ত ধাপ 2 পুনরাবৃত্তি করুন।\n     * 4. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n     * 5. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে ছোট এবং এটি যোগ করুন।\n     * 6. আপনি আর অক্ষর বেছে নিতে না পারা পর্যন্ত ধাপ 5 পুনরাবৃত্তি করুন।\n     * 7. s থেকে সমস্ত অক্ষর বেছে না নেওয়া পর্যন্ত ধাপ 1 থেকে 6 পুনরাবৃত্তি করুন।\n     * প্রতিটি ধাপে, যদি সবচেয়ে ছোট বা সবচেয়ে বড় অক্ষর একাধিকবার উপস্থিত হয় তবে আপনি যেকোনো একটি বেছে নিয়ে ফলাফলে যোগ করতে পারেন।\n     * এই অ্যালগরিদম দিয়ে s সাজানোর পরে ফলাফল স্ট্রিংটি ফেরত দিন।\n     */\n    public String sortString(String s)",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Даден е низ s. Трябва да пренаредите низа, използвайки следния алгоритъм:\n     * 1. Изберете най-малкия символ от s и го добавете към резултата.\n     * 2. Изберете най-малкия символ от s, който е по-голям от последния добавен символ към резултата, и го добавете.\n     * 3. Повторете стъпка 2, докато не можете да изберете повече символи.\n     * 4. Изберете най-големия символ от s и го добавете към резултата.\n     * 5. Изберете най-големия символ от s, който е по-малък от последния добавен символ към резултата, и го добавете.\n     * 6. Повторете стъпка 5, докато не можете да изберете повече символи.\n     * 7. Повторете стъпките от 1 до 6, докато не изберете всички символи от s.\n     * Във всяка стъпка, ако най-малкият или най-големият символ се появява повече от веднъж, можете да изберете всяко появяване и да го добавите към резултата.\n     * Върнете резултатния низ след сортиране на s с този алгоритъм.\n     */\n    public String sortString(String s)",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个字符串s。你应该使用以下算法重新排序字符串：\n     * 1. 从s中选择最小的字符并将其附加到结果中。\n     * 2. 从s中选择比结果中最后附加的字符大的最小字符并附加它。\n     * 3. 重复步骤2，直到无法选择更多字符。\n     * 4. 从s中选择最大的字符并将其附加到结果中。\n     * 5. 从s中选择比结果中最后附加的字符小的最大字符并附加它。\n     * 6. 重复步骤5，直到无法选择更多字符。\n     * 7. 重复步骤1到6，直到从s中选择所有字符。\n     * 在每一步中，如果最小或最大的字符出现多次，你可以选择任何一个出现并将其附加到结果中。\n     * 返回使用此算法排序后的结果字符串。\n     */\n    public String sortString(String s)",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné une chaîne de caractères s. Vous devez réorganiser la chaîne en utilisant l'algorithme suivant :\n     * 1. Choisissez le plus petit caractère de s et ajoutez-le au résultat.\n     * 2. Choisissez le plus petit caractère de s qui est plus grand que le dernier caractère ajouté au résultat et ajoutez-le.\n     * 3. Répétez l'étape 2 jusqu'à ce que vous ne puissiez plus choisir de caractères.\n     * 4. Choisissez le plus grand caractère de s et ajoutez-le au résultat.\n     * 5. Choisissez le plus grand caractère de s qui est plus petit que le dernier caractère ajouté au résultat et ajoutez-le.\n     * 6. Répétez l'étape 5 jusqu'à ce que vous ne puissiez plus choisir de caractères.\n     * 7. Répétez les étapes de 1 à 6 jusqu'à ce que vous ayez choisi tous les caractères de s.\n     * À chaque étape, si le plus petit ou le plus grand caractère apparaît plus d'une fois, vous pouvez choisir n'importe quelle occurrence et l'ajouter au résultat.\n     * Retournez la chaîne de résultat après avoir trié s avec cet algorithme.\n     */\n    public String sortString(String s)",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben ein String s. Sie sollten den String mit dem folgenden Algorithmus neu ordnen:\n     * 1. Wählen Sie das kleinste Zeichen aus s und fügen Sie es dem Ergebnis hinzu.\n     * 2. Wählen Sie das kleinste Zeichen aus s, das größer ist als das zuletzt hinzugefügte Zeichen zum Ergebnis, und fügen Sie es hinzu.\n     * 3. Wiederholen Sie Schritt 2, bis Sie keine weiteren Zeichen auswählen können.\n     * 4. Wählen Sie das größte Zeichen aus s und fügen Sie es dem Ergebnis hinzu.\n     * 5. Wählen Sie das größte Zeichen aus s, das kleiner ist als das zuletzt hinzugefügte Zeichen zum Ergebnis, und fügen Sie es hinzu.\n     * 6. Wiederholen Sie Schritt 5, bis Sie keine weiteren Zeichen auswählen können.\n     * 7. Wiederholen Sie die Schritte von 1 bis 6, bis Sie alle Zeichen aus s ausgewählt haben.\n     * In jedem Schritt, wenn das kleinste oder das größte Zeichen mehrmals vorkommt, können Sie ein beliebiges Vorkommen auswählen und es dem Ergebnis hinzufügen.\n     * Geben Sie den Ergebnis-String zurück, nachdem s mit diesem Algorithmus sortiert wurde.\n     */\n    public String sortString(String s)",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani kirtani s. Ya kamata ka sake tsara kirtanin ta amfani da wannan dabarar:\n     * 1. Zaɓi ƙaramin harafi daga s kuma haɗa shi zuwa sakamakon.\n     * 2. Zaɓi ƙaramin harafi daga s wanda ya fi ƙaramin harafin da aka ƙara zuwa sakamakon kuma haɗa shi.\n     * 3. Maimaita mataki na 2 har sai ba za ka iya zaɓar karin haruffa ba.\n     * 4. Zaɓi mafi girman harafi daga s kuma haɗa shi zuwa sakamakon.\n     * 5. Zaɓi mafi girman harafi daga s wanda ya fi ƙaramin harafin da aka ƙara zuwa sakamakon kuma haɗa shi.\n     * 6. Maimaita mataki na 5 har sai ba za ka iya zaɓar karin haruffa ba.\n     * 7. Maimaita matakan daga 1 zuwa 6 har sai ka zaɓi duk haruffa daga s.\n     * A kowane mataki, Idan ƙaramin ko mafi girman harafi ya bayyana fiye da sau ɗaya za ka iya zaɓar kowanne daga cikinsu kuma haɗa shi zuwa sakamakon.\n     * Mayar da kirtanin sakamakon bayan an tsara s da wannan dabarar.\n     */\n    public String sortString(String s)",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए स्ट्रिंग s के लिए। आपको निम्नलिखित एल्गोरिदम का उपयोग करके स्ट्रिंग को पुनः क्रमबद्ध करना चाहिए:\n     * 1. s से सबसे छोटा वर्ण चुनें और उसे परिणाम में जोड़ें।\n     * 2. s से सबसे छोटा वर्ण चुनें जो परिणाम में अंतिम जोड़े गए वर्ण से बड़ा हो और उसे जोड़ें।\n     * 3. चरण 2 को तब तक दोहराएं जब तक आप अधिक वर्ण नहीं चुन सकते।\n     * 4. s से सबसे बड़ा वर्ण चुनें और उसे परिणाम में जोड़ें।\n     * 5. s से सबसे बड़ा वर्ण चुनें जो परिणाम में अंतिम जोड़े गए वर्ण से छोटा हो और उसे जोड़ें।\n     * 6. चरण 5 को तब तक दोहराएं जब तक आप अधिक वर्ण नहीं चुन सकते।\n     * 7. चरण 1 से 6 तक तब तक दोहराएं जब तक आप s से सभी वर्ण नहीं चुन लेते।\n     * प्रत्येक चरण में, यदि सबसे छोटा या सबसे बड़ा वर्ण एक से अधिक बार आता है तो आप किसी भी आवृत्ति को चुन सकते हैं और उसे परिणाम में जोड़ सकते हैं।\n     * इस एल्गोरिदम के साथ s को क्रमबद्ध करने के बाद परिणाम स्ट्रिंग लौटाएं।\n     */\n    public String sortString(String s)",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy s string. Újra kell rendezned a stringet a következő algoritmus segítségével:\n     * 1. Válaszd ki a legkisebb karaktert s-ből, és add hozzá az eredményhez.\n     * 2. Válaszd ki a legkisebb karaktert s-ből, amely nagyobb, mint az utoljára hozzáadott karakter az eredményhez, és add hozzá.\n     * 3. Ismételd meg a 2. lépést, amíg nem tudsz több karaktert választani.\n     * 4. Válaszd ki a legnagyobb karaktert s-ből, és add hozzá az eredményhez.\n     * 5. Válaszd ki a legnagyobb karaktert s-ből, amely kisebb, mint az utoljára hozzáadott karakter az eredményhez, és add hozzá.\n     * 6. Ismételd meg az 5. lépést, amíg nem tudsz több karaktert választani.\n     * 7. Ismételd meg az 1-től 6-ig lépéseket, amíg ki nem választod az összes karaktert s-ből.\n     * Minden lépésben, ha a legkisebb vagy legnagyobb karakter többször is előfordul, bármelyik előfordulást választhatod, és hozzáadhatod az eredményhez.\n     * Add vissza az eredmény stringet, miután ezzel az algoritmussal rendezted s-t.\n     */\n    public String sortString(String s)"
    },
    "prompt_bertscore": {
      "sq": "0.9485086490635639",
      "hy": "0.9697714354622056",
      "bn": "0.941341667655063",
      "bg": "0.9641380792256751",
      "zh": "0.9559153773419738",
      "fr": "0.9390572196427808",
      "de": "0.9433388961363688",
      "ha": "0.9423765319402548",
      "hi": "0.9825540950033247",
      "hu": "0.9786404806057943"
    },
    "canonical_solution": "    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }",
    "instruction": {
      "en": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nՏրամադրել Java կոդի կարճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nजावा कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public String sortString(String s)\n    {\n\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n        StringBuilder sb = new StringBuilder();\n        while (sb.length() < s.length()) {\n            addChar(count, sb, true);\n            addChar(count, sb, false);\n        }\n        return sb.toString();\n    }\n\n    private void addChar(int[] count, StringBuilder sb, boolean asc) {\n        for (int i = 0; i < 26; i++) {\n            int j = asc ? i : 25 - i;\n            if (count[j]-- > 0) {\n                sb.append((char) (j + 'a'));\n            }\n        }\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9070264816578568",
      "bn": "0.8821843757929664",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9368240182688056",
      "hu": "0.9312252237185752"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.sortString(\"aaaabbbbcccc\").equals(\"abccbaabccba\");\n        assert solution.sortString(\"rat\").equals(\"art\");\n        assert solution.sortString(\"leetcode\").equals(\"cdelotee\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "sortString",
    "signature": "public String sortString(String s)",
    "docstring": {
      "en": "Given a string s. You should re-order the string using the following algorithm:\n1. Pick the smallest character from s and append it to the result.\n2. Pick the smallest character from s which is greater than the last appended character to the result and append it.\n3. Repeat step 2 until you cannot pick more characters.\n4. Pick the largest character from s and append it to the result.\n5. Pick the largest character from s which is smaller than the last appended character to the result and append it.\n6. Repeat step 5 until you cannot pick more characters.\n7. Repeat the steps from 1 to 6 until you pick all characters from s.\nIn each step, If the smallest or the largest character appears more than once you can choose any occurrence and append it to the result.\nReturn the result string after sorting s with this algorithm.",
      "sq": "Duke pasur një varg s. Ju duhet të ri-renditni vargun duke përdorur algoritmin e mëposhtëm:\n1. Zgjidhni karakterin më të vogël nga s dhe shtojeni atë në rezultatin.\n2. Zgjidhni karakterin më të vogël nga s i cili është më i madh se karakteri i fundit i shtuar në rezultat dhe shtojeni atë.\n3. Përsëritni hapin 2 derisa të mos mund të zgjidhni më shumë karaktere.\n4. Zgjidhni karakterin më të madh nga s dhe shtojeni atë në rezultatin.\n5. Zgjidhni karakterin më të madh nga s i cili është më i vogël se karakteri i fundit i shtuar në rezultat dhe shtojeni atë.\n6. Përsëritni hapin 5 derisa të mos mund të zgjidhni më shumë karaktere.\n7. Përsëritni hapat nga 1 deri në 6 derisa të zgjidhni të gjithë karakteret nga s.\nNë secilin hap, nëse karakteri më i vogël ose më i madh shfaqet më shumë se një herë, ju mund të zgjidhni çdo rast dhe ta shtoni atë në rezultat.\nKtheni vargun rezultat pas renditjes së s me këtë algoritëm.",
      "hy": "Տրված է տող `s`: Դուք պետք է վերադասավորեք տողը հետևյալ ալգորիթմի միջոցով.\n1. Ընտրեք ամենափոքր սիմվոլը `s`-ից և ավելացրեք այն արդյունքին:\n2. Ընտրեք ամենափոքր սիմվոլը `s`-ից, որը մեծ է արդյունքին վերջին ավելացված սիմվոլից, և ավելացրեք այն:\n3. Կրկնեք 2-րդ քայլը, մինչև չկարողանաք այլ սիմվոլներ ընտրել:\n4. Ընտրեք ամենամեծ սիմվոլը `s`-ից և ավելացրեք այն արդյունքին:\n5. Ընտրեք ամենամեծ սիմվոլը `s`-ից, որը փոքր է արդյունքին վերջին ավելացված սիմվոլից, և ավելացրեք այն:\n6. Կրկնեք 5-րդ քայլը, մինչև չկարողանաք այլ սիմվոլներ ընտրել:\n7. Կրկնեք քայլերը 1-ից 6-ը, մինչև չընտրեք բոլոր սիմվոլները `s`-ից:\nՅուրաքանչյուր քայլում, եթե ամենափոքր կամ ամենամեծ սիմվոլը հայտնվում է մեկից ավելի անգամ, կարող եք ընտրել ցանկացած հանդիպում և ավելացնել այն արդյունքին:\nՎերադարձեք արդյունքի տողը `s`-ը այս ալգորիթմով դասավորելուց հետո:",
      "bn": "একটি স্ট্রিং s দেওয়া হয়েছে। আপনাকে নিম্নলিখিত অ্যালগরিদম ব্যবহার করে স্ট্রিংটি পুনরায় সাজাতে হবে:\n1. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n2. s থেকে সবচেয়ে ছোট অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে বড় এবং এটি যোগ করুন।\n3. ধাপ 2 পুনরাবৃত্তি করুন যতক্ষণ না আপনি আরও অক্ষর বেছে নিতে পারেন।\n4. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন এবং এটি ফলাফলে যোগ করুন।\n5. s থেকে সবচেয়ে বড় অক্ষরটি বেছে নিন যা ফলাফলে সর্বশেষ যোগ করা অক্ষরের চেয়ে ছোট এবং এটি যোগ করুন।\n6. ধাপ 5 পুনরাবৃত্তি করুন যতক্ষণ না আপনি আরও অক্ষর বেছে নিতে পারেন।\n7. s থেকে সমস্ত অক্ষর বেছে না নেওয়া পর্যন্ত ধাপ 1 থেকে 6 পুনরাবৃত্তি করুন।\nপ্রতিটি ধাপে, যদি সবচেয়ে ছোট বা সবচেয়ে বড় অক্ষর একাধিকবার উপস্থিত হয় তবে আপনি যেকোনো একটি উপস্থিতি বেছে নিতে পারেন এবং এটি ফলাফলে যোগ করতে পারেন।\nএই অ্যালগরিদম দিয়ে s সাজানোর পরে ফলাফল স্ট্রিংটি ফেরত দিন।",
      "bg": "Даден е низ s. Трябва да пренаредите низа, използвайки следния алгоритъм:\n1. Изберете най-малкия символ от s и го добавете към резултата.\n2. Изберете най-малкия символ от s, който е по-голям от последния добавен символ към резултата, и го добавете.\n3. Повторете стъпка 2, докато не можете да изберете повече символи.\n4. Изберете най-големия символ от s и го добавете към резултата.\n5. Изберете най-големия символ от s, който е по-малък от последния добавен символ към резултата, и го добавете.\n6. Повторете стъпка 5, докато не можете да изберете повече символи.\n7. Повторете стъпките от 1 до 6, докато не изберете всички символи от s.\nВъв всяка стъпка, ако най-малкият или най-големият символ се появява повече от веднъж, можете да изберете което и да е появяване и да го добавите към резултата.\nВърнете резултатния низ след сортиране на s с този алгоритъм.",
      "zh": "给定一个字符串 s。你应该使用以下算法重新排序字符串：\n1. 从 s 中选择最小的字符并将其附加到结果中。\n2. 从 s 中选择比结果中最后附加的字符大的最小字符并将其附加。\n3. 重复步骤 2，直到无法选择更多字符。\n4. 从 s 中选择最大的字符并将其附加到结果中。\n5. 从 s 中选择比结果中最后附加的字符小的最大字符并将其附加。\n6. 重复步骤 5，直到无法选择更多字符。\n7. 重复步骤 1 到 6，直到从 s 中选择所有字符。\n在每一步中，如果最小或最大的字符出现多次，你可以选择任意一个出现并将其附加到结果中。\n返回使用此算法排序 s 后的结果字符串。",
      "fr": "Étant donné une chaîne de caractères s. Vous devez réorganiser la chaîne en utilisant l'algorithme suivant :\n1. Choisissez le plus petit caractère de s et ajoutez-le au résultat.\n2. Choisissez le plus petit caractère de s qui est plus grand que le dernier caractère ajouté au résultat et ajoutez-le.\n3. Répétez l'étape 2 jusqu'à ce que vous ne puissiez plus choisir de caractères.\n4. Choisissez le plus grand caractère de s et ajoutez-le au résultat.\n5. Choisissez le plus grand caractère de s qui est plus petit que le dernier caractère ajouté au résultat et ajoutez-le.\n6. Répétez l'étape 5 jusqu'à ce que vous ne puissiez plus choisir de caractères.\n7. Répétez les étapes de 1 à 6 jusqu'à ce que vous ayez choisi tous les caractères de s.\nÀ chaque étape, si le plus petit ou le plus grand caractère apparaît plus d'une fois, vous pouvez choisir n'importe quelle occurrence et l'ajouter au résultat.\nRetournez la chaîne de résultat après avoir trié s avec cet algorithme.",
      "de": "Gegeben ein String s. Sie sollten den String mit dem folgenden Algorithmus neu ordnen:\n1. Wählen Sie das kleinste Zeichen aus s und hängen Sie es an das Ergebnis an.\n2. Wählen Sie das kleinste Zeichen aus s, das größer ist als das zuletzt angehängte Zeichen zum Ergebnis, und hängen Sie es an.\n3. Wiederholen Sie Schritt 2, bis Sie keine weiteren Zeichen mehr auswählen können.\n4. Wählen Sie das größte Zeichen aus s und hängen Sie es an das Ergebnis an.\n5. Wählen Sie das größte Zeichen aus s, das kleiner ist als das zuletzt angehängte Zeichen zum Ergebnis, und hängen Sie es an.\n6. Wiederholen Sie Schritt 5, bis Sie keine weiteren Zeichen mehr auswählen können.\n7. Wiederholen Sie die Schritte 1 bis 6, bis Sie alle Zeichen aus s ausgewählt haben.\nIn jedem Schritt, wenn das kleinste oder größte Zeichen mehr als einmal vorkommt, können Sie ein beliebiges Vorkommen auswählen und es an das Ergebnis anhängen.\nGeben Sie den Ergebnisstring zurück, nachdem s mit diesem Algorithmus sortiert wurde.",
      "ha": "An ba da wata igiyar kirtani s. Ya kamata ka sake tsara igiyar kirtani ta amfani da wannan hanyar:\n1. Zaɓi mafi ƙarancin hali daga s kuma haɗa shi zuwa sakamakon.\n2. Zaɓi mafi ƙarancin hali daga s wanda ya fi wanda aka haɗa a baya zuwa sakamakon kuma haɗa shi.\n3. Maimaita mataki na 2 har sai ba za ka iya zaɓar karin haruffa ba.\n4. Zaɓi mafi girman hali daga s kuma haɗa shi zuwa sakamakon.\n5. Zaɓi mafi girman hali daga s wanda ya fi ƙaramin wanda aka haɗa a baya zuwa sakamakon kuma haɗa shi.\n6. Maimaita mataki na 5 har sai ba za ka iya zaɓar karin haruffa ba.\n7. Maimaita matakan daga 1 zuwa 6 har sai ka zaɓi duk haruffa daga s.\nA kowane mataki, Idan mafi ƙarancin ko mafi girman hali ya bayyana fiye da sau ɗaya zaka iya zaɓar kowanne bayyanar kuma haɗa shi zuwa sakamakon.\nMayar da igiyar kirtani ta sakamakon bayan tsara s da wannan hanyar.",
      "hi": "दिए गए स्ट्रिंग s को पुनः क्रमबद्ध करें निम्नलिखित एल्गोरिदम का उपयोग करके:\n1. s से सबसे छोटा वर्ण चुनें और इसे परिणाम में जोड़ें।\n2. s से सबसे छोटा वर्ण चुनें जो परिणाम में अंतिम जोड़े गए वर्ण से बड़ा हो और इसे जोड़ें।\n3. चरण 2 को तब तक दोहराएं जब तक आप और वर्ण नहीं चुन सकते।\n4. s से सबसे बड़ा वर्ण चुनें और इसे परिणाम में जोड़ें।\n5. s से सबसे बड़ा वर्ण चुनें जो परिणाम में अंतिम जोड़े गए वर्ण से छोटा हो और इसे जोड़ें।\n6. चरण 5 को तब तक दोहराएं जब तक आप और वर्ण नहीं चुन सकते।\n7. चरण 1 से 6 तक तब तक दोहराएं जब तक आप s से सभी वर्ण नहीं चुन लेते।\nप्रत्येक चरण में, यदि सबसे छोटा या सबसे बड़ा वर्ण एक से अधिक बार आता है तो आप किसी भी उपस्थिति को चुन सकते हैं और इसे परिणाम में जोड़ सकते हैं।\nइस एल्गोरिदम के साथ s को क्रमबद्ध करने के बाद परिणाम स्ट्रिंग लौटाएं।",
      "hu": "Adott egy s karakterlánc. Újra kell rendezned a karakterláncot a következő algoritmus szerint:\n1. Válaszd ki a legkisebb karaktert s-ből, és add hozzá az eredményhez.\n2. Válaszd ki a legkisebb karaktert s-ből, amely nagyobb, mint az utoljára hozzáadott karakter az eredményhez, és add hozzá.\n3. Ismételd meg a 2. lépést, amíg nem tudsz több karaktert választani.\n4. Válaszd ki a legnagyobb karaktert s-ből, és add hozzá az eredményhez.\n5. Válaszd ki a legnagyobb karaktert s-ből, amely kisebb, mint az utoljára hozzáadott karakter az eredményhez, és add hozzá.\n6. Ismételd meg az 5. lépést, amíg nem tudsz több karaktert választani.\n7. Ismételd meg az 1-től 6-ig terjedő lépéseket, amíg az összes karaktert ki nem választod s-ből.\nMinden lépésben, ha a legkisebb vagy a legnagyobb karakter többször is előfordul, bármelyik előfordulást választhatod, és hozzáadhatod az eredményhez.\nAdd vissza az eredmény karakterláncot, miután ezzel az algoritmussal rendezted s-t."
    },
    "docstring_bertscore": {
      "sq": "0.938420410641183",
      "hy": "0.8839217957358786",
      "bn": "0.9215263008430226",
      "bg": "0.935596879774772",
      "zh": "0.950934720537524",
      "fr": "0.9295255435480596",
      "de": "0.9528334283498365",
      "ha": "0.936576127553274",
      "hi": "0.9269514924402285",
      "hu": "0.9332043768352067"
    }
  },
  {
    "task_id": "Java/19",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Check if it is possible to split the given integer array into two non-empty arrays\n     * with the same average.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Kontrolloni nëse është e mundur të ndahet vargu i dhënë i numrave të plotë në dy vargje jo-bosh\n     * me të njëjtën mesatare.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ստուգել, արդյոք հնարավոր է տրված ամբողջ թվերի զանգվածը բաժանել երկու ոչ դատարկ զանգվածների,\n     * որոնք ունեն նույն միջին արժեքը։\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * প্রদত্ত পূর্ণসংখ্যার অ্যারে দুটি নন-এম্পটি অ্যারেতে ভাগ করা সম্ভব কিনা তা পরীক্ষা করুন\n     * যাদের গড় একই।\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Проверете дали е възможно да се раздели даденият масив от цели числа на два непразни масива\n     * със същата средна стойност.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 检查是否可以将给定的整数数组拆分为两个具有相同平均值的非空数组。\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Vérifiez s'il est possible de diviser le tableau d'entiers donné en deux tableaux non vides\n     * avec la même moyenne.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Überprüfen, ob es möglich ist, das gegebene Integer-Array in zwei nicht-leere Arrays\n     * mit dem gleichen Durchschnitt aufzuteilen.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duba idan yana yiwuwa a raba jerin lambobi na duka zuwa cikin jerin lambobi guda biyu\n     * da ba su da komai kuma suna da matsakaici iri ɗaya.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * जाँचें कि दिए गए पूर्णांक array को दो गैर-खाली arrays में समान औसत के साथ विभाजित करना संभव है या नहीं।\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Ellenőrizze, hogy lehetséges-e a megadott egész szám tömböt két nem üres tömbre osztani\n     * ugyanazzal az átlaggal.\n     *\n     * >>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\n     * true\n     *\n     * >>> splitArraySameAverage(new int[]{3,1})\n     * false\n     */\n    public boolean splitArraySameAverage(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "0.9939010541503237",
      "hy": "0.9728853639456895",
      "bn": "0.9822275466569034",
      "bg": "0.984309590310911",
      "zh": "0.9773072734882882",
      "fr": "0.9939010541503237",
      "de": "1",
      "ha": "0.9308565657313744",
      "hi": "0.9942595819880917",
      "hu": "0.999066437209136"
    },
    "canonical_solution": "    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }",
    "instruction": {
      "en": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nՏվեք Java կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nনিচের জাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nДайте кратко описание на Java кода на български език, използвайки максимум 500 знака.",
      "zh": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public boolean splitArraySameAverage(int[] nums)\n    {\n\n        int n = nums.length;\n        int sum = Arrays.stream(nums).sum();\n        Arrays.sort(nums);\n        for (int len = 1; len <= n / 2; ++len) {\n            if (sum * len % n == 0 && combinationSum(nums, sum * len / n, len, n)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private boolean combinationSum(int[] nums, int target, int k, int n) {\n        if (k == 0) return target == 0;\n        if (target < k * nums[0] || target > k * nums[n - 1]) return false;\n        for (int i = n - 1; i >= k - 1; --i) {\n            if (nums[i] <= target && combinationSum(nums, target - nums[i], k - 1, i)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9465259206000736",
      "bn": "0.8712875130893925",
      "bg": "0.8421186416344191",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9353706397707733",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 9}) == false;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 10}) == true;\n        assert solution.splitArraySameAverage(new int[]{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}) == true;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "splitArraySameAverage",
    "signature": "public boolean splitArraySameAverage(int[] nums)",
    "docstring": {
      "en": "Check if it is possible to split the given integer array into two non-empty arrays\nwith the same average.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "sq": "Kontrolloni nëse është e mundur të ndani vargun e dhënë të numrave të plotë në dy vargje jo-bosh me mesatare të njëjtë.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "hy": "Ստուգել, արդյոք հնարավոր է տրված ամբողջ թվերի զանգվածը բաժանել երկու ոչ դատարկ զանգվածների՝\nնույն միջին արժեքով:\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "bn": "প্রদত্ত পূর্ণসংখ্যার অ্যারেটিকে দুটি খালি নয় এমন অ্যারেতে ভাগ করা সম্ভব কিনা তা পরীক্ষা করুন\nযাদের গড় একই।\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "bg": "Проверете дали е възможно да се раздели даденият масив от цели числа на два непразни масива със същата средна стойност.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "zh": "检查是否可以将给定的整数数组分成两个非空数组，且它们的平均值相同。\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "fr": "Vérifiez s'il est possible de diviser le tableau d'entiers donné en deux tableaux non vides avec la même moyenne.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "de": "Überprüfen Sie, ob es möglich ist, das gegebene ganzzahlige Array in zwei nicht-leere Arrays mit dem gleichen Durchschnitt aufzuteilen.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "ha": "Duba idan yana yiwuwa a raba jerin lambobi na integer da aka bayar zuwa jerin lambobi guda biyu masu cike da lambobi\nda ke da matsakaici iri ɗaya.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "hi": "दिए गए पूर्णांक array को दो गैर-खाली arrays में विभाजित करना संभव है या नहीं, यह जांचें\nजिनका औसत समान है।\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse",
      "hu": "Ellenőrizze, hogy lehetséges-e a megadott egész szám tömböt két nem üres tömbre osztani\nugyanazzal az átlaggal.\n\n>>> splitArraySameAverage(new int[]{1,2,3,4,5,6,7,8})\ntrue\n\n>>> splitArraySameAverage(new int[]{3,1})\nfalse"
    },
    "docstring_bertscore": {
      "sq": "0.9919820860391457",
      "hy": "0.9728855625760705",
      "bn": "0.9953121243771956",
      "bg": "0.9809318806814128",
      "zh": "0.9782895007225056",
      "fr": "0.9919820860391457",
      "de": "1",
      "ha": "0.923265309828983",
      "hi": "0.985687092003388",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/20",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array cost where cost[i] is the cost of ith step on a staircase,\n     * return the minimum cost to reach the top of the floor.\n     * You can either start from the step with index 0 or the step with index 1.\n     *\n     * Example:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explanation: You will start at index 1.\n     * - Pay 15 and climb two steps to reach the top.\n     * The total cost is 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explanation: You will start at index 0.\n     * - Pay 1 and climb two steps to reach index 2.\n     * - Pay 1 and climb two steps to reach index 4.\n     * - Pay 1 and climb two steps to reach index 6.\n     * - Pay 1 and climb one step to reach index 7.\n     * - Pay 1 and climb two steps to reach index 9.\n     * - Pay 1 and climb one step to reach the top.\n     * The total cost is 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një varg të plotë cost ku cost[i] është kostoja e hapit të i-të në një shkallë,\n     * kthe minimumin e kostos për të arritur majën e katit.\n     * Ju mund të filloni ose nga hapi me indeks 0 ose nga hapi me indeks 1.\n     *\n     * Shembull:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Shpjegim: Ju do të filloni në indeksin 1.\n     * - Paguani 15 dhe ngjitni dy hapa për të arritur majën.\n     * Kostoja totale është 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Shpjegim: Ju do të filloni në indeksin 0.\n     * - Paguani 1 dhe ngjitni dy hapa për të arritur indeksin 2.\n     * - Paguani 1 dhe ngjitni dy hapa për të arritur indeksin 4.\n     * - Paguani 1 dhe ngjitni dy hapa për të arritur indeksin 6.\n     * - Paguani 1 dhe ngjitni një hap për të arritur indeksin 7.\n     * - Paguani 1 dhe ngjitni dy hapa për të arritur indeksin 9.\n     * - Paguani 1 dhe ngjitni një hap për të arritur majën.\n     * Kostoja totale është 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "hy": "class Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված cost, որտեղ cost[i]-ն աստիճանավանդակի i-րդ աստիճանի արժեքն է,\n     * վերադարձնել նվազագույն արժեքը, որպեսզի հասնեք հարկի գագաթին:\n     * Դուք կարող եք սկսել կամ 0 ինդեքսով աստիճանից, կամ 1 ինդեքսով աստիճանից:\n     *\n     * Օրինակ:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Բացատրություն: Դուք կսկսեք 1 ինդեքսից:\n     * - Վճարեք 15 և բարձրացեք երկու աստիճան՝ հասնելու գագաթին:\n     * Ընդհանուր արժեքը 15 է:\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Բացատրություն: Դուք կսկսեք 0 ինդեքսից:\n     * - Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 2 ինդեքսին:\n     * - Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 4 ինդեքսին:\n     * - Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 6 ինդեքսին:\n     * - Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու 7 ինդեքսին:\n     * - Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 9 ինդեքսին:\n     * - Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու գագաթին:\n     * Ընդհանուր արժեքը 6 է:\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "bn": "class Solution {\n    /**\n     * একটি পূর্ণসংখ্যা অ্যারে দেওয়া হয়েছে যেখানে cost[i] হল সিঁড়ির ith ধাপের খরচ,\n     * মেঝের শীর্ষে পৌঁছানোর জন্য ন্যূনতম খরচ ফেরত দিন।\n     * আপনি হয়তো সূচক 0 সহ ধাপ থেকে বা সূচক 1 সহ ধাপ থেকে শুরু করতে পারেন।\n     *\n     * উদাহরণ:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * ব্যাখ্যা: আপনি সূচক 1 এ শুরু করবেন।\n     * - 15 প্রদান করুন এবং শীর্ষে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * মোট খরচ 15।\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * ব্যাখ্যা: আপনি সূচক 0 এ শুরু করবেন।\n     * - 1 প্রদান করুন এবং সূচক 2 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * - 1 প্রদান করুন এবং সূচক 4 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * - 1 প্রদান করুন এবং সূচক 6 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * - 1 প্রদান করুন এবং সূচক 7 এ পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\n     * - 1 প্রদান করুন এবং সূচক 9 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n     * - 1 প্রদান করুন এবং শীর্ষে পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\n     * মোট খরচ 6।\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "bg": "class Solution {\n    /**\n     * Даден е масив от цели числа cost, където cost[i] е цената на i-тата стъпка на стълбище,\n     * върнете минималната цена за достигане до върха на етажа.\n     * Можете да започнете или от стъпката с индекс 0, или от стъпката с индекс 1.\n     *\n     * Пример:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Обяснение: Ще започнете от индекс 1.\n     * - Платете 15 и се изкачете две стъпки, за да достигнете върха.\n     * Общата цена е 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Обяснение: Ще започнете от индекс 0.\n     * - Платете 1 и се изкачете две стъпки, за да достигнете индекс 2.\n     * - Платете 1 и се изкачете две стъпки, за да достигнете индекс 4.\n     * - Платете 1 и се изкачете две стъпки, за да достигнете индекс 6.\n     * - Платете 1 и се изкачете една стъпка, за да достигнете индекс 7.\n     * - Платете 1 и се изкачете две стъпки, за да достигнете индекс 9.\n     * - Платете 1 и се изкачете една стъпка, за да достигнете върха.\n     * Общата цена е 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "zh": "class Solution {\n    /**\n     * 给定一个整数数组 cost，其中 cost[i] 是楼梯上第 i 阶的成本，\n     * 返回到达楼层顶部的最低成本。\n     * 你可以从索引为 0 的阶梯开始，或者从索引为 1 的阶梯开始。\n     *\n     * 示例:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * 解释: 你将从索引 1 开始。\n     * - 支付 15 并爬两步到达顶部。\n     * 总成本是 15。\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * 解释: 你将从索引 0 开始。\n     * - 支付 1 并爬两步到达索引 2。\n     * - 支付 1 并爬两步到达索引 4。\n     * - 支付 1 并爬两步到达索引 6。\n     * - 支付 1 并爬一步到达索引 7。\n     * - 支付 1 并爬两步到达索引 9。\n     * - 支付 1 并爬一步到达顶部。\n     * 总成本是 6。\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "fr": "class Solution {\n    /**\n     * Étant donné un tableau d'entiers cost où cost[i] est le coût de la ième marche d'un escalier,\n     * renvoyer le coût minimum pour atteindre le sommet de l'étage.\n     * Vous pouvez soit commencer à partir de la marche avec l'indice 0, soit de la marche avec l'indice 1.\n     *\n     * Exemple:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Explication : Vous commencerez à l'indice 1.\n     * - Payez 15 et montez deux marches pour atteindre le sommet.\n     * Le coût total est de 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Explication : Vous commencerez à l'indice 0.\n     * - Payez 1 et montez deux marches pour atteindre l'indice 2.\n     * - Payez 1 et montez deux marches pour atteindre l'indice 4.\n     * - Payez 1 et montez deux marches pour atteindre l'indice 6.\n     * - Payez 1 et montez une marche pour atteindre l'indice 7.\n     * - Payez 1 et montez deux marches pour atteindre l'indice 9.\n     * - Payez 1 et montez une marche pour atteindre le sommet.\n     * Le coût total est de 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "de": "class Solution {\n    /**\n     * Gegeben ein ganzzahliges Array cost, wobei cost[i] die Kosten der i-ten Stufe auf einer Treppe sind,\n     * gib die minimalen Kosten zurück, um die Spitze des Stockwerks zu erreichen.\n     * Du kannst entweder von der Stufe mit Index 0 oder der Stufe mit Index 1 starten.\n     *\n     * Beispiel:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Erklärung: Du wirst bei Index 1 starten.\n     * - Zahle 15 und klettere zwei Stufen, um die Spitze zu erreichen.\n     * Die Gesamtkosten sind 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Erklärung: Du wirst bei Index 0 starten.\n     * - Zahle 1 und klettere zwei Stufen, um Index 2 zu erreichen.\n     * - Zahle 1 und klettere zwei Stufen, um Index 4 zu erreichen.\n     * - Zahle 1 und klettere zwei Stufen, um Index 6 zu erreichen.\n     * - Zahle 1 und klettere eine Stufe, um Index 7 zu erreichen.\n     * - Zahle 1 und klettere zwei Stufen, um Index 9 zu erreichen.\n     * - Zahle 1 und klettere eine Stufe, um die Spitze zu erreichen.\n     * Die Gesamtkosten sind 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "ha": "class Solution {\n    /**\n     * An ba da wani jerin lambobi na tsada inda cost[i] shine tsadar mataki na i akan matakala,\n     * dawo da mafi ƙarancin tsada don isa saman bene.\n     * Za ka iya fara daga matakin da ke da index 0 ko matakin da ke da index 1.\n     *\n     * Misali:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Bayani: Za ka fara a index 1.\n     * - Biya 15 ka hau matakai biyu don isa saman.\n     * Jimillar tsada ita ce 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Bayani: Za ka fara a index 0.\n     * - Biya 1 ka hau matakai biyu don isa index 2.\n     * - Biya 1 ka hau matakai biyu don isa index 4.\n     * - Biya 1 ka hau matakai biyu don isa index 6.\n     * - Biya 1 ka hau mataki daya don isa index 7.\n     * - Biya 1 ka hau matakai biyu don isa index 9.\n     * - Biya 1 ka hau mataki daya don isa saman.\n     * Jimillar tsada ita ce 6.\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "hi": "class Solution {\n    /**\n     * दिए गए एक पूर्णांक array cost में जहाँ cost[i] सीढ़ी पर ith कदम की लागत है,\n     * शीर्ष तक पहुँचने के लिए न्यूनतम लागत लौटाएँ।\n     * आप या तो सूचकांक 0 वाले कदम से या सूचकांक 1 वाले कदम से शुरू कर सकते हैं।\n     *\n     * उदाहरण:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * व्याख्या: आप सूचकांक 1 पर शुरू करेंगे।\n     * - 15 का भुगतान करें और शीर्ष तक पहुँचने के लिए दो कदम चढ़ें।\n     * कुल लागत 15 है।\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * व्याख्या: आप सूचकांक 0 पर शुरू करेंगे।\n     * - 1 का भुगतान करें और सूचकांक 2 तक पहुँचने के लिए दो कदम चढ़ें।\n     * - 1 का भुगतान करें और सूचकांक 4 तक पहुँचने के लिए दो कदम चढ़ें।\n     * - 1 का भुगतान करें और सूचकांक 6 तक पहुँचने के लिए दो कदम चढ़ें।\n     * - 1 का भुगतान करें और सूचकांक 7 तक पहुँचने के लिए एक कदम चढ़ें।\n     * - 1 का भुगतान करें और सूचकांक 9 तक पहुँचने के लिए दो कदम चढ़ें।\n     * - 1 का भुगतान करें और शीर्ष तक पहुँचने के लिए एक कदम चढ़ें।\n     * कुल लागत 6 है।\n     */\n  public int minCostClimbingStairs(int[] cost) ",
      "hu": "class Solution {\n    /**\n     * Adott egy egész számokat tartalmazó tömb, ahol a cost[i] az i-edik lépcsőfok költsége egy lépcsőn,\n     * térj vissza a legkisebb költséggel, amivel elérheted a lépcső tetejét.\n     * Kezdhetsz akár a 0. indexű, akár az 1. indexű lépcsőfokról.\n     *\n     * Példa:\n     * >>> minCostClimbingStairs([10, 15, 20])\n     * 15\n     * Magyarázat: Az 1. indexnél fogsz kezdeni.\n     * - Fizess 15-öt és mássz fel két lépcsőfokot a tetejére.\n     * A teljes költség 15.\n     *\n     * >>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n     * 6\n     * Magyarázat: A 0. indexnél fogsz kezdeni.\n     * - Fizess 1-et és mássz fel két lépcsőfokot a 2. indexhez.\n     * - Fizess 1-et és mássz fel két lépcsőfokot a 4. indexhez.\n     * - Fizess 1-et és mássz fel két lépcsőfokot a 6. indexhez.\n     * - Fizess 1-et és mássz fel egy lépcsőfokot a 7. indexhez.\n     * - Fizess 1-et és mássz fel két lépcsőfokot a 9. indexhez.\n     * - Fizess 1-et és mássz fel egy lépcsőfokot a tetejére.\n     * A teljes költség 6.\n     */\n  public int minCostClimbingStairs(int[] cost) "
    },
    "prompt_bertscore": {
      "sq": "0.985749461943033",
      "hy": "0.9715285198128402",
      "bn": "0.9874419914198312",
      "bg": "0.9691979895521579",
      "zh": "0.9847859059646328",
      "fr": "0.9713459784926691",
      "de": "0.9811952645666651",
      "ha": "0.9808673258075765",
      "hi": "0.9849571253530848",
      "hu": "0.9590698264231888"
    },
    "canonical_solution": "  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }",
    "instruction": {
      "en": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nনিচের জাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int minCostClimbingStairs(int[] cost)\n  {\n\n    int n = cost.length;\n    int[] dp = new int[n + 1];\n    for (int i = 2; i <= n; i++) {\n      dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n    }\n    return dp[n];\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.8744207087198368",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9083104284408663",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minCostClimbingStairs(new int[] { 10, 15, 20 }) == 15;\n    assert solution.minCostClimbingStairs(\n      new int[] { 1, 100, 1, 1, 1, 100, 1, 1, 100, 1 }\n    ) ==\n    6;\n    assert solution.minCostClimbingStairs(new int[] { 0, 0, 0, 1 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "minCostClimbingStairs",
    "signature": "public int minCostClimbingStairs(int[] cost)",
    "docstring": {
      "en": "Given an integer array cost where cost[i] is the cost of ith step on a staircase,\nreturn the minimum cost to reach the top of the floor.\nYou can either start from the step with index 0 or the step with index 1.\n\nExample:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplanation: You will start at index 1.\n- Pay 15 and climb two steps to reach the top.\nThe total cost is 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplanation: You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6.",
      "sq": "Duke pasur një varg të plotë cost ku cost[i] është kostoja e hapit të i-të në një shkallë, kthe minimumin e kostos për të arritur në majë të katit. Ju mund të filloni ose nga hapi me indeks 0 ose hapi me indeks 1.\n\nShembull:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nShpjegim: Ju do të filloni në indeksin 1.\n- Paguani 15 dhe ngjitni dy hapa për të arritur në majë.\nKostoja totale është 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nShpjegim: Ju do të filloni në indeksin 0.\n- Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 2.\n- Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 4.\n- Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 6.\n- Paguani 1 dhe ngjitni një hap për të arritur në indeksin 7.\n- Paguani 1 dhe ngjitni dy hapa për të arritur në indeksin 9.\n- Paguani 1 dhe ngjitni një hap për të arritur në majë.\nKostoja totale është 6.",
      "hy": "Տրված է ամբողջ թվերի զանգված cost, որտեղ cost[i]-ն աստիճանավանդակի i-րդ աստիճանի արժեքն է, վերադարձնել նվազագույն արժեքը, որպեսզի հասնեք հարկի գագաթը: Դուք կարող եք սկսել կամ 0 ինդեքսով աստիճանից կամ 1 ինդեքսով աստիճանից:\n\nՕրինակ:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nԲացատրություն: Դուք կսկսեք 1 ինդեքսից:\n- Վճարեք 15 և բարձրացեք երկու աստիճան՝ հասնելու գագաթին:\nԸնդհանուր արժեքը 15 է:\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nԲացատրություն: Դուք կսկսեք 0 ինդեքսից:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 2 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 4 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 6 ինդեքսին:\n- Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու 7 ինդեքսին:\n- Վճարեք 1 և բարձրացեք երկու աստիճան՝ հասնելու 9 ինդեքսին:\n- Վճարեք 1 և բարձրացեք մեկ աստիճան՝ հասնելու գագաթին:\nԸնդհանուր արժեքը 6 է:",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যেখানে cost[i] হল সিঁড়ির ith ধাপের খরচ, মেঝের শীর্ষে পৌঁছানোর জন্য সর্বনিম্ন খরচ ফেরত দিন। আপনি হয়তো সূচক 0 সহ ধাপ থেকে বা সূচক 1 সহ ধাপ থেকে শুরু করতে পারেন।\n\nউদাহরণ:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nব্যাখ্যা: আপনি সূচক 1 এ শুরু করবেন।\n- 15 প্রদান করুন এবং শীর্ষে পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\nমোট খরচ 15।\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nব্যাখ্যা: আপনি সূচক 0 এ শুরু করবেন।\n- 1 প্রদান করুন এবং সূচক 2 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 4 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 6 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 7 এ পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং সূচক 9 এ পৌঁছানোর জন্য দুই ধাপ উপরে উঠুন।\n- 1 প্রদান করুন এবং শীর্ষে পৌঁছানোর জন্য এক ধাপ উপরে উঠুন।\nমোট খরচ 6।",
      "bg": "Даден е масив от цели числа cost, където cost[i] е цената на i-тото стъпало на стълбище, върнете минималната цена за достигане до върха на етажа. Можете да започнете или от стъпалото с индекс 0, или от стъпалото с индекс 1.\n\nПример:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nОбяснение: Ще започнете от индекс 1.\n- Платете 15 и се изкачете две стъпала, за да достигнете върха.\nОбщата цена е 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nОбяснение: Ще започнете от индекс 0.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 2.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 4.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 6.\n- Платете 1 и се изкачете едно стъпало, за да достигнете индекс 7.\n- Платете 1 и се изкачете две стъпала, за да достигнете индекс 9.\n- Платете 1 и се изкачете едно стъпало, за да достигнете върха.\nОбщата цена е 6.",
      "zh": "给定一个整数数组 cost，其中 cost[i] 是楼梯上第 i 阶的成本，返回到达楼层顶部的最低成本。你可以从索引为 0 的台阶开始，或者从索引为 1 的台阶开始。\n\n示例：\n>>> minCostClimbingStairs([10, 15, 20])\n15\n解释：你将从索引 1 开始。\n- 支付 15 并爬两步到达顶部。\n总成本是 15。\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\n解释：你将从索引 0 开始。\n- 支付 1 并爬两步到达索引 2。\n- 支付 1 并爬两步到达索引 4。\n- 支付 1 并爬两步到达索引 6。\n- 支付 1 并爬一步到达索引 7。\n- 支付 1 并爬两步到达索引 9。\n- 支付 1 并爬一步到达顶部。\n总成本是 6。",
      "fr": "Étant donné un tableau d'entiers `cost` où `cost[i]` est le coût de la i-ème marche d'un escalier, renvoyez le coût minimum pour atteindre le sommet de l'étage. Vous pouvez commencer soit à partir de la marche avec l'indice 0, soit à partir de la marche avec l'indice 1.\n\nExemple :\n>>> minCostClimbingStairs([10, 15, 20])\n15\nExplication : Vous commencerez à l'indice 1.\n- Payez 15 et montez deux marches pour atteindre le sommet.\nLe coût total est de 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nExplication : Vous commencerez à l'indice 0.\n- Payez 1 et montez deux marches pour atteindre l'indice 2.\n- Payez 1 et montez deux marches pour atteindre l'indice 4.\n- Payez 1 et montez deux marches pour atteindre l'indice 6.\n- Payez 1 et montez une marche pour atteindre l'indice 7.\n- Payez 1 et montez deux marches pour atteindre l'indice 9.\n- Payez 1 et montez une marche pour atteindre le sommet.\nLe coût total est de 6.",
      "de": "Gegeben ein ganzzahliges Array cost, wobei cost[i] die Kosten der i-ten Stufe auf einer Treppe sind, gib die minimalen Kosten zurück, um die Spitze des Stockwerks zu erreichen. Du kannst entweder von der Stufe mit Index 0 oder der Stufe mit Index 1 starten.\n\nBeispiel:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nErläuterung: Du wirst bei Index 1 starten.\n- Zahle 15 und klettere zwei Stufen, um die Spitze zu erreichen.\nDie Gesamtkosten sind 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nErläuterung: Du wirst bei Index 0 starten.\n- Zahle 1 und klettere zwei Stufen, um Index 2 zu erreichen.\n- Zahle 1 und klettere zwei Stufen, um Index 4 zu erreichen.\n- Zahle 1 und klettere zwei Stufen, um Index 6 zu erreichen.\n- Zahle 1 und klettere eine Stufe, um Index 7 zu erreichen.\n- Zahle 1 und klettere zwei Stufen, um Index 9 zu erreichen.\n- Zahle 1 und klettere eine Stufe, um die Spitze zu erreichen.\nDie Gesamtkosten sind 6.",
      "ha": "An ba da jerin lambobi na tsada inda cost[i] shine kudin matakin na i akan matakala,\nmayar da mafi ƙarancin tsada don isa saman bene.\nZa ka iya fara daga matakin da ke da alamar 0 ko matakin da ke da alamar 1.\n\nMisali:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nBayani: Za ka fara a mataki na 1.\n- Biya 15 kuma hau matakai biyu don isa saman.\nJimillar kuɗin shine 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nBayani: Za ka fara a mataki na 0.\n- Biya 1 kuma hau matakai biyu don isa mataki na 2.\n- Biya 1 kuma hau matakai biyu don isa mataki na 4.\n- Biya 1 kuma hau matakai biyu don isa mataki na 6.\n- Biya 1 kuma hau mataki daya don isa mataki na 7.\n- Biya 1 kuma hau matakai biyu don isa mataki na 9.\n- Biya 1 kuma hau mataki daya don isa saman.\nJimillar kuɗin shine 6.",
      "hi": "एक पूर्णांक ऐरे दिया गया है जहाँ cost[i] सीढ़ी पर ith कदम की लागत है,\nमंजिल के शीर्ष तक पहुँचने के लिए न्यूनतम लागत लौटाएं।\nआप या तो सूचकांक 0 वाले कदम से या सूचकांक 1 वाले कदम से शुरू कर सकते हैं।\n\nउदाहरण:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nव्याख्या: आप इंडेक्स 1 से शुरू करेंगे।\n- 15 का भुगतान करें और शीर्ष पर पहुंचने के लिए दो कदम चढ़ें।\nकुल लागत 15 है।\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nव्याख्या: आप इंडेक्स 0 से शुरू करेंगे।\n- 1 का भुगतान करें और इंडेक्स 2 तक पहुंचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और इंडेक्स 4 तक पहुंचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और इंडेक्स 6 तक पहुंचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और इंडेक्स 7 तक पहुंचने के लिए एक कदम चढ़ें।\n- 1 का भुगतान करें और इंडेक्स 9 तक पहुंचने के लिए दो कदम चढ़ें।\n- 1 का भुगतान करें और शीर्ष पर पहुंचने के लिए एक कदम चढ़ें।\nकुल लागत 6 है।",
      "hu": "Adott egy egész számokat tartalmazó tömb, `cost`, ahol `cost[i]` az i-edik lépcsőfok költsége egy lépcsőházban. Térj vissza a legkisebb költséggel, amellyel elérheted az emelet tetejét. Kezdhetsz vagy a 0. indexű, vagy az 1. indexű lépcsőfokról.\n\nPélda:\n>>> minCostClimbingStairs([10, 15, 20])\n15\nMagyarázat: Az 1. indexnél fogsz kezdeni.\n- Fizess 15-öt és mássz fel két lépcsőfokot, hogy elérd a tetejét.\nA teljes költség 15.\n\n>>> minCostClimbingStairs([1, 100, 1, 1, 1, 100, 1, 1, 100, 1])\n6\nMagyarázat: A 0. indexnél fogsz kezdeni.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 2. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 4. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 6. indexet.\n- Fizess 1-et és mássz fel egy lépcsőfokot, hogy elérd a 7. indexet.\n- Fizess 1-et és mássz fel két lépcsőfokot, hogy elérd a 9. indexet.\n- Fizess 1-et és mássz fel egy lépcsőfokot, hogy elérd a tetejét.\nA teljes költség 6."
    },
    "docstring_bertscore": {
      "sq": "0.9816338404479901",
      "hy": "0.9686100436242946",
      "bn": "0.9935079646262557",
      "bg": "0.9668666647699513",
      "zh": "0.9711209302709566",
      "fr": "0.9645742715424277",
      "de": "0.9778400001702238",
      "ha": "0.9301607635066091",
      "hi": "0.998582374970554",
      "hu": "0.9509901384138327"
    }
  },
  {
    "task_id": "Java/21",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\n     * return the number of different transformations among all words.\n     *\n     * Example:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një varg të fjalëve strings ku secila fjalë mund të shkruhet si një bashkim i kodit Morse të secilës shkronjë,\n     * kthe numrin e transformimeve të ndryshme midis të gjitha fjalëve.\n     *\n     * Shembull:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է տողերի զանգված words, որտեղ յուրաքանչյուր բառ կարող է գրվել որպես յուրաքանչյուր տառի Մորզեի կոդի միացում,\n     * վերադարձնել տարբեր փոխակերպումների քանակը բոլոր բառերի մեջ:\n     *\n     * Օրինակ:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * একটি স্ট্রিং এর অ্যারে দেওয়া আছে words যেখানে প্রতিটি শব্দকে প্রতিটি অক্ষরের মর্স কোডের সংযোজন হিসেবে লেখা যেতে পারে,\n     * সমস্ত শব্দের মধ্যে বিভিন্ন রূপান্তরের সংখ্যা ফেরত দিন।\n     *\n     * উদাহরণ:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Даден е масив от низове words, където всяка дума може да бъде написана като конкатенация на Морзовия код на всяка буква,\n     * върнете броя на различните трансформации сред всички думи.\n     *\n     * Пример:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个字符串数组 words，其中每个单词可以写成每个字母的摩尔斯码的连接，\n     * 返回所有单词中不同转换的数量。\n     *\n     * 示例:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné un tableau de chaînes de caractères words où chaque mot peut être écrit comme une concaténation du code Morse de chaque lettre,\n     * renvoyer le nombre de transformations différentes parmi tous les mots.\n     *\n     * Exemple :\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben ein Array von Zeichenketten words, wobei jedes Wort als Verkettung des Morse-Codes jedes Buchstabens geschrieben werden kann,\n     * gib die Anzahl der verschiedenen Transformationen unter allen Wörtern zurück.\n     *\n     * Beispiel:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani jerin kalmomi na kirtani inda kowace kalma za a iya rubuta ta a matsayin haɗin lambobin Morse na kowace harafi,\n     * dawo da adadin canje-canje daban-daban tsakanin duk kalmomi.\n     *\n     * Misali:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए स्ट्रिंग्स के एक array words में जहाँ प्रत्येक शब्द को प्रत्येक अक्षर के मोर्स कोड के संयोजन के रूप में लिखा जा सकता है,\n     * सभी शब्दों में विभिन्न रूपांतरणों की संख्या लौटाएं।\n     *\n     * उदाहरण:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy sztringeket tartalmazó tömb, ahol minden szó az egyes betűk Morse-kódjának összefűzéseként írható le,\n     * adja vissza a különböző átalakítások számát az összes szó között.\n     *\n     * Példa:\n     * uniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\n     * uniqueMorseRepresentations([\"a\"]) -> 1\n     */\n    public int uniqueMorseRepresentations(String[] words) "
    },
    "prompt_bertscore": {
      "sq": "0.996953804476449",
      "hy": "0.9952088365790575",
      "bn": "0.976611272633142",
      "bg": "0.9952964325770939",
      "zh": "0.9952088365790575",
      "fr": "0.9962135090463319",
      "de": "0.9952088365790575",
      "ha": "0.9853233997757131",
      "hi": "0.9753134217234599",
      "hu": "0.9716858350746198"
    },
    "canonical_solution": "    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }",
    "instruction": {
      "en": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nOfroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки най-много 500 знака.",
      "zh": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\n请用最多500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Java a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int uniqueMorseRepresentations(String[] words)\n    {\n\n        String[] MORSE = new String[]{\n            \".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\", \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\", \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"\n        };\n\n        Set<String> seen = new HashSet<>();\n        for (String word : words) {\n            StringBuilder code = new StringBuilder();\n            for (char c : word.toCharArray())\n                code.append(MORSE[c - 'a']);\n            seen.add(code.toString());\n        }\n\n        return seen.size();\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9615433705582164",
      "bn": "0.9238701393392342",
      "bg": "0.8459003654589423",
      "zh": "0.8770857325421819",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9097145466044019",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.uniqueMorseRepresentations(new String[]{\"hello\", \"world\", \"hello\"}) == 2;\n        assert solution.uniqueMorseRepresentations(new String[]{\"abc\", \"def\", \"ghi\"}) == 3;\n        assert solution.uniqueMorseRepresentations(new String[]{\"aaa\", \"aaa\", \"aaa\"}) == 1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "uniqueMorseRepresentations",
    "signature": "public int uniqueMorseRepresentations(String[] words)",
    "docstring": {
      "en": "Given an array of strings words where each word can be written as a concatenation of the Morse code of each letter,\nreturn the number of different transformations among all words.\n\nExample:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "sq": "Duke pasur një varg të fjalëve strings ku secila fjalë mund të shkruhet si një bashkim i kodit Morse të secilës shkronjë,\nkthe numrin e transformimeve të ndryshme midis të gjitha fjalëve.\n\nShembull:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hy": "Տրված է տողերի զանգված words, որտեղ յուրաքանչյուր բառ կարող է գրվել որպես յուրաքանչյուր տառի Մորզեի կոդի միացում, վերադարձնել տարբեր փոխակերպումների քանակը բոլոր բառերի մեջ:\n\nՕրինակ:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "bn": "একটি স্ট্রিং এর অ্যারের words দেওয়া হয়েছে যেখানে প্রতিটি শব্দ প্রতিটি অক্ষরের মর্স কোডের সংযোজন হিসাবে লেখা যেতে পারে, সমস্ত শব্দের মধ্যে বিভিন্ন রূপান্তরের সংখ্যা ফেরত দিন।\n\nউদাহরণ:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "bg": "Даден е масив от низове words, където всяка дума може да бъде написана като конкатенация на Морзовия код на всяка буква, върнете броя на различните трансформации сред всички думи.\n\nПример:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "zh": "给定一个字符串数组 words，其中每个单词可以写成每个字母的摩尔斯代码的连接，返回所有单词中不同转换的数量。\n\n示例：\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "fr": "Étant donné un tableau de chaînes de caractères words où chaque mot peut être écrit comme une concaténation du code Morse de chaque lettre, renvoyez le nombre de transformations différentes parmi tous les mots.\n\nExemple :\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "de": "Gegeben ein Array von Zeichenfolgen words, wobei jedes Wort als Verkettung des Morse-Codes jedes Buchstabens geschrieben werden kann, gib die Anzahl der unterschiedlichen Transformationen unter allen Wörtern zurück.\n\nBeispiel:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "ha": "An ba da wani tsararren jerin kalmomi words inda kowace kalma za a iya rubuta ta a matsayin haɗin gwiwar lambar Morse na kowace harafi,\nmayar da adadin sauye-sauye daban-daban a tsakanin duk kalmomi.\n\nMisali:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hi": "दिए गए स्ट्रिंग्स के एक array words में, जहाँ प्रत्येक शब्द को प्रत्येक अक्षर के मोर्स कोड के संयोजन के रूप में लिखा जा सकता है, सभी शब्दों के बीच विभिन्न रूपांतरणों की संख्या लौटाएँ।\n\nउदाहरण:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1",
      "hu": "Adott egy words karakterláncokat tartalmazó tömb, ahol minden szó az egyes betűk Morse-kódjának összefűzéseként írható le, adja vissza a különböző transzformációk számát az összes szó között.\n\nPélda:\nuniqueMorseRepresentations([\"gin\",\"zen\",\"gig\",\"msg\"]) -> 2\nuniqueMorseRepresentations([\"a\"]) -> 1"
    },
    "docstring_bertscore": {
      "sq": "0.9669481032261756",
      "hy": "0.9827976158504735",
      "bn": "0.9480458402757526",
      "bg": "0.9929794091823219",
      "zh": "0.9752482709584805",
      "fr": "0.9941314653923242",
      "de": "0.987184169185248",
      "ha": "0.9294063653194387",
      "hi": "0.9622550632134643",
      "hu": "0.9500788222256447"
    }
  },
  {
    "task_id": "Java/22",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n     *\n     * Example 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Explanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n     *\n     * Example 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Explanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n     *\n     * Example 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Explanation: The binary string \"00\" is not a substring of s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një varg binar s dhe një numër të plotë k, kthe true nëse çdo varg binar me gjatësi k është një nënvarg i s, ose false përndryshe.\n     *\n     * Shembull 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Shpjegim: Të gjithë vargjet binare me gjatësi 2 (\"00\", \"01\", \"10\", dhe \"11\") janë nënvargje të s.\n     *\n     * Shembull 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Shpjegim: Të gjithë vargjet binare me gjatësi 1 (\"0\" dhe \"1\") janë nënvargje të s.\n     *\n     * Shembull 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Shpjegim: Vargu binar \"00\" nuk është një nënvarg i s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է երկբայն string s և ամբողջ թիվ k, վերադարձնել true, եթե k երկարությամբ բոլոր երկբայն string-ները ենթատողեր են s-ի, կամ false՝ հակառակ դեպքում:\n     *\n     * Օրինակ 1:\n     * Մուտք: s = \"00110110\", k = 2\n     * Ելք: true\n     * Բացատրություն: 2 երկարությամբ բոլոր երկբայն string-ները (\"00\", \"01\", \"10\" և \"11\") ենթատողեր են s-ի:\n     *\n     * Օրինակ 2:\n     * Մուտք: s = \"0110\", k = 1\n     * Ելք: true\n     * Բացատրություն: 1 երկարությամբ բոլոր երկբայն string-ները (\"0\" և \"1\") ենթատողեր են s-ի:\n     *\n     * Օրինակ 3:\n     * Մուտք: s = \"0110\", k = 2\n     * Ելք: false\n     * Բացատրություն: Երկբայն string \"00\"-ը ենթատող չէ s-ի:\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * একটি বাইনারি স্ট্রিং s এবং একটি পূর্ণসংখ্যা k দেওয়া হলে, যদি দৈর্ঘ্য k এর প্রতিটি বাইনারি স্ট্রিং s এর একটি সাবস্ট্রিং হয় তবে true ফেরত দিন, অন্যথায় false ফেরত দিন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: s = \"00110110\", k = 2\n     * আউটপুট: true\n     * ব্যাখ্যা: দৈর্ঘ্য 2 এর সব বাইনারি স্ট্রিং (\"00\", \"01\", \"10\", এবং \"11\") s এর সাবস্ট্রিং।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: s = \"0110\", k = 1\n     * আউটপুট: true\n     * ব্যাখ্যা: দৈর্ঘ্য 1 এর সব বাইনারি স্ট্রিং (\"0\" এবং \"1\") s এর সাবস্ট্রিং।\n     *\n     * উদাহরণ 3:\n     * ইনপুট: s = \"0110\", k = 2\n     * আউটপুট: false\n     * ব্যাখ্যা: বাইনারি স্ট্রিং \"00\" s এর একটি সাবস্ট্রিং নয়।\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Даден е двоичен низ s и цяло число k, върнете true, ако всеки двоичен низ с дължина k е подниз на s, или false в противен случай.\n     *\n     * Пример 1:\n     * Вход: s = \"00110110\", k = 2\n     * Изход: true\n     * Обяснение: Всички двоични низове с дължина 2 (\"00\", \"01\", \"10\" и \"11\") са поднизове на s.\n     *\n     * Пример 2:\n     * Вход: s = \"0110\", k = 1\n     * Изход: true\n     * Обяснение: Всички двоични низове с дължина 1 (\"0\" и \"1\") са поднизове на s.\n     *\n     * Пример 3:\n     * Вход: s = \"0110\", k = 2\n     * Изход: false\n     * Обяснение: Двоичният низ \"00\" не е подниз на s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个二进制字符串 s 和一个整数 k，如果长度为 k 的每个二进制字符串都是 s 的子串，则返回 true，否则返回 false。\n     *\n     * 示例 1:\n     * 输入: s = \"00110110\", k = 2\n     * 输出: true\n     * 解释: 所有长度为 2 的二进制字符串 (\"00\", \"01\", \"10\", 和 \"11\") 都是 s 的子串。\n     *\n     * 示例 2:\n     * 输入: s = \"0110\", k = 1\n     * 输出: true\n     * 解释: 所有长度为 1 的二进制字符串 (\"0\" 和 \"1\") 都是 s 的子串。\n     *\n     * 示例 3:\n     * 输入: s = \"0110\", k = 2\n     * 输出: false\n     * 解释: 二进制字符串 \"00\" 不是 s 的子串。\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné une chaîne binaire s et un entier k, retourne true si chaque chaîne binaire de longueur k est une sous-chaîne de s, ou false sinon.\n     *\n     * Exemple 1 :\n     * Entrée : s = \"00110110\", k = 2\n     * Sortie : true\n     * Explication : Toutes les chaînes binaires de longueur 2 (\"00\", \"01\", \"10\", et \"11\") sont des sous-chaînes de s.\n     *\n     * Exemple 2 :\n     * Entrée : s = \"0110\", k = 1\n     * Sortie : true\n     * Explication : Toutes les chaînes binaires de longueur 1 (\"0\" et \"1\") sont des sous-chaînes de s.\n     *\n     * Exemple 3 :\n     * Entrée : s = \"0110\", k = 2\n     * Sortie : false\n     * Explication : La chaîne binaire \"00\" n'est pas une sous-chaîne de s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben ein binärer String s und ein Integer k, gib true zurück, wenn jeder binäre String der Länge k ein Substring von s ist, oder false andernfalls.\n     *\n     * Beispiel 1:\n     * Eingabe: s = \"00110110\", k = 2\n     * Ausgabe: true\n     * Erklärung: Alle binären Strings der Länge 2 (\"00\", \"01\", \"10\" und \"11\") sind Substrings von s.\n     *\n     * Beispiel 2:\n     * Eingabe: s = \"0110\", k = 1\n     * Ausgabe: true\n     * Erklärung: Alle binären Strings der Länge 1 (\"0\" und \"1\") sind Substrings von s.\n     *\n     * Beispiel 3:\n     * Eingabe: s = \"0110\", k = 2\n     * Ausgabe: false\n     * Erklärung: Der binäre String \"00\" ist kein Substring von s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * An ba da wani igiyar binary s da wani lamba k, dawo da gaskiya idan dukkan igiyoyin binary na tsawon k suna cikin s, ko kuma karya idan ba haka ba.\n     *\n     * Misali 1:\n     * Input: s = \"00110110\", k = 2\n     * Output: true\n     * Bayani: Dukkan igiyoyin binary na tsawon 2 (\"00\", \"01\", \"10\", da \"11\") suna cikin s.\n     *\n     * Misali 2:\n     * Input: s = \"0110\", k = 1\n     * Output: true\n     * Bayani: Dukkan igiyoyin binary na tsawon 1 (\"0\" da \"1\") suna cikin s.\n     *\n     * Misali 3:\n     * Input: s = \"0110\", k = 2\n     * Output: false\n     * Bayani: Igiyar binary \"00\" ba ta cikin s.\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए एक बाइनरी स्ट्रिंग s और एक पूर्णांक k के लिए, यदि लंबाई k का प्रत्येक बाइनरी स्ट्रिंग s का उपस्ट्रिंग है तो true लौटाएं, अन्यथा false लौटाएं।\n     *\n     * उदाहरण 1:\n     * इनपुट: s = \"00110110\", k = 2\n     * आउटपुट: true\n     * व्याख्या: लंबाई 2 के सभी बाइनरी स्ट्रिंग (\"00\", \"01\", \"10\", और \"11\") s के उपस्ट्रिंग हैं।\n     *\n     * उदाहरण 2:\n     * इनपुट: s = \"0110\", k = 1\n     * आउटपुट: true\n     * व्याख्या: लंबाई 1 के सभी बाइनरी स्ट्रिंग (\"0\" और \"1\") s के उपस्ट्रिंग हैं।\n     *\n     * उदाहरण 3:\n     * इनपुट: s = \"0110\", k = 2\n     * आउटपुट: false\n     * व्याख्या: बाइनरी स्ट्रिंग \"00\" s का उपस्ट्रिंग नहीं है।\n     */\n  public boolean hasAllCodes(String s, int k) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy bináris string s és egy egész szám k, adja vissza true értéket, ha minden k hosszúságú bináris string részstringje s-nek, különben false.\n     *\n     * 1. példa:\n     * Bemenet: s = \"00110110\", k = 2\n     * Kimenet: true\n     * Magyarázat: Minden 2 hosszúságú bináris string (\"00\", \"01\", \"10\" és \"11\") részstringje s-nek.\n     *\n     * 2. példa:\n     * Bemenet: s = \"0110\", k = 1\n     * Kimenet: true\n     * Magyarázat: Minden 1 hosszúságú bináris string (\"0\" és \"1\") részstringje s-nek.\n     *\n     * 3. példa:\n     * Bemenet: s = \"0110\", k = 2\n     * Kimenet: false\n     * Magyarázat: A \"00\" bináris string nem részstringje s-nek.\n     */\n  public boolean hasAllCodes(String s, int k) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9822192041808999",
      "bg": "1",
      "zh": "0.9954366656261044",
      "fr": "1",
      "de": "1",
      "ha": "0.9246716129267101",
      "hi": "0.9917443254730469",
      "hu": "0.9841492955934159"
    },
    "canonical_solution": "  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }",
    "instruction": {
      "en": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n请用不超过500个字符的中文为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nBa da takaitaccen bayanin yanayi na zahiri (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public boolean hasAllCodes(String s, int k)\n  {\n\n    Set<String> seen = new HashSet<>();\n    int total = 1 << k;\n    for (int i = k; i <= s.length(); i++) {\n      String substring = s.substring(i - k, i);\n      seen.add(substring);\n      if (seen.size() == total) {\n        return true;\n      }\n    }\n    return false;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (dokumentációs kommentet) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386897534378662",
      "hy": "0.9615433705582164",
      "bn": "0.9238701393392342",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8755010593622855",
      "hi": "0.9113991308659588",
      "hu": "0.8804161681409939"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.hasAllCodes(\"00110110\", 3) == false;\n    assert solution.hasAllCodes(\"00110110\", 2) == true;\n    assert solution.hasAllCodes(\n      \"1111111111111111111111111111111111111111111111111111111111111111\",\n      1\n    ) ==\n    false;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "hasAllCodes",
    "signature": "public boolean hasAllCodes(String s, int k)",
    "docstring": {
      "en": "Given a binary string s and an integer k, return true if every binary string of length k is a substring of s, or false otherwise.\n\nExample 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: All binary strings of length 2 (\"00\", \"01\", \"10\", and \"11\") are substrings of s.\n\nExample 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: All binary strings of length 1 (\"0\" and \"1\") are substrings of s.\n\nExample 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: The binary string \"00\" is not a substring of s.",
      "sq": "Duke pasur një varg binar s dhe një numër të plotë k, kthe true nëse çdo varg binar me gjatësi k është një nënvarg i s, ose false përndryshe.\n\nShembull 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nShpjegim: Të gjitha vargjet binare me gjatësi 2 (\"00\", \"01\", \"10\", dhe \"11\") janë nënvargje të s.\n\nShembull 2:\nInput: s = \"0110\", k = 1\nOutput: true\nShpjegim: Të gjitha vargjet binare me gjatësi 1 (\"0\" dhe \"1\") janë nënvargje të s.\n\nShembull 3:\nInput: s = \"0110\", k = 2\nOutput: false\nShpjegim: Vargu binar \"00\" nuk është një nënvarg i s.",
      "hy": "Տրված է երկբայական տող s և ամբողջ թիվ k, վերադարձնել true, եթե երկբայական բոլոր տողերը k երկարությամբ ենթատողեր են s-ի, կամ false հակառակ դեպքում:\n\nՕրինակ 1:\nՄուտք: s = \"00110110\", k = 2\nԵլք: true\nԲացատրություն: Երկբայական բոլոր տողերը 2 երկարությամբ (\"00\", \"01\", \"10\" և \"11\") ենթատողեր են s-ի:\n\nՕրինակ 2:\nՄուտք: s = \"0110\", k = 1\nԵլք: true\nԲացատրություն: Երկբայական բոլոր տողերը 1 երկարությամբ (\"0\" և \"1\") ենթատողեր են s-ի:\n\nՕրինակ 3:\nՄուտք: s = \"0110\", k = 2\nԵլք: false\nԲացատրություն: Երկբայական տողը \"00\" ենթատող չէ s-ի:",
      "bn": "দেওয়া একটি বাইনারি স্ট্রিং s এবং একটি পূর্ণসংখ্যা k, যদি s এর প্রতিটি k দৈর্ঘ্যের বাইনারি স্ট্রিং একটি সাবস্ট্রিং হয় তবে true ফেরত দিন, অন্যথায় false।\n\nউদাহরণ 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nExplanation: দৈর্ঘ্য 2 এর সমস্ত বাইনারি স্ট্রিং (\"00\", \"01\", \"10\", এবং \"11\") s এর সাবস্ট্রিং।\n\nউদাহরণ 2:\nInput: s = \"0110\", k = 1\nOutput: true\nExplanation: দৈর্ঘ্য 1 এর সমস্ত বাইনারি স্ট্রিং (\"0\" এবং \"1\") s এর সাবস্ট্রিং।\n\nউদাহরণ 3:\nInput: s = \"0110\", k = 2\nOutput: false\nExplanation: বাইনারি স্ট্রিং \"00\" s এর একটি সাবস্ট্রিং নয়।",
      "bg": "Даден е двоичен низ s и цяло число k, върнете true, ако всеки двоичен низ с дължина k е подниз на s, или false в противен случай.\n\nПример 1:\nВход: s = \"00110110\", k = 2\nИзход: true\nОбяснение: Всички двоични низове с дължина 2 (\"00\", \"01\", \"10\" и \"11\") са поднизове на s.\n\nПример 2:\nВход: s = \"0110\", k = 1\nИзход: true\nОбяснение: Всички двоични низове с дължина 1 (\"0\" и \"1\") са поднизове на s.\n\nПример 3:\nВход: s = \"0110\", k = 2\nИзход: false\nОбяснение: Двоичният низ \"00\" не е подниз на s.",
      "zh": "给定一个二进制字符串 s 和一个整数 k，如果长度为 k 的每个二进制字符串都是 s 的子字符串，则返回 true，否则返回 false。\n\n示例 1:\n输入: s = \"00110110\", k = 2\n输出: true\n解释: 所有长度为 2 的二进制字符串 (\"00\", \"01\", \"10\", 和 \"11\") 都是 s 的子字符串。\n\n示例 2:\n输入: s = \"0110\", k = 1\n输出: true\n解释: 所有长度为 1 的二进制字符串 (\"0\" 和 \"1\") 都是 s 的子字符串。\n\n示例 3:\n输入: s = \"0110\", k = 2\n输出: false\n解释: 二进制字符串 \"00\" 不是 s 的子字符串。",
      "fr": "Étant donné une chaîne binaire s et un entier k, renvoyez true si chaque chaîne binaire de longueur k est une sous-chaîne de s, ou false sinon.\n\nExemple 1 :\nInput: s = \"00110110\", k = 2\nOutput: true\nExplication : Toutes les chaînes binaires de longueur 2 (\"00\", \"01\", \"10\", et \"11\") sont des sous-chaînes de s.\n\nExemple 2 :\nInput: s = \"0110\", k = 1\nOutput: true\nExplication : Toutes les chaînes binaires de longueur 1 (\"0\" et \"1\") sont des sous-chaînes de s.\n\nExemple 3 :\nInput: s = \"0110\", k = 2\nOutput: false\nExplication : La chaîne binaire \"00\" n'est pas une sous-chaîne de s.",
      "de": "Gegeben ein binärer String s und ein ganzzahliger Wert k, gib true zurück, wenn jeder binäre String der Länge k ein Substring von s ist, oder false andernfalls.\n\nBeispiel 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nErklärung: Alle Binärstrings der Länge 2 (\"00\", \"01\", \"10\" und \"11\") sind Substrings von s.\n\nBeispiel 2:\nInput: s = \"0110\", k = 1\nOutput: true\nErklärung: Alle Binärstrings der Länge 1 (\"0\" und \"1\") sind Substrings von s.\n\nBeispiel 3:\nInput: s = \"0110\", k = 2\nOutput: false\nErklärung: Der Binärstring \"00\" ist kein Substring von s.",
      "ha": "An ba da igiyar binary s da kuma cikakken lamba k, dawo da gaskiya idan dukkan igiyoyin binary na tsawon k suna cikin s, ko kuma ƙarya in ba haka ba.\n\nMisali 1:\nInput: s = \"00110110\", k = 2\nOutput: true\nBayani: Dukkan igiyoyin binary na tsawon 2 (\"00\", \"01\", \"10\", da \"11\") suna cikin s.\n\nMisali 2:\nInput: s = \"0110\", k = 1\nOutput: true\nBayani: Dukkan igiyoyin binary na tsawon 1 (\"0\" da \"1\") suna cikin s.\n\nMisali 3:\nInput: s = \"0110\", k = 2\nOutput: false\nBayani: Igiya binary \"00\" ba ta cikin s.",
      "hi": "दिए गए एक बाइनरी स्ट्रिंग s और एक पूर्णांक k के लिए, true लौटाएं यदि लंबाई k का प्रत्येक बाइनरी स्ट्रिंग s का एक उपस्ट्रिंग है, अन्यथा false लौटाएं।\n\nउदाहरण 1:\nइनपुट: s = \"00110110\", k = 2\nआउटपुट: true\nव्याख्या: लंबाई 2 के सभी बाइनरी स्ट्रिंग (\"00\", \"01\", \"10\", और \"11\") s के सबस्ट्रिंग हैं।\n\nउदाहरण 2:\nइनपुट: s = \"0110\", k = 1\nआउटपुट: true\nव्याख्या: लंबाई 1 के सभी बाइनरी स्ट्रिंग (\"0\" और \"1\") s के सबस्ट्रिंग हैं।\n\nउदाहरण 3:\nइनपुट: s = \"0110\", k = 2\nआउटपुट: false\nव्याख्या: बाइनरी स्ट्रिंग \"00\" s का सबस्ट्रिंग नहीं है।",
      "hu": "Adott egy bináris string s és egy egész szám k, adja vissza, hogy igaz-e, ha minden k hosszúságú bináris string az s egy részstringje, vagy hamis, ha nem.\n\nPélda 1:\nBemenet: s = \"00110110\", k = 2\nKimenet: true\nMagyarázat: Az összes 2 hosszúságú bináris string (\"00\", \"01\", \"10\" és \"11\") az s részstringjei.\n\nPélda 2:\nBemenet: s = \"0110\", k = 1\nKimenet: true\nMagyarázat: Az összes 1 hosszúságú bináris string (\"0\" és \"1\") az s részstringjei.\n\nPélda 3:\nBemenet: s = \"0110\", k = 2\nKimenet: false\nMagyarázat: A \"00\" bináris string nem részstringje az s-nek."
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9917238665438004",
      "bn": "0.9784194049917025",
      "bg": "1",
      "zh": "0.994283814894578",
      "fr": "1",
      "de": "1",
      "ha": "0.9424796211080119",
      "hi": "0.994283814894578",
      "hu": "0.9800483727465696"
    }
  },
  {
    "task_id": "Java/23",
    "prompt": {
      "en": "class Solution {\n    /**\n    * Check if the searchWord is a prefix of any word in the sentence.\n    * If searchWord is a prefix of multiple words, return the index of the first matching word.\n    * If searchWord is not a prefix of any word, return -1.\n    * \n    * Example:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "sq": "class Solution {\n    /**\n    * Kontrolloni nëse searchWord është një parashtesë e ndonjë fjale në fjalinë.\n    * Nëse searchWord është një parashtesë e disa fjalëve, kthe indeksin e fjalës së parë që përputhet.\n    * Nëse searchWord nuk është një parashtesë e asnjë fjale, kthe -1.\n    * \n    * Shembull:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "hy": "class Solution {\n    /**\n    * Ստուգել, արդյոք searchWord-ը նախածանց է նախադասության որևէ բառի համար:\n    * Եթե searchWord-ը նախածանց է բազմաթիվ բառերի համար, վերադարձնել առաջին համընկնող բառի ինդեքսը:\n    * Եթե searchWord-ը ոչ մի բառի նախածանց չէ, վերադարձնել -1:\n    * \n    * Օրինակ:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "bn": "class Solution {\n    /**\n    * পরীক্ষা করুন যে searchWord বাক্যের কোনো শব্দের উপসর্গ কিনা।\n    * যদি searchWord একাধিক শব্দের উপসর্গ হয়, তবে প্রথম মিলে যাওয়া শব্দের সূচক ফেরত দিন।\n    * যদি searchWord কোনো শব্দের উপসর্গ না হয়, তবে -1 ফেরত দিন।\n    * \n    * উদাহরণ:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "bg": "class Solution {\n    /**\n    * Проверете дали searchWord е префикс на някоя дума в изречението.\n    * Ако searchWord е префикс на множество думи, върнете индекса на първата съвпадаща дума.\n    * Ако searchWord не е префикс на никоя дума, върнете -1.\n    * \n    * Пример:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "zh": "class Solution {\n    /**\n    * 检查 searchWord 是否是句子中任何单词的前缀。\n    * 如果 searchWord 是多个单词的前缀，返回第一个匹配单词的索引。\n    * 如果 searchWord 不是任何单词的前缀，返回 -1。\n    * \n    * 示例:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "fr": "class Solution {\n    /**\n    * Vérifiez si searchWord est un préfixe de n'importe quel mot dans la phrase.\n    * Si searchWord est un préfixe de plusieurs mots, renvoyez l'index du premier mot correspondant.\n    * Si searchWord n'est le préfixe d'aucun mot, renvoyez -1.\n    * \n    * Exemple:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "de": "class Solution {\n    /**\n    * Überprüfen, ob das Suchwort ein Präfix eines Wortes im Satz ist.\n    * Wenn Suchwort ein Präfix mehrerer Wörter ist, geben Sie den Index des ersten übereinstimmenden Wortes zurück.\n    * Wenn Suchwort kein Präfix eines Wortes ist, geben Sie -1 zurück.\n    * \n    * Beispiel:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "ha": "class Solution {\n    /**\n    * Duba idan searchWord kalma ce mai farawa da kowace kalma a cikin jumlar.\n    * Idan searchWord kalma ce mai farawa da kalmomi da dama, dawo da lambar kalmar farko da ta dace.\n    * Idan searchWord ba kalma ce mai farawa da kowace kalma ba, dawo da -1.\n    * \n    * Misali:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "hi": "class Solution {\n    /**\n    * जाँचें कि searchWord वाक्य में किसी शब्द का उपसर्ग है या नहीं।\n    * यदि searchWord कई शब्दों का उपसर्ग है, तो पहले मिलान करने वाले शब्द का सूचकांक लौटाएं।\n    * यदि searchWord किसी भी शब्द का उपसर्ग नहीं है, तो -1 लौटाएं।\n    * \n    * उदाहरण:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) ",
      "hu": "class Solution {\n    /**\n    * Ellenőrzi, hogy a searchWord előtagja-e bármelyik szónak a mondatban.\n    * Ha a searchWord több szó előtagja, akkor az első egyező szó indexét adja vissza.\n    * Ha a searchWord nem előtagja egyetlen szónak sem, akkor -1-et ad vissza.\n    * \n    * Példa:\n    * >>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n    * 4\n    * >>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n    * 2\n    * >>> isPrefixOfWord(\"i am tired\", \"you\")\n    * -1\n    */\n  public int isPrefixOfWord(String sentence, String searchWord) "
    },
    "prompt_bertscore": {
      "sq": "0.9937910129192304",
      "hy": "0.9922113054988599",
      "bn": "0.9951998982119109",
      "bg": "0.9951998982119109",
      "zh": "0.9938041225243788",
      "fr": "0.9951998982119109",
      "de": "0.9790935565049349",
      "ha": "0.9951998982119109",
      "hi": "0.9951998982119109",
      "hu": "0.9788170630145343"
    },
    "canonical_solution": "  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }",
    "instruction": {
      "en": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nПредоставете кратко описание на Java кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public int isPrefixOfWord(String sentence, String searchWord)\n  {\n\n      String[] words = sentence.split(\" \");\n      for (int i = 0; i < words.length; i++) {\n          if (words[i].startsWith(searchWord)) {\n              return i + 1;\n          }\n      }\n      return -1;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9242475370632005",
      "bn": "0.8832736648025618",
      "bg": "0.899404239416024",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9407980163021705"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.isPrefixOfWord(\"hello world\", \"wor\") == 2;\n      assert solution.isPrefixOfWord(\"hello world\", \"hell\") == 1;\n      assert solution.isPrefixOfWord(\"hello world\", \"foo\") == -1;\n      System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isPrefixOfWord",
    "signature": "public int isPrefixOfWord(String sentence, String searchWord)",
    "docstring": {
      "en": "Check if the searchWord is a prefix of any word in the sentence.\nIf searchWord is a prefix of multiple words, return the index of the first matching word.\nIf searchWord is not a prefix of any word, return -1.\n\nExample:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "sq": "Kontrolloni nëse searchWord është një parashtesë e ndonjë fjale në fjali.  \nNëse searchWord është një parashtesë e disa fjalëve, kthe indeksin e fjalës së parë që përputhet.  \nNëse searchWord nuk është një parashtesë e asnjë fjale, kthe -1.\n\nShembull:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1",
      "hy": "Ստուգեք, արդյոք searchWord-ը նախածանց է նախադասության որևէ բառի համար:  \nԵթե searchWord-ը մի քանի բառերի նախածանց է, վերադարձնել առաջին համընկնող բառի ինդեքսը:  \nԵթե searchWord-ը ոչ մի բառի նախածանց չէ, վերադարձնել -1:\n\nՕրինակ:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "bn": "যাচাই করুন যে searchWord বাক্যের কোনো শব্দের উপসর্গ কিনা।  \nযদি searchWord একাধিক শব্দের উপসর্গ হয়, তাহলে প্রথম মিলে যাওয়া শব্দের সূচক ফেরত দিন।  \nযদি searchWord কোনো শব্দের উপসর্গ না হয়, তাহলে -1 ফেরত দিন।\n\nউদাহরণ:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "bg": "Проверете дали searchWord е префикс на някоя дума в изречението.  \nАко searchWord е префикс на няколко думи, върнете индекса на първата съвпадаща дума.  \nАко searchWord не е префикс на нито една дума, върнете -1.\n\nПример:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1  ",
      "zh": "检查 searchWord 是否是句子中任何单词的前缀。\n如果 searchWord 是多个单词的前缀，返回第一个匹配单词的索引。\n如果 searchWord 不是任何单词的前缀，返回 -1。\n\n示例：\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "fr": "Vérifiez si searchWord est un préfixe de n'importe quel mot dans la phrase.  \nSi searchWord est un préfixe de plusieurs mots, retournez l'indice du premier mot correspondant.  \nSi searchWord n'est le préfixe d'aucun mot, retournez -1.\n\nExemple :\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "de": "Überprüfen Sie, ob searchWord ein Präfix eines beliebigen Wortes im Satz ist. Wenn searchWord ein Präfix von mehreren Wörtern ist, geben Sie den Index des ersten übereinstimmenden Wortes zurück. Wenn searchWord kein Präfix eines Wortes ist, geben Sie -1 zurück.\n\nBeispiel:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "ha": "Duba idan searchWord kalma ce ta farko a cikin kowace kalma a cikin jumlar. Idan searchWord kalma ce ta farko a cikin kalmomi da dama, dawo da lambar kalmar farko da ta dace. Idan searchWord ba kalma ce ta farko a cikin kowace kalma ba, dawo da -1.\n\nMisali:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1",
      "hi": "किसी वाक्य में searchWord किसी शब्द का उपसर्ग है या नहीं, यह जांचें।  \nयदि searchWord कई शब्दों का उपसर्ग है, तो पहले मिलान करने वाले शब्द का सूचकांक लौटाएं।  \nयदि searchWord किसी भी शब्द का उपसर्ग नहीं है, तो -1 लौटाएं।  \n\nउदाहरण:  \n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")  \n4  \n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")  \n2  \n>>> isPrefixOfWord(\"i am tired\", \"you\")  \n-1  ",
      "hu": "Ellenőrizze, hogy a searchWord bármely szó előtagja-e a mondatban.\nHa a searchWord több szó előtagja, adja vissza az első egyező szó indexét.\nHa a searchWord nem előtagja egyetlen szónak sem, adja vissza a -1 értéket.\n\nPélda:\n>>> isPrefixOfWord(\"i love eating burger\", \"burg\")\n4\n>>> isPrefixOfWord(\"this problem is an easy problem\", \"pro\")\n2\n>>> isPrefixOfWord(\"i am tired\", \"you\")\n-1"
    },
    "docstring_bertscore": {
      "sq": "0.986381901076248",
      "hy": "0.9860094691118076",
      "bn": "0.9873329433406431",
      "bg": "0.994016458401705",
      "zh": "0.994016458401705",
      "fr": "0.9911782288870975",
      "de": "0.999999801369619",
      "ha": "0.9386490342097541",
      "hi": "0.994016458401705",
      "hu": "0.9896001105097754"
    }
  },
  {
    "task_id": "Java/24",
    "prompt": {
      "en": "class Solution {\n    /**\n    * Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n    *\n    * Example 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Explanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\n    * Example 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s consists of '(' and ')' only.\n    */\n public int minInsertions(String s) ",
      "sq": "class Solution {\n    /**\n    * Duke pasur një varg s të përbërë nga '(' dhe ')', kllapat e majta dhe të djathta në s mund të jenë të pabalancuara. Çdo operacion mund të futë një '(' ose ')', dhe të llogarisë numrin minimal të operacioneve të futjes të kërkuara. Bëni që kllapat e majta dhe të djathta në s të jenë të balancuara.\n    *\n    * Shembull 1:\n    * Input: s = \"(()))\"\n    * Output: 1\n    * Shpjegim: Duhet të shtojmë një '(' në fillim të vargut për ta bërë atë të balancuar: \"((()))\".\n    * Shembull 2:\n    * Input: s = \"((()))\"\n    * Output: 0\n    *\n    * - s përbëhet vetëm nga '(' dhe ')'.\n    */\n public int minInsertions(String s) ",
      "hy": "class Solution {\n    /**\n    * Տրված է սիմվոլային տող s, որը կազմված է '(' և ')' սիմվոլներից, s-ի ձախ և աջ փակագծերը կարող են անհավասարակշռված լինել։ Յուրաքանչյուր գործողությամբ կարող ենք տեղադրել '(' կամ ')', և հաշվարկել անհրաժեշտ ներդրման գործողությունների նվազագույն քանակը։ s-ի ձախ և աջ փակագծերը հավասարակշռված դարձնելու համար։\n    *\n    * Օրինակ 1:\n    * Մուտք: s = \"(()))\"\n    * Ելք: 1\n    * Բացատրություն: Անհրաժեշտ է ավելացնել մեկ '(' տողի սկզբում, որպեսզի այն հավասարակշռված լինի: \"((()))\".\n    * Օրինակ 2:\n    * Մուտք: s = \"((()))\"\n    * Ելք: 0\n    *\n    * - s-ը բաղկացած է միայն '(' և ')' սիմվոլներից։\n    */\n public int minInsertions(String s) ",
      "bn": "class Solution {\n    /**\n    * একটি স্ট্রিং s দেওয়া হয়েছে যা '(' এবং ')' দ্বারা গঠিত, s-এ বাম এবং ডান বন্ধনীগুলি অসমতল হতে পারে। প্রতিটি অপারেশন একটি '(' বা ')' সন্নিবেশ করতে পারে এবং প্রয়োজনীয় সন্নিবেশ অপারেশনগুলির সর্বনিম্ন সংখ্যা গণনা করতে হবে। s-এ বাম এবং ডান বন্ধনীগুলি সমতল করুন।\n    *\n    * উদাহরণ 1:\n    * ইনপুট: s = \"(()))\"\n    * আউটপুট: 1\n    * ব্যাখ্যা: স্ট্রিংটিকে সমতল করতে আমাদের স্ট্রিংয়ের শুরুতে একটি '(' যোগ করতে হবে: \"((()))\"।\n    * উদাহরণ 2:\n    * ইনপুট: s = \"((()))\"\n    * আউটপুট: 0\n    *\n    * - s শুধুমাত্র '(' এবং ')' নিয়ে গঠিত।\n    */\n public int minInsertions(String s) ",
      "bg": "class Solution {\n    /**\n    * Даден е низ s, съставен от '(' и ')', левите и десните скоби в s може да са небалансирани. Всяка операция може да вмъкне '(' или ')', и да изчисли минималния брой операции за вмъкване, необходими за балансиране на левите и десните скоби в s.\n    *\n    * Пример 1:\n    * Вход: s = \"(()))\"\n    * Изход: 1\n    * Обяснение: Трябва да добавим една '(' в началото на низа, за да го направим балансиран: \"((()))\".\n    * Пример 2:\n    * Вход: s = \"((()))\"\n    * Изход: 0\n    *\n    * - s се състои само от '(' и ')'.\n    */\n public int minInsertions(String s) ",
      "zh": "class Solution {\n    /**\n    * 给定一个由 '(' 和 ')' 组成的字符串 s，s 中的左右括号可能不平衡。每次操作可以插入一个 '(' 或 ')'，计算所需的最小插入操作次数。使 s 中的左右括号平衡。\n    *\n    * 示例 1:\n    * 输入: s = \"(()))\"\n    * 输出: 1\n    * 解释: 我们需要在字符串的开头添加一个 '(' 使其平衡: \"((()))\"。\n    * 示例 2:\n    * 输入: s = \"((()))\"\n    * 输出: 0\n    *\n    * - s 仅由 '(' 和 ')' 组成。\n    */\n public int minInsertions(String s) ",
      "fr": "class Solution {\n    /**\n    * Étant donné une chaîne s composée de '(' et ')', les parenthèses gauche et droite dans s peuvent être déséquilibrées. Chaque opération peut insérer un '(' ou ')', et calculer le nombre minimum d'opérations d'insertion requises. Rendre les parenthèses gauche et droite dans s équilibrées.\n    *\n    * Exemple 1:\n    * Entrée: s = \"(()))\"\n    * Sortie: 1\n    * Explication: Nous devons ajouter un '(' au début de la chaîne pour la rendre équilibrée: \"((()))\".\n    * Exemple 2:\n    * Entrée: s = \"((()))\"\n    * Sortie: 0\n    *\n    * - s se compose uniquement de '(' et ')'.\n    */\n public int minInsertions(String s) ",
      "de": "class Solution {\n    /**\n    * Gegeben ist ein String s, der aus '(' und ')' besteht. Die linken und rechten Klammern in s können unausgeglichen sein. Jede Operation kann ein '(' oder ')' einfügen und die minimale Anzahl der erforderlichen Einfügeoperationen berechnen. Mache die linken und rechten Klammern in s ausgeglichen.\n    *\n    * Beispiel 1:\n    * Eingabe: s = \"(()))\"\n    * Ausgabe: 1\n    * Erklärung: Wir müssen ein '(' am Anfang des Strings hinzufügen, um ihn ausgeglichen zu machen: \"((()))\".\n    * Beispiel 2:\n    * Eingabe: s = \"((()))\"\n    * Ausgabe: 0\n    *\n    * - s besteht nur aus '(' und ')'.\n    */\n public int minInsertions(String s) ",
      "ha": "class Solution {\n    /**\n    * An ba da wani igiyar haruffa s wanda aka hada da '(' da ')', watakila ba a daidaita kowane daga cikin manyan baka a cikin s ba. Kowace aiki na iya saka '(' ko ')', kuma a lissafa adadin mafi karancin ayyukan saka da ake bukata. Yi manyan baka a cikin s su zama daidaitattu.\n    *\n    * Misali 1:\n    * Shigarwa: s = \"(()))\"\n    * Fitarwa: 1\n    * Bayani: Dole ne mu kara daya '(' a farkon igiyar haruffa don ya zama daidaitacce: \"((()))\".\n    * Misali 2:\n    * Shigarwa: s = \"((()))\"\n    * Fitarwa: 0\n    *\n    * - s ya ƙunshi '(' da ')' kawai.\n    */\n public int minInsertions(String s) ",
      "hi": "class Solution {\n    /**\n    * दिए गए स्ट्रिंग s में '(' और ')' शामिल हैं, s में बाएँ और दाएँ ब्रैकेट असंतुलित हो सकते हैं। प्रत्येक ऑपरेशन में एक '(' या ')' जोड़ सकते हैं, और आवश्यक न्यूनतम जोड़ ऑपरेशनों की संख्या की गणना करें। s में बाएँ और दाएँ ब्रैकेट को संतुलित बनाएं।\n    *\n    * उदाहरण 1:\n    * इनपुट: s = \"(()))\"\n    * आउटपुट: 1\n    * व्याख्या: हमें स्ट्रिंग के पहले एक '(' जोड़ने की आवश्यकता है ताकि यह संतुलित हो जाए: \"((()))\"।\n    * उदाहरण 2:\n    * इनपुट: s = \"((()))\"\n    * आउटपुट: 0\n    *\n    * - s केवल '(' और ')' से बना है।\n    */\n public int minInsertions(String s) ",
      "hu": "class Solution {\n    /**\n    * Adott egy s karakterlánc, amely '(' és ')' jelekből áll, az s-ben lévő bal és jobb zárójelek lehetnek kiegyensúlyozatlanok. Minden művelet során beilleszthetünk egy '(' vagy ')' jelet, és kiszámíthatjuk a szükséges beillesztési műveletek minimális számát. Tegyük kiegyensúlyozottá az s-ben lévő bal és jobb zárójeleket.\n    *\n    * 1. példa:\n    * Bemenet: s = \"(()))\"\n    * Kimenet: 1\n    * Magyarázat: Egy '(' jelet kell hozzáadnunk a karakterlánc elejére, hogy kiegyensúlyozott legyen: \"((()))\".\n    * 2. példa:\n    * Bemenet: s = \"((()))\"\n    * Kimenet: 0\n    *\n    * - s csak '(' és ')' jelekből áll.\n    */\n public int minInsertions(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9835593633617423",
      "hy": "0.9485984299957916",
      "bn": "0.9378398140374179",
      "bg": "0.9636150854324103",
      "zh": "0.9377331495228022",
      "fr": "0.9801304070939371",
      "de": "0.968174248568304",
      "ha": "0.934726084184315",
      "hi": "0.9439220749350873",
      "hu": "0.9437456911567282"
    },
    "canonical_solution": " {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }",
    "instruction": {
      "en": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nՏրամադրել Java կոդի հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int minInsertions(String s)\n {\n        int insertions = 0; // Count of insertions needed\n        int balance = 0; // Balance of '(' and ')'\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            \n            if (c == '(') {\n                // Increase balance for every '(' found\n                balance++;\n            } else { // c == ')'\n                // Decrease balance for every ')' found\n                if (balance > 0) {\n                    balance--;\n                } else {\n                    // If balance is already 0, we need an insertion before this ')'\n                    insertions++;\n                    // No need to modify balance as we've virtually added '(' before this ')'\n                }\n            }\n        }\n        \n        insertions += balance;\n        System.out.println(insertions);\n        return insertions;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386897534378662",
      "hy": "0.919398969462139",
      "bn": "0.9137427707317894",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.minInsertions(\"((()))\") == 0;\n        assert solution.minInsertions(\"()()()\") == 0;\n        assert solution.minInsertions(\"(()))(()\") == 2;\n        assert solution.minInsertions(\"))())(((\") == 6;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "minInsertions",
    "signature": "public int minInsertions(String s)",
    "docstring": {
      "en": "Given a string s composed of '(' and ')', the left and right brackets in s may be unbalanced. Each operation can insert a '(' or ')', and calculate the minimum number of insertion operations required. Make the left and right brackets in s balanced.\n\nExample 1:\nInput: s = \"(()))\"\nOutput: 1\nExplanation:  We need to add one '(' at the first of the string to make it balanced: \"((()))\".\nExample 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s consists of '(' and ')' only.",
      "sq": "Duke pasur një varg s të përbërë nga '(' dhe ')', kllapat e majta dhe të djathta në s mund të jenë të pabalancuara. Çdo operacion mund të fusë një '(' ose ')', dhe llogarit numrin minimal të operacioneve të futjes të kërkuara. Bëni që kllapat e majta dhe të djathta në s të jenë të balancuara.\n\nShembull 1:\nInput: s = \"(()))\"\nOutput: 1\nShpjegim: Duhet të shtojmë një '(' në fillim të vargut për ta bërë atë të balancuar: \"((()))\".\nShembull 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s përbëhet vetëm nga '(' dhe ')'.",
      "hy": "Տրված է `s` տողը, որը կազմված է '(' և ')' սիմվոլներից, `s`-ում ձախ և աջ փակագծերը կարող են անհավասարակշռված լինել։ Յուրաքանչյուր գործողությամբ կարելի է ներդնել '(' կամ ')', և հաշվարկել անհրաժեշտ ներդրման գործողությունների նվազագույն քանակը։ `s`-ում ձախ և աջ փակագծերը հավասարակշռված դարձնել։\n\nՕրինակ 1:\nՄուտք: s = \"(()))\"\nԵլք: 1\nԲացատրություն: Անհրաժեշտ է ավելացնել մեկ '(' տողի սկզբում, որպեսզի այն հավասարակշռված լինի: \"((()))\".\nՕրինակ 2:\nՄուտք: s = \"((()))\"\nԵլք: 0\n\n- s-ը բաղկացած է միայն '(' և ')' սիմվոլներից։",
      "bn": "একটি স্ট্রিং s দেওয়া হয়েছে যা '(' এবং ')' দিয়ে গঠিত, s-এ বাম এবং ডান বন্ধনীগুলি ভারসাম্যহীন হতে পারে। প্রতিটি অপারেশন একটি '(' বা ')' সন্নিবেশ করতে পারে এবং প্রয়োজনীয় সন্নিবেশ অপারেশনের সর্বনিম্ন সংখ্যা গণনা করতে হবে। s-এ বাম এবং ডান বন্ধনীগুলিকে ভারসাম্যপূর্ণ করুন।\n\nউদাহরণ ১:\nইনপুট: s = \"(()))\"\nআউটপুট: 1\nব্যাখ্যা: স্ট্রিংটিকে ভারসাম্যপূর্ণ করতে আমাদের স্ট্রিংয়ের শুরুতে একটি '(' যোগ করতে হবে: \"((()))\"।\n\nউদাহরণ ২:\nইনপুট: s = \"((()))\"\nআউটপুট: 0\n\n- s কেবলমাত্র '(' এবং ')' নিয়ে গঠিত।",
      "bg": "Даден е низ s, съставен от '(' и ')', като левите и десните скоби в s може да са небалансирани. Всяка операция може да вмъкне '(' или ')', и да изчисли минималния брой операции за вмъкване, които са необходими. Направете така, че левите и десните скоби в s да са балансирани.\n\nПример 1:\nВход: s = \"(()))\"\nИзход: 1\nОбяснение: Трябва да добавим една '(' в началото на низа, за да го направим балансиран: \"((()))\".\nПример 2:\nВход: s = \"((()))\"\nИзход: 0\n\n- s се състои само от '(' и ')'.",
      "zh": "给定一个由 '(' 和 ')' 组成的字符串 s，s 中的左右括号可能不平衡。每次操作可以插入一个 '(' 或 ')'，计算所需的最小插入操作次数。使 s 中的左右括号平衡。\n\n示例 1:\n输入: s = \"(()))\"\n输出: 1\n解释: 我们需要在字符串的开头添加一个 '(' 使其平衡: \"((()))\"。\n示例 2:\n输入: s = \"((()))\"\n输出: 0\n\n- s 仅由 '(' 和 ')' 组成。",
      "fr": "Étant donné une chaîne s composée de '(' et ')', les parenthèses gauche et droite dans s peuvent être déséquilibrées. Chaque opération peut insérer un '(' ou ')', et calculer le nombre minimum d'opérations d'insertion requises. Rendre les parenthèses gauche et droite dans s équilibrées.\n\nExemple 1 :\nEntrée : s = \"(()))\"\nSortie : 1\nExplication : Nous devons ajouter un '(' au début de la chaîne pour la rendre équilibrée : \"((()))\".\nExemple 2 :\nEntrée : s = \"((()))\"\nSortie : 0\n\n- s se compose uniquement de '(' et ')'.",
      "de": "Gegeben ein String s, der aus '(' und ')' besteht, können die linken und rechten Klammern in s unausgeglichen sein. Jede Operation kann ein '(' oder ')' einfügen und die minimale Anzahl der erforderlichen Einfügeoperationen berechnen. Machen Sie die linken und rechten Klammern in s ausgeglichen.\n\nBeispiel 1:\nEingabe: s = \"(()))\"\nAusgabe: 1\nErläuterung: Wir müssen ein '(' am Anfang des Strings hinzufügen, um ihn ausgeglichen zu machen: \"((()))\".\nBeispiel 2:\nEingabe: s = \"((()))\"\nAusgabe: 0\n\n- s besteht nur aus '(' und ')'.",
      "ha": "An ba da wata kirtani `s` da aka hada da '(' da ')', za a iya samun rashin daidaito a cikin `s`. Kowace aiki na iya saka '(' ko ')', kuma a lissafa adadin mafi karancin ayyukan da ake bukata don sanya su daidaito. Sanya kirtani `s` daidaito tsakanin hagu da dama.\n\nMisali na 1:\nInput: s = \"(()))\"\nOutput: 1\nBayani: Dole ne mu kara daya '(' a farkon kirtani don sanya shi daidaito: \"((()))\".\nMisali na 2:\nInput: s = \"((()))\"\nOutput: 0\n\n- s ya ƙunshi '(' da ')' kawai.",
      "hi": "दी गई स्ट्रिंग s जो '(' और ')' से बनी है, उसमें बाएँ और दाएँ ब्रैकेट असंतुलित हो सकते हैं। प्रत्येक ऑपरेशन में '(' या ')' जोड़ सकते हैं, और आवश्यक न्यूनतम जोड़ ऑपरेशनों की गणना करें। s में बाएँ और दाएँ ब्रैकेट को संतुलित बनाएं।\n\nउदाहरण 1:\nइनपुट: s = \"(()))\"\nआउटपुट: 1\nव्याख्या: हमें स्ट्रिंग के पहले एक '(' जोड़ने की आवश्यकता है ताकि यह संतुलित हो जाए: \"((()))\"।\n\nउदाहरण 2:\nइनपुट: s = \"((()))\"\nआउटपुट: 0\n\n- s केवल '(' और ')' से बना है।",
      "hu": "Adott egy s karakterlánc, amely '(' és ')' jelekből áll, és az s-ben a bal és jobb zárójelek lehetnek kiegyensúlyozatlanok. Minden művelet során beilleszthetünk egy '(' vagy ')' jelet, és kiszámíthatjuk a szükséges beillesztési műveletek minimális számát. Tegyük az s-ben lévő bal és jobb zárójeleket kiegyensúlyozottá.\n\nPélda 1:\nBemenet: s = \"(()))\"\nKimenet: 1\nMagyarázat: Egy '(' jelet kell hozzáadnunk a karakterlánc elejéhez, hogy kiegyensúlyozott legyen: \"((()))\".\nPélda 2:\nBemenet: s = \"((()))\"\nKimenet: 0\n\n- s csak '(' és ')' jelekből áll."
    },
    "docstring_bertscore": {
      "sq": "0.9797645299320707",
      "hy": "0.9130964274719019",
      "bn": "0.924079495760845",
      "bg": "0.9632349068831094",
      "zh": "0.9415623460083928",
      "fr": "0.9781500621950192",
      "de": "0.9733712138577009",
      "ha": "0.8950200696458219",
      "hi": "0.9347040362120201",
      "hu": "0.9422571550812529"
    }
  },
  {
    "task_id": "Java/25",
    "prompt": {
      "en": "class Solution {\n  /**\n  * Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\n  * The array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\n  * In one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\n  * The goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n  *\n  * Example 1:\n  * Input: n = 3\n  * Output: 2\n  * Explanation: arr = [1, 3, 5]\n  * First operation: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Second operation: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Example 2:\n  * Input: n = 6\n  * Output: 9\n  */\n  public int minOperations(int n) ",
      "sq": "class Solution {\n  /**\n  * Duke pasur një numër të plotë n, kthe numrin minimal të operacioneve të kërkuara për të bërë të gjitha elementet në vargun arr të barabartë.\n  * Vargu arr ka një gjatësi prej n, dhe arr[i] = (2 * i) + 1 për 0 <= i < n.\n  * Në një operacion, mund të zgjidhni dy indekse x dhe y (0 <= x, y < n) dhe të zbrisni 1 nga arr[x] dhe të shtoni 1 në arr[y] (d.m.th., arr[x] -= 1 dhe arr[y] += 1).\n  * Qëllimi është të bëhen të gjitha elementet në arr të barabartë. Rastet e testimit do të sigurojnë që pasi të kryhen disa operacione, të gjitha elementet në arr mund të bëhen të barabarta.\n  *\n  * Shembull 1:\n  * Input: n = 3\n  * Output: 2\n  * Shpjegim: arr = [1, 3, 5]\n  * Operacioni i parë: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Operacioni i dytë: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Shembull 2:\n  * Input: n = 6\n  * Output: 9\n  */\n  public int minOperations(int n) ",
      "hy": "class Solution {\n  /**\n  * Տրված է n ամբողջ թիվը, վերադարձնել նվազագույն գործողությունների քանակը, որոնք անհրաժեշտ են, որպեսզի arr զանգվածի բոլոր տարրերը հավասար լինեն:\n  * arr զանգվածի երկարությունը n է, և arr[i] = (2 * i) + 1, որտեղ 0 <= i < n:\n  * Մի գործողության ընթացքում, դուք կարող եք ընտրել երկու ինդեքսներ x և y (0 <= x, y < n) և հանել 1 arr[x]-ից և ավելացնել 1 arr[y]-ին (այսինքն՝ arr[x] -= 1 և arr[y] += 1):\n  * Նպատակն է, որպեսզի arr-ի բոլոր տարրերը հավասար լինեն: Թեստային դեպքերը կապահովեն, որ որոշ գործողություններից հետո arr-ի բոլոր տարրերը կարող են հավասար լինել:\n  *\n  * Օրինակ 1:\n  * Մուտք: n = 3\n  * Ելք: 2\n  * Բացատրություն: arr = [1, 3, 5]\n  * Առաջին գործողություն: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Երկրորդ գործողություն: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Օրինակ 2:\n  * Մուտք: n = 6\n  * Ելք: 9\n  */\n  public int minOperations(int n) ",
      "bn": "class Solution {\n  /**\n  * একটি পূর্ণসংখ্যা n দেওয়া হলে, arr অ্যারেতে সমস্ত উপাদান সমান করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন ফেরত দিন।\n  * অ্যারে arr এর দৈর্ঘ্য n, এবং arr[i] = (2 * i) + 1 যেখানে 0 <= i < n।\n  * এক অপারেশনে, আপনি দুটি সূচক x এবং y (0 <= x, y < n) নির্বাচন করতে পারেন এবং arr[x] থেকে 1 বিয়োগ করতে পারেন এবং arr[y] তে 1 যোগ করতে পারেন (অর্থাৎ, arr[x] -= 1 এবং arr[y] += 1)।\n  * লক্ষ্য হল arr এর সমস্ত উপাদান সমান করা। পরীক্ষার ক্ষেত্রে নিশ্চিত করা হবে যে কিছু অপারেশন করার পরে, arr এর সমস্ত উপাদান সমান করা যেতে পারে।\n  *\n  * উদাহরণ 1:\n  * ইনপুট: n = 3\n  * আউটপুট: 2\n  * ব্যাখ্যা: arr = [1, 3, 5]\n  * প্রথম অপারেশন: x = 2, y = 0 -> arr = [2, 3, 4]\n  * দ্বিতীয় অপারেশন: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * উদাহরণ 2:\n  * ইনপুট: n = 6\n  * আউটপুট: 9\n  */\n  public int minOperations(int n) ",
      "bg": "class Solution {\n  /**\n  * Дадено е цяло число n, върнете минималния брой операции, необходими, за да направите всички елементи в масива arr равни.\n  * Масивът arr има дължина n, и arr[i] = (2 * i) + 1 за 0 <= i < n.\n  * В една операция можете да изберете два индекса x и y (0 <= x, y < n) и да извадите 1 от arr[x] и да добавите 1 към arr[y] (т.е., arr[x] -= 1 и arr[y] += 1).\n  * Целта е да направите всички елементи в arr равни. Тестовите случаи ще гарантират, че след извършване на някои операции, всички елементи в arr могат да бъдат направени равни.\n  *\n  * Пример 1:\n  * Вход: n = 3\n  * Изход: 2\n  * Обяснение: arr = [1, 3, 5]\n  * Първа операция: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Втора операция: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Пример 2:\n  * Вход: n = 6\n  * Изход: 9\n  */\n  public int minOperations(int n) ",
      "zh": "class Solution {\n  /**\n  * 给定一个整数 n，返回使数组 arr 中所有元素相等所需的最小操作次数。\n  * 数组 arr 的长度为 n，并且 arr[i] = (2 * i) + 1，其中 0 <= i < n。\n  * 在一次操作中，你可以选择两个索引 x 和 y (0 <= x, y < n)，并从 arr[x] 中减去 1 并将 1 加到 arr[y] (即，arr[x] -= 1 和 arr[y] += 1)。\n  * 目标是使 arr 中所有元素相等。测试用例将确保在执行一些操作后，arr 中的所有元素可以变得相等。\n  *\n  * 示例 1:\n  * 输入: n = 3\n  * 输出: 2\n  * 解释: arr = [1, 3, 5]\n  * 第一次操作: x = 2, y = 0 -> arr = [2, 3, 4]\n  * 第二次操作: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * 示例 2:\n  * 输入: n = 6\n  * 输出: 9\n  */\n  public int minOperations(int n) ",
      "fr": "class Solution {\n  /**\n  * Étant donné un entier n, renvoie le nombre minimum d'opérations nécessaires pour rendre tous les éléments du tableau arr égaux.\n  * Le tableau arr a une longueur de n, et arr[i] = (2 * i) + 1 pour 0 <= i < n.\n  * En une opération, vous pouvez sélectionner deux indices x et y (0 <= x, y < n) et soustraire 1 de arr[x] et ajouter 1 à arr[y] (c'est-à-dire, arr[x] -= 1 et arr[y] += 1).\n  * L'objectif est de rendre tous les éléments de arr égaux. Les cas de test garantiront qu'après avoir effectué certaines opérations, tous les éléments de arr peuvent être rendus égaux.\n  *\n  * Exemple 1 :\n  * Entrée : n = 3\n  * Sortie : 2\n  * Explication : arr = [1, 3, 5]\n  * Première opération : x = 2, y = 0 -> arr = [2, 3, 4]\n  * Deuxième opération : x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Exemple 2 :\n  * Entrée : n = 6\n  * Sortie : 9\n  */\n  public int minOperations(int n) ",
      "de": "class Solution {\n  /**\n  * Gegeben eine ganze Zahl n, gib die minimale Anzahl von Operationen zurück, die erforderlich sind, um alle Elemente im Array arr gleich zu machen.\n  * Das Array arr hat eine Länge von n, und arr[i] = (2 * i) + 1 für 0 <= i < n.\n  * In einer Operation kannst du zwei Indizes x und y auswählen (0 <= x, y < n) und 1 von arr[x] subtrahieren und 1 zu arr[y] addieren (d.h., arr[x] -= 1 und arr[y] += 1).\n  * Das Ziel ist es, alle Elemente in arr gleich zu machen. Die Testfälle werden sicherstellen, dass nach Durchführung einiger Operationen alle Elemente in arr gleich gemacht werden können.\n  *\n  * Beispiel 1:\n  * Eingabe: n = 3\n  * Ausgabe: 2\n  * Erklärung: arr = [1, 3, 5]\n  * Erste Operation: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Zweite Operation: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Beispiel 2:\n  * Eingabe: n = 6\n  * Ausgabe: 9\n  */\n  public int minOperations(int n) ",
      "ha": "class Solution {\n  /**\n  * An ba da wani lamba n, mayar da mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk abubuwan da ke cikin jerin arr su zama daidai.\n  * Jerin arr yana da tsawon n, kuma arr[i] = (2 * i) + 1 don 0 <= i < n.\n  * A cikin aiki guda, zaka iya zaɓar alamomi biyu x da y (0 <= x, y < n) kuma rage 1 daga arr[x] da ƙara 1 zuwa arr[y] (wato, arr[x] -= 1 da arr[y] += 1).\n  * Manufar ita ce a sanya duk abubuwan da ke cikin arr su zama daidai. Gwaje-gwajen za su tabbatar da cewa bayan yin wasu ayyuka, duk abubuwan da ke cikin arr za a iya sanya su daidai.\n  *\n  * Misali 1:\n  * Input: n = 3\n  * Output: 2\n  * Bayani: arr = [1, 3, 5]\n  * Aikin farko: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Aiki na biyu: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Misali 2:\n  * Input: n = 6\n  * Output: 9\n  */\n  public int minOperations(int n) ",
      "hi": "class Solution {\n  /**\n  * दिए गए एक पूर्णांक n के लिए, arr नामक सरणी में सभी तत्वों को समान बनाने के लिए आवश्यक न्यूनतम संचालन की संख्या लौटाएं।\n  * सरणी arr की लंबाई n है, और arr[i] = (2 * i) + 1 जहाँ 0 <= i < n।\n  * एक ऑपरेशन में, आप दो सूचकांक x और y (0 <= x, y < n) चुन सकते हैं और arr[x] से 1 घटा सकते हैं और arr[y] में 1 जोड़ सकते हैं (अर्थात, arr[x] -= 1 और arr[y] += 1)।\n  * लक्ष्य है कि arr में सभी तत्वों को समान बनाया जाए। परीक्षण मामले सुनिश्चित करेंगे कि कुछ संचालन करने के बाद, arr में सभी तत्व समान बनाए जा सकते हैं।\n  *\n  * उदाहरण 1:\n  * इनपुट: n = 3\n  * आउटपुट: 2\n  * व्याख्या: arr = [1, 3, 5]\n  * पहला ऑपरेशन: x = 2, y = 0 -> arr = [2, 3, 4]\n  * दूसरा ऑपरेशन: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * उदाहरण 2:\n  * इनपुट: n = 6\n  * आउटपुट: 9\n  */\n  public int minOperations(int n) ",
      "hu": "class Solution {\n  /**\n  * Adott egy egész szám n, térj vissza a minimális műveletek számával, amely szükséges ahhoz, hogy az arr tömb összes eleme egyenlő legyen.\n  * Az arr tömb hossza n, és arr[i] = (2 * i) + 1, ahol 0 <= i < n.\n  * Egy művelet során kiválaszthatsz két indexet, x és y (0 <= x, y < n), és kivonhatsz 1-et arr[x]-ből és hozzáadhatsz 1-et arr[y]-hez (azaz arr[x] -= 1 és arr[y] += 1).\n  * A cél az, hogy az arr összes eleme egyenlő legyen. A tesztesetek biztosítják, hogy néhány művelet végrehajtása után az arr összes eleme egyenlővé tehető.\n  *\n  * Példa 1:\n  * Bemenet: n = 3\n  * Kimenet: 2\n  * Magyarázat: arr = [1, 3, 5]\n  * Első művelet: x = 2, y = 0 -> arr = [2, 3, 4]\n  * Második művelet: x = 2, y = 0 -> arr = [3, 3, 3]\n  *\n  * Példa 2:\n  * Bemenet: n = 6\n  * Kimenet: 9\n  */\n  public int minOperations(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9967186261053036",
      "hy": "0.9863608462558584",
      "bn": "0.9831438286046174",
      "bg": "0.9991818414605173",
      "zh": "0.9875067449240487",
      "fr": "0.9950477473400382",
      "de": "0.9991818414605173",
      "ha": "0.9925650662074831",
      "hi": "0.9850236665307315",
      "hu": "0.9831424381919501"
    },
    "canonical_solution": "  {\n\n      return n * n / 4;\n  }",
    "instruction": {
      "en": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int minOperations(int n)\n  {\n\n      return n * n / 4;\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9615433705582164",
      "bn": "0.9238701393392342",
      "bg": "0.8400592418438494",
      "zh": "0.8819509850952504",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9306394627249033"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n      Solution solution = new Solution();\n\n      // Test the function with different test cases\n      assert solution.minOperations(4) == 4;\n      assert solution.minOperations(5) == 6;\n      assert solution.minOperations(7) == 12;\n      System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minOperations",
    "signature": "public int minOperations(int n)",
    "docstring": {
      "en": "Given an integer n, return the minimum number of operations required to make all elements in the array arr equal.\nThe array arr has a length of n, and arr[i] = (2 * i) + 1 for 0 <= i < n.\nIn one operation, you can select two indices x and y (0 <= x, y < n) and subtract 1 from arr[x] and add 1 to arr[y] (i.e., arr[x] -= 1 and arr[y] += 1).\nThe goal is to make all elements in arr equal. The test cases will ensure that after performing some operations, all elements in arr can be made equal.\n\nExample 1:\nInput: n = 3\nOutput: 2\nExplanation: arr = [1, 3, 5]\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nExample 2:\nInput: n = 6\nOutput: 9",
      "sq": "Duke pasur një numër të plotë n, kthe numrin minimal të operacioneve të nevojshme për të bërë të gjitha elementet në vargun arr të barabarta. Vargu arr ka një gjatësi n, dhe arr[i] = (2 * i) + 1 për 0 <= i < n. Në një operacion, ju mund të zgjidhni dy indekse x dhe y (0 <= x, y < n) dhe të zbrisni 1 nga arr[x] dhe të shtoni 1 në arr[y] (d.m.th., arr[x] -= 1 dhe arr[y] += 1). Qëllimi është të bëni të gjitha elementet në arr të barabarta. Rastet e testimit do të sigurojnë që pas kryerjes së disa operacioneve, të gjitha elementet në arr mund të bëhen të barabarta.\n\nShembull 1:\nInput: n = 3\nOutput: 2\nShpjegim: arr = [1, 3, 5]\nOperacioni i parë: x = 2, y = 0 -> arr = [2, 3, 4]\nOperacioni i dytë: x = 2, y = 0 -> arr = [3, 3, 3]\n\nShembull 2:\nInput: n = 6\nOutput: 9",
      "hy": "Տրված է ամբողջ թիվ n, վերադարձնել նվազագույն գործողությունների քանակը, որոնք անհրաժեշտ են, որպեսզի զանգվածի բոլոր տարրերը arr հավասար լինեն:\nԶանգվածը arr ունի n երկարություն, և arr[i] = (2 * i) + 1 0 <= i < n համար:\nՄեկ գործողության ընթացքում դուք կարող եք ընտրել երկու ինդեքս x և y (0 <= x, y < n) և հանել 1 arr[x]-ից և ավելացնել 1 arr[y]-ին (այսինքն՝ arr[x] -= 1 և arr[y] += 1):\nՆպատակն է, որպեսզի arr-ի բոլոր տարրերը հավասար լինեն: Թեստային դեպքերը կապահովեն, որ որոշ գործողություններ կատարելուց հետո arr-ի բոլոր տարրերը կարող են հավասար լինել:\n\nՕրինակ 1:\nՄուտքագրում: n = 3\nԵլք: 2\nԲացատրություն: arr = [1, 3, 5]\nԱռաջին գործողություն: x = 2, y = 0 -> arr = [2, 3, 4]\nԵրկրորդ գործողություն: x = 2, y = 0 -> arr = [3, 3, 3]\n\nՕրինակ 2:\nՄուտքագրում: n = 6\nԵլք: 9",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, arr অ্যারেতে সমস্ত উপাদান সমান করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন ফেরত দিন। অ্যারে arr এর দৈর্ঘ্য n, এবং arr[i] = (2 * i) + 1 যেখানে 0 <= i < n। একটি অপারেশনে, আপনি দুটি সূচক x এবং y (0 <= x, y < n) নির্বাচন করতে পারেন এবং arr[x] থেকে 1 বিয়োগ এবং arr[y] তে 1 যোগ করতে পারেন (অর্থাৎ, arr[x] -= 1 এবং arr[y] += 1)। লক্ষ্য হল arr এর সমস্ত উপাদান সমান করা। পরীক্ষার ক্ষেত্রে নিশ্চিত করা হবে যে কিছু অপারেশন করার পরে, arr এর সমস্ত উপাদান সমান করা যেতে পারে।\n\nউদাহরণ 1:\nইনপুট: n = 3\nআউটপুট: 2\nব্যাখ্যা: arr = [1, 3, 5]\nপ্রথম অপারেশন: x = 2, y = 0 -> arr = [2, 3, 4]\nদ্বিতীয় অপারেশন: x = 2, y = 0 -> arr = [3, 3, 3]\n\nউদাহরণ 2:\nইনপুট: n = 6\nআউটপুট: 9",
      "bg": "Дадено е цяло число n, върнете минималния брой операции, необходими, за да направите всички елементи в масива arr равни.\nМасивът arr има дължина n, и arr[i] = (2 * i) + 1 за 0 <= i < n.\nВ една операция можете да изберете два индекса x и y (0 <= x, y < n) и да извадите 1 от arr[x] и да добавите 1 към arr[y] (т.е. arr[x] -= 1 и arr[y] += 1).\nЦелта е да направите всички елементи в arr равни. Тестовите случаи ще гарантират, че след извършване на някои операции, всички елементи в arr могат да бъдат направени равни.\n\nПример 1:\nВход: n = 3\nИзход: 2\nОбяснение: arr = [1, 3, 5]\nПърва операция: x = 2, y = 0 -> arr = [2, 3, 4]\nВтора операция: x = 2, y = 0 -> arr = [3, 3, 3]\n\nПример 2:\nВход: n = 6\nИзход: 9",
      "zh": "给定一个整数 n，返回使数组 arr 中所有元素相等所需的最小操作次数。  \n数组 arr 的长度为 n，并且 arr[i] = (2 * i) + 1，其中 0 <= i < n。  \n在一次操作中，你可以选择两个索引 x 和 y (0 <= x, y < n)，然后从 arr[x] 中减去 1 并加到 arr[y] 上（即，arr[x] -= 1 和 arr[y] += 1）。  \n目标是使 arr 中的所有元素相等。测试用例将确保在执行一些操作后，arr 中的所有元素可以变得相等。\n\n示例 1:  \n输入: n = 3  \n输出: 2  \n解释: arr = [1, 3, 5]  \n第一次操作: x = 2, y = 0 -> arr = [2, 3, 4]  \n第二次操作: x = 2, y = 0 -> arr = [3, 3, 3]  \n\n示例 2:  \n输入: n = 6  \n输出: 9",
      "fr": "Étant donné un entier n, retournez le nombre minimum d'opérations nécessaires pour rendre tous les éléments du tableau arr égaux.\nLe tableau arr a une longueur de n, et arr[i] = (2 * i) + 1 pour 0 <= i < n.\nDans une opération, vous pouvez sélectionner deux indices x et y (0 <= x, y < n) et soustraire 1 de arr[x] et ajouter 1 à arr[y] (c'est-à-dire, arr[x] -= 1 et arr[y] += 1).\nL'objectif est de rendre tous les éléments de arr égaux. Les cas de test garantiront qu'après avoir effectué certaines opérations, tous les éléments de arr peuvent être rendus égaux.\n\nExemple 1 :\nEntrée : n = 3\nSortie : 2\nExplication : arr = [1, 3, 5]\nPremière opération : x = 2, y = 0 -> arr = [2, 3, 4]\nDeuxième opération : x = 2, y = 0 -> arr = [3, 3, 3]\n\nExemple 2 :\nEntrée : n = 6\nSortie : 9",
      "de": "Gegeben eine ganze Zahl n, gib die minimale Anzahl von Operationen zurück, die erforderlich sind, um alle Elemente im Array arr gleich zu machen.\nDas Array arr hat eine Länge von n, und arr[i] = (2 * i) + 1 für 0 <= i < n.\nIn einer Operation kannst du zwei Indizes x und y (0 <= x, y < n) auswählen und 1 von arr[x] subtrahieren und 1 zu arr[y] addieren (d.h., arr[x] -= 1 und arr[y] += 1).\nDas Ziel ist es, alle Elemente in arr gleich zu machen. Die Testfälle werden sicherstellen, dass nach Durchführung einiger Operationen alle Elemente in arr gleich gemacht werden können.\n\nBeispiel 1:\nEingabe: n = 3\nAusgabe: 2\nErklärung: arr = [1, 3, 5]\nErste Operation: x = 2, y = 0 -> arr = [2, 3, 4]\nZweite Operation: x = 2, y = 0 -> arr = [3, 3, 3]\n\nBeispiel 2:\nEingabe: n = 6\nAusgabe: 9",
      "ha": "An ba da wani lamba n, mayar da mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk abubuwan da ke cikin jerin arr su zama daidai.\nJerin arr yana da tsawon n, kuma arr[i] = (2 * i) + 1 don 0 <= i < n.\nA cikin aiki guda, za ka iya zaɓar alamomi biyu x da y (0 <= x, y < n) kuma ka cire 1 daga arr[x] ka ƙara 1 zuwa arr[y] (watau, arr[x] -= 1 da arr[y] += 1).\nManufar ita ce a sanya duk abubuwan da ke cikin arr su zama daidai. Gwaje-gwajen za su tabbatar da cewa bayan yin wasu ayyuka, duk abubuwan da ke cikin arr za a iya sanya su daidai.\n\nExample 1:  \nMisali na 1:\n\nInput: n = 3  \nShigarwa: n = 3\n\nOutput: 2  \nFitarwa: 2\n\nExplanation: arr = [1, 3, 5]  \nBayani: arr = [1, 3, 5]\n\nFirst operation: x = 2, y = 0 -> arr = [2, 3, 4]  \nAiki na farko: x = 2, y = 0 -> arr = [2, 3, 4]\n\nSecond operation: x = 2, y = 0 -> arr = [3, 3, 3]  \nAiki na biyu: x = 2, y = 0 -> arr = [3, 3, 3]\n\nExample 2:  \nMisali na 2:\n\nInput: n = 6  \nShigarwa: n = 6\n\nOutput: 9  \nFitarwa: 9",
      "hi": "दी गई एक पूर्णांक n के लिए, arr में सभी तत्वों को समान बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या लौटाएं।\nसरणी arr की लंबाई n है, और arr[i] = (2 * i) + 1 है जहाँ 0 <= i < n।\nएक ऑपरेशन में, आप दो इंडेक्स x और y (0 <= x, y < n) का चयन कर सकते हैं और arr[x] से 1 घटा सकते हैं और arr[y] में 1 जोड़ सकते हैं (अर्थात, arr[x] -= 1 और arr[y] += 1)।\nलक्ष्य यह है कि arr में सभी तत्वों को समान बनाया जाए। परीक्षण मामले यह सुनिश्चित करेंगे कि कुछ ऑपरेशनों को करने के बाद, arr में सभी तत्व समान बनाए जा सकते हैं।\n\nउदाहरण 1:\nइनपुट: n = 3\nआउटपुट: 2\nव्याख्या: arr = [1, 3, 5]\nपहला ऑपरेशन: x = 2, y = 0 -> arr = [2, 3, 4]\nदूसरा ऑपरेशन: x = 2, y = 0 -> arr = [3, 3, 3]\n\nउदाहरण 2:\nइनपुट: n = 6\nआउटपुट: 9",
      "hu": "Adott egy egész szám n, térj vissza a minimális műveletek számával, amely szükséges ahhoz, hogy az arr tömb összes elemét egyenlővé tegyük.\nAz arr tömb hossza n, és arr[i] = (2 * i) + 1, ahol 0 <= i < n.\nEgy művelet során kiválaszthatsz két indexet x és y (0 <= x, y < n), és kivonhatsz 1-et arr[x]-ből, valamint hozzáadhatsz 1-et arr[y]-hoz (azaz arr[x] -= 1 és arr[y] += 1).\nA cél az, hogy az arr összes eleme egyenlő legyen. A tesztesetek biztosítják, hogy néhány művelet elvégzése után az arr összes eleme egyenlővé tehető.\n\nPélda 1:\nBemenet: n = 3\nKimenet: 2\nMagyarázat: arr = [1, 3, 5]\nElső művelet: x = 2, y = 0 -> arr = [2, 3, 4]\nMásodik művelet: x = 2, y = 0 -> arr = [3, 3, 3]\n\nPélda 2:\nBemenet: n = 6\nKimenet: 9"
    },
    "docstring_bertscore": {
      "sq": "0.9965918999222034",
      "hy": "0.9905287075411134",
      "bn": "0.9795730502447532",
      "bg": "0.9923624632188275",
      "zh": "0.9826802252952819",
      "fr": "0.9958794127454312",
      "de": "0.9949297608937034",
      "ha": "0.9877832384144491",
      "hi": "0.9807721818550608",
      "hu": "0.9734981386711821"
    }
  },
  {
    "task_id": "Java/26",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n     *\n     * Example:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n     *\n     * Constraints:\n     * - The length of the `gain` array is between 1 and 100, inclusive.\n     * - Each element in the `gain` array is between -100 and 100, inclusive.\n     */\n    public int highestAltitude(int[] gain) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një varg të plotë `gain` që përfaqëson fitimin neto në lartësi midis pikave të njëpasnjëshme, kthe lartësinë më të lartë të arritur.\n     *\n     * Shembull:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Shpjegim: Lartësitë janë [0,-5,-4,1,1,-6]. Lartësia më e lartë e arritur është 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Shpjegim: Lartësitë janë [0,-4,-7,-9,-10,-6,-3,-1]. Lartësia më e lartë e arritur është 0.\n     *\n     * Kufizimet:\n     * - Gjatësia e vargut `gain` është midis 1 dhe 100, përfshirë.\n     * - Çdo element në vargun `gain` është midis -100 dhe 100, përfshirë.\n     */\n    public int highestAltitude(int[] gain) ",
      "hy": "class Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված `gain`, որը ներկայացնում է բարձրության զուտ աճը հաջորդական կետերի միջև, վերադարձնել հասած ամենաբարձր բարձրությունը:\n     *\n     * Օրինակ:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Բացատրություն: Բարձրությունները [0,-5,-4,1,1,-6] են: Հասած ամենաբարձր բարձրությունը 1 է:\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Բացատրություն: Բարձրությունները [0,-4,-7,-9,-10,-6,-3,-1] են: Հասած ամենաբարձր բարձրությունը 0 է:\n     *\n     * Պահանջներ:\n     * - `gain` զանգվածի երկարությունը 1-ից 100 է, ներառյալ:\n     * - `gain` զանգվածի յուրաքանչյուր տարր -100-ից 100 է, ներառյալ:\n     */\n    public int highestAltitude(int[] gain) ",
      "bn": "class Solution {\n    /**\n     * একটি পূর্ণসংখ্যার অ্যারে `gain` দেওয়া হয়েছে যা পরপর বিন্দুগুলির মধ্যে উচ্চতার নিট বৃদ্ধি উপস্থাপন করে, সর্বোচ্চ উচ্চতা ফেরত দিন যা পৌঁছানো হয়েছে।\n     *\n     * উদাহরণ:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * ব্যাখ্যা: উচ্চতাগুলি হল [0,-5,-4,1,1,-6]। সর্বোচ্চ উচ্চতা যা পৌঁছানো হয়েছে তা হল 1।\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * ব্যাখ্যা: উচ্চতাগুলি হল [0,-4,-7,-9,-10,-6,-3,-1]। সর্বোচ্চ উচ্চতা যা পৌঁছানো হয়েছে তা হল 0।\n     *\n     * শর্তাবলী:\n     * - `gain` অ্যারের দৈর্ঘ্য 1 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।\n     * - `gain` অ্যারের প্রতিটি উপাদান -100 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।\n     */\n    public int highestAltitude(int[] gain) ",
      "bg": "class Solution {\n    /**\n     * Като се даде масив от цели числа `gain`, представляващ нетната печалба във височина между последователни точки, върнете най-високата достигната височина.\n     *\n     * Пример:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Обяснение: Височините са [0,-5,-4,1,1,-6]. Най-високата достигната височина е 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Обяснение: Височините са [0,-4,-7,-9,-10,-6,-3,-1]. Най-високата достигната височина е 0.\n     *\n     * Ограничения:\n     * - Дължината на масива `gain` е между 1 и 100, включително.\n     * - Всеки елемент в масива `gain` е между -100 и 100, включително.\n     */\n    public int highestAltitude(int[] gain) ",
      "zh": "class Solution {\n    /**\n     * 给定一个整数数组 `gain`，表示连续点之间的海拔净增益，返回达到的最高海拔。\n     *\n     * 示例:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * 解释: 海拔为 [0,-5,-4,1,1,-6]。达到的最高海拔是 1。\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * 解释: 海拔为 [0,-4,-7,-9,-10,-6,-3,-1]。达到的最高海拔是 0。\n     *\n     * 约束条件:\n     * - `gain` 数组的长度在 1 到 100 之间（包括 1 和 100）。\n     * - `gain` 数组中的每个元素在 -100 到 100 之间（包括 -100 和 100）。\n     */\n    public int highestAltitude(int[] gain) ",
      "fr": "class Solution {\n    /**\n     * Étant donné un tableau d'entiers `gain` représentant le gain net en altitude entre des points consécutifs, renvoie l'altitude la plus élevée atteinte.\n     *\n     * Exemple:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Explication : Les altitudes sont [0,-5,-4,1,1,-6]. L'altitude la plus élevée atteinte est 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Explication : Les altitudes sont [0,-4,-7,-9,-10,-6,-3,-1]. L'altitude la plus élevée atteinte est 0.\n     *\n     * Contraintes :\n     * - La longueur du tableau `gain` est comprise entre 1 et 100, inclus.\n     * - Chaque élément du tableau `gain` est compris entre -100 et 100, inclus.\n     */\n    public int highestAltitude(int[] gain) ",
      "de": "class Solution {\n    /**\n     * Gegeben ein ganzzahliges Array `gain`, das den Nettogewinn in der Höhe zwischen aufeinanderfolgenden Punkten darstellt, gib die höchste erreichte Höhe zurück.\n     *\n     * Beispiel:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Erklärung: Die Höhen sind [0,-5,-4,1,1,-6]. Die höchste erreichte Höhe ist 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Erklärung: Die Höhen sind [0,-4,-7,-9,-10,-6,-3,-1]. Die höchste erreichte Höhe ist 0.\n     *\n     * Einschränkungen:\n     * - Die Länge des `gain` Arrays liegt zwischen 1 und 100, einschließlich.\n     * - Jedes Element im `gain` Array liegt zwischen -100 und 100, einschließlich.\n     */\n    public int highestAltitude(int[] gain) ",
      "ha": "class Solution {\n    /**\n     * An ba da wani jerin lambobi `gain` wanda ke wakiltar ribar tsawo tsakanin maki masu jere, dawo da mafi girman tsawo da aka kai.\n     *\n     * Misali:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Bayani: Tsawowin suna [0,-5,-4,1,1,-6]. Mafi girman tsawo da aka kai shine 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Bayani: Tsawowin suna [0,-4,-7,-9,-10,-6,-3,-1]. Mafi girman tsawo da aka kai shine 0.\n     *\n     * Ƙuntatawa:\n     * - Tsawon jerin `gain` yana tsakanin 1 da 100, ciki har da.\n     * - Kowane abu a cikin jerin `gain` yana tsakanin -100 da 100, ciki har da.\n     */\n    public int highestAltitude(int[] gain) ",
      "hi": "class Solution {\n    /**\n     * दिए गए एक पूर्णांक array `gain` जो लगातार बिंदुओं के बीच ऊंचाई में शुद्ध लाभ का प्रतिनिधित्व करता है, उच्चतम ऊंचाई लौटाएं जो प्राप्त की गई है।\n     *\n     * उदाहरण:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * व्याख्या: ऊंचाइयां [0,-5,-4,1,1,-6] हैं। प्राप्त की गई उच्चतम ऊंचाई 1 है।\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * व्याख्या: ऊंचाइयां [0,-4,-7,-9,-10,-6,-3,-1] हैं। प्राप्त की गई उच्चतम ऊंचाई 0 है।\n     *\n     * बाधाएं:\n     * - `gain` array की लंबाई 1 और 100 के बीच है, समावेशी।\n     * - `gain` array में प्रत्येक तत्व -100 और 100 के बीच है, समावेशी।\n     */\n    public int highestAltitude(int[] gain) ",
      "hu": "class Solution {\n    /**\n     * Adott egy `gain` egész számokat tartalmazó tömb, amely a magasság közötti nettó nyereséget jelenti az egymást követő pontok között, adja vissza a legmagasabb elért magasságot.\n     *\n     * Példa:\n     * >>> highestAltitude([-5,1,5,0,-7])\n     * 1\n     * Magyarázat: A magasságok [0,-5,-4,1,1,-6]. A legmagasabb elért magasság 1.\n     *\n     * >>> highestAltitude([-4,-3,-2,-1,4,3,2])\n     * 0\n     * Magyarázat: A magasságok [0,-4,-7,-9,-10,-6,-3,-1]. A legmagasabb elért magasság 0.\n     *\n     * Korlátozások:\n     * - A `gain` tömb hossza 1 és 100 között van, beleértve.\n     * - A `gain` tömb minden eleme -100 és 100 között van, beleértve.\n     */\n    public int highestAltitude(int[] gain) "
    },
    "prompt_bertscore": {
      "sq": "0.9927223814692627",
      "hy": "0.9744320987228081",
      "bn": "0.999038231695029",
      "bg": "0.9905618788147462",
      "zh": "0.9742221464100543",
      "fr": "0.990372385431239",
      "de": "1",
      "ha": "0.9751970243201735",
      "hi": "0.9965009272076895",
      "hu": "0.9760690116929167"
    },
    "canonical_solution": "    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }",
    "instruction": {
      "en": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки най-много 500 знака.",
      "zh": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\n请提供一段中文的简洁自然语言描述（文档字符串），用于描述该Java代码，字数不超过500个字符。",
      "fr": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nजावा कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों में प्रदान करें।",
      "hu": "public int highestAltitude(int[] gain)\n    {\n\n        int altitude = 0, highest = 0;\n        for (int i : gain) {\n            altitude += i;\n            highest = Math.max(highest, altitude);\n        }\n        return highest;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9615433705582164",
      "bn": "0.9011084880853033",
      "bg": "0.8459003654589423",
      "zh": "0.8757628542044895",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.952466359405684",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.highestAltitude(new int[]{-5,1,5,0,-7}) == 1;\n        assert solution.highestAltitude(new int[]{-4,-3,-2,-1,4,3,2}) == 0;\n        assert solution.highestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2, 1}) == 0;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "highestAltitude",
    "signature": "public int highestAltitude(int[] gain)",
    "docstring": {
      "en": "Given an integer array `gain` representing the net gain in altitude between consecutive points, return the highest altitude reached.\n\nExample:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplanation: The altitudes are [0,-5,-4,1,1,-6]. The highest altitude reached is 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplanation: The altitudes are [0,-4,-7,-9,-10,-6,-3,-1]. The highest altitude reached is 0.\n\nConstraints:\n- The length of the `gain` array is between 1 and 100, inclusive.\n- Each element in the `gain` array is between -100 and 100, inclusive.",
      "sq": "Duke pasur një varg të plotë `gain` që përfaqëson fitimin neto në lartësi midis pikave të njëpasnjëshme, kthe lartësinë më të lartë të arritur.\n\nShembull:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nShpjegim: Lartësitë janë [0,-5,-4,1,1,-6]. Lartësia më e lartë e arritur është 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nShpjegim: Lartësitë janë [0,-4,-7,-9,-10,-6,-3,-1]. Lartësia më e lartë e arritur është 0.\n\nKufizimet:\n- Gjatësia e vargut `gain` është midis 1 dhe 100, përfshirë.\n- Çdo element në vargun `gain` është midis -100 dhe 100, përfshirë.",
      "hy": "Տրված է ամբողջ թվերի զանգված `gain`, որը ներկայացնում է բարձրության զուտ աճը հաջորդական կետերի միջև, վերադարձնել ամենաբարձր հասած բարձրությունը:\n\nՕրինակ:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nԲացատրություն: Բարձրությունները են [0,-5,-4,1,1,-6]: Ամենաբարձր հասած բարձրությունը 1 է:\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nԲացատրություն: Բարձրությունները են [0,-4,-7,-9,-10,-6,-3,-1]: Ամենաբարձր հասած բարձրությունը 0 է:\n\nՊահանջներ:\n- `gain` զանգվածի երկարությունը 1-ից 100-ի միջև է, ներառյալ:\n- `gain` զանգվածի յուրաքանչյուր տարր -100-ից 100-ի միջև է, ներառյալ:",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে `gain` দেওয়া হয়েছে যা পরপর বিন্দুগুলির মধ্যে উচ্চতার নিট বৃদ্ধি উপস্থাপন করে, সর্বোচ্চ উচ্চতা ফেরত দিন যা অর্জিত হয়েছে।\n\nউদাহরণ:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nব্যাখ্যা: উচ্চতাগুলি হল [0,-5,-4,1,1,-6]। সর্বোচ্চ উচ্চতা যা অর্জিত হয়েছে তা হল 1।\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nব্যাখ্যা: উচ্চতাগুলি হল [0,-4,-7,-9,-10,-6,-3,-1]। সর্বোচ্চ উচ্চতা যা অর্জিত হয়েছে তা হল 0।\n\nসীমাবদ্ধতা:\n- `gain` অ্যারের দৈর্ঘ্য 1 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।\n- `gain` অ্যারের প্রতিটি উপাদান -100 এবং 100 এর মধ্যে, অন্তর্ভুক্ত।",
      "bg": "Даден е масив от цели числа `gain`, представляващ нетната печалба в надморска височина между последователни точки, върнете най-високата достигната надморска височина.\n\nПример:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nОбяснение: Надморските височини са [0,-5,-4,1,1,-6]. Най-високата достигната надморска височина е 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nОбяснение: Надморските височини са [0,-4,-7,-9,-10,-6,-3,-1]. Най-високата достигната надморска височина е 0.\n\nОграничения:\n- Дължината на масива `gain` е между 1 и 100, включително.\n- Всеки елемент в масива `gain` е между -100 и 100, включително.",
      "zh": "给定一个整数数组 `gain`，表示连续点之间的海拔净增益，返回达到的最高海拔。\n\n示例：\n>>> highestAltitude([-5,1,5,0,-7])\n1\n解释：海拔为 [0,-5,-4,1,1,-6]。达到的最高海拔是 1。\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\n解释：海拔为 [0,-4,-7,-9,-10,-6,-3,-1]。达到的最高海拔是 0。\n\n约束条件：\n- `gain` 数组的长度在 1 到 100 之间（包括 1 和 100）。\n- `gain` 数组中的每个元素在 -100 到 100 之间（包括 -100 和 100）。",
      "fr": "Étant donné un tableau d'entiers `gain` représentant le gain net en altitude entre des points consécutifs, renvoyez l'altitude la plus élevée atteinte.\n\nExemple :\n>>> highestAltitude([-5,1,5,0,-7])\n1\nExplication : Les altitudes sont [0,-5,-4,1,1,-6]. L'altitude la plus élevée atteinte est 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nExplication : Les altitudes sont [0,-4,-7,-9,-10,-6,-3,-1]. L'altitude la plus élevée atteinte est 0.\n\nContraintes :\n- La longueur du tableau `gain` est comprise entre 1 et 100, inclus.\n- Chaque élément du tableau `gain` est compris entre -100 et 100, inclus.",
      "de": "Gegeben ein Integer-Array `gain`, das den Nettogewinn in der Höhe zwischen aufeinanderfolgenden Punkten darstellt, gib die höchste erreichte Höhe zurück.\n\nBeispiel:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nErläuterung: Die Höhen sind [0,-5,-4,1,1,-6]. Die höchste erreichte Höhe ist 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nErläuterung: Die Höhen sind [0,-4,-7,-9,-10,-6,-3,-1]. Die höchste erreichte Höhe ist 0.\n\nEinschränkungen:\n- Die Länge des `gain`-Arrays liegt zwischen 1 und 100, einschließlich.\n- Jedes Element im `gain`-Array liegt zwischen -100 und 100, einschließlich.",
      "ha": "An ba da jerin lambobi `gain` wanda ke wakiltar karin tsawo tsakanin maki masu jere, dawo da mafi girman tsawo da aka kai.\n\nMisali:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nBayani: Matsayin tsayin daka sun kasance [0,-5,-4,1,1,-6]. Mafi girman tsayin daka da aka kai shine 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nBayani: Matsayin tsayin daka sun kasance [0,-4,-7,-9,-10,-6,-3,-1]. Mafi girman tsayin daka da aka kai shine 0.\n\nTakaitaccen bayani:\n- Tsawon jerin `gain` yana tsakanin 1 da 100, har da.\n- Kowanne abu a cikin jerin `gain` yana tsakanin -100 da 100, har da.",
      "hi": "दिए गए पूर्णांक array `gain` जो लगातार बिंदुओं के बीच ऊँचाई में शुद्ध लाभ को दर्शाता है, के आधार पर सबसे अधिक ऊँचाई लौटाएँ।\n\nउदाहरण:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nव्याख्या: ऊँचाइयाँ [0,-5,-4,1,1,-6] हैं। सबसे अधिक ऊँचाई जो प्राप्त की गई है वह 1 है।\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nव्याख्या: ऊँचाइयाँ [0,-4,-7,-9,-10,-6,-3,-1] हैं। सबसे अधिक ऊँचाई जो प्राप्त की गई है वह 0 है।\n\nबाधाएँ:\n- `gain` array की लंबाई 1 और 100 के बीच है, दोनों सम्मिलित।\n- `gain` array का प्रत्येक तत्व -100 और 100 के बीच है, दोनों सम्मिलित।",
      "hu": "Adott egy egész számokból álló tömb `gain`, amely a nettó magasságnövekedést jelenti az egymást követő pontok között, adja vissza az elért legmagasabb magasságot.\n\nPélda:\n>>> highestAltitude([-5,1,5,0,-7])\n1\nMagyarázat: A magasságok [0,-5,-4,1,1,-6]. Az elért legmagasabb magasság 1.\n\n>>> highestAltitude([-4,-3,-2,-1,4,3,2])\n0\nMagyarázat: A magasságok [0,-4,-7,-9,-10,-6,-3,-1]. Az elért legmagasabb magasság 0.\n\nKorlátozások:\n- A `gain` tömb hossza 1 és 100 között van, beleértve.\n- A `gain` tömb minden eleme -100 és 100 között van, beleértve."
    },
    "docstring_bertscore": {
      "sq": "0.9834689865383714",
      "hy": "0.9830123352923722",
      "bn": "0.951184994817628",
      "bg": "0.9866295931613985",
      "zh": "0.9759365252287664",
      "fr": "0.9873553885737001",
      "de": "1",
      "ha": "0.9807068324597003",
      "hi": "0.9937113621364354",
      "hu": "0.9694653460450308"
    }
  },
  {
    "task_id": "Java/27",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given an integer array nums, return the maximum absolute sum of any subarray.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një varg të plotë nums, kthe maksimumin e shumës absolute të çdo nënvargu.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "hy": "class Solution {\n    /**\n     * Տրված է ամբողջ թվերի զանգված nums, վերադարձնել ցանկացած ենթազանգվածի առավելագույն բացարձակ գումարը։\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "bn": "class Solution {\n    /**\n     * একটি পূর্ণসংখ্যা অ্যারে nums দেওয়া হলে, যেকোনো উপঅ্যারের সর্বাধিক পরম যোগফল ফেরত দিন।\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "bg": "class Solution {\n    /**\n     * Даден е масив от цели числа nums, върнете максималната абсолютна сума на произволен подмасив.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "zh": "class Solution {\n    /**\n     * 给定一个整数数组 nums，返回任何子数组的最大绝对和。\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "fr": "class Solution {\n    /**\n     * Étant donné un tableau d'entiers nums, renvoie la somme absolue maximale de n'importe quel sous-tableau.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "de": "class Solution {\n    /**\n     * Gegeben ein ganzzahliges Array nums, gib die maximale absolute Summe eines beliebigen Teilarrays zurück.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "ha": "class Solution {\n    /**\n     * Idan aka ba da jerin lambobi na integer nums, dawo da mafi girman adadin da ba shi da alamar kowace ƙananan rukuni.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "hi": "class Solution {\n    /**\n     * दिए गए पूर्णांक सरणी nums के लिए, किसी भी उपसरणी का अधिकतम परिपूर्ण योगफल लौटाएं।\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) ",
      "hu": "class Solution {\n    /**\n     * Adott egy egész számokat tartalmazó tömb, nums, térj vissza bármely részhalmaz maximális abszolút összegével.\n     *\n     * >>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n     * 5\n     *\n     * >>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n     * 8\n     */\n    public int maxAbsoluteSum(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9900144534846141",
      "bn": "1",
      "bg": "0.9900144534846141",
      "zh": "1",
      "fr": "0.9900144534846141",
      "de": "1",
      "ha": "0.9900144534846141",
      "hi": "0.9892753498367833",
      "hu": "0.97837093917873"
    },
    "canonical_solution": "    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }",
    "instruction": {
      "en": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nBayar da taƙaitaccen bayanin harshen halitta (docstring) na lambar Java cikin harshen Hausa ta amfani da haruffa 500 kawai.",
      "hi": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nजावा कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int maxAbsoluteSum(int[] nums)\n    {\n\n        int maxSoFar = 0, minSoFar = 0, maxTotal = 0;\n        for (int num : nums) {\n            maxSoFar = Math.max(num, maxSoFar + num);\n            minSoFar = Math.min(num, minSoFar + num);\n            maxTotal = Math.max(maxTotal, Math.max(maxSoFar, -minSoFar));\n        }\n        return maxTotal;\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9615433705582164",
      "bn": "0.8954556660714315",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.952466359405684",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.maxAbsoluteSum(new int[]{1,-3,2,3,-4}) == 5;\n        assert solution.maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2}) == 8;\n        assert solution.maxAbsoluteSum(new int[]{-2, -3, 4, -1, -2, 1, 5, -3}) == 7;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "maxAbsoluteSum",
    "signature": "public int maxAbsoluteSum(int[] nums)",
    "docstring": {
      "en": "Given an integer array nums, return the maximum absolute sum of any subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "sq": "Duke pasur një varg të plotë nums, kthe maksimumin e shumës absolute të çdo nënvargu.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hy": "Տրված է ամբողջ թվերի զանգված `nums`, վերադարձնել ցանկացած ենթազանգվածի առավելագույն բացարձակ գումարը։\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "bn": "প্রদত্ত একটি পূর্ণসংখ্যার অ্যারে nums, যেকোনো উপঅ্যারের সর্বাধিক পরম যোগফল ফেরত দিন।\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "bg": "Даден е масив от цели числа nums, върнете максималната абсолютна сума на произволен подмасив.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "zh": "给定一个整数数组 `nums`，返回任何子数组的最大绝对和。\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "fr": "Étant donné un tableau d'entiers nums, renvoyez la somme absolue maximale de n'importe quel sous-tableau.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "de": "Gegeben ein Integer-Array nums, gib die maximale absolute Summe eines beliebigen Teilarrays zurück.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "ha": "An ba da jerin lambobi na integers nums, mayar da mafi girman jimlar da ba ta da alamar kowace subarray.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hi": "दिए गए पूर्णांक array nums के लिए, किसी भी उपarray का अधिकतम परिमाणात्मक योग लौटाएं।\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8",
      "hu": "Adott egy egész számokat tartalmazó tömb, nums, térj vissza bármely részhalmaz maximális abszolút összegével.\n\n>>> maxAbsoluteSum(new int[]{1,-3,2,3,-4})\n5\n\n>>> maxAbsoluteSum(new int[]{2,-5,1,-4,3,-2})\n8"
    },
    "docstring_bertscore": {
      "sq": "0.9714446977920435",
      "hy": "0.9859518663013075",
      "bn": "0.971846527052877",
      "bg": "0.9859518663013075",
      "zh": "0.999999801369619",
      "fr": "0.9859518663013075",
      "de": "0.999999801369619",
      "ha": "0.9584344022508821",
      "hi": "0.9840827544157692",
      "hu": "0.9469702567624486"
    }
  },
  {
    "task_id": "Java/28",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\n     * Fibonacci numbers are defined as follows:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, for n > 2.\n     * It is guaranteed that there is at least one valid solution for the given k.\n     *\n     * Example 1:\n     * Input: k = 7\n     * Output: 2\n     * Explanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\n     * For k = 7, we can get 2 + 5 = 7.\n     *\n     * Example 2:\n     * Input: k = 10\n     * Output: 2\n     * Explanation: For k = 10, we can get 2 + 8 = 10.\n     *\n     * Example 3:\n     * Input: k = 19\n     * Output: 3\n     * Explanation: For k = 19, we can get 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Duke pasur një numër të plotë k, kthe numrin minimal të numrave të Fibonaccit, shuma e të cilëve është e barabartë me k.\n     * Numrat e Fibonaccit janë të përcaktuar si më poshtë:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, për n > 2.\n     * Është e garantuar që ekziston të paktën një zgjidhje e vlefshme për k e dhënë.\n     *\n     * Shembull 1:\n     * Input: k = 7\n     * Output: 2\n     * Shpjegim: Numrat e Fibonaccit janë: 1, 1, 2, 3, 5, 8, 13, ...\n     * Për k = 7, mund të marrim 2 + 5 = 7.\n     *\n     * Shembull 2:\n     * Input: k = 10\n     * Output: 2\n     * Shpjegim: Për k = 10, mund të marrim 2 + 8 = 10.\n     *\n     * Shembull 3:\n     * Input: k = 19\n     * Output: 3\n     * Shpjegim: Për k = 19, mund të marrim 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Տրված է ամբողջ թիվ k, վերադարձնել Ֆիբոնաչի թվերի նվազագույն քանակը, որոնց գումարը հավասար է k-ին:\n     * Ֆիբոնաչի թվերը սահմանվում են հետևյալ կերպ.\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, n > 2-ի համար:\n     * Երաշխավորված է, որ տրված k-ի համար առնվազն մեկ վավեր լուծում կա:\n     *\n     * Օրինակ 1:\n     * Մուտք: k = 7\n     * Ելք: 2\n     * Բացատրություն: Ֆիբոնաչի թվերն են՝ 1, 1, 2, 3, 5, 8, 13, ...\n     * k = 7-ի համար կարող ենք ստանալ 2 + 5 = 7:\n     *\n     * Օրինակ 2:\n     * Մուտք: k = 10\n     * Ելք: 2\n     * Բացատրություն: k = 10-ի համար կարող ենք ստանալ 2 + 8 = 10:\n     *\n     * Օրինակ 3:\n     * Մուտք: k = 19\n     * Ելք: 3\n     * Բացատրություն: k = 19-ի համար կարող ենք ստանալ 1 + 5 + 13 = 19:\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * একটি পূর্ণসংখ্যা k দেওয়া হলে, সেই k এর সমান যোগফল যেসব ফিবোনাচ্চি সংখ্যার মাধ্যমে পাওয়া যায়, সেগুলোর সর্বনিম্ন সংখ্যা ফেরত দিন।\n     * ফিবোনাচ্চি সংখ্যা নিম্নরূপে সংজ্ঞায়িত:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, n > 2 এর জন্য।\n     * প্রদত্ত k এর জন্য অন্তত একটি বৈধ সমাধান থাকার গ্যারান্টি দেওয়া হয়েছে।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: k = 7\n     * আউটপুট: 2\n     * ব্যাখ্যা: ফিবোনাচ্চি সংখ্যা হলো: 1, 1, 2, 3, 5, 8, 13, ...\n     * k = 7 এর জন্য, আমরা 2 + 5 = 7 পেতে পারি।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: k = 10\n     * আউটপুট: 2\n     * ব্যাখ্যা: k = 10 এর জন্য, আমরা 2 + 8 = 10 পেতে পারি।\n     *\n     * উদাহরণ 3:\n     * ইনপুট: k = 19\n     * আউটপুট: 3\n     * ব্যাখ্যা: k = 19 এর জন্য, আমরা 1 + 5 + 13 = 19 পেতে পারি।\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Дадено е цяло число k, върнете минималния брой числа на Фибоначи, чиято сума е равна на k.\n     * Числата на Фибоначи са дефинирани по следния начин:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, за n > 2.\n     * Гарантирано е, че съществува поне едно валидно решение за даденото k.\n     *\n     * Пример 1:\n     * Вход: k = 7\n     * Изход: 2\n     * Обяснение: Числата на Фибоначи са: 1, 1, 2, 3, 5, 8, 13, ...\n     * За k = 7, можем да получим 2 + 5 = 7.\n     *\n     * Пример 2:\n     * Вход: k = 10\n     * Изход: 2\n     * Обяснение: За k = 10, можем да получим 2 + 8 = 10.\n     *\n     * Пример 3:\n     * Вход: k = 19\n     * Изход: 3\n     * Обяснение: За k = 19, можем да получим 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 给定一个整数 k，返回其和等于 k 的最少斐波那契数字的数量。\n     * 斐波那契数定义如下：\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, 对于 n > 2。\n     * 可以保证对于给定的 k 至少存在一个有效的解决方案。\n     *\n     * 示例 1:\n     * 输入: k = 7\n     * 输出: 2\n     * 解释: 斐波那契数为: 1, 1, 2, 3, 5, 8, 13, ...\n     * 对于 k = 7，我们可以得到 2 + 5 = 7。\n     *\n     * 示例 2:\n     * 输入: k = 10\n     * 输出: 2\n     * 解释: 对于 k = 10，我们可以得到 2 + 8 = 10。\n     *\n     * 示例 3:\n     * 输入: k = 19\n     * 输出: 3\n     * 解释: 对于 k = 19，我们可以得到 1 + 5 + 13 = 19。\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Étant donné un entier k, retourne le nombre minimum de nombres de Fibonacci dont la somme est égale à k.\n     * Les nombres de Fibonacci sont définis comme suit :\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, pour n > 2.\n     * Il est garanti qu'il existe au moins une solution valide pour le k donné.\n     *\n     * Exemple 1 :\n     * Entrée : k = 7\n     * Sortie : 2\n     * Explication : Les nombres de Fibonacci sont : 1, 1, 2, 3, 5, 8, 13, ...\n     * Pour k = 7, nous pouvons obtenir 2 + 5 = 7.\n     *\n     * Exemple 2 :\n     * Entrée : k = 10\n     * Sortie : 2\n     * Explication : Pour k = 10, nous pouvons obtenir 2 + 8 = 10.\n     *\n     * Exemple 3 :\n     * Entrée : k = 19\n     * Sortie : 3\n     * Explication : Pour k = 19, nous pouvons obtenir 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gegeben eine ganze Zahl k, gib die minimale Anzahl von Fibonacci-Zahlen zurück, deren Summe gleich k ist.\n     * Fibonacci-Zahlen sind wie folgt definiert:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, für n > 2.\n     * Es ist garantiert, dass es mindestens eine gültige Lösung für das gegebene k gibt.\n     *\n     * Beispiel 1:\n     * Eingabe: k = 7\n     * Ausgabe: 2\n     * Erklärung: Fibonacci-Zahlen sind: 1, 1, 2, 3, 5, 8, 13, ...\n     * Für k = 7 können wir 2 + 5 = 7 erhalten.\n     *\n     * Beispiel 2:\n     * Eingabe: k = 10\n     * Ausgabe: 2\n     * Erklärung: Für k = 10 können wir 2 + 8 = 10 erhalten.\n     *\n     * Beispiel 3:\n     * Eingabe: k = 19\n     * Ausgabe: 3\n     * Erklärung: Für k = 19 können wir 1 + 5 + 13 = 19 erhalten.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * Idan aka ba da cikakken lamba k, mayar da mafi ƙarancin adadin lambobin Fibonacci waɗanda jimlarsu ta yi daidai da k.\n     * An ayyana lambobin Fibonacci kamar haka:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, don n > 2.\n     * An tabbatar da cewa akwai aƙalla mafita ɗaya mai inganci don k da aka bayar.\n     *\n     * Misali 1:\n     * Shigarwa: k = 7\n     * Fitarwa: 2\n     * Bayani: Lambobin Fibonacci sune: 1, 1, 2, 3, 5, 8, 13, ...\n     * Don k = 7, za mu iya samun 2 + 5 = 7.\n     *\n     * Misali 2:\n     * Shigarwa: k = 10\n     * Fitarwa: 2\n     * Bayani: Don k = 10, za mu iya samun 2 + 8 = 10.\n     *\n     * Misali 3:\n     * Shigarwa: k = 19\n     * Fitarwa: 3\n     * Bayani: Don k = 19, za mu iya samun 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * दिए गए पूर्णांक k के लिए, न्यूनतम संख्या में फिबोनाची संख्याएँ लौटाएँ जिनका योग k के बराबर हो।\n     * फिबोनाची संख्याएँ निम्नलिखित रूप से परिभाषित की जाती हैं:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, जहां n > 2.\n     * यह गारंटी है कि दिए गए k के लिए कम से कम एक वैध समाधान है।\n     *\n     * उदाहरण 1:\n     * इनपुट: k = 7\n     * आउटपुट: 2\n     * व्याख्या: फिबोनाची संख्याएँ हैं: 1, 1, 2, 3, 5, 8, 13, ...\n     * k = 7 के लिए, हम 2 + 5 = 7 प्राप्त कर सकते हैं।\n     *\n     * उदाहरण 2:\n     * इनपुट: k = 10\n     * आउटपुट: 2\n     * व्याख्या: k = 10 के लिए, हम 2 + 8 = 10 प्राप्त कर सकते हैं।\n     *\n     * उदाहरण 3:\n     * इनपुट: k = 19\n     * आउटपुट: 3\n     * व्याख्या: k = 19 के लिए, हम 1 + 5 + 13 = 19 प्राप्त कर सकते हैं।\n     */\n  public int findMinFibonacciNumbers(int k) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adott egy egész szám k, adja vissza a minimális számú Fibonacci számot, amelyek összege egyenlő k-val.\n     * A Fibonacci számok a következőképpen vannak definiálva:\n     * F1 = 1\n     * F2 = 1\n     * Fn = Fn-1 + Fn-2, ha n > 2.\n     * Garantált, hogy legalább egy érvényes megoldás létezik a megadott k-ra.\n     *\n     * 1. példa:\n     * Bemenet: k = 7\n     * Kimenet: 2\n     * Magyarázat: A Fibonacci számok: 1, 1, 2, 3, 5, 8, 13, ...\n     * K esetén 7, kaphatjuk 2 + 5 = 7.\n     *\n     * 2. példa:\n     * Bemenet: k = 10\n     * Kimenet: 2\n     * Magyarázat: K esetén 10, kaphatjuk 2 + 8 = 10.\n     *\n     * 3. példa:\n     * Bemenet: k = 19\n     * Kimenet: 3\n     * Magyarázat: K esetén 19, kaphatjuk 1 + 5 + 13 = 19.\n     */\n  public int findMinFibonacciNumbers(int k) "
    },
    "prompt_bertscore": {
      "sq": "0.9917510789060021",
      "hy": "0.989757425771555",
      "bn": "0.9971009895887958",
      "bg": "0.9886731025214855",
      "zh": "0.996276673507501",
      "fr": "0.9896525489303686",
      "de": "0.9976180244706296",
      "ha": "0.9905598925109359",
      "hi": "0.9859300169593936",
      "hu": "0.9907871256668398"
    },
    "canonical_solution": "  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }",
    "instruction": {
      "en": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nՏվեք Java կոդի կարճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\n提供一段不超过500个字符的中文自然语言描述（文档字符串），用于说明这段Java代码的功能。",
      "fr": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Java cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public int findMinFibonacciNumbers(int k)\n  {\n\n    List<Integer> fibs = new ArrayList<>();\n    fibs.add(1);\n    fibs.add(1);\n    while (fibs.get(fibs.size() - 1) < k) {\n      int nextFib = fibs.get(fibs.size() - 1) + fibs.get(fibs.size() - 2);\n      fibs.add(nextFib);\n    }\n    int count = 0;\n    for (int i = fibs.size() - 1; i >= 0; i--) {\n      if (fibs.get(i) <= k) {\n        k -= fibs.get(i);\n        count++;\n      }\n    }\n    return count;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9070264816578568",
      "bn": "0.9096337040393208",
      "bg": "0.8376140553201085",
      "zh": "0.8494856438366221",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9168968225522425",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.findMinFibonacciNumbers(7) == 2;\n    assert solution.findMinFibonacciNumbers(10) == 2;\n    assert solution.findMinFibonacciNumbers(13) == 1;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "findMinFibonacciNumbers",
    "signature": "public int findMinFibonacciNumbers(int k)",
    "docstring": {
      "en": "Given an integer k, return the minimum number of Fibonacci numbers whose sum is equal to k.\nFibonacci numbers are defined as follows:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, for n > 2.\nIt is guaranteed that there is at least one valid solution for the given k.\n\nExample 1:\nInput: k = 7\nOutput: 2\nExplanation: Fibonacci numbers are: 1, 1, 2, 3, 5, 8, 13, ...\nFor k = 7, we can get 2 + 5 = 7.\n\nExample 2:\nInput: k = 10\nOutput: 2\nExplanation: For k = 10, we can get 2 + 8 = 10.\n\nExample 3:\nInput: k = 19\nOutput: 3\nExplanation: For k = 19, we can get 1 + 5 + 13 = 19.",
      "sq": "Duke pasur një numër të plotë k, kthe numrin minimal të numrave të Fibonaccit, shuma e të cilëve është e barabartë me k. Numrat e Fibonaccit përcaktohen si më poshtë: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, për n > 2. Garantohet që ekziston të paktën një zgjidhje e vlefshme për k e dhënë.\n\nShembull 1: Input: k = 7 Output: 2 Shpjegim: Numrat e Fibonaccit janë: 1, 1, 2, 3, 5, 8, 13, ... Për k = 7, mund të marrim 2 + 5 = 7.\n\nShembull 2: Input: k = 10 Output: 2 Shpjegim: Për k = 10, mund të marrim 2 + 8 = 10.\n\nShembull 3: Input: k = 19 Output: 3 Shpjegim: Për k = 19, mund të marrim 1 + 5 + 13 = 19.",
      "hy": "Տրված է ամբողջ թիվ k, վերադարձնել Ֆիբոնաչիի թվերի նվազագույն քանակը, որոնց գումարը հավասար է k-ին։ Ֆիբոնաչիի թվերը սահմանվում են հետևյալ կերպ՝\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, n > 2-ի համար։\nԵրաշխավորված է, որ տրված k-ի համար առնվազն մեկ վավեր լուծում կա։\n\nՕրինակ 1:\nՄուտք: k = 7\nԵլք: 2\nԲացատրություն: Ֆիբոնաչիի թվերն են՝ 1, 1, 2, 3, 5, 8, 13, ...\nk = 7-ի համար, մենք կարող ենք ստանալ 2 + 5 = 7։\n\nՕրինակ 2:\nՄուտք: k = 10\nԵլք: 2\nԲացատրություն: k = 10-ի համար, մենք կարող ենք ստանալ 2 + 8 = 10։\n\nՕրինակ 3:\nՄուտք: k = 19\nԵլք: 3\nԲացատրություն: k = 19-ի համար, մենք կարող ենք ստանալ 1 + 5 + 13 = 19։",
      "bn": "একটি পূর্ণসংখ্যা k দেওয়া হলে, সেই k এর সমান যোগফল যেসব ফিবোনাচ্চি সংখ্যার মাধ্যমে পাওয়া যায়, সেগুলোর মধ্যে সর্বনিম্ন সংখ্যক ফিবোনাচ্চি সংখ্যা ফেরত দিন। ফিবোনাচ্চি সংখ্যা নিম্নরূপে সংজ্ঞায়িত করা হয়:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, যেখানে n > 2।\nপ্রদত্ত k এর জন্য অন্তত একটি বৈধ সমাধান থাকা নিশ্চিত।\n\nউদাহরণ 1:\nইনপুট: k = 7\nআউটপুট: 2\nব্যাখ্যা: ফিবোনাচ্চি সংখ্যা হল: 1, 1, 2, 3, 5, 8, 13, ...\nk = 7 এর জন্য, আমরা 2 + 5 = 7 পেতে পারি।\n\nউদাহরণ 2:\nইনপুট: k = 10\nআউটপুট: 2\nব্যাখ্যা: k = 10 এর জন্য, আমরা 2 + 8 = 10 পেতে পারি।\n\nউদাহরণ 3:\nইনপুট: k = 19\nআউটপুট: 3\nব্যাখ্যা: k = 19 এর জন্য, আমরা 1 + 5 + 13 = 19 পেতে পারি।",
      "bg": "Дадено е цяло число k, върнете минималния брой числа на Фибоначи, чиято сума е равна на k. Числата на Фибоначи са дефинирани както следва: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, за n > 2. Гарантирано е, че има поне едно валидно решение за даденото k.\n\nПример 1: Вход: k = 7 Изход: 2 Обяснение: Числата на Фибоначи са: 1, 1, 2, 3, 5, 8, 13, ... За k = 7, можем да получим 2 + 5 = 7.\n\nПример 2: Вход: k = 10 Изход: 2 Обяснение: За k = 10, можем да получим 2 + 8 = 10.\n\nПример 3: Вход: k = 19 Изход: 3 Обяснение: За k = 19, можем да получим 1 + 5 + 13 = 19.",
      "zh": "给定一个整数 k，返回其和等于 k 的最少斐波那契数字的数量。  \n斐波那契数定义如下：  \nF1 = 1  \nF2 = 1  \nFn = Fn-1 + Fn-2，对于 n > 2。  \n保证对于给定的 k 至少存在一个有效解。\n\n示例 1:  \n输入: k = 7  \n输出: 2  \n解释: 斐波那契数为: 1, 1, 2, 3, 5, 8, 13, ...  \n对于 k = 7，我们可以得到 2 + 5 = 7。\n\n示例 2:  \n输入: k = 10  \n输出: 2  \n解释: 对于 k = 10，我们可以得到 2 + 8 = 10。\n\n示例 3:  \n输入: k = 19  \n输出: 3  \n解释: 对于 k = 19，我们可以得到 1 + 5 + 13 = 19。",
      "fr": "Étant donné un entier k, renvoyer le nombre minimum de nombres de Fibonacci dont la somme est égale à k.\nLes nombres de Fibonacci sont définis comme suit :\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, pour n > 2.\nIl est garanti qu'il existe au moins une solution valide pour le k donné.\n\nExemple 1 :\nEntrée : k = 7\nSortie : 2\nExplication : Les nombres de Fibonacci sont : 1, 1, 2, 3, 5, 8, 13, ...\nPour k = 7, nous pouvons obtenir 2 + 5 = 7.\n\nExemple 2 :\nEntrée : k = 10\nSortie : 2\nExplication : Pour k = 10, nous pouvons obtenir 2 + 8 = 10.\n\nExemple 3 :\nEntrée : k = 19\nSortie : 3\nExplication : Pour k = 19, nous pouvons obtenir 1 + 5 + 13 = 19.",
      "de": "Gegeben eine ganze Zahl k, geben Sie die minimale Anzahl von Fibonacci-Zahlen zurück, deren Summe gleich k ist. Fibonacci-Zahlen sind wie folgt definiert: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, für n > 2. Es ist garantiert, dass es mindestens eine gültige Lösung für das gegebene k gibt.\n\nBeispiel 1: Eingabe: k = 7 Ausgabe: 2 Erklärung: Fibonacci-Zahlen sind: 1, 1, 2, 3, 5, 8, 13, ... Für k = 7 können wir 2 + 5 = 7 erhalten.\n\nBeispiel 2: Eingabe: k = 10 Ausgabe: 2 Erklärung: Für k = 10 können wir 2 + 8 = 10 erhalten.\n\nBeispiel 3: Eingabe: k = 19 Ausgabe: 3 Erklärung: Für k = 19 können wir 1 + 5 + 13 = 19 erhalten.",
      "ha": "An ba da wani cikakken lamba k, dawo da mafi ƙarancin adadin lambobin Fibonacci waɗanda jimlarsu ta yi daidai da k. Ana ayyana lambobin Fibonacci kamar haka:  \nF1 = 1  \nF2 = 1  \nFn = Fn-1 + Fn-2, don n > 2.  \nAna tabbatar da cewa akwai aƙalla mafita guda ɗaya mai inganci don k da aka bayar.  \n\nMisali na 1:  \nShigarwa: k = 7  \nFitarwa: 2  \nBayani: Lambobin Fibonacci sune: 1, 1, 2, 3, 5, 8, 13, ...  \nDon k = 7, zamu iya samun 2 + 5 = 7.  \n\nMisali na 2:  \nShigarwa: k = 10  \nFitarwa: 2  \nBayani: Don k = 10, zamu iya samun 2 + 8 = 10.  \n\nMisali na 3:  \nShigarwa: k = 19  \nFitarwa: 3  \nBayani: Don k = 19, zamu iya samun 1 + 5 + 13 = 19.",
      "hi": "दी गई संख्या k के लिए, उन न्यूनतम फिबोनाची संख्याओं की संख्या लौटाएं जिनका योग k के बराबर है। फिबोनाची संख्याएं निम्नलिखित रूप में परिभाषित की जाती हैं:\nF1 = 1\nF2 = 1\nFn = Fn-1 + Fn-2, जहाँ n > 2.\nयह सुनिश्चित है कि दिए गए k के लिए कम से कम एक वैध समाधान है।\n\nउदाहरण 1:\nइनपुट: k = 7\nआउटपुट: 2\nव्याख्या: फिबोनाची संख्याएं हैं: 1, 1, 2, 3, 5, 8, 13, ...\nk = 7 के लिए, हम 2 + 5 = 7 प्राप्त कर सकते हैं।\n\nउदाहरण 2:\nइनपुट: k = 10\nआउटपुट: 2\nव्याख्या: k = 10 के लिए, हम 2 + 8 = 10 प्राप्त कर सकते हैं।\n\nउदाहरण 3:\nइनपुट: k = 19\nआउटपुट: 3\nव्याख्या: k = 19 के लिए, हम 1 + 5 + 13 = 19 प्राप्त कर सकते हैं।",
      "hu": "Adott egy egész szám k, térj vissza a legkisebb számú Fibonacci-számmal, amelyek összege egyenlő k-val. A Fibonacci-számok a következőképpen vannak definiálva: F1 = 1 F2 = 1 Fn = Fn-1 + Fn-2, ahol n > 2. Garantált, hogy legalább egy érvényes megoldás létezik a megadott k-ra.\n\nPélda 1: Bemenet: k = 7 Kimenet: 2 Magyarázat: A Fibonacci-számok: 1, 1, 2, 3, 5, 8, 13, ... K esetén k = 7, kaphatjuk a 2 + 5 = 7 összeget.\n\nPélda 2: Bemenet: k = 10 Kimenet: 2 Magyarázat: K esetén k = 10, kaphatjuk a 2 + 8 = 10 összeget.\n\nPélda 3: Bemenet: k = 19 Kimenet: 3 Magyarázat: K esetén k = 19, kaphatjuk az 1 + 5 + 13 = 19 összeget."
    },
    "docstring_bertscore": {
      "sq": "0.9821224711853359",
      "hy": "0.9970312703250526",
      "bn": "0.9962293994768148",
      "bg": "0.9875665326687402",
      "zh": "0.9872892446568154",
      "fr": "0.9875665326687402",
      "de": "0.9972132157540805",
      "ha": "0.9870437375058563",
      "hi": "0.9924057646418931",
      "hu": "0.9749145719183419"
    }
  },
  {
    "task_id": "Java/29",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given two positive integers n and k, find the kth factor of n.\n     * A factor of n is a positive integer that divides n evenly.\n     * Return the kth factor in ascending order. If n has less than k factors, return -1.\n     *\n     * Example 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Explanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n     *\n     * Example 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Explanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n     *\n     * Example 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Explanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.\n     */\n    public int kthFactor(int n, int k) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur parasysh dy numra të plotë pozitivë n dhe k, gjeni faktorin e k-të të n.\n     * Një faktor i n është një numër i plotë pozitiv që e ndan n në mënyrë të barabartë.\n     * Ktheni faktorin e k-të në rend rritës. Nëse n ka më pak se k faktorë, ktheni -1.\n     *\n     * Shembull 1:\n     * Input: n = 12, k = 3\n     * Output: 3\n     * Shpjegim: Faktorët e 12 janë [1, 2, 3, 4, 6, 12]. Faktori i 3-të është 3.\n     *\n     * Shembull 2:\n     * Input: n = 7, k = 2\n     * Output: 7\n     * Shpjegim: Faktorët e 7 janë [1, 7]. Faktori i 2-të është 7.\n     *\n     * Shembull 3:\n     * Input: n = 4, k = 4\n     * Output: -1\n     * Shpjegim: Faktorët e 4 janë [1, 2, 4]. Nuk ka faktor të 4-të, prandaj kthejmë -1.\n     */\n    public int kthFactor(int n, int k) ",
      "hy": "class Solution {\n    /**\n     * Տրված են n և k դրական ամբողջ թվերը, գտնել n-ի k-րդ գործոնը։\n     * n-ի գործոնը դրական ամբողջ թիվ է, որը n-ին բաժանում է առանց մնացորդի։\n     * Վերադարձնել k-րդ գործոնը աճման կարգով։ Եթե n-ն ունի k-ից պակաս գործոններ, վերադարձնել -1։\n     *\n     * Օրինակ 1:\n     * Մուտք: n = 12, k = 3\n     * Ելք: 3\n     * Բացատրություն: 12-ի գործոններն են [1, 2, 3, 4, 6, 12]։ 3-րդ գործոնը 3 է։\n     *\n     * Օրինակ 2:\n     * Մուտք: n = 7, k = 2\n     * Ելք: 7\n     * Բացատրություն: 7-ի գործոններն են [1, 7]։ 2-րդ գործոնը 7 է։\n     *\n     * Օրինակ 3:\n     * Մուտք: n = 4, k = 4\n     * Ելք: -1\n     * Բացատրություն: 4-ի գործոններն են [1, 2, 4]։ Չկա 4-րդ գործոն, ուստի վերադարձնում ենք -1։\n     */\n    public int kthFactor(int n, int k) ",
      "bn": "class Solution {\n    /**\n     * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া হলে, n এর k তম গুণনীয়ক খুঁজে বের করুন।\n     * n এর একটি গুণনীয়ক হল একটি ধনাত্মক পূর্ণসংখ্যা যা n কে সমানভাবে ভাগ করে।\n     * ঊর্ধ্বক্রমে k তম গুণনীয়কটি ফেরত দিন। যদি n এর k টির কম গুণনীয়ক থাকে, তবে -1 ফেরত দিন।\n     *\n     * উদাহরণ 1:\n     * ইনপুট: n = 12, k = 3\n     * আউটপুট: 3\n     * ব্যাখ্যা: 12 এর গুণনীয়কগুলি হল [1, 2, 3, 4, 6, 12]। 3য় গুণনীয়কটি হল 3।\n     *\n     * উদাহরণ 2:\n     * ইনপুট: n = 7, k = 2\n     * আউটপুট: 7\n     * ব্যাখ্যা: 7 এর গুণনীয়কগুলি হল [1, 7]। 2য় গুণনীয়কটি হল 7।\n     *\n     * উদাহরণ 3:\n     * ইনপুট: n = 4, k = 4\n     * আউটপুট: -1\n     * ব্যাখ্যা: 4 এর গুণনীয়কগুলি হল [1, 2, 4]। এখানে 4র্থ গুণনীয়ক নেই, তাই আমরা -1 ফেরত দিই।\n     */\n    public int kthFactor(int n, int k) ",
      "bg": "class Solution {\n    /**\n     * Дадени са две положителни цели числа n и k, намерете k-тия делител на n.\n     * Делител на n е положително цяло число, което дели n без остатък.\n     * Върнете k-тия делител в нарастващ ред. Ако n има по-малко от k делители, върнете -1.\n     *\n     * Пример 1:\n     * Вход: n = 12, k = 3\n     * Изход: 3\n     * Обяснение: Делителите на 12 са [1, 2, 3, 4, 6, 12]. Третият делител е 3.\n     *\n     * Пример 2:\n     * Вход: n = 7, k = 2\n     * Изход: 7\n     * Обяснение: Делителите на 7 са [1, 7]. Вторият делител е 7.\n     *\n     * Пример 3:\n     * Вход: n = 4, k = 4\n     * Изход: -1\n     * Обяснение: Делителите на 4 са [1, 2, 4]. Няма четвърти делител, затова връщаме -1.\n     */\n    public int kthFactor(int n, int k) ",
      "zh": "class Solution {\n    /**\n     * 给定两个正整数 n 和 k，找到 n 的第 k 个因子。\n     * n 的因子是能够整除 n 的正整数。\n     * 返回按升序排列的第 k 个因子。如果 n 的因子少于 k 个，则返回 -1。\n     *\n     * 示例 1:\n     * 输入: n = 12, k = 3\n     * 输出: 3\n     * 解释: 12 的因子是 [1, 2, 3, 4, 6, 12]。第 3 个因子是 3。\n     *\n     * 示例 2:\n     * 输入: n = 7, k = 2\n     * 输出: 7\n     * 解释: 7 的因子是 [1, 7]。第 2 个因子是 7。\n     *\n     * 示例 3:\n     * 输入: n = 4, k = 4\n     * 输出: -1\n     * 解释: 4 的因子是 [1, 2, 4]。没有第 4 个因子，所以返回 -1。\n     */\n    public int kthFactor(int n, int k) ",
      "fr": "class Solution {\n    /**\n     * Étant donné deux entiers positifs n et k, trouvez le k-ième facteur de n.\n     * Un facteur de n est un entier positif qui divise n sans reste.\n     * Retournez le k-ième facteur dans l'ordre croissant. Si n a moins de k facteurs, retournez -1.\n     *\n     * Exemple 1 :\n     * Entrée : n = 12, k = 3\n     * Sortie : 3\n     * Explication : Les facteurs de 12 sont [1, 2, 3, 4, 6, 12]. Le 3ème facteur est 3.\n     *\n     * Exemple 2 :\n     * Entrée : n = 7, k = 2\n     * Sortie : 7\n     * Explication : Les facteurs de 7 sont [1, 7]. Le 2ème facteur est 7.\n     *\n     * Exemple 3 :\n     * Entrée : n = 4, k = 4\n     * Sortie : -1\n     * Explication : Les facteurs de 4 sont [1, 2, 4]. Il n'y a pas de 4ème facteur, donc nous retournons -1.\n     */\n    public int kthFactor(int n, int k) ",
      "de": "class Solution {\n    /**\n     * Gegeben zwei positive ganze Zahlen n und k, finde den k-ten Faktor von n.\n     * Ein Faktor von n ist eine positive ganze Zahl, die n ohne Rest teilt.\n     * Gib den k-ten Faktor in aufsteigender Reihenfolge zurück. Wenn n weniger als k Faktoren hat, gib -1 zurück.\n     *\n     * Beispiel 1:\n     * Eingabe: n = 12, k = 3\n     * Ausgabe: 3\n     * Erklärung: Die Faktoren von 12 sind [1, 2, 3, 4, 6, 12]. Der 3. Faktor ist 3.\n     *\n     * Beispiel 2:\n     * Eingabe: n = 7, k = 2\n     * Ausgabe: 7\n     * Erklärung: Die Faktoren von 7 sind [1, 7]. Der 2. Faktor ist 7.\n     *\n     * Beispiel 3:\n     * Eingabe: n = 4, k = 4\n     * Ausgabe: -1\n     * Erklärung: Die Faktoren von 4 sind [1, 2, 4]. Es gibt keinen 4. Faktor, daher geben wir -1 zurück.\n     */\n    public int kthFactor(int n, int k) ",
      "ha": "class Solution {\n    /**\n     * An ba da lambobi guda biyu masu kyau n da k, nemo k na dalilin n.\n     * Dalilin n shine lamba mai kyau wanda ke raba n ba tare da saura ba.\n     * Mayar da k na dalilin a tsari mai hawa. Idan n yana da ƙasa da k dalilai, mayar da -1.\n     *\n     * Misali 1:\n     * Shigarwa: n = 12, k = 3\n     * Fitarwa: 3\n     * Bayani: Dalilan 12 sune [1, 2, 3, 4, 6, 12]. Dalili na 3 shine 3.\n     *\n     * Misali 2:\n     * Shigarwa: n = 7, k = 2\n     * Fitarwa: 7\n     * Bayani: Dalilan 7 sune [1, 7]. Dalili na 2 shine 7.\n     *\n     * Misali 3:\n     * Shigarwa: n = 4, k = 4\n     * Fitarwa: -1\n     * Bayani: Dalilan 4 sune [1, 2, 4]. Babu dalili na 4, don haka muna mayar da -1.\n     */\n    public int kthFactor(int n, int k) ",
      "hi": "class Solution {\n    /**\n     * दिए गए दो धनात्मक पूर्णांक n और k, n का kth गुणक खोजें।\n     * n का एक गुणक वह धनात्मक पूर्णांक होता है जो n को पूर्ण रूप से विभाजित करता है।\n     * आरोही क्रम में kth गुणक लौटाएं। यदि n के k से कम गुणक हैं, तो -1 लौटाएं।\n     *\n     * उदाहरण 1:\n     * इनपुट: n = 12, k = 3\n     * आउटपुट: 3\n     * व्याख्या: 12 के गुणक [1, 2, 3, 4, 6, 12] हैं। तीसरा गुणक 3 है।\n     *\n     * उदाहरण 2:\n     * इनपुट: n = 7, k = 2\n     * आउटपुट: 7\n     * व्याख्या: 7 के गुणक [1, 7] हैं। दूसरा गुणक 7 है।\n     *\n     * उदाहरण 3:\n     * इनपुट: n = 4, k = 4\n     * आउटपुट: -1\n     * व्याख्या: 4 के गुणक [1, 2, 4] हैं। कोई चौथा गुणक नहीं है, इसलिए हम -1 लौटाते हैं।\n     */\n    public int kthFactor(int n, int k) ",
      "hu": "class Solution {\n    /**\n     * Két pozitív egész szám, n és k adott, keresse meg n k-adik osztóját.\n     * Az n egy osztója egy olyan pozitív egész szám, amely n-t maradék nélkül osztja.\n     * Adja vissza az n k-adik osztóját növekvő sorrendben. Ha n-nek kevesebb mint k osztója van, adja vissza a -1-et.\n     *\n     * 1. példa:\n     * Bemenet: n = 12, k = 3\n     * Kimenet: 3\n     * Magyarázat: A 12 osztói [1, 2, 3, 4, 6, 12]. A 3. osztó 3.\n     *\n     * 2. példa:\n     * Bemenet: n = 7, k = 2\n     * Kimenet: 7\n     * Magyarázat: A 7 osztói [1, 7]. A 2. osztó 7.\n     *\n     * 3. példa:\n     * Bemenet: n = 4, k = 4\n     * Kimenet: -1\n     * Magyarázat: A 4 osztói [1, 2, 4]. Nincs 4. osztó, ezért -1-et adunk vissza.\n     */\n    public int kthFactor(int n, int k) "
    },
    "prompt_bertscore": {
      "sq": "0.9826959170953836",
      "hy": "0.9706539502451436",
      "bn": "0.9884778488569282",
      "bg": "0.9083765723577509",
      "zh": "0.9825054305599712",
      "fr": "0.9753181888526048",
      "de": "0.9753181888526048",
      "ha": "0.9674353435508543",
      "hi": "0.9895244323346011",
      "hu": "0.9020660851522725"
    },
    "canonical_solution": "    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }",
    "instruction": {
      "en": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nBada takaitaccen bayanin yanayi (docstring) na lambar Java cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int kthFactor(int n, int k)\n    {\n\n        int count = 0;\n        for (int i = 1; i <= n; i++) {\n            if (n % i == 0) {\n                count++;\n                if (count == k) {\n                    return i;\n                }\n            }\n        }\n        return -1;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9310446687022145",
      "bn": "0.8954556660714315",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8888063154359075",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.kthFactor(100, 3) == 4;\n        assert solution.kthFactor(15, 4) == 15;\n        assert solution.kthFactor(30, 18) == -1;\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "kthFactor",
    "signature": "public int kthFactor(int n, int k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the kth factor of n.\nA factor of n is a positive integer that divides n evenly.\nReturn the kth factor in ascending order. If n has less than k factors, return -1.\n\nExample 1:\nInput: n = 12, k = 3\nOutput: 3\nExplanation: The factors of 12 are [1, 2, 3, 4, 6, 12]. The 3rd factor is 3.\n\nExample 2:\nInput: n = 7, k = 2\nOutput: 7\nExplanation: The factors of 7 are [1, 7]. The 2nd factor is 7.\n\nExample 3:\nInput: n = 4, k = 4\nOutput: -1\nExplanation: The factors of 4 are [1, 2, 4]. There is no 4th factor, so we return -1.",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni faktorin e k-të të n.\nNjë faktor i n është një numër i plotë pozitiv që e ndan n në mënyrë të barabartë.\nKtheni faktorin e k-të në rend rritës. Nëse n ka më pak se k faktorë, ktheni -1.\n\nShembull 1:\nInput: n = 12, k = 3\nOutput: 3\nShpjegim: Faktorët e 12 janë [1, 2, 3, 4, 6, 12]. Faktori i 3-të është 3.\n\nShembull 2:\nInput: n = 7, k = 2\nOutput: 7\nShpjegim: Faktorët e 7 janë [1, 7]. Faktori i 2-të është 7.\n\nShembull 3:\nInput: n = 4, k = 4\nOutput: -1\nShpjegim: Faktorët e 4 janë [1, 2, 4]. Nuk ka faktor të 4-të, kështu që ne kthejmë -1.",
      "hy": "Տրված են երկու դրական ամբողջ թվեր՝ n և k, գտնել n-ի k-րդ գործակիցը։ \nn-ի գործակիցը դրական ամբողջ թիվ է, որը n-ը հավասարապես բաժանում է։ \nՎերադարձնել k-րդ գործակիցը աճման կարգով։ Եթե n-ն ունի k-ից պակաս գործակիցներ, վերադարձնել -1։\n\nՕրինակ 1:\nՄուտքագրում: n = 12, k = 3\nԵլք: 3\nԲացատրություն: 12-ի գործակիցներն են [1, 2, 3, 4, 6, 12]։ 3-րդ գործակիցը 3 է։\n\nՕրինակ 2:\nՄուտքագրում: n = 7, k = 2\nԵլք: 7\nԲացատրություն: 7-ի գործակիցներն են [1, 7]։ 2-րդ գործակիցը 7 է։\n\nՕրինակ 3:\nՄուտքագրում: n = 4, k = 4\nԵլք: -1\nԲացատրություն: 4-ի գործակիցներն են [1, 2, 4]։ Չկա 4-րդ գործակից, ուստի վերադարձնում ենք -1։",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, n-এর kth গুণনীয়ক খুঁজে বের করুন। n-এর একটি গুণনীয়ক হল একটি ধনাত্মক পূর্ণসংখ্যা যা n কে সমানভাবে ভাগ করে। ক্রমবর্ধমান ক্রমে kth গুণনীয়কটি ফেরত দিন। যদি n-এর k-এর চেয়ে কম গুণনীয়ক থাকে, তাহলে -1 ফেরত দিন।\n\nউদাহরণ 1:\nইনপুট: n = 12, k = 3\nআউটপুট: 3\nব্যাখ্যা: 12-এর গুণনীয়কগুলি হল [1, 2, 3, 4, 6, 12]। তৃতীয় গুণনীয়ক হল 3।\n\nউদাহরণ 2:\nইনপুট: n = 7, k = 2\nআউটপুট: 7\nব্যাখ্যা: 7-এর গুণনীয়কগুলি হল [1, 7]। দ্বিতীয় গুণনীয়ক হল 7।\n\nউদাহরণ 3:\nইনপুট: n = 4, k = 4\nআউটপুট: -1\nব্যাখ্যা: 4-এর গুণনীয়কগুলি হল [1, 2, 4]। চতুর্থ গুণনীয়ক নেই, তাই আমরা -1 ফেরত দিই।",
      "bg": "Дадени са две положителни цели числа n и k, намерете k-тия делител на n. Делител на n е положително цяло число, което дели n без остатък. Върнете k-тия делител във възходящ ред. Ако n има по-малко от k делители, върнете -1.\n\nПример 1:\nВход: n = 12, k = 3\nИзход: 3\nОбяснение: Делителите на 12 са [1, 2, 3, 4, 6, 12]. Третият делител е 3.\n\nПример 2:\nВход: n = 7, k = 2\nИзход: 7\nОбяснение: Делителите на 7 са [1, 7]. Вторият делител е 7.\n\nПример 3:\nВход: n = 4, k = 4\nИзход: -1\nОбяснение: Делителите на 4 са [1, 2, 4]. Няма четвърти делител, затова връщаме -1.",
      "zh": "给定两个正整数 n 和 k，找出 n 的第 k 个因子。\nn 的因子是能整除 n 的正整数。\n按升序返回第 k 个因子。如果 n 的因子少于 k 个，则返回 -1。\n\n示例 1:\n输入: n = 12, k = 3\n输出: 3\n解释: 12 的因子是 [1, 2, 3, 4, 6, 12]。第 3 个因子是 3。\n\n示例 2:\n输入: n = 7, k = 2\n输出: 7\n解释: 7 的因子是 [1, 7]。第 2 个因子是 7。\n\n示例 3:\n输入: n = 4, k = 4\n输出: -1\n解释: 4 的因子是 [1, 2, 4]。没有第 4 个因子，因此返回 -1。",
      "fr": "Étant donné deux entiers positifs n et k, trouvez le k-ième facteur de n.  \nUn facteur de n est un entier positif qui divise n sans reste.  \nRetournez le k-ième facteur dans l'ordre croissant. Si n a moins de k facteurs, retournez -1.\n\nExemple 1:  \nEntrée: n = 12, k = 3  \nSortie: 3  \nExplication: Les facteurs de 12 sont [1, 2, 3, 4, 6, 12]. Le 3ème facteur est 3.\n\nExemple 2:  \nEntrée: n = 7, k = 2  \nSortie: 7  \nExplication: Les facteurs de 7 sont [1, 7]. Le 2ème facteur est 7.\n\nExemple 3:  \nEntrée: n = 4, k = 4  \nSortie: -1  \nExplication: Les facteurs de 4 sont [1, 2, 4]. Il n'y a pas de 4ème facteur, donc nous retournons -1.",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde den k-ten Faktor von n.\nEin Faktor von n ist eine positive ganze Zahl, die n ohne Rest teilt.\nGib den k-ten Faktor in aufsteigender Reihenfolge zurück. Wenn n weniger als k Faktoren hat, gib -1 zurück.\n\nBeispiel 1:\nEingabe: n = 12, k = 3\nAusgabe: 3\nErläuterung: Die Faktoren von 12 sind [1, 2, 3, 4, 6, 12]. Der 3. Faktor ist 3.\n\nBeispiel 2:\nEingabe: n = 7, k = 2\nAusgabe: 7\nErläuterung: Die Faktoren von 7 sind [1, 7]. Der 2. Faktor ist 7.\n\nBeispiel 3:\nEingabe: n = 4, k = 4\nAusgabe: -1\nErläuterung: Die Faktoren von 4 sind [1, 2, 4]. Es gibt keinen 4. Faktor, daher geben wir -1 zurück.",
      "ha": "An ba da lambobi guda biyu masu kyau n da k, nemo k na dalilin n.\nWani abin nadi na n shine lamba mai kyau wadda take raba n ba tare da saura ba.  \nReturn the kth factor in ascending order. Idan n yana da ƙasa da k abubuwan nadi, dawo da -1.\n\nMisali 1:  \nInput: n = 12, k = 3  \nOutput: 3  \nBayani: Abubuwan nadi na 12 sune [1, 2, 3, 4, 6, 12]. Abin nadi na 3 shine 3.\n\nMisali 2:  \nInput: n = 7, k = 2  \nOutput: 7  \nBayani: Abubuwan nadi na 7 sune [1, 7]. Abin nadi na 2 shine 7.\n\nMisali 3:  \nInput: n = 4, k = 4  \nOutput: -1  \nBayani: Abubuwan nadi na 4 sune [1, 2, 4]. Babu abin nadi na 4, don haka muna dawowa da -1.",
      "hi": "दिए गए दो धनात्मक पूर्णांक n और k के लिए, n का kth गुणक खोजें।\nn का एक गुणक एक धनात्मक पूर्णांक है जो n को समान रूप से विभाजित करता है।  \nAscending क्रम में kth गुणक लौटाएं। यदि n के पास k से कम गुणक हैं, तो -1 लौटाएं।\n\nउदाहरण 1:  \nइनपुट: n = 12, k = 3  \nआउटपुट: 3  \nव्याख्या: 12 के गुणक [1, 2, 3, 4, 6, 12] हैं। तीसरा गुणक 3 है।\n\nउदाहरण 2:  \nइनपुट: n = 7, k = 2  \nआउटपुट: 7  \nव्याख्या: 7 के गुणक [1, 7] हैं। दूसरा गुणक 7 है।\n\nउदाहरण 3:  \nइनपुट: n = 4, k = 4  \nआउटपुट: -1  \nव्याख्या: 4 के गुणक [1, 2, 4] हैं। कोई चौथा गुणक नहीं है, इसलिए हम -1 लौटाते हैं।",
      "hu": "Adott két pozitív egész szám, n és k, keressük meg n k-adik osztóját. Egy n osztója olyan pozitív egész szám, amely n-t maradék nélkül osztja. Adjuk vissza az osztókat növekvő sorrendben. Ha n-nek kevesebb mint k osztója van, térjünk vissza -1-gyel.\n\nPélda 1:\nBemenet: n = 12, k = 3\nKimenet: 3\nMagyarázat: A 12 osztói [1, 2, 3, 4, 6, 12]. A 3. osztó 3.\n\nPélda 2:\nBemenet: n = 7, k = 2\nKimenet: 7\nMagyarázat: A 7 osztói [1, 7]. A 2. osztó 7.\n\nPélda 3:\nBemenet: n = 4, k = 4\nKimenet: -1\nMagyarázat: A 4 osztói [1, 2, 4]. Nincs 4. osztó, így visszatérünk -1-gyel."
    },
    "docstring_bertscore": {
      "sq": "0.9856791467881466",
      "hy": "0.979208166234792",
      "bn": "0.9025135994007442",
      "bg": "0.8996445821770762",
      "zh": "0.9677891042594774",
      "fr": "0.9743252355778114",
      "de": "0.9743252355778114",
      "ha": "0.9841282407730262",
      "hi": "0.9885682256802991",
      "hu": "0.8873549232416856"
    }
  },
  {
    "task_id": "Java/30",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a string s consisting of lowercase and uppercase English letters,\n     * you need to make the string \"good\".\n     * A string is considered \"good\" if there are no adjacent characters such that\n     * one is a lowercase letter and the other is the corresponding uppercase letter.\n     * You can choose any adjacent characters in the string and remove them until the string is \"good\".\n     * Return the final \"good\" string.\n     *\n     * Example 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Explanation: You can remove \"Ee\" to make \"leetcode\".\n     *\n     * Example 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Explanation: There are multiple possible solutions, such as:\n     * - Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n     * - Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\n     *   then remove \"aA\" to make \"\".\n     * No matter the choices, the result is an empty string.\n     *\n     * Example 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Explanation: The string is already \"good\".\n     */\n  public String makeGood(String s) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një varg s që përbëhet nga shkronja angleze të vogla dhe të mëdha,\n     * ju duhet ta bëni vargun \"të mirë\".\n     * Një varg konsiderohet \"i mirë\" nëse nuk ka karaktere ngjitur të tilla që\n     * njëra është një shkronjë e vogël dhe tjetra është shkronja përkatëse e madhe.\n     * Ju mund të zgjidhni çdo karakter ngjitur në varg dhe t'i hiqni ato derisa vargu të jetë \"i mirë\".\n     * Kthejeni vargun përfundimtar \"të mirë\".\n     *\n     * Shembull 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Shpjegim: Ju mund të hiqni \"Ee\" për të bërë \"leetcode\".\n     *\n     * Shembull 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Shpjegim: Ka disa zgjidhje të mundshme, të tilla si:\n     * - Hiqni \"bB\" për të bërë \"aAcC\", pastaj hiqni \"cC\" për të bërë \"aA\", pastaj hiqni \"aA\" për të bërë \"\".\n     * - Hiqni \"aA\" për të bërë \"abBAcC\", pastaj hiqni \"bB\" për të bërë \"aAcC\", pastaj hiqni \"cC\" për të bërë \"aA\",\n     *   pastaj hiqni \"aA\" për të bërë \"\".\n     * Pavarësisht zgjedhjeve, rezultati është një varg bosh.\n     *\n     * Shembull 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Shpjegim: Vargu është tashmë \"i mirë\".\n     */\n  public String makeGood(String s) ",
      "hy": "class Solution {\n    /**\n     * Տրված է s տողը, որը բաղկացած է փոքրատառ և մեծատառ անգլերեն տառերից,\n     * դուք պետք է տողը դարձնեք \"լավ\":\n     * Տողը համարվում է \"լավ\", եթե չկան հարակից նիշեր, որոնցից\n     * մեկը փոքրատառ է, իսկ մյուսը՝ համապատասխան մեծատառ:\n     * Դուք կարող եք ընտրել ցանկացած հարակից նիշեր տողի մեջ և հեռացնել դրանք, մինչև տողը դառնա \"լավ\":\n     * Վերադարձնել վերջնական \"լավ\" տողը:\n     *\n     * Օրինակ 1:\n     * Մուտք: s = \"leEeetcode\"\n     * Ելք: \"leetcode\"\n     * Բացատրություն: Դուք կարող եք հեռացնել \"Ee\", որպեսզի ստացվի \"leetcode\":\n     *\n     * Օրինակ 2:\n     * Մուտք: s = \"abBAcC\"\n     * Ելք: \"\"\n     * Բացատրություն: Կան բազմաթիվ հնարավոր լուծումներ, օրինակ՝\n     * - Հեռացնել \"bB\", որպեսզի ստացվի \"aAcC\", ապա հեռացնել \"cC\", որպեսզի ստացվի \"aA\", ապա հեռացնել \"aA\", որպեսզի ստացվի \"\":\n     * - Հեռացնել \"aA\", որպեսզի ստացվի \"abBAcC\", ապա հեռացնել \"bB\", որպեսզի ստացվի \"aAcC\", ապա հեռացնել \"cC\", որպեսզի ստացվի \"aA\",\n     *   ապա հեռացնել \"aA\", որպեսզի ստացվի \"\":\n     * Անկախ ընտրություններից, արդյունքը դատարկ տողն է:\n     *\n     * Օրինակ 3:\n     * Մուտք: s = \"s\"\n     * Ելք: \"s\"\n     * Բացատրություն: Տողն արդեն \"լավ\" է:\n     */\n  public String makeGood(String s) ",
      "bn": "class Solution {\n    /**\n     * একটি স্ট্রিং s দেওয়া হয়েছে যা ছোট হাতের এবং বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত,\n     * আপনাকে স্ট্রিংটিকে \"ভালো\" করতে হবে।\n     * একটি স্ট্রিংকে \"ভালো\" বিবেচনা করা হয় যদি কোনো সংলগ্ন অক্ষর না থাকে যাতে\n     * একটি ছোট হাতের অক্ষর এবং অন্যটি সংশ্লিষ্ট বড় হাতের অক্ষর হয়।\n     * আপনি স্ট্রিংয়ের যেকোনো সংলগ্ন অক্ষর বেছে নিতে পারেন এবং তাদের সরিয়ে দিতে পারেন যতক্ষণ না স্ট্রিংটি \"ভালো\" হয়।\n     * চূড়ান্ত \"ভালো\" স্ট্রিংটি ফেরত দিন।\n     *\n     * উদাহরণ ১:\n     * ইনপুট: s = \"leEeetcode\"\n     * আউটপুট: \"leetcode\"\n     * ব্যাখ্যা: আপনি \"Ee\" সরিয়ে \"leetcode\" করতে পারেন।\n     *\n     * উদাহরণ ২:\n     * ইনপুট: s = \"abBAcC\"\n     * আউটপুট: \"\"\n     * ব্যাখ্যা: একাধিক সম্ভাব্য সমাধান রয়েছে, যেমন:\n     * - \"bB\" সরিয়ে \"aAcC\" করতে পারেন, তারপর \"cC\" সরিয়ে \"aA\" করতে পারেন, তারপর \"aA\" সরিয়ে \"\" করতে পারেন।\n     * - \"aA\" সরিয়ে \"abBAcC\" করতে পারেন, তারপর \"bB\" সরিয়ে \"aAcC\" করতে পারেন, তারপর \"cC\" সরিয়ে \"aA\" করতে পারেন,\n     *   তারপর \"aA\" সরিয়ে \"\" করতে পারেন।\n     * যেভাবেই হোক, ফলাফল একটি খালি স্ট্রিং।\n     *\n     * উদাহরণ ৩:\n     * ইনপুট: s = \"s\"\n     * আউটপুট: \"s\"\n     * ব্যাখ্যা: স্ট্রিংটি ইতিমধ্যে \"ভালো\"।\n     */\n  public String makeGood(String s) ",
      "bg": "class Solution {\n    /**\n     * Даден е низ s, състоящ се от малки и главни английски букви,\n     * трябва да направите низа \"добър\".\n     * Низ се счита за \"добър\", ако няма съседни символи, такива че\n     * единият е малка буква, а другият е съответната главна буква.\n     * Можете да изберете произволни съседни символи в низа и да ги премахнете, докато низът стане \"добър\".\n     * Върнете крайния \"добър\" низ.\n     *\n     * Пример 1:\n     * Вход: s = \"leEeetcode\"\n     * Изход: \"leetcode\"\n     * Обяснение: Можете да премахнете \"Ee\", за да получите \"leetcode\".\n     *\n     * Пример 2:\n     * Вход: s = \"abBAcC\"\n     * Изход: \"\"\n     * Обяснение: Има множество възможни решения, като например:\n     * - Премахнете \"bB\", за да получите \"aAcC\", след това премахнете \"cC\", за да получите \"aA\", след това премахнете \"aA\", за да получите \"\".\n     * - Премахнете \"aA\", за да получите \"abBAcC\", след това премахнете \"bB\", за да получите \"aAcC\", след това премахнете \"cC\", за да получите \"aA\",\n     *   след това премахнете \"aA\", за да получите \"\".\n     * Независимо от избора, резултатът е празен низ.\n     *\n     * Пример 3:\n     * Вход: s = \"s\"\n     * Изход: \"s\"\n     * Обяснение: Низът вече е \"добър\".\n     */\n  public String makeGood(String s) ",
      "zh": "class Solution {\n    /**\n     * 给定一个由小写和大写英文字母组成的字符串 s，\n     * 你需要将该字符串变为“良好”。\n     * 如果没有相邻字符满足一个是小写字母而另一个是对应的大写字母，\n     * 则认为字符串是“良好”的。\n     * 你可以选择字符串中的任何相邻字符并将其删除，直到字符串是“良好”的。\n     * 返回最终的“良好”字符串。\n     *\n     * 示例 1:\n     * 输入: s = \"leEeetcode\"\n     * 输出: \"leetcode\"\n     * 解释: 你可以移除 \"Ee\" 使其变为 \"leetcode\"。\n     *\n     * 示例 2:\n     * 输入: s = \"abBAcC\"\n     * 输出: \"\"\n     * 解释: 有多种可能的解决方案，例如：\n     * - 移除 \"bB\" 使其变为 \"aAcC\"，然后移除 \"cC\" 使其变为 \"aA\"，然后移除 \"aA\" 使其变为 \"\"。\n     * - 移除 \"aA\" 使其变为 \"abBAcC\"，然后移除 \"bB\" 使其变为 \"aAcC\"，然后移除 \"cC\" 使其变为 \"aA\"，\n     *   然后移除 \"aA\" 使其变为 \"\"。\n     * 无论选择如何，结果都是一个空字符串。\n     *\n     * 示例 3:\n     * 输入: s = \"s\"\n     * 输出: \"s\"\n     * 解释: 字符串已经是“良好”的。\n     */\n  public String makeGood(String s) ",
      "fr": "class Solution {\n    /**\n     * Étant donné une chaîne de caractères s composée de lettres anglaises minuscules et majuscules,\n     * vous devez rendre la chaîne \"bonne\".\n     * Une chaîne est considérée comme \"bonne\" s'il n'y a pas de caractères adjacents tels que\n     * l'un soit une lettre minuscule et l'autre la lettre majuscule correspondante.\n     * Vous pouvez choisir n'importe quels caractères adjacents dans la chaîne et les supprimer jusqu'à ce que la chaîne soit \"bonne\".\n     * Retournez la chaîne finale \"bonne\".\n     *\n     * Exemple 1 :\n     * Entrée : s = \"leEeetcode\"\n     * Sortie : \"leetcode\"\n     * Explication : Vous pouvez supprimer \"Ee\" pour obtenir \"leetcode\".\n     *\n     * Exemple 2 :\n     * Entrée : s = \"abBAcC\"\n     * Sortie : \"\"\n     * Explication : Il y a plusieurs solutions possibles, telles que :\n     * - Supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\", puis supprimer \"aA\" pour obtenir \"\".\n     * - Supprimer \"aA\" pour obtenir \"abBAcC\", puis supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\",\n     *   puis supprimer \"aA\" pour obtenir \"\".\n     * Peu importe les choix, le résultat est une chaîne vide.\n     *\n     * Exemple 3 :\n     * Entrée : s = \"s\"\n     * Sortie : \"s\"\n     * Explication : La chaîne est déjà \"bonne\".\n     */\n  public String makeGood(String s) ",
      "de": "class Solution {\n    /**\n     * Gegeben ein String s, bestehend aus Klein- und Großbuchstaben des englischen Alphabets,\n     * müssen Sie den String \"gut\" machen.\n     * Ein String wird als \"gut\" betrachtet, wenn es keine benachbarten Zeichen gibt, \n     * bei denen eines ein Kleinbuchstabe und das andere der entsprechende Großbuchstabe ist.\n     * Sie können beliebige benachbarte Zeichen im String auswählen und entfernen, bis der String \"gut\" ist.\n     * Geben Sie den endgültigen \"guten\" String zurück.\n     *\n     * Beispiel 1:\n     * Eingabe: s = \"leEeetcode\"\n     * Ausgabe: \"leetcode\"\n     * Erklärung: Sie können \"Ee\" entfernen, um \"leetcode\" zu erhalten.\n     *\n     * Beispiel 2:\n     * Eingabe: s = \"abBAcC\"\n     * Ausgabe: \"\"\n     * Erklärung: Es gibt mehrere mögliche Lösungen, wie zum Beispiel:\n     * - Entfernen Sie \"bB\", um \"aAcC\" zu erhalten, dann entfernen Sie \"cC\", um \"aA\" zu erhalten, dann entfernen Sie \"aA\", um \"\" zu erhalten.\n     * - Entfernen Sie \"aA\", um \"abBAcC\" zu erhalten, dann entfernen Sie \"bB\", um \"aAcC\" zu erhalten, dann entfernen Sie \"cC\", um \"aA\" zu erhalten,\n     *   dann entfernen Sie \"aA\", um \"\" zu erhalten.\n     * Unabhängig von den Entscheidungen ist das Ergebnis ein leerer String.\n     *\n     * Beispiel 3:\n     * Eingabe: s = \"s\"\n     * Ausgabe: \"s\"\n     * Erklärung: Der String ist bereits \"gut\".\n     */\n  public String makeGood(String s) ",
      "ha": "class Solution {\n    /**\n     * An ba da wata igiya s da ta ƙunshi ƙananan da manyan haruffan Ingilishi,\n     * kana buƙatar ka sa igiyar ta zama \"mai kyau\".\n     * Ana ɗaukar igiya \"mai kyau\" idan babu haruffa masu makwabtaka da\n     * ɗaya yana ƙaramin harafi kuma ɗayan shine daidai manyan harafin.\n     * Za ka iya zaɓar duk wani haruffa masu makwabtaka a cikin igiyar kuma ka cire su har sai igiyar ta zama \"mai kyau\".\n     * Mayar da igiyar \"mai kyau\" ta ƙarshe.\n     *\n     * Misali 1:\n     * Input: s = \"leEeetcode\"\n     * Output: \"leetcode\"\n     * Bayani: Za ka iya cire \"Ee\" don sa \"leetcode\".\n     *\n     * Misali 2:\n     * Input: s = \"abBAcC\"\n     * Output: \"\"\n     * Bayani: Akwai hanyoyi da dama masu yiwuwa, kamar:\n     * - Cire \"bB\" don sa \"aAcC\", sannan cire \"cC\" don sa \"aA\", sannan cire \"aA\" don sa \"\".\n     * - Cire \"aA\" don sa \"abBAcC\", sannan cire \"bB\" don sa \"aAcC\", sannan cire \"cC\" don sa \"aA\",\n     *   sannan cire \"aA\" don sa \"\".\n     * Duk da zaɓuɓɓuka, sakamakon shine igiya mai komai.\n     *\n     * Misali 3:\n     * Input: s = \"s\"\n     * Output: \"s\"\n     * Bayani: Igiya ta riga ta zama \"mai kyau\".\n     */\n  public String makeGood(String s) ",
      "hi": "class Solution {\n    /**\n     * दिए गए एक स्ट्रिंग s जिसमें छोटे और बड़े अंग्रेजी अक्षर शामिल हैं,\n     * आपको स्ट्रिंग को \"अच्छा\" बनाना है।\n     * एक स्ट्रिंग को \"अच्छा\" तब माना जाता है जब उसमें कोई ऐसे आसन्न वर्ण न हों\n     * जिनमें से एक छोटा अक्षर हो और दूसरा उसके अनुरूप बड़ा अक्षर हो।\n     * आप स्ट्रिंग में किसी भी आसन्न वर्णों को चुन सकते हैं और उन्हें तब तक हटा सकते हैं जब तक कि स्ट्रिंग \"अच्छी\" न हो जाए।\n     * अंतिम \"अच्छी\" स्ट्रिंग लौटाएं।\n     *\n     * उदाहरण 1:\n     * इनपुट: s = \"leEeetcode\"\n     * आउटपुट: \"leetcode\"\n     * व्याख्या: आप \"Ee\" को हटाकर \"leetcode\" बना सकते हैं।\n     *\n     * उदाहरण 2:\n     * इनपुट: s = \"abBAcC\"\n     * आउटपुट: \"\"\n     * व्याख्या: कई संभावित समाधान हैं, जैसे:\n     * - \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं, फिर \"aA\" को हटाकर \"\" बनाएं।\n     * - \"aA\" को हटाकर \"abBAcC\" बनाएं, फिर \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं,\n     *   फिर \"aA\" को हटाकर \"\" बनाएं।\n     * चाहे जो भी विकल्प चुने जाएं, परिणाम एक खाली स्ट्रिंग है।\n     *\n     * उदाहरण 3:\n     * इनपुट: s = \"s\"\n     * आउटपुट: \"s\"\n     * व्याख्या: स्ट्रिंग पहले से ही \"अच्छी\" है।\n     */\n  public String makeGood(String s) ",
      "hu": "class Solution {\n    /**\n     * Adott egy s karakterlánc, amely kis- és nagybetűs angol betűkből áll,\n     * a karakterláncot \"jóvá\" kell tenni.\n     * Egy karakterlánc akkor tekinthető \"jónak\", ha nincsenek egymás melletti karakterek úgy, hogy\n     * az egyik kisbetűs, a másik pedig a megfelelő nagybetűs.\n     * Kiválaszthatsz bármelyik egymás melletti karaktert a karakterláncban, és eltávolíthatod őket, amíg a karakterlánc \"jó\" nem lesz.\n     * Térj vissza a végső \"jó\" karakterlánccal.\n     *\n     * 1. példa:\n     * Bemenet: s = \"leEeetcode\"\n     * Kimenet: \"leetcode\"\n     * Magyarázat: Eltávolíthatod az \"Ee\"-t, hogy \"leetcode\"-t kapj.\n     *\n     * 2. példa:\n     * Bemenet: s = \"abBAcC\"\n     * Kimenet: \"\"\n     * Magyarázat: Több lehetséges megoldás is van, például:\n     * - Eltávolítod a \"bB\"-t, hogy \"aAcC\"-t kapj, majd eltávolítod a \"cC\"-t, hogy \"aA\"-t kapj, majd eltávolítod az \"aA\"-t, hogy \"\"-t kapj.\n     * - Eltávolítod az \"aA\"-t, hogy \"abBAcC\"-t kapj, majd eltávolítod a \"bB\"-t, hogy \"aAcC\"-t kapj, majd eltávolítod a \"cC\"-t, hogy \"aA\"-t kapj,\n     *   majd eltávolítod az \"aA\"-t, hogy \"\"-t kapj.\n     * Nem számít, milyen választásokat teszel, az eredmény egy üres karakterlánc lesz.\n     *\n     * 3. példa:\n     * Bemenet: s = \"s\"\n     * Kimenet: \"s\"\n     * Magyarázat: A karakterlánc már \"jó\".\n     */\n  public String makeGood(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.998331902060069",
      "hy": "0.9722100206501708",
      "bn": "0.9856390234511776",
      "bg": "0.9868300112158628",
      "zh": "0.9754610040965689",
      "fr": "0.9855085232908377",
      "de": "0.9748535923913642",
      "ha": "0.9893718842019662",
      "hi": "0.9865763602192812",
      "hu": "0.9736073853807513"
    },
    "canonical_solution": "  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }",
    "instruction": {
      "en": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public String makeGood(String s)\n  {\n\n    StringBuilder sb = new StringBuilder(s);\n    int i = 0;\n    while (i < sb.length() - 1) {\n      if (Math.abs(sb.charAt(i) - sb.charAt(i + 1)) == 32) {\n        sb.delete(i, i + 2);\n        i = Math.max(0, i - 1);\n      } else {\n        i++;\n      }\n    }\n    return sb.toString();\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9444834043918918",
      "hy": "0.9242475370632005",
      "bn": "0.9096337040393208",
      "bg": "0.8376140553201085",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.makeGood(\"aAbBcC\").equals(\"\");\n    assert solution.makeGood(\"AaBbCc\").equals(\"\");\n    assert solution.makeGood(\"abcABC\").equals(\"abcABC\");\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "makeGood",
    "signature": "public String makeGood(String s)",
    "docstring": {
      "en": "Given a string s consisting of lowercase and uppercase English letters,\nyou need to make the string \"good\".\nA string is considered \"good\" if there are no adjacent characters such that\none is a lowercase letter and the other is the corresponding uppercase letter.\nYou can choose any adjacent characters in the string and remove them until the string is \"good\".\nReturn the final \"good\" string.\n\nExample 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nExplanation: You can remove \"Ee\" to make \"leetcode\".\n\nExample 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nExplanation: There are multiple possible solutions, such as:\n- Remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\", then remove \"aA\" to make \"\".\n- Remove \"aA\" to make \"abBAcC\", then remove \"bB\" to make \"aAcC\", then remove \"cC\" to make \"aA\",\nthen remove \"aA\" to make \"\".\nNo matter the choices, the result is an empty string.\n\nExample 3:\nInput: s = \"s\"\nOutput: \"s\"\nExplanation: The string is already \"good\".",
      "sq": "Duke pasur një varg s që përbëhet nga shkronja të vogla dhe të mëdha të alfabetit anglisht,\nju duhet ta bëni vargun \"të mirë\".\nNjë varg konsiderohet \"i mirë\" nëse nuk ka karaktere ngjitur të tilla që\nnjëri është një shkronjë e vogël dhe tjetri është shkronja përkatëse e madhe.\nJu mund të zgjidhni çdo karakter ngjitur në varg dhe t'i hiqni ato derisa vargu të jetë \"i mirë\".\nKthe vargun përfundimtar \"të mirë\".\n\nShembull 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nShpjegim: Ju mund të hiqni \"Ee\" për të bërë \"leetcode\".\n\nShembull 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nShpjegim: Ka zgjidhje të shumta të mundshme, të tilla si:\n- Hiqni \"bB\" për të bërë \"aAcC\", pastaj hiqni \"cC\" për të bërë \"aA\", pastaj hiqni \"aA\" për të bërë \"\".\n- Hiqni \"aA\" për të bërë \"abBAcC\", pastaj hiqni \"bB\" për të bërë \"aAcC\", pastaj hiqni \"cC\" për të bërë \"aA\",\npastaj hiqni \"aA\" për të bërë \"\".\nPavarësisht zgjedhjeve, rezultati është një varg bosh.\n\nShembull 3:\nInput: s = \"s\"\nOutput: \"s\"\nShpjegim: Vargu është tashmë \"i mirë\".",
      "hy": "Տրված է s տողը, որը բաղկացած է փոքրատառ և մեծատառ անգլերեն տառերից, \nդուք պետք է տողը դարձնեք \"լավ\":\nՏողը համարվում է \"լավ\", եթե չկան հարակից նիշեր, որոնցից մեկը փոքրատառ է, իսկ մյուսը՝ համապատասխան մեծատառը:\nԴուք կարող եք ընտրել տողի ցանկացած հարակից նիշեր և հեռացնել դրանք, մինչև տողը դառնա \"լավ\":\nՎերադարձնել վերջնական \"լավ\" տողը:\n\nՕրինակ 1:\nՄուտքագրում: s = \"leEeetcode\"\nԵլք: \"leetcode\"\nԲացատրություն: Դուք կարող եք հեռացնել \"Ee\"՝ դարձնելու համար \"leetcode\":\n\nՕրինակ 2:\nՄուտքագրում: s = \"abBAcC\"\nԵլք: \"\"\nԲացատրություն: Կան բազմաթիվ հնարավոր լուծումներ, օրինակ՝\n- Հեռացնել \"bB\"՝ դարձնելու համար \"aAcC\", ապա հեռացնել \"cC\"՝ դարձնելու համար \"aA\", ապա հեռացնել \"aA\"՝ դարձնելու համար \"\".\n- Հեռացնել \"aA\"՝ դարձնելու համար \"abBAcC\", ապա հեռացնել \"bB\"՝ դարձնելու համար \"aAcC\", ապա հեռացնել \"cC\"՝ դարձնելու համար \"aA\",\nապա հեռացնել \"aA\"՝ դարձնելու համար \"\".\nԱնկախ ընտրություններից, արդյունքը դատարկ տող է:\n\nՕրինակ 3:\nՄուտքագրում: s = \"s\"\nԵլք: \"s\"\nԲացատրություն: Տողն արդեն \"լավ\" է:",
      "bn": "একটি স্ট্রিং s দেওয়া হয়েছে যা ছোট হাতের এবং বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত, \nআপনাকে স্ট্রিংটিকে \"ভাল\" করতে হবে। \nএকটি স্ট্রিংকে \"ভাল\" বলে বিবেচনা করা হয় যদি কোনো সংলগ্ন অক্ষর না থাকে \nযেখানে একটি ছোট হাতের অক্ষর এবং অন্যটি সংশ্লিষ্ট বড় হাতের অক্ষর। \nআপনি স্ট্রিংয়ের যেকোনো সংলগ্ন অক্ষর নির্বাচন করতে পারেন এবং সেগুলি সরিয়ে ফেলতে পারেন যতক্ষণ না স্ট্রিংটি \"ভাল\" হয়। \nচূড়ান্ত \"ভাল\" স্ট্রিংটি ফেরত দিন।\n\nউদাহরণ ১:\nইনপুট: s = \"leEeetcode\"\nআউটপুট: \"leetcode\"\nব্যাখ্যা: আপনি \"Ee\" সরিয়ে \"leetcode\" করতে পারেন।\n\nউদাহরণ ২:\nইনপুট: s = \"abBAcC\"\nআউটপুট: \"\"\nব্যাখ্যা: একাধিক সম্ভাব্য সমাধান রয়েছে, যেমন:\n- \"bB\" সরিয়ে \"aAcC\" করতে পারেন, তারপর \"cC\" সরিয়ে \"aA\" করতে পারেন, তারপর \"aA\" সরিয়ে \"\" করতে পারেন।\n- \"aA\" সরিয়ে \"abBAcC\" করতে পারেন, তারপর \"bB\" সরিয়ে \"aAcC\" করতে পারেন, তারপর \"cC\" সরিয়ে \"aA\" করতে পারেন,\nতারপর \"aA\" সরিয়ে \"\" করতে পারেন।\nযে কোনো পছন্দেই, ফলাফল একটি খালি স্ট্রিং।\n\nউদাহরণ ৩:\nইনপুট: s = \"s\"\nআউটপুট: \"s\"\nব্যাখ্যা: স্ট্রিংটি ইতিমধ্যেই \"ভাল\"।",
      "bg": "Даден е низ `s`, състоящ се от малки и главни английски букви, трябва да направите низа \"добър\". Един низ се счита за \"добър\", ако няма съседни символи, такива че единият е малка буква, а другият е съответната главна буква. Можете да изберете произволни съседни символи в низа и да ги премахнете, докато низът стане \"добър\". Върнете крайния \"добър\" низ.\n\nПример 1:\nВход: s = \"leEeetcode\"\nИзход: \"leetcode\"\nОбяснение: Можете да премахнете \"Ee\", за да направите \"leetcode\".\n\nПример 2:\nВход: s = \"abBAcC\"\nИзход: \"\"\nОбяснение: Има множество възможни решения, като например:\n- Премахнете \"bB\", за да направите \"aAcC\", след това премахнете \"cC\", за да направите \"aA\", след това премахнете \"aA\", за да направите \"\".\n- Премахнете \"aA\", за да направите \"abBAcC\", след това премахнете \"bB\", за да направите \"aAcC\", след това премахнете \"cC\", за да направите \"aA\",\nслед това премахнете \"aA\", за да направите \"\".\nНезависимо от избора, резултатът е празен низ.\n\nПример 3:\nВход: s = \"s\"\nИзход: \"s\"\nОбяснение: Низът вече е \"добър\".",
      "zh": "给定一个由小写和大写英文字母组成的字符串 s，您需要使字符串“良好”。 如果没有相邻字符使得一个是小写字母而另一个是相应的大写字母，则认为字符串是“良好”的。 您可以选择字符串中的任何相邻字符并将其删除，直到字符串是“良好”的。 返回最终的“良好”字符串。\n\n示例 1:\n输入: s = \"leEeetcode\"\n输出: \"leetcode\"\n解释: 您可以删除 \"Ee\" 以使 \"leetcode\"。\n\n示例 2:\n输入: s = \"abBAcC\"\n输出: \"\"\n解释: 有多种可能的解决方案，例如：\n- 删除 \"bB\" 以使 \"aAcC\"，然后删除 \"cC\" 以使 \"aA\"，然后删除 \"aA\" 以使 \"\"。\n- 删除 \"aA\" 以使 \"abBAcC\"，然后删除 \"bB\" 以使 \"aAcC\"，然后删除 \"cC\" 以使 \"aA\"，然后删除 \"aA\" 以使 \"\"。\n无论选择如何，结果都是一个空字符串。\n\n示例 3:\n输入: s = \"s\"\n输出: \"s\"\n解释: 字符串已经是“良好”的。",
      "fr": "Étant donné une chaîne `s` composée de lettres anglaises minuscules et majuscules, vous devez rendre la chaîne \"bonne\". Une chaîne est considérée comme \"bonne\" s'il n'y a pas de caractères adjacents tels que l'un soit une lettre minuscule et l'autre la lettre majuscule correspondante. Vous pouvez choisir n'importe quels caractères adjacents dans la chaîne et les supprimer jusqu'à ce que la chaîne soit \"bonne\". Retournez la chaîne \"bonne\" finale.\n\nExemple 1 :\nEntrée : s = \"leEeetcode\"\nSortie : \"leetcode\"\nExplication : Vous pouvez supprimer \"Ee\" pour obtenir \"leetcode\".\n\nExemple 2 :\nEntrée : s = \"abBAcC\"\nSortie : \"\"\nExplication : Il existe plusieurs solutions possibles, telles que :\n- Supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\", puis supprimer \"aA\" pour obtenir \"\".\n- Supprimer \"aA\" pour obtenir \"abBAcC\", puis supprimer \"bB\" pour obtenir \"aAcC\", puis supprimer \"cC\" pour obtenir \"aA\",\npuis supprimer \"aA\" pour obtenir \"\".\nPeu importe les choix, le résultat est une chaîne vide.\n\nExemple 3 :\nEntrée : s = \"s\"\nSortie : \"s\"\nExplication : La chaîne est déjà \"bonne\".",
      "de": "Gegeben ist ein String s, der aus Klein- und Großbuchstaben des englischen Alphabets besteht. Sie müssen den String \"gut\" machen. Ein String wird als \"gut\" betrachtet, wenn es keine benachbarten Zeichen gibt, bei denen eines ein Kleinbuchstabe und das andere der entsprechende Großbuchstabe ist. Sie können beliebige benachbarte Zeichen im String auswählen und entfernen, bis der String \"gut\" ist. Geben Sie den endgültigen \"guten\" String zurück.\n\nBeispiel 1:\nEingabe: s = \"leEeetcode\"\nAusgabe: \"leetcode\"\nErläuterung: Sie können \"Ee\" entfernen, um \"leetcode\" zu erhalten.\n\nBeispiel 2:\nEingabe: s = \"abBAcC\"\nAusgabe: \"\"\nErläuterung: Es gibt mehrere mögliche Lösungen, wie zum Beispiel:\n- Entfernen Sie \"bB\", um \"aAcC\" zu erhalten, dann entfernen Sie \"cC\", um \"aA\" zu erhalten, dann entfernen Sie \"aA\", um \"\" zu erhalten.\n- Entfernen Sie \"aA\", um \"abBAcC\" zu erhalten, dann entfernen Sie \"bB\", um \"aAcC\" zu erhalten, dann entfernen Sie \"cC\", um \"aA\" zu erhalten, dann entfernen Sie \"aA\", um \"\" zu erhalten.\nUnabhängig von den Entscheidungen ist das Ergebnis ein leerer String.\n\nBeispiel 3:\nEingabe: s = \"s\"\nAusgabe: \"s\"\nErläuterung: Der String ist bereits \"gut\".",
      "ha": "An ba da wata igiyar s da ta ƙunshi ƙananan da manyan haruffan Ingilishi,\nkana buƙatar ka sa igiyar ta zama \"mai kyau\".\nAna ɗaukar igiya a matsayin \"mai kyau\" idan babu haruffa masu makwabtaka da\ndaya yana da ƙaramar harafi kuma ɗayan yana da babbar harafi mai dacewa.\nZa ka iya zaɓar duk wani haruffa masu makwabtaka a cikin igiyar kuma ka cire su har sai igiyar ta zama \"mai kyau\".\nMayar da igiyar \"mai kyau\" ta ƙarshe.\n\nMisali 1:\nInput: s = \"leEeetcode\"\nOutput: \"leetcode\"\nBayani: Za ka iya cire \"Ee\" don sa \"leetcode\".\n\nMisali 2:\nInput: s = \"abBAcC\"\nOutput: \"\"\nBayani: Akwai hanyoyi da dama masu yiwuwa, kamar:\n- Cire \"bB\" don sa \"aAcC\", sannan cire \"cC\" don sa \"aA\", sannan cire \"aA\" don sa \"\".\n- Cire \"aA\" don sa \"abBAcC\", sannan cire \"bB\" don sa \"aAcC\", sannan cire \"cC\" don sa \"aA\",\nsannan cire \"aA\" don sa \"\".\nDuk da zaɓuɓɓuka, sakamakon shi ne igiya mai komai.\n\nMisali 3:\nInput: s = \"s\"\nOutput: \"s\"\nBayani: Igiyar ta riga ta zama \"mai kyau\".",
      "hi": "दी गई एक स्ट्रिंग s जिसमें छोटे और बड़े अंग्रेजी अक्षर शामिल हैं, आपको स्ट्रिंग को \"अच्छा\" बनाना है। \nएक स्ट्रिंग को \"अच्छा\" तब माना जाता है जब कोई भी आसन्न वर्ण ऐसे नहीं होते हैं कि \nएक छोटा अक्षर हो और दूसरा संबंधित बड़ा अक्षर हो। \nआप स्ट्रिंग में किसी भी आसन्न वर्णों को चुन सकते हैं और उन्हें तब तक हटा सकते हैं जब तक कि स्ट्रिंग \"अच्छा\" न हो जाए। \nअंतिम \"अच्छा\" स्ट्रिंग लौटाएं।\n\nउदाहरण 1:\nइनपुट: s = \"leEeetcode\"\nआउटपुट: \"leetcode\"\nव्याख्या: आप \"Ee\" को हटाकर \"leetcode\" बना सकते हैं।\n\nउदाहरण 2:\nइनपुट: s = \"abBAcC\"\nआउटपुट: \"\"\nव्याख्या: कई संभावित समाधान हैं, जैसे:\n- \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं, फिर \"aA\" को हटाकर \"\" बनाएं।\n- \"aA\" को हटाकर \"abBAcC\" बनाएं, फिर \"bB\" को हटाकर \"aAcC\" बनाएं, फिर \"cC\" को हटाकर \"aA\" बनाएं,\nफिर \"aA\" को हटाकर \"\" बनाएं।\nचाहे जो भी विकल्प चुने जाएं, परिणाम एक खाली स्ट्रिंग है।\n\nउदाहरण 3:\nइनपुट: s = \"s\"\nआउटपुट: \"s\"\nव्याख्या: स्ट्रिंग पहले से ही \"अच्छा\" है।",
      "hu": "Adott egy s string, amely kis- és nagybetűs angol betűkből áll,\nés \"jóvá\" kell tenni a stringet.\nEgy string akkor tekinthető \"jónak\", ha nincsenek szomszédos karakterek úgy,\nhogy az egyik kisbetű, a másik pedig a megfelelő nagybetű.\nKiválaszthat bármilyen szomszédos karaktereket a stringben, és eltávolíthatja őket, amíg a string \"jó\" nem lesz.\nAdja vissza a végső \"jó\" stringet.\n\nPélda 1:\nBemenet: s = \"leEeetcode\"\nKimenet: \"leetcode\"\nMagyarázat: Eltávolíthatja az \"Ee\"-t, hogy \"leetcode\"-t kapjon.\n\nPélda 2:\nBemenet: s = \"abBAcC\"\nKimenet: \"\"\nMagyarázat: Több lehetséges megoldás is van, például:\n- Eltávolítja a \"bB\"-t, hogy \"aAcC\"-t kapjon, majd eltávolítja a \"cC\"-t, hogy \"aA\"-t kapjon, majd eltávolítja az \"aA\"-t, hogy \"\"-t kapjon.\n- Eltávolítja az \"aA\"-t, hogy \"abBAcC\"-t kapjon, majd eltávolítja a \"bB\"-t, hogy \"aAcC\"-t kapjon, majd eltávolítja a \"cC\"-t, hogy \"aA\"-t kapjon,\nmajd eltávolítja az \"aA\"-t, hogy \"\"-t kapjon.\nBármilyen választás esetén az eredmény egy üres string.\n\nPélda 3:\nBemenet: s = \"s\"\nKimenet: \"s\"\nMagyarázat: A string már \"jó\"."
    },
    "docstring_bertscore": {
      "sq": "0.9824468345975659",
      "hy": "0.9925314976730882",
      "bn": "0.9840916927829158",
      "bg": "0.9861842638471183",
      "zh": "0.9897631860526049",
      "fr": "0.9738085979567397",
      "de": "0.9741043585941006",
      "ha": "0.9833933083631972",
      "hi": "0.9971115169989907",
      "hu": "0.9740249064416866"
    }
  },
  {
    "task_id": "Java/31",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Given a string s, split the string and return the maximum number of unique substrings.\n   * The split substrings should be able to reconstruct the original string, and each substring must be unique.\n   *\n   * Example:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Explanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\n   *              Splitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n   *\n   * Note:\n   * - The length of s is between 1 and 16.\n   * - s only contains lowercase English letters.\n   */\n  public int maxUniqueSplit(String s) ",
      "sq": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Duke pasur një varg s, ndani vargun dhe ktheni numrin maksimal të nënvargjeve unike.\n   * Nënvargjet e ndara duhet të jenë në gjendje të rindërtojnë vargun origjinal, dhe secili nënvarg duhet të jetë unik.\n   *\n   * Shembull:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Shpjegim: Një mënyrë e mundshme për të ndarë vargun është ['a', 'b', 'ab', 'c', 'cc'].\n   *              Ndarja e vargut si ['a', 'b', 'a', 'b', 'c', 'cc'] nuk është e vlefshme, sepse si 'a' ashtu edhe 'b' shfaqen më shumë se një herë.\n   *\n   * Shënim:\n   * - Gjatësia e s është midis 1 dhe 16.\n   * - s përmban vetëm shkronja të vogla të anglishtes.\n   */\n  public int maxUniqueSplit(String s) ",
      "hy": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Տրված է s տողը, բաժանեք տողը և վերադարձեք եզակի ենթատողերի առավելագույն քանակը:\n   * Բաժանված ենթատողերը պետք է կարողանան վերականգնել սկզբնական տողը, և յուրաքանչյուր ենթատող պետք է լինի եզակի:\n   *\n   * Օրինակ:\n   * Մուտք: s = \"ababccc\"\n   * Ելք: 5\n   * Բացատրություն: Տողը բաժանելու հնարավոր տարբերակներից մեկն է ['a', 'b', 'ab', 'c', 'cc']:\n   *               Տողը ['a', 'b', 'a', 'b', 'c', 'cc'] ձևով բաժանելը անվավեր է, քանի որ 'a' և 'b' երկուսն էլ հայտնվում են մեկից ավելի անգամ:\n   *\n   * Նշում:\n   * - s-ի երկարությունը 1-ից 16 է:\n   * - s-ն պարունակում է միայն փոքրատառ անգլերեն տառեր:\n   */\n  public int maxUniqueSplit(String s) ",
      "bn": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * একটি স্ট্রিং s দেওয়া আছে, স্ট্রিংটি ভাগ করুন এবং সর্বাধিক সংখ্যক অনন্য উপ-স্ট্রিং ফেরত দিন।\n   * বিভক্ত উপ-স্ট্রিংগুলিকে মূল স্ট্রিংটি পুনর্গঠন করতে সক্ষম হতে হবে, এবং প্রতিটি উপ-স্ট্রিং অনন্য হতে হবে।\n   *\n   * উদাহরণ:\n   * ইনপুট: s = \"ababccc\"\n   * আউটপুট: 5\n   * ব্যাখ্যা: স্ট্রিংটি ভাগ করার একটি সম্ভাব্য উপায় হল ['a', 'b', 'ab', 'c', 'cc']।\n   *              স্ট্রিংটি ['a', 'b', 'a', 'b', 'c', 'cc'] হিসাবে ভাগ করা বৈধ নয়, কারণ 'a' এবং 'b' উভয়ই একাধিকবার উপস্থিত হয়।\n   *\n   * নোট:\n   * - s এর দৈর্ঘ্য 1 এবং 16 এর মধ্যে।\n   * - s শুধুমাত্র ছোট হাতের ইংরেজি অক্ষর ধারণ করে।\n   */\n  public int maxUniqueSplit(String s) ",
      "bg": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Даден е низ s, разделете низа и върнете максималния брой уникални поднизове.\n   * Разделените поднизове трябва да могат да възстановят оригиналния низ, и всеки подниз трябва да е уникален.\n   *\n   * Пример:\n   * Вход: s = \"ababccc\"\n   * Изход: 5\n   * Обяснение: Един възможен начин за разделяне на низа е ['a', 'b', 'ab', 'c', 'cc'].\n   *              Разделянето на низа като ['a', 'b', 'a', 'b', 'c', 'cc'] не е валидно, защото както 'a', така и 'b' се появяват повече от веднъж.\n   *\n   * Забележка:\n   * - Дължината на s е между 1 и 16.\n   * - s съдържа само малки английски букви.\n   */\n  public int maxUniqueSplit(String s) ",
      "zh": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * 给定一个字符串 s，拆分字符串并返回最大数量的唯一子字符串。\n   * 拆分后的子字符串应能够重构原始字符串，并且每个子字符串必须是唯一的。\n   *\n   * 示例:\n   * 输入: s = \"ababccc\"\n   * 输出: 5\n   * 解释: 拆分字符串的一种可能方式是 ['a', 'b', 'ab', 'c', 'cc']。\n   *              将字符串拆分为 ['a', 'b', 'a', 'b', 'c', 'cc'] 是无效的，因为 'a' 和 'b' 都出现了多次。\n   *\n   * 注意:\n   * - s 的长度在 1 到 16 之间。\n   * - s 仅包含小写英文字母。\n   */\n  public int maxUniqueSplit(String s) ",
      "fr": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Étant donné une chaîne de caractères s, divisez la chaîne et retournez le nombre maximum de sous-chaînes uniques.\n   * Les sous-chaînes divisées doivent pouvoir reconstruire la chaîne originale, et chaque sous-chaîne doit être unique.\n   *\n   * Exemple :\n   * Entrée : s = \"ababccc\"\n   * Sortie : 5\n   * Explication : Une façon possible de diviser la chaîne est ['a', 'b', 'ab', 'c', 'cc'].\n   *               Diviser la chaîne comme ['a', 'b', 'a', 'b', 'c', 'cc'] n'est pas valide, car 'a' et 'b' apparaissent plus d'une fois.\n   *\n   * Remarque :\n   * - La longueur de s est comprise entre 1 et 16.\n   * - s ne contient que des lettres minuscules anglaises.\n   */\n  public int maxUniqueSplit(String s) ",
      "de": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Gegeben ein String s, teile den String und gib die maximale Anzahl einzigartiger Substrings zurück.\n   * Die geteilten Substrings sollten in der Lage sein, den ursprünglichen String zu rekonstruieren, und jedes Substring muss einzigartig sein.\n   *\n   * Beispiel:\n   * Eingabe: s = \"ababccc\"\n   * Ausgabe: 5\n   * Erklärung: Eine mögliche Möglichkeit, den String zu teilen, ist ['a', 'b', 'ab', 'c', 'cc'].\n   *              Das Teilen des Strings als ['a', 'b', 'a', 'b', 'c', 'cc'] ist nicht gültig, da sowohl 'a' als auch 'b' mehr als einmal vorkommen.\n   *\n   * Hinweis:\n   * - Die Länge von s liegt zwischen 1 und 16.\n   * - s enthält nur kleine englische Buchstaben.\n   */\n  public int maxUniqueSplit(String s) ",
      "ha": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Idan aka ba da igiyar s, a raba igiyar kuma a dawo da yawan abubuwan da ba su maimaita kansu ba.\n   * Ya kamata a iya sake gina igiyar asali daga abubuwan da aka raba, kuma kowanne abu dole ne ya zama na musamman.\n   *\n   * Misali:\n   * Input: s = \"ababccc\"\n   * Output: 5\n   * Bayani: Wata hanya mai yiwuwa don raba igiyar ita ce ['a', 'b', 'ab', 'c', 'cc'].\n   *              Raba igiyar a matsayin ['a', 'b', 'a', 'b', 'c', 'cc'] ba daidai ba ne, domin duka 'a' da 'b' sun bayyana fiye da sau daya.\n   *\n   * Lura:\n   * - Tsawon s yana tsakanin 1 da 16.\n   * - s yana dauke da ƙananan haruffan Ingilishi kawai.\n   */\n  public int maxUniqueSplit(String s) ",
      "hi": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * दिए गए एक स्ट्रिंग s को विभाजित करें और अद्वितीय उपस्ट्रिंग्स की अधिकतम संख्या लौटाएं।\n   * विभाजित उपस्ट्रिंग्स को मूल स्ट्रिंग को पुनर्निर्माण करने में सक्षम होना चाहिए, और प्रत्येक उपस्ट्रिंग अद्वितीय होनी चाहिए।\n   *\n   * उदाहरण:\n   * इनपुट: s = \"ababccc\"\n   * आउटपुट: 5\n   * व्याख्या: स्ट्रिंग को विभाजित करने का एक संभव तरीका ['a', 'b', 'ab', 'c', 'cc'] है।\n   *              स्ट्रिंग को ['a', 'b', 'a', 'b', 'c', 'cc'] के रूप में विभाजित करना मान्य नहीं है, क्योंकि 'a' और 'b' दोनों एक से अधिक बार प्रकट होते हैं।\n   *\n   * नोट:\n   * - s की लंबाई 1 और 16 के बीच है।\n   * - s केवल छोटे अंग्रेजी अक्षरों को शामिल करता है।\n   */\n  public int maxUniqueSplit(String s) ",
      "hu": "import java.util.*;\n\nclass Solution {\n\n  /**\n   * Adott egy s string, ossza fel a stringet, és adja vissza az egyedi részstringek maximális számát.\n   * Az osztott részstringeknek képesnek kell lenniük az eredeti string rekonstruálására, és minden részstringnek egyedinek kell lennie.\n   *\n   * Példa:\n   * Bemenet: s = \"ababccc\"\n   * Kimenet: 5\n   * Magyarázat: A string felosztásának egyik lehetséges módja ['a', 'b', 'ab', 'c', 'cc'].\n   *              A string felosztása ['a', 'b', 'a', 'b', 'c', 'cc'] nem érvényes, mert mind az 'a', mind a 'b' többször is előfordul.\n   *\n   * Megjegyzés:\n   * - Az s hossza 1 és 16 között van.\n   * - s csak kisbetűs angol betűket tartalmaz.\n   */\n  public int maxUniqueSplit(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9994088759860402",
      "hy": "0.9917085720044606",
      "bn": "0.9940496296753378",
      "bg": "0.993600526383818",
      "zh": "0.9891418702207279",
      "fr": "0.994051020088005",
      "de": "0.9976158395364383",
      "ha": "0.9604584514170038",
      "hi": "0.9832910137169641",
      "hu": "0.9841002338893003"
    },
    "canonical_solution": "  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n",
    "instruction": {
      "en": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "public int maxUniqueSplit(String s)\n  {\n    return dfs(s, 0, new HashSet<>());\n  }\n\n  private int dfs(String s, int start, Set<String> seen) {\n    if (start == s.length()) {\n      return seen.size();\n    }\n    int max = 0;\n    for (int end = start + 1; end <= s.length(); end++) {\n      String sub = s.substring(start, end);\n      if (seen.add(sub)) {\n        max = Math.max(max, dfs(s, end, seen));\n        seen.remove(sub);\n      }\n    }\n    return max;\n  }\n\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.9238701393392342",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9212090881245099",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.maxUniqueSplit(\"ababccc\") == 5;\n    assert solution.maxUniqueSplit(\"abcabcabc\") == 6;\n    assert solution.maxUniqueSplit(\"abcdefg\") == 7;\n    assert solution.maxUniqueSplit(\"aaaaaaa\") == 3;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "maxUniqueSplit",
    "signature": "public int maxUniqueSplit(String s)",
    "docstring": {
      "en": "Given a string s, split the string and return the maximum number of unique substrings.\nThe split substrings should be able to reconstruct the original string, and each substring must be unique.\n\nExample:\nInput: s = \"ababccc\"\nOutput: 5\nExplanation: One possible way to split the string is ['a', 'b', 'ab', 'c', 'cc'].\nSplitting the string as ['a', 'b', 'a', 'b', 'c', 'cc'] is not valid, because both 'a' and 'b' appear more than once.\n\nNote:\n- The length of s is between 1 and 16.\n- s only contains lowercase English letters.",
      "sq": "Duke pasur një varg s, ndani vargun dhe ktheni numrin maksimal të nënvargjeve unike. Nënvargjet e ndara duhet të jenë në gjendje të rindërtojnë vargun origjinal, dhe çdo nënvargje duhet të jetë unik.\n\nShembull:\nInput: s = \"ababccc\"\nOutput: 5\nShpjegim: Një mënyrë e mundshme për të ndarë vargun është ['a', 'b', 'ab', 'c', 'cc'].\nNdarja e vargut si ['a', 'b', 'a', 'b', 'c', 'cc'] nuk është e vlefshme, sepse si 'a' ashtu edhe 'b' shfaqen më shumë se një herë.\n\nShënim:\n- Gjatësia e s është midis 1 dhe 16.\n- s përmban vetëm shkronja të vogla të anglishtes.",
      "hy": "Տրված է s տողը, բաժանեք տողը և վերադարձեք առավելագույն քանակով եզակի ենթատողեր:\nԲաժանված ենթատողերը պետք է կարողանան վերականգնել սկզբնական տողը, և յուրաքանչյուր ենթատող պետք է լինի եզակի:\n\nՕրինակ:\nՄուտքագրում: s = \"ababccc\"\nԵլք: 5\nԲացատրություն: Տողի բաժանման հնարավոր տարբերակներից մեկն է ['a', 'b', 'ab', 'c', 'cc']:\nՏողը ['a', 'b', 'a', 'b', 'c', 'cc'] ձևով բաժանելը անվավեր է, քանի որ և՛ 'a', և՛ 'b' հայտնվում են մեկից ավելի անգամ:\n\nՆշում:\n- s-ի երկարությունը 1-ից 16 է:\n- s-ն պարունակում է միայն փոքրատառ անգլերեն տառեր:",
      "bn": "প্রদত্ত একটি স্ট্রিং s, স্ট্রিংটি বিভক্ত করুন এবং সর্বাধিক সংখ্যক অনন্য উপ-স্ট্রিং ফেরত দিন। বিভক্ত উপ-স্ট্রিংগুলি মূল স্ট্রিংটি পুনর্গঠন করতে সক্ষম হওয়া উচিত এবং প্রতিটি উপ-স্ট্রিং অনন্য হতে হবে।\n\nউদাহরণ:\nইনপুট: s = \"ababccc\"\nআউটপুট: 5\nব্যাখ্যা: স্ট্রিংটি বিভক্ত করার একটি সম্ভাব্য উপায় হল ['a', 'b', 'ab', 'c', 'cc']।\nস্ট্রিংটি ['a', 'b', 'a', 'b', 'c', 'cc'] হিসাবে বিভক্ত করা বৈধ নয়, কারণ 'a' এবং 'b' উভয়ই একাধিকবার উপস্থিত হয়।\n\nনোট:\n- s এর দৈর্ঘ্য 1 এবং 16 এর মধ্যে।\n- s শুধুমাত্র ছোট হাতের ইংরেজি অক্ষর ধারণ করে।",
      "bg": "Даден е низ s, разделете низа и върнете максималния брой уникални поднизове. Разделените поднизове трябва да могат да реконструират оригиналния низ, и всеки подниз трябва да е уникален.\n\nПример:\nВход: s = \"ababccc\"\nИзход: 5\nОбяснение: Един възможен начин да се раздели низа е ['a', 'b', 'ab', 'c', 'cc'].\nРазделянето на низа като ['a', 'b', 'a', 'b', 'c', 'cc'] не е валидно, защото както 'a', така и 'b' се появяват повече от веднъж.\n\nЗабележка:\n- Дължината на s е между 1 и 16.\n- s съдържа само малки английски букви.",
      "zh": "给定一个字符串 s，拆分字符串并返回最大数量的唯一子字符串。  \n拆分后的子字符串应能够重构原始字符串，并且每个子字符串必须是唯一的。\n\n示例:  \n输入: s = \"ababccc\"  \n输出: 5  \n解释: 一种可能的拆分方式是 ['a', 'b', 'ab', 'c', 'cc']。  \n将字符串拆分为 ['a', 'b', 'a', 'b', 'c', 'cc'] 是无效的，因为 'a' 和 'b' 都出现了不止一次。\n\n注意:  \n- s 的长度在 1 到 16 之间。  \n- s 仅包含小写英文字母。",
      "fr": "Étant donné une chaîne de caractères s, divisez la chaîne et retournez le nombre maximum de sous-chaînes uniques.  \nLes sous-chaînes divisées doivent pouvoir reconstruire la chaîne originale, et chaque sous-chaîne doit être unique.\n\nExemple :  \nEntrée : s = \"ababccc\"  \nSortie : 5  \nExplication : Une façon possible de diviser la chaîne est ['a', 'b', 'ab', 'c', 'cc'].  \nDiviser la chaîne comme ['a', 'b', 'a', 'b', 'c', 'cc'] n'est pas valide, car 'a' et 'b' apparaissent plus d'une fois.\n\nRemarque :  \n- La longueur de s est comprise entre 1 et 16.  \n- s ne contient que des lettres minuscules anglaises.",
      "de": "Gegeben ein String s, teile den String und gib die maximale Anzahl einzigartiger Substrings zurück.\nDie geteilten Substrings sollten in der Lage sein, den ursprünglichen String zu rekonstruieren, und jedes Substring muss einzigartig sein.\n\nBeispiel:\nEingabe: s = \"ababccc\"\nAusgabe: 5\nErklärung: Eine mögliche Möglichkeit, den String zu teilen, ist ['a', 'b', 'ab', 'c', 'cc'].\nDas Teilen des Strings als ['a', 'b', 'a', 'b', 'c', 'cc'] ist nicht gültig, da sowohl 'a' als auch 'b' mehr als einmal vorkommen.\n\nHinweis:\n- Die Länge von s liegt zwischen 1 und 16.\n- s enthält nur kleine englische Buchstaben.",
      "ha": "An ba da wani kirtani s, a raba kirtanin kuma a mayar da mafi girman adadin kirtan-kirtan na musamman.\nKirtan-kirtan da aka raba yakamata su iya sake gina kirtani na asali, kuma kowanne kirtani dole ne ya zama na musamman.\n\nMisali:\nShigar: s = \"ababccc\"\nFitarwa: 5\nBayani: Wani yuwuwar hanya don raba kirtanin shine ['a', 'b', 'ab', 'c', 'cc'].\nRaba kirtanin kamar ['a', 'b', 'a', 'b', 'c', 'cc'] ba daidai bane, saboda duka 'a' da 'b' sun bayyana fiye da sau daya.\n\nLura:\n- Tsawon s yana tsakanin 1 da 16.\n- s yana dauke da ƙananan haruffan Turanci kawai.",
      "hi": "दी गई स्ट्रिंग s के लिए, स्ट्रिंग को विभाजित करें और अद्वितीय उपस्ट्रिंग्स की अधिकतम संख्या लौटाएं। विभाजित उपस्ट्रिंग्स को मूल स्ट्रिंग को पुनर्निर्मित करने में सक्षम होना चाहिए, और प्रत्येक उपस्ट्रिंग अद्वितीय होनी चाहिए।\n\nउदाहरण:\nइनपुट: s = \"ababccc\"\nआउटपुट: 5\nव्याख्या: स्ट्रिंग को विभाजित करने का एक संभावित तरीका है ['a', 'b', 'ab', 'c', 'cc']।\nस्ट्रिंग को ['a', 'b', 'a', 'b', 'c', 'cc'] के रूप में विभाजित करना मान्य नहीं है, क्योंकि 'a' और 'b' दोनों एक से अधिक बार दिखाई देते हैं।\n\nनोट:\n- s की लंबाई 1 और 16 के बीच है।\n- s में केवल छोटे अक्षरों वाले अंग्रेजी अक्षर होते हैं।",
      "hu": "Adott egy s string, ossza fel a stringet, és adja vissza az egyedi részstringek maximális számát.  \nA felosztott részstringeknek képesnek kell lenniük az eredeti string rekonstruálására, és minden részstringnek egyedinek kell lennie.\n\nPélda:  \nBemenet: s = \"ababccc\"  \nKimenet: 5  \nMagyarázat: A string felosztásának egyik lehetséges módja ['a', 'b', 'ab', 'c', 'cc'].  \nA string ['a', 'b', 'a', 'b', 'c', 'cc'] felosztása nem érvényes, mert az 'a' és 'b' is többször szerepel.\n\nMegjegyzés:  \n- Az s hossza 1 és 16 között van.  \n- s csak kisbetűs angol betűket tartalmaz."
    },
    "docstring_bertscore": {
      "sq": "0.9977743465805041",
      "hy": "0.9818469708468406",
      "bn": "0.9927096691248765",
      "bg": "0.99592907034069",
      "zh": "0.9840801722208158",
      "fr": "0.9909374888652832",
      "de": "0.9973155104003135",
      "ha": "0.9917989488278315",
      "hi": "0.9964320024654703",
      "hu": "0.9779415002949325"
    }
  },
  {
    "task_id": "Java/32",
    "prompt": {
      "en": "class Solution {\n    /**\n     * Given a list of logs representing folder operations,\n     * return the minimum number of steps required to return to the main folder.\n     *\n     * Example:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Explanation: Perform the \"../\" operation twice to return to the main folder.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "sq": "class Solution {\n    /**\n     * Duke pasur një listë të regjistrave që përfaqësojnë operacionet e dosjeve,\n     * kthe numrin minimal të hapave të nevojshëm për t'u kthyer në dosjen kryesore.\n     *\n     * Shembull:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Shpjegim: Kryeni operacionin \"../\" dy herë për t'u kthyer në dosjen kryesore.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "hy": "class Solution {\n    /**\n     * Տրված է թղթապանակի գործողությունները ներկայացնող գրանցամատյանների ցուցակը,\n     * վերադարձնել հիմնական թղթապանակին վերադառնալու համար անհրաժեշտ նվազագույն քայլերի քանակը:\n     *\n     * Օրինակ:\n     * Մուտք: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Ելք: 2\n     * Բացատրություն: Կատարեք \"../\" գործողությունը երկու անգամ՝ հիմնական թղթապանակին վերադառնալու համար:\n     *\n     * Մուտք: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Ելք: 3\n     *\n     * Մուտք: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Ելք: 0\n     */\n  public int minOperations(String[] logs) ",
      "bn": "class Solution {\n    /**\n     * ফোল্ডার অপারেশনগুলি উপস্থাপনকারী লগগুলির একটি তালিকা দেওয়া আছে,\n     * মূল ফোল্ডারে ফিরে আসার জন্য প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা ফেরত দিন।\n     *\n     * উদাহরণ:\n     * ইনপুট: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * আউটপুট: 2\n     * ব্যাখ্যা: মূল ফোল্ডারে ফিরে আসার জন্য \"../\" অপারেশনটি দুইবার সম্পাদন করুন।\n     *\n     * ইনপুট: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * আউটপুট: 3\n     *\n     * ইনপুট: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * আউটপুট: 0\n     */\n  public int minOperations(String[] logs) ",
      "bg": "class Solution {\n    /**\n     * Като се даде списък от дневници, представляващи операции с папки,\n     * върнете минималния брой стъпки, необходими за връщане към главната папка.\n     *\n     * Пример:\n     * Вход: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Изход: 2\n     * Обяснение: Изпълнете операцията \"../\" два пъти, за да се върнете към главната папка.\n     *\n     * Вход: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Изход: 3\n     *\n     * Вход: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Изход: 0\n     */\n  public int minOperations(String[] logs) ",
      "zh": "class Solution {\n    /**\n     * 给定一个表示文件夹操作的日志列表，\n     * 返回返回主文件夹所需的最小步骤数。\n     *\n     * 示例:\n     * 输入: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * 输出: 2\n     * 解释: 执行两次\"../\"操作以返回主文件夹。\n     *\n     * 输入: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * 输出: 3\n     *\n     * 输入: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * 输出: 0\n     */\n  public int minOperations(String[] logs) ",
      "fr": "class Solution {\n    /**\n     * Étant donné une liste de logs représentant des opérations de dossier,\n     * retournez le nombre minimum d'étapes nécessaires pour revenir au dossier principal.\n     *\n     * Exemple:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Explication: Effectuez l'opération \"../\" deux fois pour revenir au dossier principal.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "de": "class Solution {\n    /**\n     * Gegeben eine Liste von Protokollen, die Ordneroperationen darstellen,\n     * gib die minimale Anzahl von Schritten zurück, die erforderlich sind, um zum Hauptordner zurückzukehren.\n     *\n     * Beispiel:\n     * Eingabe: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Ausgabe: 2\n     * Erklärung: Führe die \"../\"-Operation zweimal aus, um zum Hauptordner zurückzukehren.\n     *\n     * Eingabe: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Ausgabe: 3\n     *\n     * Eingabe: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Ausgabe: 0\n     */\n  public int minOperations(String[] logs) ",
      "ha": "class Solution {\n    /**\n     * An ba da jerin rajistan ayyukan da ke wakiltar ayyukan manyan fayiloli,\n     * dawo da mafi ƙarancin adadin matakai da ake buƙata don komawa babban fayil.\n     *\n     * Misali:\n     * Input: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Output: 2\n     * Bayani: Yi aikin \"../\" sau biyu don komawa babban fayil.\n     *\n     * Input: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Output: 3\n     *\n     * Input: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Output: 0\n     */\n  public int minOperations(String[] logs) ",
      "hi": "class Solution {\n    /**\n     * दिए गए लॉग्स की सूची जो फ़ोल्डर संचालन का प्रतिनिधित्व करती है,\n     * मुख्य फ़ोल्डर पर लौटने के लिए आवश्यक न्यूनतम चरणों की संख्या लौटाएं।\n     *\n     * उदाहरण:\n     * इनपुट: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * आउटपुट: 2\n     * व्याख्या: मुख्य फ़ोल्डर पर लौटने के लिए \"../\" संचालन दो बार करें।\n     *\n     * इनपुट: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * आउटपुट: 3\n     *\n     * इनपुट: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * आउटपुट: 0\n     */\n  public int minOperations(String[] logs) ",
      "hu": "class Solution {\n    /**\n     * Adott egy lista naplókkal, amelyek mappaműveleteket képviselnek,\n     * adja vissza a minimális lépések számát, amelyek szükségesek a fő mappához való visszatéréshez.\n     *\n     * Példa:\n     * Bemenet: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n     * Kimenet: 2\n     * Magyarázat: Hajtsa végre a \"../\" műveletet kétszer a fő mappához való visszatéréshez.\n     *\n     * Bemenet: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n     * Kimenet: 3\n     *\n     * Bemenet: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n     * Kimenet: 0\n     */\n  public int minOperations(String[] logs) "
    },
    "prompt_bertscore": {
      "sq": "0.9963892969335478",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.999999801369619",
      "zh": "0.999999801369619",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9800513522022851",
      "hi": "0.9848941595222968",
      "hu": "0.999305588187902"
    },
    "canonical_solution": "  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }",
    "instruction": {
      "en": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки най-много 500 знака.",
      "zh": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\n提供一段简洁的中文自然语言描述（文档字符串），描述该Java代码，字数不超过500个字符。",
      "fr": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nKa bayar da takaitaccen bayanin yaren halitta (docstring) na lambar Java a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public int minOperations(String[] logs)\n  {\n    int depth = 0;\n    for (String log : logs) {\n      if (log.equals(\"../\")) {\n        if (depth > 0) {\n          depth--;\n        }\n      } else if (!log.equals(\"./\")) {\n        depth++;\n      }\n    }\n    return depth;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9242475370632005",
      "bn": "0.8821843757929664",
      "bg": "0.8459003654589423",
      "zh": "0.8944658908827345",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9004128844909192",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    Solution solution = new Solution();\n\n    // Test the function with different test cases\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"../\", \"d21/\", \"./\", \"../\" }\n    ) ==\n    1;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"d2/\", \"./\", \"d3/\", \"../\", \"d31/\", \"../\" }\n    ) ==\n    2;\n    assert solution.minOperations(\n      new String[] { \"d1/\", \"../\", \"../\", \"../\", \"d2/\" }\n    ) ==\n    1;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minOperations",
    "signature": "public int minOperations(String[] logs)",
    "docstring": {
      "en": "Given a list of logs representing folder operations,\nreturn the minimum number of steps required to return to the main folder.\n\nExample:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nExplanation: Perform the \"../\" operation twice to return to the main folder.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "sq": "Duke pasur një listë të regjistrimeve që përfaqësojnë operacione të dosjeve,\nkthe numrin minimal të hapave të nevojshëm për t'u kthyer në dosjen kryesore.\n\nShembull:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nShpjegim: Kryeni operacionin \"../\" dy herë për t'u kthyer në dosjen kryesore.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "hy": "Տրված է թղթապանակների գործողությունները ներկայացնող գրառումների ցուցակը, \nվերադարձնել նվազագույն քայլերի քանակը, որոնք անհրաժեշտ են հիմնական թղթապանակ վերադառնալու համար։\n\nՕրինակ:\nՄուտքագրում: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nԵլք: 2\nԲացատրություն: Կատարեք \"../\" գործողությունը երկու անգամ՝ հիմնական թղթապանակ վերադառնալու համար։\n\nՄուտքագրում: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nԵլք: 3\n\nՄուտքագրում: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nԵլք: 0",
      "bn": "একটি ফোল্ডার অপারেশনগুলিকে উপস্থাপনকারী লগের তালিকা দেওয়া হয়েছে, মূল ফোল্ডারে ফিরে আসার জন্য প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা ফেরত দিন।\n\nউদাহরণ:\nইনপুট: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nআউটপুট: 2\nব্যাখ্যা: মূল ফোল্ডারে ফিরে আসার জন্য \"../\" অপারেশনটি দুইবার সম্পাদন করুন।\n\nইনপুট: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nআউটপুট: 3\n\nইনপুট: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nআউটপুট: 0",
      "bg": "Даден е списък от логове, представляващи операции с папки, върнете минималния брой стъпки, необходими за връщане към главната папка.\n\nПример:\nВход: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nИзход: 2\nОбяснение: Изпълнете операцията \"../\" два пъти, за да се върнете към главната папка.\n\nВход: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nИзход: 3\n\nВход: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nИзход: 0",
      "zh": "给定一个表示文件夹操作的日志列表，返回返回到主文件夹所需的最小步骤数。\n\n示例：\n输入: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\n输出: 2\n解释: 执行两次\"../\"操作以返回到主文件夹。\n\n输入: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\n输出: 3\n\n输入: logs = [\"d1/\",\"../\",\"../\",\"../\"]\n输出: 0",
      "fr": "Étant donné une liste de journaux représentant des opérations de dossiers, renvoyez le nombre minimum d'étapes nécessaires pour revenir au dossier principal.\n\nExemple :\nEntrée : logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nSortie : 2\nExplication : Effectuez l'opération \"../\" deux fois pour revenir au dossier principal.\n\nEntrée : logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nSortie : 3\n\nEntrée : logs = [\"d1/\",\"../\",\"../\",\"../\"]\nSortie : 0",
      "de": "Angesichts einer Liste von Protokollen, die Ordneroperationen darstellen, geben Sie die minimale Anzahl von Schritten zurück, die erforderlich sind, um zum Hauptordner zurückzukehren.\n\nBeispiel:\nEingabe: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nAusgabe: 2\nErläuterung: Führen Sie die \"../\"-Operation zweimal aus, um zum Hauptordner zurückzukehren.\n\nEingabe: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nAusgabe: 3\n\nEingabe: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nAusgabe: 0",
      "ha": "An ba da jerin bayanan aiki da ke wakiltar ayyukan manyan fayiloli, dawo da mafi ƙarancin adadin matakai da ake buƙata don komawa babban fayil.\n\nMisali:\nInput: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nOutput: 2\nBayani: Yi aikin \"../\" sau biyu don komawa babban fayil.\n\nInput: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nOutput: 3\n\nInput: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nOutput: 0",
      "hi": "दिए गए लॉग्स की सूची जो फ़ोल्डर संचालन का प्रतिनिधित्व करती है, मुख्य फ़ोल्डर पर लौटने के लिए आवश्यक न्यूनतम चरणों की संख्या लौटाएं।\n\nउदाहरण:\nइनपुट: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nआउटपुट: 2\nव्याख्या: मुख्य फ़ोल्डर पर लौटने के लिए \"../\" ऑपरेशन दो बार करें।\n\nइनपुट: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nआउटपुट: 3\n\nइनपुट: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nआउटपुट: 0",
      "hu": "Adott egy naplólista, amely mappaműveleteket reprezentál, térj vissza a fő mappához való visszatéréshez szükséges minimális lépések számával.\n\nPélda:\nBemenet: logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]\nKimenet: 2\nMagyarázat: Hajtsd végre a \"../\" műveletet kétszer a fő mappához való visszatéréshez.\n\nBemenet: logs = [\"d1/\",\"d2/\",\"./\",\"d3/\",\"../\",\"d31/\"]\nKimenet: 3\n\nBemenet: logs = [\"d1/\",\"../\",\"../\",\"../\"]\nKimenet: 0"
    },
    "docstring_bertscore": {
      "sq": "0.9895297953548889",
      "hy": "1",
      "bn": "0.9859633868634076",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9808260106883212",
      "hi": "1",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/33",
    "prompt": {
      "en": "import java.util.*;\n\nclass Solution {\n    /**\n     * Return the lexicographically smallest string of length n and value k.\n     * The value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\n     * Example:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "sq": "import java.util.*;\n\nclass Solution {\n    /**\n     * Kthen vargun më të vogël leksikografik me gjatësi n dhe vlerë k.\n     * Vlera e një vargu është shuma e pozicioneve të karaktereve të tij në alfabet (duke filluar nga 1).\n     * Shembull:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "hy": "import java.util.*;\n\nclass Solution {\n    /**\n     * Վերադարձնել լեքսիկոգրաֆիկորեն ամենափոքր տողը, որը ունի n երկարություն և k արժեք:\n     * Տողի արժեքը նրա սիմվոլների դիրքերի գումարն է այբուբենում (սկսած 1-ից):\n     * Օրինակ:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "bn": "import java.util.*;\n\nclass Solution {\n    /**\n     * দৈর্ঘ্য n এবং মান k এর লেক্সিকোগ্রাফিক্যালি সবচেয়ে ছোট স্ট্রিং ফেরত দিন।\n     * একটি স্ট্রিং এর মান হল বর্ণমালায় এর অক্ষরগুলির অবস্থানের যোগফল (১ থেকে শুরু করে)।\n     * উদাহরণ:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "bg": "import java.util.*;\n\nclass Solution {\n    /**\n     * Връща лексикографски най-малкия низ с дължина n и стойност k.\n     * Стойността на един низ е сумата от позициите на неговите символи в азбуката (започвайки от 1).\n     * Пример:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "zh": "import java.util.*;\n\nclass Solution {\n    /**\n     * 返回长度为 n 且值为 k 的字典序最小字符串。\n     * 字符串的值是其字符在字母表中的位置之和（从 1 开始）。\n     * 示例：\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "fr": "import java.util.*;\n\nclass Solution {\n    /**\n     * Retourne la plus petite chaîne lexicographique de longueur n et de valeur k.\n     * La valeur d'une chaîne est la somme des positions de ses caractères dans l'alphabet (en commençant par 1).\n     * Exemple :\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "de": "import java.util.*;\n\nclass Solution {\n    /**\n     * Gibt die lexikographisch kleinste Zeichenkette der Länge n und des Wertes k zurück.\n     * Der Wert einer Zeichenkette ist die Summe der Positionen ihrer Zeichen im Alphabet (beginnend bei 1).\n     * Beispiel:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "ha": "import java.util.*;\n\nclass Solution {\n    /**\n     * Mayar da ƙaramin kirtani a cikin tsari na lexicographically mai tsawon n da ƙima k.\n     * Ƙimar kirtani ita ce jimillar matsayin haruffansa a cikin haruffa (fara daga 1).\n     * Misali:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "hi": "import java.util.*;\n\nclass Solution {\n    /**\n     * लंबाई n और मान k की वर्णानुक्रम में सबसे छोटी स्ट्रिंग लौटाएं।\n     * एक स्ट्रिंग का मान उसके वर्णों की वर्णमाला में स्थितियों के योग के बराबर होता है (1 से शुरू होकर)।\n     * उदाहरण:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) ",
      "hu": "import java.util.*;\n\nclass Solution {\n    /**\n     * Adja vissza a lexicoográfiailag legkisebb n hosszúságú és k értékű karakterláncot.\n     * Egy karakterlánc értéke a karaktereinek az ábécében elfoglalt helyének összege (1-től kezdődően).\n     * Példa:\n     * >>> getSmallestString(3, 27)\n     * \"aay\"\n     * >>> getSmallestString(5, 73)\n     * \"aaszz\"\n     */\n    public String getSmallestString(int n, int k) "
    },
    "prompt_bertscore": {
      "sq": "0.9926929841728696",
      "hy": "0.994084787252781",
      "bn": "0.999999801369619",
      "bg": "0.9966701602923311",
      "zh": "0.9898178094073896",
      "fr": "0.9950666172262365",
      "de": "0.9964800710176808",
      "ha": "0.9799248246495659",
      "hi": "0.9896189803959736",
      "hu": "0.999999801369619"
    },
    "canonical_solution": "    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }",
    "instruction": {
      "en": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nՏվեք Java կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nBayar da taƙaitaccen bayanin harshen halitta (docstring) na lambar Java cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public String getSmallestString(int n, int k)\n    {\n        char[] res = new char[n];\n        Arrays.fill(res, 'a');\n        k -= n;\n        while (k > 0) {\n            res[--n] += Math.min(25, k);\n            k -= Math.min(25, k);\n        }\n        return String.valueOf(res);\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.9097683754376624",
      "bg": "0.8400592418438494",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test the function with different test cases\n        assert solution.getSmallestString(3, 27).equals(\"aay\");\n        assert solution.getSmallestString(5, 73).equals(\"aaszz\");\n        assert solution.getSmallestString(3, 30).equals(\"acz\");\n        System.out.println(\"All tests passed\");\n    }\n}",
    "entry_point": "getSmallestString",
    "signature": "public String getSmallestString(int n, int k)",
    "docstring": {
      "en": "Return the lexicographically smallest string of length n and value k.\nThe value of a string is the sum of the positions of its characters in the alphabet (starting from 1).\nExample:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "sq": "Kthe vargun leksikografikisht më të vogël me gjatësi n dhe vlerë k.  \nVlera e një vargu është shuma e pozicioneve të karaktereve të tij në alfabet (duke filluar nga 1).  \nShembull:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "hy": "Վերադարձնել լեքսիկոգրաֆիկորեն ամենափոքր տողը, որի երկարությունը n է և արժեքը՝ k: Տողի արժեքը նրա նիշերի դիրքերի գումարն է այբուբենում (սկսած 1-ից): Օրինակ:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "bn": "লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম স্ট্রিং ফেরত দিন যার দৈর্ঘ্য n এবং মান k।\nএকটি স্ট্রিং এর মান হল বর্ণমালায় তার অক্ষরগুলির অবস্থানের যোগফল (১ থেকে শুরু করে)।\nউদাহরণ:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "bg": "Върнете лексикографски най-малкия низ с дължина n и стойност k. Стойността на низа е сумата от позициите на неговите символи в азбуката (започвайки от 1).\nПример:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "zh": "返回长度为 n 且值为 k 的字典序最小字符串。  \n字符串的值是其字符在字母表中的位置之和（从 1 开始）。  \n示例：  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"  ",
      "fr": "Retourner la plus petite chaîne lexicographique de longueur n et de valeur k.  \nLa valeur d'une chaîne est la somme des positions de ses caractères dans l'alphabet (en commençant par 1).  \nExemple :  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "de": "Geben Sie die lexikografisch kleinste Zeichenkette der Länge n und des Wertes k zurück. Der Wert einer Zeichenkette ist die Summe der Positionen ihrer Zeichen im Alphabet (beginnend bei 1). Beispiel:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "ha": "Mayar da ƙaramar kalma ta lexicographically mai tsawon n da ƙimar k. \nƘimar kalma ita ce jimillar matsayin haruffanta a cikin haruffa (farawa daga 1).\n\nMisali:\n>>> getSmallestString(3, 27)\n\"aay\"\n>>> getSmallestString(5, 73)\n\"aaszz\"",
      "hi": "लंबाई n और मान k के लिए शब्दकोशानुक्रम में सबसे छोटा स्ट्रिंग लौटाएं।  \nएक स्ट्रिंग का मान वर्णमाला में उसके वर्णों की स्थितियों के योग के बराबर होता है (1 से शुरू होकर)।  \nउदाहरण:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\"",
      "hu": "Adja vissza a lexisztozikusan legkisebb n hosszúságú és k értékű karakterláncot.  \nEgy karakterlánc értéke a karaktereinek az ábécében elfoglalt pozícióinak összege (1-től kezdve).  \nPélda:  \n>>> getSmallestString(3, 27)  \n\"aay\"  \n>>> getSmallestString(5, 73)  \n\"aaszz\""
    },
    "docstring_bertscore": {
      "sq": "0.9963030913481786",
      "hy": "0.9887871163601996",
      "bn": "0.9927360869655542",
      "bg": "0.9903755635173356",
      "zh": "0.97348046056727",
      "fr": "0.9924885935107847",
      "de": "0.9966701602923311",
      "ha": "0.9999996027392379",
      "hi": "0.9359518322656813",
      "hu": "0.9999996027392379"
    }
  },
  {
    "task_id": "Java/34",
    "prompt": {
      "en": "public class Solution {\n\n  // Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  // @param n The number of passengers.\n  // @return The probability that the last passenger will sit in their own seat.\n\n  // Example 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // Example 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // Example 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // Example 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // Example 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // Example 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // Function to calculate the probability that the last passenger will sit in their own seat\n  public static double calculateProbability(int n) ",
      "sq": "public class Solution {\n\n  // Duke pasur parasysh numrin e pasagjerëve n, llogaritni probabilitetin që pasagjeri i fundit do të ulet në vendin e tij.\n  // @param n Numri i pasagjerëve.\n  // @return Probabiliteti që pasagjeri i fundit do të ulet në vendin e tij.\n\n  // Shembull 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // Shembull 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // Shembull 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // Shembull 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // Shembull 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // Shembull 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // Funksion për të llogaritur probabilitetin që pasagjeri i fundit do të ulet në vendin e tij\n  public static double calculateProbability(int n) ",
      "hy": "public class Solution {\n\n  // Տրված է ուղևորների քանակը n, հաշվարկել հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստարանին։\n  // @param n Ուղևորների քանակը։\n  // @return Հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստարանին։\n\n  // Օրինակ 1:\n  // Մուտքագրում: n = 1\n  // Ելք: 1.00000\n\n  // Օրինակ 2:\n  // Մուտքագրում: n = 2\n  // Ելք: 0.50000\n\n  // Օրինակ 3:\n  // Մուտքագրում: n = 3\n  // Ելք: 0.50000\n\n  // Օրինակ 4:\n  // Մուտքագրում: n = 4\n  // Ելք: 0.50000\n\n  // Օրինակ 5:\n  // Մուտքագրում: n = 5\n  // Ելք: 0.50000\n\n  // Օրինակ 6:\n  // Մուտքագրում: n = 100000\n  // Ելք: 0.50000\n\n  // Ֆունկցիա՝ հաշվարկելու հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստարանին\n  public static double calculateProbability(int n) ",
      "bn": "public class Solution {\n\n  // যাত্রী সংখ্যা n দেওয়া আছে, শেষ যাত্রী তাদের নিজের আসনে বসার সম্ভাবনা গণনা করুন।\n  // @param n যাত্রীদের সংখ্যা।\n  // @return শেষ যাত্রী তাদের নিজের আসনে বসার সম্ভাবনা।\n\n  // উদাহরণ 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // উদাহরণ 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // উদাহরণ 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // উদাহরণ 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // উদাহরণ 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // উদাহরণ 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // শেষ যাত্রী তাদের নিজের আসনে বসার সম্ভাবনা গণনা করার ফাংশন\n  public static double calculateProbability(int n) ",
      "bg": "public class Solution {\n\n  // Даден е броят на пътниците n, изчислете вероятността последният пътник да седне на своето място.\n  // @param n Броят на пътниците.\n  // @return Вероятността последният пътник да седне на своето място.\n\n  // Пример 1:\n  // Вход: n = 1\n  // Изход: 1.00000\n\n  // Пример 2:\n  // Вход: n = 2\n  // Изход: 0.50000\n\n  // Пример 3:\n  // Вход: n = 3\n  // Изход: 0.50000\n\n  // Пример 4:\n  // Вход: n = 4\n  // Изход: 0.50000\n\n  // Пример 5:\n  // Вход: n = 5\n  // Изход: 0.50000\n\n  // Пример 6:\n  // Вход: n = 100000\n  // Изход: 0.50000\n\n  // Функция за изчисляване на вероятността последният пътник да седне на своето място\n  public static double calculateProbability(int n) ",
      "zh": "public class Solution {\n\n  // 给定乘客数量 n，计算最后一位乘客坐在自己座位上的概率。\n  // @param n 乘客数量。\n  // @return 最后一位乘客坐在自己座位上的概率。\n\n  // 示例 1:\n  // 输入: n = 1\n  // 输出: 1.00000\n\n  // 示例 2:\n  // 输入: n = 2\n  // 输出: 0.50000\n\n  // 示例 3:\n  // 输入: n = 3\n  // 输出: 0.50000\n\n  // 示例 4:\n  // 输入: n = 4\n  // 输出: 0.50000\n\n  // 示例 5:\n  // 输入: n = 5\n  // 输出: 0.50000\n\n  // 示例 6:\n  // 输入: n = 100000\n  // 输出: 0.50000\n\n  // 计算最后一位乘客坐在自己座位上的概率的函数\n  public static double calculateProbability(int n) ",
      "fr": "public class Solution {\n\n  // Étant donné le nombre de passagers n, calculez la probabilité que le dernier passager s'assoit à sa propre place.\n  // @param n Le nombre de passagers.\n  // @return La probabilité que le dernier passager s'assoit à sa propre place.\n\n  // Exemple 1:\n  // Entrée: n = 1\n  // Sortie: 1.00000\n\n  // Exemple 2:\n  // Entrée: n = 2\n  // Sortie: 0.50000\n\n  // Exemple 3:\n  // Entrée: n = 3\n  // Sortie: 0.50000\n\n  // Exemple 4:\n  // Entrée: n = 4\n  // Sortie: 0.50000\n\n  // Exemple 5:\n  // Entrée: n = 5\n  // Sortie: 0.50000\n\n  // Exemple 6:\n  // Entrée: n = 100000\n  // Sortie: 0.50000\n\n  // Fonction pour calculer la probabilité que le dernier passager s'assoit à sa propre place\n  public static double calculateProbability(int n) ",
      "de": "public class Solution {\n\n  // Gegeben die Anzahl der Passagiere n, berechne die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n  // @param n Die Anzahl der Passagiere.\n  // @return Die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n\n  // Beispiel 1:\n  // Eingabe: n = 1\n  // Ausgabe: 1.00000\n\n  // Beispiel 2:\n  // Eingabe: n = 2\n  // Ausgabe: 0.50000\n\n  // Beispiel 3:\n  // Eingabe: n = 3\n  // Ausgabe: 0.50000\n\n  // Beispiel 4:\n  // Eingabe: n = 4\n  // Ausgabe: 0.50000\n\n  // Beispiel 5:\n  // Eingabe: n = 5\n  // Ausgabe: 0.50000\n\n  // Beispiel 6:\n  // Eingabe: n = 100000\n  // Ausgabe: 0.50000\n\n  // Funktion zur Berechnung der Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt\n  public static double calculateProbability(int n) ",
      "ha": "public class Solution {\n\n  // An ba da yawan fasinjoji n, lissafa yiwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa.\n  // @param n Yawan fasinjoji.\n  // @return Yiwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa.\n\n  // Misali 1:\n  // Input: n = 1\n  // Output: 1.00000\n\n  // Misali 2:\n  // Input: n = 2\n  // Output: 0.50000\n\n  // Misali 3:\n  // Input: n = 3\n  // Output: 0.50000\n\n  // Misali 4:\n  // Input: n = 4\n  // Output: 0.50000\n\n  // Misali 5:\n  // Input: n = 5\n  // Output: 0.50000\n\n  // Misali 6:\n  // Input: n = 100000\n  // Output: 0.50000\n\n  // Aiki don lissafa yiwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa\n  public static double calculateProbability(int n) ",
      "hi": "public class Solution {\n\n  // दिए गए यात्रियों की संख्या n के आधार पर यह गणना करें कि अंतिम यात्री के अपनी सीट पर बैठने की संभावना क्या है।\n  // @param n यात्रियों की संख्या।\n  // @return संभावना कि अंतिम यात्री अपनी सीट पर बैठेगा।\n\n  // उदाहरण 1:\n  // इनपुट: n = 1\n  // आउटपुट: 1.00000\n\n  // उदाहरण 2:\n  // इनपुट: n = 2\n  // आउटपुट: 0.50000\n\n  // उदाहरण 3:\n  // इनपुट: n = 3\n  // आउटपुट: 0.50000\n\n  // उदाहरण 4:\n  // इनपुट: n = 4\n  // आउटपुट: 0.50000\n\n  // उदाहरण 5:\n  // इनपुट: n = 5\n  // आउटपुट: 0.50000\n\n  // उदाहरण 6:\n  // इनपुट: n = 100000\n  // आउटपुट: 0.50000\n\n  // यह गणना करने के लिए फ़ंक्शन कि अंतिम यात्री अपनी सीट पर बैठेगा\n  public static double calculateProbability(int n) ",
      "hu": "public class Solution {\n\n  // Adott az utasok száma n, számítsuk ki annak valószínűségét, hogy az utolsó utas a saját ülésébe fog ülni.\n  // @param n Az utasok száma.\n  // @return Annak valószínűsége, hogy az utolsó utas a saját ülésébe fog ülni.\n\n  // 1. példa:\n  // Bemenet: n = 1\n  // Kimenet: 1.00000\n\n  // 2. példa:\n  // Bemenet: n = 2\n  // Kimenet: 0.50000\n\n  // 3. példa:\n  // Bemenet: n = 3\n  // Kimenet: 0.50000\n\n  // 4. példa:\n  // Bemenet: n = 4\n  // Kimenet: 0.50000\n\n  // 5. példa:\n  // Bemenet: n = 5\n  // Kimenet: 0.50000\n\n  // 6. példa:\n  // Bemenet: n = 100000\n  // Kimenet: 0.50000\n\n  // Függvény, amely kiszámítja annak valószínűségét, hogy az utolsó utas a saját ülésébe fog ülni\n  public static double calculateProbability(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9731125971015934",
      "hy": "0.9937981636129477",
      "bn": "0.9740227215074952",
      "bg": "1",
      "zh": "0.9769030606628821",
      "fr": "0.9885426023611456",
      "de": "0.9885426023611456",
      "ha": "0.9731125971015934",
      "hi": "0.9701311550822598",
      "hu": "0.997881805616644"
    },
    "canonical_solution": "  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }",
    "instruction": {
      "en": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\n请用中文为以下 Java 代码提供简洁的自然语言描述（文档注释），字数不超过 500 个字符。",
      "fr": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static double calculateProbability(int n)\n  {\n    if (n == 1) return 1.0;\n    return 0.5;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9242475370632005",
      "bn": "0.8954556660714315",
      "bg": "0.8400592418438494",
      "zh": "0.8312340940144693",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8773228972171375",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "public static void main(String[] args) {\n    assert Math.abs(calculateProbability(6) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(10) - 0.50000) < 0.00001;\n    assert Math.abs(calculateProbability(50) - 0.50000) < 0.00001;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateProbability",
    "signature": "public static double calculateProbability(int n)",
    "docstring": {
      "en": "Given the number of passengers n, calculate the probability that the last passenger will sit in their own seat.\n  @param n The number of passengers.\n  @return The probability that the last passenger will sit in their own seat.\n\n  Example 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Example 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Example 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Example 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Example 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Example 6:\n  Input: n = 100000\n  Output: 0.50000",
      "sq": "Duke pasur parasysh numrin e pasagjerëve n, llogaritni probabilitetin që pasagjeri i fundit të ulet në vendin e tij.\n\n@param n Numri i pasagjerëve.\n@return Probabiliteti që pasagjeri i fundit të ulet në vendin e tij.\n\nShembulli 1:\nInput: n = 1\nOutput: 1.00000\n\nShembulli 2:\nInput: n = 2\nOutput: 0.50000\n\nShembulli 3:\nInput: n = 3\nOutput: 0.50000\n\nShembulli 4:\nInput: n = 4\nOutput: 0.50000\n\nShembulli 5:\nInput: n = 5\nOutput: 0.50000\n\nShembulli 6:\nInput: n = 100000\nOutput: 0.50000",
      "hy": "Տրված է ուղևորների քանակը n, հաշվարկել հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստատեղում:\n  @param n Ուղևորների քանակը:\n  @return Հավանականությունը, որ վերջին ուղևորը կնստի իր սեփական նստատեղում:\n\n  Օրինակ 1:\n  Մուտք: n = 1\n  Ելք: 1.00000\n\n  Օրինակ 2:\n  Մուտք: n = 2\n  Ելք: 0.50000\n\n  Օրինակ 3:\n  Մուտք: n = 3\n  Ելք: 0.50000\n\n  Օրինակ 4:\n  Մուտք: n = 4\n  Ելք: 0.50000\n\n  Օրինակ 5:\n  Մուտք: n = 5\n  Ելք: 0.50000\n\n  Օրինակ 6:\n  Մուտք: n = 100000\n  Ելք: 0.50000",
      "bn": "যদি যাত্রীদের সংখ্যা n দেওয়া হয়, তাহলে শেষ যাত্রী তাদের নিজের আসনে বসার সম্ভাবনা গণনা করুন।\n  @param n যাত্রীদের সংখ্যা।\n  @return শেষ যাত্রী তাদের নিজের আসনে বসার সম্ভাবনা।\n\n  উদাহরণ 1:\n  Input: n = 1\n  Output: 1.00000\n\n  উদাহরণ 2:\n  Input: n = 2\n  Output: 0.50000\n\n  উদাহরণ 3:\n  Input: n = 3\n  Output: 0.50000\n\n  উদাহরণ 4:\n  Input: n = 4\n  Output: 0.50000\n\n  উদাহরণ 5:\n  Input: n = 5\n  Output: 0.50000\n\n  উদাহরণ 6:\n  Input: n = 100000\n  Output: 0.50000",
      "bg": "Даден е броят на пътниците n, изчислете вероятността последният пътник да седне на своето място.\n  @param n Броят на пътниците.\n  @return Вероятността последният пътник да седне на своето място.\n\n  Пример 1:\n  Вход: n = 1\n  Изход: 1.00000\n\n  Пример 2:\n  Вход: n = 2\n  Изход: 0.50000\n\n  Пример 3:\n  Вход: n = 3\n  Изход: 0.50000\n\n  Пример 4:\n  Вход: n = 4\n  Изход: 0.50000\n\n  Пример 5:\n  Вход: n = 5\n  Изход: 0.50000\n\n  Пример 6:\n  Вход: n = 100000\n  Изход: 0.50000",
      "zh": "给定乘客数量 n，计算最后一位乘客坐在自己座位上的概率。\n  @param n 乘客的数量。\n  @return 最后一位乘客坐在自己座位上的概率。\n\n  示例 1:\n  输入: n = 1\n  输出: 1.00000\n\n  示例 2:\n  输入: n = 2\n  输出: 0.50000\n\n  示例 3:\n  输入: n = 3\n  输出: 0.50000\n\n  示例 4:\n  输入: n = 4\n  输出: 0.50000\n\n  示例 5:\n  输入: n = 5\n  输出: 0.50000\n\n  示例 6:\n  输入: n = 100000\n  输出: 0.50000",
      "fr": "Étant donné le nombre de passagers n, calculez la probabilité que le dernier passager s'assoie à sa propre place.\n  @param n Le nombre de passagers.\n  @return La probabilité que le dernier passager s'assoie à sa propre place.\n\n  Exemple 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Exemple 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Exemple 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Exemple 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Exemple 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Exemple 6:\n  Input: n = 100000\n  Output: 0.50000",
      "de": "Gegeben die Anzahl der Passagiere n, berechne die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n@param n Die Anzahl der Passagiere.  \n@return Die Wahrscheinlichkeit, dass der letzte Passagier auf seinem eigenen Sitzplatz sitzt.\n\nExample 1:  \nInput: n = 1  \nOutput: 1.00000\n\nExample 2:  \nInput: n = 2  \nOutput: 0.50000\n\nExample 3:  \nInput: n = 3  \nOutput: 0.50000\n\nExample 4:  \nInput: n = 4  \nOutput: 0.50000\n\nExample 5:  \nInput: n = 5  \nOutput: 0.50000\n\nExample 6:  \nInput: n = 100000  \nOutput: 0.50000",
      "ha": "An ba da yawan fasinjoji n, ƙididdige yuwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa.\n@param n Yawan fasinjoji.  \n@return Yiwuwar cewa fasinja na ƙarshe zai zauna a kujerarsa.\n\nExample 1:  \nInput: n = 1  \nOutput: 1.00000\n\nExample 2:  \nInput: n = 2  \nOutput: 0.50000\n\nExample 3:  \nInput: n = 3  \nOutput: 0.50000\n\nExample 4:  \nInput: n = 4  \nOutput: 0.50000\n\nExample 5:  \nInput: n = 5  \nOutput: 0.50000\n\nExample 6:  \nInput: n = 100000  \nOutput: 0.50000",
      "hi": "दी गई संख्या n यात्रियों की, यह गणना करें कि अंतिम यात्री अपने स्वयं के सीट पर बैठेगा, इसकी संभावना कितनी है।\n  @param n यात्रियों की संख्या।\n  @return यह संभावना कि अंतिम यात्री अपने स्वयं के सीट पर बैठेगा।\n\n  उदाहरण 1:\n  इनपुट: n = 1\n  आउटपुट: 1.00000\n\n  उदाहरण 2:\n  इनपुट: n = 2\n  आउटपुट: 0.50000\n\n  उदाहरण 3:\n  इनपुट: n = 3\n  आउटपुट: 0.50000\n\n  उदाहरण 4:\n  इनपुट: n = 4\n  आउटपुट: 0.50000\n\n  उदाहरण 5:\n  इनपुट: n = 5\n  आउटपुट: 0.50000\n\n  उदाहरण 6:\n  इनपुट: n = 100000\n  आउटपुट: 0.50000",
      "hu": "Adott az utasok száma n, számítsa ki annak valószínűségét, hogy az utolsó utas a saját ülésére fog ülni.\n  @param n Az utasok száma.\n  @return Annak valószínűsége, hogy az utolsó utas a saját ülésére fog ülni.\n\n  Példa 1:\n  Input: n = 1\n  Output: 1.00000\n\n  Példa 2:\n  Input: n = 2\n  Output: 0.50000\n\n  Példa 3:\n  Input: n = 3\n  Output: 0.50000\n\n  Példa 4:\n  Input: n = 4\n  Output: 0.50000\n\n  Példa 5:\n  Input: n = 5\n  Output: 0.50000\n\n  Példa 6:\n  Input: n = 100000\n  Output: 0.50000"
    },
    "docstring_bertscore": {
      "sq": "0.9536209978106398",
      "hy": "0.9833406713122229",
      "bn": "0.9618139051371859",
      "bg": "1",
      "zh": "0.9862013460598874",
      "fr": "0.9862013460598874",
      "de": "1",
      "ha": "0.9694502501360721",
      "hi": "0.9850218788573022",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/35",
    "prompt": {
      "en": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n   *\n   * @param nums An integer array where every element appears three times except for one.\n   * @return The element that appears only once.\n   *\n   * Example:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Example:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "sq": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Duke pasur një varg të plotë nums ku çdo element shfaqet tre herë përveç njërit, i cili shfaqet vetëm një herë. Gjeni dhe ktheni elementin që shfaqet vetëm një herë.\n   *\n   * @param nums Një varg i plotë ku çdo element shfaqet tre herë përveç njërit.\n   * @return Elementi që shfaqet vetëm një herë.\n   *\n   * Shembull:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Shembull:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "hy": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Տրված է ամբողջ թվերի զանգված nums, որտեղ յուրաքանչյուր տարր հանդիպում է երեք անգամ, բացի մեկից, որը հանդիպում է միայն մեկ անգամ։ Գտնել և վերադարձնել տարրը, որը հանդիպում է միայն մեկ անգամ։\n   *\n   * @param nums Ամբողջ թվերի զանգված, որտեղ յուրաքանչյուր տարր հանդիպում է երեք անգամ, բացի մեկից։\n   * @return Տարրը, որը հանդիպում է միայն մեկ անգամ։\n   *\n   * Օրինակ:\n   * singleNumber(new int[]{2,2,3,2})\n   * Արդյունք: 3\n   *\n   * Օրինակ:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Արդյունք: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "bn": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যার অ্যারে nums দেওয়া হয়েছে যেখানে প্রতিটি উপাদান তিনবার প্রদর্শিত হয় শুধুমাত্র একটি ছাড়া, যা শুধুমাত্র একবার প্রদর্শিত হয়। যে উপাদানটি শুধুমাত্র একবার প্রদর্শিত হয় তা খুঁজে বের করুন এবং ফেরত দিন।\n   *\n   * @param nums একটি পূর্ণসংখ্যার অ্যারে যেখানে প্রতিটি উপাদান তিনবার প্রদর্শিত হয় শুধুমাত্র একটি ছাড়া।\n   * @return যে উপাদানটি শুধুমাত্র একবার প্রদর্শিত হয়।\n   *\n   * উদাহরণ:\n   * singleNumber(new int[]{2,2,3,2})\n   * আউটপুট: 3\n   *\n   * উদাহরণ:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * আউটপুট: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "bg": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Даден е масив от цели числа nums, където всеки елемент се появява три пъти, с изключение на един, който се появява само веднъж. Намерете и върнете елемента, който се появява само веднъж.\n   *\n   * @param nums Масив от цели числа, където всеки елемент се появява три пъти, с изключение на един.\n   * @return Елементът, който се появява само веднъж.\n   *\n   * Пример:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Пример:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "zh": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * 给定一个整数数组 nums，其中每个元素出现三次，只有一个元素出现一次。找出并返回只出现一次的元素。\n   *\n   * @param nums 一个整数数组，其中每个元素出现三次，只有一个元素出现一次。\n   * @return 只出现一次的元素。\n   *\n   * 示例:\n   * singleNumber(new int[]{2,2,3,2})\n   * 输出: 3\n   *\n   * 示例:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * 输出: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "fr": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Étant donné un tableau d'entiers nums où chaque élément apparaît trois fois sauf un, qui apparaît une seule fois. Trouvez et renvoyez l'élément qui apparaît une seule fois.\n   *\n   * @param nums Un tableau d'entiers où chaque élément apparaît trois fois sauf un.\n   * @return L'élément qui apparaît une seule fois.\n   *\n   * Exemple:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Exemple:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "de": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Gegeben ein Integer-Array nums, bei dem jedes Element dreimal vorkommt, außer einem, das nur einmal vorkommt. Finde und gib das Element zurück, das nur einmal vorkommt.\n   *\n   * @param nums Ein Integer-Array, bei dem jedes Element dreimal vorkommt, außer einem.\n   * @return Das Element, das nur einmal vorkommt.\n   *\n   * Beispiel:\n   * singleNumber(new int[]{2,2,3,2})\n   * Ausgabe: 3\n   *\n   * Beispiel:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Ausgabe: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "ha": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * An ba da wani jerin lambobi nums inda kowanne abu ya bayyana sau uku sai dai ɗaya, wanda ya bayyana sau ɗaya kawai. Nemo kuma dawo da abin da ya bayyana sau ɗaya kawai.\n   *\n   * @param nums Wani jerin lambobi inda kowanne abu ya bayyana sau uku sai dai ɗaya.\n   * @return Abin da ya bayyana sau ɗaya kawai.\n   *\n   * Misali:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * Misali:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "hi": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * दिए गए पूर्णांक सरणी nums में हर तत्व तीन बार प्रकट होता है सिवाय एक के, जो केवल एक बार प्रकट होता है। उस तत्व को खोजें और लौटाएं जो केवल एक बार प्रकट होता है।\n   *\n   * @param nums एक पूर्णांक सरणी जहां हर तत्व तीन बार प्रकट होता है सिवाय एक के।\n   * @return वह तत्व जो केवल एक बार प्रकट होता है।\n   *\n   * उदाहरण:\n   * singleNumber(new int[]{2,2,3,2})\n   * Output: 3\n   *\n   * उदाहरण:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Output: 99\n   */\n  public static int singleNumber(int[] nums) ",
      "hu": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n\n  /**\n   * Adott egy egész számokat tartalmazó tömb nums, ahol minden elem háromszor jelenik meg, kivéve egyet, amely csak egyszer. Találja meg és adja vissza azt az elemet, amely csak egyszer jelenik meg.\n   *\n   * @param nums Egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet.\n   * @return Az az elem, amely csak egyszer jelenik meg.\n   *\n   * Példa:\n   * singleNumber(new int[]{2,2,3,2})\n   * Kimenet: 3\n   *\n   * Példa:\n   * singleNumber(new int[]{0,1,0,1,0,1,99})\n   * Kimenet: 99\n   */\n  public static int singleNumber(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "0.996282036527789",
      "hy": "0.9747816881934296",
      "bn": "0.996282036527789",
      "bg": "0.9791420223179075",
      "zh": "0.9803193045863012",
      "fr": "0.9776884451894942",
      "de": "0.9929148543084856",
      "ha": "0.9725212744572526",
      "hi": "0.9893403019713817",
      "hu": "0.9797955162715122"
    },
    "canonical_solution": "  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }",
    "instruction": {
      "en": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nՀրահանգի բովանդակության միակ բնական լեզուն թարգմանեք հայերեն:\n\nՏվեք Java կոդի հակիրճ բնութագրություն (docstring) հայերեն՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\n请用不超过500个字符的中文为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nजावा कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static int singleNumber(int[] nums)\n  {\n    Map<Integer, Integer> frequencyMap = new HashMap<>();\n\n    for (int num : nums) {\n      frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n    }\n\n    for (int num : frequencyMap.keySet()) {\n      if (frequencyMap.get(num) == 1) {\n        return num;\n      }\n    }\n\n    // this part of the code should never be reached if the input array meets the problem statement\n    throw new IllegalArgumentException(\"No element appears only once.\");\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9133739141142077",
      "bn": "0.9137427707317894",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.956912899115531",
      "hi": "0.952466359405684",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert singleNumber(new int[] { 6, 1, 6, 6 }) == 1 : \"Test case 1 failed\";\n    assert singleNumber(new int[] { 22, 22, 22, 11, 11, 11, 55 }) ==\n    55 : \"Test case 2 failed\";\n    assert singleNumber(new int[] { -1, 3, -1, 3, -1, 3, 99 }) ==\n    99 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "singleNumber",
    "signature": "public static int singleNumber(int[] nums)",
    "docstring": {
      "en": "Given an integer array nums where every element appears three times except for one, which appears only once. Find and return the element that appears only once.\n\n @param nums An integer array where every element appears three times except for one.\n @return The element that appears only once.\n\n Example:\n singleNumber(new int[]{2,2,3,2})\n Output: 3\n\n Example:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Output: 99",
      "sq": "Duke pasur një varg të plotë nums ku çdo element shfaqet tre herë përveç njërit, i cili shfaqet vetëm një herë. Gjeni dhe ktheni elementin që shfaqet vetëm një herë.\n\n@param nums Një varg të plotë ku çdo element shfaqet tre herë përveç njërit.\n@return Elementi që shfaqet vetëm një herë.\n\nShembull:\nsingleNumber(new int[]{2,2,3,2})\nOutput: 3\n\nShembull:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nOutput: 99",
      "hy": "Տրված է ամբողջ թվերի զանգված nums, որտեղ յուրաքանչյուր տարր հանդիպում է երեք անգամ, բացի մեկից, որը հանդիպում է միայն մեկ անգամ։ Գտեք և վերադարձեք տարրը, որը հանդիպում է միայն մեկ անգամ։\n\n @param nums Ամբողջ թվերի զանգված, որտեղ յուրաքանչյուր տարր հանդիպում է երեք անգամ, բացի մեկից։\n @return Տարրը, որը հանդիպում է միայն մեկ անգամ։\n\n Օրինակ:\n singleNumber(new int[]{2,2,3,2})\n Արդյունք: 3\n\n Օրինակ:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Արդյունք: 99",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে `nums` দেওয়া আছে যেখানে প্রতিটি উপাদান তিনবার করে প্রদর্শিত হয়, শুধুমাত্র একটি উপাদান যা একবারই প্রদর্শিত হয়। যে উপাদানটি শুধুমাত্র একবার প্রদর্শিত হয় তা খুঁজে বের করুন এবং ফেরত দিন।\n\n@param nums একটি পূর্ণসংখ্যার অ্যারে যেখানে প্রতিটি উপাদান তিনবার করে প্রদর্শিত হয়, শুধুমাত্র একটি উপাদান যা একবারই প্রদর্শিত হয়।\n@return যে উপাদানটি শুধুমাত্র একবার প্রদর্শিত হয়।\n\nউদাহরণ:\nsingleNumber(new int[]{2,2,3,2})\nআউটপুট: 3\n\nউদাহরণ:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nআউটপুট: 99",
      "bg": "Даден е масив от цели числа nums, където всеки елемент се появява три пъти, с изключение на един, който се появява само веднъж. Намерете и върнете елемента, който се появява само веднъж.\n\n @param nums Масив от цели числа, където всеки елемент се появява три пъти, с изключение на един.\n @return Елементът, който се появява само веднъж.\n\n Пример:\n singleNumber(new int[]{2,2,3,2})\n Изход: 3\n\n Пример:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Изход: 99",
      "zh": "给定一个整数数组 nums，其中每个元素出现三次，只有一个元素出现一次。找到并返回只出现一次的元素。\n\n@param nums 一个整数数组，其中每个元素出现三次，只有一个元素出现一次。\n@return 只出现一次的元素。\n\n例子：\nsingleNumber(new int[]{2,2,3,2})\n输出: 3\n\n例子：\nsingleNumber(new int[]{0,1,0,1,0,1,99})\n输出: 99",
      "fr": "Étant donné un tableau d'entiers nums où chaque élément apparaît trois fois sauf un, qui apparaît une seule fois. Trouver et retourner l'élément qui apparaît une seule fois.\n\n @param nums Un tableau d'entiers où chaque élément apparaît trois fois sauf un.\n @return L'élément qui apparaît une seule fois.\n\n Exemple:\n singleNumber(new int[]{2,2,3,2})\n Sortie: 3\n\n Exemple:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Sortie: 99",
      "de": "Gegeben ein ganzzahliges Array nums, in dem jedes Element dreimal vorkommt, außer einem, das nur einmal vorkommt. Finde und gib das Element zurück, das nur einmal vorkommt.\n\n@param nums Ein ganzzahliges Array, in dem jedes Element dreimal vorkommt, außer einem.\n@return Das Element, das nur einmal vorkommt.\n\nBeispiel:\nsingleNumber(new int[]{2,2,3,2})\nOutput: 3\n\nBeispiel:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nOutput: 99",
      "ha": "An ba da wani jerin lambobi na integer nums inda kowace ƙungiya ta bayyana sau uku sai ɗaya, wanda ya bayyana sau ɗaya kawai. Nemo kuma dawo da abin da ya bayyana sau ɗaya kawai.\n\n@param nums Wani tsararren lambobi inda kowanne abu ya bayyana sau uku sai dai ɗaya.\n@return Abin da ya bayyana sau ɗaya kawai.\n\nExample:\nsingleNumber(new int[]{2,2,3,2})\nOutput: 3\n\nExample:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nOutput: 99",
      "hi": "दिए गए पूर्णांक array nums में हर तत्व तीन बार आता है सिवाय एक के, जो केवल एक बार आता है। उस तत्व को खोजें और लौटाएं जो केवल एक बार आता है।\n\n@param nums एक पूर्णांक array जिसमें हर तत्व तीन बार आता है सिवाय एक के।\n@return वह तत्व जो केवल एक बार आता है।\n\nउदाहरण:\nsingleNumber(new int[]{2,2,3,2})\nआउटपुट: 3\n\nउदाहरण:\nsingleNumber(new int[]{0,1,0,1,0,1,99})\nआउटपुट: 99",
      "hu": "Adott egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet, amely csak egyszer jelenik meg. Találd meg és add vissza azt az elemet, amely csak egyszer jelenik meg.\n\n @param nums Egy egész számokat tartalmazó tömb, ahol minden elem háromszor jelenik meg, kivéve egyet.\n @return Az az elem, amely csak egyszer jelenik meg.\n\n Példa:\n singleNumber(new int[]{2,2,3,2})\n Kimenet: 3\n\n Példa:\n singleNumber(new int[]{0,1,0,1,0,1,99})\n Kimenet: 99"
    },
    "docstring_bertscore": {
      "sq": "0.9632879411948457",
      "hy": "0.9707566421521386",
      "bn": "0.9515546459567339",
      "bg": "0.9719297531825306",
      "zh": "0.9570789541140762",
      "fr": "0.9792828512580611",
      "de": "1",
      "ha": "0.9492918486559845",
      "hi": "0.9955443232926254",
      "hu": "0.9812737235671738"
    }
  },
  {
    "task_id": "Java/36",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n   *\n   * @param low The lower bound of the range.\n   * @param high The upper bound of the range.\n   * @return A list of stepping numbers within the range [low, high] sorted in ascending order.\n   *\n   * Example:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "sq": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Gjeni të gjitha numrat hapës në intervalin [low, high] ku një numër hapës përcaktohet si një numër ku çdo shifër është ose një më shumë ose një më pak se shifra ngjitur.\n   *\n   * @param low Kufiri i poshtëm i intervalit.\n   * @param high Kufiri i sipërm i intervalit.\n   * @return Një listë e numrave hapës brenda intervalit [low, high] të renditur në rend rritës.\n   *\n   * Shembull:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "hy": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Գտնել բոլոր քայլող թվերը [low, high] միջակայքում, որտեղ քայլող թիվը սահմանվում է որպես թիվ, որի յուրաքանչյուր թվանշանը կամ մեկով ավելի է կամ մեկով պակաս հարևան թվանշանից:\n   *\n   * @param low Միջակայքի ստորին սահմանը:\n   * @param high Միջակայքի վերին սահմանը:\n   * @return Քայլող թվերի ցուցակ [low, high] միջակայքում, դասավորված աճման կարգով:\n   *\n   * Օրինակ:\n   * findSteppingNumbers(0, 21)\n   * Արդյունք: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "bn": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * [low, high] সীমার মধ্যে সমস্ত স্টেপিং নম্বর খুঁজুন যেখানে একটি স্টেপিং নম্বরকে সংজ্ঞায়িত করা হয় এমন একটি সংখ্যা হিসাবে যেখানে প্রতিটি অঙ্ক হয় এক বেশি বা এক কম পাশের অঙ্কের তুলনায়।\n   *\n   * @param low সীমার নিম্ন সীমা।\n   * @param high সীমার উপরের সীমা।\n   * @return [low, high] সীমার মধ্যে স্টেপিং নম্বরের একটি তালিকা যা ঊর্ধ্বক্রমে সাজানো।\n   *\n   * উদাহরণ:\n   * findSteppingNumbers(0, 21)\n   * আউটপুট: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "bg": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Намерете всички стъпкови числа в диапазона [low, high], където стъпково число е дефинирано като число, при което всяка цифра е или с едно повече, или с едно по-малко от съседната цифра.\n   *\n   * @param low Долна граница на диапазона.\n   * @param high Горна граница на диапазона.\n   * @return Списък със стъпкови числа в диапазона [low, high], сортирани във възходящ ред.\n   *\n   * Пример:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "zh": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * 找到范围 [low, high] 内的所有阶梯数，其中阶梯数被定义为每个数字与相邻数字相差1的数字。\n   *\n   * @param low 范围的下界。\n   * @param high 范围的上界。\n   * @return 范围 [low, high] 内按升序排列的阶梯数列表。\n   *\n   * 示例:\n   * findSteppingNumbers(0, 21)\n   * 输出: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "fr": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Trouver tous les nombres à pas dans la plage [low, high] où un nombre à pas est défini comme un nombre où chaque chiffre est soit un de plus, soit un de moins que le chiffre adjacent.\n   *\n   * @param low La borne inférieure de la plage.\n   * @param high La borne supérieure de la plage.\n   * @return Une liste de nombres à pas dans la plage [low, high] triée par ordre croissant.\n   *\n   * Exemple:\n   * findSteppingNumbers(0, 21)\n   * Output: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "de": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Finde alle Stepping-Nummern im Bereich [low, high], wobei eine Stepping-Nummer als eine Zahl definiert ist, bei der jede Ziffer entweder eins mehr oder eins weniger als die benachbarte Ziffer ist.\n   *\n   * @param low Die untere Grenze des Bereichs.\n   * @param high Die obere Grenze des Bereichs.\n   * @return Eine Liste von Stepping-Nummern innerhalb des Bereichs [low, high], sortiert in aufsteigender Reihenfolge.\n   *\n   * Beispiel:\n   * findSteppingNumbers(0, 21)\n   * Ausgabe: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "ha": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Nemo dukkan lambobin mataki a cikin kewayon [low, high] inda aka ayyana lambar mataki a matsayin lamba inda kowace lamba tana da ɗaya fiye ko ɗaya ƙasa da lambobin da ke kusa da ita.\n   *\n   * @param low Ƙananan iyaka na kewayon.\n   * @param high Babban iyaka na kewayon.\n   * @return Jerin lambobin mataki a cikin kewayon [low, high] an jera su a tsari mai ƙaruwa.\n   *\n   * Misali:\n   * findSteppingNumbers(0, 21)\n   * Fitarwa: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "hi": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * उस सीमा [low, high] में सभी स्टेपिंग नंबर खोजें जहाँ एक स्टेपिंग नंबर को एक संख्या के रूप में परिभाषित किया जाता है जहाँ प्रत्येक अंक या तो समीपवर्ती अंक से एक अधिक या एक कम होता है।\n   *\n   * @param low सीमा की निचली सीमा।\n   * @param high सीमा की ऊपरी सीमा।\n   * @return सीमा [low, high] के भीतर स्टेपिंग नंबरों की एक सूची जो आरोही क्रम में सॉर्ट की गई हो।\n   *\n   * उदाहरण:\n   * findSteppingNumbers(0, 21)\n   * आउटपुट: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) ",
      "hu": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Keresse meg az összes lépőszámot a [low, high] tartományban, ahol a lépőszám olyan szám, amelyben minden számjegy vagy eggyel nagyobb, vagy eggyel kisebb, mint a szomszédos számjegy.\n   *\n   * @param low A tartomány alsó határa.\n   * @param high A tartomány felső határa.\n   * @return A [low, high] tartományban lévő lépőszámok listája növekvő sorrendben rendezve.\n   *\n   * Példa:\n   * findSteppingNumbers(0, 21)\n   * Kimenet: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]\n   */\n  public static List<Integer> findSteppingNumbers(int low, int high) "
    },
    "prompt_bertscore": {
      "sq": "0.9791573168572472",
      "hy": "0.9695050721212377",
      "bn": "0.9816521144430453",
      "bg": "0.9736707484723014",
      "zh": "0.955170712043474",
      "fr": "0.9974005242033964",
      "de": "0.9929889434406115",
      "ha": "0.9743977356668891",
      "hi": "0.9985956832060834",
      "hu": "0.9830911915536431"
    },
    "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "instruction": {
      "en": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static List<Integer> findSteppingNumbers(int low, int high)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = low; i <= high; i++) {\n      if (isSteppingNumber(i)) {\n        result.add(i);\n      }\n    }\n    return result;\n  }\n\n  private static boolean isSteppingNumber(int num) {\n    String strNum = String.valueOf(num);\n    int length = strNum.length();\n\n    for (int i = 0; i < length - 1; i++) {\n      int diff = Math.abs(strNum.charAt(i) - strNum.charAt(i + 1));\n      if (diff != 1) {\n        return false;\n      }\n    }\n    return true;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386897534378662",
      "hy": "0.9615433705582164",
      "bn": "0.9071198379369432",
      "bg": "0.8376140553201085",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9360370446991453",
      "ha": "0.9107035272715747",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert findSteppingNumbers(0, 21)\n      .equals(\n        new ArrayList<>(List.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21))\n      );\n    assert findSteppingNumbers(10, 15).equals(new ArrayList<>(List.of(10, 12)));\n    assert findSteppingNumbers(50, 55).equals(List.of(54));\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "findSteppingNumbers",
    "signature": "public static List<Integer> findSteppingNumbers(int low, int high)",
    "docstring": {
      "en": "Find all stepping numbers in the range [low, high] where a stepping number is defined as a number where each digit is either one more or one less than the adjacent digit.\n\n@param low The lower bound of the range.\n@param high The upper bound of the range.\n@return A list of stepping numbers within the range [low, high] sorted in ascending order.\n\nExample:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "sq": "Gjeni të gjitha numrat hapës në intervalin [low, high] ku një numër hapës është i përcaktuar si një numër ku çdo shifër është ose një më shumë ose një më pak se shifra ngjitur.\n\n@param low Kufiri i poshtëm i intervalit.\n@param high Kufiri i sipërm i intervalit.\n@return Një listë e numrave hapës brenda intervalit [low, high] të renditur në rritje.\n\nShembull:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hy": "Գտնել բոլոր քայլող թվերը [low, high] միջակայքում, որտեղ քայլող թիվը սահմանվում է որպես թիվ, որի յուրաքանչյուր թվանշանը կամ մեկով ավել կամ մեկով պակաս է հարակից թվանշանից։\n\n@param low Միջակայքի ստորին սահմանը։\n@param high Միջակայքի վերին սահմանը։\n@return Քայլող թվերի ցուցակ [low, high] միջակայքում, դասավորված աճման կարգով։\n\nՕրինակ:\nfindSteppingNumbers(0, 21)\nԵլք: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "bn": "Find all stepping numbers in the range [low, high] যেখানে একটি stepping number সংজ্ঞায়িত হয় এমন একটি সংখ্যা হিসেবে যেখানে প্রতিটি অঙ্ক সংলগ্ন অঙ্কের চেয়ে এক বেশি বা এক কম হয়।\n\n@param low পরিসরের নিম্ন সীমা।\n@param high পরিসরের উপরের সীমা।\n@return পরিসর [low, high] এর মধ্যে থাকা stepping numbers এর একটি তালিকা যা ঊর্ধ্বক্রমে সাজানো।\n\nউদাহরণ:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "bg": "Намерете всички стъпкови числа в диапазона [low, high], където стъпково число е число, при което всяка цифра е или с едно повече, или с едно по-малко от съседната цифра.\n\n@param low Долна граница на диапазона.\n@param high Горна граница на диапазона.\n@return Списък със стъпкови числа в диапазона [low, high], сортирани във възходящ ред.\n\nПример:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "zh": "在范围 [low, high] 中查找所有的阶梯数，其中阶梯数被定义为每个数字与相邻数字相差1的数字。\n\n@param low 范围的下界。\n@param high 范围的上界。\n@return 范围 [low, high] 内按升序排序的阶梯数列表。\n\n示例：\nfindSteppingNumbers(0, 21)\n输出: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "fr": "Trouver tous les nombres à pas dans la plage [low, high] où un nombre à pas est défini comme un nombre où chaque chiffre est soit un de plus, soit un de moins que le chiffre adjacent.\n\n@param low La borne inférieure de la plage.\n@param high La borne supérieure de la plage.\n@return Une liste de nombres à pas dans la plage [low, high] triée par ordre croissant.\n\nExemple:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "de": "Finde alle Stepping-Nummern im Bereich [low, high], wobei eine Stepping-Nummer als eine Zahl definiert ist, bei der jede Ziffer entweder eins mehr oder eins weniger als die benachbarte Ziffer ist.\n\n@param low Die untere Grenze des Bereichs.\n@param high Die obere Grenze des Bereichs.\n@return Eine Liste von Stepping-Nummern innerhalb des Bereichs [low, high], sortiert in aufsteigender Reihenfolge.\n\nBeispiel:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "ha": "Nemo duk lambobin mataki a cikin kewayon [low, high] inda ake ayyana lambar mataki a matsayin lamba inda kowace lamba tana da ɗaya fiye ko ɗaya ƙasa da lambobin da ke kusa da ita.\n\n@param low Ƙananan iyaka na kewayon.\n@param high Babban iyaka na kewayon.\n@return Jerin lambobin stepping a cikin kewayon [low, high] da aka tsara a cikin tsari mai hawa.\n\nMisali:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hi": "उन सभी स्टेपिंग नंबरों को खोजें जो [low, high] रेंज में हैं, जहाँ एक स्टेपिंग नंबर को एक संख्या के रूप में परिभाषित किया जाता है जहाँ प्रत्येक अंक या तो अगले अंक से एक अधिक या एक कम होता है।\n\n@param low सीमा का निचला बाउंड।\n@param high सीमा का ऊपरी बाउंड।\n@return सीमा [low, high] के भीतर सभी स्टेपिंग नंबरों की एक सूची जो आरोही क्रम में सॉर्ट की गई है।\n\nउदाहरण:\nfindSteppingNumbers(0, 21)\nOutput: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]",
      "hu": "Találja meg az összes lépőszámot a [low, high] tartományban, ahol a lépőszám olyan szám, amelyben minden számjegy vagy eggyel több, vagy eggyel kevesebb, mint a szomszédos számjegy.\n\n@param low A tartomány alsó határa.\n@param high A tartomány felső határa.\n@return A [low, high] tartományon belüli lépőszámok listája növekvő sorrendben rendezve.\n\nPélda:\nfindSteppingNumbers(0, 21)\nKimenet: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 21]"
    },
    "docstring_bertscore": {
      "sq": "0.9728283570263325",
      "hy": "0.9870465183311908",
      "bn": "0.974305571170089",
      "bg": "0.9676957479803909",
      "zh": "0.9533121275681306",
      "fr": "0.9981372442866548",
      "de": "0.9876924643303162",
      "ha": "0.9760161760115614",
      "hi": "0.9838169869659446",
      "hu": "0.9761365460224686"
    }
  },
  {
    "task_id": "Java/37",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   *\n   * @param n An integer representing the upper limit.\n   * @return The number of times the digit 1 appears.\n   *\n   * Example:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Example:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Llogarit numrin e herëve që shifra 1 shfaqet në të gjitha numrat e plotë jo-negativë më të vegjël ose të barabartë me n.\n   *\n   * @param n Një numër i plotë që përfaqëson kufirin e sipërm.\n   * @return Numri i herëve që shifra 1 shfaqet.\n   *\n   * Shembull:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Shembull:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Հաշվել, թե քանի անգամ է թիվ 1-ը հայտնվում բոլոր ոչ բացասական ամբողջ թվերում, որոնք փոքր կամ հավասար են n-ին:\n   *\n   * @param n Մի ամբողջ թիվ, որը ներկայացնում է վերին սահմանը:\n   * @return Թիվ 1-ի հայտնվելու քանակը:\n   *\n   * Օրինակ:\n   * countDigitOne(13)\n   * Արդյունք: 6\n   *\n   * Օրինակ:\n   * countDigitOne(0)\n   * Արդյունք: 0\n   */\n  public static int countDigitOne(int n) ",
      "bn": "public class Solution {\n\n  /**\n   * সমস্ত অ-ঋণাত্মক পূর্ণসংখ্যায় সংখ্যা 1 কতবার প্রদর্শিত হয় তা গণনা করুন যা n এর চেয়ে কম বা সমান।\n   *\n   * @param n একটি পূর্ণসংখ্যা যা উপরের সীমা উপস্থাপন করে।\n   * @return সংখ্যা 1 প্রদর্শিত হওয়ার সংখ্যা।\n   *\n   * উদাহরণ:\n   * countDigitOne(13)\n   * আউটপুট: 6\n   *\n   * উদাহরণ:\n   * countDigitOne(0)\n   * আউটপুট: 0\n   */\n  public static int countDigitOne(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Изчислява броя на появяванията на цифрата 1 във всички неотрицателни цели числа, по-малки или равни на n.\n   *\n   * @param n Цяло число, представляващо горната граница.\n   * @return Броят на появяванията на цифрата 1.\n   *\n   * Пример:\n   * countDigitOne(13)\n   * Изход: 6\n   *\n   * Пример:\n   * countDigitOne(0)\n   * Изход: 0\n   */\n  public static int countDigitOne(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 计算数字1在所有小于或等于n的非负整数中出现的次数。\n   *\n   * @param n 表示上限的整数。\n   * @return 数字1出现的次数。\n   *\n   * 示例:\n   * countDigitOne(13)\n   * 输出: 6\n   *\n   * 示例:\n   * countDigitOne(0)\n   * 输出: 0\n   */\n  public static int countDigitOne(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Calculer le nombre de fois que le chiffre 1 apparaît dans tous les entiers non négatifs inférieurs ou égaux à n.\n   *\n   * @param n Un entier représentant la limite supérieure.\n   * @return Le nombre de fois que le chiffre 1 apparaît.\n   *\n   * Exemple:\n   * countDigitOne(13)\n   * Output: 6\n   *\n   * Exemple:\n   * countDigitOne(0)\n   * Output: 0\n   */\n  public static int countDigitOne(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Berechne, wie oft die Ziffer 1 in allen nicht-negativen ganzen Zahlen kleiner oder gleich n erscheint.\n   *\n   * @param n Eine Ganzzahl, die die obere Grenze darstellt.\n   * @return Die Anzahl der Vorkommen der Ziffer 1.\n   *\n   * Beispiel:\n   * countDigitOne(13)\n   * Ausgabe: 6\n   *\n   * Beispiel:\n   * countDigitOne(0)\n   * Ausgabe: 0\n   */\n  public static int countDigitOne(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * Lissafa yawan lokutan da lamba 1 ta bayyana a duk lambobin da ba su da kyau kasa da ko daidai da n.\n   *\n   * @param n Wani lamba wanda ke wakiltar iyaka ta sama.\n   * @return Yawan lokutan da lamba 1 ta bayyana.\n   *\n   * Misali:\n   * countDigitOne(13)\n   * Fitarwa: 6\n   *\n   * Misali:\n   * countDigitOne(0)\n   * Fitarwa: 0\n   */\n  public static int countDigitOne(int n) ",
      "hi": "public class Solution {\n\n  /**\n   * सभी गैर-ऋणात्मक पूर्णांकों में अंक 1 कितनी बार प्रकट होता है, इसकी गणना करें जो n से कम या उसके बराबर हैं।\n   *\n   * @param n एक पूर्णांक जो ऊपरी सीमा का प्रतिनिधित्व करता है।\n   * @return यह संख्या कि अंक 1 कितनी बार प्रकट होता है।\n   *\n   * उदाहरण:\n   * countDigitOne(13)\n   * आउटपुट: 6\n   *\n   * उदाहरण:\n   * countDigitOne(0)\n   * आउटपुट: 0\n   */\n  public static int countDigitOne(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Számolja ki, hogy hányszor jelenik meg az 1-es számjegy az összes nem negatív egész szám között, amelyek kisebbek vagy egyenlők n-nél.\n   *\n   * @param n Egy egész szám, amely a felső határt jelenti.\n   * @return Annak a száma, hogy hányszor jelenik meg az 1-es számjegy.\n   *\n   * Példa:\n   * countDigitOne(13)\n   * Kimenet: 6\n   *\n   * Példa:\n   * countDigitOne(0)\n   * Kimenet: 0\n   */\n  public static int countDigitOne(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9983638815514156",
      "hy": "0.9695511543696379",
      "bn": "0.9648527513366386",
      "bg": "0.9808748737620558",
      "zh": "1",
      "fr": "1",
      "de": "0.9774773010944541",
      "ha": "0.975951621137725",
      "hi": "0.9802628935580873",
      "hu": "0.987605662853804"
    },
    "canonical_solution": "  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }",
    "instruction": {
      "en": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nՏվեք Java կոդի համառոտ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简明的自然语言描述（文档字符串）。",
      "fr": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static int countDigitOne(int n)\n  {\n    int count = 0;\n    for (long k = 1; k <= n; k *= 10) {\n      long divider = k * 10;\n      count +=\n        (n / divider) * k + Math.min(Math.max(n % divider - k + 1, 0), k);\n    }\n    return count;\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386897534378662",
      "hy": "0.9133739141142077",
      "bn": "0.8954556660714315",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert countDigitOne(20) == 12 : \"Test case 1 failed\";\n    assert countDigitOne(55) == 16 : \"Test case 2 failed\";\n    assert countDigitOne(99) == 20 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "countDigitOne",
    "signature": "public static int countDigitOne(int n)",
    "docstring": {
      "en": "Calculate the number of times the digit 1 appears in all non-negative integers less than or equal to n.\n   \n    @param n An integer representing the upper limit.\n    @return The number of times the digit 1 appears.\n   \n    Example:\n    countDigitOne(13)\n    Output: 6\n   \n    Example:\n    countDigitOne(0)\n    Output: 0",
      "sq": "Llogarit numrin e herëve që shfaqet shifra 1 në të gjitha numrat e plotë jo-negativë më të vegjël ose të barabartë me n.\n\n    @param n Një numër i plotë që përfaqëson kufirin e sipërm.\n    @return Numri i herëve që shfaqet shifra 1.\n\n    Shembull:\n    countDigitOne(13)\n    Output: 6\n\n    Shembull:\n    countDigitOne(0)\n    Output: 0",
      "hy": "Հաշվել, թե քանի անգամ է թիվ 1-ը հայտնվում բոլոր ոչ բացասական ամբողջ թվերում, որոնք փոքր կամ հավասար են n-ին:\n\n    @param n Ամբողջ թիվ, որը ներկայացնում է վերին սահմանը:\n    @return Թիվ 1-ի հայտնվելու քանակը:\n   \n    Օրինակ:\n    countDigitOne(13)\n    Արդյունք: 6\n   \n    Օրինակ:\n    countDigitOne(0)\n    Արդյունք: 0",
      "bn": "সমস্ত অ-ঋণাত্মক পূর্ণসংখ্যায় সংখ্যা 1 কতবার উপস্থিত হয় তা গণনা করুন যা n এর চেয়ে কম বা সমান।\n   \n    @param n একটি পূর্ণসংখ্যা যা উপরের সীমা নির্দেশ করে।\n    @return সংখ্যা 1 কতবার প্রদর্শিত হয়।\n\n    উদাহরণ:\n    countDigitOne(13)\n    Output: 6\n\n    উদাহরণ:\n    countDigitOne(0)\n    Output: 0",
      "bg": "Изчислете колко пъти цифрата 1 се появява във всички неотрицателни цели числа, по-малки или равни на n.\n   \n    @param n Цяло число, представляващо горната граница.\n    @return Броят пъти, когато цифрата 1 се появява.\n   \n    Пример:\n    countDigitOne(13)\n    Output: 6\n   \n    Пример:\n    countDigitOne(0)\n    Output: 0",
      "zh": "计算在所有小于或等于 n 的非负整数中，数字 1 出现的次数。\n\n    @param n 一个整数，表示上限。\n    @return 数字 1 出现的次数。\n   \n    示例:\n    countDigitOne(13)\n    输出: 6\n   \n    示例:\n    countDigitOne(0)\n    输出: 0",
      "fr": "Calculer le nombre de fois que le chiffre 1 apparaît dans tous les entiers non négatifs inférieurs ou égaux à n.\n   \n    @param n Un entier représentant la limite supérieure.\n    @return Le nombre de fois que le chiffre 1 apparaît.\n   \n    Exemple:\n    countDigitOne(13)\n    Output: 6\n   \n    Exemple:\n    countDigitOne(0)\n    Output: 0",
      "de": "Berechne, wie oft die Ziffer 1 in allen nicht-negativen ganzen Zahlen kleiner oder gleich n vorkommt.\n   \n    @param n Eine ganze Zahl, die die obere Grenze darstellt.\n    @return Die Anzahl der Vorkommen der Ziffer 1.\n   \n    Beispiel:\n    countDigitOne(13)\n    Ausgabe: 6\n   \n    Beispiel:\n    countDigitOne(0)\n    Ausgabe: 0",
      "ha": "Ƙididdige adadin lokutan da lamba 1 ta bayyana a cikin dukkan lambobin da ba su da korafi ƙasa da ko daidai da n.\n\n    @param n Wani lamba da ke wakiltar iyaka mafi girma.\n    @return Adadin lokutan da lamba 1 ta bayyana.\n\n    Misali:\n    countDigitOne(13)\n    Output: 6\n\n    Misali:\n    countDigitOne(0)\n    Output: 0",
      "hi": "सभी गैर-ऋणात्मक पूर्णांकों में अंक 1 कितनी बार प्रकट होता है, इसकी गणना करें जो n से कम या उसके बराबर हैं।\n\n    @param n ऊपरी सीमा का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    @return अंक 1 जितनी बार प्रकट होता है, उसकी संख्या।\n\n    उदाहरण:\n    countDigitOne(13)\n    Output: 6\n\n    उदाहरण:\n    countDigitOne(0)\n    Output: 0",
      "hu": "Számítsa ki, hogy az 1-es számjegy hányszor jelenik meg az összes nem negatív egész számokban, amelyek kisebbek vagy egyenlőek n-nél.\n   \n    @param n Egy egész szám, amely a felső határt jelenti.\n    @return Az 1-es számjegy megjelenésének száma.\n   \n    Példa:\n    countDigitOne(13)\n    Kimenet: 6\n   \n    Példa:\n    countDigitOne(0)\n    Kimenet: 0"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9481040389773958",
      "bn": "0.9806039419223243",
      "bg": "0.9911456535046078",
      "zh": "1",
      "fr": "1",
      "de": "0.9686732080854636",
      "ha": "0.9723725003018574",
      "hi": "0.9781039799466191",
      "hu": "0.9660687665293342"
    }
  },
  {
    "task_id": "Java/38",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, determine if it is a power of two.\n   * If it is, return true; otherwise, return false.\n   * A number n is a power of two if there exists an integer x such that n == 2^x.\n   *\n   * @param n The integer to be checked.\n   * @return True if n is a power of two, false otherwise.\n   *\n   * Example:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Example:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Example:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një numër të plotë n, përcaktoni nëse është një fuqi e dy.\n   * Nëse është, kthe true; përndryshe, kthe false.\n   * Një numër n është një fuqi e dy nëse ekziston një numër i plotë x i tillë që n == 2^x.\n   *\n   * @param n Numri i plotë që do të kontrollohet.\n   * @return True nëse n është një fuqi e dy, false përndryshe.\n   *\n   * Shembull:\n   * isPowerOfTwo(1)\n   * Dalja: true\n   *\n   * Shembull:\n   * isPowerOfTwo(16)\n   * Dalja: true\n   *\n   * Shembull:\n   * isPowerOfTwo(3)\n   * Dalja: false\n   *\n   * Shembull:\n   * isPowerOfTwo(4)\n   * Dalja: true\n   *\n   * Shembull:\n   * isPowerOfTwo(5)\n   * Dalja: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է ամբողջ թիվ n, որոշեք՝ արդյոք այն երկուսի աստիճան է:\n   * Եթե այո, վերադարձնել true; հակառակ դեպքում՝ false:\n   * Թիվը n երկուսի աստիճան է, եթե գոյություն ունի ամբողջ թիվ x, որ n == 2^x:\n   *\n   * @param n Ստուգվող ամբողջ թիվը:\n   * @return True, եթե n-ը երկուսի աստիճան է, false՝ հակառակ դեպքում:\n   *\n   * Օրինակ:\n   * isPowerOfTwo(1)\n   * Արդյունք: true\n   *\n   * Օրինակ:\n   * isPowerOfTwo(16)\n   * Արդյունք: true\n   *\n   * Օրինակ:\n   * isPowerOfTwo(3)\n   * Արդյունք: false\n   *\n   * Օրինակ:\n   * isPowerOfTwo(4)\n   * Արդյունք: true\n   *\n   * Օրինակ:\n   * isPowerOfTwo(5)\n   * Արդյունք: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "bn": "public class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যা n দেওয়া হলে, এটি দুইয়ের ঘাত কিনা তা নির্ধারণ করুন।\n   * যদি হয়, তাহলে true ফেরত দিন; অন্যথায়, false ফেরত দিন।\n   * একটি সংখ্যা n দুইয়ের ঘাত যদি বিদ্যমান থাকে একটি পূর্ণসংখ্যা x যার জন্য n == 2^x।\n   *\n   * @param n যে পূর্ণসংখ্যাটি পরীক্ষা করা হবে।\n   * @return যদি n দুইয়ের ঘাত হয় তাহলে True, অন্যথায় false।\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(1)\n   * আউটপুট: true\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(16)\n   * আউটপুট: true\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(3)\n   * আউটপুট: false\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(4)\n   * আউটপুট: true\n   *\n   * উদাহরণ:\n   * isPowerOfTwo(5)\n   * আউটপুট: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадено е цяло число n, определете дали е степен на две.\n   * Ако е, върнете true; в противен случай върнете false.\n   * Число n е степен на две, ако съществува цяло число x, такова че n == 2^x.\n   *\n   * @param n Цялото число, което да бъде проверено.\n   * @return True ако n е степен на две, false в противен случай.\n   *\n   * Пример:\n   * isPowerOfTwo(1)\n   * Изход: true\n   *\n   * Пример:\n   * isPowerOfTwo(16)\n   * Изход: true\n   *\n   * Пример:\n   * isPowerOfTwo(3)\n   * Изход: false\n   *\n   * Пример:\n   * isPowerOfTwo(4)\n   * Изход: true\n   *\n   * Пример:\n   * isPowerOfTwo(5)\n   * Изход: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个整数 n，确定它是否是二的幂。\n   * 如果是，返回 true；否则，返回 false。\n   * 如果存在一个整数 x 使得 n == 2^x，则数字 n 是二的幂。\n   *\n   * @param n 要检查的整数。\n   * @return 如果 n 是二的幂，返回 true，否则返回 false。\n   *\n   * 示例:\n   * isPowerOfTwo(1)\n   * 输出: true\n   *\n   * 示例:\n   * isPowerOfTwo(16)\n   * 输出: true\n   *\n   * 示例:\n   * isPowerOfTwo(3)\n   * 输出: false\n   *\n   * 示例:\n   * isPowerOfTwo(4)\n   * 输出: true\n   *\n   * 示例:\n   * isPowerOfTwo(5)\n   * 输出: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné un entier n, déterminez s'il est une puissance de deux.\n   * Si c'est le cas, renvoyez true ; sinon, renvoyez false.\n   * Un nombre n est une puissance de deux s'il existe un entier x tel que n == 2^x.\n   *\n   * @param n L'entier à vérifier.\n   * @return True si n est une puissance de deux, false sinon.\n   *\n   * Exemple:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Exemple:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Exemple:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Exemple:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Exemple:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine ganze Zahl n, bestimmen, ob sie eine Potenz von zwei ist.\n   * Wenn ja, gib true zurück; andernfalls gib false zurück.\n   * Eine Zahl n ist eine Potenz von zwei, wenn es eine ganze Zahl x gibt, so dass n == 2^x.\n   *\n   * @param n Die zu überprüfende ganze Zahl.\n   * @return True, wenn n eine Potenz von zwei ist, andernfalls false.\n   *\n   * Beispiel:\n   * isPowerOfTwo(1)\n   * Ausgabe: true\n   *\n   * Beispiel:\n   * isPowerOfTwo(16)\n   * Ausgabe: true\n   *\n   * Beispiel:\n   * isPowerOfTwo(3)\n   * Ausgabe: false\n   *\n   * Beispiel:\n   * isPowerOfTwo(4)\n   * Ausgabe: true\n   *\n   * Beispiel:\n   * isPowerOfTwo(5)\n   * Ausgabe: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da wani lamba n, tantance ko shi iko ne na biyu.\n   * Idan haka ne, mayar da gaskiya; in ba haka ba, mayar da ƙarya.\n   * Wani lamba n iko ne na biyu idan akwai wani lamba x wanda n == 2^x.\n   *\n   * @param n Lambar da za a duba.\n   * @return Gaskiya idan n iko ne na biyu, ƙarya in ba haka ba.\n   *\n   * Misali:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * Misali:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * Misali:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * Misali:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * Misali:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए पूर्णांक n के लिए, यह निर्धारित करें कि क्या यह दो की घात है।\n   * यदि यह है, तो true लौटाएं; अन्यथा, false लौटाएं।\n   * एक संख्या n दो की घात है यदि ऐसा कोई पूर्णांक x मौजूद है जिससे n == 2^x हो।\n   *\n   * @param n वह पूर्णांक जिसे जांचना है।\n   * @return true यदि n दो की घात है, अन्यथा false।\n   *\n   * उदाहरण:\n   * isPowerOfTwo(1)\n   * Output: true\n   *\n   * उदाहरण:\n   * isPowerOfTwo(16)\n   * Output: true\n   *\n   * उदाहरण:\n   * isPowerOfTwo(3)\n   * Output: false\n   *\n   * उदाहरण:\n   * isPowerOfTwo(4)\n   * Output: true\n   *\n   * उदाहरण:\n   * isPowerOfTwo(5)\n   * Output: false\n   */\n  public static boolean isPowerOfTwo(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy egész szám n, határozza meg, hogy kettő hatványa-e.\n   * Ha igen, adja vissza az igaz értéket; ellenkező esetben adja vissza a hamis értéket.\n   * Egy szám n akkor kettő hatványa, ha létezik egy x egész szám, amelyre n == 2^x.\n   *\n   * @param n Az ellenőrizendő egész szám.\n   * @return Igaz, ha n kettő hatványa, hamis egyébként.\n   *\n   * Példa:\n   * isPowerOfTwo(1)\n   * Kimenet: true\n   *\n   * Példa:\n   * isPowerOfTwo(16)\n   * Kimenet: true\n   *\n   * Példa:\n   * isPowerOfTwo(3)\n   * Kimenet: false\n   *\n   * Példa:\n   * isPowerOfTwo(4)\n   * Kimenet: true\n   *\n   * Példa:\n   * isPowerOfTwo(5)\n   * Kimenet: false\n   */\n  public static boolean isPowerOfTwo(int n) "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9671465349768295",
      "bn": "0.9924373468724776",
      "bg": "1",
      "zh": "0.9886045750400284",
      "fr": "0.9964679545644376",
      "de": "0.9904025772491563",
      "ha": "0.9834022467303437",
      "hi": "0.9903658306286648",
      "hu": "0.9881387867965017"
    },
    "canonical_solution": "  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }",
    "instruction": {
      "en": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, সর্বাধিক ৫০০ অক্ষর ব্যবহার করে।",
      "bg": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Java a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static boolean isPowerOfTwo(int n)\n  {\n    if (n <= 0) {\n      return false;\n    }\n    while (n % 2 == 0) {\n      n /= 2;\n    }\n    return n == 1;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386897534378662",
      "hy": "0.9242475370632005",
      "bn": "0.9487728274703403",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9168968225522425",
      "hi": "0.9113991308659588",
      "hu": "0.9407980163021705"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert isPowerOfTwo(1024) == true; // 1024 is 2^10\n    assert isPowerOfTwo(65536) == true; // 65536 is 2^16\n    assert isPowerOfTwo(14) == false; // 14 is not a power of two\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isPowerOfTwo",
    "signature": "public static boolean isPowerOfTwo(int n)",
    "docstring": {
      "en": "Given an integer n, determine if it is a power of two.\n    If it is, return true; otherwise, return false.\n    A number n is a power of two if there exists an integer x such that n == 2^x.\n   \n    @param n The integer to be checked.\n    @return True if n is a power of two, false otherwise.\n   \n    Example:\n    isPowerOfTwo(1)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(16)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(3)\n    Output: false\n   \n    Example:\n    isPowerOfTwo(4)\n    Output: true\n   \n    Example:\n    isPowerOfTwo(5)\n    Output: false",
      "sq": "Duke pasur një numër të plotë n, përcaktoni nëse është fuqi e dyshit. Nëse është, kthe true; përndryshe, kthe false. Një numër n është fuqi e dyshit nëse ekziston një numër i plotë x i tillë që n == 2^x.\n\n@param n Numri i plotë që do të kontrollohet.\n@return True nëse n është fuqi e dyshit, false përndryshe.\n\nShembull:\nisPowerOfTwo(1)\nOutput: true\n\nShembull:\nisPowerOfTwo(16)\nOutput: true\n\nShembull:\nisPowerOfTwo(3)\nOutput: false\n\nShembull:\nisPowerOfTwo(4)\nOutput: true\n\nShembull:\nisPowerOfTwo(5)\nOutput: false",
      "hy": "Տրված է ամբողջ թիվ n, որոշել՝ արդյոք այն երկուի աստիճան է:\n    Եթե այո, վերադարձնել true, հակառակ դեպքում՝ false:\n    Թիվ n-ը երկուի աստիճան է, եթե գոյություն ունի ամբողջ թիվ x, այնպես, որ n == 2^x:\n   \n    @param n Ստուգվող ամբողջ թիվը:\n    @return True, եթե n-ը երկուի աստիճան է, false՝ հակառակ դեպքում:\n   \n    Օրինակ:\n    isPowerOfTwo(1)\n    Արդյունք: true\n   \n    Օրինակ:\n    isPowerOfTwo(16)\n    Արդյունք: true\n   \n    Օրինակ:\n    isPowerOfTwo(3)\n    Արդյունք: false\n   \n    Օրինակ:\n    isPowerOfTwo(4)\n    Արդյունք: true\n   \n    Օրինակ:\n    isPowerOfTwo(5)\n    Արդյունք: false",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, নির্ধারণ করুন এটি দুইয়ের ঘাত কিনা। \n    যদি হয়, তাহলে true ফেরত দিন; অন্যথায়, false ফেরত দিন। \n    একটি সংখ্যা n দুইয়ের ঘাত যদি হয়, তাহলে একটি পূর্ণসংখ্যা x বিদ্যমান এমন যে n == 2^x।\n\n    @param n যাচাই করার জন্য পূর্ণসংখ্যা।\n    @return যদি n দুইয়ের ঘাত হয় তাহলে True, অন্যথায় false।\n\n    উদাহরণ:\n    isPowerOfTwo(1)\n    আউটপুট: true\n\n    উদাহরণ:\n    isPowerOfTwo(16)\n    আউটপুট: true\n\n    উদাহরণ:\n    isPowerOfTwo(3)\n    আউটপুট: false\n\n    উদাহরণ:\n    isPowerOfTwo(4)\n    আউটপুট: true\n\n    উদাহরণ:\n    isPowerOfTwo(5)\n    আউটপুট: false",
      "bg": "Дадено е цяло число n, определете дали е степен на две.\n    Ако е, върнете true; в противен случай върнете false.\n    Число n е степен на две, ако съществува цяло число x, такова че n == 2^x.\n   \n    @param n Цялото число, което трябва да се провери.\n    @return True ако n е степен на две, false в противен случай.\n   \n    Пример:\n    isPowerOfTwo(1)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(16)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(3)\n    Изход: false\n   \n    Пример:\n    isPowerOfTwo(4)\n    Изход: true\n   \n    Пример:\n    isPowerOfTwo(5)\n    Изход: false",
      "zh": "给定一个整数 n，确定它是否是二的幂。\n    如果是，返回 true；否则，返回 false。\n    如果存在一个整数 x 使得 n == 2^x，则数字 n 是二的幂。\n   \n    @param n 要检查的整数。\n    @return 如果 n 是二的幂则为 True，否则为 false。\n   \n    示例:\n    isPowerOfTwo(1)\n    输出: true\n   \n    示例:\n    isPowerOfTwo(16)\n    输出: true\n   \n    示例:\n    isPowerOfTwo(3)\n    输出: false\n   \n    示例:\n    isPowerOfTwo(4)\n    输出: true\n   \n    示例:\n    isPowerOfTwo(5)\n    输出: false",
      "fr": "Étant donné un entier n, déterminez s'il est une puissance de deux.\n    Si c'est le cas, retournez vrai ; sinon, retournez faux.  \n    Un nombre n est une puissance de deux s'il existe un entier x tel que n == 2^x.\n   \n    @param n L'entier à vérifier.\n    @return Vrai si n est une puissance de deux, faux sinon.\n   \n    Exemple:\n    isPowerOfTwo(1)\n    Sortie: true\n   \n    Exemple:\n    isPowerOfTwo(16)\n    Sortie: true\n   \n    Exemple:\n    isPowerOfTwo(3)\n    Sortie: false\n   \n    Exemple:\n    isPowerOfTwo(4)\n    Sortie: true\n   \n    Exemple:\n    isPowerOfTwo(5)\n    Sortie: false",
      "de": "Gegeben eine ganze Zahl n, bestimmen, ob sie eine Potenz von zwei ist.\n    Wenn es so ist, geben Sie true zurück; andernfalls false.  \nEine Zahl n ist eine Potenz von zwei, wenn es eine ganze Zahl x gibt, so dass n == 2^x.\n\n@param n Die zu prüfende ganze Zahl.  \n@return True, wenn n eine Potenz von zwei ist, andernfalls false.\n\nBeispiel:  \nisPowerOfTwo(1)  \nAusgabe: true\n\nBeispiel:  \nisPowerOfTwo(16)  \nAusgabe: true\n\nBeispiel:  \nisPowerOfTwo(3)  \nAusgabe: false\n\nBeispiel:  \nisPowerOfTwo(4)  \nAusgabe: true\n\nBeispiel:  \nisPowerOfTwo(5)  \nAusgabe: false",
      "ha": "An ba da wani lamba n, tantance ko yana da ikon biyu.\n    Idan haka ne, dawo da gaskiya; in ba haka ba, dawo da ƙarya.  \n    Wani lamba n yana da ikon biyu idan akwai wani cikakken lamba x wanda n == 2^x.  \n   \n    @param n Lambar cikakke da za a duba.  \n    @return Gaskiya idan n yana da ikon biyu, ƙarya in ba haka ba.  \n   \n    Misali:  \n    isPowerOfTwo(1)  \n    Output: true  \n   \n    Misali:  \n    isPowerOfTwo(16)  \n    Output: true  \n   \n    Misali:  \n    isPowerOfTwo(3)  \n    Output: false  \n   \n    Misali:  \n    isPowerOfTwo(4)  \n    Output: true  \n   \n    Misali:  \n    isPowerOfTwo(5)  \n    Output: false",
      "hi": "दिए गए एक पूर्णांक n के लिए, यह निर्धारित करें कि क्या यह दो का घात है।\n    यदि यह है, तो true लौटाएं; अन्यथा, false लौटाएं।  \n    एक संख्या n दो की शक्ति है यदि कोई पूर्णांक x मौजूद है ऐसा कि n == 2^x।  \n   \n    @param n जाँच की जाने वाली पूर्णांक।  \n    @return True यदि n दो की शक्ति है, अन्यथा false।  \n   \n    उदाहरण:  \n    isPowerOfTwo(1)  \n    Output: true  \n   \n    उदाहरण:  \n    isPowerOfTwo(16)  \n    Output: true  \n   \n    उदाहरण:  \n    isPowerOfTwo(3)  \n    Output: false  \n   \n    उदाहरण:  \n    isPowerOfTwo(4)  \n    Output: true  \n   \n    उदाहरण:  \n    isPowerOfTwo(5)  \n    Output: false",
      "hu": "Adott egy egész szám n, határozza meg, hogy kettő hatványa-e.\n    Ha igen, adjon vissza igazat; ellenkező esetben hamisat.\n    Egy szám n akkor kettő hatványa, ha létezik egy x egész szám, amelyre n == 2^x.\n   \n    @param n Az ellenőrizendő egész szám.\n    @return Igaz, ha n kettő hatványa, hamis egyébként.\n   \n    Példa:\n    isPowerOfTwo(1)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(16)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(3)\n    Kimenet: false\n   \n    Példa:\n    isPowerOfTwo(4)\n    Kimenet: true\n   \n    Példa:\n    isPowerOfTwo(5)\n    Kimenet: false"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9554626987035953",
      "bn": "0.9934416220789901",
      "bg": "1",
      "zh": "0.9728877475102619",
      "fr": "0.9959245018419262",
      "de": "0.9901145631966557",
      "ha": "0.9875230326152935",
      "hi": "0.9827970199593304",
      "hu": "0.9940704858653465"
    }
  },
  {
    "task_id": "Java/39",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n   *\n   * @param num The non-negative integer to perform the operation on.\n   * @return The single digit result after repeatedly adding all digits.\n   *\n   * Example:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një numër të plotë jo-negativ num, shtoni përsëri të gjitha shifrat e tij derisa rezultati të jetë një shifër e vetme. Kthe rezultatin.\n   *\n   * @param num Numri i plotë jo-negativ mbi të cilin do të kryhet operacioni.\n   * @return Rezultati me një shifër pasi të jenë shtuar përsëri të gjitha shifrat.\n   *\n   * Shembull:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է ոչ բացասական ամբողջ թիվ num, կրկնվող կերպով գումարեք նրա բոլոր թվանշանները, մինչև արդյունքը լինի մեկանիշ թիվ: Վերադարձնել արդյունքը:\n   *\n   * @param num Ոչ բացասական ամբողջ թիվ, որի վրա պետք է կատարվի գործողությունը:\n   * @return Մեկանիշ արդյունքը, որը ստացվում է բոլոր թվանշանները կրկնվող կերպով գումարելուց հետո:\n   *\n   * Օրինակ:\n   * addDigits(38)\n   * Արդյունք: 2\n   */\n  public static int addDigits(int num) ",
      "bn": "public class Solution {\n\n  /**\n   * একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, ফলাফল একটি একক অঙ্ক না হওয়া পর্যন্ত এর সমস্ত অঙ্ক বারবার যোগ করুন। ফলাফল ফেরত দিন।\n   *\n   * @param num যে অ-ঋণাত্মক পূর্ণসংখ্যার উপর অপারেশনটি সম্পন্ন করতে হবে।\n   * @return সমস্ত অঙ্ক বারবার যোগ করার পরে একক অঙ্কের ফলাফল।\n   *\n   * উদাহরণ:\n   * addDigits(38)\n   * আউটপুট: 2\n   */\n  public static int addDigits(int num) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадено е неотрицателно цяло число num, повтарящо се събиране на всичките му цифри, докато резултатът стане едноцифрен. Върнете резултата.\n   *\n   * @param num Неотрицателното цяло число, върху което да се извърши операцията.\n   * @return Едноцифреният резултат след повтарящото се събиране на всички цифри.\n   *\n   * Пример:\n   * addDigits(38)\n   * Изход: 2\n   */\n  public static int addDigits(int num) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个非负整数 num，重复将所有位数相加，直到结果为一位数。返回结果。\n   *\n   * @param num 要执行操作的非负整数。\n   * @return 重复相加所有位数后的单一数字结果。\n   *\n   * 示例:\n   * addDigits(38)\n   * 输出: 2\n   */\n  public static int addDigits(int num) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que le résultat soit un seul chiffre. Retournez le résultat.\n   *\n   * @param num L'entier non négatif sur lequel effectuer l'opération.\n   * @return Le résultat à un chiffre après avoir ajouté de manière répétée tous les chiffres.\n   *\n   * Exemple :\n   * addDigits(38)\n   * Sortie : 2\n   */\n  public static int addDigits(int num) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis eine einzelne Ziffer ist. Gib das Ergebnis zurück.\n   *\n   * @param num Die nicht-negative ganze Zahl, auf der die Operation durchgeführt werden soll.\n   * @return Das einstellige Ergebnis nach wiederholtem Addieren aller Ziffern.\n   *\n   * Beispiel:\n   * addDigits(38)\n   * Ausgabe: 2\n   */\n  public static int addDigits(int num) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon ya zama lamba guda. Mayar da sakamakon.\n   *\n   * @param num Lamba mara kyau da za a yi aikin a kai.\n   * @return Sakamakon lamba guda bayan ci gaba da ƙara duk lambobi.\n   *\n   * Misali:\n   * addDigits(38)\n   * Output: 2\n   */\n  public static int addDigits(int num) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए एक गैर-ऋणात्मक पूर्णांक num पर, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम एकल अंक न हो जाए। परिणाम लौटाएं।\n   *\n   * @param num गैर-ऋणात्मक पूर्णांक जिस पर ऑपरेशन करना है।\n   * @return सभी अंकों को बार-बार जोड़ने के बाद एकल अंक का परिणाम।\n   *\n   * उदाहरण:\n   * addDigits(38)\n   * आउटपुट: 2\n   */\n  public static int addDigits(int num) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy nem negatív egész szám, ismételten adjuk össze az összes számjegyét, amíg az eredmény egyetlen számjegy nem lesz. Adja vissza az eredményt.\n   *\n   * @param num A nem negatív egész szám, amelyen a műveletet végre kell hajtani.\n   * @return Az egyetlen számjegyű eredmény az összes számjegy ismételt összeadása után.\n   *\n   * Példa:\n   * addDigits(38)\n   * Kimenet: 2\n   */\n  public static int addDigits(int num) "
    },
    "prompt_bertscore": {
      "sq": "0.9699013397314024",
      "hy": "0.9604763281512969",
      "bn": "0.9773354790023951",
      "bg": "0.9880507935377032",
      "zh": "1",
      "fr": "0.9835146715260095",
      "de": "0.9820072655643357",
      "ha": "0.9710339301640633",
      "hi": "0.9648976418027525",
      "hu": "0.9731120012104503"
    },
    "canonical_solution": "  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }",
    "instruction": {
      "en": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static int addDigits(int num)\n  {\n    while (num >= 10) {\n      num = sumOfDigits(num);\n    }\n    return num;\n  }\n\n  private static int sumOfDigits(int num) {\n    int sum = 0;\n    while (num > 0) {\n      sum += num % 10; // adds the last digit to the sum\n      num /= 10; // removes the last digit\n    }\n    return sum;\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9386897534378662",
      "hy": "0.9242475370632005",
      "bn": "0.9071198379369432",
      "bg": "0.8400592418438494",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9217739929281731",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert addDigits(123) == 6 : \"Test case 1 failed\";\n    assert addDigits(59) == 5 : \"Test case 2 failed\";\n    assert addDigits(0) == 0 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "addDigits",
    "signature": "public static int addDigits(int num)",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result is a single digit. Return the result.\n\n@param num The non-negative integer to perform the operation on.\n@return The single digit result after repeatedly adding all digits.\n\nExample:\naddDigits(38)\nOutput: 2",
      "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni në mënyrë të përsëritur të gjitha shifrat e tij derisa rezultati të jetë një shifër e vetme. Kthe rezultatin.\n\n@param num Numri i plotë jo-negativ mbi të cilin do të kryhet operacioni.\n@return Rezultati me një shifër pas shtimit të përsëritur të të gjitha shifrave.\n\nShembull:\naddDigits(38)\nOutput: 2",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը լինի միանիշ։ Վերադարձնել արդյունքը։\n\n@param num Ոչ բացասական ամբողջ թիվ, որի վրա պետք է կատարել գործողությունը։\n@return Միանիշ արդյունքը, որը ստացվում է բոլոր թվանշանները բազմիցս գումարելուց հետո։\n\nՕրինակ:\naddDigits(38)\nԱրդյունք: 2",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফল একটি একক অঙ্ক হয়। ফলাফল ফেরত দিন।\n\n@param num যে অ-ঋণাত্মক পূর্ণসংখ্যার উপর অপারেশনটি সম্পাদন করতে হবে।\n@return সমস্ত অঙ্ক বারবার যোগ করার পরে একক অঙ্কের ফলাফল।\n\nউদাহরণ:\naddDigits(38)\nOutput: 2",
      "bg": "Дадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът стане едноцифрено число. Върнете резултата.\n\n@param num Неотрицателното цяло число, върху което да се извърши операцията.\n@return Едноцифреният резултат след многократно събиране на всички цифри.\n\nПример:\naddDigits(38)\nИзход: 2",
      "zh": "给定一个非负整数 num，重复将其所有位数相加，直到结果为一位数。返回结果。\n\n@param num 要执行操作的非负整数。\n@return 反复相加所有位数后的单一数字结果。\n\n示例：\naddDigits(38)\n输出: 2",
      "fr": "Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat soit un seul chiffre. Retournez le résultat.\n\n@param num L'entier non négatif sur lequel effectuer l'opération.\n@return Le résultat à un chiffre après avoir additionné de manière répétée tous les chiffres.\n\nExemple :\naddDigits(38)\nOutput: 2",
      "de": "Gegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis eine einzelne Ziffer ist. Gib das Ergebnis zurück.\n\n@param num Die nicht-negative ganze Zahl, auf der die Operation durchgeführt werden soll.\n@return Das einstellige Ergebnis nach wiederholtem Addieren aller Ziffern.\n\nBeispiel:\naddDigits(38)\nAusgabe: 2",
      "ha": "An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon ya zama lamba guda ɗaya. Mayar da sakamakon.\n\n@param num Lamba mara kyau da za a yi aikin a kai.\n@return Sakamakon lamba guda ɗaya bayan ci gaba da ƙara duk lambobi.\n\nMisali:\naddDigits(38)\nOutput: 2",
      "hi": "गैर-ऋणात्मक पूर्णांक num दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक कि परिणाम एकल अंक न हो जाए। परिणाम लौटाएं।\n\n@param num वह गैर-ऋणात्मक पूर्णांक जिस पर ऑपरेशन करना है।\n@return सभी अंकों को बार-बार जोड़ने के बाद एकल अंक का परिणाम।\n\nउदाहरण:\naddDigits(38)\nOutput: 2",
      "hu": "Adott egy nem negatív egész szám, num, ismételten add össze az összes számjegyét, amíg az eredmény egyjegyű nem lesz. Add vissza az eredményt.\n\n@param num A nem negatív egész szám, amelyen a műveletet végre kell hajtani.\n@return Az egyjegyű eredmény, miután ismételten összeadtuk az összes számjegyet.\n\nPélda:\naddDigits(38)\nKimenet: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9735932826236978",
      "hy": "0.9547305471191007",
      "bn": "0.9529897504597109",
      "bg": "0.9741482559083093",
      "zh": "0.9951772543484729",
      "fr": "0.9811452097106442",
      "de": "0.9745834550731567",
      "ha": "0.8630117768939549",
      "hi": "0.9411493934462213",
      "hu": "0.9649645802411613"
    }
  },
  {
    "task_id": "Java/40",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n   * The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   *\n   * @param mat The binary matrix.\n   * @return The length of the longest continuous line of 1s.\n   *\n   * Example:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një matricë binare mat me madhësi m x n, kthe gjatësinë e vijës më të gjatë të pandërprerë të 1-shave në matricë.\n   * Vija mund të jetë horizontale, vertikale, diagonale, ose anti-diagonale.\n   *\n   * @param mat Matrica binare.\n   * @return Gjatësia e vijës më të gjatë të pandërprerë të 1-shave.\n   *\n   * Shembull:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է m x n չափսի երկբայնական մատրիցա mat, վերադարձնել մատրիցայում 1-երի ամենաերկար շարունակական գծի երկարությունը:\n   * Գիծը կարող է լինել հորիզոնական, ուղղահայաց, անկյունագծային կամ հակաանկյունագծային:\n   *\n   * @param mat Երկբայնական մատրիցա:\n   * @return 1-երի ամենաերկար շարունակական գծի երկարությունը:\n   *\n   * Օրինակ:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Արդյունք: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "bn": "public class Solution {\n\n  /**\n   * একটি বাইনারি ম্যাট্রিক্স mat দেওয়া হয়েছে যার আকার m x n, ম্যাট্রিক্সে 1s এর দীর্ঘতম অবিচ্ছিন্ন রেখার দৈর্ঘ্য ফেরত দিন।\n   * রেখাটি অনুভূমিক, উল্লম্ব, তির্যক বা বিপরীত তির্যক হতে পারে।\n   *\n   * @param mat বাইনারি ম্যাট্রিক্স।\n   * @return 1s এর দীর্ঘতম অবিচ্ছিন্ন রেখার দৈর্ঘ্য।\n   *\n   * উদাহরণ:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * আউটপুট: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадена е бинарна матрица mat с размер m x n, върнете дължината на най-дългата непрекъсната линия от 1-ци в матрицата.\n   * Линията може да бъде хоризонтална, вертикална, диагонална или анти-диагонална.\n   *\n   * @param mat Бинарната матрица.\n   * @return Дължината на най-дългата непрекъсната линия от 1-ци.\n   *\n   * Пример:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Изход: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个大小为 m x n 的二进制矩阵 mat，返回矩阵中连续 1 的最长线的长度。\n   * 该线可以是水平、垂直、对角线或反对角线。\n   *\n   * @param mat 二进制矩阵。\n   * @return 连续 1 的最长线的长度。\n   *\n   * 示例:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * 输出: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné une matrice binaire mat de taille m x n, renvoie la longueur de la plus longue ligne continue de 1s dans la matrice.\n   * La ligne peut être horizontale, verticale, diagonale ou anti-diagonale.\n   *\n   * @param mat La matrice binaire.\n   * @return La longueur de la plus longue ligne continue de 1s.\n   *\n   * Exemple:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Output: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine binäre Matrix mat der Größe m x n, gib die Länge der längsten kontinuierlichen Linie von 1en in der Matrix zurück.\n   * Die Linie kann horizontal, vertikal, diagonal oder anti-diagonal verlaufen.\n   *\n   * @param mat Die binäre Matrix.\n   * @return Die Länge der längsten kontinuierlichen Linie von 1en.\n   *\n   * Beispiel:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Ausgabe: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da matrix mai lamba biyu mat na girman m x n, dawo da tsawon layin da ya fi tsayi na 1s a cikin matrix.\n   * Layin na iya zama a kwance, tsaye, diagonal, ko anti-diagonal.\n   *\n   * @param mat Matrix mai lamba biyu.\n   * @return Tsawon layin da ya fi tsayi na 1s.\n   *\n   * Misali:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Fitarwa: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए एक बाइनरी मैट्रिक्स mat के आकार m x n में, मैट्रिक्स में 1s की सबसे लंबी सतत रेखा की लंबाई लौटाएं।\n   * रेखा क्षैतिज, लंबवत, विकर्ण, या प्रतिविकर्ण हो सकती है।\n   *\n   * @param mat बाइनरी मैट्रिक्स।\n   * @return 1s की सबसे लंबी सतत रेखा की लंबाई।\n   *\n   * उदाहरण:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * आउटपुट: 3\n   */\n  public static int longestLine(int[][] mat) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy m x n méretű bináris mátrix, mat, adja vissza a leghosszabb folyamatos 1-esekből álló sor hosszát a mátrixban.\n   * A sor lehet vízszintes, függőleges, átlós vagy anti-átlós.\n   *\n   * @param mat A bináris mátrix.\n   * @return A leghosszabb folyamatos 1-esekből álló sor hossza.\n   *\n   * Példa:\n   * longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n   * Kimenet: 3\n   */\n  public static int longestLine(int[][] mat) "
    },
    "prompt_bertscore": {
      "sq": "0.9980967236889237",
      "hy": "0.966010766458072",
      "bn": "0.9851704543823163",
      "bg": "0.9990551152774171",
      "zh": "0.9743377492918166",
      "fr": "0.9990551152774171",
      "de": "0.9990551152774171",
      "ha": "0.9720540958010585",
      "hi": "0.9592746143460359",
      "hu": "0.980637113195957"
    },
    "canonical_solution": "  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }",
    "instruction": {
      "en": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nՏվեք Java կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 символа.",
      "zh": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int longestLine(int[][] mat)\n  {\n    if (mat == null || mat.length == 0 || mat[0].length == 0) {\n      return 0;\n    }\n\n    int maxLine = 0;\n    int m = mat.length;\n    int n = mat[0].length;\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < n; j++) {\n        if (mat[i][j] == 1) {\n          for (int k = 0; k < 4; k++) {\n            dp[i][j][k] = 1;\n          }\n\n          if (j > 0) {\n            dp[i][j][0] += dp[i][j - 1][0]; // Horizontal line\n          }\n          if (i > 0) {\n            dp[i][j][1] += dp[i - 1][j][1]; // Vertical line\n          }\n          if (i > 0 && j > 0) {\n            dp[i][j][2] += dp[i - 1][j - 1][2]; // Diagonal line\n          }\n          if (i > 0 && j < n - 1) {\n            dp[i][j][3] += dp[i - 1][j + 1][3]; // Anti-diagonal line\n          }\n\n          maxLine =\n            Math.max(\n              maxLine,\n              Math.max(\n                Math.max(dp[i][j][0], dp[i][j][1]),\n                Math.max(dp[i][j][2], dp[i][j][3])\n              )\n            );\n        }\n      }\n    }\n\n    return maxLine;\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9465259206000736",
      "bn": "0.9097683754376624",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9666018904720318",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert longestLine(\n      new int[][] {\n        { 1, 1, 0, 0 },\n        { 0, 1, 1, 0 },\n        { 0, 0, 0, 1 },\n        { 1, 0, 0, 0 },\n      }\n    ) ==\n    3;\n    assert longestLine(\n      new int[][] {\n        { 1, 0, 0, 1 },\n        { 0, 1, 1, 0 },\n        { 1, 1, 0, 0 },\n        { 1, 0, 1, 1 },\n      }\n    ) ==\n    4;\n    assert longestLine(new int[][] { { 0, 0, 0 }, { 0, 1, 0 }, { 0, 0, 0 } }) ==\n    1;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "longestLine",
    "signature": "public static int longestLine(int[][] mat)",
    "docstring": {
      "en": "Given a binary matrix mat of size m x n, return the length of the longest continuous line of 1s in the matrix.\n    The line could be horizontal, vertical, diagonal, or anti-diagonal.\n   \n    @param mat The binary matrix.\n    @return The length of the longest continuous line of 1s.\n   \n    Example:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "sq": "Duke pasur një matricë binare mat me madhësi m x n, kthe gjatësinë e vijës më të gjatë të pandërprerë të 1-shave në matricë.\n    Vija mund të jetë horizontale, vertikale, diagonale, ose anti-diagonale.\n   \n    @param mat Matrica binare.\n    @return Gjatësia e vijës më të gjatë të pandërprerë të 1-shave.\n   \n    Shembull:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "hy": "Տրված է երկբային մատրիցա `mat` չափսի m x n, վերադարձնել մատրիցայում ամենաերկար շարունակական 1-երի գծի երկարությունը։ Գիծը կարող է լինել հորիզոնական, ուղղահայաց, անկյունագիծ կամ հակաանկյունագիծ։\n\n@param mat Երկբային մատրիցան։\n@return Ամենաերկար շարունակական 1-երի գծի երկարությունը։\n\nՕրինակ:\nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\nԵլք: 3",
      "bn": "একটি m x n আকারের বাইনারি ম্যাট্রিক্স mat দেওয়া হয়েছে, ম্যাট্রিক্সে 1s এর সবচেয়ে দীর্ঘতর ধারাবাহিক রেখার দৈর্ঘ্য ফেরত দিন।\n    রেখাটি অনুভূমিক, উল্লম্ব, তির্যক, বা বিপরীত তির্যক হতে পারে।\n\n    @param mat বাইনারি ম্যাট্রিক্স।\n    @return 1s এর সবচেয়ে দীর্ঘতর ধারাবাহিক রেখার দৈর্ঘ্য।\n\n    উদাহরণ:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    আউটপুট: 3",
      "bg": "Дадена е двоична матрица mat с размер m x n, върнете дължината на най-дългата непрекъсната линия от 1-ци в матрицата.\n    Линията може да бъде хоризонтална, вертикална, диагонална или анти-диагонална.\n\n@param mat Двоичната матрица.  \n@return Дължината на най-дългата непрекъсната линия от 1-ци.\n\nПример:  \nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})  \nOutput: 3",
      "zh": "给定一个大小为 m x n 的二进制矩阵 mat，返回矩阵中连续 1 的最长线的长度。\n    该线可以是水平的、垂直的、对角线的或反对角线的。\n   \n    @param mat 二进制矩阵。\n    @return 连续 1 的最长线的长度。\n   \n    示例:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    输出: 3",
      "fr": "Étant donné une matrice binaire mat de taille m x n, renvoyer la longueur de la plus longue ligne continue de 1s dans la matrice.  \n    La ligne peut être horizontale, verticale, diagonale ou anti-diagonale.\n   \n    @param mat La matrice binaire.\n    @return La longueur de la plus longue ligne continue de 1s.\n   \n    Exemple:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Sortie: 3",
      "de": "Gegeben eine binäre Matrix mat der Größe m x n, gib die Länge der längsten zusammenhängenden Linie von 1en in der Matrix zurück.\n    Die Linie könnte horizontal, vertikal, diagonal oder anti-diagonal verlaufen.\n   \n    @param mat Die binäre Matrix.\n    @return Die Länge der längsten kontinuierlichen Linie von 1en.\n   \n    Beispiel:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Ausgabe: 3",
      "ha": "An ba da matrix ɗin binary mat mai girman m x n, dawo da tsawon layin ci gaba mafi tsawo na 1s a cikin matrix ɗin.  \nLayin na iya zama a kwance, tsaye, diagonal, ko anti-diagonal.\n\n@param mat Matrix ɗin binary.\n@return Tsawon layin ci gaba mafi tsawo na 1s.\n\nMisali:\nlongestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\nOutput: 3",
      "hi": "दिए गए बाइनरी मैट्रिक्स mat के आकार m x n के लिए, मैट्रिक्स में 1s की सबसे लंबी निरंतर रेखा की लंबाई लौटाएं।\n    रेखा क्षैतिज, लंबवत, विकर्ण, या प्रतिविकर्ण हो सकती है।\n\n    @param mat बाइनरी मैट्रिक्स।\n    @return 1s की सबसे लंबी निरंतर रेखा की लंबाई।\n\n    उदाहरण:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Output: 3",
      "hu": "Adott egy m x n méretű bináris mátrix, mat, térje vissza a leghosszabb folytonos 1-esekből álló vonal hosszát a mátrixban.\n    A vonal lehet vízszintes, függőleges, átlós vagy antidiagonális.\n   \n    @param mat A bináris mátrix.\n    @return Az 1-esekből álló leghosszabb folytonos vonal hossza.\n   \n    Példa:\n    longestLine(new int[][]{{0,1,1,0},{0,1,1,0},{0,0,0,1}})\n    Kimenet: 3"
    },
    "docstring_bertscore": {
      "sq": "0.9970523251454423",
      "hy": "0.9822388685886224",
      "bn": "0.9743256328385734",
      "bg": "0.9972132157540805",
      "zh": "0.9699835727091508",
      "fr": "0.998844169812758",
      "de": "0.9669987539733396",
      "ha": "0.9676885972866737",
      "hi": "0.9915919759707932",
      "hu": "0.9849505705505106"
    }
  },
  {
    "task_id": "Java/41",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   *\n   * @param n The integer to add thousand separators to.\n   * @return The string with thousand separators added.\n   *\n   * Example:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Example:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Example:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Example:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një numër të plotë n, shtoni një pikë ('.') si ndarës mijërash çdo tre shifra dhe ktheni rezultatin si një varg.\n   *\n   * @param n Numri i plotë për të cilin do të shtohen ndarës mijërash.\n   * @return Vargu me ndarës mijërash të shtuar.\n   *\n   * Shembull:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Shembull:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Shembull:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Shembull:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է n ամբողջ թիվը, ավելացրեք կետ ('.') որպես հազարավորների բաժանարար յուրաքանչյուր երեք թվանշանի միջև և վերադարձեք արդյունքը որպես տող:\n   *\n   * @param n Ամբողջ թիվ, որի վրա պետք է ավելացնել հազարավորների բաժանարարներ:\n   * @return Տող, որի վրա ավելացված են հազարավորների բաժանարարներ:\n   *\n   * Օրինակ:\n   * addThousandSeparator(987)\n   * Արդյունք: \"987\"\n   *\n   * Օրինակ:\n   * addThousandSeparator(1234)\n   * Արդյունք: \"1.234\"\n   *\n   * Օրինակ:\n   * addThousandSeparator(123456789)\n   * Արդյունք: \"123.456.789\"\n   *\n   * Օրինակ:\n   * addThousandSeparator(0)\n   * Արդյունք: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "bn": "public class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যা n দেওয়া হলে, প্রতিটি তিনটি অঙ্কের পর একটি ডট ('.') যোগ করুন এবং ফলাফলটি একটি স্ট্রিং হিসাবে ফেরত দিন।\n   *\n   * @param n যে পূর্ণসংখ্যাটিতে হাজার বিভাজক যোগ করতে হবে।\n   * @return স্ট্রিং যা হাজার বিভাজক সহ যোগ করা হয়েছে।\n   *\n   * উদাহরণ:\n   * addThousandSeparator(987)\n   * আউটপুট: \"987\"\n   *\n   * উদাহরণ:\n   * addThousandSeparator(1234)\n   * আউটপুট: \"1.234\"\n   *\n   * উদাহরণ:\n   * addThousandSeparator(123456789)\n   * আউটপুট: \"123.456.789\"\n   *\n   * উদাহরণ:\n   * addThousandSeparator(0)\n   * আউটপুট: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Като се даде цяло число n, добавете точка ('.') като разделител на хиляди на всеки три цифри и върнете резултата като низ.\n   *\n   * @param n Цялото число, към което ще се добавят разделители на хиляди.\n   * @return Низът с добавени разделители на хиляди.\n   *\n   * Пример:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Пример:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Пример:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Пример:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个整数 n，每三位数字添加一个点（'.'）作为千位分隔符，并将结果作为字符串返回。\n   *\n   * @param n 要添加千位分隔符的整数。\n   * @return 添加了千位分隔符的字符串。\n   *\n   * 示例:\n   * addThousandSeparator(987)\n   * 输出: \"987\"\n   *\n   * 示例:\n   * addThousandSeparator(1234)\n   * 输出: \"1.234\"\n   *\n   * 示例:\n   * addThousandSeparator(123456789)\n   * 输出: \"123.456.789\"\n   *\n   * 示例:\n   * addThousandSeparator(0)\n   * 输出: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné un entier n, ajoutez un point ('.') comme séparateur de milliers tous les trois chiffres et renvoyez le résultat sous forme de chaîne.\n   *\n   * @param n L'entier auquel ajouter des séparateurs de milliers.\n   * @return La chaîne avec les séparateurs de milliers ajoutés.\n   *\n   * Exemple:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Exemple:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Exemple:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Exemple:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine ganze Zahl n, füge einen Punkt ('.') als Tausendertrennzeichen alle drei Ziffern hinzu und gib das Ergebnis als Zeichenkette zurück.\n   *\n   * @param n Die ganze Zahl, der Tausendertrennzeichen hinzugefügt werden sollen.\n   * @return Die Zeichenkette mit hinzugefügten Tausendertrennzeichen.\n   *\n   * Beispiel:\n   * addThousandSeparator(987)\n   * Ausgabe: \"987\"\n   *\n   * Beispiel:\n   * addThousandSeparator(1234)\n   * Ausgabe: \"1.234\"\n   *\n   * Beispiel:\n   * addThousandSeparator(123456789)\n   * Ausgabe: \"123.456.789\"\n   *\n   * Beispiel:\n   * addThousandSeparator(0)\n   * Ausgabe: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * An ba da wani lamba n, ƙara wata doka ('.') a matsayin mai raba dubu kowane lambobi uku kuma mayar da sakamakon a matsayin kirtani.\n   *\n   * @param n Lambar da za a ƙara masu raba dubu.\n   * @return Kirtani tare da masu raba dubu da aka ƙara.\n   *\n   * Misali:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * Misali:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * Misali:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * Misali:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए पूर्णांक n के लिए, हर तीन अंकों के बाद एक डॉट ('.') जोड़ें और परिणाम को एक स्ट्रिंग के रूप में लौटाएं।\n   *\n   * @param n वह पूर्णांक जिसमें हजारों विभाजक जोड़ने हैं।\n   * @return वह स्ट्रिंग जिसमें हजारों विभाजक जोड़े गए हैं।\n   *\n   * उदाहरण:\n   * addThousandSeparator(987)\n   * Output: \"987\"\n   *\n   * उदाहरण:\n   * addThousandSeparator(1234)\n   * Output: \"1.234\"\n   *\n   * उदाहरण:\n   * addThousandSeparator(123456789)\n   * Output: \"123.456.789\"\n   *\n   * उदाहरण:\n   * addThousandSeparator(0)\n   * Output: \"0\"\n   */\n  public static String addThousandSeparator(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy egész szám n, adjunk hozzá egy pontot ('.') ezres elválasztóként minden három számjegy után, és az eredményt adjuk vissza sztringként.\n   *\n   * @param n Az egész szám, amelyhez ezres elválasztókat kell hozzáadni.\n   * @return A sztring, amelyhez hozzá lettek adva az ezres elválasztók.\n   *\n   * Példa:\n   * addThousandSeparator(987)\n   * Kimenet: \"987\"\n   *\n   * Példa:\n   * addThousandSeparator(1234)\n   * Kimenet: \"1.234\"\n   *\n   * Példa:\n   * addThousandSeparator(123456789)\n   * Kimenet: \"123.456.789\"\n   *\n   * Példa:\n   * addThousandSeparator(0)\n   * Kimenet: \"0\"\n   */\n  public static String addThousandSeparator(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9826947253130974",
      "hy": "0.9606842941602405",
      "bn": "0.9694963323844722",
      "bg": "0.982863362506596",
      "zh": "0.9653286697295982",
      "fr": "0.9828854104788909",
      "de": "0.9785771175142443",
      "ha": "0.9752631682370582",
      "hi": "0.9769032592932632",
      "hu": "0.9668897058941514"
    },
    "canonical_solution": "  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }",
    "instruction": {
      "en": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nনিচের জাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Java a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static String addThousandSeparator(int n)\n  {\n    StringBuilder result = new StringBuilder();\n    String numberString = Integer.toString(n);\n    int length = numberString.length();\n    int counter = 0;\n\n    for (int i = length - 1; i >= 0; i--) {\n      result.append(numberString.charAt(i));\n      counter++;\n      if (counter == 3 && i != 0) {\n        result.append('.');\n        counter = 0;\n      }\n    }\n\n    return result.reverse().toString();\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9395667065701353",
      "hy": "0.9222586510578982",
      "bn": "0.8712875130893925",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9168968225522425",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert \"2.147.483.647\".equals(\n        addThousandSeparator(2147483647)\n      ) : \"Test case 1 failed\";\n    assert \"10.000\".equals(addThousandSeparator(10000)) : \"Test case 2 failed\";\n    assert \"999\".equals(addThousandSeparator(999)) : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "addThousandSeparator",
    "signature": "public static String addThousandSeparator(int n)",
    "docstring": {
      "en": "Given an integer n, add a dot ('.') as a thousand separator every three digits and return the result as a string.\n   \n    @param n The integer to add thousand separators to.\n    @return The string with thousand separators added.\n   \n    Example:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Example:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Example:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Example:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "sq": "Duke pasur një numër të plotë n, shtoni një pikë ('.') si një ndarës mijërash çdo tre shifra dhe ktheni rezultatin si një varg.\n   \n    @param n Numri i plotë për të cilin do të shtohen ndarës mijërash.\n    @return Vargu me ndarës mijërash të shtuar.\n\n    Shembull:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    Shembull:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    Shembull:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    Shembull:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "hy": "Տրված է n ամբողջ թիվը, ավելացնել կետ ('.') որպես հազարավոր բաժանարար յուրաքանչյուր երեք թվանշանից հետո և վերադարձնել արդյունքը որպես տող։\n   \n    @param n Ամբողջ թիվը, որին պետք է ավելացնել հազարավոր բաժանարարներ։\n    @return Տողը, որում ավելացված են հազարավոր բաժանարարներ։\n\n    Օրինակ:\n    addThousandSeparator(987)\n    Արդյունք: \"987\"\n\n    Օրինակ:\n    addThousandSeparator(1234)\n    Արդյունք: \"1.234\"\n\n    Օրինակ:\n    addThousandSeparator(123456789)\n    Արդյունք: \"123.456.789\"\n\n    Օրինակ:\n    addThousandSeparator(0)\n    Արդյունք: \"0\"",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, প্রতি তিনটি অঙ্কের পর একটি ডট ('.') যোগ করুন এবং ফলাফলটি একটি স্ট্রিং হিসাবে ফেরত দিন।\n   \n    @param n যে পূর্ণসংখ্যায় হাজার বিভাজক যোগ করতে হবে।\n    @return স্ট্রিং যা হাজার বিভাজক যোগ করার পর ফেরত দেওয়া হবে।\n\n    উদাহরণ:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    উদাহরণ:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    উদাহরণ:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    উদাহরণ:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "bg": "Дадено е цяло число n, добавете точка ('.') като разделител за хиляди на всеки три цифри и върнете резултата като низ.\n   \n    @param n Цялото число, към което да се добавят разделители за хиляди.\n    @return Низът с добавени разделители за хиляди.\n   \n    Пример:\n    addThousandSeparator(987)\n    Изход: \"987\"\n   \n    Пример:\n    addThousandSeparator(1234)\n    Изход: \"1.234\"\n   \n    Пример:\n    addThousandSeparator(123456789)\n    Изход: \"123.456.789\"\n   \n    Пример:\n    addThousandSeparator(0)\n    Изход: \"0\"",
      "zh": "给定一个整数 n，每三位数字添加一个点（'.'）作为千位分隔符，并将结果作为字符串返回。\n   \n    @param n 要添加千位分隔符的整数。\n    @return 添加了千位分隔符的字符串。\n   \n    示例:\n    addThousandSeparator(987)\n    输出: \"987\"\n   \n    示例:\n    addThousandSeparator(1234)\n    输出: \"1.234\"\n   \n    示例:\n    addThousandSeparator(123456789)\n    输出: \"123.456.789\"\n   \n    示例:\n    addThousandSeparator(0)\n    输出: \"0\"",
      "fr": "Étant donné un entier n, ajoutez un point ('.') comme séparateur de milliers tous les trois chiffres et renvoyez le résultat sous forme de chaîne de caractères.\n   \n    @param n L'entier auquel ajouter des séparateurs de milliers.\n    @return La chaîne de caractères avec les séparateurs de milliers ajoutés.\n   \n    Exemple:\n    addThousandSeparator(987)\n    Sortie: \"987\"\n   \n    Exemple:\n    addThousandSeparator(1234)\n    Sortie: \"1.234\"\n   \n    Exemple:\n    addThousandSeparator(123456789)\n    Sortie: \"123.456.789\"\n   \n    Exemple:\n    addThousandSeparator(0)\n    Sortie: \"0\"",
      "de": "Gegeben eine ganze Zahl n, füge einen Punkt ('.') als Tausendertrennzeichen alle drei Ziffern hinzu und gib das Ergebnis als Zeichenkette zurück.\n   \n    @param n Die ganze Zahl, der Tausendertrennzeichen hinzugefügt werden sollen.\n    @return Der String mit hinzugefügten Tausendertrennzeichen.\n\n    Beispiel:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    Beispiel:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    Beispiel:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    Beispiel:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "ha": "An ba da wani lamba n, ƙara wata doka ('.') a matsayin mai raba dubu kowane lambobi uku kuma dawo da sakamakon a matsayin kirtani.\n   \n    @param n Lambar cikakke da za a kara masu raba dubu.\n    @return Kirtani tare da masu raba dubu da aka kara.\n\n    Misali:\n    addThousandSeparator(987)\n    Output: \"987\"\n   \n    Misali:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n   \n    Misali:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n   \n    Misali:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "hi": "दिए गए पूर्णांक n के लिए, हर तीन अंकों के बाद एक डॉट ('.') को हजारों विभाजक के रूप में जोड़ें और परिणाम को एक स्ट्रिंग के रूप में लौटाएं।\n   \n    @param n वह पूर्णांक जिसमें हजारों विभाजक जोड़ना है।\n    @return वह स्ट्रिंग जिसमें हजारों विभाजक जोड़े गए हैं।\n\n    उदाहरण:\n    addThousandSeparator(987)\n    Output: \"987\"\n\n    उदाहरण:\n    addThousandSeparator(1234)\n    Output: \"1.234\"\n\n    उदाहरण:\n    addThousandSeparator(123456789)\n    Output: \"123.456.789\"\n\n    उदाहरण:\n    addThousandSeparator(0)\n    Output: \"0\"",
      "hu": "Adott egy egész szám n, adjunk hozzá egy pontot ('.') ezres elválasztóként minden három számjegy után, és az eredményt adjuk vissza sztringként.\n   \n    @param n Az egész szám, amelyhez ezres elválasztókat kell hozzáadni.\n    @return A sztring, amelyhez hozzá lettek adva az ezres elválasztók.\n   \n    Példa:\n    addThousandSeparator(987)\n    Kimenet: \"987\"\n   \n    Példa:\n    addThousandSeparator(1234)\n    Kimenet: \"1.234\"\n   \n    Példa:\n    addThousandSeparator(123456789)\n    Kimenet: \"123.456.789\"\n   \n    Példa:\n    addThousandSeparator(0)\n    Kimenet: \"0\""
    },
    "docstring_bertscore": {
      "sq": "0.9803935923488083",
      "hy": "0.9509313438210464",
      "bn": "0.9610726165551636",
      "bg": "0.9815676965311054",
      "zh": "0.9595469365984347",
      "fr": "0.9729838846146828",
      "de": "0.9686593039587912",
      "ha": "0.9698943876680661",
      "hi": "0.9640196955185782",
      "hu": "0.9625641320863546"
    }
  },
  {
    "task_id": "Java/42",
    "prompt": {
      "en": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n   * Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   *\n   * @param A The input non-negative integer array.\n   * @return The number of square permutations of A.\n   *\n   * Example:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Example:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "sq": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Duke pasur një varg të numrave të plotë jo-negativ A, nëse shuma e çdo çifti të elementeve ngjitur në varg është një katror perfekt, atëherë vargu konsiderohet si një varg katror.\n   * Kthe numrin e permutacioneve katrore të A. Dy permutacione A1 dhe A2 konsiderohen të ndryshme nëse ekziston një indeks i tillë që A1[i] != A2[i].\n   *\n   * @param A Vargu hyrës i numrave të plotë jo-negativ.\n   * @return Numri i permutacioneve katrore të A.\n   *\n   * Shembull:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Shembull:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "hy": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Տրված է ոչ բացասական ամբողջ թվերի զանգված A, եթե զանգվածի հարակից տարրերի զույգերի գումարը կատարյալ քառակուսի է, ապա զանգվածը համարվում է քառակուսի զանգված:\n   * Վերադարձնում է A-ի քառակուսի փոխատեղումների քանակը: Երկու փոխատեղումներ A1 և A2 համարվում են տարբեր, եթե գոյություն ունի i ինդեքս, այնպես որ A1[i] != A2[i]:\n   *\n   * @param A Մուտքային ոչ բացասական ամբողջ թվերի զանգվածը:\n   * @return A-ի քառակուսի փոխատեղումների քանակը:\n   *\n   * Օրինակ:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Արդյունք: 2\n   *\n   * Օրինակ:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Արդյունք: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "bn": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * একটি অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে A দেওয়া হলে, যদি অ্যারের প্রতিটি সংলগ্ন উপাদান জোড়ার যোগফল একটি নিখুঁত বর্গ হয়, তবে অ্যারেটিকে একটি বর্গাকার অ্যারে হিসাবে বিবেচনা করা হয়।\n   * A এর বর্গাকার বিন্যাসের সংখ্যা ফেরত দিন। দুটি বিন্যাস A1 এবং A2 কে ভিন্ন হিসাবে বিবেচনা করা হয় যদি এমন একটি সূচক i থাকে যার জন্য A1[i] != A2[i]।\n   *\n   * @param A ইনপুট অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে।\n   * @return A এর বর্গাকার বিন্যাসের সংখ্যা।\n   *\n   * উদাহরণ:\n   * squarePermutations(new int[]{1, 17, 8})\n   * আউটপুট: 2\n   *\n   * উদাহরণ:\n   * squarePermutations(new int[]{2, 2, 2})\n   * আউটপুট: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "bg": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Даден е масив от неотрицателни цели числа A, ако сумата на всяка двойка съседни елементи в масива е точен квадрат, тогава масивът се счита за квадратен масив.\n   * Върнете броя на квадратните пермутации на A. Две пермутации A1 и A2 се считат за различни, ако съществува индекс i, такъв че A1[i] != A2[i].\n   *\n   * @param A Входният масив от неотрицателни цели числа.\n   * @return Броят на квадратните пермутации на A.\n   *\n   * Пример:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Изход: 2\n   *\n   * Пример:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Изход: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "zh": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * 给定一个非负整数数组A，如果数组中每对相邻元素的和是一个完全平方数，则该数组被认为是一个平方数组。\n   * 返回A的平方排列的数量。如果存在一个索引i使得A1[i] != A2[i]，则两个排列A1和A2被认为是不同的。\n   *\n   * @param A 输入的非负整数数组。\n   * @return A的平方排列的数量。\n   *\n   * 示例:\n   * squarePermutations(new int[]{1, 17, 8})\n   * 输出: 2\n   *\n   * 示例:\n   * squarePermutations(new int[]{2, 2, 2})\n   * 输出: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "fr": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Étant donné un tableau d'entiers non négatifs A, si la somme de chaque paire d'éléments adjacents dans le tableau est un carré parfait, alors le tableau est considéré comme un tableau carré.\n   * Retourne le nombre de permutations carrées de A. Deux permutations A1 et A2 sont considérées différentes s'il existe un indice i tel que A1[i] != A2[i].\n   *\n   * @param A Le tableau d'entiers non négatifs en entrée.\n   * @return Le nombre de permutations carrées de A.\n   *\n   * Exemple :\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Exemple :\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "de": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Gegeben ein nicht-negatives Ganzzahl-Array A, wenn die Summe jedes Paares benachbarter Elemente im Array ein perfektes Quadrat ist, dann wird das Array als Quadrat-Array betrachtet.\n   * Gib die Anzahl der quadratischen Permutationen von A zurück. Zwei Permutationen A1 und A2 werden als unterschiedlich betrachtet, wenn es einen Index i gibt, so dass A1[i] != A2[i].\n   *\n   * @param A Das Eingabe-Array nicht-negativer Ganzzahlen.\n   * @return Die Anzahl der quadratischen Permutationen von A.\n   *\n   * Beispiel:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Beispiel:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "ha": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * An ba da wani baƙi mai kyau wanda ba shi da kyau A, idan jumlar kowane ma'aurata na abubuwan da ke kusa a cikin jerin ya zama cikakken murabba'i, to ana ɗaukar jerin a matsayin jerin murabba'i.\n   * Mayar da adadin permutations na murabba'i na A. Ana ɗaukar permutations guda biyu A1 da A2 daban idan akwai wani index i wanda A1[i] != A2[i].\n   *\n   * @param A Shigar da baƙi mai kyau wanda ba shi da kyau.\n   * @return Adadin permutations na murabba'i na A.\n   *\n   * Misali:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Output: 2\n   *\n   * Misali:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Output: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "hi": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * दिए गए गैर-ऋणात्मक पूर्णांक सरणी A, यदि सरणी में प्रत्येक समवर्ती तत्वों की जोड़ी का योग एक पूर्ण वर्ग है, तो सरणी को एक वर्ग सरणी माना जाता है।\n   * A के वर्ग क्रमचयों की संख्या लौटाएँ। दो क्रमचय A1 और A2 को भिन्न माना जाता है यदि कोई ऐसा सूचकांक i मौजूद है जिसके लिए A1[i] != A2[i] हो।\n   *\n   * @param A इनपुट गैर-ऋणात्मक पूर्णांक सरणी।\n   * @return A के वर्ग क्रमचयों की संख्या।\n   *\n   * उदाहरण:\n   * squarePermutations(new int[]{1, 17, 8})\n   * आउटपुट: 2\n   *\n   * उदाहरण:\n   * squarePermutations(new int[]{2, 2, 2})\n   * आउटपुट: 1\n   */\n  public static int squarePermutations(int[] A) ",
      "hu": "import java.util.HashSet;\nimport java.util.Set;\n\npublic class Solution {\n\n  /**\n   * Adott egy nemnegatív egész számokat tartalmazó tömb A, ha a tömb minden szomszédos elempárjának összege tökéletes négyzet, akkor a tömb négyzet tömbnek tekinthető.\n   * Adja vissza A négyzet permutációinak számát. Két permutáció A1 és A2 különbözőnek tekintendő, ha létezik egy i index, amelyre A1[i] != A2[i].\n   *\n   * @param A A bemeneti nemnegatív egész számokat tartalmazó tömb.\n   * @return A négyzet permutációinak száma A esetén.\n   *\n   * Példa:\n   * squarePermutations(new int[]{1, 17, 8})\n   * Kimenet: 2\n   *\n   * Példa:\n   * squarePermutations(new int[]{2, 2, 2})\n   * Kimenet: 1\n   */\n  public static int squarePermutations(int[] A) "
    },
    "prompt_bertscore": {
      "sq": "0.9864629422717103",
      "hy": "0.9657865127578836",
      "bn": "0.966699616619501",
      "bg": "0.9886371504225182",
      "zh": "0.9764287313129708",
      "fr": "0.9888417397149841",
      "de": "0.9942923560009624",
      "ha": "0.9898130422782447",
      "hi": "0.971003936976527",
      "hu": "0.973070288830433"
    },
    "canonical_solution": "  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }",
    "instruction": {
      "en": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nՏվյալ Java կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\n请用不超过500个字符的中文为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int squarePermutations(int[] A)\n  {\n    Set<String> permutations = new HashSet<>();\n    permute(A, 0, permutations);\n    return permutations.size();\n  }\n\n  private static void permute(int[] arr, int start, Set<String> permutations) {\n    if (start == arr.length) {\n      if (isSquareArray(arr)) {\n        permutations.add(arrayToString(arr));\n      }\n      return;\n    }\n\n    for (int i = start; i < arr.length; i++) {\n      swap(arr, i, start);\n      permute(arr, start + 1, permutations);\n      swap(arr, i, start);\n    }\n  }\n\n  private static boolean isSquareArray(int[] arr) {\n    for (int i = 0; i < arr.length - 1; i++) {\n      if (!isPerfectSquare(arr[i] + arr[i + 1])) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private static boolean isPerfectSquare(int num) {\n    int sqrt = (int) Math.sqrt(num);\n    return num == sqrt * sqrt;\n  }\n\n  private static void swap(int[] arr, int i, int j) {\n    int temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static String arrayToString(int[] arr) {\n    StringBuilder sb = new StringBuilder();\n    for (int num : arr) {\n      sb.append(num).append(\",\");\n    }\n    return sb.toString();\n  }\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.8847604132046079",
      "bn": "0.9238701393392342",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9406516257113479",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert squarePermutations(new int[] { 1, 8, 27 }) == 0;\n    assert squarePermutations(new int[] { 1, 8, 17 }) == 2;\n    assert squarePermutations(new int[] { 4, 1, 3, 0, 2 }) == 0;\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "squarePermutations",
    "signature": "public static int squarePermutations(int[] A)",
    "docstring": {
      "en": "Given a non-negative integer array A, if the sum of each pair of adjacent elements in the array is a perfect square, then the array is considered a square array.\n    Return the number of square permutations of A. Two permutations A1 and A2 are considered different if there exists an index i such that A1[i] != A2[i].\n   \n    @param A The input non-negative integer array.\n    @return The number of square permutations of A.\n   \n    Example:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Example:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "sq": "Given një varg të numrave të plotë jo-negativ A, nëse shuma e secilit çift elementësh ngjitur në varg është një katror perfekt, atëherë vargu konsiderohet si një varg katror.\n    Kthe numrin e permutacioneve katrore të A. Dy permutacione A1 dhe A2 konsiderohen të ndryshme nëse ekziston një indeks i tillë që A1[i] != A2[i].\n   \n    @param A Vargu hyrës i numrave të plotë jo-negativ.\n    @return Numri i permutacioneve katrore të A.\n   \n    Shembull:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Shembull:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "hy": "Տրված է ոչ բացասական ամբողջ թվերի զանգված A, եթե զանգվածի հարակից տարրերի զույգերի գումարը կատարյալ քառակուսի է, ապա զանգվածը համարվում է քառակուսի զանգված։ \n    Վերադարձնել A-ի քառակուսի փոխատեղումների քանակը։ Երկու փոխատեղումներ A1 և A2 համարվում են տարբեր, եթե գոյություն ունի i ինդեքս, որի դեպքում A1[i] != A2[i]։\n\n    @param A Մուտքային ոչ բացասական ամբողջ թվերի զանգվածը։\n    @return A-ի քառակուսի փոխատեղումների քանակը։\n\n    Օրինակ:\n    squarePermutations(new int[]{1, 17, 8})\n    Արդյունք: 2\n\n    Օրինակ:\n    squarePermutations(new int[]{2, 2, 2})\n    Արդյունք: 1",
      "bn": "প্রদত্ত একটি অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে A, যদি অ্যারেতে প্রতিটি সন্নিহিত উপাদানের জোড়ার যোগফল একটি পূর্ণবর্গ হয়, তবে অ্যারেটিকে একটি বর্গাকার অ্যারে হিসেবে বিবেচনা করা হয়। \n    A এর বর্গাকার বিন্যাসের সংখ্যা ফেরত দিন। দুটি বিন্যাস A1 এবং A2 কে ভিন্ন বিবেচনা করা হয় যদি এমন একটি সূচক i থাকে যাতে A1[i] != A2[i] হয়।\n\n    @param A ইনপুট অ-ঋণাত্মক পূর্ণসংখ্যার অ্যারে।\n    @return A এর বর্গাকার বিন্যাসের সংখ্যা।\n\n    উদাহরণ:\n    squarePermutations(new int[]{1, 17, 8})\n    আউটপুট: 2\n\n    উদাহরণ:\n    squarePermutations(new int[]{2, 2, 2})\n    আউটপুট: 1",
      "bg": "Даден е масив от неотрицателни цели числа A, ако сумата на всяка двойка съседни елементи в масива е точен квадрат, тогава масивът се счита за квадратен масив.\n    Върнете броя на квадратните пермутации на A. Две пермутации A1 и A2 се считат за различни, ако съществува индекс i такъв, че A1[i] != A2[i].\n   \n    @param A Входният масив от неотрицателни цели числа.\n    @return Броят на квадратните пермутации на A.\n   \n    Пример:\n    squarePermutations(new int[]{1, 17, 8})\n    Output: 2\n   \n    Пример:\n    squarePermutations(new int[]{2, 2, 2})\n    Output: 1",
      "zh": "给定一个非负整数数组A，如果数组中每对相邻元素的和是一个完全平方数，则该数组被认为是一个平方数组。\n    返回A的平方排列的数量。如果存在一个索引i使得A1[i] != A2[i]，则两个排列A1和A2被认为是不同的。\n   \n    @param A 输入的非负整数数组。\n    @return A的平方排列的数量。\n   \n    示例:\n    squarePermutations(new int[]{1, 17, 8})\n    输出: 2\n   \n    示例:\n    squarePermutations(new int[]{2, 2, 2})\n    输出: 1",
      "fr": "Étant donné un tableau d'entiers non négatifs A, si la somme de chaque paire d'éléments adjacents dans le tableau est un carré parfait, alors le tableau est considéré comme un tableau carré.\n    Retourne le nombre de permutations carrées de A. Deux permutations A1 et A2 sont considérées différentes s'il existe un indice i tel que A1[i] != A2[i].\n   \n    @param A Le tableau d'entiers non négatifs d'entrée.\n    @return Le nombre de permutations carrées de A.\n   \n    Exemple:\n    squarePermutations(new int[]{1, 17, 8})\n    Sortie: 2\n   \n    Exemple:\n    squarePermutations(new int[]{2, 2, 2})\n    Sortie: 1",
      "de": "Gegeben ein nicht-negatives Integer-Array A, wenn die Summe jedes Paares benachbarter Elemente im Array ein perfektes Quadrat ist, dann wird das Array als Quadrat-Array betrachtet.\n    Geben Sie die Anzahl der quadratischen Permutationen von A zurück. Zwei Permutationen A1 und A2 werden als unterschiedlich betrachtet, wenn es einen Index i gibt, sodass A1[i] != A2[i].\n\n    @param A Das Eingabe-Array nicht-negativer Ganzzahlen.\n    @return Die Anzahl der quadratischen Permutationen von A.\n\n    Beispiel:\n    squarePermutations(new int[]{1, 17, 8})\n    Ausgabe: 2\n\n    Beispiel:\n    squarePermutations(new int[]{2, 2, 2})\n    Ausgabe: 1",
      "ha": "An ba da jerin lambobi marasa kyau A, idan jumlar kowanne ma'aurata na abubuwan da ke makwabtaka a cikin jerin lambobin ta kasance cikakken murabba'i, to ana ɗaukar jerin lambobin a matsayin jerin murabba'i.\n    Mayar da adadin permutations na murabba'i na A. Ana ɗaukar permutations A1 da A2 daban idan akwai wani index i wanda A1[i] != A2[i].\n   \n    @param A Jerin lambobi marasa kyau na shigarwa.\n    @return Adadin permutations na murabba'i na A.\n   \n    Misali:\n    squarePermutations(new int[]{1, 17, 8})\n    Fitarwa: 2\n   \n    Misali:\n    squarePermutations(new int[]{2, 2, 2})\n    Fitarwa: 1",
      "hi": "दी गई एक गैर-ऋणात्मक पूर्णांक सरणी A के लिए, यदि सरणी में प्रत्येक समीपवर्ती तत्वों की जोड़ी का योग एक पूर्ण वर्ग है, तो सरणी को एक वर्ग सरणी माना जाता है। \n    A के वर्ग क्रमचयों की संख्या लौटाएं। दो क्रमचय A1 और A2 को अलग माना जाता है यदि कोई ऐसा सूचकांक i मौजूद हो जिसके लिए A1[i] != A2[i] हो।\n\n    @param A इनपुट गैर-ऋणात्मक पूर्णांक सरणी।\n    @return A के वर्ग क्रमचयों की संख्या।\n\n    उदाहरण:\n    squarePermutations(new int[]{1, 17, 8})\n    आउटपुट: 2\n\n    उदाहरण:\n    squarePermutations(new int[]{2, 2, 2})\n    आउटपुट: 1",
      "hu": "Adott egy nemnegatív egész számokat tartalmazó tömb, A, ha a tömb szomszédos elemeinek összege tökéletes négyzet, akkor a tömb négyzet tömbnek tekinthető.\n    Visszaadja A négyzet permutációinak számát. Két permutáció, A1 és A2 különbözőnek tekinthető, ha létezik egy i index, amelyre A1[i] != A2[i].\n   \n    @param A A bemeneti nemnegatív egész számokat tartalmazó tömb.\n    @return A négyzet permutációinak száma A-ból.\n   \n    Példa:\n    squarePermutations(new int[]{1, 17, 8})\n    Kimenet: 2\n   \n    Példa:\n    squarePermutations(new int[]{2, 2, 2})\n    Kimenet: 1"
    },
    "docstring_bertscore": {
      "sq": "0.9812622030050738",
      "hy": "0.9727697610639272",
      "bn": "0.9629186873165019",
      "bg": "0.9844547891194476",
      "zh": "0.9659984513744478",
      "fr": "0.9804595376353118",
      "de": "0.9931164641452359",
      "ha": "0.9411716400488972",
      "hi": "0.9743047766485647",
      "hu": "0.957874468790121"
    }
  },
  {
    "task_id": "Java/43",
    "prompt": {
      "en": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Given n non-negative integers representing the heights of bars in a bar chart.\n   * Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   *\n   * @param heights An array of integers representing the heights of bars.\n   * @return The maximum area of the rectangle that can be formed.\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Example:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "sq": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Duke pasur parasysh n numra të plotë jo-negativë që përfaqësojnë lartësitë e shufrave në një grafik shufrash.\n   * Çdo shufër ka një gjerësi prej 1 njësie. Llogaritni sipërfaqen më të madhe të drejtkëndëshit që mund të formohet në grafik shufrash.\n   *\n   * @param heights Një varg numrash të plotë që përfaqësojnë lartësitë e shufrave.\n   * @return Sipërfaqja maksimale e drejtkëndëshit që mund të formohet.\n   *\n   * Shembull:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Shembull:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "hy": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Տրված է n ոչ բացասական ամբողջ թվեր, որոնք ներկայացնում են սյուների բարձրությունները սյունակազմում:\n   * Յուրաքանչյուր սյուն ունի 1 միավոր լայնություն: Հաշվեք ամենամեծ ուղղանկյուն տարածքը, որը կարող է ձևավորվել սյունակազմում:\n   *\n   * @param heights Սյուների բարձրությունները ներկայացնող ամբողջ թվերի զանգված:\n   * @return Ուղղանկյան առավելագույն տարածքը, որը կարող է ձևավորվել:\n   *\n   * Օրինակ:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Արդյունք: 10\n   *\n   * Օրինակ:\n   * largestRectangleArea(new int[]{2,4})\n   * Արդյունք: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "bn": "import java.util.*;\npublic class Solution {\n\n  /**\n   * n টি অ-ঋণাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে যা একটি বার চার্টে বারগুলির উচ্চতা উপস্থাপন করে।\n   * প্রতিটি বারের প্রস্থ 1 ইউনিট। বার চার্টে গঠিত হতে পারে এমন বৃহত্তম আয়তক্ষেত্রের ক্ষেত্রফল হিসাব করুন।\n   *\n   * @param heights একটি পূর্ণসংখ্যার অ্যারে যা বারগুলির উচ্চতা উপস্থাপন করে।\n   * @return আয়তক্ষেত্রের সর্বাধিক ক্ষেত্রফল যা গঠিত হতে পারে।\n   *\n   * উদাহরণ:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * উদাহরণ:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "bg": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Дадени са n неотрицателни цели числа, представляващи височините на пръчките в диаграма с пръчки.\n   * Всяка пръчка има ширина от 1 единица. Изчислете най-голямата площ на правоъгълник, която може да бъде образувана в диаграмата с пръчки.\n   *\n   * @param heights Масив от цели числа, представляващи височините на пръчките.\n   * @return Максималната площ на правоъгълника, която може да бъде образувана.\n   *\n   * Пример:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Пример:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "zh": "import java.util.*;\npublic class Solution {\n\n  /**\n   * 给定 n 个非负整数，表示柱状图中柱子的高度。\n   * 每个柱子的宽度为 1 单位。计算可以在柱状图中形成的最大矩形面积。\n   *\n   * @param heights 一个整数数组，表示柱子的高度。\n   * @return 可以形成的矩形的最大面积。\n   *\n   * 示例:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * 输出: 10\n   *\n   * 示例:\n   * largestRectangleArea(new int[]{2,4})\n   * 输出: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "fr": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Étant donné n entiers non négatifs représentant les hauteurs des barres dans un histogramme.\n   * Chaque barre a une largeur de 1 unité. Calculer la plus grande aire de rectangle qui peut être formée dans l'histogramme.\n   *\n   * @param heights Un tableau d'entiers représentant les hauteurs des barres.\n   * @return L'aire maximale du rectangle qui peut être formée.\n   *\n   * Exemple:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Exemple:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "de": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Gegeben sind n nicht-negative ganze Zahlen, die die Höhen von Balken in einem Balkendiagramm darstellen.\n   * Jeder Balken hat eine Breite von 1 Einheit. Berechne die größte Rechteckfläche, die im Balkendiagramm gebildet werden kann.\n   *\n   * @param heights Ein Array von ganzen Zahlen, das die Höhen der Balken darstellt.\n   * @return Die maximale Fläche des Rechtecks, das gebildet werden kann.\n   *\n   * Beispiel:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Ausgabe: 10\n   *\n   * Beispiel:\n   * largestRectangleArea(new int[]{2,4})\n   * Ausgabe: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "ha": "import java.util.*;\npublic class Solution {\n\n  /**\n   * An ba da n lambobi marasa kyau waɗanda ke wakiltar tsayin sanduna a cikin ginshiƙi.\n   * Kowace sanda tana da faɗin naúrar 1. Lissafa mafi girman yankin murabba'i da za a iya samarwa a cikin ginshiƙi.\n   *\n   * @param heights Jeren lambobi da ke wakiltar tsayin sanduna.\n   * @return Mafi girman yankin murabba'i da za a iya samarwa.\n   *\n   * Misali:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * Misali:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "hi": "import java.util.*;\npublic class Solution {\n\n  /**\n   * n गैर-ऋणात्मक पूर्णांकों को दिया गया है जो एक बार चार्ट में बार की ऊँचाई का प्रतिनिधित्व करते हैं।\n   * प्रत्येक बार की चौड़ाई 1 इकाई है। बार चार्ट में बनने वाले सबसे बड़े आयत क्षेत्र की गणना करें।\n   *\n   * @param heights पूर्णांकों की एक array जो बार की ऊँचाई का प्रतिनिधित्व करती है।\n   * @return आयत का अधिकतम क्षेत्रफल जो बनाया जा सकता है।\n   *\n   * उदाहरण:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Output: 10\n   *\n   * उदाहरण:\n   * largestRectangleArea(new int[]{2,4})\n   * Output: 4\n   */\n  public static int largestRectangleArea(int[] heights) ",
      "hu": "import java.util.*;\npublic class Solution {\n\n  /**\n   * Adott n nemnegatív egész szám, amelyek egy oszlopdiagram oszlopainak magasságát képviselik.\n   * Minden oszlop szélessége 1 egység. Számítsa ki a legnagyobb téglalap területét, amely az oszlopdiagramon kialakítható.\n   *\n   * @param heights Egész számok tömbje, amely az oszlopok magasságát képviseli.\n   * @return A téglalap maximális területe, amely kialakítható.\n   *\n   * Példa:\n   * largestRectangleArea(new int[]{2,1,5,6,2,3})\n   * Kimenet: 10\n   *\n   * Példa:\n   * largestRectangleArea(new int[]{2,4})\n   * Kimenet: 4\n   */\n  public static int largestRectangleArea(int[] heights) "
    },
    "prompt_bertscore": {
      "sq": "0.984269466973942",
      "hy": "0.9538394912297782",
      "bn": "0.9868701345528318",
      "bg": "0.9865324629050725",
      "zh": "0.9759450663351509",
      "fr": "0.9793245636380785",
      "de": "0.9970952293077457",
      "ha": "0.9629739065624296",
      "hi": "0.9843354122604456",
      "hu": "0.9650573406291045"
    },
    "canonical_solution": "  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }",
    "instruction": {
      "en": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\n请用不超过500个字符的中文为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int largestRectangleArea(int[] heights)\n  {\n    int maxArea = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    int i = 0;\n    while (i <= heights.length) {\n      int h = (i == heights.length) ? 0 : heights[i];\n      if (stack.isEmpty() || h >= heights[stack.peek()]) {\n        stack.push(i);\n        i++;\n      } else {\n        int top = stack.pop();\n        int width = stack.isEmpty() ? i : i - 1 - stack.peek();\n        maxArea = Math.max(maxArea, heights[top] * width);\n      }\n    }\n    return maxArea;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9310446687022145",
      "bn": "0.9097683754376624",
      "bg": "0.8400592418438494",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9534068742598842",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert largestRectangleArea(new int[] { 1, 2, 3, 4, 5, 3, 3, 2 }) == 15;\n    assert largestRectangleArea(new int[] { 6, 2, 5, 4, 5, 1, 6 }) == 12;\n    assert largestRectangleArea(new int[] { 2, 1, 2, 3, 1 }) == 5;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "largestRectangleArea",
    "signature": "public static int largestRectangleArea(int[] heights)",
    "docstring": {
      "en": "Given n non-negative integers representing the heights of bars in a bar chart.\n    Each bar has a width of 1 unit. Calculate the largest rectangle area that can be formed in the bar chart.\n   \n    @param heights An array of integers representing the heights of bars.\n    @return The maximum area of the rectangle that can be formed.\n   \n    Example:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Example:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "sq": "Duke pasur parasysh n numra të plotë jo-negativë që përfaqësojnë lartësitë e shufrave në një grafik shufrash.\n    Çdo shufër ka një gjerësi prej 1 njësi. Llogaritni sipërfaqen më të madhe të drejtkëndëshit që mund të formohet në grafik shufrash.\n   \n    @param heights Një varg numrash të plotë që përfaqësojnë lartësitë e shufrave.\n    @return Sipërfaqja maksimale e drejtkëndëshit që mund të formohet.\n   \n    Shembull:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Shembull:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "hy": "Տրված են n ոչ բացասական ամբողջ թվեր, որոնք ներկայացնում են սյունակների բարձրությունները սյունակային գծապատկերում։ \n    Յուրաքանչյուր սյունակ ունի 1 միավոր լայնություն։ Հաշվեք ամենամեծ ուղղանկյունի մակերեսը, որը կարող է ձևավորվել սյունակային գծապատկերում։\n   \n    @param heights Թվերի զանգված, որը ներկայացնում է սյունակների բարձրությունները։\n    @return Ուղղանկյան առավելագույն մակերեսը, որը կարող է ձևավորվել։\n   \n    Օրինակ:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Արդյունք: 10\n   \n    Օրինակ:\n    largestRectangleArea(new int[]{2,4})\n    Արդյունք: 4",
      "bn": "n টি অ-ঋণাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে যা একটি বার চার্টে বারের উচ্চতা উপস্থাপন করে। \n    প্রতিটি বারের প্রস্থ 1 ইউনিট। বার চার্টে গঠিত হতে পারে এমন বৃহত্তম আয়তক্ষেত্রের ক্ষেত্রফল গণনা করুন।\n   \n    @param heights বারের উচ্চতা উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে।\n    @return আয়তক্ষেত্রের সর্বাধিক ক্ষেত্রফল যা গঠিত হতে পারে।\n   \n    উদাহরণ:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    আউটপুট: 10\n   \n    উদাহরণ:\n    largestRectangleArea(new int[]{2,4})\n    আউটপুট: 4",
      "bg": "Дадени са n неотрицателни цели числа, представляващи височините на колоните в диаграма с колони. \n    Всяка колона има ширина от 1 единица. Изчислете най-голямата площ на правоъгълник, която може да бъде образувана в диаграмата с колони.\n   \n    @param heights Масив от цели числа, представляващи височините на колоните.\n    @return Максималната площ на правоъгълника, която може да бъде образувана.\n   \n    Пример:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Output: 10\n   \n    Пример:\n    largestRectangleArea(new int[]{2,4})\n    Output: 4",
      "zh": "给定 n 个非负整数，表示柱状图中柱子的高度。  \n每个柱子的宽度为 1 个单位。计算在柱状图中可以形成的最大矩形面积。\n\n@param heights 一个整数数组，表示柱子的高度。\n@return 可以形成的矩形的最大面积。\n\n示例:\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\n输出: 10\n\n示例:\nlargestRectangleArea(new int[]{2,4})\n输出: 4",
      "fr": "Étant donné n entiers non négatifs représentant les hauteurs des barres dans un histogramme. Chaque barre a une largeur de 1 unité. Calculez la plus grande aire de rectangle qui peut être formée dans l'histogramme.\n\n@param heights Un tableau d'entiers représentant les hauteurs des barres.\n@return La superficie maximale du rectangle qui peut être formée.\n\nExemple:\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\nOutput: 10\n\nExemple:\nlargestRectangleArea(new int[]{2,4})\nOutput: 4",
      "de": "Gegeben sind n nicht-negative ganze Zahlen, die die Höhen von Balken in einem Balkendiagramm darstellen.\n    Jeder Balken hat eine Breite von 1 Einheit. Berechne die größte Rechteckfläche, die im Balkendiagramm gebildet werden kann.\n   \n    @param heights Ein Array von ganzen Zahlen, das die Höhen der Balken darstellt.\n    @return Die maximale Fläche des Rechtecks, das gebildet werden kann.\n   \n    Beispiel:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Ausgabe: 10\n   \n    Beispiel:\n    largestRectangleArea(new int[]{2,4})\n    Ausgabe: 4",
      "ha": "An ba da n lambobi marasa kyau waɗanda ke wakiltar tsayin sanduna a cikin ginshiƙin sanduna. \nKowane sanda yana da faɗin naúrar 1. Lissafa mafi girman yankin rectangle da za a iya samarwa a cikin ginshiƙin sanduna.\n\n@param heights Wani tsararren lambobi da ke wakiltar tsayin sanduna.\n@return Mafi girman yankin rectangle da za a iya samarwa.\n\nMisali:\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\nOutput: 10\n\nMisali:\nlargestRectangleArea(new int[]{2,4})\nOutput: 4",
      "hi": "n गैर-ऋणात्मक पूर्णांकों को दिया गया है जो एक बार चार्ट में बार की ऊँचाई का प्रतिनिधित्व करते हैं। प्रत्येक बार की चौड़ाई 1 इकाई है। बार चार्ट में बनने वाले सबसे बड़े आयत क्षेत्र की गणना करें।\n\n@param heights बार की ऊँचाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक श्रृंखला।\n@return आयत का अधिकतम क्षेत्रफल जो बनाया जा सकता है।\n\nउदाहरण:\nlargestRectangleArea(new int[]{2,1,5,6,2,3})\nOutput: 10\n\nउदाहरण:\nlargestRectangleArea(new int[]{2,4})\nOutput: 4",
      "hu": "Adott n nem negatív egész szám, amelyek egy oszlopdiagram oszlopainak magasságát képviselik. \n    Minden oszlop szélessége 1 egység. Számítsd ki a legnagyobb téglalap területét, amely az oszlopdiagramon kialakítható.\n   \n    @param heights Egy egész számokat tartalmazó tömb, amely az oszlopok magasságát képviseli.\n    @return A téglalap maximális területe, amely kialakítható.\n   \n    Példa:\n    largestRectangleArea(new int[]{2,1,5,6,2,3})\n    Kimenet: 10\n   \n    Példa:\n    largestRectangleArea(new int[]{2,4})\n    Kimenet: 4"
    },
    "docstring_bertscore": {
      "sq": "0.9802112496590182",
      "hy": "0.9316089776147345",
      "bn": "0.960038348161115",
      "bg": "0.9480466347972767",
      "zh": "0.9647649567082212",
      "fr": "0.9738477281418035",
      "de": "0.9877921767815958",
      "ha": "0.9681635225277281",
      "hi": "0.9627103240467964",
      "hu": "0.9504667473598057"
    }
  },
  {
    "task_id": "Java/44",
    "prompt": {
      "en": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Return all elements in the matrix in diagonal order.\n   *\n   * @param mat The input matrix.\n   * @return An array containing all elements in diagonal order.\n   *\n   * Example:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "sq": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Kthen të gjitha elementet në matricë në rend diagonal.\n   *\n   * @param mat Matrica hyrëse.\n   * @return Një varg që përmban të gjitha elementet në rend diagonal.\n   *\n   * Shembull:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "hy": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Վերադարձնել մատրիցի բոլոր տարրերը անկյունագծային կարգով:\n   *\n   * @param mat Մուտքային մատրից:\n   * @return Զանգված, որը պարունակում է բոլոր տարրերը անկյունագծային կարգով:\n   *\n   * Օրինակ:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Արդյունք: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "bn": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * ম্যাট্রিক্সের সমস্ত উপাদান তির্যক ক্রমে ফেরত দিন।\n   *\n   * @param mat ইনপুট ম্যাট্রিক্স।\n   * @return একটি অ্যারে যা তির্যক ক্রমে সমস্ত উপাদান ধারণ করে।\n   *\n   * উদাহরণ:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * আউটপুট: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "bg": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Връща всички елементи в матрицата в диагонален ред.\n   *\n   * @param mat Входната матрица.\n   * @return Масив, съдържащ всички елементи в диагонален ред.\n   *\n   * Пример:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Изход: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "zh": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * 返回矩阵中所有元素的对角线顺序。\n   *\n   * @param mat 输入矩阵。\n   * @return 一个包含所有元素按对角线顺序排列的数组。\n   *\n   * 示例:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * 输出: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "fr": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Retourne tous les éléments de la matrice en ordre diagonal.\n   *\n   * @param mat La matrice d'entrée.\n   * @return Un tableau contenant tous les éléments en ordre diagonal.\n   *\n   * Exemple :\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "de": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Gibt alle Elemente der Matrix in diagonaler Reihenfolge zurück.\n   *\n   * @param mat Die Eingabematrix.\n   * @return Ein Array, das alle Elemente in diagonaler Reihenfolge enthält.\n   *\n   * Beispiel:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Ausgabe: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "ha": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Mayar da dukkan abubuwan da ke cikin matrix a cikin tsarin diagonal.\n   *\n   * @param mat Matrix ɗin da aka shigar.\n   * @return Wani array da ke ɗauke da dukkan abubuwan a cikin tsarin diagonal.\n   *\n   * Misali:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Output: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "hi": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * मैट्रिक्स के सभी तत्वों को विकर्ण क्रम में लौटाएं।\n   *\n   * @param mat इनपुट मैट्रिक्स।\n   * @return एक array जो विकर्ण क्रम में सभी तत्वों को समाहित करता है।\n   *\n   * उदाहरण:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * आउटपुट: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) ",
      "hu": "import java.util.ArrayList;\n\npublic class Solution {\n\n  /**\n   * Adja vissza az összes elemet a mátrixban átlós sorrendben.\n   *\n   * @param mat A bemeneti mátrix.\n   * @return Egy tömb, amely az összes elemet átlós sorrendben tartalmazza.\n   *\n   * Példa:\n   * diagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n   * Kimenet: [1,2,4,7,5,3,6,8,9]\n   */\n  public static int[] diagonalOrder(int[][] mat) "
    },
    "prompt_bertscore": {
      "sq": "0.9922444767724928",
      "hy": "0.9759216279501888",
      "bn": "0.9899361931144863",
      "bg": "0.9810895932039545",
      "zh": "0.9887032943394028",
      "fr": "0.9956541658933377",
      "de": "0.9956541658933377",
      "ha": "0.9966985644368191",
      "hi": "0.9897349805384981",
      "hu": "0.9986604367103007"
    },
    "canonical_solution": "  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }",
    "instruction": {
      "en": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nՏվեք Java կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nBa da taƙaitaccen bayani a cikin yaren ɗan adam (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static int[] diagonalOrder(int[][] mat)\n  {\n    if (mat == null || mat.length == 0) {\n      return new int[0];\n    }\n\n    int N = mat.length;\n    int M = mat[0].length;\n    ArrayList<Integer> result = new ArrayList<>();\n    int row = 0, col = 0;\n    boolean up = true;\n\n    for (int i = 0; i < N * M; i++) {\n      result.add(mat[row][col]);\n      if (up) {\n        if (col == M - 1) {\n          row++;\n          up = false;\n        } else if (row == 0) {\n          col++;\n          up = false;\n        } else {\n          row--;\n          col++;\n        }\n      } else {\n        if (row == N - 1) {\n          col++;\n          up = true;\n        } else if (col == 0) {\n          row++;\n          up = true;\n        } else {\n          row++;\n          col--;\n        }\n      }\n    }\n\n    return result.stream().mapToInt(i -> i).toArray();\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9395667065701353",
      "hy": "0.9242475370632005",
      "bn": "0.8954556660714315",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8977268058481843",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1, 2 }, { 3, 4 } }),\n      new int[] { 1, 2, 3, 4 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(\n        new int[][] { { 1, 2, 3, 4 }, { 5, 6, 7, 8 }, { 9, 10, 11, 12 } }\n      ),\n      new int[] { 1, 2, 5, 9, 6, 3, 4, 7, 10, 11, 8, 12 }\n    );\n    assert java.util.Arrays.equals(\n      diagonalOrder(new int[][] { { 1 }, { 2 }, { 3 } }),\n      new int[] { 1, 2, 3 }\n    );\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "diagonalOrder",
    "signature": "public static int[] diagonalOrder(int[][] mat)",
    "docstring": {
      "en": "Return all elements in the matrix in diagonal order.\n\n@param mat The input matrix.\n@return An array containing all elements in diagonal order.\n\nExample:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "sq": "Kthe të gjitha elementet në matricë në rend diagonal.\n\n@param mat Matrica hyrëse.\n@return Një varg që përmban të gjitha elementet në rend diagonal.\n\nShembull:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "hy": "Վերադարձնել մատրիցի բոլոր տարրերը անկյունագծային կարգով։\n\n@param mat Մուտքային մատրիցը։\n@return Զանգված, որը պարունակում է բոլոր տարրերը անկյունագծային կարգով։\n\nՕրինակ:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nԵլք: [1,2,4,7,5,3,6,8,9]",
      "bn": "ডায়াগোনাল ক্রমে ম্যাট্রিক্সের সমস্ত উপাদান ফেরত দিন।\n\n@param mat ইনপুট ম্যাট্রিক্স।\n@return একটি অ্যারে যা ডায়াগোনাল ক্রমে সমস্ত উপাদান ধারণ করে।\n\nউদাহরণ:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "bg": "Върнете всички елементи в матрицата в диагонален ред.\n\n@param mat Входната матрица.\n@return Масив, съдържащ всички елементи в диагонален ред.\n\nПример:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nOutput: [1,2,4,7,5,3,6,8,9]",
      "zh": "返回矩阵中所有元素的对角线顺序。\n\n@param mat 输入矩阵。\n@return 一个包含所有元素按对角线顺序排列的数组。\n\n示例：\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\n输出: [1,2,4,7,5,3,6,8,9]",
      "fr": "Retourner tous les éléments de la matrice dans l'ordre diagonal.\n\n@param mat La matrice d'entrée.\n@return Un tableau contenant tous les éléments dans l'ordre diagonal.\n\nExemple :\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nSortie : [1,2,4,7,5,3,6,8,9]",
      "de": "Gibt alle Elemente in der Matrix in diagonaler Reihenfolge zurück.\n\n@param mat Die Eingabematrix.\n@return Ein Array, das alle Elemente in diagonaler Reihenfolge enthält.\n\nBeispiel:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nAusgabe: [1,2,4,7,5,3,6,8,9]",
      "ha": "Mayar da dukkan abubuwa a cikin matrix a cikin tsari na diagonal.\n\n@param mat Matrix ɗin shigarwa.\n@return Wani tsari mai ɗauke da dukkan abubuwa a cikin tsari na diagonal.\n\nMisali:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nFitarwa: [1,2,4,7,5,3,6,8,9]",
      "hi": "मैट्रिक्स में सभी तत्वों को विकर्ण क्रम में लौटाएं।\n\n@param mat इनपुट मैट्रिक्स।\n@return एक सरणी जो विकर्ण क्रम में सभी तत्वों को समाहित करती है।\n\nउदाहरण:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nआउटपुट: [1,2,4,7,5,3,6,8,9]",
      "hu": "Adja vissza a mátrix összes elemét átlós sorrendben.\n\n@param mat A bemeneti mátrix.\n@return Egy tömb, amely az összes elemet átlós sorrendben tartalmazza.\n\nPélda:\ndiagonalOrder(new int[][]{{1,2,3},{4,5,6},{7,8,9}})\nKimenet: [1,2,4,7,5,3,6,8,9]"
    },
    "docstring_bertscore": {
      "sq": "0.9799953384348333",
      "hy": "0.997369736494336",
      "bn": "0.9878881152556356",
      "bg": "0.9755052986715397",
      "zh": "0.9855192493314135",
      "fr": "0.997369736494336",
      "de": "0.9993796773200281",
      "ha": "1",
      "hi": "0.9603196087806604",
      "hu": "0.997369736494336"
    }
  },
  {
    "task_id": "Java/45",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n   *\n   * @param n The input positive integer.\n   * @return The smallest rearranged integer greater than n, or -1 if not possible.\n   *\n   * Example:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Gjeni numrin më të vogël të plotë që mund të formohet duke riorganizuar shifrat e numrit të dhënë pozitiv n, i cili është më i madh se n.\n   *\n   * @param n Numri i plotë pozitiv i dhënë.\n   * @return Numri më i vogël i riorganizuar më i madh se n, ose -1 nëse nuk është e mundur.\n   *\n   * Shembull:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Գտնել ամենափոքր ամբողջ թիվը, որը կարող է ձևավորվել տրված դրական ամբողջ թիվ n-ի թվանշանները վերադասավորելով, որը մեծ է n-ից:\n   *\n   * @param n Մուտքային դրական ամբողջ թիվը:\n   * @return Ամենափոքր վերադասավորված թիվը, որը մեծ է n-ից, կամ -1, եթե դա հնարավոր չէ:\n   *\n   * Օրինակ:\n   * findSmallestInteger(12)\n   * Արդյունք: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "bn": "public class Solution {\n\n  /**\n   * প্রদত্ত ধনাত্মক পূর্ণসংখ্যা n এর অঙ্কগুলি পুনর্বিন্যাস করে n এর চেয়ে বড় ক্ষুদ্রতম পূর্ণসংখ্যা খুঁজুন।\n   *\n   * @param n ইনপুট ধনাত্মক পূর্ণসংখ্যা।\n   * @return n এর চেয়ে বড় ক্ষুদ্রতম পুনর্বিন্যাসিত পূর্ণসংখ্যা, অথবা সম্ভব না হলে -1।\n   *\n   * উদাহরণ:\n   * findSmallestInteger(12)\n   * আউটপুট: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Намерете най-малкото цяло число, което може да бъде образувано чрез пренареждане на цифрите на даденото положително цяло число n, което е по-голямо от n.\n   *\n   * @param n Входното положително цяло число.\n   * @return Най-малкото пренаредено цяло число, по-голямо от n, или -1 ако не е възможно.\n   *\n   * Пример:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 找到可以通过重新排列给定正整数 n 的数字而形成的最小整数，该整数大于 n。\n   *\n   * @param n 输入的正整数。\n   * @return 大于 n 的最小重新排列整数，如果不可能则返回 -1。\n   *\n   * 示例:\n   * findSmallestInteger(12)\n   * 输出: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Trouver le plus petit entier qui peut être formé en réarrangeant les chiffres de l'entier positif donné n, qui est supérieur à n.\n   *\n   * @param n L'entier positif d'entrée.\n   * @return Le plus petit entier réarrangé supérieur à n, ou -1 si ce n'est pas possible.\n   *\n   * Exemple:\n   * findSmallestInteger(12)\n   * Output: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Finde die kleinste ganze Zahl, die durch Umordnen der Ziffern der gegebenen positiven ganzen Zahl n gebildet werden kann und die größer als n ist.\n   *\n   * @param n Die eingegebene positive ganze Zahl.\n   * @return Die kleinste umgeordnete ganze Zahl, die größer als n ist, oder -1, wenn dies nicht möglich ist.\n   *\n   * Beispiel:\n   * findSmallestInteger(12)\n   * Ausgabe: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * Nemo ƙaramin cikakken lamba wanda za a iya samarwa ta hanyar sake tsara lambobin lambar da aka bayar mai kyau n, wanda ya fi n girma.\n   *\n   * @param n Lambar cikakken lamba mai kyau da aka shigar.\n   * @return Ƙaramin lambar da aka sake tsara wanda ya fi n girma, ko -1 idan ba zai yiwu ba.\n   *\n   * Misali:\n   * findSmallestInteger(12)\n   * Fitarwa: 21\n   */\n  public static int findSmallestInteger(int n)",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए धनात्मक पूर्णांक n के अंकों को पुनर्व्यवस्थित करके बनने वाली सबसे छोटी पूर्णांक संख्या खोजें, जो n से बड़ी हो।\n   *\n   * @param n इनपुट धनात्मक पूर्णांक।\n   * @return सबसे छोटी पुनर्व्यवस्थित पूर्णांक जो n से बड़ी हो, या -1 यदि संभव नहीं है।\n   *\n   * उदाहरण:\n   * findSmallestInteger(12)\n   * आउटपुट: 21\n   */\n  public static int findSmallestInteger(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Keresse meg a legkisebb egész számot, amely a megadott pozitív egész szám n számjegyeinek átrendezésével képezhető, és amely nagyobb, mint n.\n   *\n   * @param n A bemeneti pozitív egész szám.\n   * @return A legkisebb átrendezett egész szám, amely nagyobb, mint n, vagy -1, ha nem lehetséges.\n   *\n   * Példa:\n   * findSmallestInteger(12)\n   * Kimenet: 21\n   */\n  public static int findSmallestInteger(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9808043599767884",
      "hy": "0.9732133027047781",
      "bn": "0.9370274157789853",
      "bg": "1",
      "zh": "1",
      "fr": "0.9943155957555436",
      "de": "0.9723657468689022",
      "ha": "1",
      "hi": "0.9859802704457955",
      "hu": "0.9801520578054699"
    },
    "canonical_solution": "  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n",
    "instruction": {
      "en": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nՏվեք Java կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nFournir une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Java a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static int findSmallestInteger(int n)\n  {\n    char[] characters = Integer.toString(n).toCharArray();\n    int i = characters.length - 2;\n\n    // Find the first digit that is smaller than the digit next to it.\n    while (i >= 0 && characters[i] >= characters[i + 1]) {\n      i--;\n    }\n\n    if (i == -1) {\n      return -1; // Digits are in descending order, no greater number possible.\n    }\n\n    // Find the smallest digit on right side of (i) which is greater than characters[i]\n    int j = characters.length - 1;\n    while (characters[j] <= characters[i]) {\n      j--;\n    }\n\n    // Swap the digits at indices i and j\n    swap(characters, i, j);\n\n    // Reverse the digits from index i+1 to the end of the array\n    reverse(characters, i + 1);\n\n    try {\n      return Integer.parseInt(new String(characters));\n    } catch (NumberFormatException e) {\n      return -1; // The number formed is beyond the range of int.\n    }\n  }\n\n  private static void swap(char[] arr, int i, int j) {\n    char temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n\n  private static void reverse(char[] arr, int start) {\n    int end = arr.length - 1;\n    while (start < end) {\n      swap(arr, start, end);\n      start++;\n      end--;\n    }\n  }\n\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.8939869930340595",
      "bg": "0.8376140553201085",
      "zh": "0.8819509850952504",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8970607981805744",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert findSmallestInteger(123) == 132;\n    assert findSmallestInteger(531) == -1;\n    assert findSmallestInteger(2071) == 2107;\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "findSmallestInteger",
    "signature": "public static int findSmallestInteger(int n)",
    "docstring": {
      "en": "Find the smallest integer that can be formed by rearranging the digits of the given positive integer n, which is greater than n.\n\n@param n The input positive integer.\n@return The smallest rearranged integer greater than n, or -1 if not possible.\n\nExample:\nfindSmallestInteger(12)\nOutput: 21",
      "sq": "Gjeni numrin më të vogël të plotë që mund të formohet duke riorganizuar shifrat e numrit të dhënë pozitiv n, i cili është më i madh se n.\n\n@param n Numri i plotë pozitiv i dhënë si hyrje.\n@return Numri më i vogël i riorganizuar që është më i madh se n, ose -1 nëse nuk është e mundur.\n\nShembull:\nfindSmallestInteger(12)\nDalja: 21",
      "hy": "Գտնել ամենափոքր ամբողջ թիվը, որը կարող է ձևավորվել տրված դրական ամբողջ թիվ n-ի թվանշանները վերադասավորելով, որը մեծ է n-ից:\n\n@param n Մուտքային դրական ամբողջ թիվը:\n@return Ամենափոքր վերադասավորված թիվը, որը մեծ է n-ից, կամ -1, եթե դա հնարավոր չէ:\n\nՕրինակ:\nfindSmallestInteger(12)\nOutput: 21",
      "bn": "প্রদত্ত ধনাত্মক পূর্ণসংখ্যা n এর অঙ্কগুলো পুনর্বিন্যাস করে যে ক্ষুদ্রতম পূর্ণসংখ্যা গঠন করা যায়, যা n এর চেয়ে বড়।\n\n@param n ইনপুট ধনাত্মক পূর্ণসংখ্যা।\n@return n এর চেয়ে বড় ক্ষুদ্রতম পুনর্বিন্যাসিত পূর্ণসংখ্যা, অথবা সম্ভব না হলে -1।\n\nউদাহরণ:\nfindSmallestInteger(12)\nOutput: 21",
      "bg": "Намерете най-малкото цяло число, което може да бъде образувано чрез пренареждане на цифрите на даденото положително цяло число n, което е по-голямо от n.\n\n@param n Входното положително цяло число.\n@return Най-малкото пренаредено цяло число, по-голямо от n, или -1, ако не е възможно.\n\nПример:\nfindSmallestInteger(12)\nИзход: 21",
      "zh": "找到通过重新排列给定正整数 n 的数字而形成的比 n 大的最小整数。\n\n@param n 输入的正整数。\n@return 比 n 大的最小重新排列整数，如果不可能则返回 -1。\n\n示例：\nfindSmallestInteger(12)\n输出: 21",
      "fr": "Trouver le plus petit entier qui peut être formé en réarrangeant les chiffres de l'entier positif donné n, qui est supérieur à n.\n\n@param n L'entier positif d'entrée.\n@return Le plus petit entier réarrangé supérieur à n, ou -1 si ce n'est pas possible.\n\nExemple :\nfindSmallestInteger(12)\nSortie : 21",
      "de": "Finde die kleinste ganze Zahl, die durch Umordnen der Ziffern der gegebenen positiven ganzen Zahl n gebildet werden kann und die größer als n ist.\n\n@param n Die Eingabe positive ganze Zahl.\n@return Die kleinste umgeordnete ganze Zahl, die größer als n ist, oder -1, falls nicht möglich.\n\nBeispiel:\nfindSmallestInteger(12)\nAusgabe: 21",
      "ha": "Nemo ƙaramin cikakken lamba wanda za a iya samarwa ta hanyar sake tsara lambobin lamba mai kyau da aka bayar n, wanda ya fi n girma.\n\n@param n Lambar shigar da lamba mai kyau.\n@return Mafi ƙarancin lambar da aka sake tsara fiye da n, ko -1 idan ba zai yiwu ba.\n\nMisali:\nfindSmallestInteger(12)\nOutput: 21",
      "hi": "दिए गए धनात्मक पूर्णांक n के अंकों को पुनर्व्यवस्थित करके वह सबसे छोटा पूर्णांक खोजें, जो n से बड़ा हो।\n\n@param n इनपुट धनात्मक पूर्णांक।\n@return सबसे छोटा पुनर्व्यवस्थित पूर्णांक जो n से बड़ा हो, या -1 यदि संभव नहीं है।\n\nउदाहरण:\nfindSmallestInteger(12)\nOutput: 21",
      "hu": "Keresse meg a legkisebb egész számot, amely a megadott pozitív egész szám n számjegyeinek átrendezésével képezhető, és amely nagyobb, mint n.\n\n@param n A bemeneti pozitív egész szám.\n@return A legkisebb átrendezett egész szám, amely nagyobb, mint n, vagy -1, ha nem lehetséges.\n\nPélda:\nfindSmallestInteger(12)\nKimenet: 21"
    },
    "docstring_bertscore": {
      "sq": "0.9741015777687662",
      "hy": "0.873140933174829",
      "bn": "0.9873228131912103",
      "bg": "1",
      "zh": "0.9260932105637767",
      "fr": "0.9921068259184356",
      "de": "0.9893865828501628",
      "ha": "0.9653542930487516",
      "hi": "0.9787904465434757",
      "hu": "0.9893865828501628"
    }
  },
  {
    "task_id": "Java/46",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Given an integer n, return all the center symmetric numbers of length n.\n   *\n   * @param n The length of the center symmetric numbers.\n   * @return A list of center symmetric numbers.\n   *\n   * Example:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "sq": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Duke pasur një numër të plotë n, kthe të gjithë numrat simetrikë qendrorë me gjatësi n.\n   *\n   * @param n Gjatësia e numrave simetrikë qendrorë.\n   * @return Një listë e numrave simetrikë qendrorë.\n   *\n   * Shembull:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "hy": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Տրված է ամբողջ թիվ n, վերադարձնել բոլոր կենտրոնական սիմետրիկ թվերը, որոնք ունեն n երկարություն։\n   *\n   * @param n Կենտրոնական սիմետրիկ թվերի երկարությունը։\n   * @return Կենտրոնական սիմետրիկ թվերի ցուցակ։\n   *\n   * Օրինակ:\n   * centerSymmetricNumbers(2)\n   * Արդյունք: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Արդյունք: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "bn": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যা n দেওয়া হলে, n দৈর্ঘ্যের সমস্ত কেন্দ্র সমমিত সংখ্যা ফেরত দিন।\n   *\n   * @param n কেন্দ্র সমমিত সংখ্যার দৈর্ঘ্য।\n   * @return কেন্দ্র সমমিত সংখ্যার একটি তালিকা।\n   *\n   * উদাহরণ:\n   * centerSymmetricNumbers(2)\n   * আউটপুট: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * আউটপুট: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "bg": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Дадено е цяло число n, върнете всички централно симетрични числа с дължина n.\n   *\n   * @param n Дължината на централно симетричните числа.\n   * @return Списък с централно симетрични числа.\n   *\n   * Пример:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "zh": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * 给定一个整数 n，返回所有长度为 n 的中心对称数。\n   *\n   * @param n 中心对称数的长度。\n   * @return 中心对称数的列表。\n   *\n   * 示例:\n   * centerSymmetricNumbers(2)\n   * 输出: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * 输出: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "fr": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Étant donné un entier n, retourne tous les nombres symétriques centraux de longueur n.\n   *\n   * @param n La longueur des nombres symétriques centraux.\n   * @return Une liste de nombres symétriques centraux.\n   *\n   * Exemple:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "de": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Gegeben eine ganze Zahl n, gebe alle zentrumsymmetrischen Zahlen der Länge n zurück.\n   *\n   * @param n Die Länge der zentrumsymmetrischen Zahlen.\n   * @return Eine Liste von zentrumsymmetrischen Zahlen.\n   *\n   * Beispiel:\n   * centerSymmetricNumbers(2)\n   * Ausgabe: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Ausgabe: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "ha": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * An ba da wani lamba n, mayar da duk lambobin da ke da daidaito a tsakiya na tsawon n.\n   *\n   * @param n Tsawon lambobin da ke da daidaito a tsakiya.\n   * @return Jerin lambobin da ke da daidaito a tsakiya.\n   *\n   * Misali:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n)",
      "hi": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * दिए गए एक पूर्णांक n के लिए, n लंबाई की सभी केंद्र सममित संख्याएँ लौटाएँ।\n   *\n   * @param n केंद्र सममित संख्याओं की लंबाई।\n   * @return केंद्र सममित संख्याओं की एक सूची।\n   *\n   * उदाहरण:\n   * centerSymmetricNumbers(2)\n   * Output: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Output: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) ",
      "hu": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Adott egy egész szám n, adja vissza az összes középen szimmetrikus számot, amelyek hossza n.\n   *\n   * @param n A középen szimmetrikus számok hossza.\n   * @return A középen szimmetrikus számok listája.\n   *\n   * Példa:\n   * centerSymmetricNumbers(2)\n   * Kimenet: [\"11\",\"69\",\"88\",\"96\"]\n   *\n   * centerSymmetricNumbers(1)\n   * Kimenet: [\"0\",\"1\",\"8\"]\n   */\n  public static List<String> centerSymmetricNumbers(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9972966405141152",
      "hy": "0.9851154337667696",
      "bn": "0.9904730910344236",
      "bg": "0.9740852900775212",
      "zh": "0.9972966405141152",
      "fr": "0.9728015419248928",
      "de": "0.9740852900775212",
      "ha": "0.9769278894605116",
      "hi": "0.9887515615219943",
      "hu": "0.9719583559573997"
    },
    "canonical_solution": "  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }",
    "instruction": {
      "en": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Java a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static List<String> centerSymmetricNumbers(int n)\n  {\n    return findCenterSymmetricNumbers(n, n);\n  }\n\n  private static List<String> findCenterSymmetricNumbers(\n    int n,\n    int totalLength\n  ) {\n    if (n == 0) return new ArrayList<>(Arrays.asList(\"\"));\n    if (n == 1) return new ArrayList<>(Arrays.asList(\"0\", \"1\", \"8\"));\n\n    List<String> list = findCenterSymmetricNumbers(n - 2, totalLength);\n    List<String> resultList = new ArrayList<>();\n\n    for (String middle : list) {\n      if (n != totalLength) resultList.add(\"0\" + middle + \"0\");\n      resultList.add(\"1\" + middle + \"1\");\n      resultList.add(\"8\" + middle + \"8\");\n      resultList.add(\"6\" + middle + \"9\");\n      resultList.add(\"9\" + middle + \"6\");\n    }\n\n    return resultList;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.9137427707317894",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8970607981805744",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  private static void assertArrays(String[] expected, List<String> actual) {\n    if (actual == null || actual.size() != expected.length) {\n      throw new AssertionError(\"Test case failed\");\n    }\n    for (String str : expected) {\n      if (!actual.contains(str)) {\n        throw new AssertionError(\"Test case failed\");\n      }\n    }\n  }\n\n  public static void main(String[] args) {\n    assertArrays(\n      new String[] { \"11\", \"69\", \"88\", \"96\" },\n      centerSymmetricNumbers(2)\n    );\n    assertArrays(new String[] { \"0\", \"1\", \"8\" }, centerSymmetricNumbers(1));\n    assertArrays(\n      new String[] {\n        \"101\",\n        \"111\",\n        \"181\",\n        \"609\",\n        \"619\",\n        \"689\",\n        \"808\",\n        \"818\",\n        \"888\",\n        \"906\",\n        \"916\",\n        \"986\",\n      },\n      centerSymmetricNumbers(3)\n    );\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "centerSymmetricNumbers",
    "signature": "public static List<String> centerSymmetricNumbers(int n)",
    "docstring": {
      "en": "Given an integer n, return all the center symmetric numbers of length n.\n\n@param n The length of the center symmetric numbers.\n@return A list of center symmetric numbers.\n\nExample:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "sq": "Duke pasur një numër të plotë n, kthe të gjitha numrat simetrikë qendrorë me gjatësi n.\n\n@param n Gjatësia e numrave simetrikë qendrorë.\n@return Një listë e numrave simetrikë qendrorë.\n\nShembull:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "hy": "Տրված է ամբողջ թիվ n, վերադարձնել բոլոր կենտրոնական սիմետրիկ թվերը, որոնք ունեն n երկարություն։\n\n@param n Կենտրոնական սիմետրիկ թվերի երկարությունը։\n@return Կենտրոնական սիմետրիկ թվերի ցանկ։\n\nՕրինակ:\ncenterSymmetricNumbers(2)\nԱրդյունք: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nԱրդյունք: [\"0\",\"1\",\"8\"]",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, n দৈর্ঘ্যের সমস্ত কেন্দ্র সমমিত সংখ্যা ফেরত দিন।\n\n@param n কেন্দ্র সমমিত সংখ্যার দৈর্ঘ্য।\n@return কেন্দ্র সমমিত সংখ্যার একটি তালিকা।\n\nউদাহরণ:\ncenterSymmetricNumbers(2)\nআউটপুট: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nআউটপুট: [\"0\",\"1\",\"8\"]",
      "bg": "Дадено е цяло число n, върнете всички централно симетрични числа с дължина n.\n\n@param n Дължината на централно симетричните числа.\n@return Списък с централно симетрични числа.\n\nПример:\ncenterSymmetricNumbers(2)\nИзход: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nИзход: [\"0\",\"1\",\"8\"]",
      "zh": "给定一个整数 n，返回所有长度为 n 的中心对称数。\n\n@param n 中心对称数的长度。\n@return 一个中心对称数的列表。\n\n示例：\ncenterSymmetricNumbers(2)\n输出: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\n输出: [\"0\",\"1\",\"8\"]",
      "fr": "Étant donné un entier n, renvoie tous les nombres symétriques centraux de longueur n.\n\n@param n La longueur des nombres symétriques centraux.\n@return Une liste de nombres symétriques centraux.\n\nExemple :\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "de": "Gibt eine ganze Zahl n, alle zentrierte symmetrische Zahlen der Länge n zurück.\n\n@param n Die Länge der zentrierten symmetrischen Zahlen.\n@return Eine Liste von zentrierten symmetrischen Zahlen.\n\nBeispiel:\ncenterSymmetricNumbers(2)\nAusgabe: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nAusgabe: [\"0\",\"1\",\"8\"]",
      "ha": "Duba wani lamba n, dawo da duk lambobin da suke daidai daga tsakiya na tsawon n.\n\n@param n Tsawon lambobin da suke daidai daga tsakiya.\n@return Jerin lambobin da suke daidai daga tsakiya.\n\nMisali:\ncenterSymmetricNumbers(2)\nOutput: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nOutput: [\"0\",\"1\",\"8\"]",
      "hi": "दिए गए पूर्णांक n के लिए, लंबाई n के सभी केंद्र सममित संख्याएँ लौटाएँ।\n\n@param n केंद्र सममित संख्याओं की लंबाई।\n@return केंद्र सममित संख्याओं की एक सूची।\n\nउदाहरण:\ncenterSymmetricNumbers(2)\nआउटपुट: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nआउटपुट: [\"0\",\"1\",\"8\"]",
      "hu": "Adott egy egész szám n, adja vissza az összes középen szimmetrikus számot, amelynek hossza n.\n\n@param n A középen szimmetrikus számok hossza.\n@return A középen szimmetrikus számok listája.\n\nPélda:\ncenterSymmetricNumbers(2)\nKimenet: [\"11\",\"69\",\"88\",\"96\"]\n\ncenterSymmetricNumbers(1)\nKimenet: [\"0\",\"1\",\"8\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9929277652832528",
      "hy": "0.9625184470987166",
      "bn": "0.9859951677243731",
      "bg": "0.9621156246859779",
      "zh": "0.9621156246859779",
      "fr": "0.9621156246859779",
      "de": "0.9677956590620516",
      "ha": "0.9008584124355804",
      "hi": "0.9859951677243731",
      "hu": "0.9621156246859779"
    }
  },
  {
    "task_id": "Java/47",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Determine if the given points form a boomerang on the X-Y plane.\n   *\n   * @param points An array of points where points[i] = [xi, yi].\n   * @return True if the points form a boomerang, false otherwise.\n   *\n   * Example:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "sq": "public class Solution {\n\n  /**\n   * Përcaktoni nëse pikat e dhëna formojnë një bumerang në planin X-Y.\n   *\n   * @param points Një varg pikash ku points[i] = [xi, yi].\n   * @return True nëse pikat formojnë një bumerang, false përndryshe.\n   *\n   * Shembull:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "hy": "public class Solution {\n\n  /**\n   * Որոշել՝ արդյոք տրված կետերը ձևավորում են բումերանգ X-Y հարթության վրա:\n   *\n   * @param points Կետերի զանգված, որտեղ points[i] = [xi, yi]:\n   * @return Ճիշտ, եթե կետերը ձևավորում են բումերանգ, սխալ՝ հակառակ դեպքում:\n   *\n   * Օրինակ:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Արդյունք: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "bn": "public class Solution {\n\n  /**\n   * নির্ধারণ করুন প্রদত্ত বিন্দুগুলি X-Y সমতলে একটি বুমেরাং গঠন করে কিনা।\n   *\n   * @param points একটি বিন্দুর অ্যারে যেখানে points[i] = [xi, yi]।\n   * @return সত্য যদি বিন্দুগুলি একটি বুমেরাং গঠন করে, অন্যথায় মিথ্যা।\n   *\n   * উদাহরণ:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * আউটপুট: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "bg": "public class Solution {\n\n  /**\n   * Определете дали дадените точки образуват бумеранг в X-Y равнината.\n   *\n   * @param points Масив от точки, където points[i] = [xi, yi].\n   * @return Връща true, ако точките образуват бумеранг, false в противен случай.\n   *\n   * Пример:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "zh": "public class Solution {\n\n  /**\n   * 确定给定的点是否在 X-Y 平面上形成回旋镖。\n   *\n   * @param points 一个点的数组，其中 points[i] = [xi, yi]。\n   * @return 如果点形成回旋镖则返回真，否则返回假。\n   *\n   * 示例:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * 输出: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "fr": "public class Solution {\n\n  /**\n   * Déterminer si les points donnés forment un boomerang sur le plan X-Y.\n   *\n   * @param points Un tableau de points où points[i] = [xi, yi].\n   * @return True si les points forment un boomerang, false sinon.\n   *\n   * Exemple:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points)",
      "de": "public class Solution {\n\n  /**\n   * Bestimmen, ob die gegebenen Punkte auf der X-Y-Ebene einen Bumerang bilden.\n   *\n   * @param points Ein Array von Punkten, wobei points[i] = [xi, yi].\n   * @return True, wenn die Punkte einen Bumerang bilden, andernfalls false.\n   *\n   * Beispiel:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Ausgabe: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "ha": "public class Solution {\n\n  /**\n   * Tantance idan maki da aka bayar suna samar da boomerang akan faifan X-Y.\n   *\n   * @param points Wani tsari na maki inda points[i] = [xi, yi].\n   * @return Gaskiya idan maki suna samar da boomerang, ƙarya in ba haka ba.\n   *\n   * Misali:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "hi": "public class Solution {\n\n  /**\n   * निर्धारित करें कि दिए गए बिंदु X-Y तल पर एक बूमरैंग बनाते हैं या नहीं।\n   *\n   * @param points बिंदुओं की एक array जहाँ points[i] = [xi, yi] है।\n   * @return True अगर बिंदु एक बूमरैंग बनाते हैं, अन्यथा false।\n   *\n   * उदाहरण:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Output: true\n   */\n  public static boolean isBoomerang(int[][] points) ",
      "hu": "public class Solution {\n\n  /**\n   * Határozza meg, hogy a megadott pontok bumerángot alkotnak-e az X-Y síkon.\n   *\n   * @param points Egy pontokat tartalmazó tömb, ahol points[i] = [xi, yi].\n   * @return Igaz, ha a pontok bumerángot alkotnak, különben hamis.\n   *\n   * Példa:\n   * isBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n   * Kimenet: true\n   */\n  public static boolean isBoomerang(int[][] points) "
    },
    "prompt_bertscore": {
      "sq": "0.9986512997127731",
      "hy": "0.9890207056882966",
      "bn": "0.9956704535845825",
      "bg": "0.9868931756770318",
      "zh": "0.9861453322924355",
      "fr": "1",
      "de": "0.9910646123091456",
      "ha": "1",
      "hi": "0.9907746119528347",
      "hu": "0.9897055832421049"
    },
    "canonical_solution": "  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }",
    "instruction": {
      "en": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nՏվեք Java կոդի հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static boolean isBoomerang(int[][] points)\n  {\n    // A boomerang is a set of three points that are all distinct from each other and do not lie in a straight line.\n    // To check this, we can use the slope formula: (y2 - y1) / (x2 - x1) and compare the slope of two lines\n    // If the slopes are equal, it means the points are collinear and hence cannot form a boomerang.\n\n    int x1 = points[0][0], y1 = points[0][1];\n    int x2 = points[1][0], y2 = points[1][1];\n    int x3 = points[2][0], y3 = points[2][1];\n\n    // Calculate the slopes of line segment formed by (point1, point2) and (point1, point3).\n    // To avoid division by zero, we'll cross-multiply to compare the slopes.\n    int slope1 = (y2 - y1) * (x3 - x1);\n    int slope2 = (y3 - y1) * (x2 - x1);\n\n    // The points form a boomerang if the slopes are not equal.\n    return slope1 != slope2;\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9444834043918918",
      "hy": "0.9242475370632005",
      "bn": "0.9071198379369432",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9406516257113479",
      "hi": "0.9113991308659588",
      "hu": "0.9394101858298798"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert isBoomerang(new int[][] { { 0, 0 }, { 2, 2 }, { 1, 1 } }) ==\n    false : \"Test case 1 failed\";\n    assert isBoomerang(new int[][] { { 1, 1 }, { 2, 4 }, { 3, 1 } }) ==\n    true : \"Test case 2 failed\";\n    assert isBoomerang(new int[][] { { 0, 1 }, { 1, 0 }, { 0, -1 } }) ==\n    true : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "isBoomerang",
    "signature": "public static boolean isBoomerang(int[][] points)",
    "docstring": {
      "en": "Determine if the given points form a boomerang on the X-Y plane.\n\n@param points An array of points where points[i] = [xi, yi].\n@return True if the points form a boomerang, false otherwise.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "sq": "Përcaktoni nëse pikat e dhëna formojnë një bumerang në planin X-Y.\n\n@param points Një varg pikash ku points[i] = [xi, yi].\n@return True nëse pikat formojnë një bumerang, false përndryshe.\n\nShembull:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "hy": "Սահմանել, արդյոք տրված կետերը ձևավորում են բումերանգ X-Y հարթության վրա։\n\n@param points Կետերի զանգված, որտեղ points[i] = [xi, yi]։\n@return Ճիշտ, եթե կետերը ձևավորում են բումերանգ, սխալ՝ հակառակ դեպքում։\n\nՕրինակ:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nԵլք: true",
      "bn": "প্রদত্ত পয়েন্টগুলি X-Y প্লেনে একটি বুমেরাং তৈরি করে কিনা তা নির্ধারণ করুন।\n\n@param points পয়েন্টগুলির একটি অ্যারে যেখানে points[i] = [xi, yi]।\n@return পয়েন্টগুলি যদি একটি বুমেরাং গঠন করে তবে সত্য, অন্যথায় মিথ্যা।\n\nউদাহরণ:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "bg": "Определете дали дадените точки образуват бумеранг в X-Y равнината.\n\n@param points Масив от точки, където points[i] = [xi, yi].\n@return True, ако точките образуват бумеранг, false в противен случай.\n\nПример:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "zh": "确定给定的点是否在 X-Y 平面上形成回旋镖。\n\n@param points 一个点的数组，其中 points[i] = [xi, yi]。\n@return 如果这些点形成回旋镖，则返回 True，否则返回 false。\n\n示例：\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\n输出: true",
      "fr": "Déterminer si les points donnés forment un boomerang sur le plan X-Y.\n\n@param points Un tableau de points où points[i] = [xi, yi].\n@return True si les points forment un boomerang, false sinon.\n\nExemple :\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "de": "Bestimmen Sie, ob die gegebenen Punkte auf der X-Y-Ebene einen Bumerang bilden.\n\n@param points Ein Array von Punkten, wobei points[i] = [xi, yi].\n@return True, wenn die Punkte einen Bumerang bilden, andernfalls false.\n\nBeispiel:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nAusgabe: true",
      "ha": "Tantance idan maki da aka bayar suna samar da boomerang a kan filin X-Y.\n\n@param points Wani tsararraki na maki inda points[i] = [xi, yi].\n@return Gaskiya idan maki sun samar da boomerang, ƙarya in ba haka ba.\n\nExample:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "hi": "निर्धारित करें कि दिए गए बिंदु X-Y तल पर एक बूमरैंग बनाते हैं या नहीं।\n\n@param points बिंदुओं की एक array जहां points[i] = [xi, yi] है।\n@return True यदि बिंदु एक बूमरैंग बनाते हैं, अन्यथा false।\n\nउदाहरण:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nOutput: true",
      "hu": "Határozza meg, hogy az adott pontok bumerángot alkotnak-e az X-Y síkon.\n\n@param points Egy pontokat tartalmazó tömb, ahol points[i] = [xi, yi].\n@return Igaz, ha a pontok bumerángot alkotnak, hamis különben.\n\nPélda:\nisBoomerang(new int[][]{{1,1},{2,3},{3,2}})\nKimenet: true"
    },
    "docstring_bertscore": {
      "sq": "0.9980647441975771",
      "hy": "0.9841786928898091",
      "bn": "0.9724994251153387",
      "bg": "0.9836612607472132",
      "zh": "0.9764029093634363",
      "fr": "1",
      "de": "0.9873389022520741",
      "ha": "1",
      "hi": "0.9957890359220604",
      "hu": "0.9891813976665538"
    }
  },
  {
    "task_id": "Java/48",
    "prompt": {
      "en": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Find and return the nth ugly number.\n   *\n   * @param n The index of the ugly number to find.\n   * @return The nth ugly number.\n   *\n   * Example:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "sq": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Gjej dhe kthe numrin e n-të të shëmtuar.\n   *\n   * @param n Indeksi i numrit të shëmtuar për të gjetur.\n   * @return Numri i n-të i shëmtuar.\n   *\n   * Shembull:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "hy": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Գտնել և վերադարձնել n-րդ տգեղ թիվը։\n   *\n   * @param n Տգեղ թվի ինդեքսը, որը պետք է գտնել։\n   * @return n-րդ տգեղ թիվը։\n   *\n   * Օրինակ:\n   * findNthUglyNumber(10)\n   * Արդյունք: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "bn": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * nth কুৎসিত সংখ্যা খুঁজে বের করুন এবং ফেরত দিন।\n   *\n   * @param n যে কুৎসিত সংখ্যাটি খুঁজে বের করতে হবে তার সূচক।\n   * @return nth কুৎসিত সংখ্যা।\n   *\n   * উদাহরণ:\n   * findNthUglyNumber(10)\n   * আউটপুট: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "bg": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Намерете и върнете n-тото грозно число.\n   *\n   * @param n Индексът на грозното число, което да се намери.\n   * @return n-тото грозно число.\n   *\n   * Пример:\n   * findNthUglyNumber(10)\n   * Изход: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "zh": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * 查找并返回第 n 个丑数。\n   *\n   * @param n 要查找的丑数的索引。\n   * @return 第 n 个丑数。\n   *\n   * 示例:\n   * findNthUglyNumber(10)\n   * 输出: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "fr": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Trouver et retourner le nième nombre laid.\n   *\n   * @param n L'indice du nombre laid à trouver.\n   * @return Le nième nombre laid.\n   *\n   * Exemple:\n   * findNthUglyNumber(10)\n   * Output: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "de": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Finde und gib die n-te hässliche Zahl zurück.\n   *\n   * @param n Der Index der zu findenden hässlichen Zahl.\n   * @return Die n-te hässliche Zahl.\n   *\n   * Beispiel:\n   * findNthUglyNumber(10)\n   * Ausgabe: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "ha": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Nemo kuma dawo da lamba mai muni ta n.\n   *\n   * @param n Lambar alamar lamba mai muni da za a nema.\n   * @return Lamba mai muni ta n.\n   *\n   * Misali:\n   * findNthUglyNumber(10)\n   * Fitarwa: 12\n   */\n  public static int findNthUglyNumber(int n)",
      "hi": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * nth बदसूरत संख्या खोजें और लौटाएं।\n   *\n   * @param n बदसूरत संख्या का सूचकांक जिसे खोजना है।\n   * @return nth बदसूरत संख्या।\n   *\n   * उदाहरण:\n   * findNthUglyNumber(10)\n   * आउटपुट: 12\n   */\n  public static int findNthUglyNumber(int n) ",
      "hu": "import java.lang.Math;\n\npublic class Solution {\n\n  /**\n   * Keresse meg és adja vissza az n-edik csúnya számot.\n   *\n   * @param n A keresendő csúnya szám indexe.\n   * @return Az n-edik csúnya szám.\n   *\n   * Példa:\n   * findNthUglyNumber(10)\n   * Kimenet: 12\n   */\n  public static int findNthUglyNumber(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9835142742652474",
      "hy": "0.9953494668888302",
      "bn": "0.99273529244403",
      "bg": "0.9835142742652474",
      "zh": "1",
      "fr": "1",
      "de": "0.9835142742652474",
      "ha": "1",
      "hi": "0.99273529244403",
      "hu": "1"
    },
    "canonical_solution": "  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n",
    "instruction": {
      "en": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nনিচের জাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\n请用最多500个字符的中文对该Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Java a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static int findNthUglyNumber(int n)\n  {\n    if (n <= 0) {\n      throw new IllegalArgumentException(\"Input must be a positive integer.\");\n    }\n    int[] ugly = new int[n]; // To store ugly numbers\n    ugly[0] = 1; // 1 is the first ugly number\n\n    int index2 = 0, index3 = 0, index5 = 0;\n    int factor2 = 2, factor3 = 3, factor5 = 5;\n\n    for (int i = 1; i < n; i++) {\n      int min = Math.min(Math.min(factor2, factor3), factor5);\n      ugly[i] = min;\n      if (min == factor2) {\n        index2++;\n        factor2 = 2 * ugly[index2];\n      }\n      if (min == factor3) {\n        index3++;\n        factor3 = 3 * ugly[index3];\n      }\n      if (min == factor5) {\n        index5++;\n        factor5 = 5 * ugly[index5];\n      }\n    }\n\n    return ugly[n - 1];\n  }\n\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9615433705582164",
      "bn": "0.8857905103606548",
      "bg": "0.8376140553201085",
      "zh": "0.8385482140021155",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9353706397707733",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert findNthUglyNumber(1) == 1 : \"Test case 1 failed\";\n    assert findNthUglyNumber(7) == 8 : \"Test case 2 failed\";\n    assert findNthUglyNumber(15) == 24 : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "findNthUglyNumber",
    "signature": "public static int findNthUglyNumber(int n)",
    "docstring": {
      "en": "Find and return the nth ugly number.\n   \n    @param n The index of the ugly number to find.\n    @return The nth ugly number.\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12",
      "sq": "Gjeni dhe ktheni numrin e n-të të shëmtuar.\n\n    @param n Indeksi i numrit të shëmtuar për të gjetur.\n    @return Numri i n-të i shëmtuar.\n   \n    Shembull:\n    findNthUglyNumber(10)\n    Output: 12",
      "hy": "Գտնել և վերադարձնել n-րդ տգեղ թիվը։\n\n    @param n Տգեղ թվի ինդեքսը, որը պետք է գտնել։\n    @return n-րդ տգեղ թիվը։\n\n    Օրինակ:\n    findNthUglyNumber(10)\n    Արդյունք: 12",
      "bn": "nth কদর্য সংখ্যা খুঁজে বের করুন এবং ফেরত দিন।\n   \n    @param n খুঁজে বের করার জন্য কুৎসিত সংখ্যার সূচক।\n    @return nth কুৎসিত সংখ্যা।\n   \n    উদাহরণ:\n    findNthUglyNumber(10)\n    Output: 12",
      "bg": "Намерете и върнете n-тото грозно число.\n   \n    @param n Индексът на грозното число, което трябва да се намери.\n    @return n-тото грозно число.\n   \n    Пример:\n    findNthUglyNumber(10)\n    Изход: 12",
      "zh": "找到并返回第 n 个丑数。\n\n    @param n 要查找的丑数的索引。\n    @return 第 n 个丑数。\n   \n    示例:\n    findNthUglyNumber(10)\n    Output: 12",
      "fr": "Trouver et retourner le nième nombre laid.\n   \n    @param n L'indice du nombre laid à trouver.\n    @return Le nième nombre laid.\n   \n    Exemple:\n    findNthUglyNumber(10)\n    Output: 12",
      "de": "Finde und gib die n-te hässliche Zahl zurück.\n   \n    @param n Der Index der zu findenden hässlichen Zahl.\n    @return Die n-te hässliche Zahl.\n   \n    Beispiel:\n    findNthUglyNumber(10)\n    Ausgabe: 12",
      "ha": "Nemo kuma dawo da lamba mai muni ta n.\n   \n    @param n Lambar da ke nuna matsayin lambar mummuna da za a nema.\n    @return Lambar mummuna ta n.\n   \n    Misali:\n    findNthUglyNumber(10)\n    Output: 12",
      "hi": "nth बदसूरत संख्या खोजें और लौटाएं।\n   \n    @param n बदसूरत संख्या का वह सूचकांक जिसे खोजना है।\n    @return nth बदसूरत संख्या।\n   \n    Example:\n    findNthUglyNumber(10)\n    Output: 12",
      "hu": "Keresse meg és adja vissza az n-edik csúnya számot.\n   \n    @param n A csúnya szám indexe, amelyet meg kell találni.\n    @return Az nth csúnya szám.\n\n    Példa:\n    findNthUglyNumber(10)\n    Kimenet: 12"
    },
    "docstring_bertscore": {
      "sq": "0.961450610170273",
      "hy": "0.9726857404127495",
      "bn": "0.9861888323458822",
      "bg": "0.9908715435787796",
      "zh": "1",
      "fr": "1",
      "de": "0.9726857404127495",
      "ha": "0.9914708114383619",
      "hi": "0.9861888323458822",
      "hu": "0.9908715435787796"
    }
  },
  {
    "task_id": "Java/49",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   *\n   * @param s The input string.\n   * @return The energy of the string.\n   *\n   * Example:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "sq": "public class Solution {\n\n  /**\n   * Llogarit energjinë e vargut, e cila përcaktohet si gjatësia e nënvargut më të gjatë jo-bosh që përmban vetëm një karakter.\n   *\n   * @param s Vargu hyrës.\n   * @return Energjia e vargut.\n   *\n   * Shembull:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "hy": "public class Solution {\n\n  /**\n   * Հաշվարկել տողի էներգիան, որը սահմանվում է որպես ամենաերկար ոչ դատարկ ենթատողի երկարություն, որը պարունակում է միայն մեկ նիշ:\n   *\n   * @param s Մուտքային տողը:\n   * @return Տողի էներգիան:\n   *\n   * Օրինակ:\n   * calculateEnergy(\"aabbccdd\")\n   * Արդյունք: 2\n   */\n  public static int calculateEnergy(String s) ",
      "bn": "public class Solution {\n\n  /**\n   * স্ট্রিংয়ের শক্তি গণনা করুন, যা শুধুমাত্র একটি অক্ষর ধারণকারী দীর্ঘতম নন-এম্পটি সাবস্ট্রিংয়ের দৈর্ঘ্য হিসাবে সংজ্ঞায়িত করা হয়।\n   *\n   * @param s ইনপুট স্ট্রিং।\n   * @return স্ট্রিংয়ের শক্তি।\n   *\n   * উদাহরণ:\n   * calculateEnergy(\"aabbccdd\")\n   * আউটপুট: 2\n   */\n  public static int calculateEnergy(String s) ",
      "bg": "public class Solution {\n\n  /**\n   * Изчислява енергията на низа, която се определя като дължината на най-дългия непразен подниз, съдържащ само един символ.\n   *\n   * @param s Входният низ.\n   * @return Енергията на низа.\n   *\n   * Пример:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "zh": "public class Solution {\n\n  /**\n   * 计算字符串的能量，定义为仅包含一个字符的最长非空子串的长度。\n   *\n   * @param s 输入字符串。\n   * @return 字符串的能量。\n   *\n   * 例子:\n   * calculateEnergy(\"aabbccdd\")\n   * 输出: 2\n   */\n  public static int calculateEnergy(String s) ",
      "fr": "public class Solution {\n\n  /**\n   * Calculer l'énergie de la chaîne, qui est définie comme la longueur de la plus longue sous-chaîne non vide contenant un seul caractère.\n   *\n   * @param s La chaîne d'entrée.\n   * @return L'énergie de la chaîne.\n   *\n   * Exemple:\n   * calculateEnergy(\"aabbccdd\")\n   * Output: 2\n   */\n  public static int calculateEnergy(String s) ",
      "de": "public class Solution {\n\n  /**\n   * Berechnet die Energie des Strings, die als die Länge des längsten nicht-leeren Substrings definiert ist, der nur ein Zeichen enthält.\n   *\n   * @param s Der Eingabestring.\n   * @return Die Energie des Strings.\n   *\n   * Beispiel:\n   * calculateEnergy(\"aabbccdd\")\n   * Ausgabe: 2\n   */\n  public static int calculateEnergy(String s) ",
      "ha": "public class Solution {\n\n  /**\n   * Lissafa kuzarin igiyar, wanda aka ayyana shi azaman tsawon mafi tsawo substring mara komai wanda ke dauke da harafi daya kawai.\n   *\n   * @param s Igiyar shigarwa.\n   * @return Kuzarin igiyar.\n   *\n   * Misali:\n   * calculateEnergy(\"aabbccdd\")\n   * Fitarwa: 2\n   */\n  public static int calculateEnergy(String s) ",
      "hi": "public class Solution {\n\n  /**\n   * स्ट्रिंग की ऊर्जा की गणना करें, जिसे केवल एक वर्ण वाली सबसे लंबी गैर-खाली उपस्ट्रिंग की लंबाई के रूप में परिभाषित किया गया है।\n   *\n   * @param s इनपुट स्ट्रिंग।\n   * @return स्ट्रिंग की ऊर्जा।\n   *\n   * उदाहरण:\n   * calculateEnergy(\"aabbccdd\")\n   * आउटपुट: 2\n   */\n  public static int calculateEnergy(String s) ",
      "hu": "public class Solution {\n\n  /**\n   * Számítsa ki a karakterlánc energiáját, amelyet az egyetlen karaktert tartalmazó leghosszabb nem üres részkarakterlánc hossza határoz meg.\n   *\n   * @param s A bemeneti karakterlánc.\n   * @return A karakterlánc energiája.\n   *\n   * Példa:\n   * calculateEnergy(\"aabbccdd\")\n   * Kimenet: 2\n   */\n  public static int calculateEnergy(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9760062444925096",
      "hy": "0.9809316820510318",
      "bn": "0.9711135809468583",
      "bg": "0.9782052814409469",
      "zh": "0.9742686259192165",
      "fr": "0.9919882435809578",
      "de": "0.9879465125876599",
      "ha": "0.955529835772385",
      "hi": "0.9664392121899642",
      "hu": "0.9846899674905929"
    },
    "canonical_solution": "  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }",
    "instruction": {
      "en": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nՏվեք Java կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\n请用中文为以下Java代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Java a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int calculateEnergy(String s)\n  {\n    if (s == null || s.length() == 0) {\n      return 0;\n    }\n\n    int maxEnergy = 1, currentEnergy = 1;\n    char lastChar = s.charAt(0);\n\n    // Start from the second character\n    for (int i = 1; i < s.length(); i++) {\n      char currentChar = s.charAt(i);\n      if (currentChar == lastChar) {\n        // Increment the energy of the current substring\n        currentEnergy++;\n      } else {\n        // Update the maximum energy if needed and reset current energy\n        maxEnergy = Math.max(maxEnergy, currentEnergy);\n        currentEnergy = 1;\n        lastChar = currentChar;\n      }\n    }\n\n    // Ensure we check the last sequence energy\n    maxEnergy = Math.max(maxEnergy, currentEnergy);\n\n    return maxEnergy;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9465259206000736",
      "bn": "0.8954556660714315",
      "bg": "0.8400592418438494",
      "zh": "0.8871169640452058",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9323453004372309",
      "hi": "0.9113991308659588",
      "hu": "0.9407980163021705"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert calculateEnergy(\"aabbccdd\") == 2 : \"Test case 1 failed\"; // Contains two characters 'aa', 'bb', 'cc', 'dd'\n    assert calculateEnergy(\"horizon\") == 1 : \"Test case 2 failed\"; // All characters are unique\n    assert calculateEnergy(\"success\") == 2 : \"Test case 3 failed\"; // Contains three characters 'ccc'\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateEnergy",
    "signature": "public static int calculateEnergy(String s)",
    "docstring": {
      "en": "Calculate the energy of the string, which is defined as the length of the longest non-empty substring containing only one character.\n   \n    @param s The input string.\n    @return The energy of the string.\n   \n    Example:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "sq": "Llogarit energjinë e vargut, e cila përcaktohet si gjatësia e nënvargut më të gjatë jo-bosh që përmban vetëm një karakter.\n   \n    @param s Vargu hyrës.\n    @return Energjia e vargut.\n   \n    Shembull:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "hy": "Հաշվեք տողի էներգիան, որը սահմանվում է որպես ամենաերկար ոչ դատարկ ենթատողի երկարությունը, որը պարունակում է միայն մեկ սիմվոլ։\n   \n    @param s Մուտքային տողը։\n    @return Տողի էներգիան։\n   \n    Օրինակ:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "bn": "স্ট্রিংয়ের শক্তি গণনা করুন, যা শুধুমাত্র একটি অক্ষর ধারণকারী দীর্ঘতম নন-এম্পটি সাবস্ট্রিংয়ের দৈর্ঘ্য হিসাবে সংজ্ঞায়িত করা হয়।\n   \n    @param s ইনপুট স্ট্রিং।\n    @return স্ট্রিংয়ের শক্তি।\n\n    উদাহরণ:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "bg": "Изчислете енергията на низа, която се определя като дължината на най-дългия непразен подниз, съдържащ само един символ.\n   \n    @param s Входният низ.\n    @return Енергията на низа.\n   \n    Пример:\n    calculateEnergy(\"aabbccdd\")\n    Изход: 2",
      "zh": "计算字符串的能量，其定义为仅包含一个字符的最长非空子字符串的长度。\n   \n    @param s 输入字符串。\n    @return 字符串的能量。\n   \n    示例：\n    calculateEnergy(\"aabbccdd\")\n    输出: 2",
      "fr": "Calculer l'énergie de la chaîne, qui est définie comme la longueur de la plus longue sous-chaîne non vide contenant un seul caractère.\n   \n    @param s La chaîne d'entrée.\n    @return L'énergie de la chaîne.\n   \n    Exemple :\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "de": "Berechnen Sie die Energie der Zeichenkette, die als die Länge der längsten nicht-leeren Teilzeichenkette definiert ist, die nur ein Zeichen enthält.\n   \n    @param s Die Eingabezeichenkette.\n    @return Die Energie der Zeichenkette.\n   \n    Beispiel:\n    calculateEnergy(\"aabbccdd\")\n    Ausgabe: 2",
      "ha": "Ƙididdige kuzarin igiyar, wanda aka ayyana azaman tsawon mafi tsawo ba komai ba substring mai ɗauke da harafi ɗaya kawai.\n   \n    @param s Jeren shigarwa.\n    @return Makaman jeren.\n   \n    Misali:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "hi": "स्ट्रिंग की ऊर्जा की गणना करें, जिसे केवल एक वर्ण वाली सबसे लंबी गैर-खाली उपस्ट्रिंग की लंबाई के रूप में परिभाषित किया गया है।\n   \n    @param s इनपुट स्ट्रिंग।\n    @return स्ट्रिंग की ऊर्जा।\n\n    उदाहरण:\n    calculateEnergy(\"aabbccdd\")\n    Output: 2",
      "hu": "Számítsa ki a karakterlánc energiáját, amelyet a leghosszabb nem üres, csak egy karaktert tartalmazó részkarakterlánc hossza határoz meg.\n   \n    @param s A bemeneti karakterlánc.\n    @return A karakterlánc energiája.\n\n    Példa:\n    calculateEnergy(\"aabbccdd\")\n    Kimenet: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9679768099695554",
      "hy": "0.9699913192940112",
      "bn": "0.9707826627320542",
      "bg": "0.967997864789945",
      "zh": "0.9793499883268509",
      "fr": "0.999999801369619",
      "de": "0.9911047356461146",
      "ha": "0.964353593189098",
      "hi": "0.9707826627320542",
      "hu": "0.9835297674349681"
    }
  },
  {
    "task_id": "Java/50",
    "prompt": {
      "en": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Return all integers in the range [1, n] in lexicographical order.\n   *\n   * @param n The upper limit of the range.\n   * @return List of integers in lexicographical order.\n   *\n   * Example:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "sq": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Kthen të gjitha numrat e plotë në intervalin [1, n] në rend leksikografik.\n   *\n   * @param n Kufiri i sipërm i intervalit.\n   * @return Lista e numrave të plotë në rend leksikografik.\n   *\n   * Shembull:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "hy": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Վերադարձնել բոլոր ամբողջ թվերը [1, n] միջակայքում բառարանային կարգով:\n   *\n   * @param n Միջակայքի վերին սահմանը:\n   * @return Բառարանային կարգով ամբողջ թվերի ցուցակ:\n   *\n   * Օրինակ:\n   * lexicalOrder(13)\n   * Արդյունք: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "bn": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * লেক্সিকোগ্রাফিক ক্রমে [1, n] সীমার মধ্যে সমস্ত পূর্ণসংখ্যা ফেরত দিন।\n   *\n   * @param n সীমার উপরের সীমা।\n   * @return লেক্সিকোগ্রাফিক ক্রমে পূর্ণসংখ্যার তালিকা।\n   *\n   * উদাহরণ:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "bg": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Връща всички цели числа в диапазона [1, n] в лексикографски ред.\n   *\n   * @param n Горната граница на диапазона.\n   * @return Списък с цели числа в лексикографски ред.\n   *\n   * Пример:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "zh": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * 返回范围 [1, n] 内按字典顺序排列的所有整数。\n   *\n   * @param n 范围的上限。\n   * @return 按字典顺序排列的整数列表。\n   *\n   * 示例:\n   * lexicalOrder(13)\n   * 输出: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "fr": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Retourne tous les entiers dans la plage [1, n] dans l'ordre lexicographique.\n   *\n   * @param n La limite supérieure de la plage.\n   * @return Liste d'entiers dans l'ordre lexicographique.\n   *\n   * Exemple:\n   * lexicalOrder(13)\n   * Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "de": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Gibt alle ganzen Zahlen im Bereich [1, n] in lexikographischer Reihenfolge zurück.\n   *\n   * @param n Die obere Grenze des Bereichs.\n   * @return Liste von ganzen Zahlen in lexikographischer Reihenfolge.\n   *\n   * Beispiel:\n   * lexicalOrder(13)\n   * Ausgabe: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "ha": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Mayar da duk lambobi a cikin kewayon [1, n] a cikin tsarin haruffa.\n   *\n   * @param n Iyakar sama na kewayon.\n   * @return Jerin lambobi a cikin tsarin haruffa.\n   *\n   * Misali:\n   * lexicalOrder(13)\n   * Fitarwa: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "hi": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * श्रेणी [1, n] में सभी पूर्णांकों को शब्दकोशीय क्रम में लौटाएं।\n   *\n   * @param n श्रेणी की ऊपरी सीमा।\n   * @return शब्दकोशीय क्रम में पूर्णांकों की सूची।\n   *\n   * उदाहरण:\n   * lexicalOrder(13)\n   * आउटपुट: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) ",
      "hu": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n\n  /**\n   * Visszaadja az összes egész számot az [1, n] tartományban lexikografikus sorrendben.\n   *\n   * @param n A tartomány felső határa.\n   * @return Egész számok listája lexikografikus sorrendben.\n   *\n   * Példa:\n   * lexicalOrder(13)\n   * Kimenet: [1,10,11,12,13,2,3,4,5,6,7,8,9]\n   */\n  public static List<Integer> lexicalOrder(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9926673608537161",
      "hy": "0.9903562963703751",
      "bn": "1",
      "bg": "0.9888254520237393",
      "zh": "0.9926254498433177",
      "fr": "0.998866615045815",
      "de": "0.998866615045815",
      "ha": "0.9829322872488152",
      "hi": "0.9921328464983512",
      "hu": "0.998866615045815"
    },
    "canonical_solution": "  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }",
    "instruction": {
      "en": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nজাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Java a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "public static List<Integer> lexicalOrder(int n)\n  {\n    List<Integer> result = new ArrayList<>();\n    for (int i = 1; i < 10; i++) { // start with all numbers from 1 to 9\n      dfs(i, n, result);\n    }\n    return result;\n  }\n\n  private static void dfs(int current, int n, List<Integer> result) {\n    if (current > n) {\n      return; // stop the recursion if current is greater than n\n    }\n    result.add(current); // add current number to the result list\n    for (int i = 0; i < 10; i++) { // traverse the next digit\n      if (10 * current + i > n) {\n        return; // stop if the next number is greater than n\n      }\n      dfs(10 * current + i, n, result); // recurse with next number\n    }\n  }\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Java kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9615433705582164",
      "bn": "0.8954556660714315",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.9168968225522425",
      "hi": "0.9212090881245099",
      "hu": "0.9407980163021705"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    // Test cases\n    assert lexicalOrder(13)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(2);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 1 failed\";\n\n    assert lexicalOrder(20)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(10);\n            add(11);\n            add(12);\n            add(13);\n            add(14);\n            add(15);\n            add(16);\n            add(17);\n            add(18);\n            add(19);\n            add(2);\n            add(20);\n            add(3);\n            add(4);\n            add(5);\n            add(6);\n            add(7);\n            add(8);\n            add(9);\n          }\n        }\n      ) : \"Test case 2 failed\";\n\n    assert lexicalOrder(2)\n      .equals(\n        new ArrayList<Integer>() {\n          {\n            add(1);\n            add(2);\n          }\n        }\n      ) : \"Test case 3 failed\";\n\n    System.out.println(\"All tests passed\");\n  }\n}\n",
    "entry_point": "lexicalOrder",
    "signature": "public static List<Integer> lexicalOrder(int n)",
    "docstring": {
      "en": "Return all integers in the range [1, n] in lexicographical order.\n   \n    @param n The upper limit of the range.\n    @return List of integers in lexicographical order.\n   \n    Example:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "sq": "Kthe të gjitha numrat e plotë në intervalin [1, n] në rend leksikografik.\n\n    @param n Kufiri i sipërm i intervalit.\n    @return Listë e numrave të plotë në rend leksikografik.\n\n    Shembull:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hy": "Բոլոր ամբողջ թվերը վերադարձնել [1, n] միջակայքում բառարանային կարգով։\n\n    @param n Միջակայքի վերին սահմանը։\n    @return Բառարանային կարգով ամբողջ թվերի ցուցակ։\n\n    Օրինակ:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "bn": "লেক্সিকোগ্রাফিক ক্রমে [1, n] পরিসরের সমস্ত পূর্ণসংখ্যা ফেরত দিন।\n\n    @param n পরিসরের উপরের সীমা।\n    @return বর্ণানুক্রমিক ক্রমে পূর্ণসংখ্যার তালিকা।\n\n    উদাহরণ:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "bg": "Върнете всички цели числа в диапазона [1, n] в лексикографски ред.\n   \n    @param n Горната граница на диапазона.\n    @return Списък от цели числа в лексикографски ред.\n   \n    Пример:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "zh": "返回范围 [1, n] 内的所有整数，按字典顺序排列。\n\n    @param n 范围的上限。\n    @return 按字典顺序排列的整数列表。\n\n    示例：\n    lexicalOrder(13)\n    输出: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "fr": "Retourne tous les entiers dans la plage [1, n] dans l'ordre lexicographique.\n\n    @param n La limite supérieure de la plage.\n    @return Liste des entiers dans l'ordre lexicographique.\n   \n    Exemple:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "de": "Gibt alle ganzen Zahlen im Bereich [1, n] in lexikographischer Reihenfolge zurück.\n   \n    @param n Die obere Grenze des Bereichs.\n    @return Liste von ganzen Zahlen in lexikographischer Reihenfolge.\n   \n    Beispiel:\n    lexicalOrder(13)\n    Ausgabe: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "ha": "Mayar da duk lambobi a cikin kewayon [1, n] a cikin tsari na haruffa.\n\n    @param n Iyakar sama na kewayon.\n    @return Jerin lambobin cikakkun adadi a cikin tsari na haruffa.\n\n    Misali:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hi": "श्रेणी [1, n] में सभी पूर्णांकों को शब्दकोशीय क्रम में लौटाएं।\n\n    @param n श्रेणी की ऊपरी सीमा।\n    @return शब्दकोशीय क्रम में पूर्णांकों की सूची।\n\n    उदाहरण:\n    lexicalOrder(13)\n    Output: [1,10,11,12,13,2,3,4,5,6,7,8,9]",
      "hu": "Adja vissza az összes egész számot a [1, n] tartományban lexikografikus sorrendben.\n   \n    @param n A tartomány felső határa.\n    @return Egész számok listája lexikografikus sorrendben.\n   \n    Példa:\n    lexicalOrder(13)\n    Kimenet: [1,10,11,12,13,2,3,4,5,6,7,8,9]"
    },
    "docstring_bertscore": {
      "sq": "0.9656591906836403",
      "hy": "0.994670548246453",
      "bn": "0.9890316303592535",
      "bg": "0.9865997986042433",
      "zh": "0.9626729815351618",
      "fr": "1",
      "de": "0.9920089011405854",
      "ha": "0.9528070105091588",
      "hi": "0.9818644503203716",
      "hu": "1"
    }
  },
  {
    "task_id": "Java/51",
    "prompt": {
      "en": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calculate the sum of unique elements in the given integer array.\n   *\n   * @param nums An array of integers.\n   * @return The sum of unique elements.\n   *\n   * Example:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "sq": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Llogarit shumën e elementeve unike në vargun e dhënë të numrave të plotë.\n   *\n   * @param nums Një varg me numra të plotë.\n   * @return Shuma e elementeve unike.\n   *\n   * Shembull:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "hy": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Հաշվել տրված ամբողջ թիվերի զանգվածի եզակի տարրերի գումարը։\n   *\n   * @param nums Ամբողջ թիվերի զանգված։\n   * @return Եզակի տարրերի գումարը։\n   *\n   * Օրինակ:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Արդյունք: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "bn": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * প্রদত্ত পূর্ণসংখ্যার অ্যারেতে অনন্য উপাদানগুলির যোগফল গণনা করুন।\n   *\n   * @param nums পূর্ণসংখ্যার একটি অ্যারে।\n   * @return অনন্য উপাদানগুলির যোগফল।\n   *\n   * উদাহরণ:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * আউটপুট: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "bg": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Изчислете сумата на уникалните елементи в дадения масив от цели числа.\n   *\n   * @param nums Масив от цели числа.\n   * @return Сумата на уникалните елементи.\n   *\n   * Пример:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Изход: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "zh": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * 计算给定整数数组中唯一元素的和。\n   *\n   * @param nums 一个整数数组。\n   * @return 唯一元素的和。\n   *\n   * 示例:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * 输出: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "fr": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Calculer la somme des éléments uniques dans le tableau d'entiers donné.\n   *\n   * @param nums Un tableau d'entiers.\n   * @return La somme des éléments uniques.\n   *\n   * Exemple:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Output: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "de": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Berechne die Summe der einzigartigen Elemente im gegebenen Integer-Array.\n   *\n   * @param nums Ein Array von ganzen Zahlen.\n   * @return Die Summe der einzigartigen Elemente.\n   *\n   * Beispiel:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Ausgabe: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "ha": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Lissafa jimillar abubuwan da ba su maimaita kansu ba a cikin jerin lambobin cikakke da aka bayar.\n   *\n   * @param nums Jerin lambobin cikakke.\n   * @return Jimillar abubuwan da ba su maimaita kansu ba.\n   *\n   * Misali:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Fitarwa: 4\n   */\n  public static int calculateUniqueSum(int[] nums)",
      "hi": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * दिए गए पूर्णांक array में अद्वितीय तत्वों का योग गणना करें।\n   *\n   * @param nums पूर्णांकों का एक array।\n   * @return अद्वितीय तत्वों का योग।\n   *\n   * उदाहरण:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * आउटपुट: 4\n   */\n  public static int calculateUniqueSum(int[] nums) ",
      "hu": "import java.util.HashMap;\n\npublic class Solution {\n\n  /**\n   * Számítsa ki az egyedi elemek összegét a megadott egész szám tömbben.\n   *\n   * @param nums Egész számokat tartalmazó tömb.\n   * @return Az egyedi elemek összege.\n   *\n   * Példa:\n   * calculateUniqueSum(new int[]{1, 2, 3, 2})\n   * Kimenet: 4\n   */\n  public static int calculateUniqueSum(int[] nums) "
    },
    "prompt_bertscore": {
      "sq": "0.9921084149614839",
      "hy": "0.9759730732188768",
      "bn": "1",
      "bg": "0.9886885956912063",
      "zh": "0.9919433531148439",
      "fr": "1",
      "de": "0.9911122836005939",
      "ha": "0.9710879576277048",
      "hi": "1",
      "hu": "0.986307017422598"
    },
    "canonical_solution": "  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }",
    "instruction": {
      "en": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nՏվեք Java կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nনিচের জাভা কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, като използвате не повече от 500 символа.",
      "zh": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nGeben Sie eine prägnante Beschreibung des Java-Codes in natürlicher Sprache auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar Java a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static int calculateUniqueSum(int[] nums)\n  {\n    HashMap<Integer, Integer> hashMap = new HashMap<>();\n    for (int num : nums) {\n      hashMap.put(num, hashMap.getOrDefault(num, 0) + 1);\n    }\n\n    int sum = 0;\n    for (int key : hashMap.keySet()) {\n      if (hashMap.get(key) == 1) {\n        sum += key;\n      }\n    }\n\n    return sum;\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9615433705582164",
      "bn": "0.8643475662064145",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.8691027775283897",
      "ha": "0.9168968225522425",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert calculateUniqueSum(new int[] { 1, 4, 5, 1, 2, 4 }) == 7; // Test Case 1\n    assert calculateUniqueSum(new int[] { 0, 0, 0, 0 }) == 0; // Test Case 2\n    assert calculateUniqueSum(new int[] { -1, -2, -3, -2 }) == -4; // Test Case 3\n\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "calculateUniqueSum",
    "signature": "public static int calculateUniqueSum(int[] nums)",
    "docstring": {
      "en": "Calculate the sum of unique elements in the given integer array.\n\n   @param nums An array of integers.\n   @return The sum of unique elements.\n\n   Example:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "sq": "Llogarit shumën e elementeve unike në vargun e dhënë të numrave të plotë.\n\n   @param nums Një varg me numra të plotë.\n   @return Shuma e elementeve unike.\n\n   Shembull:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "hy": "Հաշվարկել տրված ամբողջ թվերի զանգվածում եզակի տարրերի գումարը։\n\n   @param nums Ամբողջ թվերի զանգված։\n   @return Եզակի տարրերի գումարը։\n\n   Օրինակ:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Արդյունք: 4",
      "bn": "অনন্য উপাদানগুলির যোগফল গণনা করুন প্রদত্ত পূর্ণসংখ্যার অ্যারেতে।\n\n   @param nums পূর্ণসংখ্যার একটি অ্যারে।\n   @return অনন্য উপাদানগুলির যোগফল।\n\n   উদাহরণ:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   আউটপুট: 4",
      "bg": "Изчислете сумата на уникалните елементи в дадения масив от цели числа.\n\n   @param nums Масив от цели числа.\n   @return Сумата на уникалните елементи.\n\n   Пример:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Изход: 4",
      "zh": "计算给定整数数组中唯一元素的和。\n\n   @param nums 一个整数数组。\n   @return 唯一元素的和。\n\n   示例：\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   输出: 4",
      "fr": "Calculer la somme des éléments uniques dans le tableau d'entiers donné.\n\n   @param nums Un tableau d'entiers.\n   @return La somme des éléments uniques.\n\n   Exemple :\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Sortie : 4",
      "de": "Berechne die Summe der einzigartigen Elemente im gegebenen Integer-Array.\n\n   @param nums Ein Array von Ganzzahlen.\n   @return Die Summe der einzigartigen Elemente.\n\n   Beispiel:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Ausgabe: 4",
      "ha": "Lissafa jumillar abubuwan da ba su maimaita kansu ba a cikin jerin lambobin da aka bayar.\n\n   @param nums Wani tsararren lambobi.\n   @return Jimillar abubuwan da ba su maimaita kansu ba.\n\n   Misali:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Output: 4",
      "hi": "अद्वितीय तत्वों का योग दिए गए पूर्णांक सरणी में गणना करें।\n\n   @param nums पूर्णांकों की एक सरणी।\n   @return अद्वितीय तत्वों का योग।\n\n   उदाहरण:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   आउटपुट: 4",
      "hu": "Számítsa ki az egyedi elemek összegét a megadott egész szám tömbben.\n\n   @param nums Egy egész számokat tartalmazó tömb.\n   @return Az egyedi elemek összege.\n\n   Példa:\n   calculateUniqueSum(new int[]{1, 2, 3, 2})\n   Kimenet: 4"
    },
    "docstring_bertscore": {
      "sq": "0.9908139407682796",
      "hy": "0.9548250951804733",
      "bn": "0.9952626654123179",
      "bg": "0.979789160099319",
      "zh": "0.9846266043990427",
      "fr": "0.9908139407682796",
      "de": "0.9899481109373485",
      "ha": "1",
      "hi": "1",
      "hu": "0.9709793068092787"
    }
  },
  {
    "task_id": "Java/52",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   *\n   * @param n The target integer.\n   * @return The minimum number of perfect square numbers.\n   *\n   * Example:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Example:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "sq": "public class Solution {\n\n  /**\n   * Duke pasur një numër të plotë n, kthe numrin minimal të numrave katrorë të përsosur që shuma e tyre është n.\n   *\n   * @param n Numri i plotë objektiv.\n   * @return Numri minimal i numrave katrorë të përsosur.\n   *\n   * Shembull:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Shembull:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "hy": "public class Solution {\n\n  /**\n   * Տրված է ամբողջ թիվ n, վերադարձնել կատարյալ քառակուսիների նվազագույն քանակը, որոնք գումարվում են n-ի:\n   *\n   * @param n Նպատակային ամբողջ թիվը։\n   * @return Կատարյալ քառակուսիների նվազագույն քանակը։\n   *\n   * Օրինակ:\n   * minPerfectSquareSum(12)\n   * Արդյունք: 3\n   *\n   * Օրինակ:\n   * minPerfectSquareSum(13)\n   * Արդյունք: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "bn": "public class Solution {\n\n  /**\n   * একটি পূর্ণসংখ্যা n দেওয়া হলে, n এর সমষ্টি হিসাবে ন্যূনতম সংখ্যক পূর্ণবর্গ সংখ্যা ফেরত দিন।\n   *\n   * @param n লক্ষ্য পূর্ণসংখ্যা।\n   * @return ন্যূনতম সংখ্যক পূর্ণবর্গ সংখ্যা।\n   *\n   * উদাহরণ:\n   * minPerfectSquareSum(12)\n   * আউটপুট: 3\n   *\n   * উদাহরণ:\n   * minPerfectSquareSum(13)\n   * আউটপুট: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "bg": "public class Solution {\n\n  /**\n   * Дадено е цяло число n, върнете минималния брой перфектни квадратни числа, които се сумират до n.\n   *\n   * @param n Целевото цяло число.\n   * @return Минималният брой перфектни квадратни числа.\n   *\n   * Пример:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Пример:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "zh": "public class Solution {\n\n  /**\n   * 给定一个整数 n，返回其和为 n 的最小完全平方数数量。\n   *\n   * @param n 目标整数。\n   * @return 最小完全平方数数量。\n   *\n   * 示例:\n   * minPerfectSquareSum(12)\n   * 输出: 3\n   *\n   * 示例:\n   * minPerfectSquareSum(13)\n   * 输出: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "fr": "public class Solution {\n\n  /**\n   * Étant donné un entier n, renvoie le nombre minimum de nombres carrés parfaits qui s'additionnent pour donner n.\n   *\n   * @param n L'entier cible.\n   * @return Le nombre minimum de nombres carrés parfaits.\n   *\n   * Exemple:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Exemple:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "de": "public class Solution {\n\n  /**\n   * Gegeben eine ganze Zahl n, gib die minimale Anzahl von perfekten Quadratzahlen zurück, die sich zu n summieren.\n   *\n   * @param n Die Zielzahl.\n   * @return Die minimale Anzahl von perfekten Quadratzahlen.\n   *\n   * Beispiel:\n   * minPerfectSquareSum(12)\n   * Ausgabe: 3\n   *\n   * Beispiel:\n   * minPerfectSquareSum(13)\n   * Ausgabe: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "ha": "public class Solution {\n\n  /**\n   * Idan aka ba da cikakken lamba n, dawo da mafi ƙarancin adadin lambobin murabba'i masu cikakken da suka taru zuwa n.\n   *\n   * @param n Cikakken lambar da ake nufi.\n   * @return Mafi ƙarancin adadin lambobin murabba'i masu cikakken.\n   *\n   * Misali:\n   * minPerfectSquareSum(12)\n   * Output: 3\n   *\n   * Misali:\n   * minPerfectSquareSum(13)\n   * Output: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए एक पूर्णांक n के लिए, उन पूर्ण वर्ग संख्याओं की न्यूनतम संख्या लौटाएं जिनका योग n होता है।\n   *\n   * @param n लक्षित पूर्णांक।\n   * @return पूर्ण वर्ग संख्याओं की न्यूनतम संख्या।\n   *\n   * उदाहरण:\n   * minPerfectSquareSum(12)\n   * आउटपुट: 3\n   *\n   * उदाहरण:\n   * minPerfectSquareSum(13)\n   * आउटपुट: 2\n   */\n  public static int minPerfectSquareSum(int n) ",
      "hu": "public class Solution {\n\n  /**\n   * Adott egy egész szám n, térj vissza a legkisebb számú tökéletes négyzet számmal, amelyek összege n.\n   *\n   * @param n A cél egész szám.\n   * @return A legkisebb számú tökéletes négyzet szám.\n   *\n   * Példa:\n   * minPerfectSquareSum(12)\n   * Kimenet: 3\n   *\n   * Példa:\n   * minPerfectSquareSum(13)\n   * Kimenet: 2\n   */\n  public static int minPerfectSquareSum(int n) "
    },
    "prompt_bertscore": {
      "sq": "0.9961497486940197",
      "hy": "0.9688009274204691",
      "bn": "0.9797585710206397",
      "bg": "1",
      "zh": "0.975353346430048",
      "fr": "0.9982762855533792",
      "de": "0.9738667966583828",
      "ha": "0.9848377484940829",
      "hi": "0.9635537086446704",
      "hu": "0.9745755098579153"
    },
    "canonical_solution": "  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }",
    "instruction": {
      "en": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Java կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\n请用最多500个字符的中文对该Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nFournir une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na Java cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static int minPerfectSquareSum(int n)\n  {\n    int[] dp = new int[n + 1];\n    for (int i = 1; i <= n; i++) {\n      dp[i] = Integer.MAX_VALUE;\n      for (int j = 1; j * j <= i; j++) {\n        dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n      }\n    }\n    return dp[n];\n  }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550874859138204",
      "hy": "0.9497000340890112",
      "bn": "0.9238701393392342",
      "bg": "0.8376140553201085",
      "zh": "0.9022569008771947",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8451938371936013",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    assert minPerfectSquareSum(26) == 2 : \"Test case 1 failed\";\n    assert minPerfectSquareSum(17) == 2 : \"Test case 2 failed\";\n    assert minPerfectSquareSum(99) == 3 : \"Test case 3 failed\";\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "minPerfectSquareSum",
    "signature": "public static int minPerfectSquareSum(int n)",
    "docstring": {
      "en": "Given an integer n, return the minimum number of perfect square numbers that sum up to n.\n   \n    @param n The target integer.\n    @return The minimum number of perfect square numbers.\n   \n    Example:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Example:\n    minPerfectSquareSum(13)\n    Output: 2",
      "sq": "Duke pasur një numër të plotë n, kthe numrin minimal të numrave të katrorëve të përsosur që shuma e tyre është n.\n   \n    @param n Numri i plotë i synuar.\n    @return Numri minimal i numrave të katrorëve të përsosur.\n   \n    Shembull:\n    minPerfectSquareSum(12)\n    Output: 3\n   \n    Shembull:\n    minPerfectSquareSum(13)\n    Output: 2",
      "hy": "Տրված է ամբողջ թիվ n, վերադարձնել նվազագույն քանակությամբ կատարյալ քառակուսի թվեր, որոնք գումարվում են n-ի:\n\n    @param n Նպատակային ամբողջ թիվը։\n    @return Կատարյալ քառակուսի թվերի նվազագույն քանակը։\n\n    Օրինակ:\n    minPerfectSquareSum(12)\n    Արդյունք: 3\n\n    Օրինակ:\n    minPerfectSquareSum(13)\n    Արդյունք: 2",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, n এর সমষ্টি হিসেবে ন্যূনতম সংখ্যক নিখুঁত বর্গ সংখ্যা ফেরত দিন।\n\n    @param n লক্ষ্য পূর্ণসংখ্যা।\n    @return ন্যূনতম সংখ্যক নিখুঁত বর্গ সংখ্যা।\n\n    উদাহরণ:\n    minPerfectSquareSum(12)\n    আউটপুট: 3\n\n    উদাহরণ:\n    minPerfectSquareSum(13)\n    আউটপুট: 2",
      "bg": "Като се даде цяло число n, върнете минималния брой перфектни квадратни числа, които се сумират до n.\n   \n    @param n Целевото цяло число.\n    @return Минималният брой перфектни квадратни числа.\n   \n    Пример:\n    minPerfectSquareSum(12)\n    Изход: 3\n   \n    Пример:\n    minPerfectSquareSum(13)\n    Изход: 2",
      "zh": "给定一个整数 n，返回其和为 n 的最少完全平方数的数量。\n\n    @param n 目标整数。\n    @return 完全平方数的最少数量。\n   \n    示例:\n    minPerfectSquareSum(12)\n    输出: 3\n   \n    示例:\n    minPerfectSquareSum(13)\n    输出: 2",
      "fr": "Étant donné un entier n, renvoyer le nombre minimum de nombres carrés parfaits qui s'additionnent pour donner n.\n   \n    @param n L'entier cible.\n    @return Le nombre minimum de nombres carrés parfaits.\n   \n    Exemple:\n    minPerfectSquareSum(12)\n    Sortie: 3\n   \n    Exemple:\n    minPerfectSquareSum(13)\n    Sortie: 2",
      "de": "Gegeben eine ganze Zahl n, gib die minimale Anzahl von perfekten Quadratzahlen zurück, die sich zu n summieren.\n\n    @param n Die Zielzahl.\n    @return Die minimale Anzahl von perfekten Quadratzahlen.\n   \n    Beispiel:\n    minPerfectSquareSum(12)\n    Ausgabe: 3\n   \n    Beispiel:\n    minPerfectSquareSum(13)\n    Ausgabe: 2",
      "ha": "An ba da wani lamba n, dawo da mafi ƙarancin adadin lambobin murabba'in cikakke waɗanda ke haɗuwa zuwa n.\n   \n    @param n Lambar manufa.\n    @return Mafi ƙarancin adadin lambobin murabba'in cikakke.\n   \n    Misali:\n    minPerfectSquareSum(12)\n    Fitarwa: 3\n   \n    Misali:\n    minPerfectSquareSum(13)\n    Fitarwa: 2",
      "hi": "दिए गए पूर्णांक n के लिए, उन संपूर्ण वर्ग संख्याओं की न्यूनतम संख्या लौटाएं जिनका योग n के बराबर होता है।\n\n    @param n लक्ष्य पूर्णांक।\n    @return संपूर्ण वर्ग संख्याओं की न्यूनतम संख्या।\n\n    उदाहरण:\n    minPerfectSquareSum(12)\n    आउटपुट: 3\n\n    उदाहरण:\n    minPerfectSquareSum(13)\n    आउटपुट: 2",
      "hu": "Adott egy egész szám n, add vissza a legkisebb számú tökéletes négyzet számot, amelyek összege n.\n\n    @param n A cél egész szám.\n    @return A legkisebb számú tökéletes négyzet szám.\n\n    Példa:\n    minPerfectSquareSum(12)\n    Kimenet: 3\n\n    Példa:\n    minPerfectSquareSum(13)\n    Kimenet: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9937860471597045",
      "hy": "0.9466371536134531",
      "bn": "0.9687681534075984",
      "bg": "0.9948600416299602",
      "zh": "0.9470731472998247",
      "fr": "0.999999801369619",
      "de": "0.8884108423472671",
      "ha": "0.962423899037344",
      "hi": "0.9747880443656227",
      "hu": "0.96537316293495"
    }
  },
  {
    "task_id": "Java/53",
    "prompt": {
      "en": "public class Solution {\n\n  /**\n   * Reverse the characters of each word in the given string while maintaining the original word order.\n   *\n   * @param s The input string containing words separated by spaces.\n   * @return The string with characters of each word reversed.\n   *\n   * Example:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "sq": "public class Solution {\n\n  /**\n   * Kthen karakteret e secilës fjalë në vargun e dhënë duke ruajtur rendin origjinal të fjalëve.\n   *\n   * @param s Vargu hyrës që përmban fjalë të ndara me hapësira.\n   * @return Vargu me karakteret e secilës fjalë të kthyera.\n   *\n   * Shembull:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "hy": "public class Solution {\n\n  /**\n   * Շրջել տրված տողի յուրաքանչյուր բառի նիշերը՝ պահպանելով բնօրինակ բառերի հերթականությունը:\n   *\n   * @param s Մուտքային տող, որը պարունակում է բառեր, որոնք բաժանված են բացատներով:\n   * @return Տող, որտեղ յուրաքանչյուր բառի նիշերը շրջված են:\n   *\n   * Օրինակ:\n   * reverseWords(\"Mr Ding\")\n   * Արդյունք: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "bn": "public class Solution {\n\n  /**\n   * প্রদত্ত স্ট্রিংয়ের প্রতিটি শব্দের অক্ষর উল্টানো, মূল শব্দের ক্রম বজায় রেখে।\n   *\n   * @param s ইনপুট স্ট্রিং যা স্পেস দ্বারা পৃথক করা শব্দগুলি ধারণ করে।\n   * @return স্ট্রিং যা প্রতিটি শব্দের অক্ষর উল্টানো অবস্থায় রয়েছে।\n   *\n   * উদাহরণ:\n   * reverseWords(\"Mr Ding\")\n   * আউটপুট: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "bg": "public class Solution {\n\n  /**\n   * Обърнете символите на всяка дума в дадения низ, като запазите оригиналния ред на думите.\n   *\n   * @param s Входният низ, съдържащ думи, разделени с интервали.\n   * @return Низът с обърнати символи на всяка дума.\n   *\n   * Пример:\n   * reverseWords(\"Mr Ding\")\n   * Изход: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "zh": "public class Solution {\n\n  /**\n   * 反转给定字符串中每个单词的字符，同时保持原始单词顺序。\n   *\n   * @param s 输入字符串，其中包含由空格分隔的单词。\n   * @return 每个单词字符反转后的字符串。\n   *\n   * 示例:\n   * reverseWords(\"Mr Ding\")\n   * 输出: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "fr": "public class Solution {\n\n  /**\n   * Inverser les caractères de chaque mot dans la chaîne donnée tout en maintenant l'ordre original des mots.\n   *\n   * @param s La chaîne d'entrée contenant des mots séparés par des espaces.\n   * @return La chaîne avec les caractères de chaque mot inversés.\n   *\n   * Exemple:\n   * reverseWords(\"Mr Ding\")\n   * Output: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "de": "public class Solution {\n\n  /**\n   * Kehre die Zeichen jedes Wortes in dem gegebenen String um, während die ursprüngliche Wortreihenfolge beibehalten wird.\n   *\n   * @param s Der Eingabestring, der Wörter enthält, die durch Leerzeichen getrennt sind.\n   * @return Der String mit umgekehrten Zeichen jedes Wortes.\n   *\n   * Beispiel:\n   * reverseWords(\"Mr Ding\")\n   * Ausgabe: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "ha": "public class Solution {\n\n  /**\n   * Juya haruffan kowanne kalma a cikin igiyar da aka bayar yayin da ake kiyaye tsarin kalmomi na asali.\n   *\n   * @param s Igiyar shigarwa da ke dauke da kalmomi da aka raba ta wurin sarari.\n   * @return Igiyar da ke dauke da haruffan kowanne kalma an juyasu.\n   *\n   * Misali:\n   * reverseWords(\"Mr Ding\")\n   * Fitarwa: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "hi": "public class Solution {\n\n  /**\n   * दिए गए स्ट्रिंग में प्रत्येक शब्द के अक्षरों को उलटें जबकि मूल शब्द क्रम को बनाए रखें।\n   *\n   * @param s इनपुट स्ट्रिंग जिसमें शब्द स्पेस द्वारा अलग किए गए हैं।\n   * @return स्ट्रिंग जिसमें प्रत्येक शब्द के अक्षर उलटे हुए हैं।\n   *\n   * उदाहरण:\n   * reverseWords(\"Mr Ding\")\n   * आउटपुट: \"rM gniD\"\n   */\n  public static String reverseWords(String s) ",
      "hu": "public class Solution {\n\n  /**\n   * Fordítsa meg az egyes szavak karaktereit a megadott sztringben, miközben megőrzi az eredeti szórendet.\n   *\n   * @param s A bemeneti sztring, amely szavakat tartalmaz, szóközökkel elválasztva.\n   * @return A sztring, amelyben az egyes szavak karakterei meg vannak fordítva.\n   *\n   * Példa:\n   * reverseWords(\"Mr Ding\")\n   * Kimenet: \"rM gniD\"\n   */\n  public static String reverseWords(String s) "
    },
    "prompt_bertscore": {
      "sq": "0.9713926566322123",
      "hy": "0.9596311558799935",
      "bn": "0.9689282494947125",
      "bg": "0.9800424138351386",
      "zh": "0.9725882128956613",
      "fr": "0.9855381192176118",
      "de": "0.9957149467899343",
      "ha": "0.9759182512337112",
      "hi": "0.9568463579378843",
      "hu": "0.9968697838252712"
    },
    "canonical_solution": "  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }",
    "instruction": {
      "en": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nProvide a concise natural language description (docstring) of the Java code in English using at most 500 characters.",
      "sq": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Java në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nՏվեք Java կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nজাভা কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nПредоставете кратко описание на Java кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\n请用不超过500个字符的中文，为以下Java代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nFournissez une description concise en langage naturel (docstring) du code Java en français en utilisant au maximum 500 caractères.",
      "de": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Java-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nBayar da gajeriyar bayanin yanayi (docstring) na lambar Java cikin harshen Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nजावा कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "public static String reverseWords(String s)\n  {\n    String[] words = s.split(\" \");\n    StringBuilder reversedString = new StringBuilder();\n    for (String word : words) {\n      StringBuilder reverse = new StringBuilder(word).reverse();\n      reversedString.append(reverse.toString()).append(\" \");\n    }\n    return reversedString.toString().trim();\n  }\n\n  private static void testReverseWords(String input, String expectedOutput) {\n    assert reverseWords(input).equals(expectedOutput) : \"Test failed\";\n  }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Java kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9549017665075528",
      "hy": "0.9242475370632005",
      "bn": "0.9137427707317894",
      "bg": "0.8376140553201085",
      "zh": "0.871968616665961",
      "fr": "0.9692740649880942",
      "de": "0.9218500683641094",
      "ha": "0.8888063154359075",
      "hi": "0.9113991308659588",
      "hu": "0.9527698666279053"
    },
    "level": "",
    "test": "  public static void main(String[] args) {\n    testReverseWords(\"The quick brown fox\", \"ehT kciuq nworb xof\");\n    testReverseWords(\"Hello World\", \"olleH dlroW\");\n    testReverseWords(\"a b c d e f\", \"a b c d e f\");\n    System.out.println(\"All tests passed\");\n  }\n}",
    "entry_point": "reverseWords",
    "signature": "public static String reverseWords(String s)",
    "docstring": {
      "en": "Reverse the characters of each word in the given string while maintaining the original word order.\n   \n    @param s The input string containing words separated by spaces.\n    @return The string with characters of each word reversed.\n   \n    Example:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "sq": "Kthe karakteret e secilës fjalë në vargun e dhënë duke ruajtur rendin origjinal të fjalëve.\n\n    @param s Vargu hyrës që përmban fjalë të ndara me hapësira.\n    @return Vargu me karakteret e secilës fjalë të kthyera.\n\n    Shembull:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "hy": "Շրջել տրված տողի յուրաքանչյուր բառի նիշերը՝ պահպանելով սկզբնական բառերի հերթականությունը։\n\n    @param s Մուտքային տողը, որը պարունակում է բառեր, բաժանված բացատներով։\n    @return Տողը, որտեղ յուրաքանչյուր բառի նիշերը շրջված են։\n\n    Օրինակ:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "bn": "প্রতিটি শব্দের অক্ষরগুলি উল্টে দিন প্রদত্ত স্ট্রিং-এ, মূল শব্দের ক্রম বজায় রেখে।\n\n    @param s শব্দগুলি স্পেস দ্বারা পৃথক করা ইনপুট স্ট্রিং।\n    @return প্রতিটি শব্দের অক্ষর উল্টানো স্ট্রিং।\n\n    উদাহরণ:\n    reverseWords(\"Mr Ding\")\n    আউটপুট: \"rM gniD\"",
      "bg": "Обърнете символите на всяка дума в дадения низ, като запазите оригиналния ред на думите.\n\n    @param s Входният низ, съдържащ думи, разделени с интервали.\n    @return Низът с обърнати символи на всяка дума.\n\n    Пример:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "zh": "将给定字符串中每个单词的字符反转，同时保持原始单词顺序。\n\n    @param s 输入字符串，其中包含以空格分隔的单词。\n    @return 字符反转后的字符串。\n   \n    示例:\n    reverseWords(\"Mr Ding\")\n    输出: \"rM gniD\"",
      "fr": "Inversez les caractères de chaque mot dans la chaîne donnée tout en conservant l'ordre original des mots.\n\n    @param s La chaîne d'entrée contenant des mots séparés par des espaces.\n    @return La chaîne avec les caractères de chaque mot inversés.\n   \n    Exemple:\n    reverseWords(\"Mr Ding\")\n    Sortie: \"rM gniD\"",
      "de": "Kehrt die Zeichen jedes Wortes in der gegebenen Zeichenkette um, während die ursprüngliche Wortreihenfolge beibehalten wird.\n\n    @param s Der Eingabestring, der Wörter enthält, die durch Leerzeichen getrennt sind.\n    @return Der String mit umgekehrten Zeichen jedes Wortes.\n   \n    Beispiel:\n    reverseWords(\"Mr Ding\")\n    Ausgabe: \"rM gniD\"",
      "ha": "Juya haruffan kowace kalma a cikin igiyar da aka bayar yayin da ake kiyaye tsarin kalmomi na asali.\n\n    @param s Kalmomin da aka shigar a cikin igiyar rubutu da aka raba su da sarari.\n    @return Igiyar rubutu tare da haruffan kowace kalma an juyasu baya.\n\n    Misali:\n    reverseWords(\"Mr Ding\")\n    Output: \"rM gniD\"",
      "hi": "प्रत्येक शब्द के वर्णों को उलटें लेकिन मूल शब्द क्रम को बनाए रखें।\n\n    @param s इनपुट स्ट्रिंग जिसमें शब्द स्पेस द्वारा अलग किए गए हैं।\n    @return स्ट्रिंग जिसमें प्रत्येक शब्द के वर्ण उलटे हुए हैं।\n\n    उदाहरण:\n    reverseWords(\"Mr Ding\")\n    आउटपुट: \"rM gniD\"",
      "hu": "Fordítsa meg az egyes szavak karaktereit a megadott szövegben, miközben megőrzi az eredeti szórendet.\n   \n    @param s A bemeneti szöveg, amely szóközökkel elválasztott szavakat tartalmaz.\n    @return A szöveg, amelyben az egyes szavak karakterei meg vannak fordítva.\n   \n    Példa:\n    reverseWords(\"Mr Ding\")\n    Kimenet: \"rM gniD\""
    },
    "docstring_bertscore": {
      "sq": "0.980323873085065",
      "hy": "0.908883874350914",
      "bn": "0.9336312335240508",
      "bg": "0.9804698664151257",
      "zh": "0.9626489472590565",
      "fr": "0.9814650046241105",
      "de": "0.9920754423182321",
      "ha": "0.9558498293162323",
      "hi": "0.928662693172844",
      "hu": "0.9918106680203126"
    }
  }
]