[
  {
    "task_id": "Kotlin/1",
    "prompt": {
      "en": "/**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "sq": "/**\n    * Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n    * pragu i dhënë.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "hy": "/**\n    * Ստուգել, արդյոք տրված թվերի ցանկում որևէ երկու թիվ միմյանց ավելի մոտ են, քան\n    * տրված շեմը։\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "bn": "/**\n    * প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "bg": "/**\n    * Проверете дали в дадения списък от числа, някои две числа са по-близо едно до друго от\n    * дадения праг.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "zh": "/**\n    * 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "fr": "/**\n    * Vérifiez si, dans la liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que\n    * le seuil donné.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "de": "/**\n    * Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n    * der gegebene Schwellenwert.\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "ha": "/**\n    * Duba idan a cikin jerin lambobin da aka bayar, ko akwai lambobi biyu da suka fi kusanci da juna fiye da\n    * ƙayyadadden ƙima.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "hi": "/**\n    * जाँचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "hu": "/**\n    * Ellenőrizze, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a\n    * megadott küszöbérték.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean"
    },
    "prompt_bertscore": {
      "sq": "0.9879711427549082",
      "hy": "0.9683065364020732",
      "bn": "0.9400390496162362",
      "bg": "0.9879711427549082",
      "zh": "0.908587716452791",
      "fr": "0.9794771117707133",
      "de": "0.9666555206749112",
      "ha": "0.9495764859920074",
      "hi": "0.9255964359808084",
      "hu": "0.9681571663555351"
    },
    "canonical_solution": "{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}",
    "instruction": {
      "en": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nՏվեք կարճ բնութագրություն (docstring) Kotlin կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nনিম্নলিখিত Kotlin কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\n请用最多500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean\n{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9028212778609671",
      "bn": "0.8681205502941722",
      "bg": "0.8383597137705134",
      "zh": "0.8815686216117583",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "// Test cases\nfun main() {\n    println(\"start\")\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n\n}",
    "entry_point": "hasCloseElements",
    "signature": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se sa pragu i dhënë.",
      "hy": "Ստուգել, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ ավելի մոտ են իրար, քան տրված շեմը:",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা প্রদত্ত সীমার চেয়ে একে অপরের কাছাকাছি আছে কিনা তা পরীক্ষা করুন।",
      "bg": "Проверете дали в дадения списък от числа, някои две числа са по-близо едно до друго от дадения праг.",
      "zh": "检查给定数字列表中，是否有任意两个数字之间的距离小于给定的阈值。",
      "fr": "Vérifiez si, dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei beliebige Zahlen näher beieinander liegen als der angegebene Schwellenwert.",
      "ha": "Duba idan a cikin jerin lambobin da aka bayar, ko akwai wasu lambobi biyu da suka fi kusa da juna fiye da ƙayyadadden ƙimar ƙasa.",
      "hi": "दिए गए संख्याओं की सूची में जांचें कि क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।",
      "hu": "Ellenőrizze, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték."
    },
    "docstring_bertscore": {
      "sq": "0.9754973534562983",
      "hy": "0.913825599600681",
      "bn": "0.906025781798203",
      "bg": "0.9754973534562983",
      "zh": "0.8307951208723822",
      "fr": "0.9617060488402839",
      "de": "0.911736007992194",
      "ha": "0.9130495507019777",
      "hi": "0.8477053197314064",
      "hu": "0.9282684118664898"
    }
  },
  {
    "task_id": "Kotlin/2",
    "prompt": {
      "en": "/**\n * Finds all Armstrong numbers within a specified range.\n * An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\n * For example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "sq": "/**\n * Gjen të gjitha numrat Armstrong brenda një diapazoni të specifikuar.\n * Një numër Armstrong është një numër që është i barabartë me shumën e shifrave të tij, secila e ngritur në fuqinë e numrit 3.\n * Për shembull, 153 është një numër Armstrong sepse 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */ \n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "hy": "/**\n * Գտնում է բոլոր Արմսթրոնգի թվերը նշված միջակայքում:\n * Արմսթրոնգի թիվը թիվ է, որը հավասար է իր սեփական թվանշանների գումարին, որոնցից յուրաքանչյուրն աճեցված է 3-ի աստիճանի:\n * Օրինակ, 153-ը Արմսթրոնգի թիվ է, քանի որ 1^3 + 5^3 + 3^3 = 153:\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "bn": "/**\n * নির্দিষ্ট পরিসরের মধ্যে সমস্ত আর্মস্ট্রং সংখ্যা খুঁজে বের করে।\n * একটি আর্মস্ট্রং সংখ্যা হল এমন একটি সংখ্যা যা তার নিজস্ব অঙ্কের সমষ্টির সমান, প্রতিটি অঙ্ককে 3 এর ঘাতের সাথে উত্তোলন করা হয়।\n * উদাহরণস্বরূপ, 153 একটি আর্মস্ট্রং সংখ্যা কারণ 1^3 + 5^3 + 3^3 = 153।\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */ \n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "bg": "/**\n * Намира всички числа на Армстронг в даден диапазон.\n * Число на Армстронг е число, което е равно на сумата от собствените си цифри, всяка повдигната на степента на числото 3.\n * Например, 153 е число на Армстронг, защото 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "zh": "/**\n * 查找指定范围内的所有阿姆斯特朗数。\n * 阿姆斯特朗数是一个等于其自身数字的立方和的数。\n * 例如，153 是一个阿姆斯特朗数，因为 1^3 + 5^3 + 3^3 = 153。\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "fr": "/**\n * Trouve tous les nombres d'Armstrong dans une plage spécifiée.\n * Un nombre d'Armstrong est un nombre qui est égal à la somme de ses propres chiffres, chacun élevé à la puissance du nombre de 3.\n * Par exemple, 153 est un nombre d'Armstrong parce que 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "de": "/**\n * Findet alle Armstrong-Zahlen innerhalb eines angegebenen Bereichs.\n * Eine Armstrong-Zahl ist eine Zahl, die gleich der Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Zahl 3 erhoben wird.\n * Zum Beispiel ist 153 eine Armstrong-Zahl, weil 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "ha": "/**\n * Nemi duk lambobin Armstrong a cikin kewayon da aka fayyace.\n * Lambar Armstrong ita ce lamba da ta yi daidai da jumlar lambobinta da aka ɗaga kowanne zuwa ƙarfin lamba 3.\n * Alal misali, 153 lambar Armstrong ce saboda 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */ \n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "hi": "/**\n * निर्दिष्ट श्रेणी के भीतर सभी आर्मस्ट्रांग संख्याएँ खोजता है।\n * एक आर्मस्ट्रांग संख्या वह संख्या होती है जो अपने स्वयं के अंकों के योग के बराबर होती है, प्रत्येक को 3 की घात तक बढ़ाया जाता है।\n * उदाहरण के लिए, 153 एक आर्मस्ट्रांग संख्या है क्योंकि 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "hu": "/**\n * Megtalálja az összes Armstrong-számot egy megadott tartományon belül.\n * Egy Armstrong-szám olyan szám, amely egyenlő a saját számjegyeinek összegével, amelyek mindegyike a számjegyek számának 3. hatványára van emelve.\n * Például, 153 egy Armstrong-szám, mert 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9811396480599753",
      "hy": "0.9483314707636807",
      "bn": "0.9874982038176642",
      "bg": "0.9507343024830598",
      "zh": "0.9303456883913527",
      "fr": "0.9604530883967158",
      "de": "0.954652286748973",
      "ha": "0.9743953521023168",
      "hi": "0.9545678688370332",
      "hu": "0.9528955996591004"
    },
    "canonical_solution": "{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}",
    "instruction": {
      "en": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত স্বাভাবিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Kotlin a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nकोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>\n{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9417669353008588",
      "bn": "0.8738053517993907",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9450916106186207",
      "ha": "0.9191087704754469",
      "hi": "0.9001058019218392",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(findArmstrongNumbersInRange(1, 500) == listOf(1, 153, 370, 371, 407))\n    check(findArmstrongNumbersInRange(500, 1000) == emptyList<Int>())\n    check(findArmstrongNumbersInRange(1, 100) == listOf(1))\n    check(findArmstrongNumbersInRange(100, 200) == listOf(153))\n    check(findArmstrongNumbersInRange(100, 1000) == listOf(153, 370, 371, 407))\n}\n\n\nmain()",
    "entry_point": "findArmstrongNumbersInRange",
    "signature": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>",
    "docstring": {
      "en": "Finds all Armstrong numbers within a specified range.\nAn Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\nFor example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "sq": "Gjen të gjitha numrat Armstrong brenda një diapazoni të specifikuar. Një numër Armstrong është një numër që është i barabartë me shumën e shifrave të tij, secila e ngritur në fuqinë e numrit 3. Për shembull, 153 është një numër Armstrong sepse 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "hy": "Գտնում է բոլոր Արմսթրոնգի թվերը նշված տիրույթում:\nԱրմսթրոնգի թիվը այն թիվն է, որը հավասար է իր թվանշանների գումարին, որոնցից յուրաքանչյուրը բարձրացված է 3 աստիճանի:\nՕրինակ, 153-ը Արմսթրոնգի թիվ է, քանի որ 1^3 + 5^3 + 3^3 = 153:\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "bn": "নির্দিষ্ট একটি পরিসরের মধ্যে সকল আর্মস্ট্রং সংখ্যা খুঁজে বের করে।  \nএকটি আর্মস্ট্রং সংখ্যা হল এমন একটি সংখ্যা যা তার নিজস্ব অঙ্কগুলির সমান হয়, প্রতিটি অঙ্কের ঘনফল সংখ্যা ৩ এর ঘাতের সমান।  \nউদাহরণস্বরূপ, ১৫৩ একটি আর্মস্ট্রং সংখ্যা কারণ ১^৩ + ৫^৩ + ৩^৩ = ১৫৩।  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  ",
      "bg": "Намира всички числа на Армстронг в определен диапазон.  \nЧисло на Армстронг е число, което е равно на сумата от собствените му цифри, всяка повдигната на степента на числото 3.  \nНапример, 153 е число на Армстронг, защото 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  ",
      "zh": "在指定范围内查找所有的阿姆斯特朗数。  \n阿姆斯特朗数是指一个数等于其每个数字的立方和。  \n例如，153 是一个阿姆斯特朗数，因为 1^3 + 5^3 + 3^3 = 153。  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  ",
      "fr": "Trouve tous les nombres d'Armstrong dans une plage spécifiée.  \nUn nombre d'Armstrong est un nombre qui est égal à la somme de ses propres chiffres chacun élevé à la puissance du nombre de 3.  \nPar exemple, 153 est un nombre d'Armstrong parce que 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  ",
      "de": "Findet alle Armstrong-Zahlen innerhalb eines angegebenen Bereichs.\nEine Armstrong-Zahl ist eine Zahl, die gleich der Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Zahl 3 erhoben wird.\nZum Beispiel ist 153 eine Armstrong-Zahl, weil 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "ha": "Nemo duk lambobin Armstrong a cikin kewayon da aka kayyade.\nLambar Armstrong ita ce lamba wadda ta yi daidai da jimillar lambobinta da aka ɗaga kowanne zuwa ƙarfin lambar 3.\nMisali, 153 lamba ce ta Armstrong saboda 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "hi": "निर्दिष्ट सीमा के भीतर सभी आर्मस्ट्रांग संख्याएँ खोजता है।\nएक आर्मस्ट्रांग संख्या वह संख्या होती है जो अपने अंकों के घन के योग के बराबर होती है।\nउदाहरण के लिए, 153 एक आर्मस्ट्रांग संख्या है क्योंकि 1^3 + 5^3 + 3^3 = 153।\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "hu": "Megtalálja az összes Armstrong-számot egy megadott tartományban.  \nEgy Armstrong-szám olyan szám, amely megegyezik a saját számjegyeinek összegével, ahol minden számjegy a számjegyek számának hatványára van emelve.  \nPéldául a 153 Armstrong-szám, mert 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  "
    },
    "docstring_bertscore": {
      "sq": "0.9712422934337689",
      "hy": "0.9766851631348868",
      "bn": "0.9773867256407022",
      "bg": "0.9720014587500843",
      "zh": "0.9524167018104253",
      "fr": "0.9773789790558418",
      "de": "0.9788385150956861",
      "ha": "0.9705258336493761",
      "hi": "0.9528878530742401",
      "hu": "0.9654126903807759"
    }
  },
  {
    "task_id": "Kotlin/3",
    "prompt": {
      "en": "/**\n * Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\n * to safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\n * so you need to ensure that no M consecutive test tubes contain chemicals.\n *\n * Write a function that calculates the total number of safe placement options.\n *\n * Example:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Constraints:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Note: The result can be a large number, so return it as a Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "sq": "/**\n * Duke pasur një laborator me N epruveta të renditura në një vijë të drejtë, ju duhet të gjeni numrin e mënyrave\n * për të vendosur në mënyrë të sigurt kimikatet në epruveta. Vendosja e kimikateve në M epruveta radhazi do të shkaktojë një shpërthim,\n * kështu që ju duhet të siguroheni që asnjë M epruveta radhazi të mos përmbajnë kimikate.\n *\n * Shkruani një funksion që llogarit numrin total të opsioneve të vendosjes së sigurt.\n *\n * Shembull:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Kufizimet:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Shënim: Rezultati mund të jetë një numër i madh, kështu që kthejeni atë si një Long.\n */",
      "hy": "/**\n * Տրված է լաբորատորիա՝ N փորձանոթներով, որոնք դասավորված են ուղիղ գծով, դուք պետք է գտնեք քիմիկատները\n * փորձանոթներում անվտանգ տեղադրելու եղանակների քանակը։ M հաջորդական փորձանոթներում քիմիկատներ տեղադրելը\n * պայթյուն կառաջացնի, ուստի դուք պետք է ապահովեք, որ ոչ մի M հաջորդական փորձանոթներում քիմիկատներ չլինեն։\n *\n * Գրել ֆունկցիա, որը կհաշվարկի անվտանգ տեղադրման տարբերակների ընդհանուր քանակը։\n *\n * Օրինակ:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Սահմանափակումներ:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Նշում: Արդյունքը կարող է մեծ թիվ լինել, ուստի վերադարձնել այն որպես Long։\n */",
      "bn": "/**\n * একটি পরীক্ষাগারে N টি টেস্ট টিউব সোজা লাইনে সাজানো আছে, আপনাকে রাসায়নিকগুলি নিরাপদে স্থাপন করার উপায়গুলির সংখ্যা খুঁজে বের করতে হবে।\n * M টি ধারাবাহিক টেস্ট টিউবে রাসায়নিক স্থাপন করলে বিস্ফোরণ ঘটবে,\n * তাই আপনাকে নিশ্চিত করতে হবে যে কোনো M টি ধারাবাহিক টেস্ট টিউবে রাসায়নিক নেই।\n *\n * একটি ফাংশন লিখুন যা নিরাপদ স্থাপনার মোট বিকল্পের সংখ্যা গণনা করে।\n *\n * উদাহরণ:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * শর্তাবলী:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * নোট: ফলাফল একটি বড় সংখ্যা হতে পারে, তাই এটি Long হিসাবে ফেরত দিন।\n */",
      "bg": "/**\n * Дадена е лаборатория с N епруветки, подредени в права линия, трябва да намерите броя на начините\n * за безопасно поставяне на химикали в епруветките. Поставянето на химикали в M последователни епруветки ще предизвика експлозия,\n * така че трябва да се уверите, че няма M последователни епруветки, които съдържат химикали.\n *\n * Напишете функция, която изчислява общия брой на безопасните опции за поставяне.\n *\n * Пример:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Ограничения:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Забележка: Резултатът може да бъде голямо число, затова го върнете като Long.\n */",
      "zh": "/**\n * 给定一个实验室，其中有 N 个试管按直线排列，你需要找到安全放置化学品的方法数。\n * 在 M 个连续试管中放置化学品会导致爆炸，因此你需要确保没有 M 个连续试管含有化学品。\n *\n * 编写一个函数来计算安全放置选项的总数。\n *\n * 示例:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * 约束条件:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * 注意: 结果可能是一个大数，因此以 Long 返回。\n */",
      "fr": "/**\n * Étant donné un laboratoire avec N tubes à essai disposés en ligne droite, vous devez trouver le nombre de façons\n * de placer en toute sécurité des produits chimiques dans les tubes à essai. Placer des produits chimiques dans M tubes à essai consécutifs provoquera une explosion,\n * vous devez donc vous assurer qu'aucun M tubes à essai consécutifs ne contiennent de produits chimiques.\n *\n * Écrivez une fonction qui calcule le nombre total d'options de placement sûr.\n *\n * Exemple:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Contraintes:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Remarque : Le résultat peut être un grand nombre, donc retournez-le en tant que Long.\n */",
      "de": "/**\n * Gegeben ein Labor mit N Reagenzgläsern, die in einer geraden Linie angeordnet sind, müssen Sie die Anzahl der Möglichkeiten finden,\n * um Chemikalien sicher in den Reagenzgläsern zu platzieren. Das Platzieren von Chemikalien in M aufeinanderfolgenden Reagenzgläsern wird eine Explosion verursachen,\n * daher müssen Sie sicherstellen, dass keine M aufeinanderfolgenden Reagenzgläser Chemikalien enthalten.\n *\n * Schreiben Sie eine Funktion, die die Gesamtzahl der sicheren Platzierungsoptionen berechnet.\n *\n * Beispiel:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Einschränkungen:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Hinweis: Das Ergebnis kann eine große Zahl sein, daher geben Sie es als Long zurück.\n */",
      "ha": "/**\n * An ba da dakin gwaje-gwaje tare da N bututun gwaji da aka shirya a layi madaidaiciya, kana buƙatar nemo adadin hanyoyin\n * don sanya sinadarai cikin aminci a cikin bututun gwaji. Sanya sinadarai a cikin bututun gwaji M masu jere zai haifar da fashewa,\n * don haka kana buƙatar tabbatar da cewa babu bututun gwaji M masu jere da ke dauke da sinadarai.\n *\n * Rubuta wata aiki da ke lissafin jimillar adadin zaɓuɓɓukan sanya sinadarai cikin aminci.\n *\n * Misali:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Ƙuntatawa:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Lura: Sakamakon na iya zama babba, don haka mayar da shi a matsayin Long.\n */",
      "hi": "/**\n * दिए गए एक प्रयोगशाला में N टेस्ट ट्यूब्स को एक सीधी रेखा में व्यवस्थित किया गया है, आपको यह पता लगाना है कि\n * टेस्ट ट्यूब्स में रसायनों को सुरक्षित रूप से रखने के कितने तरीके हैं। M लगातार टेस्ट ट्यूब्स में रसायन रखने से विस्फोट होगा,\n * इसलिए आपको यह सुनिश्चित करना होगा कि कोई भी M लगातार टेस्ट ट्यूब्स में रसायन न हों।\n *\n * एक फ़ंक्शन लिखें जो सुरक्षित प्लेसमेंट विकल्पों की कुल संख्या की गणना करता है।\n *\n * उदाहरण:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * बाधाएं:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * नोट: परिणाम एक बड़ा संख्या हो सकता है, इसलिए इसे Long के रूप में लौटाएं।\n */",
      "hu": "/**\n * Adott egy laboratórium N kémcsővel, amelyek egy egyenes vonalban vannak elrendezve, meg kell találnod, hogy hányféleképpen\n * lehet biztonságosan elhelyezni a vegyszereket a kémcsövekben. Ha M egymást követő kémcsőben helyezel el vegyszereket, robbanás következik be,\n * ezért biztosítanod kell, hogy ne legyen M egymást követő kémcső, amely vegyszert tartalmaz.\n *\n * Írj egy függvényt, amely kiszámítja a biztonságos elhelyezési lehetőségek összes számát.\n *\n * Példa:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Korlátozások:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Megjegyzés: Az eredmény nagy szám lehet, ezért Long típusban add vissza.\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9576486260468843",
      "hy": "0.9490324373783529",
      "bn": "0.925121113478992",
      "bg": "0.9601386565035376",
      "zh": "0.9404974885356647",
      "fr": "0.9628938585188725",
      "de": "0.9594549707320155",
      "ha": "0.9382364789083446",
      "hi": "0.9272857873715102",
      "hu": "0.9325518760335072"
    },
    "canonical_solution": "{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}",
    "instruction": {
      "en": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nПредоставете кратко описание на естествен език (докстринг) на Kotlin кода на български, използвайки най-много 500 знака.",
      "zh": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun countSafePlacementOptions(N: Int, M: Int): Long\n{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9417669353008588",
      "bn": "0.8688058251087426",
      "bg": "0.9466200714006842",
      "zh": "0.8774533973774774",
      "fr": "0.948617697142752",
      "de": "0.9221452331103273",
      "ha": "0.9141819425042575",
      "hi": "0.8761702451159921",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    // Test cases\n    check(countSafePlacementOptions(4, 3) == 13L)\n    check(countSafePlacementOptions(3, 2) == 5L)\n    check(countSafePlacementOptions(5, 2) == 13L)\n    check(countSafePlacementOptions(7, 3) == 81L)\n    check(countSafePlacementOptions(10, 4) == 773L)\n    check(countSafePlacementOptions(12, 5) == 3525L)\n}\n\nmain()",
    "entry_point": "countSafePlacementOptions",
    "signature": "fun countSafePlacementOptions(N: Int, M: Int): Long",
    "docstring": {
      "en": "Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\nto safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\nso you need to ensure that no M consecutive test tubes contain chemicals.\n\nWrite a function that calculates the total number of safe placement options.\n\nExample:\n>>> countSafePlacementOptions(4, 3)\n13\n\nConstraints:\n1 < N < 32\n2 <= M <= 5\n\nNote: The result can be a large number, so return it as a Long.",
      "sq": "Duke pasur një laborator me N epruveta të radhitura në një vijë të drejtë, ju duhet të gjeni numrin e mënyrave\npër të vendosur në mënyrë të sigurt kimikatet në epruveta. Vendosja e kimikateve në M epruveta radhazi do të shkaktojë një shpërthim,\nprandaj ju duhet të siguroheni që asnjë M epruveta radhazi të mos përmbajnë kimikate.\n\nShkruani një funksion që llogarit numrin total të opsioneve të vendosjes së sigurt.\n\nShembull:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKufizimet:\n1 < N < 32\n2 <= M <= 5\n\nShënim: Rezultati mund të jetë një numër i madh, prandaj kthejeni atë si një Long.",
      "hy": "Լաբորատորիայում N փորձանոթներ կան, որոնք դասավորված են ուղիղ գծով, և դուք պետք է գտնեք քիմիական նյութերը փորձանոթներում անվտանգ տեղադրելու եղանակների քանակը: M հաջորդական փորձանոթներում քիմիական նյութեր տեղադրելը պայթյուն կառաջացնի, ուստի դուք պետք է ապահովեք, որ ոչ մի M հաջորդական փորձանոթներ քիմիական նյութեր չպարունակեն:\n\nԳրեք ֆունկցիա, որը կհաշվարկի անվտանգ տեղադրման տարբերակների ընդհանուր քանակը:\n\nՕրինակ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nՊահանջներ:\n1 < N < 32\n2 <= M <= 5\n\nՆշում: Արդյունքը կարող է մեծ թիվ լինել, ուստի վերադարձնել այն որպես Long:",
      "bn": "একটি পরীক্ষাগারে N সংখ্যক টেস্ট টিউব সোজা লাইনে সাজানো আছে, আপনাকে নিরাপদে রাসায়নিক পদার্থ রাখার উপায়ের সংখ্যা খুঁজে বের করতে হবে। M সংখ্যক ধারাবাহিক টেস্ট টিউবে রাসায়নিক রাখলে বিস্ফোরণ ঘটবে, তাই আপনাকে নিশ্চিত করতে হবে যে কোনো M ধারাবাহিক টেস্ট টিউবে রাসায়নিক থাকবে না।\n\nএকটি ফাংশন লিখুন যা নিরাপদে রাখার মোট বিকল্পের সংখ্যা গণনা করে।\n\nউদাহরণ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nসীমাবদ্ধতা:\n1 < N < 32\n2 <= M <= 5\n\nদ্রষ্টব্য: ফলাফল একটি বড় সংখ্যা হতে পারে, তাই এটি Long হিসাবে ফেরত দিন।",
      "bg": "Дадена е лаборатория с N епруветки, подредени в права линия, трябва да намерите броя на начините\nза безопасно поставяне на химикали в епруветките. Поставянето на химикали в M последователни епруветки ще предизвика експлозия,\nтака че трябва да се уверите, че няма M последователни епруветки, които съдържат химикали.\n\nНапишете функция, която изчислява общия брой на безопасните варианти за поставяне.\n\nПример:\n>>> countSafePlacementOptions(4, 3)\n13\n\nОграничения:\n1 < N < 32\n2 <= M <= 5\n\nЗабележка: Резултатът може да бъде голямо число, така че го върнете като Long.",
      "zh": "给定一个实验室，其中有 N 个试管按直线排列，你需要找到安全放置化学品的方法数。在 M 个连续试管中放置化学品将导致爆炸，因此你需要确保没有 M 个连续试管中含有化学品。\n\n编写一个函数来计算安全放置选项的总数。\n\n示例:\n>>> countSafePlacementOptions(4, 3)\n13\n\n约束条件:\n1 < N < 32\n2 <= M <= 5\n\n注意: 结果可能是一个大数字，因此以 Long 返回。",
      "fr": "Étant donné un laboratoire avec N tubes à essai disposés en ligne droite, vous devez trouver le nombre de façons de placer en toute sécurité des produits chimiques dans les tubes à essai. Placer des produits chimiques dans M tubes à essai consécutifs provoquera une explosion, vous devez donc vous assurer qu'aucun M tubes à essai consécutifs ne contiennent de produits chimiques.\n\nÉcrivez une fonction qui calcule le nombre total d'options de placement sûr.\n\nExemple:\n>>> countSafePlacementOptions(4, 3)\n13\n\nContraintes:\n1 < N < 32\n2 <= M <= 5\n\nRemarque : Le résultat peut être un grand nombre, donc retournez-le en tant que Long.",
      "de": "Gegeben ein Labor mit N Reagenzgläsern, die in einer geraden Linie angeordnet sind, müssen Sie die Anzahl der Möglichkeiten finden, um Chemikalien sicher in den Reagenzgläsern zu platzieren. Das Platzieren von Chemikalien in M aufeinanderfolgenden Reagenzgläsern wird eine Explosion verursachen, daher müssen Sie sicherstellen, dass keine M aufeinanderfolgenden Reagenzgläser Chemikalien enthalten.\n\nSchreiben Sie eine Funktion, die die Gesamtanzahl der sicheren Platzierungsoptionen berechnet.\n\nBeispiel:\n>>> countSafePlacementOptions(4, 3)\n13\n\nEinschränkungen:\n1 < N < 32\n2 <= M <= 5\n\nHinweis: Das Ergebnis kann eine große Zahl sein, daher geben Sie es als Long zurück.",
      "ha": "An ba da dakin gwaje-gwaje tare da N bututun gwaji da aka shirya a layi madaidaici, kuna buƙatar nemo yawan hanyoyin\nda za a sanya sinadarai cikin aminci a cikin bututun gwaji. Sanya sinadarai a cikin M bututun gwaji masu jere zai haifar da fashewa,\ndon haka kuna buƙatar tabbatar da cewa babu M bututun gwaji masu jere da ke dauke da sinadarai.\n\nRubuta wata aiki da ke lissafin jimillar yawan zaɓuɓɓukan sanya sinadarai cikin aminci.\n\nMisali:\n>>> countSafePlacementOptions(4, 3)\n13\n\nƘuntatawa:\n1 < N < 32\n2 <= M <= 5\n\nLura: Sakamakon na iya zama babban lamba, don haka ku mayar da shi a matsayin Long.",
      "hi": "एक प्रयोगशाला में N टेस्ट ट्यूब्स सीधे रेखा में व्यवस्थित हैं, आपको रासायनिक पदार्थों को सुरक्षित रूप से रखने के तरीकों की संख्या खोजनी है। M लगातार टेस्ट ट्यूब्स में रासायनिक पदार्थ रखने से विस्फोट होगा, इसलिए आपको यह सुनिश्चित करना होगा कि कोई भी M लगातार टेस्ट ट्यूब्स में रासायनिक पदार्थ न हों।\n\nएक फ़ंक्शन लिखें जो सुरक्षित स्थान विकल्पों की कुल संख्या की गणना करता है।\n\nउदाहरण:\n>>> countSafePlacementOptions(4, 3)\n13\n\nबाधाएं:\n1 < N < 32\n2 <= M <= 5\n\nध्यान दें: परिणाम एक बड़ा संख्या हो सकता है, इसलिए इसे Long के रूप में लौटाएं।",
      "hu": "Adott egy laboratórium N kémcsővel, amelyek egy egyenes vonalban vannak elrendezve. Meg kell találnod, hányféleképpen lehet biztonságosan elhelyezni a vegyszereket a kémcsövekben. Ha vegyszereket helyezel el M egymást követő kémcsőben, robbanás következik be, ezért biztosítanod kell, hogy ne legyen M egymást követő kémcső, amely vegyszereket tartalmaz.\n\nÍrj egy függvényt, amely kiszámítja a biztonságos elhelyezési lehetőségek teljes számát.\n\nPélda:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKorlátozások:\n1 < N < 32\n2 <= M <= 5\n\nMegjegyzés: Az eredmény nagy szám lehet, ezért Long típusban add vissza."
    },
    "docstring_bertscore": {
      "sq": "0.9928902241412372",
      "hy": "0.9646769634494228",
      "bn": "0.9616901584098011",
      "bg": "0.9928781076879941",
      "zh": "0.9826250060493542",
      "fr": "0.9968842838430867",
      "de": "0.9898621039823603",
      "ha": "0.9676820424840995",
      "hi": "0.9629357695292708",
      "hu": "0.954305478103686"
    }
  },
  {
    "task_id": "Kotlin/4",
    "prompt": {
      "en": "/**\n * Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\n * that are both prime and palindrome.\n *\n * Example:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n *\n * Note:\n * - A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n * - A palindrome number is a number that reads the same forwards and backwards.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "sq": "/**\n * Duke pasur një numër të plotë 'n', gjeni dhe ktheni numrin e numrave midis 11 dhe 'n' (përfshirë)\n * që janë si numra të thjeshtë ashtu edhe palindromë.\n *\n * Shembull:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Sepse ka dy numra, 11 dhe 22, që janë numra të thjeshtë dhe palindromë midis 11 dhe 50.\n *\n * Shënim:\n * - Një numër i thjeshtë është një numër i plotë pozitiv më i madh se 1 që nuk ka ndarës të plotë pozitivë përveç 1 dhe vetes.\n * - Një numër palindromë është një numër që lexohet njësoj përpara dhe prapa.\n */",
      "hy": "/**\n * Տրված է ամբողջ թիվ 'n', գտնել և վերադարձնել 11-ից մինչև 'n' (ներառյալ) թվերի քանակը,\n * որոնք և՛ պարզ են, և՛ պալինդրոմ։\n *\n * Օրինակ:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Քանի որ կա երկու թիվ, 11 և 22, որոնք պարզ են և պալինդրոմ 11-ից մինչև 50։\n *\n * Նշում:\n * - Պարզ թիվը դրական ամբողջ թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ 1-ից և իրենից բացի։\n * - Պալինդրոմ թիվը թիվ է, որը կարդացվում է նույն կերպ ինչպես առաջ, այնպես էլ հետ։\n */",
      "bn": "/**\n * একটি পূর্ণসংখ্যা 'n' দেওয়া হলে, 11 এবং 'n' (অন্তর্ভুক্ত) এর মধ্যে এমন সংখ্যাগুলির সংখ্যা খুঁজে বের করুন এবং ফেরত দিন\n * যেগুলি উভয়ই মৌলিক সংখ্যা এবং প্যালিনড্রোম।\n *\n * উদাহরণ:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // কারণ 11 এবং 22 দুটি সংখ্যা, যা 11 এবং 50 এর মধ্যে মৌলিক সংখ্যা এবং প্যালিনড্রোম।\n *\n * নোট:\n * - একটি মৌলিক সংখ্যা হল 1 এর চেয়ে বড় একটি ধনাত্মক পূর্ণসংখ্যা যার 1 এবং তার নিজের বাইরে অন্য কোনো ধনাত্মক পূর্ণসংখ্যা বিভাজক নেই।\n * - একটি প্যালিনড্রোম সংখ্যা হল এমন একটি সংখ্যা যা সামনের দিক থেকে এবং পিছনের দিক থেকে একই রকম পড়ে।\n */",
      "bg": "/**\n * Дадено е цяло число 'n', намерете и върнете броя на числата между 11 и 'n' (включително),\n * които са едновременно прости и палиндроми.\n *\n * Пример:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Защото има две числа, 11 и 22, които са прости и палиндроми между 11 и 50.\n *\n * Забележка:\n * - Просто число е положително цяло число, по-голямо от 1, което няма положителни делители, различни от 1 и самото него.\n * - Палиндром число е число, което се чете еднакво напред и назад.\n */",
      "zh": "/**\n * 给定一个整数 'n'，找出并返回在 11 和 'n'（包括 'n'）之间既是质数又是回文数的数字个数。\n *\n * 示例：\n * >>> countPrimePalindromeNumbers(50)\n * 2 // 因为在 11 和 50 之间有两个数字，11 和 22，既是质数又是回文数。\n *\n * 注意：\n * - 质数是大于 1 的正整数，除了 1 和它本身之外没有其他正整数因子。\n * - 回文数是指正反读都相同的数字。\n */",
      "fr": "/**\n * Étant donné un entier 'n', trouver et retourner le nombre de chiffres entre 11 et 'n' (inclus)\n * qui sont à la fois premiers et palindromes.\n *\n * Exemple:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Parce qu'il y a deux nombres, 11 et 22, qui sont premiers et palindromes entre 11 et 50.\n *\n * Remarque:\n * - Un nombre premier est un entier positif supérieur à 1 qui n'a pas de diviseurs entiers positifs autres que 1 et lui-même.\n * - Un nombre palindrome est un nombre qui se lit de la même manière à l'endroit et à l'envers.\n */",
      "de": "/**\n * Gegeben eine ganze Zahl 'n', finde und gib die Anzahl der Zahlen zwischen 11 und 'n' (einschließlich) zurück,\n * die sowohl Primzahlen als auch Palindrome sind.\n *\n * Beispiel:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Weil es zwei Zahlen gibt, 11 und 22, die zwischen 11 und 50 sowohl Primzahlen als auch Palindrome sind.\n *\n * Hinweis:\n * - Eine Primzahl ist eine positive ganze Zahl größer als 1, die keine positiven ganzzahligen Teiler außer 1 und sich selbst hat.\n * - Eine Palindromzahl ist eine Zahl, die vorwärts und rückwärts gleich gelesen wird.\n */",
      "ha": "/**\n * Idan aka ba da cikakken lamba 'n', nemo kuma dawo da adadin lambobin da ke tsakanin 11 da 'n' (ciki har da)\n * waɗanda suke duka lambobin farko da palindrome.\n *\n * Misali:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Domin akwai lambobi biyu, 11 da 22, waɗanda suke lambobin farko da palindrome tsakanin 11 da 50.\n *\n * Lura:\n * - Lamba ta farko ita ce cikakkiyar lamba mai kyau fiye da 1 wanda ba shi da masu raba lambobi masu kyau banda 1 da kanta.\n * - Lamba palindrome ita ce lamba da ake karantawa iri ɗaya daga gaba da baya.\n */",
      "hi": "/**\n * दिए गए पूर्णांक 'n' के लिए, 11 और 'n' (समावेशी) के बीच उन संख्याओं की गिनती खोजें और लौटाएं\n * जो दोनों ही अभाज्य और पालिंड्रोम हैं।\n *\n * उदाहरण:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // क्योंकि 11 और 22 दो संख्याएँ हैं, जो 11 और 50 के बीच अभाज्य और पालिंड्रोम हैं।\n *\n * ध्यान दें:\n * - एक अभाज्य संख्या एक धनात्मक पूर्णांक है जो 1 और स्वयं के अलावा किसी अन्य धनात्मक पूर्णांक से विभाजित नहीं होता।\n * - एक पालिंड्रोम संख्या वह संख्या है जो आगे और पीछे से पढ़ने पर समान होती है।\n */",
      "hu": "/**\n * Adott egy 'n' egész szám, keresse meg és adja vissza azoknak a számoknak a számát 11 és 'n' között (beleértve),\n * amelyek egyszerre prímek és palindromok.\n *\n * Példa:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Mert két szám van, 11 és 22, amelyek prímek és palindromok 11 és 50 között.\n *\n * Megjegyzés:\n * - A prímszám olyan pozitív egész szám, amely nagyobb, mint 1, és nincs más pozitív egész osztója, mint 1 és önmaga.\n * - A palindrom szám olyan szám, amely előre és hátrafelé olvasva is ugyanaz.\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9476360657996776",
      "hy": "0.9605444583719919",
      "bn": "0.9449831584305757",
      "bg": "0.9534384564904688",
      "zh": "0.9234740703594507",
      "fr": "0.9534070728902653",
      "de": "0.9443163562414415",
      "ha": "0.9539423817671543",
      "hi": "0.9299931194650157",
      "hu": "0.9489972798009096"
    },
    "canonical_solution": "{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}",
    "instruction": {
      "en": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nকোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\n请用不超过500个字符的中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun countPrimePalindromeNumbers(n: Int): Int\n{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9341065560258672",
      "bn": "0.8522390581785277",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(countPrimePalindromeNumbers(50) == 1) // There are two prime palindrome numbers between 11 and 50 (11).\n    check(countPrimePalindromeNumbers(150) == 3) // There are three prime palindrome numbers between 11 and 100 (11, 101, 131).\n    check(countPrimePalindromeNumbers(200) == 6) // There are four prime palindrome numbers between 11 and 200 (11, 101, 131, 151, 181, 191).\n    check(countPrimePalindromeNumbers(11) == 1)  // The only prime palindrome number between 11 and 11 is 11 itself.\n}\n\nmain()",
    "entry_point": "countPrimePalindromeNumbers",
    "signature": "fun countPrimePalindromeNumbers(n: Int): Int",
    "docstring": {
      "en": "Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\nthat are both prime and palindrome.\n\nExample:\n>>> countPrimePalindromeNumbers(50)\n2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n\nNote:\n- A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n- A palindrome number is a number that reads the same forwards and backwards.",
      "sq": "Duke pasur një numër të plotë 'n', gjeni dhe ktheni numrin e numrave midis 11 dhe 'n' (përfshirë)\nqë janë si numra të thjeshtë ashtu edhe palindromë.\n\nShembull:\n>>> countPrimePalindromeNumbers(50)\n2 // Sepse ka dy numra, 11 dhe 22, që janë numra të thjeshtë dhe palindromë midis 11 dhe 50.\n\nShënim:\n- Një numër i thjeshtë është një numër i plotë pozitiv më i madh se 1 që nuk ka ndarës të plotë pozitivë përveç 1 dhe vetes.\n- Një numër palindromë është një numër që lexohet njësoj përpara dhe prapa.",
      "hy": "Տրված է ամբողջ թիվ 'n', գտնել և վերադարձնել 11-ից մինչև 'n' (ներառյալ) այն թվերի քանակը, որոնք և՛ պարզ են, և՛ պալինդրոմ։\n\nՕրինակ:\n>>> countPrimePalindromeNumbers(50)\n2 // Քանի որ 11-ից մինչև 50 երկու թիվ կա, 11 և 22, որոնք պարզ են և պալինդրոմ։\n\nՆշում:\n- Պարզ թիվը դրական ամբողջ թիվ է, որը մեծ է 1-ից և չունի դրական ամբողջ թվային բաժանարարներ, բացի 1-ից և իրենից։\n- Պալինդրոմ թիվը այն թիվն է, որը նույն կերպ է կարդացվում առաջ և հետ։",
      "bn": "একটি পূর্ণসংখ্যা 'n' দেওয়া হলে, 11 এবং 'n' (অন্তর্ভুক্ত) এর মধ্যে এমন সংখ্যাগুলির সংখ্যা খুঁজে বের করুন এবং ফেরত দিন যা উভয়ই মৌলিক সংখ্যা এবং প্যালিনড্রোম।\n\nউদাহরণ:\n>>> countPrimePalindromeNumbers(50)\n2 // কারণ 11 এবং 22 দুটি সংখ্যা, যা 11 এবং 50 এর মধ্যে মৌলিক সংখ্যা এবং প্যালিনড্রোম।\n\nনোট:\n- একটি মৌলিক সংখ্যা হল একটি ধনাত্মক পূর্ণসংখ্যা যা 1 এবং তার নিজস্ব ছাড়া অন্য কোনও ধনাত্মক পূর্ণসংখ্যা বিভাজক নেই।\n- একটি প্যালিনড্রোম সংখ্যা হল একটি সংখ্যা যা সামনে এবং পিছনে একইভাবে পড়ে।",
      "bg": "Дадено е цяло число 'n', намерете и върнете броя на числата между 11 и 'n' (включително), които са едновременно прости и палиндроми.\n\nПример:\n>>> countPrimePalindromeNumbers(50)\n2 // Защото има две числа, 11 и 22, които са прости и палиндроми между 11 и 50.\n\nЗабележка:\n- Просто число е положително цяло число, по-голямо от 1, което няма положителни делители, различни от 1 и себе си.\n- Палиндромно число е число, което се чете еднакво напред и назад.",
      "zh": "给定一个整数 'n'，找到并返回在 11 和 'n'（包括 'n'）之间既是质数又是回文数的数字个数。\n\n示例：\n>>> countPrimePalindromeNumbers(50)\n2 // 因为在 11 和 50 之间有两个数字，11 和 22，既是质数又是回文数。\n\n注意：\n- 质数是大于 1 的正整数，除了 1 和它本身以外没有其他正整数因子。\n- 回文数是一个正着读和反着读都相同的数字。",
      "fr": "Étant donné un entier 'n', trouvez et retournez le nombre de nombres entre 11 et 'n' (inclus) qui sont à la fois premiers et palindromes.\n\nExemple :\n>>> countPrimePalindromeNumbers(50)\n2 // Parce qu'il y a deux nombres, 11 et 22, qui sont premiers et palindromes entre 11 et 50.\n\nRemarque :\n- Un nombre premier est un entier positif supérieur à 1 qui n'a pas de diviseurs entiers positifs autres que 1 et lui-même.\n- Un nombre palindrome est un nombre qui se lit de la même manière de gauche à droite et de droite à gauche.",
      "de": "Gegeben eine ganze Zahl 'n', finde und gib die Anzahl der Zahlen zwischen 11 und 'n' (einschließlich) zurück, die sowohl Primzahlen als auch Palindrome sind.\n\nBeispiel:\n>>> countPrimePalindromeNumbers(50)\n2 // Weil es zwei Zahlen gibt, 11 und 22, die Primzahlen und Palindrome zwischen 11 und 50 sind.\n\nHinweis:\n- Eine Primzahl ist eine positive ganze Zahl größer als 1, die keine positiven ganzzahligen Teiler außer 1 und sich selbst hat.\n- Eine Palindromzahl ist eine Zahl, die vorwärts und rückwärts gleich gelesen wird.",
      "ha": "An ba da cikakken lamba 'n', nemo kuma dawo da adadin lambobin da ke tsakanin 11 da 'n' (ciki har da)\nwanda duka suna lamba mai farko da palindrome.\n\nMisali:\n>>> countPrimePalindromeNumbers(50)\n2 // Domin akwai lambobi biyu, 11 da 22, waɗanda suke lamba mai farko da palindrome tsakanin 11 da 50.\n\nLura:\n- Lamba mai farko ita ce cikakken lamba mai kyau wanda ya fi 1 wanda ba shi da masu rarrabewa masu kyau sai dai 1 da kansa.\n- Lamba palindrome ita ce lamba da ke karanta iri ɗaya gaba da baya.",
      "hi": "दिए गए पूर्णांक 'n' के लिए, 11 और 'n' (समावेशी) के बीच की उन संख्याओं की गिनती खोजें और लौटाएं जो दोनों ही अभाज्य और पलिंड्रोम हैं।\n\nउदाहरण:\n>>> countPrimePalindromeNumbers(50)\n2 // क्योंकि 11 और 22 दो संख्याएँ हैं जो 11 और 50 के बीच अभाज्य और पलिंड्रोम हैं।\n\nनोट:\n- एक अभाज्य संख्या एक धनात्मक पूर्णांक है जो 1 और स्वयं के अलावा किसी अन्य धनात्मक पूर्णांक से विभाजित नहीं होता है।\n- एक पलिंड्रोम संख्या वह संख्या है जो आगे और पीछे से एक जैसी पढ़ी जाती है।",
      "hu": "Adott egy egész szám, 'n', keresse meg és adja vissza az 11 és 'n' közötti (beleértve) számok számát, amelyek egyszerre prímek és palindromok.\n\nPélda:\n>>> countPrimePalindromeNumbers(50)\n2 // Mert két szám van, 11 és 22, amelyek prímek és palindromok 11 és 50 között.\n\nMegjegyzés:\n- A prímszám egy pozitív egész szám, amely nagyobb, mint 1, és nincs más pozitív egész osztója, mint 1 és önmaga.\n- A palindrom szám olyan szám, amely előre és hátrafelé olvasva is ugyanaz."
    },
    "docstring_bertscore": {
      "sq": "0.9709538821205063",
      "hy": "0.9559860897576222",
      "bn": "0.9597795327746266",
      "bg": "0.9738326322328449",
      "zh": "0.9485755875019726",
      "fr": "0.9520661191878987",
      "de": "0.9704181759828552",
      "ha": "0.9699887370990578",
      "hi": "0.9397250149838201",
      "hu": "0.9743854205832649"
    }
  },
  {
    "task_id": "Kotlin/5",
    "prompt": {
      "en": "/**\n    * Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\n    * A Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\n    * The function returns a list of triples (a, b, c) that satisfy the conditions.\n    *\n    * Example:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n    * (3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n    * (5, 12, 13) and (6, 8, 10) are other valid triplets.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "sq": "/**\n    * Duke pasur një kufi, gjej të gjitha tripletet Pitagoriane (a, b, c) të tilla që a < b < c dhe a + b + c <= kufi.\n    * Një triplet Pitagorian është një grup prej tre numrash të plotë pozitivë a, b, dhe c, ku a^2 + b^2 = c^2.\n    * Funksioni kthen një listë treshe (a, b, c) që plotësojnë kushtet.\n    *\n    * Shembull:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Shpjegim: Për kufi=30, funksioni gjen tripletet Pitagoriane ku a + b + c është më pak ose e barabartë me 30.\n    * (3, 4, 5) është tripleti i parë me a^2 + b^2 = c^2 dhe a + b + c = 12, që është më pak se 30.\n    * (5, 12, 13) dhe (6, 8, 10) janë triplete të tjera të vlefshme.\n**/",
      "hy": "/**\n    * Տրված սահմանաչափի դեպքում գտնել բոլոր Պյութագորասյան եռյակները (a, b, c), այնպես, որ a < b < c և a + b + c <= սահմանաչափ:\n    * Պյութագորասյան եռյակն այնպիսի երեք դրական ամբողջ թվերի հավաքածու է, որտեղ a^2 + b^2 = c^2:\n    * Ֆունկցիան վերադարձնում է եռյակների ցուցակ (a, b, c), որոնք բավարարում են պայմանները:\n    *\n    * Օրինակ:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Բացատրություն: Սահմանաչափ=30-ի դեպքում, ֆունկցիան գտնում է Պյութագորասյան եռյակներ, որտեղ a + b + c փոքր կամ հավասար է 30-ի:\n    * (3, 4, 5) առաջին եռյակն է, որտեղ a^2 + b^2 = c^2 և a + b + c = 12, որը փոքր է 30-ից:\n    * (5, 12, 13) և (6, 8, 10) այլ վավեր եռյակներ են:\n**/",
      "bn": "/**\n    * একটি সীমা দেওয়া হলে, সমস্ত পিথাগোরিয়ান ট্রিপলেট (a, b, c) খুঁজে বের করুন যেখানে a < b < c এবং a + b + c <= সীমা।\n    * একটি পিথাগোরিয়ান ট্রিপলেট হল তিনটি ধনাত্মক পূর্ণসংখ্যার সেট a, b, এবং c, যেখানে a^2 + b^2 = c^2।\n    * ফাংশনটি এমন ট্রিপল (a, b, c) এর একটি তালিকা ফেরত দেয় যা শর্তগুলি পূরণ করে।\n    *\n    * উদাহরণ:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * ব্যাখ্যা: সীমা=30 এর জন্য, ফাংশনটি পিথাগোরিয়ান ট্রিপলেট খুঁজে পায় যেখানে a + b + c 30 এর সমান বা তার চেয়ে কম।\n    * (3, 4, 5) হল প্রথম ট্রিপলেট যেখানে a^2 + b^2 = c^2 এবং a + b + c = 12, যা 30 এর চেয়ে কম।\n    * (5, 12, 13) এবং (6, 8, 10) অন্যান্য বৈধ ট্রিপলেট।\n**/",
      "bg": "/**\n    * Дадена е граница, намерете всички Питагорови тройки (a, b, c) такива, че a < b < c и a + b + c <= границата.\n    * Питагорова тройка е набор от три положителни цели числа a, b и c, където a^2 + b^2 = c^2.\n    * Функцията връща списък от тройки (a, b, c), които удовлетворяват условията.\n    *\n    * Пример:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Обяснение: За граница=30, функцията намира Питагорови тройки, където a + b + c е по-малко или равно на 30.\n    * (3, 4, 5) е първата тройка с a^2 + b^2 = c^2 и a + b + c = 12, което е по-малко от 30.\n    * (5, 12, 13) и (6, 8, 10) са други валидни тройки.\n**/",
      "zh": "/**\n    * 给定一个上限，找到所有满足 a < b < c 且 a + b + c <= 上限的毕达哥拉斯三元组 (a, b, c)。\n    * 毕达哥拉斯三元组是一组三个正整数 a, b 和 c，其中 a^2 + b^2 = c^2。\n    * 该函数返回满足条件的三元组 (a, b, c) 的列表。\n    *\n    * 示例:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * 解释: 对于上限=30，函数找到 a + b + c 小于或等于 30 的毕达哥拉斯三元组。\n    * (3, 4, 5) 是第一个三元组，满足 a^2 + b^2 = c^2 且 a + b + c = 12，小于 30。\n    * (5, 12, 13) 和 (6, 8, 10) 是其他有效的三元组。\n**/",
      "fr": "/**\n    * Étant donné une limite, trouver tous les triplets pythagoriciens (a, b, c) tels que a < b < c et a + b + c <= limite.\n    * Un triplet pythagoricien est un ensemble de trois entiers positifs a, b et c, où a^2 + b^2 = c^2.\n    * La fonction renvoie une liste de triplets (a, b, c) qui satisfont les conditions.\n    *\n    * Exemple:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explication : Pour limite=30, la fonction trouve des triplets pythagoriciens où a + b + c est inférieur ou égal à 30.\n    * (3, 4, 5) est le premier triplet avec a^2 + b^2 = c^2 et a + b + c = 12, ce qui est inférieur à 30.\n    * (5, 12, 13) et (6, 8, 10) sont d'autres triplets valides.\n**/",
      "de": "/**\n    * Gegeben ein Limit, finde alle pythagoreischen Tripel (a, b, c) so dass a < b < c und a + b + c <= Limit.\n    * Ein pythagoreisches Tripel ist eine Menge von drei positiven ganzen Zahlen a, b und c, wobei a^2 + b^2 = c^2.\n    * Die Funktion gibt eine Liste von Tripeln (a, b, c) zurück, die die Bedingungen erfüllen.\n    *\n    * Beispiel:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Erklärung: Für Limit=30 findet die Funktion pythagoreische Tripel, bei denen a + b + c kleiner oder gleich 30 ist.\n    * (3, 4, 5) ist das erste Tripel mit a^2 + b^2 = c^2 und a + b + c = 12, welches kleiner als 30 ist.\n    * (5, 12, 13) und (6, 8, 10) sind andere gültige Tripel.\n**/",
      "ha": "/**\n    * Idan aka ba da iyaka, nemo dukkan triplet na Pythagorean (a, b, c) inda a < b < c kuma a + b + c <= iyaka.\n    * Triplet na Pythagorean wani saiti ne na lambobi guda uku masu kyau a, b, da c, inda a^2 + b^2 = c^2.\n    * Aikin yana dawo da jerin triples (a, b, c) waɗanda suka cika sharuɗɗan.\n    *\n    * Misali:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Bayani: Don iyaka=30, aikin yana samun triplet na Pythagorean inda a + b + c ya kasance ƙasa ko daidai da 30.\n    * (3, 4, 5) shine triplet na farko tare da a^2 + b^2 = c^2 kuma a + b + c = 12, wanda yake ƙasa da 30.\n    * (5, 12, 13) da (6, 8, 10) suna da sauran triplet masu inganci.\n**/",
      "hi": "/**\n    * दिए गए सीमा के लिए, सभी पाइथागोरियन त्रय (a, b, c) खोजें, ऐसे कि a < b < c और a + b + c <= सीमा।\n    * एक पाइथागोरियन त्रय तीन धनात्मक पूर्णांक a, b, और c का सेट है, जहाँ a^2 + b^2 = c^2।\n    * यह फ़ंक्शन उन त्रय (a, b, c) की सूची लौटाता है जो शर्तों को पूरा करते हैं।\n    *\n    * उदाहरण:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * व्याख्या: सीमा=30 के लिए, फ़ंक्शन पाइथागोरियन त्रय खोजता है जहाँ a + b + c 30 से कम या बराबर है।\n    * (3, 4, 5) पहला त्रय है जिसमें a^2 + b^2 = c^2 और a + b + c = 12 है, जो 30 से कम है।\n    * (5, 12, 13) और (6, 8, 10) अन्य मान्य त्रय हैं।\n**/",
      "hu": "/**\n    * Adott egy határérték, találja meg az összes Pitagoraszi hármasokat (a, b, c), ahol a < b < c és a + b + c <= határérték.\n    * Egy Pitagoraszi hármas három pozitív egész szám halmaza, ahol a^2 + b^2 = c^2.\n    * A függvény visszaad egy listát azokról a hármasokról (a, b, c), amelyek megfelelnek a feltételeknek.\n    *\n    * Példa:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Magyarázat: Ha a határérték=30, a függvény olyan Pitagoraszi hármasokat talál, ahol a + b + c kisebb vagy egyenlő 30-nál.\n    * (3, 4, 5) az első hármas, ahol a^2 + b^2 = c^2 és a + b + c = 12, ami kisebb, mint 30.\n    * (5, 12, 13) és (6, 8, 10) más érvényes hármasok.\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9711560878483998",
      "hy": "0.9488769097900025",
      "bn": "0.9644560864657119",
      "bg": "0.9681937143456454",
      "zh": "0.9490350195733063",
      "fr": "0.9714568142452865",
      "de": "0.9714568142452865",
      "ha": "0.9664402053418695",
      "hi": "0.9597241148983178",
      "hu": "0.9509488232945774"
    },
    "canonical_solution": "{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}",
    "instruction": {
      "en": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\n请用中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>\n{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9273302805768621",
      "bn": "0.8738053517993907",
      "bg": "0.8383597137705134",
      "zh": "0.8901365430976982",
      "fr": "0.9695779694710775",
      "de": "0.9385961985283988",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.9315084706419309"
    },
    "level": "",
    "test": "fun main() {\n    val result1 = findPythagoreanTriplets(20)\n    val expected1 = listOf(Triple(3, 4, 5))\n    check(result1 == expected1) // Should print true\n\n    \n    val result2 = findPythagoreanTriplets(30)\n    val expected2 = listOf(Triple(3, 4, 5), Triple(5, 12, 13), Triple(6, 8, 10))\n    check(result2 == expected2) // Should print true\n \n}\n\n\nmain()",
    "entry_point": "findPythagoreanTriplets",
    "signature": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>",
    "docstring": {
      "en": "Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\nA Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\nThe function returns a list of triples (a, b, c) that satisfy the conditions.\n\nExample:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n(3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n(5, 12, 13) and (6, 8, 10) are other valid triplets.",
      "sq": "Duke pasur një kufi, gjeni të gjitha treshet Pitagoriane (a, b, c) të tilla që a < b < c dhe a + b + c <= kufi.\nNjë treshe Pitagoriane është një grup prej tre numrash të plotë pozitivë a, b, dhe c, ku a^2 + b^2 = c^2.\nFunksioni kthen një listë tresheve (a, b, c) që plotësojnë kushtet.\n\nShembull:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nShpjegim: Për kufirin=30, funksioni gjen treshet Pitagoriane ku a + b + c është më pak ose e barabartë me 30.\n(3, 4, 5) është tresha e parë me a^2 + b^2 = c^2 dhe a + b + c = 12, që është më pak se 30.\n(5, 12, 13) dhe (6, 8, 10) janë treshe të tjera të vlefshme.",
      "hy": "Տրված սահմանաչափի դեպքում գտնել բոլոր Պյութագորասյան եռյակները (a, b, c), այնպես որ a < b < c և a + b + c <= սահմանաչափ:\nՊյութագորասյան եռյակն այնպիսի երեք դրական ամբողջ թվերի հավաքածու է, որտեղ a^2 + b^2 = c^2:\nՖունկցիան վերադարձնում է եռյակների (a, b, c) ցուցակը, որոնք բավարարում են պայմաններին:\n\nՕրինակ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nԲացատրություն: Սահմանաչափ=30-ի դեպքում ֆունկցիան գտնում է Պյութագորասյան եռյակներ, որտեղ a + b + c-ն փոքր կամ հավասար է 30-ի:\n(3, 4, 5) առաջին եռյակն է, որտեղ a^2 + b^2 = c^2 և a + b + c = 12, որը փոքր է 30-ից:\n(5, 12, 13) և (6, 8, 10) այլ վավեր եռյակներ են:",
      "bn": "প্রদত্ত সীমার মধ্যে সমস্ত পাইথাগোরিয়ান ট্রিপলেট (a, b, c) খুঁজে বের করুন যেখানে a < b < c এবং a + b + c <= সীমা।\nএকটি পাইথাগোরিয়ান ট্রিপলেট হল তিনটি ধনাত্মক পূর্ণসংখ্যার সেট a, b, এবং c, যেখানে a^2 + b^2 = c^2।\nফাংশনটি এমন ট্রিপলগুলির একটি তালিকা প্রদান করে যা শর্তগুলি পূরণ করে।\n\nউদাহরণ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nব্যাখ্যা: সীমা=30 এর জন্য, ফাংশনটি পাইথাগোরিয়ান ট্রিপলেট খুঁজে পায় যেখানে a + b + c 30 এর সমান বা কম।\n(3, 4, 5) প্রথম ট্রিপলেট যেখানে a^2 + b^2 = c^2 এবং a + b + c = 12, যা 30 এর চেয়ে কম।\n(5, 12, 13) এবং (6, 8, 10) অন্যান্য বৈধ ট্রিপলেট।",
      "bg": "Дадена е граница, намерете всички Питагорови тройки (a, b, c) такива, че a < b < c и a + b + c <= граница. Питагорова тройка е набор от три положителни цели числа a, b и c, където a^2 + b^2 = c^2. Функцията връща списък от тройки (a, b, c), които удовлетворяват условията.\n\nПример:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nОбяснение: За граница=30, функцията намира Питагорови тройки, където a + b + c е по-малко или равно на 30.\n(3, 4, 5) е първата тройка с a^2 + b^2 = c^2 и a + b + c = 12, което е по-малко от 30.\n(5, 12, 13) и (6, 8, 10) са други валидни тройки.",
      "zh": "给定一个限制，找到所有毕达哥拉斯三元组 (a, b, c)，使得 a < b < c 且 a + b + c <= 限制。 毕达哥拉斯三元组是一组三个正整数 a, b 和 c，其中 a^2 + b^2 = c^2。 该函数返回满足条件的三元组 (a, b, c) 的列表。\n\n示例：\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\n解释：对于 limit=30，函数找到 a + b + c 小于或等于 30 的毕达哥拉斯三元组。 (3, 4, 5) 是第一个三元组，满足 a^2 + b^2 = c^2 且 a + b + c = 12，小于 30。 (5, 12, 13) 和 (6, 8, 10) 是其他有效的三元组。",
      "fr": "Étant donné une limite, trouvez tous les triplets pythagoriciens (a, b, c) tels que a < b < c et a + b + c <= limite.\nUn triplet pythagoricien est un ensemble de trois entiers positifs a, b et c, où a^2 + b^2 = c^2.\nLa fonction renvoie une liste de triplets (a, b, c) qui satisfont les conditions.\n\nExemple :\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplication : Pour limite=30, la fonction trouve des triplets pythagoriciens où a + b + c est inférieur ou égal à 30.\n(3, 4, 5) est le premier triplet avec a^2 + b^2 = c^2 et a + b + c = 12, ce qui est inférieur à 30.\n(5, 12, 13) et (6, 8, 10) sont d'autres triplets valides.",
      "de": "Gegeben ein Limit, finde alle pythagoreischen Tripel (a, b, c), so dass a < b < c und a + b + c <= Limit.\nEin pythagoreisches Tripel ist eine Menge von drei positiven ganzen Zahlen a, b und c, wobei a^2 + b^2 = c^2.\nDie Funktion gibt eine Liste von Tripeln (a, b, c) zurück, die die Bedingungen erfüllen.\n\nBeispiel:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nErläuterung: Für Limit=30 findet die Funktion pythagoreische Tripel, bei denen a + b + c kleiner oder gleich 30 ist.\n(3, 4, 5) ist das erste Tripel mit a^2 + b^2 = c^2 und a + b + c = 12, was kleiner als 30 ist.\n(5, 12, 13) und (6, 8, 10) sind weitere gültige Tripel.",
      "ha": "An ba da iyaka, nemo dukkan triplets na Pythagorean (a, b, c) inda a < b < c kuma a + b + c <= iyaka. Triplet na Pythagorean shine saitin lambobi guda uku masu kyau a, b, da c, inda a^2 + b^2 = c^2. Aikin yana dawo da jerin triples (a, b, c) waɗanda suka cika sharuɗɗan.\n\nMisali:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nBayani: Don iyaka=30, aikin yana nemo triplets na Pythagorean inda a + b + c ya kasance ƙasa ko daidai da 30. (3, 4, 5) shine triplet na farko tare da a^2 + b^2 = c^2 kuma a + b + c = 12, wanda ya kasance ƙasa da 30. (5, 12, 13) da (6, 8, 10) suna daga cikin sauran triplets masu inganci.",
      "hi": "दी गई सीमा के अनुसार, सभी पाइथागोरियन ट्रिपलेट्स (a, b, c) खोजें ताकि a < b < c और a + b + c <= सीमा हो।\nएक पाइथागोरियन ट्रिपलेट तीन धनात्मक पूर्णांकों a, b, और c का सेट है, जहाँ a^2 + b^2 = c^2 होता है।\nयह फ़ंक्शन उन ट्रिपल्स (a, b, c) की सूची लौटाता है जो शर्तों को पूरा करते हैं।\n\nउदाहरण:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nव्याख्या: सीमा=30 के लिए, फ़ंक्शन पाइथागोरियन ट्रिपलेट्स खोजता है जहाँ a + b + c तीस से कम या उसके बराबर है।\n(3, 4, 5) पहला ट्रिपलेट है जिसमें a^2 + b^2 = c^2 और a + b + c = 12 है, जो 30 से कम है।\n(5, 12, 13) और (6, 8, 10) अन्य मान्य ट्रिपलेट्स हैं।",
      "hu": "Adott egy határérték, találja meg az összes Pitagoraszi számhármast (a, b, c), úgy hogy a < b < c és a + b + c <= határérték.\nEgy Pitagoraszi számhármas három pozitív egész szám, a, b és c, ahol a^2 + b^2 = c^2.\nA függvény visszaad egy listát a hármasokról (a, b, c), amelyek megfelelnek a feltételeknek.\n\nPélda:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nMagyarázat: Ha a határérték 30, a függvény megtalálja azokat a Pitagoraszi számhármasokat, ahol a + b + c kisebb vagy egyenlő 30-nál.\n(3, 4, 5) az első hármas, ahol a^2 + b^2 = c^2 és a + b + c = 12, ami kisebb, mint 30.\n(5, 12, 13) és (6, 8, 10) más érvényes hármasok."
    },
    "docstring_bertscore": {
      "sq": "0.9977368054384885",
      "hy": "0.9623704674648456",
      "bn": "0.9595286626033794",
      "bg": "0.9977874561856523",
      "zh": "0.9927420458769852",
      "fr": "0.9977874561856523",
      "de": "0.9967084959558709",
      "ha": "0.9909462286020487",
      "hi": "0.9800084480399817",
      "hu": "0.9808895724102523"
    }
  },
  {
    "task_id": "Kotlin/6",
    "prompt": {
      "en": "/**\n * Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\n * and counts the number of words in it. Words in the input string are separated by spaces.\n *\n * Example:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "sq": "/**\n * Shkruani një funksion në Kotlin që merr një varg si hyrje (gjatësia nuk tejkalon 80 karaktere)\n * dhe numëron numrin e fjalëve në të. Fjalët në vargun e hyrjes ndahen me hapësira.\n *\n * Shembull:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */",
      "hy": "/**\n * Գրեք Kotlin ֆունկցիա, որը ընդունում է տող որպես մուտք (երկարությունը չպետք է գերազանցի 80 նիշը)\n * և հաշվում է դրա մեջ բառերի քանակը։ Մուտքագրված տողի բառերը բաժանվում են բացատներով։\n *\n * Օրինակ:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "bn": "/**\n * একটি Kotlin ফাংশন লিখুন যা একটি স্ট্রিং ইনপুট হিসেবে গ্রহণ করে (দৈর্ঘ্য ৮০ অক্ষরের বেশি নয়)\n * এবং এতে থাকা শব্দের সংখ্যা গণনা করে। ইনপুট স্ট্রিংয়ে শব্দগুলি স্পেস দ্বারা পৃথক করা হয়।\n *\n * উদাহরণ:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "bg": "/**\n * Напишете функция на Kotlin, която приема низ като вход (дължина, която не надвишава 80 знака)\n * и брои броя на думите в него. Думите в входния низ са разделени с интервали.\n *\n * Пример:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "zh": "/**\n * 编写一个Kotlin函数，该函数接受一个字符串作为输入（长度不超过80个字符），\n * 并计算其中的单词数量。输入字符串中的单词由空格分隔。\n *\n * 例子:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */",
      "fr": "/**\n * Écrire une fonction Kotlin qui prend une chaîne de caractères en entrée (longueur ne dépassant pas 80 caractères)\n * et compte le nombre de mots qu'elle contient. Les mots dans la chaîne d'entrée sont séparés par des espaces.\n *\n * Exemple:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "de": "/**\n * Schreiben Sie eine Kotlin-Funktion, die einen String als Eingabe nimmt (Länge darf 80 Zeichen nicht überschreiten)\n * und die Anzahl der Wörter darin zählt. Wörter im Eingabestring sind durch Leerzeichen getrennt.\n *\n * Beispiel:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */",
      "ha": "/**\n * Rubuta wani aikin Kotlin wanda yake karɓar wani igiyar rubutu a matsayin shigarwa (tsawon ba zai wuce haruffa 80 ba)\n * kuma ya ƙirga adadin kalmomi a cikinsa. Kalmomi a cikin igiyar rubutu suna rabuwa da sarari.\n *\n * Misali:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "hi": "/**\n * एक Kotlin फ़ंक्शन लिखें जो एक स्ट्रिंग को इनपुट के रूप में लेता है (लंबाई 80 वर्णों से अधिक नहीं होनी चाहिए)\n * और इसमें शब्दों की संख्या गिनता है। इनपुट स्ट्रिंग में शब्द स्पेस द्वारा अलग किए गए हैं।\n *\n * उदाहरण:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "hu": "/**\n * Írj egy Kotlin függvényt, amely egy karakterláncot vesz bemenetként (hossza nem haladja meg a 80 karaktert),\n * és megszámolja benne a szavak számát. A bemeneti karakterláncban a szavakat szóközök választják el.\n *\n * Példa:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int"
    },
    "prompt_bertscore": {
      "sq": "0.9552662532567519",
      "hy": "0.9823993619364986",
      "bn": "0.987548854564828",
      "bg": "0.9881600402472723",
      "zh": "0.9551454859850825",
      "fr": "0.9883441706104917",
      "de": "0.9575550711374168",
      "ha": "0.9917298254552314",
      "hi": "0.9931498340492498",
      "hu": "0.9809797506032422"
    },
    "canonical_solution": "{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}",
    "instruction": {
      "en": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 अक्षरों का हो।",
      "hu": "fun countWords(inputString: String): Int\n{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9459955774827105",
      "hy": "0.9478766071911109",
      "bn": "0.8738053517993907",
      "bg": "0.8382497190726216",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9368963197275022",
      "hi": "0.8761702451159921",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    // Test cases\n    check(countWords(\"This is a book\") == 4)\n    check(countWords(\"   Hello   World!  World World \") == 3)\n    check(countWords(\"A  string  with  multiple  spaces\") == 5)\n    check(countWords(\"\") == 0) // Edge case: Empty string should have 0 words\n    check(countWords(\"SingleWord\") == 1) // Edge case: String with a single word\n    check(countWords(\"a a a a a a a a a a a a\") == 1) \n    check(countWords(\"a a a ab ab c c c c c c b a c\") == 4) \n}\n\n\nmain()",
    "entry_point": "countWords",
    "signature": "fun countWords(inputString: String): Int",
    "docstring": {
      "en": "Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\nand counts the number of words in it. Words in the input string are separated by spaces.\n\nExample:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "sq": "Shkruani një funksion Kotlin që merr një varg si hyrje (gjatësia nuk duhet të kalojë 80 karaktere) dhe numëron numrin e fjalëve në të. Fjalët në vargun e hyrjes ndahen nga hapësirat.\n\nShembull:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "hy": "Գրեք Kotlin ֆունկցիա, որը որպես մուտք կստանա տող (երկարությունը չի գերազանցում 80 նիշը)\nև կհաշվի դրա մեջ բառերի քանակը։ Մուտքային տողի բառերը բաժանված են բացատներով։\n\nՕրինակ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "bn": "একটি Kotlin ফাংশন লিখুন যা একটি স্ট্রিং ইনপুট হিসাবে গ্রহণ করে (দৈর্ঘ্য ৮০ অক্ষর অতিক্রম করবে না) এবং এতে থাকা শব্দগুলির সংখ্যা গণনা করে। ইনপুট স্ট্রিংয়ে শব্দগুলি স্পেস দ্বারা পৃথক করা হয়।\n\nউদাহরণ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "bg": "Напишете Kotlin функция, която приема низ като вход (с дължина, която не надвишава 80 знака) и брои броя на думите в него. Думите в входния низ са разделени с интервали.\n\nПример:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "zh": "编写一个 Kotlin 函数，该函数接受一个字符串作为输入（长度不超过 80 个字符），并计算其中的单词数量。输入字符串中的单词由空格分隔。\n\n示例：\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "fr": "Écrire une fonction Kotlin qui prend une chaîne de caractères en entrée (longueur ne dépassant pas 80 caractères) et compte le nombre de mots qu'elle contient. Les mots dans la chaîne d'entrée sont séparés par des espaces.\n\nExemple :\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "de": "Schreiben Sie eine Kotlin-Funktion, die einen String als Eingabe nimmt (Länge nicht mehr als 80 Zeichen) und die Anzahl der Wörter darin zählt. Wörter im Eingabestring sind durch Leerzeichen getrennt.\n\nBeispiel:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "ha": "Rubuta wani aikin Kotlin wanda ke ɗaukar kirtani a matsayin shigarwa (tsawon ba ya wuce haruffa 80) kuma yana ƙidaya adadin kalmomi a cikinsa. Kalmomi a cikin kirtanin shigarwa suna rabuwa da sarari.\n\nMisali:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "hi": "Kotlin फ़ंक्शन लिखें जो एक स्ट्रिंग को इनपुट के रूप में लेता है (लंबाई 80 अक्षरों से अधिक नहीं होनी चाहिए) और इसमें शब्दों की संख्या गिनता है। इनपुट स्ट्रिंग में शब्द स्पेस द्वारा अलग किए गए हैं।\n\nउदाहरण:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "hu": "Írj egy Kotlin függvényt, amely bemenetként egy karakterláncot vesz (hossza nem haladja meg a 80 karaktert), és megszámolja benne a szavak számát. A bemeneti karakterláncban a szavakat szóközök választják el.\n\nPélda:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5"
    },
    "docstring_bertscore": {
      "sq": "0.9789666316914536",
      "hy": "0.9845985975153169",
      "bn": "0.977648123222144",
      "bg": "0.9854884616223532",
      "zh": "0.9854884616223532",
      "fr": "0.9869829566092596",
      "de": "0.993794191005327",
      "ha": "1",
      "hi": "0.967787316586048",
      "hu": "0.982623417006306"
    }
  },
  {
    "task_id": "Kotlin/7",
    "prompt": {
      "en": "/**\n  * Generates a Pascal's Triangle up to the specified number of rows.\n  * In Pascal's Triangle, each number is the sum of the two numbers directly above it.\n  * The function returns a list of lists, where each inner list represents a row in the triangle.\n  *\n  * Example:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "sq": "/**\n  * Gjeneron një Trekëndësh të Pascal-it deri në numrin e specifikuar të rreshtave.\n  * Në Trekëndëshin e Pascal-it, çdo numër është shuma e dy numrave direkt mbi të.\n  * Funksioni kthen një listë listash, ku çdo listë e brendshme përfaqëson një rresht në trekëndësh.\n  *\n  * Shembull:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "hy": "/**\n  * Գեներացնում է Պասկալի եռանկյունին մինչև նշված տողերի քանակը:\n  * Պասկալի եռանկյունում յուրաքանչյուր թիվ հավասար է իր վերևում գտնվող երկու թվերի գումարին:\n  * Ֆունկցիան վերադարձնում է ցուցակների ցուցակ, որտեղ յուրաքանչյուր ներքին ցուցակը ներկայացնում է եռանկյան մեկ տող:\n  *\n  * Օրինակ:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "bn": "/**\n  * নির্দিষ্ট সংখ্যক সারি পর্যন্ত প্যাসকেলের ত্রিভুজ তৈরি করে।\n  * প্যাসকেলের ত্রিভুজে, প্রতিটি সংখ্যা তার উপরের দুটি সংখ্যার যোগফল।\n  * ফাংশনটি তালিকার একটি তালিকা প্রদান করে, যেখানে প্রতিটি অভ্যন্তরীণ তালিকা ত্রিভুজের একটি সারি উপস্থাপন করে।\n  *\n  * উদাহরণ:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "bg": "/**\n  * Генерира Триъгълника на Паскал до зададения брой редове.\n  * В Триъгълника на Паскал всяко число е сумата от двете числа директно над него.\n  * Функцията връща списък от списъци, където всеки вътрешен списък представлява ред в триъгълника.\n  *\n  * Пример:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "zh": "/**\n  * 生成一个指定行数的帕斯卡三角形。\n  * 在帕斯卡三角形中，每个数字是其正上方两个数字之和。\n  * 该函数返回一个列表的列表，其中每个内部列表代表三角形中的一行。\n  *\n  * 示例:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "fr": "/**\n  * Génère un triangle de Pascal jusqu'au nombre de lignes spécifié.\n  * Dans le triangle de Pascal, chaque nombre est la somme des deux nombres directement au-dessus de lui.\n  * La fonction renvoie une liste de listes, où chaque liste interne représente une ligne du triangle.\n  *\n  * Exemple :\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "de": "/**\n  * Generiert ein Pascalsches Dreieck bis zur angegebenen Anzahl von Zeilen.\n  * Im Pascalschen Dreieck ist jede Zahl die Summe der beiden direkt darüber liegenden Zahlen.\n  * Die Funktion gibt eine Liste von Listen zurück, wobei jede innere Liste eine Zeile im Dreieck darstellt.\n  *\n  * Beispiel:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "ha": "/**\n  * Yana ƙirƙirar Triangle na Pascal har zuwa adadin layuka da aka fayyace.\n  * A cikin Triangle na Pascal, kowace lamba ita ce jumlar lambobin guda biyu da ke kai tsaye a saman ta.\n  * Aikin yana mayar da jerin jerin, inda kowace jerin ciki ke wakiltar layi a cikin triangle.\n  *\n  * Misali:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "hi": "/**\n  * निर्दिष्ट पंक्तियों की संख्या तक पास्कल त्रिभुज उत्पन्न करता है।\n  * पास्कल त्रिभुज में, प्रत्येक संख्या उसके सीधे ऊपर की दो संख्याओं का योग होती है।\n  * फ़ंक्शन एक सूची की सूची लौटाता है, जहाँ प्रत्येक आंतरिक सूची त्रिभुज में एक पंक्ति का प्रतिनिधित्व करती है।\n  *\n  * उदाहरण:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "hu": "/**\n  * Generál egy Pascal háromszöget a megadott sorok számáig.\n  * A Pascal háromszögben minden szám az közvetlenül fölötte lévő két szám összege.\n  * A függvény egy listát ad vissza listákból, ahol minden belső lista egy sort képvisel a háromszögben.\n  *\n  * Példa:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> "
    },
    "prompt_bertscore": {
      "sq": "0.9652299504302239",
      "hy": "0.9550994037366825",
      "bn": "0.9450403639803137",
      "bg": "0.9613169319238366",
      "zh": "0.9504949528739127",
      "fr": "0.95504517764266",
      "de": "0.9624902415846096",
      "ha": "0.9580214552720867",
      "hi": "0.9586544902964449",
      "hu": "0.9624902415846096"
    },
    "canonical_solution": "{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}",
    "instruction": {
      "en": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nՏվեք կարճ բնութագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun generatePascalsTriangle(rows: Int): List<List<Int>>\n{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódhoz magyarul, legfeljebb 500 karakter felhasználásával."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.8909350372294584",
      "bn": "0.8738053517993907",
      "bg": "0.8383597137705134",
      "zh": "0.83038971626469",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9422539769951562",
      "hi": "0.8761702451159921",
      "hu": "0.9427815392871849"
    },
    "level": "",
    "test": "fun main() {\n    check(generatePascalsTriangle(1) == listOf(listOf(1)))\n    check(generatePascalsTriangle(2) == listOf(listOf(1), listOf(1, 1)))\n    check(generatePascalsTriangle(3) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1)))\n    check(generatePascalsTriangle(4) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1)))\n    check(generatePascalsTriangle(5) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1)))\n    check(generatePascalsTriangle(6) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1), listOf(1, 5, 10, 10, 5, 1)))\n\n}\n\nmain()",
    "entry_point": "generatePascalsTriangle",
    "signature": "fun generatePascalsTriangle(rows: Int): List<List<Int>>",
    "docstring": {
      "en": "Generates a Pascal's Triangle up to the specified number of rows.\nIn Pascal's Triangle, each number is the sum of the two numbers directly above it.\nThe function returns a list of lists, where each inner list represents a row in the triangle.\n\nExample:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "sq": "Gjeneron Trekëndëshin e Pascal-it deri në numrin e specifikuar të rreshtave.  \nNë Trekëndëshin e Pascal-it, çdo numër është shuma e dy numrave direkt mbi të.  \nFunksioni kthen një listë listash, ku çdo listë e brendshme përfaqëson një rresht në trekëndësh.\n\nShembull:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hy": "Ստեղծում է Պասկալի եռանկյունի մինչև նշված տողերի քանակը:\nՊասկալի եռանկյունում յուրաքանչյուր թիվ հավասար է անմիջապես վերևում գտնվող երկու թվերի գումարին:\nՖունկցիան վերադարձնում է ցուցակների ցուցակ, որտեղ յուրաքանչյուր ներքին ցուցակ ներկայացնում է եռանկյունու տող:\n\nՕրինակ:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "bn": "নির্দিষ্ট সংখ্যক সারি পর্যন্ত প্যাসকেলের ত্রিভুজ তৈরি করে।  \nপ্যাসকেলের ত্রিভুজে, প্রতিটি সংখ্যা তার ঠিক উপরে থাকা দুটি সংখ্যার যোগফল।  \nফাংশনটি তালিকার একটি তালিকা প্রদান করে, যেখানে প্রতিটি অভ্যন্তরীণ তালিকা ত্রিভুজের একটি সারি উপস্থাপন করে।\n\nউদাহরণ:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "bg": "Генерира триъгълник на Паскал до посочения брой редове.  \nВ триъгълника на Паскал всяко число е сумата от двете числа директно над него.  \nФункцията връща списък от списъци, където всеки вътрешен списък представлява ред в триъгълника.\n\nПример:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "zh": "生成一个指定行数的帕斯卡三角形。\n在帕斯卡三角形中，每个数字是其正上方两个数字之和。\n该函数返回一个列表的列表，其中每个内部列表代表三角形中的一行。\n\n示例：\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "fr": "Génère un triangle de Pascal jusqu'au nombre spécifié de lignes.  \nDans le triangle de Pascal, chaque nombre est la somme des deux nombres directement au-dessus de lui.  \nLa fonction renvoie une liste de listes, où chaque liste interne représente une ligne du triangle.\n\nExemple :  \n>>> generatePascalsTriangle(3)  \n[[1], [1, 1], [1, 2, 1]]  \n>>> generatePascalsTriangle(5)  \n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "de": "Erzeugt ein Pascalsches Dreieck bis zur angegebenen Anzahl von Zeilen.\nIn Pascals Dreieck ist jede Zahl die Summe der beiden Zahlen direkt über ihr.\nDie Funktion gibt eine Liste von Listen zurück, wobei jede innere Liste eine Zeile im Dreieck darstellt.\n\nBeispiel:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "ha": "Yana haifar da Triangle na Pascal har zuwa adadin layuka da aka ƙayyade.  \nA cikin Triangle na Pascal, kowanne lamba yana daidai da jumlar lambobin biyu da ke kai tsaye a sama da shi.  \nAikin yana dawowa da jerin jerin, inda kowanne jerin ciki yana wakiltar layi a cikin triangle.  \n\nMisali:  \n>>> generatePascalsTriangle(3)  \n[[1], [1, 1], [1, 2, 1]]  \n>>> generatePascalsTriangle(5)  \n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hi": "निर्दिष्ट पंक्तियों की संख्या तक एक पास्कल त्रिभुज उत्पन्न करता है। पास्कल त्रिभुज में, प्रत्येक संख्या उसके ठीक ऊपर की दो संख्याओं का योग होता है। यह फ़ंक्शन सूचियों की एक सूची लौटाता है, जहां प्रत्येक आंतरिक सूची त्रिभुज में एक पंक्ति का प्रतिनिधित्व करती है।\n\nउदाहरण:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hu": "Generál egy Pascal-háromszöget a megadott sorok számáig.\nA Pascal-háromszögben minden szám az őt közvetlenül megelőző két szám összege.\nA függvény egy listákból álló listát ad vissza, ahol minden belső lista a háromszög egy sorát képviseli.\n\nPélda:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]"
    },
    "docstring_bertscore": {
      "sq": "0.993617608596587",
      "hy": "0.9780825278654673",
      "bn": "0.9779949318674309",
      "bg": "0.9905008992877685",
      "zh": "0.9807032571128417",
      "fr": "0.9917872296353505",
      "de": "1",
      "ha": "0.9909768176807281",
      "hi": "0.990298494929494",
      "hu": "0.9917872296353505"
    }
  },
  {
    "task_id": "Kotlin/8",
    "prompt": {
      "en": "/**\n * Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n * - For profit up to 100,000, the bonus is 10%.\n * - For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n * - For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n * - For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n * - For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n * - For profit above 1,000,000, it's 1% for the amount over 1,000,000. \n * The function returns the total bonus amount.\n * Example:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "sq": "/**\n * Llogarit shpërblimin bazuar në shumën e fitimit të dhënë. Shpërblimi llogaritet sipas një sistemi me nivele:\n * - Për fitim deri në 100,000, shpërblimi është 10%.\n * - Për fitim mbi 100,000 dhe deri në 200,000, është 10% për 100,000 e parë dhe 7.5% për pjesën tjetër.\n * - Për fitim midis 200,000 dhe 400,000, është 5% për shumën mbi 200,000.\n * - Për fitim midis 400,000 dhe 600,000, është 3% për shumën mbi 400,000.\n * - Për fitim midis 600,000 dhe 1,000,000, është 1.5% për shumën mbi 600,000.\n * - Për fitim mbi 1,000,000, është 1% për shumën mbi 1,000,000. \n * Funksioni kthen shumën totale të shpërblimit.\n * Shembull:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "hy": "/**\n * Հաշվում է բոնուսը տրված շահույթի գումարի հիման վրա։ Բոնուսը հաշվարկվում է աստիճանավոր համակարգով.\n * - Մինչև 100,000 շահույթի դեպքում բոնուսը կազմում է 10%:\n * - 100,000-ից մինչև 200,000 շահույթի դեպքում՝ առաջին 100,000-ի համար 10% և մնացածի համար 7.5%:\n * - 200,000-ից մինչև 400,000 շահույթի դեպքում՝ 5% 200,000-ից ավել գումարի համար:\n * - 400,000-ից մինչև 600,000 շահույթի դեպքում՝ 3% 400,000-ից ավել գումարի համար:\n * - 600,000-ից մինչև 1,000,000 շահույթի դեպքում՝ 1.5% 600,000-ից ավել գումարի համար:\n * - 1,000,000-ից ավել շահույթի դեպքում՝ 1% 1,000,000-ից ավել գումարի համար։ \n * Ֆունկցիան վերադարձնում է ընդհանուր բոնուսի գումարը։\n * Օրինակ:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "bn": "/**\n * প্রদত্ত মুনাফার পরিমাণের ভিত্তিতে বোনাস গণনা করে। বোনাসটি একটি স্তরভিত্তিক পদ্ধতিতে গণনা করা হয়:\n * - মুনাফা 100,000 পর্যন্ত হলে, বোনাস 10%।\n * - মুনাফা 100,000 এর উপরে এবং 200,000 পর্যন্ত হলে, প্রথম 100,000 এর জন্য 10% এবং বাকি অংশের জন্য 7.5%।\n * - মুনাফা 200,000 এবং 400,000 এর মধ্যে হলে, 200,000 এর উপরের পরিমাণের জন্য 5%।\n * - মুনাফা 400,000 এবং 600,000 এর মধ্যে হলে, 400,000 এর উপরের পরিমাণের জন্য 3%।\n * - মুনাফা 600,000 এবং 1,000,000 এর মধ্যে হলে, 600,000 এর উপরের পরিমাণের জন্য 1.5%।\n * - মুনাফা 1,000,000 এর উপরে হলে, 1,000,000 এর উপরের পরিমাণের জন্য 1%। \n * ফাংশনটি মোট বোনাস পরিমাণ ফেরত দেয়।\n * উদাহরণ:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "bg": "/**\n * Изчислява бонуса на базата на дадената сума на печалбата. Бонусът се изчислява по система на нива:\n * - За печалба до 100,000, бонусът е 10%.\n * - За печалба над 100,000 и до 200,000, е 10% за първите 100,000 и 7.5% за останалото.\n * - За печалба между 200,000 и 400,000, е 5% за сумата над 200,000.\n * - За печалба между 400,000 и 600,000, е 3% за сумата над 400,000.\n * - За печалба между 600,000 и 1,000,000, е 1.5% за сумата над 600,000.\n * - За печалба над 1,000,000, е 1% за сумата над 1,000,000. \n * Функцията връща общата сума на бонуса.\n * Пример:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "zh": "/**\n * 根据给定的利润金额计算奖金。奖金是根据分级系统计算的：\n * - 利润最高为100,000时，奖金为10%。\n * - 利润超过100,000且最高为200,000时，前100,000的奖金为10%，其余部分为7.5%。\n * - 利润在200,000到400,000之间时，超过200,000的部分为5%。\n * - 利润在400,000到600,000之间时，超过400,000的部分为3%。\n * - 利润在600,000到1,000,000之间时，超过600,000的部分为1.5%。\n * - 利润超过1,000,000时，超过1,000,000的部分为1%。 \n * 该函数返回总奖金金额。\n * 示例:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "fr": "/**\n * Calcule le bonus basé sur le montant du profit donné. Le bonus est calculé selon un système par paliers :\n * - Pour un profit jusqu'à 100 000, le bonus est de 10 %.\n * - Pour un profit supérieur à 100 000 et jusqu'à 200 000, c'est 10 % pour les premiers 100 000 et 7,5 % pour le reste.\n * - Pour un profit entre 200 000 et 400 000, c'est 5 % pour le montant au-dessus de 200 000.\n * - Pour un profit entre 400 000 et 600 000, c'est 3 % pour le montant au-dessus de 400 000.\n * - Pour un profit entre 600 000 et 1 000 000, c'est 1,5 % pour le montant au-dessus de 600 000.\n * - Pour un profit supérieur à 1 000 000, c'est 1 % pour le montant au-dessus de 1 000 000. \n * La fonction renvoie le montant total du bonus.\n * Exemple :\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "de": "/**\n * Berechnet den Bonus basierend auf dem gegebenen Gewinnbetrag. Der Bonus wird nach einem gestaffelten System berechnet:\n * - Für Gewinn bis zu 100.000 beträgt der Bonus 10%.\n * - Für Gewinn über 100.000 und bis zu 200.000 sind es 10% für die ersten 100.000 und 7,5% für den Rest.\n * - Für Gewinn zwischen 200.000 und 400.000 sind es 5% für den Betrag über 200.000.\n * - Für Gewinn zwischen 400.000 und 600.000 sind es 3% für den Betrag über 400.000.\n * - Für Gewinn zwischen 600.000 und 1.000.000 sind es 1,5% für den Betrag über 600.000.\n * - Für Gewinn über 1.000.000 sind es 1% für den Betrag über 1.000.000. \n * Die Funktion gibt den gesamten Bonusbetrag zurück.\n * Beispiel:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "ha": "/**\n * Lissafa alawus bisa ga adadin ribar da aka bayar. Ana lissafa alawus ɗin bisa tsarin matakai:\n * - Don riba har zuwa 100,000, alawus ɗin yana da 10%.\n * - Don riba sama da 100,000 kuma har zuwa 200,000, yana da 10% don farkon 100,000 da 7.5% don sauran.\n * - Don riba tsakanin 200,000 da 400,000, yana da 5% don adadin sama da 200,000.\n * - Don riba tsakanin 400,000 da 600,000, yana da 3% don adadin sama da 400,000.\n * - Don riba tsakanin 600,000 da 1,000,000, yana da 1.5% don adadin sama da 600,000.\n * - Don riba sama da 1,000,000, yana da 1% don adadin sama da 1,000,000. \n * Aikin yana dawo da jimillar adadin alawus ɗin.\n * Misali:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "hi": "/**\n * दिए गए लाभ राशि के आधार पर बोनस की गणना करता है। बोनस एक स्तरीय प्रणाली पर गणना की जाती है:\n * - लाभ 100,000 तक के लिए, बोनस 10% है।\n * - 100,000 से अधिक और 200,000 तक के लाभ के लिए, पहले 100,000 के लिए 10% और बाकी के लिए 7.5% है।\n * - 200,000 और 400,000 के बीच लाभ के लिए, 200,000 से ऊपर की राशि के लिए 5% है।\n * - 400,000 और 600,000 के बीच लाभ के लिए, 400,000 से ऊपर की राशि के लिए 3% है।\n * - 600,000 और 1,000,000 के बीच लाभ के लिए, 600,000 से ऊपर की राशि के लिए 1.5% है।\n * - 1,000,000 से अधिक लाभ के लिए, 1,000,000 से ऊपर की राशि के लिए 1% है।\n * यह फ़ंक्शन कुल बोनस राशि को लौटाता है।\n * उदाहरण:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "hu": "/**\n * Kiszámítja a bónuszt a megadott nyereségösszeg alapján. A bónusz egy lépcsőzetes rendszer szerint kerül kiszámításra:\n * - 100 000-ig terjedő nyereség esetén a bónusz 10%.\n * - 100 000 feletti és 200 000-ig terjedő nyereség esetén az első 100 000-re 10%, a fennmaradó részre 7,5%.\n * - 200 000 és 400 000 közötti nyereség esetén a 200 000 feletti összegre 5%.\n * - 400 000 és 600 000 közötti nyereség esetén a 400 000 feletti összegre 3%.\n * - 600 000 és 1 000 000 közötti nyereség esetén a 600 000 feletti összegre 1,5%.\n * - 1 000 000 feletti nyereség esetén az 1 000 000 feletti összegre 1%. \n * A függvény visszaadja a teljes bónusz összegét.\n * Példa:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */"
    },
    "prompt_bertscore": {
      "sq": "0.973184302669147",
      "hy": "0.9426301829368363",
      "bn": "0.9489537797474631",
      "bg": "0.9909970779795937",
      "zh": "0.9049412599177525",
      "fr": "0.962589358144746",
      "de": "0.975296935401834",
      "ha": "0.9766988686311783",
      "hi": "0.9598985123728664",
      "hu": "0.9470296472463781"
    },
    "canonical_solution": "{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}",
    "instruction": {
      "en": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nՏվեք հակիրճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fun calculateBonus(profit: Double): Double\n{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.8961598107722001",
      "bn": "0.8688058251087426",
      "bg": "0.8999760962830234",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9422539769951562",
      "hi": "0.8761702451159921",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n    check(calculateBonus(50_000.00) == 5000.00)\n    check(calculateBonus(210_000.00) == 18000.00)\n    check(calculateBonus(150_000.00) == 13750.00)\n    check(calculateBonus(250_000.00) == 20000.00)\n    check(calculateBonus(450_000.00) == 29000.00)\n    check(calculateBonus(650_000.00) == 34250.00)\n    check(calculateBonus(1_050_000.00) == 40000.00)\n    check(calculateBonus(2_000_000.00) == 49500.00)\n}\n\nmain()",
    "entry_point": "calculateBonus",
    "signature": "fun calculateBonus(profit: Double): Double",
    "docstring": {
      "en": "Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n- For profit up to 100,000, the bonus is 10%.\n- For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n- For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n- For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n- For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n- For profit above 1,000,000, it's 1% for the amount over 1,000,000.\nThe function returns the total bonus amount.\nExample:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "sq": "Llogarit shpërblimin bazuar në shumën e fitimit të dhënë. Shpërblimi llogaritet sipas një sistemi të shkallëzuar:\n- Për fitim deri në 100,000, shpërblimi është 10%.\n- Për fitim mbi 100,000 dhe deri në 200,000, është 10% për 100,000 e parë dhe 7.5% për pjesën tjetër.\n- Për fitim midis 200,000 dhe 400,000, është 5% për shumën mbi 200,000.\n- Për fitim midis 400,000 dhe 600,000, është 3% për shumën mbi 400,000.\n- Për fitim midis 600,000 dhe 1,000,000, është 1.5% për shumën mbi 600,000.\n- Për fitim mbi 1,000,000, është 1% për shumën mbi 1,000,000.\nFunksioni kthen shumën totale të shpërblimit.\nShembull:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hy": "Հաշվարկում է բոնուսը տրված շահույթի գումարի հիման վրա։ Բոնուսը հաշվարկվում է աստիճանավոր համակարգով.\n- Մինչև 100,000 շահույթի դեպքում բոնուսը կազմում է 10%:\n- 100,000-ից մինչև 200,000 շահույթի դեպքում՝ 10% առաջին 100,000-ի համար և 7.5% մնացածի համար:\n- 200,000-ից մինչև 400,000 շահույթի դեպքում՝ 5% 200,000-ից ավել գումարի համար:\n- 400,000-ից մինչև 600,000 շահույթի դեպքում՝ 3% 400,000-ից ավել գումարի համար:\n- 600,000-ից մինչև 1,000,000 շահույթի դեպքում՝ 1.5% 600,000-ից ավել գումարի համար:\n- 1,000,000-ից ավել շահույթի դեպքում՝ 1% 1,000,000-ից ավել գումարի համար:\nՖունկցիան վերադարձնում է ընդհանուր բոնուսի գումարը։\nՕրինակ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "bn": "প্রদত্ত মুনাফার পরিমাণের উপর ভিত্তি করে বোনাস গণনা করে। বোনাসটি একটি স্তরভিত্তিক সিস্টেমে গণনা করা হয়:\n- মুনাফা 100,000 পর্যন্ত হলে, বোনাস 10%।\n- মুনাফা 100,000 এর উপরে এবং 200,000 পর্যন্ত হলে, প্রথম 100,000 এর জন্য 10% এবং বাকি অংশের জন্য 7.5%।\n- মুনাফা 200,000 এবং 400,000 এর মধ্যে হলে, 200,000 এর উপরে পরিমাণের জন্য 5%।\n- মুনাফা 400,000 এবং 600,000 এর মধ্যে হলে, 400,000 এর উপরে পরিমাণের জন্য 3%।\n- মুনাফা 600,000 এবং 1,000,000 এর মধ্যে হলে, 600,000 এর উপরে পরিমাণের জন্য 1.5%।\n- মুনাফা 1,000,000 এর উপরে হলে, 1,000,000 এর উপরে পরিমাণের জন্য 1%।\nফাংশনটি মোট বোনাসের পরিমাণ প্রদান করে।\nউদাহরণ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "bg": "Изчислява бонуса на базата на дадената сума на печалбата. Бонусът се изчислява по система на нива:\n- За печалба до 100,000, бонусът е 10%.\n- За печалба над 100,000 и до 200,000, е 10% за първите 100,000 и 7.5% за останалото.\n- За печалба между 200,000 и 400,000, е 5% за сумата над 200,000.\n- За печалба между 400,000 и 600,000, е 3% за сумата над 400,000.\n- За печалба между 600,000 и 1,000,000, е 1.5% за сумата над 600,000.\n- За печалба над 1,000,000, е 1% за сумата над 1,000,000.\nФункцията връща общата сума на бонуса.\nПример:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "zh": "计算基于给定利润金额的奖金。奖金是根据分级系统计算的：\n- 对于利润不超过 100,000 的部分，奖金为 10%。\n- 对于利润超过 100,000 且不超过 200,000 的部分，前 100,000 的奖金为 10%，其余部分为 7.5%。\n- 对于利润在 200,000 到 400,000 之间的部分，超过 200,000 的部分奖金为 5%。\n- 对于利润在 400,000 到 600,000 之间的部分，超过 400,000 的部分奖金为 3%。\n- 对于利润在 600,000 到 1,000,000 之间的部分，超过 600,000 的部分奖金为 1.5%。\n- 对于利润超过 1,000,000 的部分，超过 1,000,000 的部分奖金为 1%。\n函数返回总奖金金额。\n例子：\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "fr": "Calcule le bonus basé sur le montant du bénéfice donné. Le bonus est calculé selon un système par paliers :\n- Pour un bénéfice jusqu'à 100 000, le bonus est de 10 %.\n- Pour un bénéfice supérieur à 100 000 et jusqu'à 200 000, c'est 10 % pour les premiers 100 000 et 7,5 % pour le reste.\n- Pour un bénéfice entre 200 000 et 400 000, c'est 5 % pour le montant supérieur à 200 000.\n- Pour un bénéfice entre 400 000 et 600 000, c'est 3 % pour le montant supérieur à 400 000.\n- Pour un bénéfice entre 600 000 et 1 000 000, c'est 1,5 % pour le montant supérieur à 600 000.\n- Pour un bénéfice supérieur à 1 000 000, c'est 1 % pour le montant supérieur à 1 000 000.\nLa fonction retourne le montant total du bonus.\nExemple :\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "de": "Berechnet den Bonus basierend auf dem gegebenen Gewinnbetrag. Der Bonus wird nach einem gestuften System berechnet:\n- Für Gewinne bis zu 100.000 beträgt der Bonus 10%.\n- Für Gewinne über 100.000 und bis zu 200.000 sind es 10% für die ersten 100.000 und 7,5% für den Rest.\n- Für Gewinne zwischen 200.000 und 400.000 sind es 5% für den Betrag über 200.000.\n- Für Gewinne zwischen 400.000 und 600.000 sind es 3% für den Betrag über 400.000.\n- Für Gewinne zwischen 600.000 und 1.000.000 sind es 1,5% für den Betrag über 600.000.\n- Für Gewinne über 1.000.000 sind es 1% für den Betrag über 1.000.000.\nDie Funktion gibt den gesamten Bonusbetrag zurück.\nBeispiel:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "ha": "Yana lissafin kari bisa ga adadin riba da aka bayar. Ana ƙididdige ƙarin akan tsarin matakai:\n- Don riba har zuwa 100,000, ƙarin yana da 10%.\n- Don riba sama da 100,000 kuma har zuwa 200,000, yana da 10% don farkon 100,000 da 7.5% don sauran.\n- Don riba tsakanin 200,000 da 400,000, yana da 5% don adadin da ya wuce 200,000.\n- Don riba tsakanin 400,000 da 600,000, yana da 3% don adadin da ya wuce 400,000.\n- Don riba tsakanin 600,000 da 1,000,000, yana da 1.5% don adadin da ya wuce 600,000.\n- Don riba sama da 1,000,000, yana da 1% don adadin da ya wuce 1,000,000.\nAikin yana dawowa da jimlar adadin ƙarin.\nMisali:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hi": "दिए गए लाभ राशि के आधार पर बोनस की गणना करता है। बोनस दिए गए लाभ राशि के आधार पर गणना की जाती है। बोनस एक स्तरित प्रणाली पर आधारित है:\n- 100,000 तक के लाभ के लिए, बोनस 10% है।\n- 100,000 से अधिक और 200,000 तक के लाभ के लिए, पहले 100,000 के लिए 10% और बाकी के लिए 7.5% है।\n- 200,000 और 400,000 के बीच के लाभ के लिए, 200,000 से अधिक राशि के लिए 5% है।\n- 400,000 और 600,000 के बीच के लाभ के लिए, 400,000 से अधिक राशि के लिए 3% है।\n- 600,000 और 1,000,000 के बीच के लाभ के लिए, 600,000 से अधिक राशि के लिए 1.5% है।\n- 1,000,000 से अधिक लाभ के लिए, 1,000,000 से अधिक राशि के लिए 1% है।\nThe function returns the total bonus amount. यह फ़ंक्शन कुल बोनस राशि लौटाता है।\nउदाहरण:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hu": "Kiszámítja a bónuszt a megadott nyereség alapján. A bónusz egy sávos rendszer szerint kerül kiszámításra:\n- 100,000-ig terjedő nyereség esetén a bónusz 10%.\n- 100,000 feletti és 200,000-ig terjedő nyereség esetén az első 100,000-re 10%, a fennmaradó részre 7,5%.\n- 200,000 és 400,000 közötti nyereség esetén a 200,000 feletti összegre 5%.\n- 400,000 és 600,000 közötti nyereség esetén a 400,000 feletti összegre 3%.\n- 600,000 és 1,000,000 közötti nyereség esetén a 600,000 feletti összegre 1,5%.\n- 1,000,000 feletti nyereség esetén az 1,000,000 feletti összegre 1%.\nA függvény visszaadja a teljes bónusz összegét.\nPélda:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00"
    },
    "docstring_bertscore": {
      "sq": "0.9811871207210426",
      "hy": "0.9861054075858475",
      "bn": "0.9667949592023978",
      "bg": "0.9909349066703298",
      "zh": "0.9007086451282801",
      "fr": "0.9796274749691567",
      "de": "0.9881546772269845",
      "ha": "0.983790569125267",
      "hi": "0.9918553598560454",
      "hu": "0.9405693927335994"
    }
  },
  {
    "task_id": "Kotlin/9",
    "prompt": {
      "en": "/**\n    * Returns the top ten highest scores from a given list of scores, sorted in descending order.\n    * If there are fewer than ten scores in the list, all scores are returned.\n    * Example:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "sq": "/**\n    * Kthen dhjetë rezultatet më të larta nga një listë e dhënë e rezultateve, të renditura në rend zbritës.\n    * Nëse ka më pak se dhjetë rezultate në listë, të gjitha rezultatet kthehen.\n    * Shembull:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "hy": "/**\n    * Վերադարձնում է տասն ամենաբարձր միավորները տրված միավորների ցուցակից, դասավորված նվազման կարգով:\n    * Եթե ցուցակում տասից քիչ միավորներ կան, վերադարձվում են բոլոր միավորները:\n    * Օրինակ:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "bn": "/**\n    * প্রদত্ত স্কোরের তালিকা থেকে শীর্ষ দশটি সর্বোচ্চ স্কোর ফেরত দেয়, অবতরণ ক্রমে সাজানো।\n    * যদি তালিকায় দশটির কম স্কোর থাকে, তবে সব স্কোর ফেরত দেওয়া হয়।\n    * উদাহরণ:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "bg": "/**\n    * Връща десетте най-високи резултата от даден списък с резултати, подредени в низходящ ред.\n    * Ако в списъка има по-малко от десет резултата, се връщат всички резултати.\n    * Пример:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "zh": "/**\n    * 返回给定分数列表中最高的前十个分数，按降序排序。\n    * 如果列表中的分数少于十个，则返回所有分数。\n    * 示例:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "fr": "/**\n    * Renvoie les dix meilleurs scores d'une liste donnée de scores, triés par ordre décroissant.\n    * S'il y a moins de dix scores dans la liste, tous les scores sont renvoyés.\n    * Exemple :\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "de": "/**\n    * Gibt die zehn höchsten Punktzahlen aus einer gegebenen Liste von Punktzahlen zurück, sortiert in absteigender Reihenfolge.\n    * Wenn es weniger als zehn Punktzahlen in der Liste gibt, werden alle Punktzahlen zurückgegeben.\n    * Beispiel:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "ha": "/**\n    * Yana dawo da maki goma mafi girma daga jerin maki da aka bayar, an jera su a cikin tsari mai sauka.\n    * Idan akwai ƙasa da maki goma a cikin jerin, duk maki za a dawo da su.\n    * Misali:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "hi": "/**\n    * दिए गए स्कोर की सूची से शीर्ष दस उच्चतम स्कोर लौटाता है, जो अवरोही क्रम में क्रमबद्ध होते हैं।\n    * यदि सूची में दस से कम स्कोर हैं, तो सभी स्कोर लौटाए जाते हैं।\n    * उदाहरण:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "hu": "/**\n    * Visszaadja a legmagasabb tíz pontszámot egy adott pontszámok listájából, csökkenő sorrendben rendezve.\n    * Ha kevesebb mint tíz pontszám van a listában, az összes pontszám visszaadásra kerül.\n    * Példa:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> "
    },
    "prompt_bertscore": {
      "sq": "0.9932443821106224",
      "hy": "0.9915218594462879",
      "bn": "0.9981225456384583",
      "bg": "0.9932443821106224",
      "zh": "0.9922136890634324",
      "fr": "0.9932443821106224",
      "de": "0.9935300125985506",
      "ha": "0.9914392292077774",
      "hi": "0.9981225456384583",
      "hu": "0.9965432354788498"
    },
    "canonical_solution": "{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}",
    "instruction": {
      "en": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত স্বাভাবিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Kotlin cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun topTenScores(scores: List<Double>): List<Double>\n{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.9244352427732785",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9191087704754469",
      "hi": "0.8761702451159921",
      "hu": "0.9438932735298372"
    },
    "level": "",
    "test": "fun main(){\n    check(topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5)) == listOf(22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5))\n    check(topTenScores(listOf(5.0, 3.0, 4.0)) == listOf(5.0, 4.0, 3.0))\n    check(topTenScores(listOf(8.0, 7.5, 9.0, 10.0)) == listOf(10.0, 9.0, 8.0, 7.5))\n    check(topTenScores(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) == listOf(12.0, 11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0))\n    check(topTenScores(listOf(32.0, 31.5, 33.0, 30.0)) == listOf(33.0, 32.0, 31.5, 30.0))\n}\n\nmain()",
    "entry_point": "topTenScores",
    "signature": "fun topTenScores(scores: List<Double>): List<Double>",
    "docstring": {
      "en": "Returns the top ten highest scores from a given list of scores, sorted in descending order.\nIf there are fewer than ten scores in the list, all scores are returned.\nExample:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "sq": "Kthen dhjetë rezultatet më të larta nga një listë e dhënë e rezultateve, të renditura në rend zbritës. Nëse ka më pak se dhjetë rezultate në listë, kthehen të gjitha rezultatet.\nShembull:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "hy": "Վերադարձնում է տրված միավորների ցանկից տասը ամենաբարձր միավորները՝ դասավորված նվազման կարգով: Եթե ցանկում տասից պակաս միավորներ կան, վերադարձվում են բոլոր միավորները:\nՕրինակ:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "bn": "দেওয়া স্কোরের তালিকা থেকে শীর্ষ দশটি সর্বোচ্চ স্কোর ফেরত দেয়, অবতরণী ক্রমে সাজানো।\nযদি তালিকায় দশটির কম স্কোর থাকে, তবে সমস্ত স্কোর ফেরত দেওয়া হয়।\nউদাহরণ:  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]  ",
      "bg": "Връща десетте най-високи резултата от даден списък с резултати, сортирани в низходящ ред. Ако в списъка има по-малко от десет резултата, се връщат всички резултати.  \nПример:  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]",
      "zh": "返回给定分数列表中排名前十的最高分，按降序排列。\n如果列表中的分数少于十个，则返回所有分数。\n示例：\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "fr": "Retourne les dix scores les plus élevés d'une liste donnée de scores, triés par ordre décroissant.  \nS'il y a moins de dix scores dans la liste, tous les scores sont retournés.  \nExemple:  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]",
      "de": "Gibt die zehn höchsten Punktzahlen aus einer gegebenen Liste von Punktzahlen zurück, sortiert in absteigender Reihenfolge.\nWenn es weniger als zehn Punktzahlen in der Liste gibt, werden alle Punktzahlen zurückgegeben.\nBeispiel:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "ha": "Yana mayar da maki goma mafi girma daga jerin maki da aka bayar, an jera su a cikin tsari mai saukowa. Idan akwai maki kasa da goma a cikin jerin, duk maki za a mayar da su.\n\nMisali:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "hi": "दिए गए अंकों की सूची से शीर्ष दस उच्चतम स्कोर लौटाता है, जो अवरोही क्रम में क्रमबद्ध होते हैं। यदि सूची में दस से कम स्कोर हैं, तो सभी स्कोर लौटाए जाते हैं।  \nउदाहरण:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "hu": "Visszaadja a megadott pontszámok listájából a tíz legmagasabb pontszámot, csökkenő sorrendben rendezve.\nHa a listában kevesebb mint tíz pontszám van, az összes pontszám visszaadásra kerül.\nPélda:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]"
    },
    "docstring_bertscore": {
      "sq": "0.9929905324836599",
      "hy": "0.9908920025080262",
      "bn": "1",
      "bg": "0.9929905324836599",
      "zh": "0.9925305045211831",
      "fr": "0.9937931978534218",
      "de": "0.9958053236133052",
      "ha": "0.9917065857006503",
      "hi": "0.9972930651672566",
      "hu": "0.987229854172886"
    }
  },
  {
    "task_id": "Kotlin/10",
    "prompt": {
      "en": "/**\n * Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\n * If multiple elements have the same absolute value, the one with the smallest row index is returned,\n * and if there is still a tie, the one with the smallest column index is chosen.\n *\n * Example:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Absolute value 12 at row 2, column 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "sq": "/**\n * Gjen elementin me vlerën më të madhe absolute në një matricë 3x4 dhe kthen vlerën e tij absolute dhe indeksat.\n * Nëse disa elementë kanë të njëjtën vlerë absolute, kthehet ai me indeksin më të vogël të rreshtit,\n * dhe nëse ka ende barazim, zgjidhet ai me indeksin më të vogël të kolonës.\n *\n * Shembull:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Vlera absolute 12 në rreshtin 2, kolonën 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Vlera absolute 4 në rreshtin 0, kolonën 0 (para se të ndodhë përsëri)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "hy": "/**\n * Գտնում է 3x4 մատրիցայի ամենամեծ բացարձակ արժեք ունեցող տարրը և վերադարձնում է դրա բացարձակ արժեքը և ինդեքսները:\n * Եթե մի քանի տարրեր ունեն նույն բացարձակ արժեքը, վերադարձվում է այն, որը ունի ամենափոքր տողի ինդեքսը,\n * և եթե դեռ կա հավասարություն, ընտրվում է այն, որը ունի ամենափոքր սյունակի ինդեքսը:\n *\n * Օրինակ:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Բացարձակ արժեք 12 տող 2, սյունակ 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Բացարձակ արժեք 4 տող 0, սյունակ 0 (առաջին հանդիպում)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "bn": "/**\n * 3x4 ম্যাট্রিক্সে সর্বাধিক মানের উপাদান খুঁজে বের করে এবং এর মান এবং সূচকগুলি ফেরত দেয়।\n * যদি একাধিক উপাদানের একই মান থাকে, তবে যেটির সারির সূচক সবচেয়ে ছোট, সেটি ফেরত দেওয়া হয়,\n * এবং যদি এখনও সমতা থাকে, তবে যেটির কলামের সূচক সবচেয়ে ছোট, সেটি বেছে নেওয়া হয়।\n *\n * উদাহরণ:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // সারি 2, কলাম 3 এ মান 12\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // সারি 0, কলাম 0 এ মান 4 (প্রথম উপস্থিতি)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "bg": "/**\n * Намира елемента с най-голяма абсолютна стойност в 3x4 матрица и връща неговата абсолютна стойност и индекси.\n * Ако няколко елемента имат една и съща абсолютна стойност, се връща този с най-малък индекс на реда,\n * и ако все още има равенство, се избира този с най-малък индекс на колоната.\n *\n * Пример:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Абсолютна стойност 12 на ред 2, колона 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Абсолютна стойност 4 на ред 0, колона 0 (първа поява)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "zh": "/**\n * 在一个3x4矩阵中查找绝对值最大的元素，并返回其绝对值和索引。\n * 如果多个元素具有相同的绝对值，则返回行索引最小的元素，\n * 如果仍然存在平局，则选择列索引最小的元素。\n *\n * 示例:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // 绝对值12在第2行，第3列\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // 绝对值4在第0行，第0列（首次出现）\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "fr": "/**\n * Trouve l'élément avec la plus grande valeur absolue dans une matrice 3x4 et renvoie sa valeur absolue et ses indices.\n * Si plusieurs éléments ont la même valeur absolue, celui avec le plus petit indice de ligne est retourné,\n * et s'il y a encore une égalité, celui avec le plus petit indice de colonne est choisi.\n *\n * Exemple:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Valeur absolue 12 à la ligne 2, colonne 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Valeur absolue 4 à la ligne 0, colonne 0 (première occurrence)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "de": "/**\n * Findet das Element mit dem größten Absolutwert in einer 3x4-Matrix und gibt dessen Absolutwert und Indizes zurück.\n * Wenn mehrere Elemente den gleichen Absolutwert haben, wird das Element mit dem kleinsten Zeilenindex zurückgegeben,\n * und wenn es immer noch einen Gleichstand gibt, wird das Element mit dem kleinsten Spaltenindex gewählt.\n *\n * Beispiel:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Absolutwert 12 in Zeile 2, Spalte 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Absolutwert 4 in Zeile 0, Spalte 0 (erstes Vorkommen)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "ha": "/**\n * Nemi abin da ke da mafi girman ƙimar duka a cikin matrix 3x4 kuma ya dawo da ƙimar duka da alamun sa.\n * Idan abubuwa da yawa suna da irin wannan ƙimar duka, wanda ke da ƙaramin alamar layi za a dawo da shi,\n * kuma idan har yanzu akwai daidaito, wanda ke da ƙaramin alamar ginshiƙi za a zaɓi.\n *\n * Misali:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Ƙimar duka 12 a layi na 2, ginshiƙi na 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Ƙimar duka 4 a layi na 0, ginshiƙi na 0 (farin bayyana)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "hi": "/**\n * 3x4 मैट्रिक्स में सबसे बड़े परिमाण वाले तत्व को खोजता है और उसके परिमाण और सूचकांक को लौटाता है।\n * यदि कई तत्वों का परिमाण समान है, तो सबसे छोटे पंक्ति सूचकांक वाला तत्व लौटाया जाता है,\n * और यदि अभी भी टाई है, तो सबसे छोटे स्तंभ सूचकांक वाला तत्व चुना जाता है।\n *\n * उदाहरण:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // पंक्ति 2, स्तंभ 3 पर परिमाण 12\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // पंक्ति 0, स्तंभ 0 पर परिमाण 4 (पहला प्रकट होने वाला)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "hu": "/**\n * Megkeresi a 3x4-es mátrixban a legnagyobb abszolút értékű elemet, és visszaadja annak abszolút értékét és indexeit.\n * Ha több elemnek is ugyanaz az abszolút értéke, akkor az kerül visszaadásra, amelyiknek a sorindexe a legkisebb,\n * és ha még mindig döntetlen van, akkor az, amelyiknek az oszlopindexe a legkisebb.\n *\n * Példa:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Abszolút érték 12 a 2. sorban, a 3. oszlopban\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Abszolút érték 4 a 0. sorban, a 0. oszlopban (első előfordulás)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "sq": "0.9898861382584656",
      "hy": "0.9912930372473356",
      "bn": "0.9712454715198654",
      "bg": "1",
      "zh": "0.9784160282752249",
      "fr": "1",
      "de": "0.995712960486124",
      "ha": "0.9768188413813234",
      "hi": "0.9598728890537129",
      "hu": "0.9955083711936581"
    },
    "canonical_solution": "{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}",
    "instruction": {
      "en": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nBayar da takaitaccen bayanin yare na halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>\n{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.8927018544687637",
      "bn": "0.8777010894626279",
      "bg": "0.8999760962830234",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(1, -2, 3, -4), arrayOf(0, 6, -7, 8), arrayOf(9, -10, -11, -12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(4, 4, -3, -2), arrayOf(-1, 0, 4, 4), arrayOf(-2, -3, 4, -4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0))) == Triple(0, 0, 0))\n}\nmain()",
    "entry_point": "findMaxAbsElement",
    "signature": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\nIf multiple elements have the same absolute value, the one with the smallest row index is returned,\nand if there is still a tie, the one with the smallest column index is chosen.\n\nExample:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolute value 12 at row 2, column 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)",
      "sq": "Gjen elementin me vlerën absolute më të madhe në një matricë 3x4 dhe kthen vlerën e tij absolute dhe indeksat.\nNëse disa elemente kanë të njëjtën vlerë absolute, kthehet ai me indeksin më të vogël të rreshtit,\ndhe nëse ende ka barazim, zgjidhet ai me indeksin më të vogël të kolonës.\n\nShembull:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Vlera absolute 12 në rreshtin 2, kolona 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Vlera absolute 4 në rreshtin 0, kolona 0 (para shfaqjes)",
      "hy": "Գտնում է 3x4 մատրիցի ամենամեծ բացարձակ արժեքով տարրը և վերադարձնում դրա բացարձակ արժեքը և ինդեքսները:\nԵթե մի քանի տարրեր ունեն նույն բացարձակ արժեքը, վերադարձվում է այն, որը ունի ամենափոքր տողի ինդեքսը,\nև եթե դեռ կա հավասարություն, ընտրվում է այն, որը ունի ամենափոքր սյունակի ինդեքսը:\n\nՕրինակ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Բացարձակ արժեքը 12 տող 2, սյունակ 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Բացարձակ արժեքը 4 տող 0, սյունակ 0 (առաջին հանդիպում)",
      "bn": "3x4 ম্যাট্রিক্সে সর্বাধিক মানের উপাদান খুঁজে বের করে এবং এর মান এবং সূচকগুলি ফেরত দেয়। \nযদি একাধিক উপাদানের একই মান থাকে, তবে যেটির সারির সূচক সবচেয়ে ছোট সেটি ফেরত দেওয়া হয়, \nএবং যদি এখনও সমতা থাকে, তবে যেটির কলামের সূচক সবচেয়ে ছোট সেটি বেছে নেওয়া হয়।\n\nউদাহরণ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // সারি 2, কলাম 3 এ মান 12\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // সারি 0, কলাম 0 এ মান 4 (প্রথম উপস্থিতি)",
      "bg": "Намира елемента с най-голяма абсолютна стойност в 3x4 матрица и връща неговата абсолютна стойност и индекси. Ако няколко елемента имат една и съща абсолютна стойност, се връща този с най-малък индекс на реда, а ако има все още равенство, се избира този с най-малък индекс на колоната.\n\nПример:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Абсолютна стойност 12 на ред 2, колона 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Абсолютна стойност 4 на ред 0, колона 0 (първо срещане)",
      "zh": "查找3x4矩阵中绝对值最大的元素，并返回其绝对值及其索引。\n如果多个元素具有相同的绝对值，则返回行索引最小的那个，\n如果仍然有平局，则选择列索引最小的那个。\n\n示例：\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // 绝对值12位于第2行，第3列\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // 绝对值4位于第0行，第0列（首次出现）",
      "fr": "Trouve l'élément avec la plus grande valeur absolue dans une matrice 3x4 et renvoie sa valeur absolue et ses indices.\nSi plusieurs éléments ont la même valeur absolue, celui avec le plus petit indice de ligne est renvoyé,\net s'il y a encore une égalité, celui avec le plus petit indice de colonne est choisi.\n\nExemple :\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Valeur absolue 12 à la ligne 2, colonne 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Valeur absolue 4 à la ligne 0, colonne 0 (première occurrence)",
      "de": "Findet das Element mit dem größten absoluten Wert in einer 3x4-Matrix und gibt dessen absoluten Wert und Indizes zurück. Wenn mehrere Elemente denselben absoluten Wert haben, wird das Element mit dem kleinsten Zeilenindex zurückgegeben, und wenn es immer noch ein Unentschieden gibt, wird das Element mit dem kleinsten Spaltenindex ausgewählt.\n\nBeispiel:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absoluter Wert 12 in Zeile 2, Spalte 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absoluter Wert 4 in Zeile 0, Spalte 0 (erstes Vorkommen)",
      "ha": "Yana nemo abin da ke da mafi girman ƙimar duka a cikin matrix 3x4 kuma yana mayar da ƙimar duka da alamomin sa.\nIdan abubuwa da yawa suna da ƙimar duka iri ɗaya, wanda ke da ƙaramin index na layi za a mayar da shi,\nkuma idan har yanzu akwai daidaito, wanda ke da ƙaramin index na ginshiƙi za a zaɓa.\n\nMisali:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Ƙimar duka 12 a layi na 2, ginshiƙi na 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Ƙimar duka 4 a layi na 0, ginshiƙi na 0 (farin farko)",
      "hi": "3x4 मैट्रिक्स में सबसे बड़े परिमाण मान वाले तत्व को खोजता है और उसके परिमाण मान और सूचकांक लौटाता है। यदि कई तत्वों का परिमाण मान समान है, तो सबसे छोटे पंक्ति सूचकांक वाला तत्व लौटाया जाता है, और यदि अभी भी टाई है, तो सबसे छोटे स्तंभ सूचकांक वाला तत्व चुना जाता है।\n\nउदाहरण:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // पंक्ति 2, स्तंभ 3 पर परिमाण मान 12\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // पंक्ति 0, स्तंभ 0 पर परिमाण मान 4 (पहली घटना)",
      "hu": "Megkeresi a legnagyobb abszolút értékű elemet egy 3x4-es mátrixban, és visszaadja annak abszolút értékét és indexeit. Ha több elemnek azonos az abszolút értéke, akkor azt adja vissza, amelyiknek a sorindexe a legkisebb, és ha még mindig döntetlen van, akkor azt, amelyiknek az oszlopindexe a legkisebb.\n\nPélda:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Abszolút érték 12 a 2. sorban, a 3. oszlopban\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Abszolút érték 4 a 0. sorban, a 0. oszlopban (első előfordulás)"
    },
    "docstring_bertscore": {
      "sq": "0.9773493831290676",
      "hy": "0.9904653444495632",
      "bn": "0.9561503570827381",
      "bg": "0.9995064035031282",
      "zh": "0.9768764441918235",
      "fr": "0.9939143623858531",
      "de": "0.9935864236267645",
      "ha": "0.9815792170932055",
      "hi": "0.9557121784621752",
      "hu": "0.9651330188042788"
    }
  },
  {
    "task_id": "Kotlin/11",
    "prompt": {
      "en": "/**\n    * Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\n    * The interest is compounded monthly based on the total amount in the account at the end of each month.\n    Example:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "sq": "/**\n    * Llogarit kursimet totale të akumuluara gjatë një periudhe muajsh me depozita mujore dhe një normë interesi fikse.\n    * Interesi përllogaritet çdo muaj bazuar në shumën totale në llogari në fund të çdo muaji.\n    Shembull:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depozitë mujore, 1% interes mujor, gjatë 6 muajve\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depozitë mujore, 2% interes mujor, gjatë 12 muajve\n        6840.17\n**/",
      "hy": "/**\n    * Հաշվում է ընդհանուր խնայողությունները, որոնք կուտակվել են ամիսների ընթացքում ամսական ավանդներով և հաստատուն տոկոսադրույքով:\n    * Տոկոսը հաշվարկվում է ամսական՝ հաշվի վերջնական գումարի հիման վրա յուրաքանչյուր ամսվա վերջում:\n    Օրինակ:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ամսական ավանդ, 1% ամսական տոկոս, 6 ամսվա ընթացքում\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ամսական ավանդ, 2% ամսական տոկոս, 12 ամսվա ընթացքում\n        6840.17\n**/",
      "bn": "/**\n    * মাসিক জমা এবং একটি নির্দিষ্ট সুদের হারের সাথে মাসগুলির একটি সময়কালে সঞ্চিত মোট সঞ্চয় গণনা করে।\n    * প্রতিটি মাসের শেষে অ্যাকাউন্টে থাকা মোট পরিমাণের ভিত্তিতে সুদ মাসিকভাবে চক্রবৃদ্ধি হয়।\n    উদাহরণ:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 মাসিক জমা, 1% মাসিক সুদ, 6 মাসের জন্য\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 মাসিক জমা, 2% মাসিক সুদ, 12 মাসের জন্য\n        6840.17\n**/",
      "bg": "/**\n    * Изчислява общите спестявания, натрупани за период от месеци с месечни вноски и фиксиран лихвен процент.\n    * Лихвата се начислява месечно на база на общата сума в сметката в края на всеки месец.\n    Пример:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 месечна вноска, 1% месечна лихва, за 6 месеца\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 месечна вноска, 2% месечна лихва, за 12 месеца\n        6840.17\n**/ \n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "zh": "/**\n    * 计算在一段月份内通过每月存款和固定利率累积的总储蓄。\n    * 利息是基于每月底账户中的总金额按月复利计算的。\n    示例:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 每月存款1000，月利率1%，持续6个月\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 每月存款500，月利率2%，持续12个月\n        6840.17\n**/",
      "fr": "/**\n    * Calcule l'épargne totale accumulée sur une période de mois avec des dépôts mensuels et un taux d'intérêt fixe.\n    * L'intérêt est composé mensuellement en fonction du montant total sur le compte à la fin de chaque mois.\n    Exemple:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // dépôt mensuel de 1000, intérêt mensuel de 1%, sur 6 mois\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // dépôt mensuel de 500, intérêt mensuel de 2%, sur 12 mois\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "de": "/**\n    * Berechnet die gesamten Ersparnisse, die über einen Zeitraum von Monaten mit monatlichen Einzahlungen und einem festen Zinssatz angesammelt werden.\n    * Die Zinsen werden monatlich auf der Grundlage des Gesamtbetrags auf dem Konto am Ende jedes Monats aufgezinst.\n    Beispiel:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monatliche Einzahlung, 1% monatlicher Zins, über 6 Monate\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monatliche Einzahlung, 2% monatlicher Zins, über 12 Monate\n        6840.17\n**/",
      "ha": "/**\n    * Lissafa jimillar ajiyar da aka tara a tsawon watanni tare da ajiya na wata-wata da kuma kudi mai tsayayyen riba.\n    * Ana tara ribar ne a kowane wata bisa ga jimillar kudin da ke cikin asusun a karshen kowane wata.\n    Misali:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ajiya na wata-wata, 1% riba na wata-wata, a tsawon watanni 6\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ajiya na wata-wata, 2% riba na wata-wata, a tsawon watanni 12\n        6840.17\n**/",
      "hi": "/**\n    * मासिक जमा और एक निश्चित ब्याज दर के साथ महीनों की अवधि में संचित कुल बचत की गणना करता है।\n    * ब्याज प्रत्येक महीने के अंत में खाते में कुल राशि के आधार पर मासिक रूप से संयोजित होता है।\n    उदाहरण:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 मासिक जमा, 1% मासिक ब्याज, 6 महीनों में\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 मासिक जमा, 2% मासिक ब्याज, 12 महीनों में\n        6840.17\n**/",
      "hu": "/**\n    * Kiszámítja a teljes megtakarítást, amely hónapok alatt halmozódik fel havi befizetésekkel és fix kamatlábbal.\n    * A kamat havonta tőkésítődik a hónap végén a számlán lévő teljes összeg alapján.\n    Példa:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 havi befizetés, 1% havi kamat, 6 hónap alatt\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 havi befizetés, 2% havi kamat, 12 hónap alatt\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double "
    },
    "prompt_bertscore": {
      "sq": "0.9412743319558922",
      "hy": "0.9207434985113641",
      "bn": "0.9322342660542323",
      "bg": "0.974533598847517",
      "zh": "0.9186523178598288",
      "fr": "0.9754794767220051",
      "de": "0.951020131601369",
      "ha": "0.9361901887229233",
      "hi": "0.9448441171638512",
      "hu": "0.9782309047601004"
    },
    "canonical_solution": "{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}",
    "instruction": {
      "en": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nՏվեք հակիրճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nकृपया निम्नलिखित Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double\n{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.9141424150584316",
      "bn": "0.8868496075523329",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8742320098578537",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main(){\n    check(calculateSavingsInterest(1000.0, 0.01, 6) == 6213.54)\n    check(calculateSavingsInterest(500.0, 0.02, 12) == 6840.17)\n    check(calculateSavingsInterest(2000.0, 0.005, 3) == 6060.2)\n    check(calculateSavingsInterest(750.0, 0.01, 10) == 7925.13)\n}\nmain()",
    "entry_point": "calculateSavingsInterest",
    "signature": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double",
    "docstring": {
      "en": "Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\nThe interest is compounded monthly based on the total amount in the account at the end of each month.\nExample:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n6840.17",
      "sq": "Llogarit kursimet totale të akumuluara gjatë një periudhe muajsh me depozita mujore dhe një normë interesi fikse.\nInteresi përllogaritet çdo muaj bazuar në shumën totale në llogari në fund të çdo muaji.\nShembull:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depozitë mujore, 1% interes mujor, për 6 muaj\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depozitë mujore, 2% interes mujor, për 12 muaj\n6840.17",
      "hy": "Հաշվարկում է ընդհանուր խնայողությունները, որոնք կուտակվել են ամիսների ընթացքում ամսական ավանդներով և ֆիքսված տոկոսադրույքով:\nՏոկոսը հաշվարկվում է ամսական՝ հաշվի վերջնական գումարի հիման վրա:\nՕրինակ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ամսական ավանդ, 1% ամսական տոկոս, 6 ամիսների ընթացքում\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ամսական ավանդ, 2% ամսական տոկոս, 12 ամիսների ընթացքում\n6840.17",
      "bn": "মাসিক আমানত এবং একটি নির্দিষ্ট সুদের হারের সাথে মাসগুলির একটি সময়কালে জমাকৃত মোট সঞ্চয় গণনা করে। \nসুদটি প্রতি মাসের শেষে অ্যাকাউন্টে থাকা মোট পরিমাণের উপর ভিত্তি করে মাসিকভাবে যৌগিক হয়।\nউদাহরণ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 মাসিক আমানত, 1% মাসিক সুদ, 6 মাসের জন্য\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 মাসিক আমানত, 2% মাসিক সুদ, 12 মাসের জন্য\n6840.17",
      "bg": "Изчислява общите спестявания, натрупани за период от месеци с месечни вноски и фиксиран лихвен процент. Лихвата се капитализира месечно въз основа на общата сума в сметката в края на всеки месец. Пример:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 месечна вноска, 1% месечна лихва, за 6 месеца\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 месечна вноска, 2% месечна лихва, за 12 месеца\n6840.17",
      "zh": "计算在一段时间内通过每月存款和固定利率累积的总储蓄。  \n利息是基于每月底账户中的总金额按月复利计算的。  \n示例：  \n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 每月存款1000，月利率1%，持续6个月  \n6213.54  \n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 每月存款500，月利率2%，持续12个月  \n6840.17  ",
      "fr": "Calcule les économies totales accumulées sur une période de mois avec des dépôts mensuels et un taux d'intérêt fixe.  \nL'intérêt est composé mensuellement en fonction du montant total sur le compte à la fin de chaque mois.  \nExemple:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // dépôt mensuel de 1000, intérêt mensuel de 1%, sur 6 mois\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // dépôt mensuel de 500, intérêt mensuel de 2%, sur 12 mois\n6840.17",
      "de": "Berechnet die gesamten Ersparnisse, die über einen Zeitraum von Monaten mit monatlichen Einzahlungen und einem festen Zinssatz angesammelt werden. Die Zinsen werden monatlich auf der Grundlage des Gesamtbetrags auf dem Konto am Ende jedes Monats aufgezinst. Beispiel:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monatliche Einzahlung, 1% monatlicher Zins, über 6 Monate\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monatliche Einzahlung, 2% monatlicher Zins, über 12 Monate\n6840.17",
      "ha": "Yana lissafin jimillar ajiyar da aka tara a tsawon watanni tare da ajiya na wata-wata da kuma kudi mai tsayayyen riba.\nAna tara ribar kowane wata bisa ga jimillar adadin da ke cikin asusun a ƙarshen kowane wata.\nMisali:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ajiya na wata-wata, 1% riba na wata-wata, a tsawon watanni 6\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ajiya na wata-wata, 2% riba na wata-wata, a tsawon watanni 12\n6840.17",
      "hi": "महीनों की अवधि में मासिक जमा और एक निश्चित ब्याज दर के साथ संचित कुल बचत की गणना करता है।  \nब्याज प्रत्येक महीने के अंत में खाते में कुल राशि के आधार पर मासिक रूप से संयोजित होता है।  \nउदाहरण:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 मासिक जमा, 1% मासिक ब्याज, 6 महीनों में\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 मासिक जमा, 2% मासिक ब्याज, 12 महीनों में\n6840.17",
      "hu": "Kiszámítja az összes megtakarítást, amely hónapok alatt halmozódik fel havi befizetésekkel és egy rögzített kamatlábbal.\nA kamat havonta tőkésedik az adott hónap végén a számlán lévő teljes összeg alapján.\nPélda:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 havi befizetés, 1% havi kamat, 6 hónap alatt\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 havi befizetés, 2% havi kamat, 12 hónap alatt\n6840.17"
    },
    "docstring_bertscore": {
      "sq": "0.9785955901396804",
      "hy": "0.9573427352600905",
      "bn": "0.9786853710719082",
      "bg": "0.9787173505632548",
      "zh": "0.9613123634250728",
      "fr": "0.9701752510268494",
      "de": "1",
      "ha": "0.9728021378160359",
      "hi": "0.9903004812333044",
      "hu": "0.9813968744034155"
    }
  },
  {
    "task_id": "Kotlin/12",
    "prompt": {
      "en": "/**\n * Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n * \n * Example:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "sq": "/**\n * Gjeneron dhe kthen një listë të numrave të plotë brenda një intervali të specifikuar (përfshirë të dy skajet) që janë të pjesëtueshëm me një pjesëtues të dhënë.\n * \n * Shembull:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */ \n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "hy": "/**\n * Գեներացնում և վերադարձնում է ամբողջ թվերի ցուցակ նշված միջակայքում (ներառյալ երկու ծայրերը), որոնք բաժանվում են տրված բաժանարարով:\n * \n * Օրինակ:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "bn": "/**\n * একটি নির্দিষ্ট সীমার (উভয় প্রান্ত সহ) মধ্যে যে পূর্ণসংখ্যাগুলি একটি প্রদত্ত বিভাজক দ্বারা বিভাজ্য, সেগুলির একটি তালিকা তৈরি করে এবং ফেরত দেয়।\n * \n * উদাহরণ:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "bg": "/**\n * Генерира и връща списък от цели числа в зададен диапазон (включително и двата края), които са делими на даден делител.\n * \n * Пример:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "zh": "/**\n * 生成并返回一个在指定范围内（包括两端）可被给定除数整除的整数列表。\n * \n * 示例:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "fr": "/**\n * Génère et retourne une liste d'entiers dans une plage spécifiée (inclusivement aux deux extrémités) qui sont divisibles par un diviseur donné.\n * \n * Exemple:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */ \n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "de": "/**\n * Generiert und gibt eine Liste von ganzen Zahlen innerhalb eines angegebenen Bereichs (einschließlich beider Enden) zurück, die durch einen gegebenen Divisor teilbar sind.\n * \n * Beispiel:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "ha": "/**\n * Yana ƙirƙira kuma yana dawo da jerin lambobi masu cikakken lamba a cikin kewayon da aka ƙayyade (ciki har da duka ƙarshen) waɗanda za a iya raba su da wani mai raba.\n * \n * Misali:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "hi": "/**\n * एक निर्दिष्ट सीमा के भीतर (दोनों छोरों सहित) उन पूर्णांकों की सूची उत्पन्न करता है और लौटाता है जो एक दिए गए भाजक से विभाज्य होते हैं।\n * \n * उदाहरण:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "hu": "/**\n * Generál és visszaad egy egész számokból álló listát egy megadott tartományon belül (mindkét végét beleértve), amelyek oszthatók egy adott osztóval.\n * \n * Példa:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9871658951901928",
      "hy": "0.9313167923242323",
      "bn": "0.924956250262733",
      "bg": "0.9305556407041066",
      "zh": "0.9197690178620069",
      "fr": "0.9966332150414586",
      "de": "0.9356681880815635",
      "ha": "0.932346094958755",
      "hi": "0.9460674816806451",
      "hu": "0.9323866155564862"
    },
    "canonical_solution": "{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}",
    "instruction": {
      "en": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nনিম্নলিখিত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\n请用不超过500个字符的中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Kotlin cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nकृपया Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>\n{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9244352427732785",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8859374968426207",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9191087704754469",
      "hi": "0.9022003592898521",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(printDivisibleNumbersInRange(1, 10, 2) == listOf(2, 4, 6, 8, 10))\n    check(printDivisibleNumbersInRange(3, 15, 3) == listOf(3, 6, 9, 12, 15))\n    check(printDivisibleNumbersInRange(5, 20, 5) == listOf(5, 10, 15, 20))\n    check(printDivisibleNumbersInRange(7, 21, 7) == listOf(7, 14, 21))\n    check(printDivisibleNumbersInRange(10, 30, 10) == listOf(10, 20, 30))\n}\n\nmain()",
    "entry_point": "printDivisibleNumbersInRange",
    "signature": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>",
    "docstring": {
      "en": "Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n\nExample:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "sq": "Gjeneron dhe kthen një listë të numrave të plotë brenda një diapazoni të specifikuar (përfshirë të dy skajet) që janë të pjestueshëm me një pjestues të dhënë.\n\nShembull:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hy": "Ստեղծում և վերադարձնում է ամբողջ թվերի ցուցակ որոշված միջակայքում (ներառյալ երկու ծայրերը), որոնք բաժանվում են տրված բաժանարարով:\n\nՕրինակ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "bn": "নির্দিষ্ট একটি পরিসরের মধ্যে (উভয় প্রান্ত সহ) একটি প্রদত্ত বিভাজক দ্বারা বিভাজ্য পূর্ণসংখ্যার একটি তালিকা তৈরি করে এবং ফেরত দেয়।\n\nউদাহরণ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "bg": "Генерира и връща списък от цели числа в рамките на определен диапазон (включително и двата края), които са делими на даден делител.\n\nПример:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "zh": "生成并返回一个在指定范围内（包括两端）的整数列表，这些整数可以被给定的除数整除。\n\n示例：\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "fr": "Génère et renvoie une liste d'entiers dans une plage spécifiée (inclusivement aux deux extrémités) qui sont divisibles par un diviseur donné.\n\nExemple :\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "de": "Erzeugt und gibt eine Liste von ganzen Zahlen innerhalb eines angegebenen Bereichs zurück (einschließlich beider Enden), die durch einen gegebenen Divisor teilbar sind.\n\nBeispiel:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "ha": "Yana haifar da kuma dawowa da jerin lambobin cikakke a cikin kewayon da aka ƙayyade (ciki har da duka ƙarshen) waɗanda za a iya raba su da mai raba da aka bayar.\n\nMisali:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hi": "निर्दिष्ट सीमा के भीतर (दोनों सिरों सहित) उन पूर्णांकों की एक सूची उत्पन्न करता है और लौटाता है जो एक दिए गए भाजक से विभाज्य हैं।\n\nउदाहरण:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hu": "Generál és visszaad egy listát az adott tartományon belüli (mindkét végét beleértve) egész számokról, amelyek oszthatók egy adott osztóval.\n\nPélda:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]"
    },
    "docstring_bertscore": {
      "sq": "0.9877808548498768",
      "hy": "0.9684036666583993",
      "bn": "0.9584479147001687",
      "bg": "0.9877808548498768",
      "zh": "0.9618186722663307",
      "fr": "0.995695679642974",
      "de": "0.9802855374215252",
      "ha": "0.9670158361861085",
      "hi": "0.9848119265445483",
      "hu": "0.9806222159173794"
    }
  },
  {
    "task_id": "Kotlin/13",
    "prompt": {
      "en": "/**\n * Converts a given integer to its octal, decimal, and hexadecimal representations.\n * Args:\n *   number: An integer number to be converted.\n * Returns:\n *   A Triple containing the octal, decimal, and hexadecimal representations of the number.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "sq": "/**\n * Konverton një numër të dhënë të plotë në përfaqësimet e tij oktale, dhjetore dhe heksadecimale.\n * Args:\n *   number: Një numër i plotë që do të konvertohet.\n * Returns:\n *   Një Triple që përmban përfaqësimet oktale, dhjetore dhe heksadecimale të numrit.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "hy": "/**\n * Փոխակերպում է տրված ամբողջ թիվը իր ութական, տասնորդական և տասնվեցական ներկայացումներին:\n * Փոխանցվող արգումենտներ:\n *   number: Ամբողջ թիվ, որը պետք է փոխակերպել:\n * Վերադարձնում է:\n *   Եռյակ, որը պարունակում է թվի ութական, տասնորդական և տասնվեցական ներկայացումները:\n * Օրինակներ:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "bn": "/**\n * একটি প্রদত্ত পূর্ণসংখ্যাকে এর অক্টাল, দশমিক এবং হেক্সাডেসিমাল উপস্থাপনায় রূপান্তর করে।\n * Args:\n *   number: একটি পূর্ণসংখ্যা যা রূপান্তরিত হবে।\n * Returns:\n *   একটি Triple যা সংখ্যার অক্টাল, দশমিক এবং হেক্সাডেসিমাল উপস্থাপনা ধারণ করে।\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "bg": "/**\n * Преобразува дадено цяло число в неговите осмична, десетична и шестнадесетична представяния.\n * Args:\n *   number: Цяло число, което да бъде преобразувано.\n * Returns:\n *   Тройка, съдържаща осмичното, десетичното и шестнадесетичното представяне на числото.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */ \n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "zh": "/**\n * 将给定的整数转换为其八进制、十进制和十六进制表示。\n * 参数:\n *   number: 要转换的整数。\n * 返回:\n *   包含该数字的八进制、十进制和十六进制表示的三元组。\n * 示例:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "fr": "/**\n * Convertit un entier donné en ses représentations octale, décimale et hexadécimale.\n * Args:\n *   number: Un nombre entier à convertir.\n * Returns:\n *   Un Triple contenant les représentations octale, décimale et hexadécimale du nombre.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */ \n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "de": "/**\n * Konvertiert eine gegebene ganze Zahl in ihre oktale, dezimale und hexadezimale Darstellung.\n * Args:\n *   number: Eine ganze Zahl, die konvertiert werden soll.\n * Returns:\n *   Ein Triple, das die oktale, dezimale und hexadezimale Darstellung der Zahl enthält.\n * Beispiele:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "ha": "/**\n * Canza wani lamba zuwa wakilcinsa na octal, decimal, da hexadecimal.\n * Args:\n *   number: Wani lamba da za a canza.\n * Returns:\n *   A Triple wanda ya ƙunshi wakilcin octal, decimal, da hexadecimal na lambar.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "hi": "/**\n * एक दिए गए पूर्णांक को उसके अष्टाधारी, दशमलव, और षोडशाधारी रूपांतरणों में बदलता है।\n * Args:\n *   number: एक पूर्णांक संख्या जिसे रूपांतरित किया जाना है।\n * Returns:\n *   एक Triple जिसमें संख्या के अष्टाधारी, दशमलव, और षोडशाधारी रूपांतरण होते हैं।\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "hu": "/**\n * Egy adott egész szám átalakítása oktális, decimális és hexadecimális reprezentációira.\n * Args:\n *   number: Egy egész szám, amelyet át kell alakítani.\n * Returns:\n *   Egy Triple, amely tartalmazza a szám oktális, decimális és hexadecimális reprezentációit.\n * Példák:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> "
    },
    "prompt_bertscore": {
      "sq": "0.9605968967925851",
      "hy": "0.9453671109571161",
      "bn": "0.9575717560894238",
      "bg": "0.99258175115949",
      "zh": "0.9384301435298537",
      "fr": "0.9905304952145427",
      "de": "0.9553768903789882",
      "ha": "0.9371541419620855",
      "hi": "0.9627430980596671",
      "hu": "0.9921439697996891"
    },
    "canonical_solution": "{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}",
    "instruction": {
      "en": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nকোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（docstring）。",
      "fr": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>\n{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9244352427732785",
      "bn": "0.853350991051561",
      "bg": "0.8382497190726216",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9385961985283988",
      "ha": "0.9669622059832291",
      "hi": "0.8761702451159921",
      "hu": "0.9436378348598263"
    },
    "level": "",
    "test": "fun main() {\n    check(convertNumberToDifferentBases(10) == Triple(\"12\", \"10\", \"A\"))\n    check(convertNumberToDifferentBases(255) == Triple(\"377\", \"255\", \"FF\"))\n    check(convertNumberToDifferentBases(16) == Triple(\"20\", \"16\", \"10\"))\n    check(convertNumberToDifferentBases(1) == Triple(\"1\", \"1\", \"1\"))\n    check(convertNumberToDifferentBases(0) == Triple(\"0\", \"0\", \"0\"))\n    check(convertNumberToDifferentBases(100) == Triple(\"144\", \"100\", \"64\"))\n    check(convertNumberToDifferentBases(500) == Triple(\"764\", \"500\", \"1F4\"))\n}\n\nmain()",
    "entry_point": "convertNumberToDifferentBases",
    "signature": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>",
    "docstring": {
      "en": "Converts a given integer to its octal, decimal, and hexadecimal representations.\nArgs:\nnumber: An integer number to be converted.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "sq": "Konverton një numër të dhënë të plotë në përfaqësimet e tij oktale, dhjetore dhe heksadecimale.\nArgumentet:\nnumber: Një numër i plotë që do të konvertohet.\nKthen:\nNjë Triple që përmban përfaqësimet oktale, dhjetore dhe heksadecimale të numrit.\nShembuj:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hy": "Փոխակերպում է տրված ամբողջ թիվը նրա ութական, տասնորդական և տասնվեցական ներկայացումներին:\nԱրգումենտներ:\nnumber: Ամբողջ թիվ, որը պետք է փոխակերպվի:\nՎերադարձնում է:\nԵռյակ, որը պարունակում է թվի ութական, տասնորդական և տասնվեցական ներկայացումները:\nՕրինակներ:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "bn": "একটি প্রদত্ত পূর্ণসংখ্যাকে এর অক্টাল, দশমিক এবং হেক্সাডেসিমাল উপস্থাপনে রূপান্তর করে।\nআর্গস:\nnumber: একটি পূর্ণসংখ্যা যা রূপান্তরিত হবে।\nরিটার্নস:\nএকটি ট্রিপল যা সংখ্যার অক্টাল, দশমিক এবং হেক্সাডেসিমাল উপস্থাপন ধারণ করে।\nউদাহরণ:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "bg": "Преобразува дадено цяло число в неговите осмична, десетична и шестнадесетична представяния.\nАргументи:\nnumber: Цяло число, което да бъде преобразувано.\nВръща:\nТройка, съдържаща осмичното, десетичното и шестнадесетичното представяне на числото.\nПримери:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "zh": "将给定的整数转换为其八进制、十进制和十六进制表示形式。\n参数：\nnumber: 要转换的整数。\n返回：\n一个包含该数字的八进制、十进制和十六进制表示形式的Triple。\n示例：\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "fr": "Convertit un entier donné en ses représentations octale, décimale et hexadécimale.\nArgs:\nnumber: Un nombre entier à convertir.\nReturns:\nUn Triple contenant les représentations octale, décimale et hexadécimale du nombre.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "de": "Konvertiert eine gegebene ganze Zahl in ihre oktale, dezimale und hexadezimale Darstellung.\nArgs:\nnumber: Eine ganze Zahl, die konvertiert werden soll.\nReturns:\nEin Triple, das die oktale, dezimale und hexadezimale Darstellung der Zahl enthält.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "ha": "Canza wani cikakken lamba zuwa wakilcinsa na octal, decimal, da hexadecimal.\nArgs:\nnumber: Wani lamba mai cikakken adadi da za a canza.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hi": "दिए गए पूर्णांक को इसके अष्टाधारी, दाशमिक, और षोडशाधारी रूपांतरणों में बदलता है।\nआर्ग्स:\nnumber: एक पूर्णांक संख्या जिसे रूपांतरित किया जाना है।\nरिटर्न्स:\nएक Triple जिसमें संख्या के अष्टाधारी, दाशमिक, और षोडशाधारी रूपांतरण शामिल हैं।\nउदाहरण:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hu": "Átalakít egy adott egész számot annak oktális, decimális és hexadecimális reprezentációira.\nArgs:\nnumber: Egy egész szám, amelyet át kell alakítani.\nReturns:\nEgy Triple, amely tartalmazza a szám oktális, decimális és hexadecimális reprezentációit.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")"
    },
    "docstring_bertscore": {
      "sq": "0.9961598788434525",
      "hy": "0.980375119723372",
      "bn": "0.9825092045372108",
      "bg": "0.9839208706552258",
      "zh": "0.9710933206479927",
      "fr": "0.9885650475942025",
      "de": "0.9897639805741291",
      "ha": "0.9934322864510814",
      "hi": "0.9962963379152234",
      "hu": "0.9961598788434525"
    }
  },
  {
    "task_id": "Kotlin/14",
    "prompt": {
      "en": "/**\n * Returns a list of all factors of the given number, excluding the number itself.\n * A factor is a number that divides the given number without leaving a remainder.\n * Examples:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "sq": "/**\n * Kthen një listë të të gjithë faktorëve të numrit të dhënë, përjashtuar vetë numrin.\n * Një faktor është një numër që e ndan numrin e dhënë pa lënë mbetje.\n * Shembuj:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "hy": "/**\n * Վերադարձնում է տրված թվի բոլոր գործակիցների ցուցակը, բացառությամբ հենց այդ թվի։\n * Գործակիցը թիվ է, որը բաժանում է տրված թիվը առանց մնացորդի։\n * Օրինակներ:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int>",
      "bn": "/**\n * প্রদত্ত সংখ্যার সমস্ত গুণনীয়কের একটি তালিকা প্রদান করে, সংখ্যা নিজেকে বাদ দিয়ে।\n * একটি গুণনীয়ক হল এমন একটি সংখ্যা যা প্রদত্ত সংখ্যাকে ভাগ করে অবশিষ্টাংশ ছাড়াই।\n * উদাহরণ:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "bg": "/**\n * Връща списък с всички делители на даденото число, без да включва самото число.\n * Делител е число, което дели даденото число, без да оставя остатък.\n * Примери:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "zh": "/**\n * 返回给定数字的所有因子列表，不包括数字本身。\n * 因子是指能够整除给定数字且不留余数的数字。\n * 例子:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "fr": "/**\n * Renvoie une liste de tous les facteurs du nombre donné, à l'exclusion du nombre lui-même.\n * Un facteur est un nombre qui divise le nombre donné sans laisser de reste.\n * Exemples :\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "de": "/**\n * Gibt eine Liste aller Faktoren der gegebenen Zahl zurück, ohne die Zahl selbst.\n * Ein Faktor ist eine Zahl, die die gegebene Zahl ohne Rest teilt.\n * Beispiele:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "ha": "/**\n * Yana dawo da jerin dukkan abubuwan da ke rarraba lambar da aka bayar, ban da lambar kanta.\n * Abin rarrabawa shi ne lamba da ke rarraba lambar da aka bayar ba tare da barin saura ba.\n * Misalai:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */",
      "hi": "/**\n * दिए गए संख्या के सभी गुणकों की एक सूची लौटाता है, जिसमें संख्या स्वयं शामिल नहीं होती।\n * एक गुणक वह संख्या है जो दिए गए संख्या को बिना शेष के विभाजित करती है।\n * उदाहरण:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */",
      "hu": "/**\n * Visszaadja a megadott szám összes osztójának listáját, a számot magát kivéve.\n * Egy osztó olyan szám, amely maradék nélkül osztja a megadott számot.\n * Példák:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9939989789281739",
      "bn": "0.9867497645419246",
      "bg": "0.9641116613849975",
      "zh": "0.9863451544557567",
      "fr": "1",
      "de": "0.9939989789281739",
      "ha": "0.9142635795908629",
      "hi": "0.9428407311407333",
      "hu": "0.9622491043020333"
    },
    "canonical_solution": "{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}",
    "instruction": {
      "en": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nकोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun listFactors(number: Int): List<Int>\n{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.8872653409398389",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9669622059832291",
      "hi": "0.8905183106900473",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n    check(listFactors(10) == listOf(1, 2, 5))\n    check(listFactors(15) == listOf(1, 3, 5))\n    check(listFactors(7) == listOf(1))\n    check(listFactors(12) == listOf(1, 2, 3, 4, 6))\n    check(listFactors(9) == listOf(1, 3))\n    check(listFactors(17) == listOf(1))\n    check(listFactors(20) == listOf(1, 2, 4, 5, 10))\n}\n\nmain()",
    "entry_point": "listFactors",
    "signature": "fun listFactors(number: Int): List<Int>",
    "docstring": {
      "en": "Returns a list of all factors of the given number, excluding the number itself.\nA factor is a number that divides the given number without leaving a remainder.\nExamples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "sq": "Kthen një listë të të gjithë faktorëve të numrit të dhënë, duke përjashtuar vetë numrin.\nNjë faktor është një numër që ndan numrin e dhënë pa lënë mbetje.\nShembuj:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "hy": "Վերադարձնում է տրված թվի բոլոր գործակիցների ցուցակը՝ բացառությամբ հենց այդ թվի։  \nԳործակիցը այն թիվն է, որը բաժանում է տրված թիվը առանց մնացորդի։  \nՕրինակներ:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]",
      "bn": "প্রদত্ত সংখ্যার সকল গুণনীয়ক (ফ্যাক্টর) এর একটি তালিকা প্রদান করে, যা সংখ্যা নিজে বাদে। \nএকটি গুণনীয়ক হল এমন একটি সংখ্যা যা প্রদত্ত সংখ্যাকে ভাগ করে কোনো অবশিষ্টাংশ রেখে যায় না।\nউদাহরণস্বরূপ:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "bg": "Връща списък с всички делители на даденото число, без самото число.\nДелител е число, което дели даденото число, без да оставя остатък.\nПримери:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "zh": "返回给定数字的所有因子列表，不包括数字本身。\n因子是指能够整除给定数字且不留余数的数字。\n示例：\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "fr": "Renvoie une liste de tous les facteurs du nombre donné, à l'exclusion du nombre lui-même.  \nUn facteur est un nombre qui divise le nombre donné sans laisser de reste.  \nExemples:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]",
      "de": "Gibt eine Liste aller Faktoren der gegebenen Zahl zurück, wobei die Zahl selbst ausgeschlossen ist.\nEin Faktor ist eine Zahl, die die gegebene Zahl ohne Rest teilt.\nBeispiele:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "ha": "Yana dawowa da jerin dukkan abubuwan da ke cikin lambar da aka bayar, banda lambar kanta. \nAbu mai mahimmanci shine lamba da ke raba lambar da aka bayar ba tare da barin saura ba.\nMisalai:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "hi": "दिए गए संख्या के सभी गुणकों की सूची लौटाता है, जिसमें संख्या स्वयं शामिल नहीं होती है। एक गुणक वह संख्या होती है जो दिए गए संख्या को बिना शेष के विभाजित करती है।\n\nउदाहरण:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "hu": "Visszaadja a megadott szám összes osztóját, a számot magát kivéve.\nEgy osztó olyan szám, amely a megadott számot maradék nélkül osztja.\nPéldák:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9856364412562242",
      "bn": "0.9880070948538755",
      "bg": "0.9572845365584473",
      "zh": "0.976577902729128",
      "fr": "1",
      "de": "0.9925130250476519",
      "ha": "1",
      "hi": "0.9886593970251941",
      "hu": "0.9462696874085386"
    }
  },
  {
    "task_id": "Kotlin/15",
    "prompt": {
      "en": "import java.util.LinkedList\n\n/**\n    * Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n    * \n    * The process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\n    * the current number is removed from the sequence. This process continues until only one number remains in the sequence.\n    *\n    * Examples:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "sq": "import java.util.LinkedList\n\n/**\n    * Gjen numrin e fundit të mbetur në një sekuencë prej n numrash, ku numrat eliminohen në një cikël të çdo elementi të tretë.\n    * \n    * Procesi fillon me elementin e parë në një sekuencë nga 1 deri në n, duke numëruar deri në tre. Sa herë që numërimi arrin tre,\n    * numri aktual hiqet nga sekuenca. Ky proces vazhdon derisa të mbetet vetëm një numër në sekuencë.\n    *\n    * Shembuj:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "hy": "import java.util.LinkedList\n\n/**\n    * Գտնում է n թվերից բաղկացած հաջորդականության վերջին մնացած թիվը, որտեղ թվերը վերացվում են յուրաքանչյուր երրորդ տարրի ցիկլով:\n    * \n    * Գործընթացը սկսվում է հաջորդականության առաջին տարրից՝ 1-ից n, հաշվելով մինչև երեք: Ամեն անգամ, երբ հաշիվը հասնում է երեքի,\n    * ընթացիկ թիվը հեռացվում է հաջորդականությունից: Այս գործընթացը շարունակվում է, մինչև հաջորդականության մեջ մնա միայն մեկ թիվ:\n    *\n    * Օրինակներ:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "bn": "import java.util.LinkedList\n\n/**\n    * n সংখ্যার একটি ক্রমে শেষ অবশিষ্ট সংখ্যা খুঁজে বের করে, যেখানে প্রতিটি তৃতীয় উপাদান চক্রাকারে বাদ দেওয়া হয়।\n    * \n    * প্রক্রিয়াটি 1 থেকে n পর্যন্ত ক্রমের প্রথম উপাদান দিয়ে শুরু হয়, তিন পর্যন্ত গণনা করা হয়। প্রতিবার গণনা তিনে পৌঁছালে,\n    * বর্তমান সংখ্যাটি ক্রম থেকে সরিয়ে ফেলা হয়। এই প্রক্রিয়াটি চলতে থাকে যতক্ষণ না ক্রমে শুধুমাত্র একটি সংখ্যা অবশিষ্ট থাকে।\n    *\n    * উদাহরণ:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "bg": "import java.util.LinkedList\n\n/**\n    * Намира последното останало число в последователност от n числа, където числата се елиминират в цикъл на всеки трети елемент.\n    * \n    * Процесът започва с първия елемент в последователност от 1 до n, като се брои до три. Всеки път, когато броят достигне три,\n    * текущото число се премахва от последователността. Този процес продължава, докато в последователността остане само едно число.\n    *\n    * Примери:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "zh": "import java.util.LinkedList\n\n/**\n    * 找到 n 个数字序列中最后剩下的数字，其中数字以每第三个元素的周期被淘汰。\n    * \n    * 该过程从 1 到 n 的序列中的第一个元素开始，数到三。每当计数到三时，\n    * 当前数字就会从序列中移除。这个过程持续进行，直到序列中只剩下一个数字。\n    *\n    * 示例:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "fr": "import java.util.LinkedList\n\n/**\n    * Trouve le dernier nombre restant dans une séquence de n nombres, où les nombres sont éliminés dans un cycle de chaque troisième élément.\n    * \n    * Le processus commence avec le premier élément d'une séquence de 1 à n, en comptant jusqu'à trois. Chaque fois que le compte atteint trois,\n    * le nombre actuel est retiré de la séquence. Ce processus continue jusqu'à ce qu'il ne reste qu'un seul nombre dans la séquence.\n    *\n    * Exemples :\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\nfun findLastRemaining(n: Int): Int ",
      "de": "import java.util.LinkedList\n\n/**\n    * Findet die letzte verbleibende Zahl in einer Sequenz von n Zahlen, wobei Zahlen in einem Zyklus jedes dritten Elements eliminiert werden.\n    * \n    * Der Prozess beginnt mit dem ersten Element in einer Sequenz von 1 bis n und zählt bis drei. Jedes Mal, wenn der Zähler drei erreicht,\n    * wird die aktuelle Zahl aus der Sequenz entfernt. Dieser Prozess wird fortgesetzt, bis nur noch eine Zahl in der Sequenz verbleibt.\n    *\n    * Beispiele:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "ha": "import java.util.LinkedList\n\n/**\n    * Yana nemo lambar karshe da ta rage a cikin jerin lambobi n, inda ake cire lambobi a cikin kewayawa na kowane abu na uku.\n    * \n    * Tsarin yana farawa da abu na farko a cikin jerin daga 1 zuwa n, yana kirgawa har zuwa uku. Duk lokacin da kirga ya kai uku,\n    * ana cire lambar yanzu daga jerin. Wannan tsarin yana ci gaba har sai lamba daya ta rage a cikin jerin.\n    *\n    * Misalai:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "hi": "import java.util.LinkedList\n\n/**\n    * n संख्याओं के अनुक्रम में अंतिम शेष संख्या खोजता है, जहाँ संख्याएँ हर तीसरे तत्व के चक्र में समाप्त की जाती हैं।\n    * \n    * प्रक्रिया 1 से n तक के अनुक्रम में पहले तत्व से शुरू होती है, तीन तक गिनती करते हुए। हर बार जब गिनती तीन तक पहुँचती है,\n    * वर्तमान संख्या को अनुक्रम से हटा दिया जाता है। यह प्रक्रिया तब तक जारी रहती है जब तक अनुक्रम में केवल एक संख्या शेष नहीं रह जाती।\n    *\n    * उदाहरण:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "hu": "import java.util.LinkedList\n\n/**\n    * Megtalálja az utolsó megmaradó számot egy n számot tartalmazó sorozatban, ahol a számokat minden harmadik elem ciklikus eltávolításával távolítják el.\n    * \n    * A folyamat az 1-től n-ig terjedő sorozat első elemével kezdődik, és hármasával számolunk. Minden alkalommal, amikor a számolás eléri a hármat,\n    * az aktuális számot eltávolítjuk a sorozatból. Ez a folyamat addig folytatódik, amíg csak egy szám marad a sorozatban.\n    *\n    * Példák:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9977393876334419",
      "hy": "0.9796880572353723",
      "bn": "0.971134437136867",
      "bg": "0.9891732538209314",
      "zh": "0.9648191828022437",
      "fr": "0.9933198616554156",
      "de": "0.9778803221375738",
      "ha": "0.9584604284141738",
      "hi": "0.993105539474279",
      "hu": "0.9543199781215016"
    },
    "canonical_solution": "{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}",
    "instruction": {
      "en": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "fun findLastRemaining(n: Int): Int\n{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9417669353008588",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.843415698022577",
      "hi": "0.9001058019218392",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n    check(findLastRemaining(5) == 4)\n    check(findLastRemaining(10) == 4)\n    check(findLastRemaining(6) == 1)\n    check(findLastRemaining(7) == 4)\n    check(findLastRemaining(15) == 5)\n    check(findLastRemaining(20) == 20)\n    check(findLastRemaining(1) == 1)\n}\nmain()",
    "entry_point": "findLastRemaining",
    "signature": "fun findLastRemaining(n: Int): Int",
    "docstring": {
      "en": "Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n\nThe process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\nthe current number is removed from the sequence. This process continues until only one number remains in the sequence.\n\nExamples:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "sq": "Gjen numrin e fundit të mbetur në një sekuencë prej n numrash, ku numrat eliminohen në një cikël të çdo elementi të tretë.\n\nProcesi fillon me elementin e parë në një sekuencë nga 1 deri në n, duke numëruar deri në tre. Sa herë që numërimi arrin në tre,\nnumri aktual hiqet nga sekuenca. Ky proces vazhdon derisa të mbetet vetëm një numër në sekuencë.\n\nShembuj:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hy": "Գտնում է n թվերի հաջորդականության մեջ վերջին մնացած թիվը, որտեղ թվերը հեռացվում են յուրաքանչյուր երրորդ տարրի ցիկլով:\n\nԳործընթացը սկսվում է հաջորդականության առաջին տարրից՝ 1-ից n, հաշվելով մինչև երեք: Ամեն անգամ, երբ հաշիվը հասնում է երեքի, ընթացիկ թիվը հեռացվում է հաջորդականությունից: Այս գործընթացը շարունակվում է, մինչև հաջորդականության մեջ մնա միայն մեկ թիվ:\n\nՕրինակներ:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "bn": "শেষে অবশিষ্ট থাকা সংখ্যাটি খুঁজে বের করে একটি n সংখ্যার ক্রমে, যেখানে সংখ্যা গুলি প্রতি তৃতীয় উপাদানের চক্রে বাদ দেওয়া হয়।\n\nপ্রক্রিয়াটি শুরু হয় ১ থেকে n পর্যন্ত একটি ক্রমের প্রথম উপাদান দিয়ে, তিন পর্যন্ত গণনা করে। প্রতিবার যখন গণনা তিনে পৌঁছায়, তখন বর্তমান সংখ্যাটি ক্রম থেকে সরিয়ে দেওয়া হয়। এই প্রক্রিয়াটি চলতে থাকে যতক্ষণ না ক্রমে শুধুমাত্র একটি সংখ্যা অবশিষ্ট থাকে।\n\nউদাহরণসমূহ:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "bg": "Намира последното останало число в последователност от n числа, където числата се елиминират в цикъл на всеки трети елемент.\n\nПроцесът започва с първия елемент в последователност от 1 до n, като се брои до три. Всеки път, когато броят достигне три,\nтекущото число се премахва от последователността. Този процес продължава, докато в последователността остане само едно число.\n\nПримери:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "zh": "在 n 个数字的序列中找到最后剩下的数字，其中数字以每第三个元素的循环方式被淘汰。\n\n该过程从序列中的第一个元素开始，从 1 到 n 计数，每次计数到三时，\n当前数字将从序列中移除。此过程持续进行，直到序列中只剩下一个数字。\n\n示例：\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "fr": "Trouve le dernier numéro restant dans une séquence de n nombres, où les nombres sont éliminés dans un cycle de chaque troisième élément.\n\nLe processus commence avec le premier élément d'une séquence de 1 à n, en comptant jusqu'à trois. Chaque fois que le compte atteint trois, le numéro actuel est retiré de la séquence. Ce processus continue jusqu'à ce qu'il ne reste qu'un seul numéro dans la séquence.\n\nExemples :\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "de": "Findet die letzte verbleibende Zahl in einer Sequenz von n Zahlen, wobei Zahlen in einem Zyklus jedes dritten Elements eliminiert werden.\n\nDer Prozess beginnt mit dem ersten Element in einer Sequenz von 1 bis n und zählt bis drei. Jedes Mal, wenn die Zählung drei erreicht, wird die aktuelle Zahl aus der Sequenz entfernt. Dieser Prozess wird fortgesetzt, bis nur noch eine Zahl in der Sequenz verbleibt.\n\nBeispiele:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "ha": "Nemo lambar ƙarshe da ta rage a cikin jerin lambobi n, inda ake kawar da lambobi a cikin kewayawa na kowane abu na uku.\n\nTsarin yana farawa da abu na farko a cikin jerin daga 1 zuwa n, yana ƙidaya zuwa uku. Duk lokacin da ƙidayar ta kai uku,\nana cire lambar yanzu daga jerin. Wannan tsarin yana ci gaba har sai an bar lamba ɗaya kawai a cikin jerin.\n\nMisalai:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hi": "n संख्याओं के अनुक्रम में अंतिम शेष संख्या खोजता है, जहाँ संख्याएँ हर तीसरे तत्व के चक्र में समाप्त की जाती हैं।\n\nप्रक्रिया 1 से n तक के अनुक्रम में पहले तत्व से शुरू होती है, तीन तक गिनती करते हुए। हर बार जब गिनती तीन तक पहुँचती है,\nवर्तमान संख्या को अनुक्रम से हटा दिया जाता है। यह प्रक्रिया तब तक जारी रहती है जब तक अनुक्रम में केवल एक संख्या शेष नहीं रह जाती।\n\nउदाहरण:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hu": "Megtalálja az utolsó megmaradó számot egy n számot tartalmazó sorozatban, ahol a számokat minden harmadik elem ciklusában távolítják el.\n\nA folyamat az 1-től n-ig terjedő sorozat első elemével kezdődik, és háromig számol. Minden alkalommal, amikor a számolás eléri a hármat, az aktuális számot eltávolítják a sorozatból. Ez a folyamat addig folytatódik, amíg csak egy szám marad a sorozatban.\n\nPéldák:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9910395848811352",
      "hy": "0.9647349635206849",
      "bn": "0.9801258385951732",
      "bg": "0.9876146012209506",
      "zh": "0.9379063552150646",
      "fr": "0.9861699624596838",
      "de": "0.9802533592997976",
      "ha": "0.9423137647398477",
      "hi": "0.9920843806853786",
      "hu": "0.9507849532302237"
    }
  },
  {
    "task_id": "Kotlin/16",
    "prompt": {
      "en": "/**\n    * Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\n    * starting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\n    Examples:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "sq": "/**\n    * Nxjerr një sekuencë specifike 4-bitëshe nga përfaqësimi binar i një numri dhjetor pozitiv të dhënë,\n    * duke filluar nga biti i 4-të deri te biti i 7-të (duke numëruar nga 0 nga e djathta), dhe pastaj kthen vlerën e tij dhjetore.\n    Shembuj:\n    >>> extractAndConvertToDecimal(173) // Binar i 173 është 10101101, bitet 4-7 janë 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binar i 59 është 111011, bitet 4-7 janë 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "hy": "/**\n    * Հանում է հատուկ 4-բիթանոց հաջորդականություն տրված դրական տասնորդական ամբողջ թվի բինար ներկայացումից,\n    * սկսած 4-րդ բիթից մինչև 7-րդ բիթը (հաշվելով 0-ից աջից), և ապա վերադարձնում է դրա տասնորդական արժեքը։\n    Օրինակներ:\n    >>> extractAndConvertToDecimal(173) // 173-ի բինարը 10101101 է, 4-7 բիթերը 1010 են\n        10\n    >>> extractAndConvertToDecimal(59) // 59-ի բինարը 111011 է, 4-7 բիթերը 0011 են\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "bn": "/**\n    * একটি প্রদত্ত ধনাত্মক দশমিক পূর্ণসংখ্যার বাইনারি উপস্থাপন থেকে একটি নির্দিষ্ট 4-বিট সিকোয়েন্স বের করে,\n    * ডান দিক থেকে 0 থেকে গণনা করে 4র্থ বিট থেকে 7ম বিট পর্যন্ত শুরু করে, এবং তারপর এর দশমিক মান ফেরত দেয়।\n    উদাহরণসমূহ:\n    >>> extractAndConvertToDecimal(173) // 173 এর বাইনারি হল 10101101, বিট 4-7 হল 1010\n        10\n    >>> extractAndConvertToDecimal(59) // 59 এর বাইনারি হল 111011, বিট 4-7 হল 0011\n        3\n**/",
      "bg": "/**\n    * Извлича специфична 4-битова последователност от двоичното представяне на дадено положително десетично число,\n    * започвайки от 4-тия бит до 7-мия бит (броейки от 0 отдясно), и след това връща неговата десетична стойност.\n    Примери:\n    >>> extractAndConvertToDecimal(173) // Двоичното на 173 е 10101101, битове 4-7 са 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Двоичното на 59 е 111011, битове 4-7 са 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "zh": "/**\n    * 从给定正十进制整数的二进制表示中提取特定的4位序列，\n    * 从第4位到第7位开始（从右边算起，从0开始计数），然后返回其十进制值。\n    示例:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/",
      "fr": "/**\n    * Extrait une séquence spécifique de 4 bits de la représentation binaire d'un entier décimal positif donné,\n    * en commençant du 4ème bit au 7ème bit (en comptant à partir de 0 depuis la droite), puis retourne sa valeur décimale.\n    Exemples :\n    >>> extractAndConvertToDecimal(173) // Binaire de 173 est 10101101, bits 4-7 sont 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binaire de 59 est 111011, bits 4-7 sont 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "de": "/**\n    * Extrahiert eine spezifische 4-Bit-Sequenz aus der binären Darstellung einer gegebenen positiven Dezimalzahl,\n    * beginnend vom 4. Bit bis zum 7. Bit (von rechts ab 0 gezählt), und gibt dann deren Dezimalwert zurück.\n    Beispiele:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/ \n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "ha": "/**\n    * Yana cire takamaiman jerin bit 4 daga wakilcin binary na wani lamba mai kyau na decimal,\n    * farawa daga bit na 4 zuwa bit na 7 (ana kirga daga 0 daga dama), sannan ya mayar da darajarsa ta decimal.\n    Misalai:\n    >>> extractAndConvertToDecimal(173) // Binary na 173 shi ne 10101101, bits 4-7 sune 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary na 59 shi ne 111011, bits 4-7 sune 0011\n        3\n**/",
      "hi": "/**\n    * एक दिए गए धनात्मक दशमलव पूर्णांक के बाइनरी प्रतिनिधित्व से एक विशेष 4-बिट अनुक्रम निकालता है,\n    * दाएं से 0 से गिनते हुए 4वें बिट से 7वें बिट तक शुरू करके, और फिर इसके दशमलव मान को लौटाता है।\n    उदाहरण:\n    >>> extractAndConvertToDecimal(173) // 173 का बाइनरी 10101101 है, बिट्स 4-7 हैं 1010\n        10\n    >>> extractAndConvertToDecimal(59) // 59 का बाइनरी 111011 है, बिट्स 4-7 हैं 0011\n        3\n**/",
      "hu": "/**\n    * Kivon egy adott 4 bites szekvenciát egy adott pozitív decimális egész szám bináris ábrázolásából,\n    * a 4. bittől a 7. bitig kezdve (jobbról számítva 0-tól), majd visszaadja annak decimális értékét.\n    Példák:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9639978461766644",
      "hy": "0.9660665815951428",
      "bn": "0.9469706540232107",
      "bg": "0.9955465082268168",
      "zh": "0.9526113595838395",
      "fr": "0.9901789194401109",
      "de": "0.9852991668692269",
      "ha": "0.9357150648514877",
      "hi": "0.9404154541882973",
      "hu": "0.9530477505309731"
    },
    "canonical_solution": "{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}",
    "instruction": {
      "en": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nकोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun extractAndConvertToDecimal(number: Int): Int\n{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.9026051680064012",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.853715080539998",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9236762760873443",
      "hi": "0.8905183106900473",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n    check(extractAndConvertToDecimal(217) == 13)  // 173 in binary is 10101101, bits 4-7 are 1101\n    check(extractAndConvertToDecimal(173) == 10)  // 173 in binary is 10101101, bits 4-7 are 1010\n    check(extractAndConvertToDecimal(59) == 3)    // 59 in binary is 111011, bits 4-7 are 0011\n    check(extractAndConvertToDecimal(32) == 2)    // 32 in binary is 100000, bits 4-7 are 0010\n    check(extractAndConvertToDecimal(255) == 15)  // 255 in binary is 11111111, bits 4-7 are 1111\n    check(extractAndConvertToDecimal(1) == 0)     // 1 in binary is 1, bits 4-7 are 0000\n\n}\n\nmain()",
    "entry_point": "extractAndConvertToDecimal",
    "signature": "fun extractAndConvertToDecimal(number: Int): Int",
    "docstring": {
      "en": "Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\nstarting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\nExamples:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "sq": "Ekstrakton një sekuencë specifike prej 4-bitësh nga përfaqësimi binar i një numri të dhënë dhjetor pozitiv, duke filluar nga biti i 4-të deri te biti i 7-të (duke numëruar nga 0 nga e djathta), dhe pastaj kthen vlerën e tij dhjetore.\nShembuj:\n>>> extractAndConvertToDecimal(173) // Binar i 173 është 10101101, bitët 4-7 janë 1010\n10\n>>> extractAndConvertToDecimal(59) // Binar i 59 është 111011, bitët 4-7 janë 0011\n3",
      "hy": "Հանում է տրված դրական տասնորդական ամբողջ թվի բինար ներկայացման հատուկ 4-բիթանոց հաջորդականությունը՝ սկսած 4-րդ բիթից մինչև 7-րդ բիթը (հաշվելով 0-ից աջից), և ապա վերադարձնում է դրա տասնորդական արժեքը։  \nՕրինակներ:  \n>>> extractAndConvertToDecimal(173) // 173-ի բինարը 10101101 է, բիթերը 4-7-ը 1010 են  \n10  \n>>> extractAndConvertToDecimal(59) // 59-ի բինարը 111011 է, բիթերը 4-7-ը 0011 են  \n3",
      "bn": "একটি প্রদত্ত ধনাত্মক দশমিক পূর্ণসংখ্যার বাইনারি উপস্থাপন থেকে একটি নির্দিষ্ট ৪-বিটের ক্রম বের করে, ডান দিক থেকে গণনা করে ৪র্থ বিট থেকে ৭ম বিট পর্যন্ত, এবং তারপর এর দশমিক মান ফেরত দেয়।\nউদাহরণসমূহ:\n>>> extractAndConvertToDecimal(173) // 173 এর বাইনারি হলো 10101101, বিট 4-7 হলো 1010\n10\n>>> extractAndConvertToDecimal(59) // 59 এর বাইনারি হলো 111011, বিট 4-7 হলো 0011\n3",
      "bg": "Извлича специфична 4-битова последователност от двоичното представяне на дадено положително десетично цяло число, започвайки от 4-тия бит до 7-мия бит (броейки от 0 отдясно наляво), и след това връща неговата десетична стойност.\nПримери:\n>>> extractAndConvertToDecimal(173) // Двоичното на 173 е 10101101, битове 4-7 са 1010\n10\n>>> extractAndConvertToDecimal(59) // Двоичното на 59 е 111011, битове 4-7 са 0011\n3",
      "zh": "从给定正十进制整数的二进制表示中提取特定的4位序列，从第4位到第7位（从右边算起，从0开始计数），然后返回其十进制值。\n\n示例：\n>>> extractAndConvertToDecimal(173) // 173的二进制是10101101，第4-7位是1010\n10\n>>> extractAndConvertToDecimal(59) // 59的二进制是111011，第4-7位是0011\n3",
      "fr": "Extrait une séquence spécifique de 4 bits de la représentation binaire d'un entier décimal positif donné, en commençant du 4ème bit au 7ème bit (en comptant à partir de 0 depuis la droite), puis retourne sa valeur décimale.\nExemples:\n>>> extractAndConvertToDecimal(173) // Binaire de 173 est 10101101, les bits 4-7 sont 1010\n10\n>>> extractAndConvertToDecimal(59) // Binaire de 59 est 111011, les bits 4-7 sont 0011\n3",
      "de": "Extrahiert eine spezifische 4-Bit-Sequenz aus der binären Darstellung einer gegebenen positiven Dezimalzahl, beginnend vom 4. Bit bis zum 7. Bit (von rechts aus gezählt), und gibt dann deren Dezimalwert zurück.\nBeispiele:\n>>> extractAndConvertToDecimal(173) // Binär von 173 ist 10101101, Bits 4-7 sind 1010\n10\n>>> extractAndConvertToDecimal(59) // Binär von 59 ist 111011, Bits 4-7 sind 0011\n3",
      "ha": "Yana fitar da takamaiman jerin 4-bit daga wakilcin binary na wani lamba mai kyau na decimal da aka bayar, farawa daga bit na 4 zuwa bit na 7 (ana kirga daga 0 daga dama), sannan yana mayar da ƙimar decimal ɗinsa.\n\nMisalai:\n>>> extractAndConvertToDecimal(173) // Binary na 173 shine 10101101, bits 4-7 sune 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary na 59 shine 111011, bits 4-7 sune 0011\n3",
      "hi": "दिए गए सकारात्मक दशमलव पूर्णांक के बाइनरी प्रतिनिधित्व से एक विशिष्ट 4-बिट अनुक्रम निकालता है, जो दाएँ से 0 से गिनते हुए 4वें बिट से 7वें बिट तक होता है, और फिर उसके दशमलव मान को लौटाता है।\n\nउदाहरण:\n>>> extractAndConvertToDecimal(173) // 173 का बाइनरी 10101101 है, बिट्स 4-7 हैं 1010\n10\n>>> extractAndConvertToDecimal(59) // 59 का बाइनरी 111011 है, बिट्स 4-7 हैं 0011\n3",
      "hu": "Kivon egy adott pozitív decimális egész szám bináris ábrázolásából egy specifikus 4 bites sorozatot, a 4. bittől a 7. bitig (jobbról 0-tól számítva), majd visszaadja annak decimális értékét.\nPéldák:\n>>> extractAndConvertToDecimal(173) // 173 bináris formája 10101101, a 4-7. bitek 1010\n10\n>>> extractAndConvertToDecimal(59) // 59 bináris formája 111011, a 4-7. bitek 0011\n3"
    },
    "docstring_bertscore": {
      "sq": "0.994716431864472",
      "hy": "0.9921179492197736",
      "bn": "0.9595981832367416",
      "bg": "0.9762678407043326",
      "zh": "0.9429779847340284",
      "fr": "0.9822638960166328",
      "de": "0.9833597398288022",
      "ha": "0.9634686948415875",
      "hi": "0.9669949799960998",
      "hu": "0.9736918032926911"
    }
  },
  {
    "task_id": "Kotlin/17",
    "prompt": {
      "en": "/**\n * Performs a right circular shift on a given unsigned 32-bit integer.\n * The function shifts the bits of the input number to the right by a specified number of positions.\n * The bits that are shifted out on the right are reinserted on the left side.\n * \n * Example:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "sq": "/**\n * Kryen një zhvendosje rrethore djathtas në një numër të dhënë të plotë 32-bit pa shenjë.\n * Funksioni zhvendos bitët e numrit të hyrjes djathtas nga një numër i caktuar pozicionesh.\n * Bitët që zhvendosen jashtë në të djathtë ri-futen në anën e majtë.\n * \n * Shembull:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "hy": "/**\n * Կատարում է աջ շրջանաձև տեղաշարժ տրված անստորակետ 32-բիթանոց ամբողջ թվի վրա։\n * Ֆունկցիան տեղափոխում է մուտքային թվի բիթերը աջ որոշակի քանակությամբ դիրքերով։\n * Աջից դուրս եկող բիթերը վերատեղադրվում են ձախ կողմում։\n * \n * Օրինակ:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt",
      "bn": "/**\n * একটি নির্দিষ্ট 32-বিট স্বাক্ষরহীন পূর্ণসংখ্যার উপর ডানদিকে বৃত্তাকার স্থানান্তর সম্পাদন করে।\n * ফাংশনটি ইনপুট সংখ্যার বিটগুলিকে একটি নির্দিষ্ট সংখ্যক অবস্থানের জন্য ডানদিকে স্থানান্তর করে।\n * ডানদিকে স্থানান্তরিত বিটগুলি বাম দিকে পুনরায় প্রবেশ করানো হয়।\n * \n * উদাহরণ:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "bg": "/**\n * Извършва дясно кръгово изместване на дадено беззнаково 32-битово цяло число.\n * Функцията измества битовете на входното число надясно с определен брой позиции.\n * Битовете, които се изместват извън дясната страна, се вмъкват отново от лявата страна.\n * \n * Пример:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt",
      "zh": "/**\n * 对给定的无符号32位整数执行右循环移位。\n * 该函数将输入数字的位向右移动指定数量的位置。\n * 从右侧移出的位将重新插入到左侧。\n * \n * 示例:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "fr": "/**\n * Effectue une rotation circulaire à droite sur un entier non signé de 32 bits donné.\n * La fonction décale les bits du nombre d'entrée vers la droite d'un nombre spécifié de positions.\n * Les bits qui sont décalés à droite sont réinsérés sur le côté gauche.\n * \n * Exemple :\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "de": "/**\n * Führt eine Rechtsrotation bei einer gegebenen 32-Bit-Unsigned-Integer durch.\n * Die Funktion verschiebt die Bits der Eingabezahl um eine angegebene Anzahl von Positionen nach rechts.\n * Die Bits, die rechts herausgeschoben werden, werden auf der linken Seite wieder eingefügt.\n * \n * Beispiel:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "ha": "/**\n * Yana yin juyawar dama mai zagaye akan wani ba-ƙari 32-bit integer.\n * Aikin yana juyar da bits na lambar shigarwa zuwa dama ta wurin adadin matsayi da aka fayyace.\n * Ana sake saka bits da aka juyar daga dama a gefen hagu.\n * \n * Misali:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "hi": "/**\n * एक दिए गए अनसाइन 32-बिट पूर्णांक पर दायां वृत्ताकार शिफ्ट करता है।\n * फ़ंक्शन इनपुट संख्या के बिट्स को निर्दिष्ट संख्या की स्थिति तक दाईं ओर शिफ्ट करता है।\n * जो बिट्स दाईं ओर से बाहर शिफ्ट होते हैं, उन्हें बाईं ओर पुनः डाला जाता है।\n * \n * उदाहरण:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "hu": "/**\n * Végrehajt egy jobbra körkörös eltolást egy adott előjelnélküli 32 bites egész számon.\n * A függvény eltolja a bemeneti szám bitjeit jobbra egy meghatározott pozíciószámmal.\n * A jobbról kicsúszó bitek visszaillesztésre kerülnek a bal oldalon.\n * \n * Példa:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt"
    },
    "prompt_bertscore": {
      "sq": "0.9522474687257836",
      "hy": "0.933171602822336",
      "bn": "0.9260280597987973",
      "bg": "0.9872189295019291",
      "zh": "0.935562715349234",
      "fr": "0.9417488599361845",
      "de": "0.9903400086791303",
      "ha": "0.9215183556277812",
      "hi": "0.9454549055855335",
      "hu": "0.9896483776923668"
    },
    "canonical_solution": "{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}",
    "instruction": {
      "en": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nՏվեք կարճ բնութագրություն (docstring) Kotlin կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, като използвате максимум 500 знака.",
      "zh": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nBa da taƙaitaccen bayanin yare na halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nकृपया निम्नलिखित Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun circularRightShift(num: UInt, shift: Int): UInt\n{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9028212778609671",
      "bn": "0.8822429717553717",
      "bg": "0.8371354026350158",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9477218741242847",
      "hi": "0.8742320098578537",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(circularRightShift(1023u, 20) == 4190208u)\n    check(circularRightShift(15u, 2) == 3221225475u)\n    check(circularRightShift(256u, 8) == 1u)\n    check(circularRightShift(123u, 5) == 3623878659u)\n    check(circularRightShift(4294967295u, 1) == 4294967295u)\n    check(circularRightShift(1024u, 10) == 1u)\n    check(circularRightShift(0u, 15) == 0u)\n}\nmain()",
    "entry_point": "circularRightShift",
    "signature": "fun circularRightShift(num: UInt, shift: Int): UInt",
    "docstring": {
      "en": "Performs a right circular shift on a given unsigned 32-bit integer.\nThe function shifts the bits of the input number to the right by a specified number of positions.\nThe bits that are shifted out on the right are reinserted on the left side.\n\nExample:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "sq": "Kryen një zhvendosje rrethore djathtas në një numër të dhënë të plotë pa shenjë 32-bitësh.\nFunksioni zhvendos bitët e numrit të hyrjes djathtas me një numër të specifikuar pozicionesh.\nBitët që zhvendosen jashtë në të djathtë ri-futen në anën e majtë.\n\nShembull:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hy": "Կատարում է աջ շրջանաձև տեղաշարժ տրված 32-բիթանոց անստորակետ ամբողջ թվի վրա:\nՖունկցիան տեղաշարժում է մուտքային թվի բիթերը աջ՝ որոշակի քանակությամբ դիրքերով:\nԱջից դուրս եկած բիթերը վերատեղադրվում են ձախ կողմում:\n\nՕրինակ:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "bn": "একটি প্রদত্ত ৩২-বিট স্বাক্ষরহীন পূর্ণসংখ্যার উপর ডানদিকে বৃত্তাকার স্থানান্তর সম্পন্ন করে। ফাংশনটি ইনপুট সংখ্যার বিটগুলিকে নির্দিষ্ট সংখ্যক অবস্থানে ডানদিকে স্থানান্তর করে। ডানদিকে স্থানান্তরিত হওয়া বিটগুলি বাম দিকে পুনরায় প্রবেশ করানো হয়।\n\nউদাহরণ:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "bg": "Извършва дясно кръгово изместване на дадено беззнаково 32-битово цяло число. Функцията измества битовете на входното число надясно с определен брой позиции. Битовете, които се изместват извън дясната страна, се вмъкват отново от лявата страна.\n\nПример:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "zh": "执行对给定的无符号32位整数进行右循环移位。  \n该函数将输入数字的位向右移动指定数量的位置。  \n在右侧移出的位会重新插入到左侧。\n\n示例：  \n>>> circularRightShift(1023u, 20)  \n4190208u  \n>>> circularRightShift(15u, 2)  \n3221225475u  \n>>> circularRightShift(256u, 8)  \n1u",
      "fr": "Effectue une rotation circulaire à droite sur un entier non signé de 32 bits donné.\nLa fonction décale les bits du nombre d'entrée vers la droite d'un nombre spécifié de positions.\nLes bits qui sont décalés à droite sont réinsérés sur le côté gauche.\n\nExemple :\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "de": "Führt eine zyklische Rechtsverschiebung auf einer gegebenen 32-Bit-Unsigned-Integer durch.  \nDie Funktion verschiebt die Bits der Eingabezahl um eine angegebene Anzahl von Positionen nach rechts.  \nDie Bits, die auf der rechten Seite herausgeschoben werden, werden auf der linken Seite wieder eingefügt.\n\nBeispiel:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "ha": "Yana aiwatar da juyawa na dama a kan wani ba sa hannu 32-bit integer.\nAikin yana jujjuya bitocin lambar shigarwa zuwa dama ta hanyar adadin matsayi da aka fayyace.\nBitocin da aka jujjuya daga dama za a sake saka su a gefen hagu.\n\nMisali:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hi": "दिए गए बिना चिह्न वाले 32-बिट पूर्णांक पर एक दायां परिपत्र शिफ्ट करता है। \nयह फ़ंक्शन इनपुट संख्या के बिट्स को निर्दिष्ट संख्या के स्थानों तक दाईं ओर शिफ्ट करता है। \nजो बिट्स दाईं ओर से बाहर शिफ्ट होते हैं, उन्हें बाईं ओर पुनः डाला जाता है।\n\nउदाहरण:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hu": "Végrehajt egy jobbra körkörös eltolást egy adott előjelnélküli 32 bites egész számon.\nA függvény eltolja a bemeneti szám bitjeit jobbra a megadott pozíciók számával.\nA jobbról kimozdított bitek visszaillesztésre kerülnek a bal oldalon.\n\nPélda:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u"
    },
    "docstring_bertscore": {
      "sq": "0.9848041799596879",
      "hy": "0.9798072354639933",
      "bn": "0.9522105234749111",
      "bg": "0.9859995375927559",
      "zh": "0.9687145232047188",
      "fr": "0.9789672275825967",
      "de": "0.9835426784097354",
      "ha": "0.9544844440769985",
      "hi": "0.980352674490315",
      "hu": "0.9693994007585272"
    }
  },
  {
    "task_id": "Kotlin/18",
    "prompt": {
      "en": "/**\n    * Determines if a given integer is a perfect number. A perfect number is one whose\n    * sum of all positive divisors (excluding itself) equals the number itself.\n    * \n    * Examples:\n    * - isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "sq": "/**\n    * Përcakton nëse një numër i dhënë është një numër perfekt. Një numër perfekt është ai\n    * shuma e të gjithë ndarësve pozitivë (përveç vetes) është e barabartë me vetë numrin.\n    * \n    * Shembuj:\n    * - isPerfectNumber(6) kthen true sepse 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) kthen true sepse 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) kthen false sepse 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "hy": "/**\n    * Սահմանում է՝ արդյոք տրված ամբողջ թիվը կատարյալ թիվ է։ Կատարյալ թիվը այն է, որի\n    * բոլոր դրական բաժանարարների գումարը (բացառելով ինքն իրեն) հավասար է հենց այդ թվին։\n    * \n    * Օրինակներ:\n    * - isPerfectNumber(6) վերադարձնում է true, որովհետև 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) վերադարձնում է true, որովհետև 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) վերադարձնում է false, որովհետև 1 + 2 + 5 ≠ 10\n**/",
      "bn": "/**\n    * নির্ধারণ করে একটি প্রদত্ত পূর্ণসংখ্যা একটি নিখুঁত সংখ্যা কিনা। একটি নিখুঁত সংখ্যা হল যার\n    * সমস্ত ধনাত্মক ভাজক (নিজেকে বাদ দিয়ে) এর যোগফল সংখ্যাটির সমান।\n    * \n    * উদাহরণ:\n    * - isPerfectNumber(6) সত্য ফেরত দেয় কারণ 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) সত্য ফেরত দেয় কারণ 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) মিথ্যা ফেরত দেয় কারণ 1 + 2 + 5 ≠ 10\n**/",
      "bg": "/**\n    * Определя дали дадено цяло число е перфектно число. Перфектно число е това, чиято\n    * сума на всички положителни делители (без самото него) е равна на самото число.\n    * \n    * Примери:\n    * - isPerfectNumber(6) връща true, защото 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) връща true, защото 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) връща false, защото 1 + 2 + 5 ≠ 10\n**/",
      "zh": "/**\n    * 确定给定的整数是否是一个完全数。完全数是指其所有正因子（不包括自身）的和等于其本身的数。\n    * \n    * 例子:\n    * - isPerfectNumber(6) 返回 true，因为 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) 返回 true，因为 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) 返回 false，因为 1 + 2 + 5 ≠ 10\n**/",
      "fr": "/**\n    * Détermine si un entier donné est un nombre parfait. Un nombre parfait est un nombre dont\n    * la somme de tous les diviseurs positifs (à l'exclusion de lui-même) est égale au nombre lui-même.\n    * \n    * Exemples :\n    * - isPerfectNumber(6) retourne true parce que 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) retourne true parce que 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) retourne false parce que 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "de": "/**\n    * Bestimmt, ob eine gegebene ganze Zahl eine vollkommene Zahl ist. Eine vollkommene Zahl ist eine Zahl, deren\n    * Summe aller positiven Teiler (ohne sich selbst) der Zahl selbst entspricht.\n    * \n    * Beispiele:\n    * - isPerfectNumber(6) gibt true zurück, weil 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) gibt true zurück, weil 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) gibt false zurück, weil 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "ha": "/**\n    * Yana tantance ko wani lamba cikakke ne. Lamba cikakke ita ce wadda\n    * jimillar dukkan masu raba ta masu kyau (banda kanta) ta yi daidai da lambar kanta.\n    * \n    * Misalai:\n    * - isPerfectNumber(6) yana dawowa da gaskiya saboda 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) yana dawowa da gaskiya saboda 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) yana dawowa da ƙarya saboda 1 + 2 + 5 ≠ 10\n**/",
      "hi": "/**\n    * यह निर्धारित करता है कि दिया गया पूर्णांक एक परिपूर्ण संख्या है या नहीं। एक परिपूर्ण संख्या वह होती है \n    * जिसके सभी धनात्मक भाजकों (स्वयं को छोड़कर) का योग संख्या के बराबर होता है।\n    * \n    * उदाहरण:\n    * - isPerfectNumber(6) true लौटाता है क्योंकि 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) true लौटाता है क्योंकि 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) false लौटाता है क्योंकि 1 + 2 + 5 ≠ 10\n**/",
      "hu": "/**\n    * Meghatározza, hogy egy adott egész szám tökéletes szám-e. Egy tökéletes szám olyan szám,\n    * amelynek az összes pozitív osztója (önmagát kivéve) összege megegyezik magával a számmal.\n    * \n    * Példák:\n    * - isPerfectNumber(6) igazat ad vissza, mert 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) igazat ad vissza, mert 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) hamisat ad vissza, mert 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean "
    },
    "prompt_bertscore": {
      "sq": "0.9841421448996986",
      "hy": "0.9513717073758008",
      "bn": "0.9533929701332118",
      "bg": "0.9535842511901483",
      "zh": "0.9360380378510504",
      "fr": "0.982879650197841",
      "de": "0.960317225216088",
      "ha": "0.930740962849612",
      "hi": "0.9371787721293339",
      "hu": "0.9924250317888536"
    },
    "canonical_solution": "{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}",
    "instruction": {
      "en": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nকোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nकोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, अधिकतम 500 वर्णों का उपयोग करते हुए।",
      "hu": "fun isPerfectNumber(number: Int): Boolean\n{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9271358214338289",
      "hy": "0.9417669353008588",
      "bn": "0.8522390581785277",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9250790038382126",
      "hi": "0.9001058019218392",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n    check(isPerfectNumber(1) == false)  // 6 is a perfect number\n    check(isPerfectNumber(6) == true)  // 6 is a perfect number\n    check(isPerfectNumber(28) == true)  // 28 is a perfect number\n    check(isPerfectNumber(10) == false)  // 10 is not a perfect number\n    check(isPerfectNumber(496) == true)  // 496 is a perfect number\n    check(isPerfectNumber(8128) == true)  // 8128 is a perfect number\n    check(isPerfectNumber(15) == false)  // 15 is not a perfect number\n    check(isPerfectNumber(20) == false)  // 20 is not a perfect number\n\n\n}\nmain()",
    "entry_point": "isPerfectNumber",
    "signature": "fun isPerfectNumber(number: Int): Boolean",
    "docstring": {
      "en": "Determines if a given integer is a perfect number. A perfect number is one whose\nsum of all positive divisors (excluding itself) equals the number itself.\n\nExamples:\n- isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10",
      "sq": "Përcakton nëse një numër i dhënë është numër perfekt. Një numër perfekt është ai numër, shuma e të gjithë pjesëtarëve pozitivë (përjashtuar vetveten) e të cilit është e barabartë me numrin vetë.\n\nShembuj:\n- isPerfectNumber(6) kthen true sepse 1 + 2 + 3 = 6\n- isPerfectNumber(28) kthen true sepse 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) kthen false sepse 1 + 2 + 5 ≠ 10",
      "hy": "Սահմանում է, արդյոք տրված ամբողջ թիվը կատարյալ թիվ է: Կատարյալ թիվը այն թիվն է, որի բոլոր դրական բաժանարարների գումարը (բացառությամբ իրեն) հավասար է հենց այդ թվին:\n\nՕրինակներ:\n- isPerfectNumber(6) վերադարձնում է true, որովհետև 1 + 2 + 3 = 6\n- isPerfectNumber(28) վերադարձնում է true, որովհետև 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) վերադարձնում է false, որովհետև 1 + 2 + 5 ≠ 10",
      "bn": "একটি প্রদত্ত পূর্ণসংখ্যা একটি নিখুঁত সংখ্যা কিনা তা নির্ধারণ করে। একটি নিখুঁত সংখ্যা হল এমন একটি সংখ্যা যার সমস্ত ধনাত্মক বিভাজকের (নিজেকে বাদ দিয়ে) যোগফল সংখ্যাটির সমান হয়।\n\nউদাহরণ:\n- isPerfectNumber(6) সত্য ফেরত দেয় কারণ 1 + 2 + 3 = 6\n- isPerfectNumber(28) সত্য ফেরত দেয় কারণ 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) মিথ্যা ফেরত দেয় কারণ 1 + 2 + 5 ≠ 10",
      "bg": "Определя дали дадено цяло число е съвършено число. Съвършено число е такова, чиято сума от всички положителни делители (без самото число) е равна на самото число.\n\nПримери:\n- isPerfectNumber(6) връща true, защото 1 + 2 + 3 = 6\n- isPerfectNumber(28) връща true, защото 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) връща false, защото 1 + 2 + 5 ≠ 10",
      "zh": "确定给定的整数是否为完全数。完全数是指其所有正因子（不包括自身）的和等于其本身的数。\n\n示例：\n- isPerfectNumber(6) 返回 true，因为 1 + 2 + 3 = 6\n- isPerfectNumber(28) 返回 true，因为 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) 返回 false，因为 1 + 2 + 5 ≠ 10",
      "fr": "Détermine si un entier donné est un nombre parfait. Un nombre parfait est un nombre dont la somme de tous les diviseurs positifs (à l'exclusion de lui-même) est égale au nombre lui-même.\n\nExemples :\n- isPerfectNumber(6) retourne vrai parce que 1 + 2 + 3 = 6\n- isPerfectNumber(28) retourne vrai parce que 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) retourne faux parce que 1 + 2 + 5 ≠ 10",
      "de": "Bestimmt, ob eine gegebene ganze Zahl eine vollkommene Zahl ist. Eine vollkommene Zahl ist eine Zahl, deren Summe aller positiven Teiler (ohne sich selbst) der Zahl selbst entspricht.\n\nBeispiele:\n- isPerfectNumber(6) gibt true zurück, weil 1 + 2 + 3 = 6\n- isPerfectNumber(28) gibt true zurück, weil 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) gibt false zurück, weil 1 + 2 + 5 ≠ 10",
      "ha": "Yana tantance ko wani cikakken lamba ne aka bayar. Cikakken lamba ita ce wadda jimillar dukkan masu rarraba masu kyau (ban da kanta) ta yi daidai da lambar kanta.\n\nMisalai:\n- isPerfectNumber(6) yana dawowa gaskiya saboda 1 + 2 + 3 = 6\n- isPerfectNumber(28) yana dawowa gaskiya saboda 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) yana dawowa ƙarya saboda 1 + 2 + 5 ≠ 10",
      "hi": "निर्धारित करता है कि दिया गया पूर्णांक एक परिपूर्ण संख्या है या नहीं। एक परिपूर्ण संख्या वह होती है जिसकी सभी धनात्मक भाजकों (स्वयं को छोड़कर) का योग संख्या के बराबर होता है।\n\nउदाहरण:\n- isPerfectNumber(6) true लौटाता है क्योंकि 1 + 2 + 3 = 6\n- isPerfectNumber(28) true लौटाता है क्योंकि 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) false लौटाता है क्योंकि 1 + 2 + 5 ≠ 10",
      "hu": "Meghatározza, hogy egy adott egész szám tökéletes szám-e. Egy tökéletes szám olyan szám, amelynek az összes pozitív osztója (kivéve önmagát) összege megegyezik magával a számmal.\n\nPéldák:\n- isPerfectNumber(6) visszaadja az igaz értéket, mert 1 + 2 + 3 = 6\n- isPerfectNumber(28) visszaadja az igaz értéket, mert 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) visszaadja a hamis értéket, mert 1 + 2 + 5 ≠ 10"
    },
    "docstring_bertscore": {
      "sq": "0.977630643748613",
      "hy": "0.9770983143274394",
      "bn": "0.9696460996917725",
      "bg": "0.9709312382570683",
      "zh": "0.9590521483192768",
      "fr": "0.9759720800669717",
      "de": "0.9950848912212917",
      "ha": "0.9819673408577477",
      "hi": "0.9701776345914219",
      "hu": "0.9940172529232292"
    }
  },
  {
    "task_id": "Kotlin/19",
    "prompt": {
      "en": "/**\n * Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\n * Example:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */\n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "sq": "/**\n * Koha kaloi shpejt dhe Wang Wang kishte arritur moshën e muajve për vaksinim. Wang Wang erdhi në spital dhe dëshironte t'i jepte vetes një dozë vaksine kundër tërbimit, por nuk mundi t'i rezistonte tundimit të mjekut. Ai ka nevojë për gjithsej 4 injeksione. Ai fillimisht mori tre doza të Miao Sanduo, dhe pastaj vaksinën kundër tërbimit. Një dozë e Miao Sanduo kushton 120 yuan, dhe një dozë e vaksinës kundër tërbimit kushton 100 yuan. Megjithatë, Wang Wang ka vetëm një yuan para dhe nuk mund t'i marrë të gjitha injeksionet menjëherë. Në këtë moment, mjeku tha: \"Si mund ta përfundojmë injeksionin në një herë? Duhet të ketë një interval prej një muaji midis çdo dy injeksioneve...\" Kështu që Wang Wang vendosi të kursejë para ndërsa i bën vetes injeksione (sepse Wang Wang është një meow që i pëlqen injeksionet), Wang Wang Nëse mund të kursejë B yuan çdo muaj, sa vaksinime mund të marrë Wangwang në kohë?\n * Shembull:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "hy": "/**\n * Ժամանակը արագ անցավ, և Վանգ Վանգը հասել էր պատվաստման ամիսների տարիքի: Վանգ Վանգը եկավ հիվանդանոց և ցանկանում էր իրեն կատաղության պատվաստանյութի ներարկում անել, բայց նա չկարողացավ դիմադրել բժշկի գայթակղությանը: Նրան անհրաժեշտ է ընդհանուր առմամբ 4 ներարկում: Նա նախ ստացավ Միաո Սանդուոյի երեք ներարկում, ապա կատաղության պատվաստանյութը: Միաո Սանդուոյի մեկ ներարկումը արժե 120 յուան, իսկ կատաղության պատվաստանյութի մեկ ներարկումը՝ 100 յուան: Սակայն Վանգ Վանգը միայն ունի յուան գումար և չի կարող բոլոր ներարկումները միանգամից անել: Այս պահին բժիշկն ասաց. \"Ինչպե՞ս կարող ենք ներարկումը միանգամից ավարտել: Յուրաքանչյուր երկու ներարկումների միջև պետք է լինի մեկ ամսվա ընդմիջում...\" Այսպիսով, Վանգ Վանգը որոշեց գումար խնայել, մինչ ինքն իրեն ներարկումներ է անում (քանի որ Վանգ Վանգը ներարկումներ սիրող միաո է), Վանգ Վանգ Եթե կարող եմ խնայել B յուան ամեն ամիս, քանի ներարկում կարող է Վանգ Վանգը ժամանակին ստանալ?\n * Օրինակ:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "bn": "/**\n * সময় দ্রুত কেটে গেল, এবং ওয়াং ওয়াং টিকাদানের জন্য মাসের বয়সে পৌঁছেছে। ওয়াং ওয়াং হাসপাতালে এসে নিজেকে জলাতঙ্কের টিকা দিতে চেয়েছিল, কিন্তু সে ডাক্তারের প্রলোভন প্রতিরোধ করতে পারেনি। তার মোট ৪টি ইনজেকশন প্রয়োজন। প্রথমে সে তিনটি মিয়াও সানডু'র শট নেয়, তারপর জলাতঙ্কের টিকা। একটি মিয়াও সানডু'র শটের খরচ ১২০ ইউয়ান, এবং একটি জলাতঙ্কের টিকার খরচ ১০০ ইউয়ান। তবে, ওয়াং ওয়াং-এর কাছে শুধুমাত্র একটি ইউয়ান অর্থ আছে এবং সে একবারে সব শট নিতে পারে না। এই সময়, ডাক্তার বললেন: \"একবারে ইনজেকশন সম্পন্ন করতে কিভাবে পারি? প্রতিটি দুটি ইনজেকশনের মধ্যে এক মাসের ব্যবধান থাকা প্রয়োজন...\" তাই ওয়াং ওয়াং সিদ্ধান্ত নিল টিকা দেওয়ার সময় অর্থ সঞ্চয় করবে (কারণ ওয়াং ওয়াং একটি মিয়াও যে ইনজেকশন ভালোবাসে), ওয়াং ওয়াং যদি প্রতি মাসে বি ইউয়ান সঞ্চয় করতে পারে, তাহলে ওয়াং ওয়াং কতগুলো টিকা সময়মতো পেতে পারে?\n * উদাহরণ:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "bg": "/**\n * Времето мина бързо и Уанг Уанг достигна възрастта за ваксинация в месеци. Уанг Уанг дойде в болницата и искаше да си направи инжекция с ваксина против бяс, но не можа да устои на изкушението на доктора. Той се нуждае от общо 4 инжекции. Първо получи три инжекции Мяо Сандуо, а след това ваксината против бяс. Една инжекция Мяо Сандуо струва 120 юана, а една инжекция ваксина против бяс струва 100 юана. Въпреки това, Уанг Уанг има само юан пари и не може да вземе всички инжекции наведнъж. В този момент докторът каза: \"Как можем да завършим инжекцията наведнъж? Трябва да има месечен интервал между всяка две инжекции...\" Така че Уанг Уанг реши да спестява пари, докато си прави инжекции (защото Уанг Уанг е мяу, който обича инжекции), Уанг Уанг Ако може да спести B юана всеки месец, колко ваксинации може да получи Уанг Уанг навреме?\n * Пример:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "zh": "/**\n * 时间过得很快，汪汪已经到了接种疫苗的月份。汪汪来到医院，想给自己打一针狂犬疫苗，但他无法抵挡医生的诱惑。他总共需要打4针。他先打了三针妙三多，然后是狂犬疫苗。一针妙三多的费用是120元，一针狂犬疫苗的费用是100元。然而，汪汪只有a元钱，不能一次性打完所有的针。这时，医生说：“怎么能一次完成注射呢？每两次注射之间需要间隔一个月……”所以汪汪决定在给自己打针的同时存钱（因为汪汪是一个爱打针的喵），汪汪如果每个月能存B元，汪汪能按时打多少针？\n * 例子:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "fr": "/**\n * Le temps est passé vite, et Wang Wang avait atteint l'âge de mois pour la vaccination. Wang Wang est venu à l'hôpital et voulait se faire une injection de vaccin contre la rage, mais il ne pouvait pas résister à la tentation du médecin. Il a besoin d'un total de 4 injections. Il a d'abord reçu trois injections de Miao Sanduo, puis le vaccin contre la rage. Une injection de Miao Sanduo coûte 120 yuans, et une injection de vaccin contre la rage coûte 100 yuans. Cependant, Wang Wang n'a qu'un yuan d'argent et ne peut pas prendre toutes les injections en une seule fois. À ce moment-là, le médecin a dit : \"Comment pouvons-nous compléter l'injection en une seule fois ? Il doit y avoir un intervalle d'un mois entre chaque deux injections...\" Alors Wang Wang a décidé d'économiser de l'argent tout en se faisant des injections (parce que Wang Wang est un meow qui aime les injections), Wang Wang Si je peux économiser B yuans chaque mois, combien de vaccinations Wangwang peut-il obtenir à temps ?\n * Exemple :\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "de": "/**\n * Die Zeit verging schnell, und Wang Wang hatte das Alter von Monaten für die Impfung erreicht. Wang Wang kam ins Krankenhaus und wollte sich eine Tollwutimpfung geben lassen, konnte jedoch der Versuchung des Arztes nicht widerstehen. Er benötigt insgesamt 4 Injektionen. Zuerst erhielt er drei Spritzen von Miao Sanduo und dann die Tollwutimpfung. Eine Spritze Miao Sanduo kostet 120 Yuan, und eine Spritze Tollwutimpfung kostet 100 Yuan. Wang Wang hat jedoch nur einen Yuan Geld und kann nicht alle Spritzen auf einmal nehmen. In diesem Moment sagte der Arzt: \"Wie können wir die Injektion auf einmal abschließen? Es muss ein Monat Abstand zwischen zwei Injektionen sein...\" Also entschied sich Wang Wang, Geld zu sparen, während er sich Injektionen gibt (weil Wang Wang eine Mieze ist, die Injektionen liebt), Wang Wang, wenn ich jeden Monat B Yuan sparen kann, wie viele Impfungen kann Wang Wang rechtzeitig bekommen?\n * Beispiel:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "ha": "/**\n * Lokaci ya wuce da sauri, kuma Wang Wang ya kai watanni na yin rigakafi. Wang Wang ya zo asibiti kuma yana son yi wa kansa allurar rigakafin cutar hauka, amma bai iya jure wa jarabar likitan ba. Yana buƙatar allurai guda 4 gaba ɗaya. Da farko ya karɓi allurai uku na Miao Sanduo, sannan rigakafin cutar hauka. Allura ɗaya ta Miao Sanduo tana kashe yuan 120, kuma allura ɗaya ta rigakafin cutar hauka tana kashe yuan 100. Duk da haka, Wang Wang yana da yuan kawai kuma ba zai iya ɗaukar duk alluran a lokaci guda ba. A wannan lokacin, likita ya ce: \"Ta yaya za mu kammala allura a lokaci guda? Dole ne a sami tazarar wata guda tsakanin kowanne allurai biyu...\" Don haka Wang Wang ya yanke shawarar adana kuɗi yayin da yake yi wa kansa allurai (saboda Wang Wang meow ne wanda ke son allurai), Wang Wang Idan zan iya adana B yuan a kowane wata, allurai nawa Wangwang zai iya samu a kan lokaci?\n * Misali:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "hi": "/**\n * समय तेजी से बीत गया, और वांग वांग टीकाकरण के लिए महीनों की उम्र तक पहुँच गया। वांग वांग अस्पताल आया और खुद को रेबीज वैक्सीन का एक शॉट देना चाहता था, लेकिन वह डॉक्टर के प्रलोभन का विरोध नहीं कर सका। उसे कुल 4 इंजेक्शन की आवश्यकता है। उसने पहले मियाओ सांडुओ के तीन शॉट प्राप्त किए, और फिर रेबीज वैक्सीन। मियाओ सांडुओ का एक शॉट 120 युआन का होता है, और रेबीज वैक्सीन का एक शॉट 100 युआन का होता है। हालांकि, वांग वांग के पास केवल एक युआन का पैसा है और वह सभी शॉट एक साथ नहीं ले सकता। इस समय, डॉक्टर ने कहा: \"हम एक बार में इंजेक्शन कैसे पूरा कर सकते हैं? हर दो इंजेक्शन के बीच एक महीने का अंतराल होना चाहिए...\" इसलिए वांग वांग ने इंजेक्शन देते समय पैसे बचाने का फैसला किया (क्योंकि वांग वांग एक म्याऊ है जो इंजेक्शन से प्यार करता है), वांग वांग अगर मैं हर महीने बी युआन बचा सकता हूँ, तो वांगवांग कितने समय पर टीके लगवा सकता है?\n * उदाहरण:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "hu": "/**\n * Az idő gyorsan telt, és Wang Wang elérte a hónapok szerinti oltási kort. Wang Wang elment a kórházba, és szeretett volna magának egy veszettség elleni oltást adni, de nem tudott ellenállni az orvos csábításának. Összesen 4 oltásra van szüksége. Először három Miao Sanduo oltást kapott, majd a veszettség elleni oltást. Egy Miao Sanduo oltás 120 jüanba kerül, és egy veszettség elleni oltás 100 jüanba kerül. Azonban Wang Wangnak csak egy jüanja van, és nem tudja egyszerre megkapni az összes oltást. Ekkor az orvos azt mondta: \"Hogyan lehet egyszerre befejezni az oltást? Minden két oltás között egy hónapos szünetnek kell lennie...\" Így Wang Wang úgy döntött, hogy pénzt takarít meg, miközben magának oltásokat ad (mert Wang Wang egy meow, aki szereti az oltásokat), Wang Wang Ha havonta B jüant tud megtakarítani, hány oltást kaphat Wangwang időben?\n * Példa:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9380581088261752",
      "hy": "0.9267991429379747",
      "bn": "0.9116009393330903",
      "bg": "0.9257918882757468",
      "zh": "0.8899998853955462",
      "fr": "0.9298012425169361",
      "de": "0.9217479723482576",
      "ha": "0.9236599883960993",
      "hi": "0.9301760580459488",
      "hu": "0.9013130773777692"
    },
    "canonical_solution": "{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}",
    "instruction": {
      "en": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nনিম্নলিখিত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, като използвате максимум 500 знака.",
      "zh": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int\n{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.9417669353008588",
      "bn": "0.8822429717553717",
      "bg": "0.8371354026350158",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.8785996933064298",
      "hi": "0.8761702451159921",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main(){\n    check(calculateMaxVaccinations(10, 200) == 0)\n    check(calculateMaxVaccinations(150, 100) == 2)\n    check(calculateMaxVaccinations(500, 100) == 4)\n    check(calculateMaxVaccinations(300, 50) == 3)\n    check(calculateMaxVaccinations(0, 200) == 0)\n    check(calculateMaxVaccinations(100, 20) == 0)\n    check(calculateMaxVaccinations(120, 100) == 1)\n    check(calculateMaxVaccinations(400, 0) == 3)\n\n}\nmain()",
    "entry_point": "calculateMaxVaccinations",
    "signature": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int",
    "docstring": {
      "en": "Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\nExample:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "sq": "Koha kaloi shpejt dhe Wang Wang kishte arritur moshën e muajve për vaksinim. Wang Wang shkoi në spital dhe donte t'i jepte vetes një injeksion të vaksinës kundër tërbimit, por nuk mundi t'i rezistonte tundimit të mjekut. Ai ka nevojë për gjithsej 4 injeksione. Ai fillimisht mori tre injeksione të Miao Sanduo, dhe pastaj vaksinën kundër tërbimit. Një injeksion i Miao Sanduo kushton 120 juan, dhe një injeksion i vaksinës kundër tërbimit kushton 100 juan. Megjithatë, Wang Wang ka vetëm një juan para dhe nuk mund t'i marrë të gjitha injeksionet menjëherë. Në këtë kohë, mjeku tha: \"Si mund ta përfundojmë injeksionin në një kohë? Duhet të ketë një interval prej një muaji midis çdo dy injeksioneve...\" Kështu që Wang Wang vendosi të kursejë para ndërsa i bën vetes injeksione (sepse Wang Wang është një meow që i pëlqen injeksionet), Wang Wang Nëse mund të kursej B juan çdo muaj, sa vaksina mund të marrë Wangwang në kohë?\nShembull:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hy": "Ժամանակը արագ անցավ, և Վանգ Վանգը հասել էր պատվաստման ամիսների տարիքին: Վանգ Վանգը եկավ հիվանդանոց և ցանկանում էր իրեն կատաղության դեմ պատվաստել, բայց նա չկարողացավ դիմակայել բժշկի գայթակղությանը: Նա ընդհանուր առմամբ պետք է ստանա 4 ներարկում: Սկզբում նա ստացավ երեք ներարկում Միաո Սանդուո, ապա կատաղության դեմ պատվաստանյութը: Միաո Սանդուոյի մեկ ներարկումը արժե 120 յուան, իսկ կատաղության դեմ պատվաստանյութի մեկ ներարկումը՝ 100 յուան: Սակայն Վանգ Վանգը միայն ունի յուան գումար և չի կարող բոլոր ներարկումները միանգամից ստանալ: Այդ պահին բժիշկն ասաց. «Ինչպե՞ս կարող ենք միանգամից ավարտել ներարկումը: Յուրաքանչյուր երկու ներարկումների միջև պետք է լինի մեկ ամսվա ընդմիջում...» Այսպիսով, Վանգ Վանգը որոշեց գումար խնայել, մինչ ինքն իրեն ներարկումներ էր անում (քանի որ Վանգ Վանգը մի մեաո է, ով սիրում է ներարկումներ), Վանգ Վանգ Եթե ես կարող եմ ամեն ամիս խնայել B յուան, քանի՞ պատվաստում կարող է Վանգվանգը ժամանակին ստանալ:\nՕրինակ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "bn": "সময় দ্রুত কেটে গেল, এবং ওয়াং ওয়াং টিকাদানের জন্য মাসের বয়সে পৌঁছেছিল। ওয়াং ওয়াং হাসপাতালে এসে নিজেকে জলাতঙ্কের টিকা দিতে চেয়েছিল, কিন্তু সে ডাক্তারদের প্রলোভন প্রতিরোধ করতে পারেনি। তার মোট ৪টি ইনজেকশন প্রয়োজন। প্রথমে সে তিনটি মিয়াও সানডু ইনজেকশন নেয়, তারপর জলাতঙ্কের টিকা। একটি মিয়াও সানডু ইনজেকশনের খরচ ১২০ ইউয়ান, এবং একটি জলাতঙ্কের টিকার খরচ ১০০ ইউয়ান। তবে, ওয়াং ওয়াং-এর কাছে কেবল একটি ইউয়ান টাকা আছে এবং সে একবারে সব ইনজেকশন নিতে পারে না। এই সময়, ডাক্তার বললেন: \"কীভাবে আমরা একবারে ইনজেকশন সম্পন্ন করতে পারি? প্রতিটি দুটি ইনজেকশনের মধ্যে এক মাসের ব্যবধান থাকতে হবে...\" তাই ওয়াং ওয়াং ইনজেকশন দেওয়ার সময় টাকা সঞ্চয় করার সিদ্ধান্ত নিল (কারণ ওয়াং ওয়াং একটি মিয়াও যে ইনজেকশন ভালোবাসে), ওয়াং ওয়াং যদি প্রতি মাসে বি ইউয়ান সঞ্চয় করতে পারে, তাহলে ওয়াংওয়াং কতগুলো টিকা সময়মতো পেতে পারে?\nউদাহরণ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "bg": "Времето мина бързо и Ванг Ванг достигна възрастта за ваксинация. Ванг Ванг отиде в болницата и искаше да си направи инжекция с ваксина против бяс, но не можа да устои на изкушението на лекаря. Той се нуждае от общо 4 инжекции. Първо получи три инжекции от Мяо Сандуо, а след това ваксината против бяс. Една инжекция от Мяо Сандуо струва 120 юана, а една инжекция с ваксина против бяс струва 100 юана. Въпреки това, Ванг Ванг има само определена сума пари и не може да си направи всички инжекции наведнъж. В този момент лекарят каза: \"Как можем да завършим инжекциите наведнъж? Трябва да има месечен интервал между всяка две инжекции...\" Така че Ванг Ванг реши да спестява пари, докато си прави инжекции (защото Ванг Ванг е коте, което обича инжекции), ако Ванг Ванг може да спести B юана всеки месец, колко ваксинации може да получи Ванг Ванг навреме?\nПример:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "zh": "时间过得很快，汪汪已经到了接种疫苗的月份。汪汪来到医院，想给自己打一针狂犬疫苗，但他无法抵挡医生的诱惑。他总共需要打4针。他先接种了三针妙三多，然后是狂犬疫苗。一针妙三多的费用是120元，一针狂犬疫苗的费用是100元。然而，汪汪只有a元钱，无法一次性打完所有针。这时，医生说：“怎么能一次完成注射呢？每两次注射之间需要间隔一个月……”于是汪汪决定在给自己打针的同时存钱（因为汪汪是一个爱打针的喵），如果汪汪每个月能存B元，那么汪汪能按时打多少针？\n例子：\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "fr": "Le temps a passé rapidement, et Wang Wang avait atteint l'âge de mois pour la vaccination. Wang Wang est venu à l'hôpital et voulait se faire une injection de vaccin contre la rage, mais il n'a pas pu résister à la tentation du médecin. Il a besoin d'un total de 4 injections. Il a d'abord reçu trois injections de Miao Sanduo, puis le vaccin contre la rage. Une injection de Miao Sanduo coûte 120 yuans, et une injection de vaccin contre la rage coûte 100 yuans. Cependant, Wang Wang n'a qu'un yuan d'argent et ne peut pas prendre toutes les injections en une seule fois. À ce moment-là, le médecin a dit : \"Comment pouvons-nous compléter l'injection en une seule fois ? Il doit y avoir un intervalle d'un mois entre chaque deux injections...\" Donc Wang Wang a décidé d'économiser de l'argent tout en se faisant des injections (parce que Wang Wang est un meow qui aime les injections), Wang Wang Si je peux économiser B yuans chaque mois, combien de vaccinations Wangwang peut-il obtenir à temps ?\nExemple :\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "de": "Die Zeit verging schnell, und Wang Wang hatte das Alter für Impfungen erreicht. Wang Wang kam ins Krankenhaus und wollte sich eine Tollwutimpfung geben lassen, konnte jedoch der Versuchung des Arztes nicht widerstehen. Er benötigt insgesamt 4 Injektionen. Zuerst erhielt er drei Spritzen von Miao Sanduo und dann die Tollwutimpfung. Eine Spritze Miao Sanduo kostet 120 Yuan, und eine Tollwutimpfung kostet 100 Yuan. Wang Wang hat jedoch nur einen Yuan Geld und kann nicht alle Spritzen auf einmal nehmen. Zu diesem Zeitpunkt sagte der Arzt: \"Wie können wir die Injektion auf einmal abschließen? Es muss ein Monat Abstand zwischen zwei Injektionen liegen...\" Also entschied sich Wang Wang, Geld zu sparen, während er sich Injektionen gibt (weil Wang Wang ein Meow ist, der Injektionen liebt). Wenn Wang Wang jeden Monat B Yuan sparen kann, wie viele Impfungen kann Wang Wang rechtzeitig erhalten?\nBeispiel:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "ha": "Lokaci ya wuce da sauri, kuma Wang Wang ya kai shekarun watanni don yin rigakafi. Wang Wang ya zo asibiti kuma yana son yi wa kansa allurar rigakafin cutar hauka, amma bai iya jure wa jarabar likita ba. Yana buƙatar allurai guda 4 gaba ɗaya. Da farko ya karɓi allurai uku na Miao Sanduo, sannan rigakafin cutar hauka. Allura ɗaya ta Miao Sanduo tana kashe yuan 120, kuma allura ɗaya ta rigakafin cutar hauka tana kashe yuan 100. Duk da haka, Wang Wang yana da yuan kaɗai na kuɗi kuma ba zai iya ɗaukar duk alluran a lokaci ɗaya ba. A wannan lokacin, likita ya ce: \"Ta yaya za mu kammala allurar a lokaci ɗaya? Dole ne a sami tazarar wata guda tsakanin kowane allurai biyu...\" Don haka Wang Wang ya yanke shawarar adana kuɗi yayin da yake yi wa kansa allurai (saboda Wang Wang meow ne wanda ke son allurai), Wang Wang Idan zan iya adana yuan B kowane wata, nawa daga cikin alluran rigakafin Wangwang zai iya samu akan lokaci?\n\nMisali:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hi": "समय तेजी से बीता, और वांग वांग टीकाकरण के महीनों की उम्र तक पहुँच गया था। वांग वांग अस्पताल आया और खुद को रेबीज वैक्सीन का एक शॉट देना चाहता था, लेकिन वह डॉक्टर के प्रलोभन का विरोध नहीं कर सका। उसे कुल 4 इंजेक्शन की आवश्यकता है। उसने पहले मियाओ सांडुओ के तीन शॉट्स प्राप्त किए, और फिर रेबीज वैक्सीन। मियाओ सांडुओ के एक शॉट की कीमत 120 युआन है, और रेबीज वैक्सीन के एक शॉट की कीमत 100 युआन है। हालाँकि, वांग वांग के पास केवल एक युआन का पैसा है और वह एक बार में सभी शॉट्स नहीं ले सकता। इस समय, डॉक्टर ने कहा: \"हम एक बार में इंजेक्शन कैसे पूरा कर सकते हैं? हर दो इंजेक्शन के बीच एक महीने का अंतराल होना चाहिए...\" इसलिए वांग वांग ने इंजेक्शन लगाते समय पैसे बचाने का फैसला किया (क्योंकि वांग वांग एक म्याऊ है जो इंजेक्शन पसंद करता है), वांग वांग अगर मैं हर महीने बी युआन बचा सकता हूँ, तो वांगवांग कितने टीकाकरण समय पर प्राप्त कर सकता है?\nउदाहरण:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hu": "Az idő gyorsan telt, és Wang Wang elérte a hónapos oltási kort. Wang Wang elment a kórházba, és szeretett volna magának egy veszettség elleni oltást adni, de nem tudott ellenállni az orvos csábításának. Összesen 4 injekcióra van szüksége. Először három Miao Sanduo injekciót kapott, majd a veszettség elleni oltást. Egy Miao Sanduo injekció 120 jüanba kerül, és egy veszettség elleni oltás 100 jüanba kerül. Azonban Wang Wangnak csak egy jüanja van, és nem tudja egyszerre megkapni az összes oltást. Ekkor az orvos azt mondta: \"Hogyan lehetne egyszerre befejezni az oltást? Minden két injekció között egy hónap szünetnek kell lennie...\" Így Wang Wang úgy döntött, hogy pénzt takarít meg, miközben magának adja az injekciókat (mert Wang Wang egy meow, aki szereti az injekciókat), Wang Wang Ha havonta B jüant tud megtakarítani, hány oltást kaphat Wangwang időben?\nPélda:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.957095440435702",
      "hy": "0.9478154290337522",
      "bn": "0.9442196232458775",
      "bg": "0.9483412036523514",
      "zh": "0.909020333422685",
      "fr": "0.9571371528157194",
      "de": "0.9379349579899336",
      "ha": "0.9544556426717484",
      "hi": "0.9581465924121387",
      "hu": "0.9366603468348328"
    }
  },
  {
    "task_id": "Kotlin/20",
    "prompt": {
      "en": "/**\n * Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\n * on two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n * \n * Example:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "sq": "/**\n * Kryen operacione aritmetike bazë (mbledhje, zbritje, shumëzim, pjestim dhe modul)\n * mbi dy numra të plotë bazuar në një karakter të specifikuar të operacionit. Llogaritja e paligjshme kthen \"invalid calcu\"\n * \n * Shembull:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "hy": "/**\n * Կատարել հիմնական թվաբանական գործողություններ (գումարում, հանում, բազմապատկում, բաժանում և մնացորդ)\n * երկու ամբողջ թվերի վրա՝ հիմնված նշված գործողության սիմվոլի վրա։ Անօրինական հաշվարկը վերադարձնում է \"invalid calcu\"\n * \n * Օրինակ:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "bn": "/**\n * দুটি পূর্ণসংখ্যার উপর নির্দিষ্ট অপারেশন চরিত্রের ভিত্তিতে মৌলিক গাণিতিক অপারেশন (যোগ, বিয়োগ, গুণ, ভাগ, এবং মডুলাস) সম্পাদন করুন\n * অবৈধ গণনা \"invalid calcu\" ফেরত দেয়\n * \n * উদাহরণ:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "bg": "/**\n * Извършва основни аритметични операции (събиране, изваждане, умножение, деление и модул)\n * върху две цели числа въз основа на зададен символ за операция. Невалидно изчисление връща \"invalid calcu\"\n * \n * Пример:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "zh": "/**\n * 对两个整数执行基本的算术运算（加法、减法、乘法、除法和取模）\n * 根据指定的操作字符。非法计算返回 \"invalid calcu\"\n * \n * 示例:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "fr": "/**\n * Effectuer des opérations arithmétiques de base (addition, soustraction, multiplication, division et modulo)\n * sur deux entiers en fonction d'un caractère d'opération spécifié. Un calcul illégal renvoie \"invalid calcu\"\n * \n * Exemple:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "de": "/**\n * Führe grundlegende arithmetische Operationen (Addition, Subtraktion, Multiplikation, Division und Modulus)\n * auf zwei ganzen Zahlen basierend auf einem angegebenen Operationszeichen durch. Ungültige Berechnung gibt \"invalid calcu\" zurück\n * \n * Beispiel:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "ha": "/**\n * Yi ayyukan lissafi na asali (ƙara, cire, ninka, raba, da kuma modulus)\n * akan lambobi guda biyu bisa ga alamar aiki da aka fayyace. Lissafi mara izini yana dawowa da \"invalid calcu\"\n * \n * Misali:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "hi": "/**\n * दो पूर्णांकों पर एक निर्दिष्ट ऑपरेशन कैरेक्टर के आधार पर बुनियादी अंकगणितीय संचालन (जोड़, घटाव, गुणा, भाग, और मापांक)\n * करें। अवैध गणना \"invalid calcu\" लौटाती है\n * \n * उदाहरण:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "hu": "/**\n * Végezzen el alapvető aritmetikai műveleteket (összeadás, kivonás, szorzás, osztás és modulus)\n * két egész számon egy megadott műveleti karakter alapján. Illegális számítás esetén \"invalid calcu\" értéket ad vissza\n * \n * Példa:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/"
    },
    "prompt_bertscore": {
      "sq": "0.9475011957709549",
      "hy": "0.9374024299383791",
      "bn": "0.9299168453986983",
      "bg": "0.9302199553601576",
      "zh": "0.9470955925328817",
      "fr": "0.9452612409640245",
      "de": "0.9455361454113768",
      "ha": "0.9383365886203862",
      "hi": "0.9412109688643421",
      "hu": "0.9378100194802628"
    },
    "canonical_solution": "{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}",
    "instruction": {
      "en": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nনিম্নলিখিত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\n请用不超过500个字符的中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nBada takaitaccen bayani a cikin yare na halitta (docstring) na lambar Kotlin cikin Hausa ba tare da wuce haruffa 500 ba.",
      "hi": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nकृपया Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any\n{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.8872653409398389",
      "bn": "0.8822429717553717",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9037361693960139",
      "hi": "0.9022003592898521",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main(){\n    check(simpleCalculator(10, 5, '+') == 15)\n    check(simpleCalculator(10, 5, '-') == 5)\n    check(simpleCalculator(10, 5, '*') == 50)\n    check(simpleCalculator(10, 5, '/') == 2)\n    check(simpleCalculator(10, 5, '%') == 0)\n    check(simpleCalculator(15, 4, '/') == 3)\n    check(simpleCalculator(15, 4, '%') == 3)\n    check(simpleCalculator(15, 0, '/') == \"invalid calc\")\n    check(simpleCalculator(15, 0, '%') == \"invalid calc\")\n\n}\nmain()",
    "entry_point": "simpleCalculator",
    "signature": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any",
    "docstring": {
      "en": "Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\non two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n\nExample:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "sq": "Kryeni operacione aritmetike bazë (mbledhje, zbritje, shumëzim, pjesëtim dhe modulus)\nmbi dy numra të plotë bazuar në një karakter të specifikuar operacioni. Llogaritja e paligjshme kthen \"invalid calcu\"\n\nShembull:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hy": "Կատարել հիմնական թվաբանական գործողություններ (գումարում, հանում, բազմապատկում, բաժանում և մնացորդ) երկու ամբողջ թվերի վրա՝ հիմնվելով նշված գործողության սիմվոլի վրա։ Անօրինական հաշվարկը վերադարձնում է \"invalid calcu\"\n\nՕրինակ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "bn": "দুটি পূর্ণসংখ্যার উপর নির্দিষ্ট অপারেশন চরিত্রের ভিত্তিতে মৌলিক গাণিতিক অপারেশন (যোগ, বিয়োগ, গুণ, ভাগ, এবং মডুলাস) সম্পাদন করুন। অবৈধ গণনা \"invalid calcu\" ফেরত দেয়।\n\nউদাহরণ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "bg": "Извършете основни аритметични операции (събиране, изваждане, умножение, деление и модул)\nвърху две цели числа въз основа на определен символ за операция. Невалидно изчисление връща \"invalid calcu\"\n\nПример:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "zh": "执行基本的算术运算（加法、减法、乘法、除法和取模）在两个整数上，基于指定的操作字符。非法计算返回“invalid calcu”\n\n示例：\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "fr": "Effectuer des opérations arithmétiques de base (addition, soustraction, multiplication, division et modulo) sur deux entiers en fonction d'un caractère d'opération spécifié. Un calcul illégal renvoie \"invalid calcu\"\n\nExemple :\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "de": "Führen Sie grundlegende arithmetische Operationen (Addition, Subtraktion, Multiplikation, Division und Modulus) auf zwei ganzen Zahlen basierend auf einem angegebenen Operationszeichen durch. Ungültige Berechnung gibt \"invalid calcu\" zurück.\n\nBeispiel:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "ha": "Ai aikace-aikacen lissafi na asali (haɗawa, cirewa, ninka, raba, da kuma modulus) akan lambobi guda biyu bisa ga alamar aiki da aka fayyace. Lissafi mara izini yana dawo da \"invalid calcu\"\n\nMisali:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hi": "दो पूर्णांकों पर निर्दिष्ट ऑपरेशन कैरेक्टर के आधार पर बुनियादी अंकगणितीय संचालन (जोड़, घटाव, गुणा, भाग, और माड्यूलस) करें। अवैध गणना \"invalid calcu\" लौटाती है।\n\nउदाहरण:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hu": "Végezzen el alapvető aritmetikai műveleteket (összeadás, kivonás, szorzás, osztás és modulus)\nkét egész szám között egy megadott műveleti karakter alapján. Érvénytelen számítás esetén \"invalid calcu\" értéket ad vissza.\n\nPélda:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2"
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9791209674975178",
      "bn": "0.9790667414034953",
      "bg": "0.9842261655508764",
      "zh": "0.9957791044030087",
      "fr": "0.9898930903218018",
      "de": "0.9825566771982782",
      "ha": "0.9819456901462149",
      "hi": "0.9765844575317022",
      "hu": "0.9560349528313569"
    }
  },
  {
    "task_id": "Kotlin/21",
    "prompt": {
      "en": "/**\n * Calculates the number of passengers on a bus at a specific station.\n * \n * The bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off, \n * so the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers \n * that got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the \n * previous station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n *\n * @param a The number of passengers boarding at the first station.\n * @param n The total number of stations.\n * @param m The number of passengers who get off at the last station.\n * @param x The station number for which the passenger count is required.\n * @return The number of passengers on the bus as it leaves station 'x'.\n *\n * Example:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "sq": "/**\n * Llogarit numrin e pasagjerëve në një autobus në një stacion specifik.\n * \n * Autobusi fillon në stacionin e parë me 'a' pasagjerë. Në stacionin e dytë, një numër i barabartë pasagjerësh hipin dhe zbresin,\n * kështu që numri mbetet 'a'. Nga stacioni i tretë e tutje, numri i pasagjerëve që hipin është shuma e pasagjerëve\n * që hipën në dy stacionet e fundit, dhe numri i pasagjerëve që zbresin është i njëjtë me numrin që hipën në\n * stacionin e mëparshëm. Procesi vazhdon deri në stacionin e parafundit. Në stacionin e fundit të gjithë pasagjerët ('m') zbresin.\n *\n * @param a Numri i pasagjerëve që hipin në stacionin e parë.\n * @param n Numri total i stacioneve.\n * @param m Numri i pasagjerëve që zbresin në stacionin e fundit.\n * @param x Numri i stacionit për të cilin kërkohet numri i pasagjerëve.\n * @return Numri i pasagjerëve në autobus ndërsa largohet nga stacioni 'x'.\n *\n * Shembull:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "hy": "/**\n * Հաշվում է ավտոբուսի ուղևորների քանակը որոշակի կայարանում:\n * \n * Ավտոբուսը սկսում է առաջին կայարանից 'a' ուղևորներով: Երկրորդ կայարանում նույն քանակությամբ ուղևորներ են նստում և իջնում, \n * այնպես որ քանակը մնում է 'a': Երրորդ կայարանից սկսած, նստող ուղևորների քանակը նախորդ երկու կայարաններում նստածների \n * գումարն է, իսկ իջնող ուղևորների քանակը նույնն է, ինչ նախորդ կայարանում նստածների քանակը: Գործընթացը շարունակվում է մինչև \n * նախավերջին կայարանը: Վերջին կայարանում բոլոր ուղևորները ('m') իջնում են:\n *\n * @param a Ուղևորների քանակը, որոնք նստում են առաջին կայարանում:\n * @param n Կայարանների ընդհանուր քանակը:\n * @param m Ուղևորների քանակը, որոնք իջնում են վերջին կայարանում:\n * @param x Կայարանի համարը, որի համար անհրաժեշտ է ուղևորների քանակը:\n * @return Ուղևորների քանակը ավտոբուսում, երբ այն հեռանում է 'x' կայարանից:\n *\n * Օրինակ:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "bn": "/**\n * একটি নির্দিষ্ট স্টেশনে একটি বাসে যাত্রীদের সংখ্যা গণনা করে।\n * \n * বাসটি প্রথম স্টেশনে 'a' যাত্রী নিয়ে শুরু হয়। দ্বিতীয় স্টেশনে, সমান সংখ্যক যাত্রী ওঠে এবং নামে, \n * তাই সংখ্যা 'a' থাকে। তৃতীয় স্টেশন থেকে শুরু করে, ওঠা যাত্রীদের সংখ্যা আগের দুই স্টেশনে ওঠা যাত্রীদের \n * যোগফল এবং নামা যাত্রীদের সংখ্যা আগের স্টেশনে ওঠা যাত্রীদের সমান। এই প্রক্রিয়া শেষের আগের স্টেশন পর্যন্ত চলতে থাকে। \n * শেষ স্টেশনে সব যাত্রী ('m') নেমে যায়।\n *\n * @param a প্রথম স্টেশনে ওঠা যাত্রীদের সংখ্যা।\n * @param n মোট স্টেশনের সংখ্যা।\n * @param m শেষ স্টেশনে নামা যাত্রীদের সংখ্যা।\n * @param x যে স্টেশনের জন্য যাত্রী সংখ্যা প্রয়োজন তার স্টেশন নম্বর।\n * @return স্টেশন 'x' ত্যাগ করার সময় বাসে থাকা যাত্রীদের সংখ্যা।\n *\n * উদাহরণ:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "bg": "/**\n * Изчислява броя на пътниците в автобус на конкретна спирка.\n * \n * Автобусът започва от първата спирка с 'a' пътници. На втората спирка, равен брой пътници се качват и слизат,\n * така че броят остава 'a'. От третата спирка нататък, броят на пътниците, които се качват, е сумата от пътниците,\n * които са се качили на последните две спирки, а броят на пътниците, които слизат, е същият като броя на тези, които са се качили на\n * предишната спирка. Процесът продължава до предпоследната спирка. На последната спирка всички пътници ('m') слизат.\n *\n * @param a Броят на пътниците, които се качват на първата спирка.\n * @param n Общият брой на спирките.\n * @param m Броят на пътниците, които слизат на последната спирка.\n * @param x Номерът на спирката, за която е необходим броят на пътниците.\n * @return Броят на пътниците в автобуса, когато напуска спирка 'x'.\n *\n * Пример:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "zh": "/**\n * 计算特定车站的公交车乘客数量。\n * \n * 公交车在第一站有 'a' 名乘客。在第二站，有相同数量的乘客上下车，\n * 所以人数保持为 'a'。从第三站开始，上车乘客人数是前两站上车乘客人数的总和，\n * 下车乘客人数与前一站上车人数相同。这个过程持续到倒数第二站。最后一站所有乘客 ('m') 下车。\n *\n * @param a 第一站上车的乘客数量。\n * @param n 车站总数。\n * @param m 最后一站下车的乘客数量。\n * @param x 需要计算乘客数量的车站编号。\n * @return 公交车离开车站 'x' 时的乘客数量。\n *\n * 示例:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "fr": "/**\n * Calcule le nombre de passagers dans un bus à une station spécifique.\n * \n * Le bus commence à la première station avec 'a' passagers. À la deuxième station, un nombre égal de passagers monte et descend, \n * donc le nombre reste 'a'. À partir de la troisième station, le nombre de passagers qui montent est la somme des passagers \n * qui sont montés aux deux dernières stations, et le nombre de passagers qui descendent est le même que le nombre qui est monté à la \n * station précédente. Le processus continue jusqu'à l'avant-dernière station. À la dernière station, tous les passagers ('m') descendent.\n *\n * @param a Le nombre de passagers montant à la première station.\n * @param n Le nombre total de stations.\n * @param m Le nombre de passagers qui descendent à la dernière station.\n * @param x Le numéro de la station pour laquelle le nombre de passagers est requis.\n * @return Le nombre de passagers dans le bus lorsqu'il quitte la station 'x'.\n *\n * Exemple:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "de": "/**\n * Berechnet die Anzahl der Passagiere in einem Bus an einer bestimmten Haltestelle.\n * \n * Der Bus startet an der ersten Haltestelle mit 'a' Passagieren. An der zweiten Haltestelle steigen gleich viele Passagiere ein und aus,\n * sodass die Anzahl 'a' bleibt. Ab der dritten Haltestelle ist die Anzahl der einsteigenden Passagiere die Summe der Passagiere,\n * die an den letzten beiden Haltestellen eingestiegen sind, und die Anzahl der aussteigenden Passagiere ist die gleiche wie die Anzahl,\n * die an der vorherigen Haltestelle eingestiegen ist. Der Prozess setzt sich bis zur vorletzten Haltestelle fort. An der letzten Haltestelle steigen alle Passagiere ('m') aus.\n *\n * @param a Die Anzahl der Passagiere, die an der ersten Haltestelle einsteigen.\n * @param n Die Gesamtzahl der Haltestellen.\n * @param m Die Anzahl der Passagiere, die an der letzten Haltestelle aussteigen.\n * @param x Die Haltestellennummer, für die die Passagieranzahl benötigt wird.\n * @return Die Anzahl der Passagiere im Bus, wenn er die Haltestelle 'x' verlässt.\n *\n * Beispiel:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "ha": "/**\n * Yana ƙididdige adadin fasinjoji a cikin bas a wani takamaiman tashar.\n * \n * Bas ɗin yana farawa a tashar farko tare da fasinjoji 'a'. A tashar ta biyu, adadin fasinjoji da suka hau da suka sauka sun yi daidai, \n * don haka adadin ya kasance 'a'. Daga tashar ta uku zuwa gaba, adadin fasinjoji da ke hawa shine jimlar fasinjojin \n * da suka hau a tashoshin biyu na baya, kuma adadin fasinjojin da ke sauka ya yi daidai da adadin da suka hau a \n * tashar da ta gabata. Tsarin yana ci gaba har zuwa tashar ta biyu daga ƙarshe. Tashar ƙarshe tana ganin duk fasinjoji ('m') suna sauka.\n *\n * @param a Adadin fasinjojin da ke hawa a tashar farko.\n * @param n Jimlar adadin tashoshi.\n * @param m Adadin fasinjojin da suka sauka a tashar ƙarshe.\n * @param x Lambar tashar da ake buƙatar adadin fasinjoji.\n * @return Adadin fasinjojin a cikin bas yayin da yake barin tashar 'x'.\n *\n * Misali:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "hi": "/**\n * एक विशिष्ट स्टेशन पर बस में यात्रियों की संख्या की गणना करता है।\n * \n * बस पहले स्टेशन पर 'a' यात्रियों के साथ शुरू होती है। दूसरे स्टेशन पर, समान संख्या में यात्री चढ़ते और उतरते हैं,\n * इसलिए गिनती 'a' बनी रहती है। तीसरे स्टेशन से आगे, चढ़ने वाले यात्रियों की संख्या पिछले दो स्टेशनों पर चढ़े यात्रियों का योग होती है,\n * और उतरने वाले यात्रियों की संख्या पिछले स्टेशन पर चढ़े यात्रियों के समान होती है। यह प्रक्रिया दूसरे अंतिम स्टेशन तक जारी रहती है।\n * अंतिम स्टेशन पर सभी यात्री ('m') उतर जाते हैं।\n *\n * @param a पहले स्टेशन पर चढ़ने वाले यात्रियों की संख्या।\n * @param n कुल स्टेशनों की संख्या।\n * @param m अंतिम स्टेशन पर उतरने वाले यात्रियों की संख्या।\n * @param x वह स्टेशन संख्या जिसके लिए यात्री संख्या की आवश्यकता है।\n * @return स्टेशन 'x' छोड़ते समय बस में यात्रियों की संख्या।\n *\n * उदाहरण:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "hu": "/**\n * Kiszámítja az utasok számát egy buszon egy adott állomáson.\n * \n * A busz az első állomáson 'a' utassal indul. A második állomáson ugyanannyi utas száll fel és le, \n * így a létszám 'a' marad. A harmadik állomástól kezdve a felszálló utasok száma az előző két állomáson \n * felszállt utasok összege, és a leszálló utasok száma megegyezik az előző állomáson felszállt utasok számával. \n * A folyamat a második utolsó állomásig folytatódik. Az utolsó állomáson minden utas ('m') leszáll.\n *\n * @param a Az első állomáson felszálló utasok száma.\n * @param n Az állomások összes száma.\n * @param m Az utolsó állomáson leszálló utasok száma.\n * @param x Az állomás száma, amelynél az utasok számát kérdezzük.\n * @return Az utasok száma a buszon, amikor elhagyja az 'x' állomást.\n *\n * Példa:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9096718410724794",
      "hy": "0.9041669986924785",
      "bn": "0.8952212822218103",
      "bg": "0.9112195690015032",
      "zh": "0.8939788491884371",
      "fr": "0.943818191245806",
      "de": "0.8934860472130894",
      "ha": "0.897280483381999",
      "hi": "0.9034944362222944",
      "hu": "0.9044965264946154"
    },
    "canonical_solution": "{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}",
    "instruction": {
      "en": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nПредоставете кратко описание на естествен език (docstring) на Kotlin кода на български, използвайки не повече от 500 знака.",
      "zh": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nGeben Sie eine prägnante natürliche Sprachbeschreibung (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nBa da taƙaitaccen bayanin yaren halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int\n{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9358497362498294",
      "bn": "0.8738053517993907",
      "bg": "0.9362722230702906",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9604816911715849",
      "ha": "0.9391801718486413",
      "hi": "0.8761702451159921",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(busStationPassengers(5, 7, 32, 5) == 21)\n    check(busStationPassengers(5, 7, 32, 4) == 13)\n    check(busStationPassengers(5, 7, 32, 3) == 10)\n    check(busStationPassengers(5, 7, 32, 2) == 5)\n    \n\n}\nmain()",
    "entry_point": "busStationPassengers",
    "signature": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int",
    "docstring": {
      "en": "Calculates the number of passengers on a bus at a specific station.\n\nThe bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off,\nso the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers\nthat got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the\nprevious station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n\n@param a The number of passengers boarding at the first station.\n@param n The total number of stations.\n@param m The number of passengers who get off at the last station.\n@param x The station number for which the passenger count is required.\n@return The number of passengers on the bus as it leaves station 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "sq": "Llogarit numrin e pasagjerëve në një autobus në një stacion specifik.\n\nAutobusi fillon në stacionin e parë me 'a' pasagjerë. Në stacionin e dytë, një numër i barabartë pasagjerësh hipin dhe zbresin,\nkështu që numri mbetet 'a'. Nga stacioni i tretë e tutje, numri i pasagjerëve që hipin është shuma e pasagjerëve\nqë hipën në dy stacionet e fundit, dhe numri i pasagjerëve që zbresin është i njëjtë me numrin që hipën në\nstacionin e mëparshëm. Procesi vazhdon deri në stacionin e parafundit. Në stacionin e fundit të gjithë pasagjerët ('m') zbresin.\n\n@param a Numri i pasagjerëve që hipin në stacionin e parë.\n@param n Numri total i stacioneve.\n@param m Numri i pasagjerëve që zbresin në stacionin e fundit.\n@param x Numri i stacionit për të cilin kërkohet numri i pasagjerëve.\n@return Numri i pasagjerëve në autobus ndërsa largohet nga stacioni 'x'.\n\nShembull:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hy": "Հաշվում է ավտոբուսի ուղևորների քանակը որոշակի կայարանում:\n\nԱվտոբուսը սկսում է առաջին կայարանում 'a' ուղևորներով: Երկրորդ կայարանում նույն քանակի ուղևորներ են նստում և իջնում, այնպես որ քանակը մնում է 'a': Երրորդ կայարանից սկսած, նստող ուղևորների քանակը հավասար է վերջին երկու կայարաններում նստած ուղևորների գումարին, իսկ իջնող ուղևորների քանակը նույնն է, ինչ նախորդ կայարանում նստած ուղևորների քանակը: Գործընթացը շարունակվում է մինչև նախավերջին կայարանը: Վերջին կայարանում բոլոր ուղևորները ('m') իջնում են:\n\n@param a Ուղևորների քանակը, ովքեր նստում են առաջին կայարանում:\n@param n Կայարանների ընդհանուր քանակը:\n@param m Ուղևորների քանակը, ովքեր իջնում են վերջին կայարանում:\n@param x Կայարանի համարը, որի համար պահանջվում է ուղևորների քանակը:\n@return Ուղևորների քանակը ավտոբուսում, երբ այն հեռանում է 'x' կայարանից:\n\nՕրինակ:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "bn": "বাসের একটি নির্দিষ্ট স্টেশনে যাত্রীদের সংখ্যা গণনা করে।\n\nবাসটি প্রথম স্টেশনে 'a' সংখ্যক যাত্রী নিয়ে শুরু হয়। দ্বিতীয় স্টেশনে, সমান সংখ্যক যাত্রী ওঠে এবং নামে, তাই সংখ্যা 'a' থাকে। তৃতীয় স্টেশন থেকে শুরু করে, যাত্রীদের ওঠার সংখ্যা শেষ দুই স্টেশনে ওঠা যাত্রীদের যোগফল, এবং নামার সংখ্যা আগের স্টেশনে ওঠা যাত্রীদের সমান। এই প্রক্রিয়া শেষের আগের স্টেশন পর্যন্ত চলতে থাকে। শেষ স্টেশনে সব যাত্রী ('m') নেমে যায়।\n\n@param a প্রথম স্টেশনে ওঠা যাত্রীদের সংখ্যা।\n@param n মোট স্টেশনের সংখ্যা।\n@param m শেষ স্টেশনে নামা যাত্রীদের সংখ্যা।\n@param x যে স্টেশনের জন্য যাত্রী সংখ্যা প্রয়োজন তার স্টেশন নম্বর।\n@return স্টেশন 'x' ছাড়ার সময় বাসে থাকা যাত্রীদের সংখ্যা।\n\nউদাহরণ:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "bg": "Изчислява броя на пътниците в автобус на определена спирка.\n\nАвтобусът започва от първата спирка с 'a' пътници. На втората спирка равен брой пътници се качват и слизат,\nтака че броят остава 'a'. От третата спирка нататък броят на качващите се пътници е сумата от пътниците,\nкоито са се качили на последните две спирки, а броят на слизащите пътници е същият като броя на качилите се на\nпредишната спирка. Процесът продължава до предпоследната спирка. На последната спирка всички пътници ('m') слизат.\n\n@param a Броят на пътниците, които се качват на първата спирка.\n@param n Общият брой на спирките.\n@param m Броят на пътниците, които слизат на последната спирка.\n@param x Номерът на спирката, за която е необходим броят на пътниците.\n@return Броят на пътниците в автобуса, когато напуска спирка 'x'.\n\nПример:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "zh": "计算特定车站公交车上的乘客数量。\n\n公交车在第一站有 'a' 名乘客。第二站时，上下车的乘客数量相等，因此乘客数量保持为 'a'。从第三站开始，上车的乘客数量是前两站上车乘客数量的总和，而下车的乘客数量与前一站上车的乘客数量相同。这个过程持续到倒数第二站。最后一站所有乘客 ('m') 下车。\n\n@param a 第一站上车的乘客数量。\n@param n 车站总数。\n@param m 最后一站下车的乘客数量。\n@param x 需要计算乘客数量的车站编号。\n@return 公交车离开车站 'x' 时的乘客数量。\n\n示例：\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "fr": "Calcule le nombre de passagers dans un bus à une station spécifique.\n\nLe bus commence à la première station avec 'a' passagers. À la deuxième station, un nombre égal de passagers monte et descend, donc le compte reste 'a'. À partir de la troisième station, le nombre de passagers montant est la somme des passagers qui sont montés aux deux dernières stations, et le nombre de passagers descendant est le même que le nombre qui est monté à la station précédente. Le processus continue jusqu'à l'avant-dernière station. La dernière station voit tous les passagers ('m') descendre.\n\n@param a Le nombre de passagers montant à la première station.\n@param n Le nombre total de stations.\n@param m Le nombre de passagers qui descendent à la dernière station.\n@param x Le numéro de la station pour laquelle le nombre de passagers est requis.\n@return Le nombre de passagers dans le bus lorsqu'il quitte la station 'x'.\n\nExemple:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "de": "Berechnet die Anzahl der Passagiere in einem Bus an einer bestimmten Station.\n\nDer Bus startet an der ersten Station mit 'a' Passagieren. An der zweiten Station steigen gleich viele Passagiere ein und aus, sodass die Anzahl 'a' bleibt. Ab der dritten Station ist die Anzahl der einsteigenden Passagiere die Summe der Passagiere, die an den letzten beiden Stationen eingestiegen sind, und die Anzahl der aussteigenden Passagiere ist die gleiche wie die Anzahl, die an der vorherigen Station eingestiegen ist. Der Prozess setzt sich bis zur vorletzten Station fort. An der letzten Station steigen alle Passagiere ('m') aus.\n\n@param a Die Anzahl der Passagiere, die an der ersten Station einsteigen.\n@param n Die Gesamtzahl der Stationen.\n@param m Die Anzahl der Passagiere, die an der letzten Station aussteigen.\n@param x Die Stationsnummer, für die die Anzahl der Passagiere benötigt wird.\n@return Die Anzahl der Passagiere im Bus, wenn er die Station 'x' verlässt.\n\nBeispiel:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "ha": "Lissafa adadin fasinjoji a kan bas a wani tashar musamman.\n\n# Bas din yana farawa a tashar farko tare da fasinjoji 'a'. A tashar ta biyu, adadin fasinjoji da suka hau da suka sauka\n# ya yi daidai, don haka adadin ya kasance 'a'. Daga tashar ta uku zuwa gaba, adadin fasinjoji da ke hawa shine jumlar fasinjojin\n# da suka hau a tashoshin biyu da suka gabata, kuma adadin fasinjoji da ke sauka ya yi daidai da adadin da suka hau a\n# tashar da ta gabata. Tsarin yana ci gaba har zuwa tashar ta biyu daga karshe. Tashar karshe tana ganin duk fasinjoji ('m') suna sauka.\n\n@param a Adadin fasinjojin da ke hawa a tashar farko.\n@param n Jimlar adadin tashoshi.\n@param m Adadin fasinjojin da ke sauka a tashar karshe.\n@param x Lambar tashar da ake bukatar adadin fasinjoji.\n@return Adadin fasinjoji a kan bas din yayin da yake barin tashar 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hi": "बस में एक विशिष्ट स्टेशन पर यात्रियों की संख्या की गणना करता है।\n\nबस पहले स्टेशन पर 'a' यात्रियों के साथ शुरू होती है। दूसरे स्टेशन पर, समान संख्या में यात्री चढ़ते और उतरते हैं, इसलिए संख्या 'a' बनी रहती है। तीसरे स्टेशन से आगे, चढ़ने वाले यात्रियों की संख्या पिछले दो स्टेशनों पर चढ़े यात्रियों का योग होती है, और उतरने वाले यात्रियों की संख्या पिछले स्टेशन पर चढ़े यात्रियों के बराबर होती है। यह प्रक्रिया दूसरे-से-अंतिम स्टेशन तक जारी रहती है। अंतिम स्टेशन पर सभी यात्री ('m') उतर जाते हैं।\n\n@param a पहले स्टेशन पर चढ़ने वाले यात्रियों की संख्या।\n@param n कुल स्टेशनों की संख्या।\n@param m अंतिम स्टेशन पर उतरने वाले यात्रियों की संख्या।\n@param x वह स्टेशन संख्या जिसके लिए यात्री संख्या की आवश्यकता है।\n@return बस में यात्रियों की संख्या जब वह स्टेशन 'x' छोड़ती है।\n\nउदाहरण:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hu": "Számítja az utasok számát egy buszon egy adott állomáson.\n\nA busz az első állomáson 'a' utassal indul. A második állomáson ugyanannyi utas száll fel és le, így a szám 'a' marad. A harmadik állomástól kezdve a felszálló utasok száma az előző két állomáson felszállt utasok összege, és a leszálló utasok száma megegyezik az előző állomáson felszállt utasok számával. A folyamat az utolsó előtti állomásig folytatódik. Az utolsó állomáson minden utas ('m') leszáll.\n\n@param a Az első állomáson felszálló utasok száma.\n@param n Az állomások összes száma.\n@param m Az utolsó állomáson leszálló utasok száma.\n@param x Az állomás száma, amelyhez az utasszám szükséges.\n@return Az utasok száma a buszon, amikor elhagyja az 'x' állomást.\n\nPélda:\n>>> busStationPassengers(5, 7, 32, 4)\n13"
    },
    "docstring_bertscore": {
      "sq": "0.9254689152761841",
      "hy": "0.9323357661789412",
      "bn": "0.9143118467734545",
      "bg": "0.9340100216606843",
      "zh": "0.9345353990185216",
      "fr": "0.977488623026173",
      "de": "0.9480452443846095",
      "ha": "0.9228992340367357",
      "hi": "0.9808776545873903",
      "hu": "0.9422541756255373"
    }
  },
  {
    "task_id": "Kotlin/22",
    "prompt": {
      "en": "/**\n    * Calculate the number of ways a person can mistakenly put letters in envelopes\n    * such that each letter ends up in the wrong envelope.\n    *\n    * This is based on a derangement problem where each item (letter) must not be\n    * in its original position (envelope).\n    *\n    * Parameters:\n    * n - the number of letters and envelopes.\n    *\n    * Returns:\n    * The total number of ways to wrongly place all the letters.\n    *\n    * Examples:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "sq": "/**\n    * Llogarit numrin e mënyrave se si një person mund të vendosë gabimisht letrat në zarfe\n    * në mënyrë që secila letër të përfundojë në zarf të gabuar.\n    *\n    * Kjo bazohet në një problem të çrregullimit ku secili artikull (letër) nuk duhet të jetë\n    * në pozicionin e tij origjinal (zarf).\n    *\n    * Parametrat:\n    * n - numri i letrave dhe zarfeve.\n    *\n    * Kthen:\n    * Numri total i mënyrave për të vendosur gabimisht të gjitha letrat.\n    *\n    * Shembuj:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "hy": "/**\n    * Հաշվել, թե քանի եղանակով մարդը կարող է սխալմամբ տեղադրել նամակները ծրարների մեջ\n    * այնպես, որ յուրաքանչյուր նամակ հայտնվի սխալ ծրարի մեջ:\n    *\n    * Սա հիմնված է տեղաշարժման խնդրի վրա, որտեղ յուրաքանչյուր տարր (նամակ) չպետք է լինի\n    * իր սկզբնական դիրքում (ծրար):\n    *\n    * Պարամետրեր:\n    * n - նամակների և ծրարների քանակը:\n    *\n    * Վերադարձնում է:\n    * Բոլոր նամակները սխալ տեղադրելու եղանակների ընդհանուր քանակը:\n    *\n    * Օրինակներ:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "bn": "/**\n    * কতভাবে একজন ব্যক্তি ভুল করে চিঠিগুলো খামে রাখতে পারে\n    * যাতে প্রতিটি চিঠি ভুল খামে শেষ হয়।\n    *\n    * এটি একটি ভুল স্থাপন সমস্যা ভিত্তিক যেখানে প্রতিটি আইটেম (চিঠি) \n    * তার মূল অবস্থানে (খাম) থাকতে পারবে না।\n    *\n    * প্যারামিটার:\n    * n - চিঠি এবং খামের সংখ্যা।\n    *\n    * রিটার্ন করে:\n    * চিঠিগুলো ভুলভাবে রাখার মোট সংখ্যা।\n    *\n    * উদাহরণ:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "bg": "/**\n    * Изчислява броя начини, по които човек може погрешно да постави писма в пликове\n    * така че всяко писмо да се окаже в грешен плик.\n    *\n    * Това се основава на проблем с разместването, където всеки елемент (писмо) не трябва да бъде\n    * в оригиналната си позиция (плик).\n    *\n    * Параметри:\n    * n - броят на писмата и пликовете.\n    *\n    * Връща:\n    * Общият брой начини за неправилно поставяне на всички писма.\n    *\n    * Примери:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "zh": "/**\n    * 计算一个人错误地将信件放入信封的方式数量，\n    * 使得每封信都放错了信封。\n    *\n    * 这是基于一个错排问题，其中每个项目（信件）都不能在其原始位置（信封）中。\n    *\n    * 参数：\n    * n - 信件和信封的数量。\n    *\n    * 返回：\n    * 错误放置所有信件的总方式数量。\n    *\n    * 示例：\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "fr": "/**\n    * Calculer le nombre de façons dont une personne peut mettre par erreur des lettres dans des enveloppes\n    * de telle sorte que chaque lettre se retrouve dans la mauvaise enveloppe.\n    *\n    * Ceci est basé sur un problème de dérangement où chaque élément (lettre) ne doit pas être\n    * dans sa position d'origine (enveloppe).\n    *\n    * Paramètres:\n    * n - le nombre de lettres et d'enveloppes.\n    *\n    * Renvoie:\n    * Le nombre total de façons de placer incorrectement toutes les lettres.\n    *\n    * Exemples:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "de": "/**\n    * Berechne die Anzahl der Möglichkeiten, wie eine Person Briefe fälschlicherweise in Umschläge stecken kann,\n    * sodass jeder Brief im falschen Umschlag landet.\n    *\n    * Dies basiert auf einem Problem der Fehlanordnung, bei dem jedes Element (Brief) nicht an seinem ursprünglichen\n    * Platz (Umschlag) sein darf.\n    *\n    * Parameter:\n    * n - die Anzahl der Briefe und Umschläge.\n    *\n    * Rückgabewert:\n    * Die Gesamtanzahl der Möglichkeiten, alle Briefe falsch zu platzieren.\n    *\n    * Beispiele:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "ha": "/**\n    * Lissafi yawan hanyoyin da mutum zai iya kuskure wajen sanya wasiku a cikin kwantena\n    * ta yadda kowace wasika za ta kare a cikin kwantena mara daidai.\n    *\n    * Wannan yana dogara ne akan matsalar derangement inda dole ne kowane abu (wasika)\n    * kada ya kasance a cikin matsayinsa na asali (kwantena).\n    *\n    * Sigogi:\n    * n - yawan wasiku da kwantena.\n    *\n    * Komawa:\n    * Jimillar yawan hanyoyin da za a sanya dukkan wasiku ba daidai ba.\n    *\n    * Misalai:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "hi": "/**\n    * गणना करें कि एक व्यक्ति कितने तरीकों से गलती से पत्रों को लिफाफों में डाल सकता है\n    * ताकि प्रत्येक पत्र गलत लिफाफे में समाप्त हो जाए।\n    *\n    * यह एक अव्यवस्था समस्या पर आधारित है जहाँ प्रत्येक वस्तु (पत्र) अपनी मूल स्थिति (लिफाफा) में नहीं होनी चाहिए।\n    *\n    * पैरामीटर्स:\n    * n - पत्रों और लिफाफों की संख्या।\n    *\n    * रिटर्न करता है:\n    * सभी पत्रों को गलत तरीके से रखने के कुल तरीकों की संख्या।\n    *\n    * उदाहरण:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "hu": "/**\n    * Számolja ki, hányféleképpen tehet egy személy hibásan leveleket borítékokba\n    * úgy, hogy minden levél rossz borítékba kerüljön.\n    *\n    * Ez egy elrendezési probléma alapján történik, ahol minden elemnek (levélnek) nem szabad\n    * az eredeti helyén (borítékban) lennie.\n    *\n    * Paraméterek:\n    * n - a levelek és borítékok száma.\n    *\n    * Visszatér:\n    * Az összes levél hibás elhelyezésének összes módja.\n    *\n    * Példák:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9660852528509601",
      "hy": "0.9609937602938928",
      "bn": "0.9210805742679803",
      "bg": "0.9587843945656417",
      "zh": "0.9442486232815086",
      "fr": "0.9664709930509299",
      "de": "0.9446486648689129",
      "ha": "0.9592209841431564",
      "hi": "0.9573673654273388",
      "hu": "0.9286072752965353"
    },
    "canonical_solution": "{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}",
    "instruction": {
      "en": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nПредоставете кратко описание на естествен език (docstring) на Kotlin кода на български, използвайки не повече от 500 знака.",
      "zh": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\n请用中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun countWrongEnvelopeCombinations(n: Int): Long\n{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.9192833665803767",
      "bn": "0.8738053517993907",
      "bg": "0.9362722230702906",
      "zh": "0.8901365430976982",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9250790038382126",
      "hi": "0.8761702451159921",
      "hu": "0.9436378348598263"
    },
    "level": "",
    "test": "fun main() {\n    check(countWrongEnvelopeCombinations(2) == 1L)\n    check(countWrongEnvelopeCombinations(3) == 2L)\n    check(countWrongEnvelopeCombinations(4) == 9L) // Additional test case for 4 letters\n    check(countWrongEnvelopeCombinations(5) == 44L) // Additional test case for 5 letters\n    check(countWrongEnvelopeCombinations(15) == 481066515734L) // Additional test case for 15 letters\n}\nmain()",
    "entry_point": "countWrongEnvelopeCombinations",
    "signature": "fun countWrongEnvelopeCombinations(n: Int): Long",
    "docstring": {
      "en": "Calculate the number of ways a person can mistakenly put letters in envelopes\nsuch that each letter ends up in the wrong envelope.\n\nThis is based on a derangement problem where each item (letter) must not be\nin its original position (envelope).\n\nParameters:\nn - the number of letters and envelopes.\n\nReturns:\nThe total number of ways to wrongly place all the letters.\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "sq": "Llogarit numrin e mënyrave se si një person mund të vendosë gabimisht letra në zarfe\nnë mënyrë që secila letër të përfundojë në zarfin e gabuar.\n\nKjo bazohet në një problem të çrregullimit ku secili artikull (letër) nuk duhet të jetë\nnë pozicionin e tij origjinal (zarf).\n\nParametrat:\nn - numri i letrave dhe zarfeve.\n\nKthen:\nNumri total i mënyrave për të vendosur gabimisht të gjitha letrat.\n\nShembuj:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "hy": "Հաշվել, թե քանի եղանակով մարդը կարող է սխալմամբ նամակները տեղադրել ծրարների մեջ այնպես, որ յուրաքանչյուր նամակ հայտնվի սխալ ծրարում:\n\nՍա հիմնված է դերանգման խնդրի վրա, որտեղ յուրաքանչյուր տարր (նամակ) չպետք է լինի իր սկզբնական դիրքում (ծրար):\n\nՊարամետրեր:\nn - նամակների և ծրարների քանակը:\n\nՎերադարձնում է:\nԲոլոր նամակները սխալ տեղադրելու եղանակների ընդհանուր քանակը:\n\nՕրինակներ:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "bn": "খামগুলিতে চিঠি ভুলভাবে রাখার উপায়ের সংখ্যা গণনা করুন\nযাতে প্রতিটি চিঠি ভুল খামে শেষ হয়।\n\nএটি একটি অব্যবস্থা সমস্যার উপর ভিত্তি করে যেখানে প্রতিটি আইটেম (চিঠি) অবশ্যই তার মূল অবস্থানে (খাম) থাকা উচিত নয়।\n\nপ্যারামিটার:\nn - চিঠি এবং খামের সংখ্যা।\n\nফেরত দেয়:\nসব চিঠি ভুলভাবে রাখার মোট উপায়ের সংখ্যা।\n\nউদাহরণ:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "bg": "Изчислете броя на начините, по които човек може погрешно да постави писма в пликове така, че всяко писмо да се окаже в грешен плик.\n\nТова се основава на задача за разместване, където всеки елемент (писмо) не трябва да бъде в първоначалната си позиция (плик).\n\nПараметри:\nn - броят на писмата и пликовете.\n\nВръща:\nОбщият брой начини за неправилно поставяне на всички писма.\n\nПримери:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "zh": "计算一个人错误地将信件放入信封的方式数量，使得每封信都放错信封。\n\n这是基于一个错排问题，其中每个项目（信件）都不能在其原始位置（信封）中。\n\n参数：\nn - 信件和信封的数量。\n\n返回：\n错误放置所有信件的总方式数量。\n\n示例：\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "fr": "Calculer le nombre de façons dont une personne peut mettre par erreur des lettres dans des enveloppes\nde telle sorte que chaque lettre se retrouve dans la mauvaise enveloppe.\n\nCeci est basé sur un problème de dérangement où chaque élément (lettre) ne doit pas être\ndans sa position d'origine (enveloppe).\n\nParamètres:\nn - le nombre de lettres et d'enveloppes.\n\nRenvoie:\nLe nombre total de façons de placer incorrectement toutes les lettres.\n\nExemples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "de": "Berechne die Anzahl der Möglichkeiten, wie eine Person fälschlicherweise Briefe in Umschläge stecken kann, sodass jeder Brief im falschen Umschlag landet.\n\nDies basiert auf einem Problem der Fehlanordnung, bei dem jedes Element (Brief) nicht an seiner ursprünglichen Position (Umschlag) sein darf.\n\nParameter:\nn - die Anzahl der Briefe und Umschläge.\n\nRückgabewert:\nDie Gesamtanzahl der Möglichkeiten, alle Briefe falsch zu platzieren.\n\nBeispiele:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "ha": "Ƙididdige yawan hanyoyin da mutum zai iya kuskure wajen sanya wasiƙu a cikin ambulan\nta yadda kowace wasiƙa za ta ƙare a cikin ambulan da ba daidai ba.\n\nWannan yana dogara ne akan matsalar derangement inda dole ne kowace abu (wasiƙa) ba za ta kasance a cikin matsayinta na asali ba (ambulan).\n\nSigogi:\nn - yawan wasiƙu da ambulan.\n\nDawowa:\nJimillar yawan hanyoyin da za a sanya duk wasiƙun da ba daidai ba.\n\nMisalai:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "hi": "गणना करें कि कितने तरीकों से एक व्यक्ति गलती से पत्रों को लिफाफों में डाल सकता है\nताकि प्रत्येक पत्र गलत लिफाफे में समाप्त हो जाए।\n\nयह एक विस्थापन समस्या पर आधारित है जहाँ प्रत्येक वस्तु (पत्र) अपने मूल स्थान (लिफाफा) में नहीं होनी चाहिए।\n\nParameters:\nn - पत्रों और लिफाफों की संख्या।\n\nReturns:\nसभी पत्रों को गलत तरीके से रखने के कुल तरीके।\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "hu": "Számítsa ki, hányféleképpen tehet egy személy hibásan leveleket borítékokba úgy, hogy minden levél rossz borítékba kerüljön.\n\nEz egy elrendezési probléma, ahol minden elemnek (levélnek) nem szabad az eredeti helyén (borítékban) lennie.\n\nParaméterek:\nn - a levelek és borítékok száma.\n\nVisszatér:\nA levelek hibás elhelyezésének összes lehetséges módja.\n\nPéldák:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9932024711002241",
      "hy": "0.9868907921124594",
      "bn": "0.9608749793260339",
      "bg": "0.9851728379468887",
      "zh": "0.971151717980017",
      "fr": "0.9933554164936209",
      "de": "0.976953711410046",
      "ha": "0.9883251020939123",
      "hi": "0.9689385782745262",
      "hu": "0.9386136780019299"
    }
  },
  {
    "task_id": "Kotlin/23",
    "prompt": {
      "en": "/**\n * Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\n * It is required that all three denominations are used in the exchange.\n * Example:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "sq": "/**\n * Llogarit numrin e mënyrave për të shkëmbyer një shumë të caktuar parash (më shumë se 10 njësi) në denominime prej 5, 2, dhe 1 njësi.\n * Kërkohet që të përdoren të tre denominimet në shkëmbim.\n * Shembull:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "hy": "/**\n * Հաշվում է, թե քանի ձևով կարելի է փոխանակել տրված գումարը (ավելի քան 10 միավոր) 5, 2 և 1 միավորանոց դրամանիշներով:\n * Պահանջվում է, որ փոխանակման մեջ օգտագործվեն բոլոր երեք դրամանիշները:\n * Օրինակ:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "bn": "/**\n * একটি নির্দিষ্ট পরিমাণ অর্থ (১০ ইউনিটের বেশি) ৫, ২, এবং ১ ইউনিটের মুদ্রায় বিনিময় করার উপায়ের সংখ্যা গণনা করে।\n * এটি প্রয়োজন যে বিনিময়ে সব তিনটি মুদ্রা ব্যবহার করা হয়।\n * উদাহরণ:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "bg": "/**\n * Изчислява броя на начините за обмен на дадена сума пари (повече от 10 единици) в номинали от 5, 2 и 1 единици.\n * Изисква се всички три номинала да бъдат използвани в обмена.\n * Пример:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "zh": "/**\n * 计算将给定金额（超过10单位）兑换成5、2和1单位面额的方法数。\n * 要求在兑换中使用所有三种面额。\n * 示例:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "fr": "/**\n * Calcule le nombre de façons d'échanger une somme d'argent donnée (plus de 10 unités) en dénominations de 5, 2 et 1 unité.\n * Il est requis que les trois dénominations soient utilisées dans l'échange.\n * Exemple:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "de": "/**\n * Berechnet die Anzahl der Möglichkeiten, einen gegebenen Geldbetrag (mehr als 10 Einheiten) in 5-, 2- und 1-Einheiten umzutauschen.\n * Es ist erforderlich, dass alle drei Stückelungen beim Umtausch verwendet werden.\n * Beispiel:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "ha": "/**\n * Lissafa yawan hanyoyin da za a iya musanya wani adadin kudi (fiye da raka'a 10) zuwa cikin raka'a 5, 2, da 1.\n * Ana bukatar a yi amfani da dukkan raka'o'in uku a cikin musanyar.\n * Misali:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "hi": "/**\n * एक दिए गए राशि (10 इकाइयों से अधिक) को 5, 2, और 1 इकाई के मूल्यवर्ग में बदलने के तरीकों की संख्या की गणना करता है।\n * यह आवश्यक है कि विनिमय में सभी तीन मूल्यवर्ग का उपयोग किया जाए।\n * उदाहरण:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "hu": "/**\n * Kiszámítja, hányféleképpen lehet egy adott pénzösszeget (több mint 10 egység) 5, 2 és 1 egységnyi címletekre váltani.\n * Szükséges, hogy mindhárom címletet használjuk a váltás során.\n * Példa:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9280558773587825",
      "hy": "0.9070799132303552",
      "bn": "0.9228863230619685",
      "bg": "0.945992995287757",
      "zh": "0.9310393056819265",
      "fr": "0.9453798233015023",
      "de": "0.944871329526053",
      "ha": "0.9025676268643856",
      "hi": "0.9422263673721925",
      "hu": "0.9412908182775181"
    },
    "canonical_solution": "{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}",
    "instruction": {
      "en": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nकॉटलिन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun countExchangeWays(amount: Int): Int\n{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9417669353008588",
      "bn": "0.8929145876068522",
      "bg": "0.8383597137705134",
      "zh": "0.853715080539998",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.9248690515254587",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n\n    check(countExchangeWays(50) == 106)\n    check(countExchangeWays(20) == 13)\n    check(countExchangeWays(15) == 6)\n    check(countExchangeWays(12) == 3)\n\n}\n\nmain()",
    "entry_point": "countExchangeWays",
    "signature": "fun countExchangeWays(amount: Int): Int",
    "docstring": {
      "en": "Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\nIt is required that all three denominations are used in the exchange.\nExample:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "sq": "Llogarit numrin e mënyrave për të shkëmbyer një shumë të caktuar parash (më shumë se 10 njësi) në denominime prej 5, 2 dhe 1 njësi.\nKërkohet që të përdoren të treja denominimet në shkëmbim.\nShembull:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "hy": "Հաշվում է գումարի փոխանակման եղանակների քանակը (ավելի քան 10 միավոր) 5, 2 և 1 միավոր անվանական արժեքներով:\nՊահանջվում է, որ փոխանակման մեջ օգտագործվեն բոլոր երեք անվանական արժեքները:\nՕրինակ:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "bn": "একটি নির্দিষ্ট পরিমাণ অর্থ (১০ ইউনিটের বেশি) ৫, ২, এবং ১ ইউনিটের মুদ্রায় বিনিময় করার উপায়ের সংখ্যা গণনা করে। বিনিময়ে সমস্ত তিনটি মুদ্রা ব্যবহার করা আবশ্যক।\n\nউদাহরণ:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "bg": "Изчислява броя на начините за обмен на дадена сума пари (повече от 10 единици) в деноминации от 5, 2 и 1 единица. Изисква се всички три деноминации да бъдат използвани в обмена.\nПример:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "zh": "计算将给定金额（超过10个单位）兑换成5、2和1单位面额的方法数量。  \n要求在兑换中使用所有三种面额。\n\n示例：\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "fr": "Calcule le nombre de façons d'échanger une somme d'argent donnée (plus de 10 unités) en dénominations de 5, 2 et 1 unité. Il est nécessaire que les trois dénominations soient utilisées dans l'échange.\nExemple :\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "de": "Berechnet die Anzahl der Möglichkeiten, einen gegebenen Geldbetrag (mehr als 10 Einheiten) in 5-, 2- und 1-Einheit-Denominationen zu tauschen.\nEs ist erforderlich, dass alle drei Denominationen im Austausch verwendet werden.\nBeispiel:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "ha": "Yana ƙididdige yawan hanyoyin musanya adadin kuɗi da aka bayar (fiye da raka'a 10) zuwa cikin raka'a 5, 2, da 1.\nAna buƙatar a yi amfani da dukkanin raka'a uku a cikin musayar.\nMisali:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "hi": "दिए गए धनराशि (10 इकाइयों से अधिक) को 5, 2, और 1 इकाई के मूल्यवर्ग में बदलने के तरीकों की संख्या की गणना करता है। यह आवश्यक है कि विनिमय में सभी तीन मूल्यवर्गों का उपयोग किया जाए।\nउदाहरण:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "hu": "Kiszámítja, hányféleképpen lehet egy adott pénzösszeget (több mint 10 egység) 5, 2 és 1 egységnyi címletekre váltani.\nSzükséges, hogy mindhárom címletet használják a váltás során.\nPélda:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13"
    },
    "docstring_bertscore": {
      "sq": "0.9631778999637525",
      "hy": "0.9621203918151227",
      "bn": "0.9128084134194013",
      "bg": "0.9820283203847254",
      "zh": "0.9598091287014007",
      "fr": "0.9742912697826545",
      "de": "0.9822946837256932",
      "ha": "0.9419421272969315",
      "hi": "0.9473661271118512",
      "hu": "0.9673264941020471"
    }
  },
  {
    "task_id": "Kotlin/24",
    "prompt": {
      "en": "/**\n    * Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\n    * Hours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n    * \n    * Example:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "sq": "/**\n    * Shton dy kohë së bashku. Çdo kohë përfaqësohet si një Triple e orëve, minutave dhe sekondave.\n    * Orët, minutat dhe sekondat normalizohen për të siguruar që minutat dhe sekondat janë brenda 0 deri në 59.\n    * \n    * Shembull:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "hy": "/**\n    * Գումարում է երկու ժամանակներ: Յուրաքանչյուր ժամանակ ներկայացված է ժամերի, րոպեների և վայրկյանների եռյակով:\n    * Ժամերը, րոպեները և վայրկյանները նորմալացվում են՝ ապահովելու համար, որ րոպեները և վայրկյանները լինեն 0-ից 59 միջակայքում:\n    * \n    * Օրինակ:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "bn": "/**\n    * দুটি সময় একত্রিত করে। প্রতিটি সময় ঘন্টা, মিনিট এবং সেকেন্ডের Triple হিসাবে উপস্থাপিত হয়।\n    * ঘন্টা, মিনিট এবং সেকেন্ডকে স্বাভাবিকীকৃত করা হয় যাতে মিনিট এবং সেকেন্ড 0 থেকে 59 এর মধ্যে থাকে।\n    * \n    * উদাহরণ:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "bg": "/**\n    * Събира две времена. Всяко време е представено като Triple от часове, минути и секунди.\n    * Часовете, минутите и секундите са нормализирани, за да се гарантира, че минутите и секундите са в диапазона от 0 до 59.\n    * \n    * Пример:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "zh": "/**\n    * 将两个时间相加。每个时间表示为小时、分钟和秒的三元组。\n    * 小时、分钟和秒被规范化以确保分钟和秒在0到59之间。\n    * \n    * 例子:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "fr": "/**\n    * Ajoute deux temps ensemble. Chaque temps est représenté comme un Triple d'heures, de minutes et de secondes.\n    * Les heures, minutes et secondes sont normalisées pour s'assurer que les minutes et secondes sont comprises entre 0 et 59.\n    * \n    * Exemple:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "de": "/**\n    * Addiert zwei Zeiten miteinander. Jede Zeit wird als Triple von Stunden, Minuten und Sekunden dargestellt.\n    * Stunden, Minuten und Sekunden werden normalisiert, um sicherzustellen, dass Minuten und Sekunden im Bereich von 0 bis 59 liegen.\n    * \n    * Beispiel:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "ha": "/**\n    * Ƙara lokuta biyu tare. Kowanne lokaci an wakilta shi azaman Triple na awanni, mintuna, da dakiku.\n    * Ana daidaita awanni, mintuna, da dakiku don tabbatar da cewa mintuna da dakiku suna tsakanin 0 zuwa 59.\n    * \n    * Misali:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "hi": "/**\n    * दो समयों को एक साथ जोड़ता है। प्रत्येक समय घंटों, मिनटों और सेकंडों के ट्रिपल के रूप में दर्शाया जाता है।\n    * घंटों, मिनटों और सेकंडों को सामान्यीकृत किया जाता है ताकि मिनट और सेकंड 0 से 59 के बीच हों।\n    * \n    * उदाहरण:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "hu": "/**\n    * Két időpontot ad össze. Minden időpont órák, percek és másodpercek hármasaként van ábrázolva.\n    * Az órák, percek és másodpercek normalizálva vannak annak biztosítására, hogy a percek és másodpercek 0 és 59 között legyenek.\n    * \n    * Példa:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9260614297028111",
      "hy": "0.9006528299912093",
      "bn": "0.9111593839960497",
      "bg": "0.906606577032349",
      "zh": "0.9115218844414383",
      "fr": "0.9094686421926808",
      "de": "0.9064423097072332",
      "ha": "0.9142828467378233",
      "hi": "0.91620539019586",
      "hu": "0.8978366484488967"
    },
    "canonical_solution": "{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}",
    "instruction": {
      "en": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nՏվեք հակիրճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nনিম্নলিখিত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\n请用最多500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Kotlin a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nकृपया निम्नलिखित Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>\n{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9459955774827105",
      "hy": "0.9026051680064012",
      "bn": "0.8822429717553717",
      "bg": "0.8383597137705134",
      "zh": "0.8815686216117583",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9191087704754469",
      "hi": "0.8742320098578537",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n\n\ncheck(addTimes(Triple(1, 2, 3), Triple(4, 5, 6)) == Triple(5, 7, 9))\ncheck(addTimes(Triple(23, 59, 59), Triple(0, 0, 1)) == Triple(24, 0, 0))\ncheck(addTimes(Triple(10, 30, 30), Triple(2, 35, 40)) == Triple(13, 6, 10))\ncheck(addTimes(Triple(0, 0, 0), Triple(0, 0, 0)) == Triple(0, 0, 0))\n\n}\n\nmain()",
    "entry_point": "addTimes",
    "signature": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\nHours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n\nExample:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "sq": "Shton dy kohë së bashku. Çdo kohë përfaqësohet si një Triple e orëve, minutave dhe sekondave. Orët, minutat dhe sekondat normalizohen për të siguruar që minutat dhe sekondat të jenë brenda 0 deri në 59.\n\nShembull:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hy": "Երկու ժամանակներ գումարում է իրար: Յուրաքանչյուր ժամանակ ներկայացված է որպես ժամերի, րոպեների և վայրկյանների եռյակ:\nԺամերը, րոպեներն ու վայրկյանները նորմալացվում են՝ ապահովելու համար, որ րոպեները և վայրկյանները լինեն 0-ից 59 միջակայքում:\n\nՕրինակ:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "bn": "দুটি সময় একসাথে যোগ করে। প্রতিটি সময় ঘন্টা, মিনিট এবং সেকেন্ডের ট্রিপল হিসাবে উপস্থাপিত হয়। ঘন্টা, মিনিট এবং সেকেন্ডকে স্বাভাবিক করা হয় যাতে মিনিট এবং সেকেন্ড ০ থেকে ৫৯ এর মধ্যে থাকে।\n\nউদাহরণ:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "bg": "Събира две времена заедно. Всяко време е представено като Тройка от часове, минути и секунди. Часовете, минутите и секундите са нормализирани, за да се гарантира, че минутите и секундите са в диапазона от 0 до 59.\n\nПример:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "zh": "将两个时间相加。每个时间表示为一个包含小时、分钟和秒的三元组。\n小时、分钟和秒会被规范化，以确保分钟和秒在0到59之间。\n\n示例：\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "fr": "Ajoute deux temps ensemble. Chaque temps est représenté comme un Triple d'heures, minutes et secondes.\nLes heures, minutes et secondes sont normalisées pour s'assurer que les minutes et secondes sont comprises entre 0 et 59.\n\nExemple :\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "de": "Addiert zwei Zeiten zusammen. Jede Zeit wird als Triple von Stunden, Minuten und Sekunden dargestellt.\nStunden, Minuten und Sekunden werden normalisiert, um sicherzustellen, dass Minuten und Sekunden zwischen 0 und 59 liegen.\n\nBeispiel:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "ha": "Ƙara lokuta biyu tare. Kowanne lokaci an wakilta shi azaman Triple na awanni, mintuna, da dakiku. Awanni, mintuna, da dakiku suna daidaitawa don tabbatar da cewa mintuna da dakiku suna tsakanin 0 zuwa 59.\n\nMisali:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hi": "दो समय को एक साथ जोड़ता है। प्रत्येक समय को घंटों, मिनटों, और सेकंडों के ट्रिपल के रूप में प्रस्तुत किया जाता है। घंटों, मिनटों, और सेकंडों को सामान्यीकृत किया जाता है ताकि मिनट और सेकंड 0 से 59 के भीतर हों।\n\nउदाहरण:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hu": "Két időpontot ad össze. Minden időpont egy hármas (Triple) formájában van megadva, amely órákból, percekből és másodpercekből áll. Az órák, percek és másodpercek normalizálva vannak annak biztosítására, hogy a percek és másodpercek 0 és 59 között legyenek.\n\nPélda:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9886677395011976",
      "hy": "0.967735672686979",
      "bn": "0.9818676284064681",
      "bg": "0.9695364557214413",
      "zh": "0.9812044015641926",
      "fr": "0.9753859218125377",
      "de": "0.9871353061115133",
      "ha": "0.9811487850575029",
      "hi": "0.9851190091136283",
      "hu": "0.9446071511192766"
    }
  },
  {
    "task_id": "Kotlin/25",
    "prompt": {
      "en": "/**\n    * Finds the mode (most frequent element) and its count in a given list of integers.\n    * If there are multiple modes, the smallest one is returned.\n    *\n    * Example:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 is the mode and it appears 3 times\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Both 1 and 3 are modes but 1 is smaller\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "sq": "/**\n    * Gjen modalitetin (elementin më të shpeshtë) dhe numrin e tij në një listë të dhënë të numrave të plotë.\n    * Nëse ka modalitete të shumta, kthehet më i vogli.\n    *\n    * Shembull:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 është modaliteti dhe shfaqet 3 herë\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Të dy 1 dhe 3 janë modalitete por 1 është më i vogël\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "hy": "/**\n    * Գտնում է մոդան (ամենահաճախ հանդիպող տարրը) և դրա քանակը տրված ամբողջ թվերի ցուցակում:\n    * Եթե կան բազմաթիվ մոդաներ, վերադարձվում է ամենափոքրն:\n    *\n    * Օրինակ:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2-ը մոդան է և այն հանդիպում է 3 անգամ\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // 1 և 3 երկուսն էլ մոդաներ են, բայց 1-ը փոքր է\n**/",
      "bn": "/**\n    * একটি প্রদত্ত পূর্ণসংখ্যার তালিকায় মোড (সবচেয়ে ঘন ঘন উপাদান) এবং এর গণনা খুঁজে বের করে।\n    * যদি একাধিক মোড থাকে, তাহলে সবচেয়ে ছোটটি ফেরত দেওয়া হয়।\n    *\n    * উদাহরণ:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 হল মোড এবং এটি 3 বার প্রদর্শিত হয়\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // 1 এবং 3 উভয়ই মোড কিন্তু 1 ছোট\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "bg": "/**\n    * Намира модата (най-често срещания елемент) и броя му в даден списък от цели числа.\n    * Ако има няколко моди, се връща най-малката.\n    *\n    * Пример:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 е модата и се появява 3 пъти\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // И 1, и 3 са моди, но 1 е по-малка\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "zh": "/**\n    * 查找给定整数列表中的众数（最频繁出现的元素）及其计数。\n    * 如果有多个众数，返回最小的那个。\n    *\n    * 示例:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 是众数，出现了 3 次\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // 1 和 3 都是众数，但 1 更小\n**/",
      "fr": "/**\n    * Trouve la mode (élément le plus fréquent) et son compte dans une liste donnée d'entiers.\n    * S'il y a plusieurs modes, le plus petit est retourné.\n    *\n    * Exemple :\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 est la mode et il apparaît 3 fois\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Les deux 1 et 3 sont des modes mais 1 est plus petit\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "de": "/**\n    * Findet den Modus (häufigstes Element) und dessen Anzahl in einer gegebenen Liste von ganzen Zahlen.\n    * Wenn es mehrere Modi gibt, wird der kleinste zurückgegeben.\n    *\n    * Beispiel:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 ist der Modus und erscheint 3 Mal\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Sowohl 1 als auch 3 sind Modi, aber 1 ist kleiner\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "ha": "/**\n    * Nemi yanayin (abin da ya fi yawan faruwa) da adadinsa a cikin jerin lambobin kirga da aka bayar.\n    * Idan akwai yanayi da yawa, mafi ƙarami ne ake dawowa da shi.\n    *\n    * Misali:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 shi ne yanayin kuma ya bayyana sau 3\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Duk 1 da 3 su ne yanayi amma 1 ya fi ƙanƙanta\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "hi": "/**\n    * एक दी गई पूर्णांकों की सूची में मोड (सबसे अधिक बार आने वाला तत्व) और उसकी गिनती खोजता है।\n    * यदि कई मोड हैं, तो सबसे छोटा लौटाया जाता है।\n    *\n    * उदाहरण:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 मोड है और यह 3 बार आता है\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // 1 और 3 दोनों मोड हैं लेकिन 1 छोटा है\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "hu": "/**\n    * Megkeresi a móduszt (leggyakrabban előforduló elem) és annak előfordulási számát egy adott egész számokat tartalmazó listában.\n    * Ha több módusz is van, a legkisebbet adja vissza.\n    *\n    * Példa:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 a módusz és 3-szor fordul elő\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Mind az 1, mind a 3 módusz, de az 1 a kisebb\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> "
    },
    "prompt_bertscore": {
      "sq": "0.9968145645793435",
      "hy": "0.9407934478034068",
      "bn": "1",
      "bg": "0.9932261081155672",
      "zh": "0.9332317878277896",
      "fr": "1",
      "de": "0.9927148335147834",
      "ha": "0.9891128701850967",
      "hi": "0.9874670188478417",
      "hu": "0.985174426989937"
    },
    "canonical_solution": "{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}",
    "instruction": {
      "en": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nনিচের Kotlin কোডটির একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\n将以下Kotlin代码的功能用中文自然语言简洁描述（文档字符串），不超过500个字符。",
      "fr": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>\n{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9363047984527804",
      "hy": "0.9478766071911109",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8336671175517657",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(findModeAndCount(listOf(1, 2, 2, 2, 3, 5)) == Pair(2, 3))\n    check(findModeAndCount(listOf(1, 1, 2, 3, 3)) == Pair(1, 2))\n    check(findModeAndCount(listOf(4, 4, 4, 5, 5, 6, 6, 6)) == Pair(4, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9)) == Pair(9, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9, 1, 1, 1, 1, 1)) == Pair(1, 5))\n}\n\nmain()",
    "entry_point": "findModeAndCount",
    "signature": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>",
    "docstring": {
      "en": "Finds the mode (most frequent element) and its count in a given list of integers.\nIf there are multiple modes, the smallest one is returned.\n\nExample:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 is the mode and it appears 3 times\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Both 1 and 3 are modes but 1 is smaller",
      "sq": "Gjen modalitetin (elementin më të shpeshtë) dhe numrin e tij në një listë të dhënë të numrave të plotë. Nëse ka modalitete të shumta, kthehet më i vogli.\n\nShembull:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 është modaliteti dhe shfaqet 3 herë\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Të dy 1 dhe 3 janë modalitete por 1 është më i vogël",
      "hy": "Գտնում է մոդան (ամենահաճախ հանդիպող տարրը) և դրա քանակը տրված ամբողջ թվերի ցուցակում։\nԵթե կան բազմաթիվ մոդաներ, վերադարձվում է ամենափոքրը։\n\nՕրինակ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2-ը մոդան է և այն հանդիպում է 3 անգամ\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 և 3 երկուսն էլ մոդաներ են, բայց 1-ը փոքր է",
      "bn": "প্রদত্ত পূর্ণসংখ্যার তালিকায় মোড (সবচেয়ে ঘন ঘন উপস্থিত উপাদান) এবং এর গণনা খুঁজে বের করে। যদি একাধিক মোড থাকে, তবে সবচেয়ে ছোটটি ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 হল মোড এবং এটি 3 বার উপস্থিত হয়\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 এবং 3 উভয়ই মোড কিন্তু 1 ছোট",
      "bg": "Намира модата (най-често срещания елемент) и броя му в даден списък от цели числа.  \nАко има няколко моди, се връща най-малката.\n\nПример:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 е модата и се появява 3 пъти\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // И 1, и 3 са моди, но 1 е по-малка",
      "zh": "查找给定整数列表中出现频率最高的元素（众数）及其出现次数。\n如果有多个众数，则返回最小的那个。\n\n示例：\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 是众数，出现了 3 次\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 和 3 都是众数，但 1 更小",
      "fr": "Trouve la mode (élément le plus fréquent) et son compte dans une liste donnée d'entiers.\nS'il y a plusieurs modes, le plus petit est retourné.\n\nExemple :\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 est la mode et il apparaît 3 fois\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Les deux 1 et 3 sont des modes mais 1 est plus petit",
      "de": "Findet den Modus (häufigstes Element) und dessen Anzahl in einer gegebenen Liste von ganzen Zahlen.\nWenn es mehrere Modi gibt, wird der kleinste zurückgegeben.\n\nBeispiel:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 ist der Modus und erscheint 3 Mal\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Sowohl 1 als auch 3 sind Modi, aber 1 ist kleiner",
      "ha": "Yana nemo yanayi (mafi yawan abu) da adadinsa a cikin jerin lambobi na cikakke da aka bayar.\nIdan akwai yanayi da yawa, mafi ƙarancin ɗaya ne ake dawowa.\n\nMisali:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 shine yanayi kuma yana bayyana sau 3\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Duk 1 da 3 yanayi ne amma 1 ya fi ƙanƙanta",
      "hi": "दिए गए पूर्णांकों की सूची में मोड (सबसे अधिक बार आने वाला तत्व) और उसकी गणना खोजता है।  \nयदि कई मोड हैं, तो सबसे छोटा लौटाया जाता है।\n\nउदाहरण:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 मोड है और यह 3 बार आता है\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 और 3 दोनों मोड हैं लेकिन 1 छोटा है",
      "hu": "Megkeresi a móduszt (leggyakrabban előforduló elemet) és annak számát egy adott egész számokat tartalmazó listában.\nHa több módusz van, a legkisebbet adja vissza.\n\nPélda:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 a módusz és 3-szor fordul elő\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Mind az 1, mind a 3 módusz, de az 1 kisebb"
    },
    "docstring_bertscore": {
      "sq": "0.9820672519394082",
      "hy": "0.9786396860842702",
      "bn": "0.9843795082050354",
      "bg": "0.9921211273058701",
      "zh": "0.9525934828495464",
      "fr": "0.9944063698396766",
      "de": "0.9959131799102072",
      "ha": "1",
      "hi": "0.9895875967957701",
      "hu": "0.9854558862398635"
    }
  },
  {
    "task_id": "Kotlin/26",
    "prompt": {
      "en": "/**\n * Processes a given 2D array representing an image, applying a series of operations.\n * Each operation is represented by a character:\n * 'A' - Rotate the image 90 degrees clockwise.\n * 'B' - Rotate the image 90 degrees counterclockwise.\n * 'C' - Flip the image horizontally.\n * 'D' - Flip the image vertically.\n *\n * @param image A 2D array of integers representing the image's pixel grayscale values.\n * @param operations A string of characters representing the operations to be applied in sequence.\n * @return A 2D array of integers representing the processed image.\n *\n * Example:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "sq": "/**\n * Përpunon një varg 2D të dhënë që përfaqëson një imazh, duke aplikuar një seri operacionesh.\n * Çdo operacion përfaqësohet nga një karakter:\n * 'A' - Rrotullo imazhin 90 gradë në drejtim të akrepave të orës.\n * 'B' - Rrotullo imazhin 90 gradë kundër drejtimit të akrepave të orës.\n * 'C' - Përmbys imazhin horizontalisht.\n * 'D' - Përmbys imazhin vertikalisht.\n *\n * @param image Një varg 2D i numrave të plotë që përfaqëson vlerat e shkallës gri të pikselëve të imazhit.\n * @param operations Një varg karakteresh që përfaqëson operacionet që do të aplikohen në sekuencë.\n * @return Një varg 2D i numrave të plotë që përfaqëson imazhin e përpunuar.\n *\n * Shembull:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "hy": "/**\n * Կատարում է տրված 2D զանգվածի մշակումը, որը ներկայացնում է պատկեր, կիրառելով մի շարք գործողություններ։\n * Յուրաքանչյուր գործողություն ներկայացված է սիմվոլով:\n * 'A' - Պատկերը պտտել 90 աստիճան ժամացույցի սլաքի ուղղությամբ։\n * 'B' - Պատկերը պտտել 90 աստիճան ժամացույցի սլաքի հակառակ ուղղությամբ։\n * 'C' - Պատկերը հորիզոնական շրջել։\n * 'D' - Պատկերը ուղղահայաց շրջել։\n *\n * @param image 2D ամբողջ թվերի զանգված, որը ներկայացնում է պատկերի պիքսելների մոխրագույն արժեքները։\n * @param operations Սիմվոլների տող, որը ներկայացնում է հերթականությամբ կիրառվելիք գործողությունները։\n * @return 2D ամբողջ թվերի զանգված, որը ներկայացնում է մշակված պատկերը։\n *\n * Օրինակ:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "bn": "/**\n * প্রদত্ত 2D অ্যারে যা একটি চিত্রকে উপস্থাপন করে, সেটিকে প্রক্রিয়াকরণ করে একটি সিরিজ অপারেশন প্রয়োগ করা হয়।\n * প্রতিটি অপারেশন একটি অক্ষর দ্বারা উপস্থাপিত হয়:\n * 'A' - চিত্রটিকে 90 ডিগ্রি ঘড়ির কাঁটার দিকে ঘোরান।\n * 'B' - চিত্রটিকে 90 ডিগ্রি ঘড়ির কাঁটার বিপরীতে ঘোরান।\n * 'C' - চিত্রটিকে অনুভূমিকভাবে উল্টান।\n * 'D' - চিত্রটিকে উল্লম্বভাবে উল্টান।\n *\n * @param image পূর্ণসংখ্যার 2D অ্যারে যা চিত্রের পিক্সেলের গ্রেস্কেল মানগুলি উপস্থাপন করে।\n * @param operations একটি অক্ষরের স্ট্রিং যা ক্রমানুসারে প্রয়োগ করার জন্য অপারেশনগুলি উপস্থাপন করে।\n * @return পূর্ণসংখ্যার 2D অ্যারে যা প্রক্রিয়াকৃত চিত্রকে উপস্থাপন করে।\n *\n * উদাহরণ:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "bg": "/**\n * Обработва даден двумерен масив, представляващ изображение, като прилага серия от операции.\n * Всяка операция е представена от символ:\n * 'A' - Завърта изображението на 90 градуса по часовниковата стрелка.\n * 'B' - Завърта изображението на 90 градуса обратно на часовниковата стрелка.\n * 'C' - Обръща изображението хоризонтално.\n * 'D' - Обръща изображението вертикално.\n *\n * @param image Двуизмерен масив от цели числа, представляващ стойностите на сивото на пикселите на изображението.\n * @param operations Низ от символи, представляващи операциите, които трябва да бъдат приложени последователно.\n * @return Двуизмерен масив от цели числа, представляващ обработеното изображение.\n *\n * Пример:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "zh": "/**\n * 处理给定的表示图像的二维数组，应用一系列操作。\n * 每个操作由一个字符表示：\n * 'A' - 将图像顺时针旋转90度。\n * 'B' - 将图像逆时针旋转90度。\n * 'C' - 水平翻转图像。\n * 'D' - 垂直翻转图像。\n *\n * @param image 一个整数的二维数组，表示图像的像素灰度值。\n * @param operations 一个字符的字符串，表示按顺序应用的操作。\n * @return 一个整数的二维数组，表示处理后的图像。\n *\n * 示例:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "fr": "/**\n * Traite un tableau 2D donné représentant une image, en appliquant une série d'opérations.\n * Chaque opération est représentée par un caractère :\n * 'A' - Faire pivoter l'image de 90 degrés dans le sens des aiguilles d'une montre.\n * 'B' - Faire pivoter l'image de 90 degrés dans le sens inverse des aiguilles d'une montre.\n * 'C' - Retourner l'image horizontalement.\n * 'D' - Retourner l'image verticalement.\n *\n * @param image Un tableau 2D d'entiers représentant les valeurs de gris des pixels de l'image.\n * @param operations Une chaîne de caractères représentant les opérations à appliquer en séquence.\n * @return Un tableau 2D d'entiers représentant l'image traitée.\n *\n * Exemple :\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "de": "/**\n * Verarbeitet ein gegebenes 2D-Array, das ein Bild darstellt, und wendet eine Reihe von Operationen an.\n * Jede Operation wird durch ein Zeichen dargestellt:\n * 'A' - Dreht das Bild um 90 Grad im Uhrzeigersinn.\n * 'B' - Dreht das Bild um 90 Grad gegen den Uhrzeigersinn.\n * 'C' - Spiegelt das Bild horizontal.\n * 'D' - Spiegelt das Bild vertikal.\n *\n * @param image Ein 2D-Array von Ganzzahlen, das die Graustufenwerte der Bildpixel darstellt.\n * @param operations Ein String von Zeichen, der die in Folge anzuwendenden Operationen darstellt.\n * @return Ein 2D-Array von Ganzzahlen, das das verarbeitete Bild darstellt.\n *\n * Beispiel:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "ha": "/**\n * Yana aiwatar da wani tsari na 2D da aka bayar wanda ke wakiltar hoto, yana amfani da jerin ayyuka.\n * Kowane aiki yana wakilta ta wata alama:\n * 'A' - Juya hoton digiri 90 a agogo.\n * 'B' - Juya hoton digiri 90 ba a agogo ba.\n * 'C' - Juya hoton a kwance.\n * 'D' - Juya hoton a tsaye.\n *\n * @param image Tsari na 2D na lambobi wanda ke wakiltar ƙimar launin toka na pixel na hoto.\n * @param operations Wata jeri na haruffa da ke wakiltar ayyukan da za a yi a jere.\n * @return Tsari na 2D na lambobi wanda ke wakiltar hoton da aka sarrafa.\n *\n * Misali:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "hi": "/**\n * एक दिए गए 2D array को प्रोसेस करता है जो एक छवि का प्रतिनिधित्व करता है, और एक श्रृंखला में संचालन लागू करता है।\n * प्रत्येक संचालन को एक अक्षर द्वारा दर्शाया गया है:\n * 'A' - छवि को 90 डिग्री घड़ी की दिशा में घुमाएं।\n * 'B' - छवि को 90 डिग्री घड़ी की विपरीत दिशा में घुमाएं।\n * 'C' - छवि को क्षैतिज रूप से पलटें।\n * 'D' - छवि को लंबवत रूप से पलटें।\n *\n * @param image पूर्णांकों का 2D array जो छवि के पिक्सेल ग्रेस्केल मानों का प्रतिनिधित्व करता है।\n * @param operations अक्षरों की एक स्ट्रिंग जो अनुक्रम में लागू होने वाले संचालन का प्रतिनिधित्व करती है।\n * @return पूर्णांकों का 2D array जो प्रोसेस की गई छवि का प्रतिनिधित्व करता है।\n *\n * उदाहरण:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "hu": "/**\n * Feldolgoz egy adott 2D tömböt, amely egy képet ábrázol, és egy sor műveletet alkalmaz.\n * Minden műveletet egy karakter képvisel:\n * 'A' - A képet 90 fokkal az óramutató járásával megegyező irányba forgatja.\n * 'B' - A képet 90 fokkal az óramutató járásával ellentétes irányba forgatja.\n * 'C' - A képet vízszintesen tükrözi.\n * 'D' - A képet függőlegesen tükrözi.\n *\n * @param image Egy 2D egész számokból álló tömb, amely a kép pixeleinek szürkeárnyalatos értékeit ábrázolja.\n * @param operations Egy karakterlánc, amely a sorban alkalmazandó műveleteket képviseli.\n * @return Egy 2D egész számokból álló tömb, amely a feldolgozott képet ábrázolja.\n *\n * Példa:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9534821551742965",
      "hy": "0.9303013938163819",
      "bn": "0.980625989894619",
      "bg": "0.9198566138600434",
      "zh": "0.9417252229208414",
      "fr": "0.9858320921815434",
      "de": "0.9744076671859409",
      "ha": "0.9576297561606859",
      "hi": "0.9512038647038262",
      "hu": "0.9410395508455089"
    },
    "canonical_solution": "{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}",
    "instruction": {
      "en": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nBayar da cikakken bayani a cikin yare na halitta (docstring) game da lambar Kotlin a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>\n{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9417669353008588",
      "bn": "0.8688058251087426",
      "bg": "0.8999760962830234",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.8900586799883325",
      "hi": "0.8761702451159921",
      "hu": "0.9436378348598263"
    },
    "level": "",
    "test": "fun main() {\n    val image1 = arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10))\n    val result1 = processImage(image1, \"AC\")\n    check(result1.contentDeepEquals(arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))))\n\n    val image2 = arrayOf(arrayOf(1, 2), arrayOf(3, 4))\n    val result2 = processImage(image2, \"A\")\n    check(result2.contentDeepEquals(arrayOf(arrayOf(3, 1), arrayOf(4, 2))))\n\n    val result3 = processImage(image2, \"B\")\n    check(result3.contentDeepEquals(arrayOf(arrayOf(2, 4), arrayOf(1, 3))))\n\n    val result4 = processImage(image2, \"BD\")\n    check(result4.contentDeepEquals(arrayOf(arrayOf(1, 3), arrayOf(2, 4))))\n\n}\n\nmain()",
    "entry_point": "processImage",
    "signature": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>",
    "docstring": {
      "en": "Processes a given 2D array representing an image, applying a series of operations.\nEach operation is represented by a character:\n'A' - Rotate the image 90 degrees clockwise.\n'B' - Rotate the image 90 degrees counterclockwise.\n'C' - Flip the image horizontally.\n'D' - Flip the image vertically.\n\n@param image A 2D array of integers representing the image's pixel grayscale values.\n@param operations A string of characters representing the operations to be applied in sequence.\n@return A 2D array of integers representing the processed image.\n\nExample:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "sq": "Përpunon një varg 2D të dhënë që përfaqëson një imazh, duke aplikuar një seri operacionesh. \nÇdo operacion përfaqësohet nga një karakter: \n'A' - Rrotullo imazhin 90 gradë në drejtim të akrepave të orës. \n'B' - Rrotullo imazhin 90 gradë kundër akrepave të orës. \n'C' - Përmbys imazhin horizontalisht. \n'D' - Përmbys imazhin vertikalisht.\n\n@param image Një varg 2D i numrave të plotë që përfaqëson vlerat e shkallës gri të pikselave të imazhit.\n@param operations Një varg karakteresh që përfaqësojnë operacionet që do të aplikohen në sekuencë.\n@return Një varg 2D i numrave të plotë që përfaqëson imazhin e përpunuar.\n\nShembull:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "hy": "Տվյալ 2D զանգվածը, որը ներկայացնում է պատկերը, մշակում է գործողությունների շարք կիրառելով: \nՅուրաքանչյուր գործողություն ներկայացված է սիմվոլով:\n'A' - Պատկերը պտտել 90 աստիճան ժամացույցի սլաքի ուղղությամբ:\n'B' - Պատկերը պտտել 90 աստիճան ժամացույցի սլաքի հակառակ ուղղությամբ:\n'C' - Պատկերը հորիզոնական շրջել:\n'D' - Պատկերը ուղղահայաց շրջել:\n\n@param image Միջակայքի ամբողջ թվերի 2D զանգված, որը ներկայացնում է պատկերի պիքսելների մոխրագույնի արժեքները:\n@param operations Սիմվոլների տող, որը ներկայացնում է հերթականությամբ կիրառվելիք գործողությունները:\n@return Միջակայքի ամբողջ թվերի 2D զանգված, որը ներկայացնում է մշակված պատկերը:\n\nՕրինակ:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "bn": "একটি প্রদত্ত 2D অ্যারে প্রক্রিয়াকরণ করে যা একটি চিত্রকে উপস্থাপন করে, একটি সিরিজ অপারেশন প্রয়োগ করে। প্রতিটি অপারেশন একটি অক্ষর দ্বারা উপস্থাপিত হয়:\n'A' - চিত্রটিকে ৯০ ডিগ্রি ঘড়ির কাঁটার দিকে ঘোরান।\n'B' - চিত্রটিকে ৯০ ডিগ্রি ঘড়ির কাঁটার বিপরীতে ঘোরান।\n'C' - চিত্রটিকে অনুভূমিকভাবে উল্টান।\n'D' - চিত্রটিকে উল্লম্বভাবে উল্টান।\n\n@param image একটি 2D পূর্ণসংখ্যার অ্যারে যা চিত্রের পিক্সেলের গ্রেস্কেল মানগুলি উপস্থাপন করে।\n@param operations একটি অক্ষরের স্ট্রিং যা ক্রমানুসারে প্রয়োগ করার জন্য অপারেশনগুলি উপস্থাপন করে।\n@return একটি 2D পূর্ণসংখ্যার অ্যারে যা প্রক্রিয়াকৃত চিত্রকে উপস্থাপন করে।\n\nউদাহরণ:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "bg": "Обработва даден 2D масив, представляващ изображение, прилагайки серия от операции. Всяка операция е представена от символ: 'A' - Завърта изображението на 90 градуса по часовниковата стрелка. 'B' - Завърта изображението на 90 градуса обратно на часовниковата стрелка. 'C' - Обръща изображението хоризонтално. 'D' - Обръща изображението вертикално.\n\n@param image 2D масив от цели числа, представляващ стойностите на сивото на пикселите на изображението. @param operations Низ от символи, представляващ операциите, които трябва да бъдат приложени последователно. @return 2D масив от цели числа, представляващ обработеното изображение.\n\nПример:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "zh": "处理给定的表示图像的二维数组，应用一系列操作。\n每个操作由一个字符表示：\n'A' - 将图像顺时针旋转90度。  \n'B' - 将图像逆时针旋转90度。  \n'C' - 水平翻转图像。  \n'D' - 垂直翻转图像。\n\n@param image 一个整数的二维数组，表示图像的像素灰度值。  \n@param operations 一个字符字符串，表示按顺序应用的操作。  \n@return 一个整数的二维数组，表示处理后的图像。\n\n示例：\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "fr": "Traite un tableau 2D donné représentant une image, en appliquant une série d'opérations.  \nChaque opération est représentée par un caractère :  \n'A' - Tourner l'image de 90 degrés dans le sens des aiguilles d'une montre.  \n'B' - Tourner l'image de 90 degrés dans le sens inverse des aiguilles d'une montre.  \n'C' - Retourner l'image horizontalement.  \n'D' - Retourner l'image verticalement.  \n\n@param image Un tableau 2D d'entiers représentant les valeurs de gris des pixels de l'image.  \n@param operations Une chaîne de caractères représentant les opérations à appliquer en séquence.  \n@return Un tableau 2D d'entiers représentant l'image traitée.  \n\nExemple :  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "de": "Verarbeitet ein gegebenes 2D-Array, das ein Bild darstellt, und wendet eine Reihe von Operationen an.  \nJede Operation wird durch ein Zeichen dargestellt:  \n'A' - Dreht das Bild um 90 Grad im Uhrzeigersinn.  \n'B' - Dreht das Bild um 90 Grad gegen den Uhrzeigersinn.  \n'C' - Spiegelt das Bild horizontal.  \n'D' - Spiegelt das Bild vertikal.  \n\n@param image Ein 2D-Array von Ganzzahlen, das die Graustufenwerte der Bildpixel darstellt.  \n@param operations Ein String von Zeichen, der die in Reihenfolge anzuwendenden Operationen darstellt.  \n@return Ein 2D-Array von Ganzzahlen, das das verarbeitete Bild darstellt.  \n\nBeispiel:  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))  ",
      "ha": "Yana sarrafa wani tsararren 2D da aka bayar wanda ke wakiltar hoto, yana amfani da jerin ayyuka.\nKowane aiki yana wakilta ta wata alama:  \n'A' - Juya hoton digiri 90 a agogo.  \n'B' - Juya hoton digiri 90 ba a agogo ba.  \n'C' - Juya hoton a kwance.  \n'D' - Juya hoton a tsaye.  \n\n@param image Wani tsari na 2D na lambobi da ke wakiltar ƙimar launin toka na pixel na hoton.  \n@param operations Wani jeren haruffa da ke wakiltar ayyukan da za a yi a jere.  \n@return Wani tsari na 2D na lambobi da ke wakiltar hoton da aka sarrafa.  \n\nExample:  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))  ",
      "hi": "दिए गए 2D एरे को प्रोसेस करता है जो एक छवि का प्रतिनिधित्व करता है, और एक श्रृंखला में संचालन लागू करता है। \nप्रत्येक ऑपरेशन को एक अक्षर द्वारा दर्शाया जाता है:\n'A' - छवि को 90 डिग्री घड़ी की दिशा में घुमाएँ।\n'B' - छवि को 90 डिग्री घड़ी की विपरीत दिशा में घुमाएँ।\n'C' - छवि को क्षैतिज रूप से पलटें।\n'D' - छवि को लंबवत रूप से पलटें।\n\n@param image पूर्णांकों का एक 2D एरे जो छवि के पिक्सेल ग्रेस्केल मानों का प्रतिनिधित्व करता है।\n@param operations अक्षरों की एक स्ट्रिंग जो अनुक्रम में लागू किए जाने वाले ऑपरेशनों का प्रतिनिधित्व करती है।\n@return पूर्णांकों का एक 2D एरे जो प्रोसेस की गई छवि का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "hu": "Egy adott 2D-s tömböt dolgoz fel, amely egy képet ábrázol, és egy sor műveletet alkalmaz.\nMinden műveletet egy karakter képvisel:\n'A' - A képet 90 fokkal az óramutató járásával megegyező irányba forgatja.\n'B' - A képet 90 fokkal az óramutató járásával ellentétes irányba forgatja.\n'C' - A képet vízszintesen tükrözi.\n'D' - A képet függőlegesen tükrözi.\n\n@param image Egy 2D-s tömb, amely a kép pixeleinek szürkeárnyalatos értékeit ábrázolja.\n@param operations Egy karakterlánc, amely a sorban alkalmazandó műveleteket képviseli.\n@return Egy 2D-s tömb, amely a feldolgozott képet ábrázolja.\n\nPélda:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))"
    },
    "docstring_bertscore": {
      "sq": "0.9743184821448562",
      "hy": "0.9636176676273637",
      "bn": "0.9748575649989849",
      "bg": "0.9670035211024843",
      "zh": "0.9671193226146277",
      "fr": "0.9885763695259215",
      "de": "0.9686318929662084",
      "ha": "0.9758676004865473",
      "hi": "0.9884285885224315",
      "hu": "0.9656758756356472"
    }
  },
  {
    "task_id": "Kotlin/27",
    "prompt": {
      "en": "/**\n    * Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\n    * A prime pair is defined as two prime numbers where the difference between them is exactly 2.\n    * Example:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "sq": "/**\n    * Gjen të gjitha çiftet e numrave të thjeshtë ku secili numër i thjeshtë është më i vogël ose i barabartë me një numër të dhënë dhe çifti ndryshon me 2.\n    * Një çift numrash të thjeshtë përcaktohet si dy numra të thjeshtë ku diferenca midis tyre është saktësisht 2.\n    * Shembull:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "hy": "/**\n    * Գտնում է բոլոր պարզ թվերի զույգերը, որտեղ յուրաքանչյուր պարզ թիվ փոքր կամ հավասար է տրված թվին և զույգը տարբերվում է 2-ով:\n    * Պարզ թվերի զույգը սահմանվում է որպես երկու պարզ թվեր, որոնց միջև տարբերությունը հենց 2 է:\n    * Օրինակ:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "bn": "/**\n    * এমন সমস্ত মৌলিক সংখ্যার জোড়া খুঁজে বের করে যেখানে প্রতিটি মৌলিক সংখ্যা একটি প্রদত্ত সংখ্যার চেয়ে কম বা সমান এবং জোড়ার পার্থক্য 2।\n    * একটি মৌলিক জোড়া এমন দুটি মৌলিক সংখ্যা হিসাবে সংজ্ঞায়িত করা হয় যেখানে তাদের মধ্যে পার্থক্য ঠিক 2।\n    * উদাহরণ:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "bg": "/**\n    * Намира всички двойки прости числа, където всяко просто число е по-малко или равно на дадено число и двойката се различава с 2.\n    * Двойка прости числа се дефинира като две прости числа, където разликата между тях е точно 2.\n    * Пример:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "zh": "/**\n    * 查找所有素数对，其中每个素数小于或等于给定的数字，并且该对相差2。\n    * 素数对被定义为两个素数，它们之间的差恰好为2。\n    * 示例:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "fr": "/**\n    * Trouve toutes les paires de nombres premiers où chaque nombre premier est inférieur ou égal à un nombre donné et la paire diffère de 2.\n    * Une paire de nombres premiers est définie comme deux nombres premiers où la différence entre eux est exactement de 2.\n    * Exemple :\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/ \n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "de": "/**\n    * Findet alle Primzahlpaare, bei denen jede Primzahl kleiner oder gleich einer gegebenen Zahl ist und das Paar sich um 2 unterscheidet.\n    * Ein Primzahlpaar ist definiert als zwei Primzahlen, bei denen der Unterschied genau 2 beträgt.\n    * Beispiel:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "ha": "/**\n    * Nemo dukkan ma'auratan lambobi masu farko inda kowanne lamba mai farko ya kasance ƙasa ko daidai da wata lamba da aka bayar kuma bambancin su ya kasance 2.\n    * An ayyana ma'auratan lambobi masu farko a matsayin lambobi biyu masu farko inda bambancin tsakanin su ya kasance daidai 2.\n    * Misali:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "hi": "/**\n    * सभी अभाज्य युग्मों को खोजता है जहाँ प्रत्येक अभाज्य एक दिए गए संख्या से कम या बराबर होता है और युग्म में 2 का अंतर होता है।\n    * एक अभाज्य युग्म को दो अभाज्य संख्याओं के रूप में परिभाषित किया जाता है जहाँ उनके बीच का अंतर ठीक 2 होता है।\n    * उदाहरण:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "hu": "/**\n    * Megtalálja az összes prímszám párt, ahol minden prímszám kisebb vagy egyenlő egy adott számnál, és a pár különbsége 2.\n    * Egy prímszám pár két prímszámból áll, ahol a különbség pontosan 2.\n    * Példa:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9235298854965215",
      "hy": "0.9258030115770848",
      "bn": "0.9225381240040144",
      "bg": "0.9235298854965215",
      "zh": "0.9186161671304804",
      "fr": "0.9712706975782569",
      "de": "0.9451319325859707",
      "ha": "0.9321973208033599",
      "hi": "0.9376904439908798",
      "hu": "0.9225424938723971"
    },
    "canonical_solution": "{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}",
    "instruction": {
      "en": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nՏվեք հակիրճ բնութագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nনিম্নোক্ত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\n请用中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>\n{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9026051680064012",
      "bn": "0.8868496075523329",
      "bg": "0.8383597137705134",
      "zh": "0.8901365430976982",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9250790038382126",
      "hi": "0.8761702451159921",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n    check(findPrimePairs(10) == listOf(Pair(3, 5), Pair(5, 7)))\n    check(findPrimePairs(100) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13), Pair(17, 19), Pair(29, 31), Pair(41, 43), Pair(59, 61), Pair(71, 73)))\n    check(findPrimePairs(15) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13)))\n    check(findPrimePairs(1) == emptyList<Pair<Int, Int>>())\n}\n\n\nmain()",
    "entry_point": "findPrimePairs",
    "signature": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>",
    "docstring": {
      "en": "Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\nA prime pair is defined as two prime numbers where the difference between them is exactly 2.\nExample:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "sq": "Gjen të gjitha çiftet e numrave të thjeshtë ku secili numër i thjeshtë është më i vogël ose i barabartë me një numër të dhënë dhe çifti ndryshon me 2. Një çift numrash të thjeshtë përkufizohet si dy numra të thjeshtë ku diferenca midis tyre është saktësisht 2.\nShembull:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "hy": "Գտնում է բոլոր պարզ թվերի զույգերը, որտեղ յուրաքանչյուր պարզ թիվ փոքր է կամ հավասար է տրված թվին, և զույգը տարբերվում է 2-ով:\nՊարզ թվերի զույգը սահմանվում է որպես երկու պարզ թվեր, որոնց միջև տարբերությունը ճիշտ 2 է:\nՕրինակ:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "bn": "প্রতিটি মৌলিক সংখ্যা একটি প্রদত্ত সংখ্যার চেয়ে ছোট বা সমান এবং যাদের পার্থক্য 2, এমন সমস্ত মৌলিক জোড়া খুঁজে বের করে। একটি মৌলিক জোড়া সংজ্ঞায়িত করা হয় দুটি মৌলিক সংখ্যা হিসাবে, যেখানে তাদের মধ্যে পার্থক্য ঠিক 2।\n\nউদাহরণ:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "bg": "Намира всички двойки прости числа, при които всяко просто число е по-малко или равно на дадено число и двойката се различава с 2. \nДвойка прости числа се определя като две прости числа, при които разликата между тях е точно 2.\nПример:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "zh": "查找所有素数对，其中每个素数小于或等于给定的数字，并且这对素数相差2。\n素数对被定义为两个素数，它们之间的差恰好为2。\n例子：\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "fr": "Trouve toutes les paires de nombres premiers où chaque nombre premier est inférieur ou égal à un nombre donné et la paire diffère de 2.  \nUne paire de nombres premiers est définie comme deux nombres premiers où la différence entre eux est exactement de 2.  \nExemple :  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "de": "Findet alle Primzahlpaare, bei denen jede Primzahl kleiner oder gleich einer gegebenen Zahl ist und das Paar sich um 2 unterscheidet. Ein Primzahlpaar ist definiert als zwei Primzahlen, bei denen der Unterschied zwischen ihnen genau 2 beträgt.\nBeispiel:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "ha": "Nemo dukkan ma'aurata lambobin farko inda kowanne lamba ta farko ya kasance ƙasa ko daidai da wata lamba da aka bayar kuma bambancin ma'auratan shine 2. \nAna ayyana ma'aurata lambobin farko a matsayin lambobi biyu na farko inda bambancin tsakanin su yake daidai da 2.\nMisali:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "hi": "दिए गए संख्या से कम या उसके बराबर सभी अभाज्य युग्मों को खोजता है और युग्म के बीच का अंतर 2 होता है।  \nएक अभाज्य युग्म को दो अभाज्य संख्याओं के रूप में परिभाषित किया जाता है जहाँ उनके बीच का अंतर ठीक 2 होता है।  \nउदाहरण:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "hu": "Megtalálja az összes prímszám párt, ahol minden prímszám kisebb vagy egyenlő egy adott számnál, és a pár különbsége 2. \nEgy prímszám pár olyan két prímszám, ahol a különbség pontosan 2.\n\nPélda:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]"
    },
    "docstring_bertscore": {
      "sq": "0.9659773965540581",
      "hy": "0.9629917832967227",
      "bn": "0.9550241228222702",
      "bg": "0.9682930295361629",
      "zh": "0.9557119798317941",
      "fr": "0.9659773965540581",
      "de": "0.9947257674923806",
      "ha": "0.9614430622157937",
      "hi": "0.9655853001818953",
      "hu": "0.9623297482367335"
    }
  },
  {
    "task_id": "Kotlin/28",
    "prompt": {
      "en": "/**\n * Converts a number from one base to another.\n * The function takes an input number as a string (which can include digits and letters),\n * the base of this number, and the target base for conversion. The bases can range from 2 to 16.\n * The output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n *\n * Examples:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "sq": "/**\n * Konverton një numër nga një bazë në një tjetër.\n * Funksioni merr një numër hyrës si një varg (i cili mund të përfshijë shifra dhe shkronja),\n * bazën e këtij numri, dhe bazën e synuar për konvertim. Bazat mund të variojnë nga 2 deri në 16.\n * Rezultati është numri i konvertuar si një varg në bazën e synuar, duke përdorur shkronja të mëdha për bazat mbi 10.\n *\n * Shembuj:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "hy": "/**\n * Թվին փոխակերպում է մի հիմքից մյուսը:\n * Ֆունկցիան ընդունում է մուտքային թիվը որպես տող (որը կարող է ներառել թվանշաններ և տառեր),\n * այս թվի հիմքը և նպատակային հիմքը փոխակերպման համար: Հիմքերը կարող են լինել 2-ից 16:\n * Արդյունքը նպատակային հիմքում փոխակերպված թիվն է որպես տող, օգտագործելով մեծատառեր 10-ից բարձր հիմքերի համար:\n *\n * Օրինակներ:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "bn": "/**\n * একটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে।\n * ফাংশনটি একটি ইনপুট সংখ্যা নেয় একটি স্ট্রিং হিসেবে (যা সংখ্যা এবং অক্ষর অন্তর্ভুক্ত করতে পারে),\n * এই সংখ্যার ভিত্তি এবং রূপান্তরের জন্য লক্ষ্য ভিত্তি। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে।\n * আউটপুটটি লক্ষ্য ভিত্তিতে একটি স্ট্রিং হিসেবে রূপান্তরিত সংখ্যা, 10 এর উপরে ভিত্তির জন্য বড় হাতের অক্ষর ব্যবহার করে।\n *\n * উদাহরণ:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "bg": "/**\n * Преобразува число от една база в друга.\n * Функцията приема входно число като низ (което може да включва цифри и букви),\n * базата на това число и целевата база за преобразуване. Базите могат да варират от 2 до 16.\n * Изходът е преобразуваното число като низ в целевата база, използвайки главни букви за бази над 10.\n *\n * Примери:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "zh": "/**\n * 将一个数字从一个进制转换为另一个进制。\n * 该函数接受一个作为字符串的输入数字（可以包含数字和字母），\n * 该数字的进制，以及要转换的目标进制。进制范围可以从2到16。\n * 输出是转换后的目标进制数字，使用大写字母表示10以上的进制。\n *\n * 例子:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "fr": "/**\n * Convertit un nombre d'une base à une autre.\n * La fonction prend un nombre d'entrée sous forme de chaîne (qui peut inclure des chiffres et des lettres),\n * la base de ce nombre, et la base cible pour la conversion. Les bases peuvent aller de 2 à 16.\n * La sortie est le nombre converti sous forme de chaîne dans la base cible, en utilisant des lettres majuscules pour les bases supérieures à 10.\n *\n * Exemples :\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "de": "/**\n * Konvertiert eine Zahl von einer Basis in eine andere.\n * Die Funktion nimmt eine Eingabezahl als String (die Ziffern und Buchstaben enthalten kann),\n * die Basis dieser Zahl und die Zielbasis für die Umwandlung. Die Basen können von 2 bis 16 reichen.\n * Die Ausgabe ist die umgewandelte Zahl als String in der Zielbasis, wobei Großbuchstaben für Basen über 10 verwendet werden.\n *\n * Beispiele:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "ha": "/**\n * Yana canza lamba daga wata tushe zuwa wata.\n * Aikin yana karɓar lamba a matsayin kirtani (wanda zai iya haɗawa da lambobi da haruffa),\n * tushen wannan lambar, da kuma tushen da ake nufi don canji. Tushen na iya zama daga 2 zuwa 16.\n * Fitarwa ita ce lambar da aka canza a matsayin kirtani a cikin tushen da ake nufi, ta amfani da manyan haruffa don tushe sama da 10.\n *\n * Misalai:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "hi": "/**\n * एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है।\n * यह फ़ंक्शन एक इनपुट संख्या को एक स्ट्रिंग के रूप में लेता है (जो अंक और अक्षर शामिल कर सकता है),\n * इस संख्या का आधार, और परिवर्तन के लिए लक्षित आधार। आधार 2 से 16 तक हो सकते हैं।\n * आउटपुट लक्षित आधार में परिवर्तित संख्या होती है, जो 10 से ऊपर के आधारों के लिए अपरकेस अक्षरों का उपयोग करती है।\n *\n * उदाहरण:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "hu": "/**\n * Átalakít egy számot egyik számrendszerből a másikba.\n * A függvény bemeneti számként egy karakterláncot vesz fel (amely tartalmazhat számjegyeket és betűket),\n * ennek a számnak az alapját, és a cél alapot az átalakításhoz. Az alapok 2-től 16-ig terjedhetnek.\n * A kimenet az átalakított szám karakterláncként a cél alapban, nagybetűket használva a 10 feletti alapoknál.\n *\n * Példák:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9539107995365698",
      "hy": "0.9355063043210201",
      "bn": "0.9577652220805517",
      "bg": "0.9605402871339902",
      "zh": "0.9265907796682691",
      "fr": "0.9590074564835439",
      "de": "0.9568914470343792",
      "ha": "0.9478196002717538",
      "hi": "0.940664139425353",
      "hu": "0.959446429625631"
    },
    "canonical_solution": "{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}",
    "instruction": {
      "en": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\n请用不超过500个字符的中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String\n{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9244352427732785",
      "bn": "0.8738053517993907",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9669622059832291",
      "hi": "0.8905183106900473",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(convertBase(\"Aab3\", 15, 7) == \"210306\")\n    check(convertBase(\"101\", 2, 10) == \"5\")\n    check(convertBase(\"FF\", 16, 2) == \"11111111\")\n    check(convertBase(\"123\", 10, 16) == \"7B\")\n}\n\nmain()",
    "entry_point": "convertBase",
    "signature": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String",
    "docstring": {
      "en": "Converts a number from one base to another.\nThe function takes an input number as a string (which can include digits and letters),\nthe base of this number, and the target base for conversion. The bases can range from 2 to 16.\nThe output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n\nExamples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "sq": "Konverton një numër nga një bazë në një tjetër. Funksioni merr një numër hyrës si një varg (i cili mund të përfshijë shifra dhe shkronja), bazën e këtij numri dhe bazën e synuar për konvertim. Bazat mund të variojnë nga 2 deri në 16. Rezultati është numri i konvertuar si një varg në bazën e synuar, duke përdorur shkronja të mëdha për bazat mbi 10.\n\nShembuj:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hy": "Թվին փոխակերպում է մեկ հիմքից մյուսը:\nՖունկցիան ընդունում է մուտքային թիվը որպես տող (որը կարող է ներառել թվեր և տառեր),\nայդ թվի հիմքը և նպատակային հիմքը փոխակերպման համար: Հիմքերը կարող են տատանվել 2-ից մինչև 16:\nԵլքը հանդիսանում է փոխակերպված թիվը որպես տող նպատակային հիմքում, օգտագործելով մեծատառեր 10-ից բարձր հիմքերի համար:\n\nՕրինակներ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "bn": "একটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে। \nফাংশনটি একটি ইনপুট সংখ্যা নেয় একটি স্ট্রিং হিসাবে (যা সংখ্যা এবং অক্ষর অন্তর্ভুক্ত করতে পারে), \nএই সংখ্যার ভিত্তি, এবং রূপান্তরের জন্য লক্ষ্য ভিত্তি। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে। \nআউটপুটটি লক্ষ্য ভিত্তিতে একটি স্ট্রিং হিসাবে রূপান্তরিত সংখ্যা, 10 এর উপরে ভিত্তির জন্য বড় হাতের অক্ষর ব্যবহার করে।\n\nউদাহরণসমূহ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "bg": "Преобразува число от една бройна система в друга. \nФункцията приема входно число като низ (което може да включва цифри и букви), \nбазата на това число и целевата база за преобразуване. Базите могат да варират от 2 до 16. \nИзходът е преобразуваното число като низ в целевата база, използвайки главни букви за бази над 10.\n\nПримери:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "zh": "将一个数字从一个进制转换为另一个进制。  \n该函数接受一个作为字符串的输入数字（可以包含数字和字母），该数字的进制，以及转换的目标进制。进制范围可以从2到16。  \n输出是转换后的目标进制的字符串形式的数字，对于大于10的进制使用大写字母。\n\n示例：\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "fr": "Convertit un nombre d'une base à une autre.  \nLa fonction prend un nombre d'entrée sous forme de chaîne (qui peut inclure des chiffres et des lettres),  \nla base de ce nombre, et la base cible pour la conversion. Les bases peuvent aller de 2 à 16.  \nLa sortie est le nombre converti sous forme de chaîne dans la base cible, en utilisant des lettres majuscules pour les bases supérieures à 10.  \n\nExemples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "de": "Konvertiert eine Zahl von einer Basis in eine andere.\nDie Funktion nimmt eine Eingabezahl als Zeichenkette (die Ziffern und Buchstaben enthalten kann),\ndie Basis dieser Zahl und die Zielbasis für die Konvertierung. Die Basen können von 2 bis 16 reichen.\nDie Ausgabe ist die konvertierte Zahl als Zeichenkette in der Zielbasis, wobei Großbuchstaben für Basen über 10 verwendet werden.\n\nBeispiele:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "ha": "Yana canza lamba daga wata tushe zuwa wata.\nAikin yana karɓar lamba ta shigarwa a matsayin kirtani (wanda zai iya haɗawa da lambobi da haruffa),\ntushen wannan lambar, da kuma tushen da ake nufi don canzawa. Tushen na iya zama daga 2 zuwa 16.\nFitarwa ita ce lambar da aka canza a matsayin kirtani a cikin tushen da ake nufi, ta amfani da manyan haruffa don tushen sama da 10.\n\nMisalai:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hi": "एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है। \nयह फ़ंक्शन एक इनपुट संख्या को एक स्ट्रिंग के रूप में लेता है (जिसमें अंक और अक्षर शामिल हो सकते हैं),\nइस संख्या का आधार, और परिवर्तन के लिए लक्षित आधार। आधार 2 से 16 तक हो सकते हैं।\nआउटपुट लक्षित आधार में परिवर्तित संख्या होती है, जिसमें 10 से ऊपर के आधारों के लिए बड़े अक्षरों का उपयोग किया जाता है।\n\nउदाहरण:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hu": "Egy szám átalakítása egyik számrendszerből a másikba.\nA függvény egy bemeneti számot vesz fel karakterláncként (amely tartalmazhat számjegyeket és betűket),\nennek a számnak az alapját, valamint a cél alapot az átalakításhoz. Az alapok 2-től 16-ig terjedhetnek.\nA kimenet az átalakított szám karakterláncként a cél alapban, nagybetűket használva a 10 feletti alapok esetén.\n\nPéldák:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\""
    },
    "docstring_bertscore": {
      "sq": "0.9944196780752058",
      "hy": "0.9840998366285383",
      "bn": "0.983734158097053",
      "bg": "0.9814371963707655",
      "zh": "0.9639869215057075",
      "fr": "0.9923976207962707",
      "de": "0.9949357198051345",
      "ha": "0.9935504715277972",
      "hi": "0.9734870153698442",
      "hu": "0.9766106767419989"
    }
  },
  {
    "task_id": "Kotlin/29",
    "prompt": {
      "en": "/**\n * Determines whether a given number string is a cyclic number.\n * A cyclic number is one where multiplying it by any number from 1 to its length,\n * results in a permutation of the original number.\n *\n * Examples:\n * >>> isCyclicNumber(\"142857\")\n *     1 // since 142857 is a cyclic number\n * >>> isCyclicNumber(\"123456\")\n *     0 // since 123456 is not a cyclic number\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "sq": "/**\n * Përcakton nëse një varg numrash i dhënë është një numër ciklik.\n * Një numër ciklik është ai ku duke e shumëzuar atë me çdo numër nga 1 deri në gjatësinë e tij,\n * rezulton në një permutacion të numrit origjinal.\n *\n * Shembuj:\n * >>> isCyclicNumber(\"142857\")\n *     1 // pasi 142857 është një numër ciklik\n * >>> isCyclicNumber(\"123456\")\n *     0 // pasi 123456 nuk është një numër ciklik\n */",
      "hy": "/**\n * Սահմանում է՝ արդյոք տրված թվային տողը ցիկլիկ թիվ է:\n * Ցիկլիկ թիվ է այն, որը բազմապատկելով 1-ից մինչև իր երկարությունը ցանկացած թվով,\n * ստացվում է սկզբնական թվի վերադասավորում:\n *\n * Օրինակներ:\n * >>> isCyclicNumber(\"142857\")\n *     1 // քանի որ 142857-ը ցիկլիկ թիվ է\n * >>> isCyclicNumber(\"123456\")\n *     0 // քանի որ 123456-ը ցիկլիկ թիվ չէ\n */",
      "bn": "/**\n * নির্ধারণ করে একটি প্রদত্ত সংখ্যা স্ট্রিং একটি চক্রাকার সংখ্যা কিনা।\n * একটি চক্রাকার সংখ্যা হল এমন একটি সংখ্যা যেখানে এটিকে 1 থেকে তার দৈর্ঘ্য পর্যন্ত যেকোন সংখ্যার সাথে গুণ করলে,\n * মূল সংখ্যার একটি বিন্যাস পাওয়া যায়।\n *\n * উদাহরণ:\n * >>> isCyclicNumber(\"142857\")\n *     1 // কারণ 142857 একটি চক্রাকার সংখ্যা\n * >>> isCyclicNumber(\"123456\")\n *     0 // কারণ 123456 একটি চক্রাকার সংখ্যা নয়\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "bg": "/**\n * Определя дали даден низ от числа е циклично число.\n * Циклично число е такова, при което умножаването му с което и да е число от 1 до неговата дължина,\n * води до пермутация на оригиналното число.\n *\n * Примери:\n * >>> isCyclicNumber(\"142857\")\n *     1 // тъй като 142857 е циклично число\n * >>> isCyclicNumber(\"123456\")\n *     0 // тъй като 123456 не е циклично число\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "zh": "/**\n * 确定给定的数字字符串是否为循环数。\n * 循环数是指将其乘以从1到其长度的任何数字，\n * 结果是原始数字的一个排列。\n *\n * 例子:\n * >>> isCyclicNumber(\"142857\")\n *     1 // 因为142857是一个循环数\n * >>> isCyclicNumber(\"123456\")\n *     0 // 因为123456不是一个循环数\n */",
      "fr": "/**\n * Détermine si une chaîne de chiffres donnée est un nombre cyclique.\n * Un nombre cyclique est un nombre tel que le multiplier par n'importe quel nombre de 1 à sa longueur,\n * résulte en une permutation du nombre original.\n *\n * Exemples :\n * >>> isCyclicNumber(\"142857\")\n *     1 // puisque 142857 est un nombre cyclique\n * >>> isCyclicNumber(\"123456\")\n *     0 // puisque 123456 n'est pas un nombre cyclique\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "de": "/**\n * Bestimmt, ob eine gegebene Zahlenfolge eine zyklische Zahl ist.\n * Eine zyklische Zahl ist eine, bei der das Multiplizieren mit einer beliebigen Zahl von 1 bis zu ihrer Länge\n * zu einer Permutation der ursprünglichen Zahl führt.\n *\n * Beispiele:\n * >>> isCyclicNumber(\"142857\")\n *     1 // da 142857 eine zyklische Zahl ist\n * >>> isCyclicNumber(\"123456\")\n *     0 // da 123456 keine zyklische Zahl ist\n */",
      "ha": "/**\n * Yana tantance ko wata lamba da aka bayar tana da yanayin cyclic.\n * Lamba mai yanayin cyclic ita ce wadda idan aka ninka ta da kowace lamba daga 1 zuwa tsawonta,\n * sakamakon yana zama permutation na asalin lambar.\n *\n * Misalai:\n * >>> isCyclicNumber(\"142857\")\n *     1 // domin 142857 tana da yanayin cyclic\n * >>> isCyclicNumber(\"123456\")\n *     0 // domin 123456 ba tana da yanayin cyclic ba\n */",
      "hi": "/**\n * यह निर्धारित करता है कि दिया गया संख्या स्ट्रिंग एक चक्रीय संख्या है या नहीं।\n * एक चक्रीय संख्या वह होती है जहाँ इसे 1 से लेकर इसकी लंबाई तक किसी भी संख्या से गुणा करने पर,\n * मूल संख्या का एक क्रमपरिवर्तन प्राप्त होता है।\n *\n * उदाहरण:\n * >>> isCyclicNumber(\"142857\")\n *     1 // क्योंकि 142857 एक चक्रीय संख्या है\n * >>> isCyclicNumber(\"123456\")\n *     0 // क्योंकि 123456 एक चक्रीय संख्या नहीं है\n */ \n\nfun isCyclicNumber(numberString: String): Int ",
      "hu": "/**\n * Meghatározza, hogy egy adott számsorozat ciklikus szám-e.\n * Egy ciklikus szám olyan, amelyet ha megszorzunk bármely számmal 1-től a hosszáig,\n * az eredeti szám egy permutációját kapjuk.\n *\n * Példák:\n * >>> isCyclicNumber(\"142857\")\n *     1 // mivel a 142857 egy ciklikus szám\n * >>> isCyclicNumber(\"123456\")\n *     0 // mivel a 123456 nem ciklikus szám\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9530149765181024",
      "hy": "0.934560625076913",
      "bn": "0.9877780740245423",
      "bg": "0.9923509426567275",
      "zh": "0.9303927637916579",
      "fr": "0.9738211116707448",
      "de": "0.9446985210945527",
      "ha": "0.885074249206643",
      "hi": "0.9884629515783506",
      "hu": "0.9298079959498912"
    },
    "canonical_solution": "{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}",
    "instruction": {
      "en": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nकृपया निम्नलिखित Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun isCyclicNumber(numberString: String): Int\n{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9417669353008588",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9368963197275022",
      "hi": "0.8742320098578537",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main(){\n    check(isCyclicNumber(\"142857\") == 1)\n    check(isCyclicNumber(\"123456\") == 0)\n    check(isCyclicNumber(\"076923\") == 0)\n    check(isCyclicNumber(\"1\") == 1)\n    check(isCyclicNumber(\"0\") == 1)\n\n}\n\nmain()",
    "entry_point": "isCyclicNumber",
    "signature": "fun isCyclicNumber(numberString: String): Int",
    "docstring": {
      "en": "Determines whether a given number string is a cyclic number.\nA cyclic number is one where multiplying it by any number from 1 to its length,\nresults in a permutation of the original number.\n\nExamples:\n>>> isCyclicNumber(\"142857\")\n1 // since 142857 is a cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // since 123456 is not a cyclic number",
      "sq": "Përcakton nëse një varg numrash i dhënë është një numër ciklik. Një numër ciklik është ai ku duke e shumëzuar atë me çdo numër nga 1 deri në gjatësinë e tij, rezulton në një permutacion të numrit origjinal.\n\nShembuj:\n>>> isCyclicNumber(\"142857\")\n1 // pasi 142857 është një numër ciklik\n>>> isCyclicNumber(\"123456\")\n0 // pasi 123456 nuk është një numër ciklik",
      "hy": "Սահմանում է, արդյոք տրված թվային տողը ցիկլիկ թիվ է:\nՑիկլիկ թիվը այն է, երբ այն բազմապատկելով 1-ից մինչև իր երկարությունը ցանկացած թվով,\nհանգեցնում է սկզբնական թվի վերադասավորմանը:\n\nՕրինակներ:\n>>> isCyclicNumber(\"142857\")\n1 // քանի որ 142857-ը ցիկլիկ թիվ է\n>>> isCyclicNumber(\"123456\")\n0 // քանի որ 123456-ը ցիկլիկ թիվ չէ",
      "bn": "নির্ধারণ করে যে একটি প্রদত্ত সংখ্যার স্ট্রিং একটি চক্রাকার সংখ্যা কিনা। একটি চক্রাকার সংখ্যা হল এমন একটি সংখ্যা যেখানে এটিকে 1 থেকে এর দৈর্ঘ্য পর্যন্ত যে কোনও সংখ্যার সাথে গুণ করলে, মূল সংখ্যার একটি বিন্যাস পাওয়া যায়।\n\nউদাহরণ:\n>>> isCyclicNumber(\"142857\")\n1 // কারণ 142857 একটি চক্রাকার সংখ্যা\n>>> isCyclicNumber(\"123456\")\n0 // কারণ 123456 একটি চক্রাকার সংখ্যা নয়",
      "bg": "Определя дали даден низ от числа е циклично число. Циклично число е такова, при което умножаването му с което и да е число от 1 до неговата дължина, води до пермутация на оригиналното число.\n\nПримери:\n>>> isCyclicNumber(\"142857\")\n1 // тъй като 142857 е циклично число\n>>> isCyclicNumber(\"123456\")\n0 // тъй като 123456 не е циклично число",
      "zh": "确定给定的数字字符串是否是循环数。  \n循环数是指将其乘以从1到其长度的任何数字，结果是原始数字的一个排列。\n\n示例：\n>>> isCyclicNumber(\"142857\")\n1 // 因为142857是一个循环数\n>>> isCyclicNumber(\"123456\")\n0 // 因为123456不是一个循环数",
      "fr": "Détermine si une chaîne de chiffres donnée est un nombre cyclique.  \nUn nombre cyclique est un nombre tel que le multiplier par n'importe quel nombre de 1 à sa longueur,  \nrésulte en une permutation du nombre original.\n\nExemples :  \n>>> isCyclicNumber(\"142857\")  \n1 // puisque 142857 est un nombre cyclique  \n>>> isCyclicNumber(\"123456\")  \n0 // puisque 123456 n'est pas un nombre cyclique  ",
      "de": "Bestimmt, ob eine gegebene Zahl als Zeichenkette eine zyklische Zahl ist.  \nEine zyklische Zahl ist eine, bei der die Multiplikation mit einer beliebigen Zahl von 1 bis zu ihrer Länge zu einer Permutation der ursprünglichen Zahl führt.\n\nBeispiele:\n>>> isCyclicNumber(\"142857\")\n1 // da 142857 eine zyklische Zahl ist\n>>> isCyclicNumber(\"123456\")\n0 // da 123456 keine zyklische Zahl ist",
      "ha": "Yana tantance ko wata lamba da aka bayar tana da siffar cyclic number.\nCyclic number ita ce wadda idan aka ninka ta da kowace lamba daga 1 zuwa tsawonta,\nza a samu permutation na ainihin lambar.\n\nMisalai:\n>>> isCyclicNumber(\"142857\")\n1 // domin 142857 tana da siffar cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // domin 123456 ba tana da siffar cyclic number ba",
      "hi": "यह निर्धारित करता है कि दिया गया संख्या स्ट्रिंग एक चक्रीय संख्या है या नहीं।  \nएक चक्रीय संख्या वह होती है जहां इसे 1 से लेकर इसकी लंबाई तक किसी भी संख्या से गुणा करने पर,  \nमूल संख्या का एक क्रमपरिवर्तन प्राप्त होता है।\n\nउदाहरण:\n>>> isCyclicNumber(\"142857\")\n1 // क्योंकि 142857 एक चक्रीय संख्या है\n>>> isCyclicNumber(\"123456\")\n0 // क्योंकि 123456 एक चक्रीय संख्या नहीं है",
      "hu": "Meghatározza, hogy egy adott számsorozat ciklikus szám-e.  \nEgy ciklikus szám olyan, amelyet ha megszorzunk bármely számmal 1-től a hosszáig, az eredeti szám egy permutációját eredményezi.\n\nPéldák:\n>>> isCyclicNumber(\"142857\")\n1 // mivel a 142857 egy ciklikus szám\n>>> isCyclicNumber(\"123456\")\n0 // mivel a 123456 nem ciklikus szám"
    },
    "docstring_bertscore": {
      "sq": "0.9838767747106361",
      "hy": "0.9726426376200649",
      "bn": "0.9850159199458711",
      "bg": "0.9910701739598146",
      "zh": "0.9676341725622701",
      "fr": "0.9653644231981845",
      "de": "0.9815778266805383",
      "ha": "0.929135234849326",
      "hi": "0.9753769834453911",
      "hu": "0.9680904265475073"
    }
  },
  {
    "task_id": "Kotlin/30",
    "prompt": {
      "en": "/**\n    * Sum the given list of fractions and simplify the resulting fraction.\n    * The simplification process involves finding the greatest common divisor (GCD)\n    * of the numerator and the denominator and dividing both by this GCD. \n    * If the denominator after simplification is 1, only the numerator is returned.\n    *\n    * Example:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "sq": "/**\n    * Mbledh listën e dhënë të thyesave dhe thjeshton thyesën që rezulton.\n    * Procesi i thjeshtimit përfshin gjetjen e divizorit më të madh të përbashkët (GCD)\n    * të numëruesit dhe emëruesit dhe ndarjen e të dyve me këtë GCD.\n    * Nëse emëruesi pas thjeshtimit është 1, vetëm numëruesi kthehet.\n    *\n    * Shembull:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "hy": "/**\n    * Գումարել տրված կոտորակների ցանկը և պարզեցնել ստացված կոտորակը։\n    * Պարզեցման գործընթացը ներառում է համարիչի և հայտարարիչի \n    * ամենամեծ ընդհանուր բաժանարարը (GCD) գտնելը և երկուսն էլ բաժանել այս GCD-ի վրա։\n    * Եթե պարզեցումից հետո հայտարարիչը 1 է, վերադարձվում է միայն համարիչը։\n    *\n    * Օրինակ:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "bn": "/**\n    * প্রদত্ত ভগ্নাংশের তালিকার যোগফল নির্ণয় করুন এবং ফলাফলকে সরলীকৃত করুন।\n    * সরলীকরণের প্রক্রিয়াটি গাণিতিক গরিষ্ঠ সাধারণ বিভাজক (GCD) খুঁজে বের করা\n    * এবং উভয়কে এই GCD দ্বারা ভাগ করা অন্তর্ভুক্ত করে। \n    * যদি সরলীকরণের পরে হর 1 হয়, তাহলে শুধুমাত্র লব্ধাংশ ফেরত দেওয়া হয়।\n    *\n    * উদাহরণ:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "bg": "/**\n    * Сумирайте дадения списък от дроби и опростете получената дроб.\n    * Процесът на опростяване включва намиране на най-големия общ делител (НОД)\n    * на числителя и знаменателя и делене на двете числа с този НОД.\n    * Ако знаменателят след опростяването е 1, се връща само числителят.\n    *\n    * Пример:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "zh": "/**\n    * 对给定的分数列表求和并简化结果分数。\n    * 简化过程涉及找到分子和分母的最大公约数 (GCD)，并将两者都除以这个 GCD。\n    * 如果简化后的分母为 1，则只返回分子。\n    *\n    * 示例:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "fr": "/**\n    * Additionner la liste donnée de fractions et simplifier la fraction résultante.\n    * Le processus de simplification implique de trouver le plus grand commun diviseur (PGCD)\n    * du numérateur et du dénominateur et de diviser les deux par ce PGCD.\n    * Si le dénominateur après simplification est 1, seul le numérateur est retourné.\n    *\n    * Exemple :\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "de": "/**\n    * Summiere die gegebene Liste von Brüchen und vereinfache den resultierenden Bruch.\n    * Der Vereinfachungsprozess beinhaltet das Finden des größten gemeinsamen Teilers (GGT)\n    * des Zählers und des Nenners und das Teilen beider durch diesen GGT.\n    * Wenn der Nenner nach der Vereinfachung 1 ist, wird nur der Zähler zurückgegeben.\n    *\n    * Beispiel:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "ha": "/**\n    * Tara jerin kason da aka bayar kuma sauƙaƙa sakamakon kaso.\n    * Tsarin sauƙaƙawa yana haɗa da nemo babbar raba gama gari (GCD)\n    * na mai lamba da mai kasa kuma a raba duka biyun da wannan GCD.\n    * Idan mai kasa bayan sauƙaƙawa ya zama 1, ana mayar da mai lamba kawai.\n    *\n    * Misali:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "hi": "/**\n    * दिए गए भिन्नों की सूची का योग करें और परिणामी भिन्न को सरल बनाएं।\n    * सरलीकरण प्रक्रिया में अंश और हर के महत्तम समापवर्तक (GCD) को खोजना शामिल है\n    * और दोनों को इस GCD से विभाजित करना। \n    * यदि सरलीकरण के बाद हर 1 है, तो केवल अंश ही लौटाया जाता है।\n    *\n    * उदाहरण:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "hu": "/**\n    * Adja össze a megadott törtek listáját, és egyszerűsítse az eredményül kapott törtet.\n    * Az egyszerűsítési folyamat magában foglalja a számláló és a nevező legnagyobb közös osztójának (GCD) megtalálását,\n    * és mindkettő osztását ezzel a GCD-vel.\n    * Ha az egyszerűsítés utáni nevező 1, csak a számláló kerül visszaadásra.\n    *\n    * Példa:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String"
    },
    "prompt_bertscore": {
      "sq": "0.9895158912282165",
      "hy": "0.994181122987583",
      "bn": "0.9596428750724745",
      "bg": "0.9955898096498824",
      "zh": "0.9735243578814787",
      "fr": "0.9942635545957125",
      "de": "0.9980411071822339",
      "ha": "0.9943497601810816",
      "hi": "0.9909402696906178",
      "hu": "0.9854912424476876"
    },
    "canonical_solution": "{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b",
    "instruction": {
      "en": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nকোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun sumAndSimplifyFractions(fractions: List<String>): String\n{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b\n\nAdjon meg egy tömör természetes nyelvű leírást (dokumentációs komment) a Kotlin kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.9244352427732785",
      "bn": "0.8639932096066483",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.8824312733565928"
    },
    "level": "",
    "test": "fun main() {\n    check(sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\")) == \"5/6\")\n    check(sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\")) == \"3/4\")\n    check(sumAndSimplifyFractions(listOf(\"1/8\", \"3/8\")) == \"1/2\")\n    check(sumAndSimplifyFractions(listOf(\"2/3\", \"1/3\")) == \"1\")\n}\n\n\nmain()",
    "entry_point": "sumAndSimplifyFractions",
    "signature": "fun sumAndSimplifyFractions(fractions: List<String>): String",
    "docstring": {
      "en": "Sum the given list of fractions and simplify the resulting fraction.\nThe simplification process involves finding the greatest common divisor (GCD)\nof the numerator and the denominator and dividing both by this GCD.\nIf the denominator after simplification is 1, only the numerator is returned.\n\nExample:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "sq": "Mbledhni listën e dhënë të fraksioneve dhe thjeshtoni fraksionin që rezulton. Procesi i thjeshtimit përfshin gjetjen e përbashkëtit më të madh (GCD) të numëruesit dhe emëruesit dhe pjesëtimin e të dyve me këtë GCD. Nëse emëruesi pas thjeshtimit është 1, kthehet vetëm numëruesi.\n\nShembull:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hy": "Տրված կոտորակների ցուցակը գումարել և պարզեցնել ստացված կոտորակը։ Պարզեցման գործընթացը ներառում է համարիչի և հայտարիչի ամենամեծ ընդհանուր բաժանարարը (GCD) գտնելը և երկուսն էլ բաժանել այդ GCD-ով։ Եթե պարզեցումից հետո հայտարիչը 1 է, վերադարձվում է միայն համարիչը։\n\nՕրինակ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "bn": "প্রদত্ত ভগ্নাংশের তালিকা যোগ করে প্রাপ্ত ভগ্নাংশকে সরল করুন। সরলীকরণ প্রক্রিয়ায় গাণিতিক ভগ্নাংশের লব এবং হর এর সর্বাধিক সাধারণ গুণনীয়ক (GCD) খুঁজে বের করা এবং উভয়কে এই GCD দ্বারা ভাগ করা অন্তর্ভুক্ত। যদি সরলীকরণের পরে হর 1 হয়, তাহলে শুধুমাত্র লবটি ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "bg": "Сумирайте дадения списък от дроби и опростете получената дроб. Процесът на опростяване включва намиране на най-големия общ делител (НОД) на числителя и знаменателя и делене на двете с този НОД. Ако знаменателят след опростяването е 1, се връща само числителят.\n\nПример:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "zh": "将给定的分数列表相加并简化结果分数。  \n简化过程涉及找到分子和分母的最大公约数 (GCD)，并将两者都除以这个 GCD。  \n如果简化后的分母为 1，则仅返回分子。\n\n示例：\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "fr": "Additionnez la liste donnée de fractions et simplifiez la fraction résultante. Le processus de simplification implique de trouver le plus grand diviseur commun (PGCD) du numérateur et du dénominateur et de diviser les deux par ce PGCD. Si le dénominateur après simplification est 1, seul le numérateur est renvoyé.\n\nExemple :\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "de": "Summiere die gegebene Liste von Brüchen und vereinfache den resultierenden Bruch. Der Vereinfachungsprozess beinhaltet das Finden des größten gemeinsamen Teilers (GGT) des Zählers und des Nenners und das Teilen beider durch diesen GGT. Wenn der Nenner nach der Vereinfachung 1 ist, wird nur der Zähler zurückgegeben.\n\nBeispiel:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "ha": "Tara jerin kason da aka bayar kuma sauƙaƙe sakamakon kason.\nTsarin sauƙaƙewa yana ƙunshe da nemo babbar raba mai yawa (GCD)\nna mai ƙididdiga da mai raba kuma a raba duka biyun da wannan GCD.\nIdan mai raba bayan sauƙaƙewa ya kasance 1, ana mayar da mai ƙididdiga kawai.\n\nMisali:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hi": "दिए गए भिन्नों की सूची का योग करें और परिणामी भिन्न को सरल करें। सरलीकरण प्रक्रिया में अंश और हर के महत्तम समापवर्तक (GCD) को खोजना और दोनों को इस GCD से विभाजित करना शामिल है। यदि सरलीकरण के बाद हर 1 होता है, तो केवल अंश लौटाया जाता है।\n\nउदाहरण:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hu": "Add össze a megadott törtek listáját, és egyszerűsítsd a kapott törtet. Az egyszerűsítési folyamat magában foglalja a számláló és a nevező legnagyobb közös osztójának (GCD) megtalálását, és mindkettőt elosztjuk ezzel a GCD-vel. Ha az egyszerűsítés után a nevező 1, akkor csak a számláló kerül visszaadásra.\n\nPélda:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\""
    },
    "docstring_bertscore": {
      "sq": "0.9930217174534823",
      "hy": "0.9770423005599876",
      "bn": "0.9713126085886552",
      "bg": "1",
      "zh": "0.9715410335268454",
      "fr": "0.9930217174534823",
      "de": "0.9970618594037319",
      "ha": "0.9840191926938381",
      "hi": "0.9970618594037319",
      "hu": "0.9842988642703352"
    }
  },
  {
    "task_id": "Kotlin/31",
    "prompt": {
      "en": "/**\n    * Calculate the number of various denominations of currency required to make up a given amount.\n    * The function takes an integer representing the total amount and returns a list of integers.\n    * The list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\n    * The goal is to minimize the total number of notes by using larger denominations where possible.\n    *\n    * Example:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "sq": "/**\n    * Llogarit numrin e denominimeve të ndryshme të monedhës të nevojshme për të arritur një shumë të caktuar.\n    * Funksioni merr një numër të plotë që përfaqëson shumën totale dhe kthen një listë të numrave të plotë.\n    * Lista përmban numrin e kartëmonedhave prej 100, 50, 20, 10, 5, dhe 1 yuan të nevojshme, në atë rend.\n    * Qëllimi është të minimizohet numri total i kartëmonedhave duke përdorur denominime më të mëdha kur është e mundur.\n    *\n    * Shembull:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "hy": "/**\n    * Հաշվել տարբեր արժույթների անվանական արժեքների քանակը՝ տրված գումարը կազմելու համար:\n    * Ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ընդհանուր գումարը և վերադարձնում է ամբողջ թվերի ցուցակ:\n    * Ցուցակը պարունակում է 100, 50, 20, 10, 5 և 1 յուանների թղթադրամների քանակը՝ այդ կարգով:\n    * Նպատակն է նվազեցնել թղթադրամների ընդհանուր քանակը՝ հնարավորության դեպքում օգտագործելով ավելի մեծ անվանական արժեքներ:\n    *\n    * Օրինակ:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "bn": "/**\n    * প্রদত্ত পরিমাণ তৈরি করতে প্রয়োজনীয় বিভিন্ন মুদ্রার সংখ্যা গণনা করুন।\n    * ফাংশনটি মোট পরিমাণকে উপস্থাপনকারী একটি পূর্ণসংখ্যা নেয় এবং পূর্ণসংখ্যার একটি তালিকা প্রদান করে।\n    * তালিকাটি 100, 50, 20, 10, 5, এবং 1 ইউয়ান নোটের সংখ্যা ধারণ করে, সেই ক্রমে।\n    * লক্ষ্য হল বড় মুদ্রা ব্যবহার করে মোট নোটের সংখ্যা কমানো।\n    *\n    * উদাহরণ:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "bg": "/**\n    * Изчислява броя на различни деноминации на валута, необходими за съставяне на дадена сума.\n    * Функцията приема цяло число, представляващо общата сума, и връща списък от цели числа.\n    * Списъкът съдържа броя на банкнотите от 100, 50, 20, 10, 5 и 1 юан, необходими в този ред.\n    * Целта е да се минимизира общият брой банкноти, като се използват по-големи деноминации, където е възможно.\n    *\n    * Пример:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "zh": "/**\n    * 计算需要多少种不同面额的货币来组成给定的金额。\n    * 该函数接受一个表示总金额的整数，并返回一个整数列表。\n    * 列表包含所需的100、50、20、10、5和1元纸币的数量，按此顺序排列。\n    * 目标是通过尽可能使用较大面额来最小化纸币的总数量。\n    *\n    * 例子:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "fr": "/**\n    * Calculer le nombre de différentes dénominations de monnaie nécessaires pour constituer un montant donné.\n    * La fonction prend un entier représentant le montant total et renvoie une liste d'entiers.\n    * La liste contient le nombre de billets de 100, 50, 20, 10, 5 et 1 yuan nécessaires, dans cet ordre.\n    * L'objectif est de minimiser le nombre total de billets en utilisant des dénominations plus grandes lorsque c'est possible.\n    *\n    * Exemple :\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "de": "/**\n    * Berechne die Anzahl der verschiedenen Währungsdenominationen, die benötigt werden, um einen gegebenen Betrag zu erreichen.\n    * Die Funktion nimmt eine ganze Zahl, die den Gesamtbetrag darstellt, und gibt eine Liste von ganzen Zahlen zurück.\n    * Die Liste enthält die Anzahl der 100, 50, 20, 10, 5 und 1 Yuan-Scheine, die benötigt werden, in dieser Reihenfolge.\n    * Das Ziel ist es, die Gesamtanzahl der Scheine zu minimieren, indem größere Denominationen, wo möglich, verwendet werden.\n    *\n    * Beispiel:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "ha": "/**\n    * Lissafa adadin nau'ikan kudade daban-daban da ake bukata don samar da wani adadi.\n    * Aikin yana karɓar cikakken adadi wanda ke wakiltar jimillar adadin kuma yana mayar da jerin cikakkun lambobi.\n    * Jerin yana ƙunshe da adadin takardun kudi na 100, 50, 20, 10, 5, da 1 yuan da ake bukata, a wannan tsari.\n    * Manufar ita ce rage jimillar adadin takardun kudi ta amfani da manyan nau'ikan idan zai yiwu.\n    *\n    * Misali:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "hi": "/**\n    * दिए गए राशि को बनाने के लिए विभिन्न मूल्यवर्ग की मुद्रा की संख्या की गणना करें।\n    * फ़ंक्शन एक पूर्णांक लेता है जो कुल राशि का प्रतिनिधित्व करता है और पूर्णांकों की एक सूची लौटाता है।\n    * सूची में 100, 50, 20, 10, 5, और 1 युआन नोटों की संख्या होती है, इसी क्रम में।\n    * लक्ष्य बड़े मूल्यवर्ग का उपयोग करके नोटों की कुल संख्या को कम करना है।\n    *\n    * उदाहरण:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "hu": "/**\n    * Számolja ki, hogy egy adott összeghez hány különböző címletű bankjegyre van szükség.\n    * A függvény egy egész számot vesz át, amely a teljes összeget jelenti, és egy egész számokból álló listát ad vissza.\n    * A lista tartalmazza a 100, 50, 20, 10, 5 és 1 jüan címletű bankjegyek számát, ebben a sorrendben.\n    * A cél az, hogy a lehető legkevesebb bankjegyet használjuk, nagyobb címleteket alkalmazva, ahol lehetséges.\n    *\n    * Példa:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9538672994831231",
      "hy": "0.9380183827499683",
      "bn": "0.9360463803270539",
      "bg": "0.9636238251691758",
      "zh": "0.9440805819791531",
      "fr": "0.9657894922135991",
      "de": "0.9751114146259475",
      "ha": "0.9838475760446239",
      "hi": "0.9384895340137831",
      "hu": "0.9374937999136552"
    },
    "canonical_solution": "{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}",
    "instruction": {
      "en": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nՏվեք կարճ բնութագրություն (docstring) Kotlin կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nনিম্নলিখিত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\n请用不超过500个字符的中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nकृपया Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fun calculateCurrency(amount: Int): List<Int>\n{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}\n\nAdj meg egy tömör, legfeljebb 500 karakter hosszú természetes nyelvű leírást (docstring) a Kotlin kódról magyarul."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.899381794182967",
      "bn": "0.8738053517993907",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9385961985283988",
      "ha": "0.9141819425042575",
      "hi": "0.9022003592898521",
      "hu": "0.9390828429619342"
    },
    "level": "",
    "test": "fun main() {\n    check(calculateCurrency(735) == listOf(7, 0, 1, 1, 1, 0))\n    check(calculateCurrency(123) == listOf(1, 0, 1, 0, 0, 3))\n    check(calculateCurrency(980) == listOf(9, 1, 1, 1, 0, 0))\n    check(calculateCurrency(50) == listOf(0, 1, 0, 0, 0, 0))\n}\n\nmain()",
    "entry_point": "calculateCurrency",
    "signature": "fun calculateCurrency(amount: Int): List<Int>",
    "docstring": {
      "en": "Calculate the number of various denominations of currency required to make up a given amount.\nThe function takes an integer representing the total amount and returns a list of integers.\nThe list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\nThe goal is to minimize the total number of notes by using larger denominations where possible.\n\nExample:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "sq": "Llogarit numrin e denominimeve të ndryshme të monedhës të nevojshme për të përbërë një shumë të dhënë.\nFunksioni merr një numër të plotë që përfaqëson shumën totale dhe kthen një listë të numrave të plotë.\nLista përmban numrin e kartëmonedhave prej 100, 50, 20, 10, 5, dhe 1 juan të nevojshme, në atë rend.\nQëllimi është të minimizohet numri total i kartëmonedhave duke përdorur denominime më të mëdha kur është e mundur.\n\nShembull:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "hy": "Հաշվարկել անհրաժեշտ տարբեր անվանական արժեքների արժույթների քանակը՝ տրված գումարը կազմելու համար:\nՖունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ընդհանուր գումարը և վերադարձնում է ամբողջ թվերի ցուցակ:\nՑուցակը պարունակում է 100, 50, 20, 10, 5 և 1 յուանանոց թղթադրամների քանակը՝ այդ կարգով:\nՆպատակն է նվազագույնացնել թղթադրամների ընդհանուր քանակը՝ օգտագործելով հնարավորության դեպքում ավելի մեծ անվանական արժեքներ:\n\nՕրինակ:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "bn": "একটি নির্দিষ্ট পরিমাণ গঠনের জন্য প্রয়োজনীয় বিভিন্ন মুদ্রার মানের সংখ্যা গণনা করুন। \nফাংশনটি মোট পরিমাণকে উপস্থাপনকারী একটি পূর্ণসংখ্যা গ্রহণ করে এবং পূর্ণসংখ্যার একটি তালিকা প্রদান করে। \nতালিকাটি ১০০, ৫০, ২০, ১০, ৫, এবং ১ ইউয়ান নোটের প্রয়োজনীয় সংখ্যা ধারণ করে, এই ক্রমে। \nলক্ষ্য হল বড় মুদ্রার মান ব্যবহার করে নোটের মোট সংখ্যা কমানো।\n\nউদাহরণ:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "bg": "Изчисляване на броя на различните номинали на валута, необходими за съставяне на дадена сума.\nФункцията приема цяло число, представляващо общата сума, и връща списък от цели числа.\nСписъкът съдържа броя на банкнотите от 100, 50, 20, 10, 5 и 1 юан, необходими в този ред.\nЦелта е да се минимизира общият брой банкноти, като се използват по-големи номинали, където е възможно.\n\nПример:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "zh": "计算所需的各种面额的货币数量以组成给定金额。  \n该函数接受一个表示总金额的整数，并返回一个整数列表。  \n该列表包含所需的100、50、20、10、5和1元纸币的数量，按此顺序排列。  \n目标是通过尽可能使用较大面额来最小化纸币的总数量。\n\n示例：\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "fr": "Calculer le nombre de différentes dénominations de monnaie nécessaires pour constituer un montant donné.  \nLa fonction prend un entier représentant le montant total et renvoie une liste d'entiers.  \nLa liste contient le nombre de billets de 100, 50, 20, 10, 5 et 1 yuan nécessaires, dans cet ordre.  \nL'objectif est de minimiser le nombre total de billets en utilisant des dénominations plus grandes lorsque c'est possible.\n\nExemple :\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "de": "Berechne die Anzahl der verschiedenen Währungsdenominationen, die benötigt werden, um einen gegebenen Betrag zu bilden.\nDie Funktion nimmt eine ganze Zahl, die den Gesamtbetrag darstellt, und gibt eine Liste von ganzen Zahlen zurück.\nDie Liste enthält die Anzahl der 100, 50, 20, 10, 5 und 1 Yuan-Scheine, die benötigt werden, in dieser Reihenfolge.\nDas Ziel ist es, die Gesamtanzahl der Scheine zu minimieren, indem, wo möglich, größere Denominationen verwendet werden.\n\nBeispiel:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "ha": "Ƙididdige adadin nau'ikan kuɗi daban-daban da ake buƙata don samar da adadin da aka bayar.\nAikin yana ɗaukar lamba mai wakiltar jimlar adadin kuma yana mayar da jerin lambobi.\nJerin yana ƙunshe da adadin takardun kuɗi na 100, 50, 20, 10, 5, da 1 yuan da ake buƙata, a wannan tsari.\nManufar ita ce rage jimlar adadin takardun kuɗi ta amfani da manyan nau'ikan inda zai yiwu.\n\nMisali:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "hi": "दिए गए राशि को बनाने के लिए आवश्यक विभिन्न मूल्यवर्ग के मुद्रा नोटों की संख्या की गणना करें। \nयह फ़ंक्शन एक पूर्णांक लेता है जो कुल राशि का प्रतिनिधित्व करता है और पूर्णांकों की एक सूची लौटाता है। \nसूची में 100, 50, 20, 10, 5, और 1 युआन नोटों की संख्या होती है, इसी क्रम में। \nलक्ष्य यह है कि जहाँ संभव हो बड़े मूल्यवर्ग का उपयोग करके कुल नोटों की संख्या को न्यूनतम किया जाए।\n\nउदाहरण:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "hu": "Számítsd ki, hogy egy adott összeghez hány különböző címletű bankjegy szükséges.\nA függvény egy egész számot vesz át, amely az összértéket jelenti, és egy egész számokat tartalmazó listát ad vissza.\nA lista a szükséges 100, 50, 20, 10, 5 és 1 jüan címletű bankjegyek számát tartalmazza, ebben a sorrendben.\nA cél az, hogy a nagyobb címletek használatával minimalizáljuk a bankjegyek teljes számát.\n\nPélda:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123"
    },
    "docstring_bertscore": {
      "sq": "0.9872483267983222",
      "hy": "0.9897262408017324",
      "bn": "0.9647288059788728",
      "bg": "0.9743256328385734",
      "zh": "0.9743357629880063",
      "fr": "0.9876714095099266",
      "de": "0.9842742341030869",
      "ha": "0.9512662346434713",
      "hi": "0.9845205357755701",
      "hu": "0.9622346042842177"
    }
  },
  {
    "task_id": "Kotlin/32",
    "prompt": {
      "en": "/**\n * Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\n * The search is conducted in ascending order.\n *\n * Example:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "sq": "/**\n * Gjen numrin e n-të me tre shifra që është katror i përsosur dhe ka të paktën dy shifra identike.\n * Kërkimi kryhet në rend rritës.\n *\n * Shembull:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */ \n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int",
      "hy": "/**\n * Գտնում է n-րդ եռանիշ թիվը, որը կատարյալ քառակուսի է և ունի առնվազն երկու նույնական թվանշան:\n * Որոնումը կատարվում է աճման կարգով:\n *\n * Օրինակ:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */ \n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int",
      "bn": "/**\n * n-তম তিন অঙ্কের সংখ্যা খুঁজে বের করে যা একটি পূর্ণবর্গ সংখ্যা এবং যার অন্তত দুটি অভিন্ন অঙ্ক রয়েছে।\n * অনুসন্ধান ঊর্ধ্বক্রমে পরিচালিত হয়।\n *\n * উদাহরণ:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "bg": "/**\n * Намира n-тото трицифрено число, което е точен квадрат и има поне две еднакви цифри.\n * Търсенето се извършва във възходящ ред.\n *\n * Пример:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "zh": "/**\n * 查找第n个三位数的完全平方数，并且至少有两个相同的数字。\n * 搜索按升序进行。\n *\n * 示例:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "fr": "/**\n * Trouve le n-ième nombre à trois chiffres qui est un carré parfait et qui a au moins deux chiffres identiques.\n * La recherche est effectuée dans l'ordre croissant.\n *\n * Exemple:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */ \n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "de": "/**\n * Findet die n-te dreistellige Zahl, die ein perfektes Quadrat ist und mindestens zwei identische Ziffern hat.\n * Die Suche wird in aufsteigender Reihenfolge durchgeführt.\n *\n * Beispiel:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "ha": "/**\n * Nemo lamba ta uku mai tsawo wadda ta kasance cikakkiyar murabba'i kuma tana da aƙalla lambobi guda biyu daidai.\n * Binciken ana yin sa ne a cikin tsari mai hawa.\n *\n * Misali:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */ \n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "hi": "/**\n * वह n-वां तीन-अंकीय संख्या खोजता है जो एक पूर्ण वर्ग है और जिसमें कम से कम दो समान अंक होते हैं।\n * खोज आरोही क्रम में की जाती है।\n *\n * उदाहरण:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "hu": "/**\n * Megkeresi az n-edik háromjegyű számot, amely tökéletes négyzet és legalább két azonos számjegyet tartalmaz.\n * A keresés növekvő sorrendben történik.\n *\n * Példa:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9982127238314481",
      "bn": "0.9503360485690848",
      "bg": "0.9560063500564878",
      "zh": "0.9228710285226288",
      "fr": "1",
      "de": "0.9577262905258689",
      "ha": "0.9529855792217092",
      "hi": "0.9531377300935819",
      "hu": "0.9470465308287661"
    },
    "canonical_solution": "{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}",
    "instruction": {
      "en": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nՏվեք կարճ բնութագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nBa da takaitaccen bayanin harshen dabi'a (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int\n{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (dokumentációs szöveget) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9001689663830083",
      "bn": "0.8777010894626279",
      "bg": "0.8383597137705134",
      "zh": "0.853715080539998",
      "fr": "0.9695779694710775",
      "de": "0.9385961985283988",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.8856129348000096"
    },
    "level": "",
    "test": "fun main() {\n    check(findNthSquareNumberWithDuplicateDigits(1) == 100)\n    check(findNthSquareNumberWithDuplicateDigits(2) == 121)\n    check(findNthSquareNumberWithDuplicateDigits(3) == 144)  // Example of another test case\n    check(findNthSquareNumberWithDuplicateDigits(4) == 225)  // Example of another test case\n}\n\n\nmain()",
    "entry_point": "findNthSquareNumberWithDuplicateDigits",
    "signature": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int",
    "docstring": {
      "en": "Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\nThe search is conducted in ascending order.\n\nExample:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "sq": "Gjen numrin e tretë me tre shifra që është një katror perfekt dhe ka të paktën dy shifra identike. Kërkimi kryhet në rend rritës.\n\nShembull:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "hy": "Գտնում է n-րդ եռանիշ թիվը, որը կատարյալ քառակուսի է և ունի առնվազն երկու նույնական թվանշան:\nՈրոնումը կատարվում է աճման կարգով:\n\nՕրինակ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "bn": "n-তম তিন অঙ্কের সংখ্যা খুঁজে বের করে যা একটি পূর্ণ বর্গ এবং যার অন্তত দুটি অভিন্ন অঙ্ক রয়েছে। অনুসন্ধানটি ঊর্ধ্বক্রমে পরিচালিত হয়।\n\nউদাহরণ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "bg": "Намира n-тото трицифрено число, което е точен квадрат и има поне две еднакви цифри. Търсенето се извършва във възходящ ред.\n\nПример:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "zh": "找到第 n 个三位数的完全平方数，并且至少有两个相同的数字。搜索按升序进行。\n\n示例：\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "fr": "Trouve le n-ième nombre à trois chiffres qui est un carré parfait et qui a au moins deux chiffres identiques.  \nLa recherche est effectuée dans l'ordre croissant.\n\nExemple :\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "de": "Findet die n-te dreistellige Zahl, die eine perfekte Quadratzahl ist und mindestens zwei identische Ziffern hat. Die Suche erfolgt in aufsteigender Reihenfolge.\n\nBeispiel:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "ha": "Yana nemo lamba ta uku mai lamba uku wanda yake cikakken murabba'i kuma yana da aƙalla lambobi biyu masu kama.\nAna gudanar da binciken a cikin tsari mai hawa.\n\nMisali:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "hi": "n-वां तीन-अंकीय संख्या खोजता है जो एक पूर्ण वर्ग है और जिसमें कम से कम दो समान अंक हैं। खोज आरोही क्रम में की जाती है।\n\nउदाहरण:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "hu": "Megkeresi az n-edik háromjegyű számot, amely tökéletes négyzet és legalább két azonos számjegyet tartalmaz. A keresés növekvő sorrendben történik.\n\nPélda:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121"
    },
    "docstring_bertscore": {
      "sq": "0.9844861727196511",
      "hy": "0.9972718117164858",
      "bn": "1",
      "bg": "0.9972718117164858",
      "zh": "0.9543179918176913",
      "fr": "0.9893049457635574",
      "de": "1",
      "ha": "0.9518408723358052",
      "hi": "0.970349251240636",
      "hu": "0.9840622954865227"
    }
  },
  {
    "task_id": "Kotlin/33",
    "prompt": {
      "en": "/**\n    * Finds the longest word in a given simple English sentence. The sentence ends with a period,\n    * and words are separated by spaces. It assumes no abbreviations or special forms are present.\n    * If there are multiple longest words of the same length, the first one is returned.\n    *\n    * Example:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ",
      "sq": "/**\n    * Gjen fjalën më të gjatë në një fjali të thjeshtë në anglisht. Fjalija përfundon me një pikë,\n    * dhe fjalët ndahen me hapësira. Supozohet se nuk ka shkurtesa apo forma të veçanta.\n    * Nëse ka disa fjalë më të gjata me të njëjtën gjatësi, kthehet e para.\n    *\n    * Shembull:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "hy": "/**\n    * Գտնում է ամենաերկար բառը տրված պարզ անգլերեն նախադասության մեջ: Նախադասությունը ավարտվում է կետով,\n    * և բառերը բաժանված են բացատներով: Ենթադրվում է, որ կրճատումներ կամ հատուկ ձևեր չկան:\n    * Եթե կան մի քանի ամենաերկար բառեր նույն երկարությամբ, վերադարձվում է առաջինը:\n    *\n    * Օրինակ:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "bn": "/**\n    * একটি সরল ইংরেজি বাক্যে সবচেয়ে দীর্ঘ শব্দটি খুঁজে বের করে। বাক্যটি একটি পূর্ণবিরাম দিয়ে শেষ হয়,\n    * এবং শব্দগুলি ফাঁকা স্থান দ্বারা পৃথক হয়। এটি ধরে নেয় যে কোন সংক্ষিপ্ত রূপ বা বিশেষ ফর্ম উপস্থিত নেই।\n    * যদি একই দৈর্ঘ্যের একাধিক দীর্ঘতম শব্দ থাকে, তবে প্রথমটি ফেরত দেওয়া হয়।\n    *\n    * উদাহরণ:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "bg": "/**\n    * Намира най-дългата дума в дадено просто английско изречение. Изречението завършва с точка,\n    * а думите са разделени с интервали. Предполага се, че няма съкращения или специални форми.\n    * Ако има няколко най-дълги думи с еднаква дължина, се връща първата.\n    *\n    * Пример:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "zh": "/**\n    * 查找给定简单英文句子中最长的单词。句子以句号结尾，单词由空格分隔。假设不存在缩写或特殊形式。\n    * 如果有多个长度相同的最长单词，则返回第一个。\n    *\n    * 示例：\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "fr": "/**\n    * Trouve le mot le plus long dans une phrase simple en anglais donnée. La phrase se termine par un point,\n    * et les mots sont séparés par des espaces. Il suppose qu'il n'y a pas d'abréviations ou de formes spéciales présentes.\n    * S'il y a plusieurs mots les plus longs de la même longueur, le premier est retourné.\n    *\n    * Exemple:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/ \n\nfun findLongestWord(sentence: String): String ",
      "de": "/**\n    * Findet das längste Wort in einem gegebenen einfachen englischen Satz. Der Satz endet mit einem Punkt,\n    * und Wörter sind durch Leerzeichen getrennt. Es wird angenommen, dass keine Abkürzungen oder speziellen Formen vorhanden sind.\n    * Wenn es mehrere längste Wörter mit derselben Länge gibt, wird das erste zurückgegeben.\n    *\n    * Beispiel:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "ha": "/**\n    * Nemi mafi tsawon kalma a cikin wani jumlar Turanci mai sauki. Jumlar tana karewa da aya,\n    * kuma kalmomi suna rabuwa da sarari. Ana tsammanin babu gajerun kalmomi ko siffofi na musamman.\n    * Idan akwai kalmomi masu tsawo iri daya, na farko ne za a dawo da shi.\n    *\n    * Misali:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "hi": "/**\n    * एक दिए गए साधारण अंग्रेजी वाक्य में सबसे लंबा शब्द खोजता है। वाक्य एक बिंदु के साथ समाप्त होता है,\n    * और शब्द रिक्त स्थान द्वारा अलग होते हैं। यह मानता है कि कोई संक्षिप्त रूप या विशेष रूप नहीं हैं।\n    * यदि समान लंबाई के कई सबसे लंबे शब्द हैं, तो पहला लौटाया जाता है।\n    *\n    * उदाहरण:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "hu": "/**\n    * Megkeresi a leghosszabb szót egy adott egyszerű angol mondatban. A mondat ponttal végződik,\n    * és a szavakat szóközök választják el. Feltételezi, hogy nincsenek rövidítések vagy speciális formák jelen.\n    * Ha több azonos hosszúságú leghosszabb szó van, az elsőt adja vissza.\n    *\n    * Példa:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9315817652525328",
      "hy": "0.9356554757371773",
      "bn": "0.9495300064828452",
      "bg": "0.9354737289385303",
      "zh": "0.9323018003837842",
      "fr": "0.9938762253526944",
      "de": "0.9422913195067908",
      "ha": "0.9169717062058926",
      "hi": "0.954054210671677",
      "hu": "0.9431998548696444"
    },
    "canonical_solution": "{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}",
    "instruction": {
      "en": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nনিম্নলিখিত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки най-много 500 знака.",
      "zh": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nBa da taƙaitaccen bayanin yaren ɗan adam (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nकृपया निम्नलिखित कोड के लिए अधिकतम 500 वर्णों में संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें।",
      "hu": "fun findLongestWord(sentence: String): String\n{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.9417669353008588",
      "bn": "0.8777010894626279",
      "bg": "0.8306217165497387",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.899876582462125",
      "hi": "0.8422594705745728",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(findLongestWord(\"I am a student of Peking University.\") == \"University\")\n    check(findLongestWord(\"Hello world.\") == \"Hello\")\n    check(findLongestWord(\"Short sentences are sweet.\") == \"sentences\")\n    check(findLongestWord(\"Each word has its own length.\") == \"length\")\n}\n\n\nmain()",
    "entry_point": "findLongestWord",
    "signature": "fun findLongestWord(sentence: String): String",
    "docstring": {
      "en": "Finds the longest word in a given simple English sentence. The sentence ends with a period,\nand words are separated by spaces. It assumes no abbreviations or special forms are present.\nIf there are multiple longest words of the same length, the first one is returned.\n\nExample:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "sq": "Gjen fjalën më të gjatë në një fjali të thjeshtë në anglisht. Fjalitë përfundojnë me një pikë, dhe fjalët ndahen nga hapësira. Supozohet se nuk ka shkurtime ose forma të veçanta të pranishme. Nëse ka disa fjalë më të gjata me të njëjtën gjatësi, kthehet e para.\n\nShembull:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "hy": "Գտնում է ամենաերկար բառը տրված պարզ անգլերեն նախադասության մեջ։ Նախադասությունը ավարտվում է կետով, և բառերը բաժանված են բացատներով։ Ենթադրվում է, որ կրճատումներ կամ հատուկ ձևեր չկան։ Եթե կան մի քանի ամենաերկար բառեր նույն երկարությամբ, վերադարձվում է առաջինը։\n\nՕրինակ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "bn": "দেওয়া সহজ ইংরেজি বাক্যে সবচেয়ে দীর্ঘ শব্দটি খুঁজে বের করে। বাক্যটি একটি পূর্ণবিরতিতে শেষ হয়, এবং শব্দগুলি স্পেস দ্বারা পৃথক করা হয়। এটি ধরে নেয় যে কোন সংক্ষিপ্ত রূপ বা বিশেষ ফর্ম উপস্থিত নেই। যদি একই দৈর্ঘ্যের একাধিক দীর্ঘ শব্দ থাকে, তবে প্রথমটিই ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "bg": "Намира най-дългата дума в дадено просто английско изречение. Изречението завършва с точка, а думите са разделени с интервали. Предполага се, че няма съкращения или специални форми. Ако има няколко най-дълги думи с еднаква дължина, се връща първата.\n\nПример:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "zh": "找到给定简单英文句子中最长的单词。句子以句号结尾，单词之间用空格分隔。假设不存在缩写或特殊形式。如果有多个长度相同的最长单词，则返回第一个。\n\n示例：\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "fr": "Trouve le mot le plus long dans une phrase anglaise simple donnée. La phrase se termine par un point, et les mots sont séparés par des espaces. Il suppose qu'il n'y a pas d'abréviations ou de formes spéciales présentes. S'il y a plusieurs mots les plus longs de même longueur, le premier est retourné.\n\nExemple :\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "de": "Findet das längste Wort in einem gegebenen einfachen englischen Satz. Der Satz endet mit einem Punkt, und die Wörter sind durch Leerzeichen getrennt. Es wird angenommen, dass keine Abkürzungen oder speziellen Formen vorhanden sind. Wenn es mehrere längste Wörter mit derselben Länge gibt, wird das erste zurückgegeben.\n\nBeispiel:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "ha": "Yana nemo kalma mafi tsawo a cikin wata jumla mai sauƙi ta Turanci. Jumlar tana ƙarewa da aya, kuma kalmomi suna rabuwa da sarari. Ana ɗauka babu gajerun kalmomi ko siffofi na musamman. Idan akwai kalmomi masu tsawo iri ɗaya, na farko ake mayarwa.\n\nMisali:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "hi": "दिए गए सरल अंग्रेजी वाक्य में सबसे लंबा शब्द ढूंढता है। वाक्य एक पूर्ण विराम के साथ समाप्त होता है, और शब्दों को रिक्त स्थान द्वारा अलग किया जाता है। यह मानता है कि कोई संक्षिप्त रूप या विशेष स्वरूप मौजूद नहीं हैं। यदि समान लंबाई के कई सबसे लंबे शब्द हैं, तो पहला लौटाया जाता है।\n\nउदाहरण:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "hu": "Megkeresi a leghosszabb szót egy adott egyszerű angol mondatban. A mondat ponttal végződik, és a szavakat szóközök választják el. Feltételezi, hogy nincsenek rövidítések vagy speciális formák jelen. Ha több azonos hosszúságú leghosszabb szó van, az elsőt adja vissza.\n\nPélda:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\""
    },
    "docstring_bertscore": {
      "sq": "0.9571770775223074",
      "hy": "0.9624568716805958",
      "bn": "0.9636204484526981",
      "bg": "0.972592384133663",
      "zh": "0.9695302981796292",
      "fr": "0.9834793153181852",
      "de": "0.9681033375222745",
      "ha": "0.948218847337634",
      "hi": "0.979891256115171",
      "hu": "0.9776520958297648"
    }
  },
  {
    "task_id": "Kotlin/34",
    "prompt": {
      "en": "/**\n    * Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\n    * Assumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n    *\n    * Example:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // For a leap year\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // For end of the year\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "sq": "/**\n    * Llogarit datën e ditës së nesërme bazuar në një datë të dhënë në formatin vvvv-mm-dd.\n    * Supozon data hyrëse të vlefshme që variojnë nga 1600-01-01 deri në 2999-12-30.\n    *\n    * Shembull:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Për një vit të brishtë\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Për fundin e vitit\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "hy": "/**\n    * Հաշվում է հաջորդ օրվա ամսաթիվը՝ հիմնվելով տրված yyyy-mm-dd ձևաչափով ամսաթվի վրա:\n    * Ենթադրում է վավեր մուտքային ամսաթվեր՝ 1600-01-01-ից մինչև 2999-12-30:\n    *\n    * Օրինակ:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Նահանջ տարվա համար\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Տարվա վերջի համար\n**/ \n\nfun getNextDayDate(currentDate: String): String ",
      "bn": "/**\n    * প্রদত্ত তারিখের ভিত্তিতে yyyy-mm-dd ফরম্যাটে পরবর্তী দিনের তারিখ গণনা করে।\n    * 1600-01-01 থেকে 2999-12-30 পর্যন্ত বৈধ ইনপুট তারিখ অনুমান করে।\n    *\n    * উদাহরণ:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // একটি অধিবর্ষের জন্য\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // বছরের শেষের জন্য\n**/ \n\nfun getNextDayDate(currentDate: String): String ",
      "bg": "/**\n    * Изчислява датата на следващия ден въз основа на дадена дата във формат гггг-мм-дд.\n    * Предполага валидни входни дати в диапазона от 1600-01-01 до 2999-12-30.\n    *\n    * Пример:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // За високосна година\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // За края на годината\n**/",
      "zh": "/**\n    * 根据格式为 yyyy-mm-dd 的给定日期计算下一天的日期。\n    * 假设有效输入日期范围为 1600-01-01 到 2999-12-30。\n    *\n    * 示例:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // 闰年\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // 年末\n**/",
      "fr": "/**\n    * Calcule la date du jour suivant en fonction d'une date donnée au format aaaa-mm-jj.\n    * Suppose des dates d'entrée valides allant de 1600-01-01 à 2999-12-30.\n    *\n    * Exemple :\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Pour une année bissextile\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Pour la fin de l'année\n**/ \n\nfun getNextDayDate(currentDate: String): String ",
      "de": "/**\n    * Berechnet das Datum des nächsten Tages basierend auf einem gegebenen Datum im Format yyyy-mm-dd.\n    * Geht von gültigen Eingabedaten im Bereich von 1600-01-01 bis 2999-12-30 aus.\n    *\n    * Beispiel:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Für ein Schaltjahr\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Für das Jahresende\n**/",
      "ha": "/**\n    * Lissafa ranar gobe bisa ga wata ranar da aka bayar a tsarin yyyy-mm-dd.\n    * Yana ɗauka ingantattun ranakun shigarwa daga 1600-01-01 zuwa 2999-12-30.\n    *\n    * Misali:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Don shekara mai tsallakewa\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Don ƙarshen shekara\n**/",
      "hi": "/**\n    * दिए गए दिनांक के आधार पर अगले दिन की तिथि की गणना करता है, प्रारूप yyyy-mm-dd में।\n    * 1600-01-01 से 2999-12-30 तक की मान्य इनपुट तिथियों को मानता है।\n    *\n    * उदाहरण:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // एक लीप वर्ष के लिए\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // वर्ष के अंत के लिए\n**/",
      "hu": "/**\n    * Kiszámítja a következő nap dátumát egy adott dátum alapján, amely a yyyy-mm-dd formátumban van megadva.\n    * Feltételezi az érvényes bemeneti dátumokat, amelyek 1600-01-01 és 2999-12-30 között vannak.\n    *\n    * Példa:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Szökőévre\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Az év végére\n**/ \n\nfun getNextDayDate(currentDate: String): String "
    },
    "prompt_bertscore": {
      "sq": "0.9973266337016514",
      "hy": "0.9791974401942162",
      "bn": "0.9812189015820082",
      "bg": "0.9576764343002291",
      "zh": "0.9371529501797993",
      "fr": "0.9973266337016514",
      "de": "0.9540337517424303",
      "ha": "0.9576730575837515",
      "hi": "0.9569901663337536",
      "hu": "0.9659583280374788"
    },
    "canonical_solution": "{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}",
    "instruction": {
      "en": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nকোটলিন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nकृपया निम्नलिखित Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun getNextDayDate(currentDate: String): String\n{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.8909350372294584",
      "bn": "0.8877698621076675",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9368963197275022",
      "hi": "0.8742320098578537",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(getNextDayDate(\"2010-07-05\") == \"2010-07-06\")\n    check(getNextDayDate(\"2020-02-28\") == \"2020-02-29\") // Leap year case\n    check(getNextDayDate(\"2020-12-31\") == \"2021-01-01\") // End of the year case\n    check(getNextDayDate(\"2019-02-28\") == \"2019-03-01\") // Non-leap year February case\n}\n\nmain()",
    "entry_point": "getNextDayDate",
    "signature": "fun getNextDayDate(currentDate: String): String",
    "docstring": {
      "en": "Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\nAssumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n\nExample:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // For a leap year\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // For end of the year",
      "sq": "Llogarit datën e ditës së ardhshme bazuar në një datë të dhënë në formatin vvvv-mm-dd. Supozon data hyrëse të vlefshme që variojnë nga 1600-01-01 deri në 2999-12-30.\n\nShembull:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Për një vit të brishtë\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Për fundin e vitit",
      "hy": "Հաշվում է հաջորդ օրվա ամսաթիվը՝ հիմնվելով տրված ամսաթվի վրա yyyy-mm-dd ձևաչափով:\nԵնթադրում է վավեր մուտքային ամսաթվեր 1600-01-01-ից մինչև 2999-12-30:\n\nՕրինակ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Նահանջ տարի համար\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Տարվա վերջի համար",
      "bn": "প্রদত্ত তারিখের উপর ভিত্তি করে yyyy-mm-dd ফরম্যাটে পরবর্তী দিনের তারিখ গণনা করে। বৈধ ইনপুট তারিখগুলি 1600-01-01 থেকে 2999-12-30 পর্যন্ত ধরে নেয়।\n\nউদাহরণ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // একটি অধিবর্ষের জন্য\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // বছরের শেষের জন্য",
      "bg": "Изчислява датата на следващия ден въз основа на дадена дата във формат гггг-мм-дд. Предполага валидни входни дати в диапазона от 1600-01-01 до 2999-12-30.\n\nПример:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // За високосна година\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // За края на годината",
      "zh": "计算基于给定日期的下一天日期，格式为 yyyy-mm-dd。假设输入日期有效，范围从 1600-01-01 到 2999-12-30。\n\n示例：\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // 闰年\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // 年末",
      "fr": "Calcule la date du jour suivant en fonction d'une date donnée au format aaaa-mm-jj. Suppose des dates d'entrée valides allant du 1600-01-01 au 2999-12-30.\n\nExemple :\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Pour une année bissextile\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Pour la fin de l'année",
      "de": "Berechnet das Datum des nächsten Tages basierend auf einem gegebenen Datum im Format yyyy-mm-dd. Geht von gültigen Eingabedaten im Bereich von 1600-01-01 bis 2999-12-30 aus.\n\nBeispiel:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Für ein Schaltjahr\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Für das Jahresende",
      "ha": "Yana lissafin ranar gobe bisa ga wata ranar da aka bayar a tsarin yyyy-mm-dd. \n\nYana ɗaukar shigar da kwanan wata masu inganci daga 1600-01-01 zuwa 2999-12-30.\n\nMisali:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Don shekara mai tsalle\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Don ƙarshen shekara",
      "hi": "दिए गए दिनांक के आधार पर अगले दिन की तिथि की गणना करता है, जो yyyy-mm-dd प्रारूप में है। \n1600-01-01 से 2999-12-30 तक की मान्य इनपुट तिथियों को मानता है।\n\nउदाहरण:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // एक लीप वर्ष के लिए\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // वर्ष के अंत के लिए",
      "hu": "Kiszámítja a következő nap dátumát egy adott dátum alapján az yyyy-mm-dd formátumban. Feltételezi az érvényes bemeneti dátumokat, amelyek 1600-01-01 és 2999-12-30 között vannak.\n\nPélda:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Szökőév esetén\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Az év végén"
    },
    "docstring_bertscore": {
      "sq": "0.9957769194688172",
      "hy": "0.9662006571023414",
      "bn": "0.9744362699608099",
      "bg": "0.9866347575513055",
      "zh": "0.9568606593253188",
      "fr": "0.9957769194688172",
      "de": "0.9817468611347989",
      "ha": "0.970081497487001",
      "hi": "0.9804666883290291",
      "hu": "0.9728406721099566"
    }
  },
  {
    "task_id": "Kotlin/35",
    "prompt": {
      "en": "/**\n    * Calculates the number of days between two given dates.\n    * The dates are provided as year, month, and day.\n    * Accounts for leap years in the calculation.\n    *\n    * Example:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "sq": "/**\n    * Llogarit numrin e ditëve midis dy datave të dhëna.\n    * Datat jepen si vit, muaj dhe ditë.\n    * Merr parasysh vitet e brishtë në llogaritje.\n    *\n    * Shembull:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "hy": "/**\n    * Հաշվում է օրերի քանակը երկու տրված ամսաթվերի միջև։\n    * Ամսաթվերը տրվում են որպես տարի, ամիս և օր։\n    * Հաշվի է առնում նահանջ տարիները հաշվարկում։\n    *\n    * Օրինակ:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "bn": "/**\n    * দুটি প্রদত্ত তারিখের মধ্যে দিনের সংখ্যা গণনা করে।\n    * তারিখগুলি বছর, মাস এবং দিন হিসাবে প্রদান করা হয়।\n    * গণনায় অধিবর্ষের হিসাব করে।\n    *\n    * উদাহরণ:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "bg": "/**\n    * Изчислява броя на дните между две дадени дати.\n    * Датите са предоставени като година, месец и ден.\n    * Взема предвид високосните години в изчислението.\n    *\n    * Пример:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "zh": "/**\n    * 计算两个给定日期之间的天数。\n    * 日期以年、月、日的形式提供。\n    * 在计算中考虑了闰年。\n    *\n    * 示例:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "fr": "/**\n    * Calcule le nombre de jours entre deux dates données.\n    * Les dates sont fournies sous forme d'année, mois et jour.\n    * Prend en compte les années bissextiles dans le calcul.\n    *\n    * Exemple:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "de": "/**\n    * Berechnet die Anzahl der Tage zwischen zwei gegebenen Daten.\n    * Die Daten werden als Jahr, Monat und Tag angegeben.\n    * Berücksichtigt Schaltjahre in der Berechnung.\n    *\n    * Beispiel:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "ha": "/**\n    * Lissafa yawan kwanaki tsakanin kwanakin da aka bayar guda biyu.\n    * An bayar da kwanakin a matsayin shekara, wata, da rana.\n    * Yana la'akari da shekarun tsallakewa a cikin lissafin.\n    *\n    * Misali:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "hi": "/**\n    * दो दिए गए तिथियों के बीच दिनों की संख्या की गणना करता है।\n    * तिथियाँ वर्ष, माह, और दिन के रूप में प्रदान की जाती हैं।\n    * गणना में लीप वर्षों का ध्यान रखता है।\n    *\n    * उदाहरण:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "hu": "/**\n    * Kiszámítja a napok számát két adott dátum között.\n    * A dátumok év, hónap és nap formátumban vannak megadva.\n    * Figyelembe veszi a szökőéveket a számítás során.\n    *\n    * Példa:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int"
    },
    "prompt_bertscore": {
      "sq": "0.9833796028669057",
      "hy": "0.9934875056970092",
      "bn": "0.9863185379846979",
      "bg": "0.9909633108148178",
      "zh": "0.9766355055396282",
      "fr": "0.9713378346470467",
      "de": "0.9887259382028408",
      "ha": "0.9863844832712015",
      "hi": "0.9744338863962375",
      "hu": "0.9798433861933417"
    },
    "canonical_solution": "{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}",
    "instruction": {
      "en": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nনিম্নলিখিত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\n请用中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int\n{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9001689663830083",
      "bn": "0.8777010894626279",
      "bg": "0.8383597137705134",
      "zh": "0.8901365430976982",
      "fr": "0.9695779694710775",
      "de": "0.9385961985283988",
      "ha": "0.9250790038382126",
      "hi": "0.8761702451159921",
      "hu": "0.9335354936803919"
    },
    "level": "",
    "test": "fun main() {\n    check(daysBetweenDates(2008, 1, 1, 2009, 1, 1) == 366)\n    check(daysBetweenDates(2010, 1, 1, 2010, 1, 3) == 2)\n    check(daysBetweenDates(2020, 5, 15, 2020, 5, 20) == 5)\n    check(daysBetweenDates(2019, 12, 31, 2020, 1, 1) == 1)\n}\n\n\nmain()",
    "entry_point": "daysBetweenDates",
    "signature": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
    "docstring": {
      "en": "Calculates the number of days between two given dates.\nThe dates are provided as year, month, and day.\nAccounts for leap years in the calculation.\n\nExample:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "sq": "Llogarit numrin e ditëve midis dy datave të dhëna.\nDatat jepen si vit, muaj dhe ditë.\nLlogarit vitet e brishtë në përllogaritje.\n\nShembull:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hy": "Հաշվում է օրերի քանակը երկու տրված ամսաթվերի միջև։\nԱմսաթվերը տրվում են որպես տարի, ամիս և օր։\nՀաշվի է առնում նահանջ տարիները հաշվարկի մեջ։\n\nՕրինակ:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "bn": "দুটি প্রদত্ত তারিখের মধ্যে দিনের সংখ্যা গণনা করে।  \nতারিখগুলি বছর, মাস এবং দিন হিসাবে প্রদান করা হয়।  \nলিপ বছরের হিসাব অন্তর্ভুক্ত করে।  \n\nউদাহরণ:  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2  ",
      "bg": "Изчислява броя на дните между две дадени дати.\nДатите са предоставени като година, месец и ден.\nВзема предвид високосните години в изчислението.\n\nПример:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "zh": "计算两个给定日期之间的天数。\n日期以年、月和日的形式提供。\n在计算中考虑了闰年。\n\n示例：\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "fr": "Calcule le nombre de jours entre deux dates données.\nLes dates sont fournies sous forme d'année, mois et jour.\nPrend en compte les années bissextiles dans le calcul.\n\nExemple :\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "de": "Berechnet die Anzahl der Tage zwischen zwei gegebenen Daten.\nDie Daten werden als Jahr, Monat und Tag angegeben.\nBerücksichtigt Schaltjahre in der Berechnung.\n\nBeispiel:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "ha": "Lissafa yawan kwanaki tsakanin ranaku biyu da aka bayar.\nAna bayar da ranakun azaman shekara, wata, da rana.\nYa ƙunshi shekarun ƙabis a cikin lissafin.\n\nMisali:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hi": "दो दी गई तिथियों के बीच दिनों की संख्या की गणना करता है।  \nतिथियाँ वर्ष, माह और दिन के रूप में प्रदान की जाती हैं।  \nलीप वर्षों के लिए गणना में ध्यान रखा गया है।\n\nउदाहरण:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hu": "Számítja a napok számát két adott dátum között.  \nA dátumok év, hónap és nap formátumban vannak megadva.  \nFigyelembe veszi a szökőéveket a számítás során.\n\nPélda:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9718475202047822",
      "hy": "0.9852215023902422",
      "bn": "0.9600901906905651",
      "bg": "0.9854983931414049",
      "zh": "0.9639813598550385",
      "fr": "0.9594086898532344",
      "de": "0.9852215023902422",
      "ha": "0.979082631833978",
      "hi": "0.9787624396597497",
      "hu": "0.9722282946452261"
    }
  },
  {
    "task_id": "Kotlin/36",
    "prompt": {
      "en": "/**\n * Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\n * An n-gram is a contiguous sequence of n characters from the text.\n * \n * Args:\n * n (Int): The length of each n-gram.\n * text (String): The text to analyze for n-grams.\n * \n * Returns:\n * Pair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\n * and the second element is a list of n-grams with that frequency, in the order they first appear in the text.\n * If the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "sq": "/**\n * Gjen n-gramet më të shpeshta (nënvargjet me gjatësi n) në tekstin e dhënë dhe frekuencën e tyre.\n * Një n-gram është një sekuencë e pandërprerë prej n karakteresh nga teksti.\n * \n * Argumentet:\n * n (Int): Gjatësia e secilit n-gram.\n * text (String): Teksti për të analizuar për n-grame.\n * \n * Kthen:\n * Pair<Int, List<String>>: Një çift ku elementi i parë është frekuenca më e lartë e çdo n-grame,\n * dhe elementi i dytë është një listë e n-grameve me atë frekuencë, në rendin që shfaqen së pari në tekst.\n * Nëse frekuenca më e lartë nuk është më e madhe se 1, kthen \"NO\" si elementi i vetëm në listë.\n * \n * Shembuj:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */ \n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "hy": "/**\n * Գտնում է ամենահաճախ հանդիպող n-գրամները (n երկարության ենթատողեր) տրված տեքստում և դրանց հաճախականությունը։\n * N-գրամը տեքստից n սիմվոլների շարունակական հաջորդականություն է։\n * \n * Փոփոխականներ:\n * n (Int): Յուրաքանչյուր n-գրամի երկարությունը։\n * text (String): Տեքստը, որը պետք է վերլուծել n-գրամների համար։\n * \n * Վերադարձնում է:\n * Pair<Int, List<String>>: Զույգ, որտեղ առաջին տարրը ցանկացած n-գրամի ամենաբարձր հաճախականությունն է,\n * իսկ երկրորդ տարրը n-գրամների ցուցակն է այդ հաճախականությամբ, այն հերթականությամբ, որով դրանք առաջին անգամ հայտնվում են տեքստում։\n * Եթե ամենաբարձր հաճախականությունը 1-ից մեծ չէ, վերադարձնում է \"NO\" որպես ցուցակի միակ տարր։\n * \n * Օրինակներ:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "bn": "/**\n * প্রদত্ত টেক্সটে সবচেয়ে ঘন ঘন n-গ্রাম (n দৈর্ঘ্যের সাবস্ট্রিং) এবং তাদের ঘনত্ব খুঁজে বের করে।\n * একটি n-গ্রাম হল টেক্সট থেকে n অক্ষরের একটি ধারাবাহিক ক্রম।\n * \n * Args:\n * n (Int): প্রতিটি n-গ্রামের দৈর্ঘ্য।\n * text (String): n-গ্রামের জন্য বিশ্লেষণ করতে টেক্সট।\n * \n * Returns:\n * Pair<Int, List<String>>: একটি জোড়া যেখানে প্রথম উপাদানটি কোনো n-গ্রামের সর্বোচ্চ ঘনত্ব,\n * এবং দ্বিতীয় উপাদানটি সেই ঘনত্ব সহ n-গ্রামের একটি তালিকা, যেভাবে তারা প্রথমে টেক্সটে উপস্থিত হয় সেই ক্রমে।\n * যদি সর্বোচ্চ ঘনত্ব 1 এর চেয়ে বেশি না হয়, তাহলে \"NO\" তালিকার একমাত্র উপাদান হিসাবে ফেরত দেয়।\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "bg": "/**\n * Намира най-често срещаните n-грамове (поднизове с дължина n) в дадения текст и тяхната честота.\n * Един n-грам е непрекъсната последователност от n символа от текста.\n * \n * Аргументи:\n * n (Int): Дължината на всеки n-грам.\n * text (String): Текстът, който да се анализира за n-грамове.\n * \n * Връща:\n * Pair<Int, List<String>>: Двойка, където първият елемент е най-високата честота на който и да е n-грам,\n * а вторият елемент е списък от n-грамове с тази честота, в реда, в който се появяват за първи път в текста.\n * Ако най-високата честота не е по-голяма от 1, връща \"NO\" като единствен елемент в списъка.\n * \n * Примери:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "zh": "/**\n * 查找给定文本中最频繁的n-gram（长度为n的子字符串）及其频率。\n * n-gram是文本中连续的n个字符序列。\n * \n * 参数:\n * n (Int): 每个n-gram的长度。\n * text (String): 要分析n-gram的文本。\n * \n * 返回:\n * Pair<Int, List<String>>: 一个对，其中第一个元素是任何n-gram的最高频率，\n * 第二个元素是具有该频率的n-gram列表，按它们在文本中首次出现的顺序排列。\n * 如果最高频率不大于1，则返回列表中唯一的元素为\"NO\"。\n * \n * 示例:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "fr": "/**\n * Trouve les n-grammes les plus fréquents (sous-chaînes de longueur n) dans le texte donné et leur fréquence.\n * Un n-gramme est une séquence contiguë de n caractères du texte.\n * \n * Args:\n * n (Int): La longueur de chaque n-gramme.\n * text (String): Le texte à analyser pour les n-grammes.\n * \n * Returns:\n * Pair<Int, List<String>>: Une paire où le premier élément est la fréquence la plus élevée de n'importe quel n-gramme,\n * et le second élément est une liste de n-grammes avec cette fréquence, dans l'ordre où ils apparaissent pour la première fois dans le texte.\n * Si la fréquence la plus élevée n'est pas supérieure à 1, renvoie \"NO\" comme seul élément de la liste.\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "de": "/**\n * Findet die häufigsten n-Gramme (Teilstrings der Länge n) im gegebenen Text und deren Häufigkeit.\n * Ein n-Gramm ist eine zusammenhängende Sequenz von n Zeichen aus dem Text.\n * \n * Argumente:\n * n (Int): Die Länge jedes n-Gramms.\n * text (String): Der Text, der auf n-Gramme analysiert werden soll.\n * \n * Rückgabewerte:\n * Pair<Int, List<String>>: Ein Paar, bei dem das erste Element die höchste Häufigkeit eines n-Gramms ist,\n * und das zweite Element eine Liste von n-Grammen mit dieser Häufigkeit ist, in der Reihenfolge, in der sie zuerst im Text erscheinen.\n * Wenn die höchste Häufigkeit nicht größer als 1 ist, wird \"NO\" als einziges Element in der Liste zurückgegeben.\n * \n * Beispiele:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "ha": "/**\n * Nemi mafi yawan n-grams (ƙananan rubutu na tsawon n) a cikin rubutun da aka bayar da kuma yawan su.\n * N-gram shi ne jere na haruffa n daga rubutun.\n * \n * Args:\n * n (Int): Tsawon kowane n-gram.\n * text (String): Rubutun da za a bincika don n-grams.\n * \n * Returns:\n * Pair<Int, List<String>>: Wata ma'aurata inda abu na farko shine mafi girman yawan kowane n-gram,\n * kuma abu na biyu jerin n-grams tare da wannan yawan, a cikin tsari da suka fara bayyana a cikin rubutun.\n * Idan mafi girman yawan bai wuce 1 ba, yana mayar da \"NO\" a matsayin abu daya a cikin jerin.\n * \n * Misalai:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "hi": "/**\n * दिए गए पाठ में सबसे अधिक बार आने वाले n-ग्राम (लंबाई n के उपस्ट्रिंग्स) और उनकी आवृत्ति खोजता है।\n * एक n-ग्राम पाठ से n वर्णों का एक सतत अनुक्रम होता है।\n * \n * तर्क:\n * n (Int): प्रत्येक n-ग्राम की लंबाई।\n * text (String): n-ग्राम के लिए विश्लेषण करने के लिए पाठ।\n * \n * लौटाता है:\n * Pair<Int, List<String>>: एक जोड़ी जहां पहला तत्व किसी भी n-ग्राम की उच्चतम आवृत्ति है,\n * और दूसरा तत्व उस आवृत्ति के साथ n-ग्राम की एक सूची है, जिस क्रम में वे पाठ में पहले दिखाई देते हैं।\n * यदि उच्चतम आवृत्ति 1 से अधिक नहीं है, तो सूची में केवल \"NO\" तत्व के रूप में लौटाता है।\n * \n * उदाहरण:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "hu": "/**\n * Megkeresi a leggyakoribb n-gramokat (n hosszúságú részsztringeket) a megadott szövegben és azok gyakoriságát.\n * Az n-gram egy n hosszúságú, egymást követő karakterekből álló sorozat a szövegből.\n * \n * Argumentumok:\n * n (Int): Az egyes n-gramok hossza.\n * text (String): A szöveg, amelyet n-gramokra elemzünk.\n * \n * Visszatér:\n * Pair<Int, List<String>>: Egy pár, ahol az első elem bármely n-gram legnagyobb gyakorisága,\n * és a második elem egy lista az ilyen gyakoriságú n-gramokról, a szövegben való első megjelenésük sorrendjében.\n * Ha a legnagyobb gyakoriság nem nagyobb, mint 1, akkor \"NO\"-t ad vissza az egyetlen elemként a listában.\n * \n * Példák:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> "
    },
    "prompt_bertscore": {
      "sq": "0.9958792141150502",
      "hy": "0.9690863592780162",
      "bn": "0.9650297310061406",
      "bg": "0.9885718010271577",
      "zh": "0.9437713144758818",
      "fr": "0.9703617649546412",
      "de": "0.9822219850062344",
      "ha": "0.945606261935882",
      "hi": "0.9526830651513931",
      "hu": "0.9779319660366429"
    },
    "canonical_solution": "{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}",
    "instruction": {
      "en": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nՏվեք կարճ բնութագրություն (docstring) Kotlin կոդի վերաբերյալ հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nনিম্নলিখিত Kotlin কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, সর্বাধিক ৫০০ অক্ষরের মধ্যে।",
      "bg": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\n请用中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>\n{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.899381794182967",
      "bn": "0.8870605530169919",
      "bg": "0.8383597137705134",
      "zh": "0.863268208715871",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9010135427631687",
      "hi": "0.8905183106900473",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(findMostFrequentNGrams(3, \"abcdefabcd\") == Pair(2, listOf(\"abc\", \"bcd\")))\n    check(findMostFrequentNGrams(2, \"abcabc\") == Pair(2, listOf(\"ab\", \"bc\")))\n    check(findMostFrequentNGrams(4, \"abcdefg\") == Pair(1, listOf(\"NO\")))\n    check(findMostFrequentNGrams(2, \"abcdabcd\") == Pair(2, listOf(\"ab\", \"bc\", \"cd\")))\n}\n\n\nmain()",
    "entry_point": "findMostFrequentNGrams",
    "signature": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>",
    "docstring": {
      "en": "Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\nAn n-gram is a contiguous sequence of n characters from the text.\n\nArgs:\nn (Int): The length of each n-gram.\ntext (String): The text to analyze for n-grams.\n\nReturns:\nPair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\nand the second element is a list of n-grams with that frequency, in the order they first appear in the text.\nIf the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "sq": "Gjen n-gramet më të shpeshta (nënvargje me gjatësi n) në tekstin e dhënë dhe frekuencën e tyre. Një n-gram është një sekuencë e pandërprerë e n karaktereve nga teksti.\n\nArgs:\nn (Int): Gjatësia e secilit n-gram.\ntext (String): Teksti për t'u analizuar për n-gramet.\n\nReturns:\nPair<Int, List<String>>: Një çift ku elementi i parë është frekuenca më e lartë e çdo n-grame,\ndhe elementi i dytë është një listë e n-grameve me atë frekuencë, në rendin që shfaqen së pari në tekst.\nNëse frekuenca më e lartë nuk është më e madhe se 1, kthen \"NO\" si elementi i vetëm në listë.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "hy": "Գտնում է տրված տեքստում ամենահաճախ հանդիպող n-գրամները (n երկարության ենթատողերը) և դրանց հաճախականությունը։  \nN-գրամը տեքստից n սիմվոլների հարակից հաջորդականություն է։\n\nԱրգումենտներ:\nn (Int): Յուրաքանչյուր n-գրամի երկարությունը։\ntext (String): Տեքստը, որը պետք է վերլուծել n-գրամների համար։\n\nՎերադարձնում է:\nPair<Int, List<String>>: Զույգ, որտեղ առաջին էլեմենտը ցանկացած n-գրամի ամենաբարձր հաճախականությունն է,  \nիսկ երկրորդ էլեմենտը n-գրամների ցուցակն է այդ հաճախականությամբ, այն հերթականությամբ, որով դրանք առաջին անգամ հայտնվում են տեքստում։  \nԵթե ամենաբարձր հաճախականությունը 1-ից մեծ չէ, վերադարձնում է \"NO\" որպես ցուցակի միակ էլեմենտ։\n\nՕրինակներ:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "bn": "প্রদত্ত টেক্সটে সবচেয়ে ঘন ঘন n-grams (n দৈর্ঘ্যের সাবস্ট্রিং) এবং তাদের ফ্রিকোয়েন্সি খুঁজে বের করে।\nএকটি n-gram হল টেক্সট থেকে n অক্ষরের একটি ধারাবাহিক ক্রম।\n\nArgs:\nn (Int): প্রতিটি n-gram এর দৈর্ঘ্য।\ntext (String): n-grams বিশ্লেষণের জন্য টেক্সট।\n\nReturns:\nPair<Int, List<String>>: একটি জোড়া যেখানে প্রথম উপাদানটি যে কোনো n-gram এর সর্বোচ্চ ফ্রিকোয়েন্সি,\nএবং দ্বিতীয় উপাদানটি সেই ফ্রিকোয়েন্সির সাথে n-grams এর একটি তালিকা, টেক্সটে তারা প্রথম যে ক্রমে উপস্থিত হয় সেই ক্রমে।\nযদি সর্বোচ্চ ফ্রিকোয়েন্সি 1 এর বেশি না হয়, তাহলে \"NO\" কে তালিকার একমাত্র উপাদান হিসেবে ফেরত দেয়।\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "bg": "Намира най-честите n-грамове (поднизове с дължина n) в дадения текст и тяхната честота. Един n-грам е непрекъсната последователност от n символа от текста.\n\nАргументи:\nn (Int): Дължината на всеки n-грам.\ntext (String): Текстът, който да се анализира за n-грамове.\n\nВръща:\nPair<Int, List<String>>: Двойка, където първият елемент е най-високата честота на който и да е n-грам,\nа вторият елемент е списък от n-грамове с тази честота, в реда, в който се появяват за първи път в текста.\nАко най-високата честота не е по-голяма от 1, връща \"NO\" като единствен елемент в списъка.\n\nПримери:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "zh": "找到给定文本中最频繁的n-gram（长度为n的子串）及其频率。\nn-gram是文本中连续的n个字符序列。\n\n参数:\nn (Int): 每个n-gram的长度。\ntext (String): 要分析n-gram的文本。\n\n返回:\nPair<Int, List<String>>: 一个对，其中第一个元素是任何n-gram的最高频率，\n第二个元素是具有该频率的n-gram列表，按它们在文本中首次出现的顺序排列。\n如果最高频率不大于1，则返回列表中唯一的元素为\"NO\"。\n\n示例:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "fr": "Trouve les n-grammes les plus fréquents (sous-chaînes de longueur n) dans le texte donné et leur fréquence. Un n-gramme est une séquence contiguë de n caractères du texte.\n\nArgs:\nn (Int): La longueur de chaque n-gramme.\ntext (String): Le texte à analyser pour les n-grammes.\n\nReturns:\nPair<Int, List<String>>: Une paire où le premier élément est la fréquence la plus élevée de n'importe quel n-gramme, et le second élément est une liste de n-grammes avec cette fréquence, dans l'ordre où ils apparaissent pour la première fois dans le texte. Si la fréquence la plus élevée n'est pas supérieure à 1, retourne \"NO\" comme seul élément de la liste.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "de": "Findet die häufigsten n-Gramme (Teilstrings der Länge n) im gegebenen Text und deren Häufigkeit.\nEin n-Gramm ist eine zusammenhängende Sequenz von n Zeichen aus dem Text.\n\nArgs:\nn (Int): Die Länge jedes n-Gramms.\ntext (String): Der Text, der auf n-Gramme analysiert werden soll.\n\nReturns:\nPair<Int, List<String>>: Ein Paar, bei dem das erste Element die höchste Häufigkeit eines n-Gramms ist,\nund das zweite Element eine Liste von n-Grammen mit dieser Häufigkeit ist, in der Reihenfolge, in der sie zuerst im Text erscheinen.\nWenn die höchste Häufigkeit nicht größer als 1 ist, wird \"NO\" als einziges Element in der Liste zurückgegeben.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "ha": "Nemo mafi yawan n-grams (ƙananan rubutu masu tsawon n) a cikin rubutun da aka bayar da kuma yawan su.\nn-gram yana nufin jere na haruffa n daga cikin rubutun.\n\nArgs:  \nn (Int): Tsawon kowanne n-gram.  \ntext (String): Rubutun da za a bincika don n-grams.\n\nReturns:  \nPair<Int, List<String>>: Wani nau'i inda abu na farko shine mafi girman yawan wani n-gram,  \nkuma abu na biyu shine jerin n-grams da wannan yawan, a cikin tsarin da suka fara bayyana a cikin rubutun.  \nIdan mafi girman yawan bai fi 1 ba, yana dawowa da \"NO\" a matsayin abu daya tilo a cikin jerin.\n\nExamples:  \n>>> findMostFrequentNGrams(3, \"abcdefabcd\")  \nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")  \nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")  \nPair(1, listOf(\"NO\"))",
      "hi": "दिए गए पाठ में सबसे अधिक बार आने वाले n-ग्राम (लंबाई n के उपस्ट्रिंग्स) और उनकी आवृत्ति खोजता है। एक n-ग्राम पाठ से n वर्णों का एक सतत अनुक्रम होता है।\n\nआर्ग्स:\nn (Int): प्रत्येक n-ग्राम की लंबाई।\ntext (String): n-ग्राम के लिए विश्लेषण करने के लिए पाठ।\n\nरिटर्न्स:\nPair<Int, List<String>>: एक जोड़ी जहां पहला तत्व किसी भी n-ग्राम की उच्चतम आवृत्ति है,\nऔर दूसरा तत्व उस आवृत्ति के साथ n-ग्राम की सूची है, जिस क्रम में वे पाठ में पहली बार आते हैं।\nयदि उच्चतम आवृत्ति 1 से अधिक नहीं है, तो सूची में \"NO\" को एकमात्र तत्व के रूप में लौटाता है।\n\nउदाहरण:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "hu": "Megtalálja a leggyakoribb n-grammákat (n hosszúságú részsztringeket) a megadott szövegben és azok gyakoriságát. \nEgy n-gramma a szöveg n karakterből álló összefüggő sorozata.\n\nArgs:\nn (Int): Az egyes n-grammák hossza.\ntext (String): A szöveg, amelyet n-grammákra kell elemezni.\n\nReturns:\nPair<Int, List<String>>: Egy pár, ahol az első elem bármely n-gramma legmagasabb gyakorisága,\na második elem pedig az ilyen gyakoriságú n-grammák listája, a szövegben való első megjelenésük sorrendjében.\nHa a legmagasabb gyakoriság nem nagyobb, mint 1, akkor \"NO\"-t ad vissza az egyetlen elemként a listában.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))"
    },
    "docstring_bertscore": {
      "sq": "0.9952964325770939",
      "hy": "0.981097935679958",
      "bn": "0.9734103440427647",
      "bg": "0.9875212449418642",
      "zh": "0.9624086044980044",
      "fr": "0.9922498397927807",
      "de": "0.9899943918161296",
      "ha": "0.978057897698219",
      "hi": "0.9847565086682396",
      "hu": "0.9787199327582083"
    }
  },
  {
    "task_id": "Kotlin/37",
    "prompt": {
      "en": "/**\n * Divide a large number (as a string) by 13 and return the quotient and remainder.\n * The input number can be up to 100 digits long.\n *\n * Example:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "sq": "/**\n * Ndaj një numër të madh (si varg) me 13 dhe kthe pjesëtuesin dhe mbetjen.\n * Numri i futur mund të jetë deri në 100 shifra i gjatë.\n *\n * Shembull:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "hy": "/**\n * Մեծ թիվը (որպես տող) բաժանել 13-ի և վերադարձնել քանորդը և մնացորդը:\n * Մուտքային թիվը կարող է լինել մինչև 100 նիշ երկարությամբ:\n *\n * Օրինակ:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "bn": "/**\n * একটি বড় সংখ্যা (স্ট্রিং হিসাবে) 13 দ্বারা ভাগ করুন এবং ভাগফল এবং অবশিষ্টাংশ ফেরত দিন।\n * ইনপুট সংখ্যা সর্বাধিক 100 অঙ্ক দীর্ঘ হতে পারে।\n *\n * উদাহরণ:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "bg": "/**\n * Разделете голямо число (като низ) на 13 и върнете частното и остатъка.\n * Входното число може да бъде до 100 цифри дълго.\n *\n * Пример:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "zh": "/**\n * 将一个大数（以字符串形式）除以13，并返回商和余数。\n * 输入数字可以长达100位。\n *\n * 示例:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */",
      "fr": "/**\n * Diviser un grand nombre (sous forme de chaîne) par 13 et retourner le quotient et le reste.\n * Le nombre d'entrée peut comporter jusqu'à 100 chiffres.\n *\n * Exemple:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "de": "/**\n * Teile eine große Zahl (als Zeichenkette) durch 13 und gib den Quotienten und den Rest zurück.\n * Die Eingabezahl kann bis zu 100 Stellen lang sein.\n *\n * Beispiel:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "ha": "/**\n * Raba babbar lamba (a matsayin kirtani) da 13 kuma dawo da sakamakon kason da saura.\n * Lambar shigarwa na iya kaiwa har zuwa tsawon lambobi 100.\n *\n * Misali:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "hi": "/**\n * एक बड़े संख्या (एक स्ट्रिंग के रूप में) को 13 से विभाजित करें और भागफल और शेषफल लौटाएं।\n * इनपुट संख्या 100 अंकों तक लंबी हो सकती है।\n *\n * उदाहरण:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */",
      "hu": "/**\n * Osszunk el egy nagy számot (sztringként) 13-mal, és adjuk vissza a hányadost és a maradékot.\n * A bemeneti szám legfeljebb 100 számjegyű lehet.\n *\n * Példa:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9978778330090232",
      "bn": "1",
      "bg": "1",
      "zh": "0.9522395235105422",
      "fr": "0.9838205623128032",
      "de": "0.9963775777410667",
      "ha": "1",
      "hi": "0.9577066261181464",
      "hu": "1"
    },
    "canonical_solution": "{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}",
    "instruction": {
      "en": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun divideByThirteen(number: String): Pair<String, String>\n{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.8927018544687637",
      "bn": "0.8822429717553717",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.8937323488855727",
      "hi": "0.8761702451159921",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(divideByThirteen(\"2132104848488485\") == Pair(\"164008065268345\", \"0\"))\n    check(divideByThirteen(\"169\") == Pair(\"13\", \"0\"))\n    check(divideByThirteen(\"20\") == Pair(\"1\", \"7\"))\n    check(divideByThirteen(\"130\") == Pair(\"10\", \"0\"))\n    check(divideByThirteen(\"0\") == Pair(\"0\", \"0\"))\n}\n\n\nmain()",
    "entry_point": "divideByThirteen",
    "signature": "fun divideByThirteen(number: String): Pair<String, String>",
    "docstring": {
      "en": "Divide a large number (as a string) by 13 and return the quotient and remainder.\nThe input number can be up to 100 digits long.\n\nExample:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "sq": "Ndaj një numër të madh (si një varg) me 13 dhe kthe pjesëtuesin dhe mbetjen. Numri i futur mund të jetë deri në 100 shifra i gjatë.\n\nShembull:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "hy": "Մեծ թիվը (որպես տող) բաժանել 13-ի և վերադարձնել քանորդը և մնացորդը։ Մուտքային թիվը կարող է լինել մինչև 100 նիշ երկարությամբ։\n\nՕրինակ:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "bn": "একটি বড় সংখ্যা (স্ট্রিং হিসাবে) 13 দ্বারা ভাগ করুন এবং ভাগফল এবং অবশিষ্টাংশ ফেরত দিন। ইনপুট সংখ্যা সর্বাধিক 100 অঙ্কের দীর্ঘ হতে পারে।\n\nউদাহরণ:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "bg": "Разделете голямо число (като низ) на 13 и върнете частното и остатъка. Входното число може да бъде до 100 цифри дълго.\n\nПример:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "zh": "将一个大数字（作为字符串）除以13，并返回商和余数。输入数字可以长达100位。\n\n示例：\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "fr": "Diviser un grand nombre (sous forme de chaîne) par 13 et retourner le quotient et le reste. Le nombre d'entrée peut comporter jusqu'à 100 chiffres.\n\nExemple :\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "de": "Teile eine große Zahl (als Zeichenkette) durch 13 und gib den Quotienten und den Rest zurück. Die Eingabezahl kann bis zu 100 Stellen lang sein.\n\nBeispiel:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "ha": "Raba babban lamba (a matsayin kirtani) da 13 kuma dawo da rabon da saura. Lambar shigarwa na iya kaiwa har zuwa tsawon 100 lambobi.\n\nMisali:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "hi": "तेरह से एक बड़े संख्या (एक स्ट्रिंग के रूप में) को विभाजित करें और भागफल और शेषफल लौटाएं। इनपुट संख्या 100 अंकों तक लंबी हो सकती है।\n\nउदाहरण:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "hu": "Osszon el egy nagy számot (sztringként) 13-mal, és adja vissza a hányadost és a maradékot.  \nA bemeneti szám akár 100 számjegy hosszú is lehet.\n\nPélda:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9966673794669967",
      "bn": "0.9849813582595711",
      "bg": "1",
      "zh": "1",
      "fr": "0.9850802761893265",
      "de": "0.995855179838945",
      "ha": "1",
      "hi": "0.9986362038038145",
      "hu": "0.995855179838945"
    }
  },
  {
    "task_id": "Kotlin/38",
    "prompt": {
      "en": "/**\n    * Extracts all integer numbers from a given string and returns them as a sorted list.\n    * The integers in the string are assumed to be non-negative and separated by non-digit characters.\n    * If no integers are found, returns a list containing only zero.\n    *\n    * Example:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/\n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "sq": "/**\n    * Nxjerr të gjitha numrat e plotë nga një varg i dhënë dhe i kthen ato si një listë të renditur.\n    * Numrat e plotë në varg supozohet të jenë jo-negativë dhe të ndarë nga karaktere jo-shifrore.\n    * Nëse nuk gjenden numra të plotë, kthen një listë që përmban vetëm zero.\n    *\n    * Shembull:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "hy": "/**\n    * Հանում է բոլոր ամբողջ թվերը տրված տողից և վերադարձնում դրանք որպես դասավորված ցուցակ:\n    * Տողի ամբողջ թվերը ենթադրվում են ոչ բացասական և բաժանված ոչ թվանշանային նիշերով:\n    * Եթե ամբողջ թվեր չեն գտնվել, վերադարձնում է ցուցակ, որը պարունակում է միայն զրո:\n    *\n    * Օրինակ:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "bn": "/**\n    * প্রদত্ত স্ট্রিং থেকে সমস্ত পূর্ণসংখ্যা বের করে এবং সেগুলিকে একটি সাজানো তালিকা হিসেবে ফেরত দেয়।\n    * স্ট্রিংয়ের পূর্ণসংখ্যাগুলি অ-ঋণাত্মক এবং অ-সংখ্যা অক্ষর দ্বারা পৃথক বলে অনুমান করা হয়।\n    * যদি কোনো পূর্ণসংখ্যা পাওয়া না যায়, তাহলে শুধুমাত্র শূন্য ধারণকারী একটি তালিকা ফেরত দেয়।\n    *\n    * উদাহরণ:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "bg": "/**\n    * Извлича всички цели числа от даден низ и ги връща като сортиран списък.\n    * Предполага се, че целите числа в низа са неотрицателни и разделени от символи, които не са цифри.\n    * Ако не бъдат намерени цели числа, връща списък, съдържащ само нула.\n    *\n    * Пример:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "zh": "/**\n    * 从给定字符串中提取所有整数，并将它们作为排序后的列表返回。\n    * 假设字符串中的整数是非负数，并由非数字字符分隔。\n    * 如果未找到整数，则返回仅包含零的列表。\n    *\n    * 示例:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "fr": "/**\n    * Extrait tous les nombres entiers d'une chaîne donnée et les renvoie sous forme de liste triée.\n    * Les entiers dans la chaîne sont supposés être non négatifs et séparés par des caractères non numériques.\n    * Si aucun entier n'est trouvé, renvoie une liste contenant uniquement zéro.\n    *\n    * Exemple :\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "de": "/**\n    * Extrahiert alle ganzen Zahlen aus einem gegebenen String und gibt sie als sortierte Liste zurück.\n    * Es wird angenommen, dass die ganzen Zahlen im String nicht negativ sind und durch Nicht-Ziffern-Zeichen getrennt sind.\n    * Wenn keine ganzen Zahlen gefunden werden, wird eine Liste zurückgegeben, die nur Null enthält.\n    *\n    * Beispiel:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "ha": "/**\n    * Yana fitar da dukkan lambobin cikakku daga wani igiyar rubutu da aka bayar kuma yana mayar da su a matsayin jerin da aka tsara.\n    * Ana tsammanin lambobin cikakku a cikin igiyar rubutu suna da tabbatacce kuma an raba su da haruffan da ba lambobi ba.\n    * Idan ba a sami lambobi ba, yana mayar da jerin da ke dauke da sifili kawai.\n    *\n    * Misali:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "hi": "/**\n    * दिए गए स्ट्रिंग से सभी पूर्णांक संख्याओं को निकालता है और उन्हें एक क्रमबद्ध सूची के रूप में लौटाता है।\n    * स्ट्रिंग में पूर्णांक संख्याएँ गैर-ऋणात्मक मानी जाती हैं और गैर-अंक वर्णों द्वारा अलग की जाती हैं।\n    * यदि कोई पूर्णांक नहीं मिलता है, तो केवल शून्य वाली एक सूची लौटाता है।\n    *\n    * उदाहरण:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "hu": "/**\n    * Kivonja az összes egész számot egy adott szövegből, és rendezett listaként adja vissza őket.\n    * Feltételezzük, hogy a szövegben lévő egész számok nem negatívak, és nem számjegy karakterek választják el őket.\n    * Ha nem található egész szám, akkor egy listát ad vissza, amely csak nullát tartalmaz.\n    *\n    * Példa:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9633240919241941",
      "hy": "0.9617708023445013",
      "bn": "0.9614257813726437",
      "bg": "0.9582854350484821",
      "zh": "0.9434066290963017",
      "fr": "0.9600163001888201",
      "de": "0.9572813584723507",
      "ha": "0.9466111330335376",
      "hi": "0.9475248327862981",
      "hu": "0.9427745872238487"
    },
    "canonical_solution": "{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}",
    "instruction": {
      "en": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\n请用不超过500个字符的中文为Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nकोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun extractAndSortIntegers(input: String): List<Int>\n{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9244352427732785",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.9024532157649096",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9669622059832291",
      "hi": "0.8761702451159921",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "check(extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\") == listOf(9, 9, 81, 88, 345, 1234, 6781, 11101))\ncheck(extractAndSortIntegers(\"no numbers\") == listOf(0))\ncheck(extractAndSortIntegers(\"123&456*789\") == listOf(123, 456, 789))\ncheck(extractAndSortIntegers(\"abc\") == listOf(0))",
    "entry_point": "extractAndSortIntegers",
    "signature": "fun extractAndSortIntegers(input: String): List<Int>",
    "docstring": {
      "en": "Extracts all integer numbers from a given string and returns them as a sorted list.\nThe integers in the string are assumed to be non-negative and separated by non-digit characters.\nIf no integers are found, returns a list containing only zero.\n\nExample:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "sq": "Ekstrakton të gjitha numrat e plotë nga një varg i dhënë dhe i kthen ato si një listë të renditur.\nNumrat e plotë në varg supozohet të jenë jo-negativë dhe të ndarë nga karaktere që nuk janë shifra.\nNëse nuk gjenden numra të plotë, kthen një listë që përmban vetëm zero.\n\nShembull:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "hy": "Բոլոր ամբողջ թվերը հանում է տրված տողից և վերադարձնում դրանք որպես դասավորված ցուցակ:  \nԵնթադրվում է, որ տողի ամբողջ թվերը ոչ բացասական են և բաժանված են ոչ թվանշանային սիմվոլներով:  \nԵթե ամբողջ թվեր չեն գտնվել, վերադարձնում է ցուցակ, որը պարունակում է միայն զրո:\n\nՕրինակ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "bn": "প্রদত্ত স্ট্রিং থেকে সমস্ত পূর্ণসংখ্যা বের করে এবং সেগুলিকে একটি সাজানো তালিকা হিসাবে ফেরত দেয়। স্ট্রিংয়ের পূর্ণসংখ্যাগুলি অ-ঋণাত্মক এবং অ-অঙ্ক অক্ষর দ্বারা পৃথক বলে অনুমান করা হয়। যদি কোনো পূর্ণসংখ্যা পাওয়া না যায়, তাহলে শুধুমাত্র শূন্য ধারণকারী একটি তালিকা ফেরত দেয়।\n\nউদাহরণ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "bg": "Извлича всички цели числа от даден низ и ги връща като сортиран списък. Целите числа в низа се приемат за неотрицателни и разделени от символи, които не са цифри. Ако не бъдат намерени цели числа, връща списък, съдържащ само нула.\n\nПример:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "zh": "从给定字符串中提取所有整数，并将它们作为排序后的列表返回。  \n假设字符串中的整数是非负的，并由非数字字符分隔。  \n如果未找到整数，则返回仅包含零的列表。\n\n示例：\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "fr": "Extrait tous les nombres entiers d'une chaîne donnée et les renvoie sous forme de liste triée.\nLes entiers dans la chaîne sont supposés être non négatifs et séparés par des caractères non numériques.\nSi aucun entier n'est trouvé, renvoie une liste contenant uniquement zéro.\n\nExemple :\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "de": "Extrahiert alle ganzen Zahlen aus einem gegebenen String und gibt sie als sortierte Liste zurück.\nEs wird angenommen, dass die ganzen Zahlen im String nicht negativ sind und durch Nicht-Ziffern-Zeichen getrennt werden.\nWenn keine ganzen Zahlen gefunden werden, wird eine Liste zurückgegeben, die nur Null enthält.\n\nBeispiel:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "ha": "Ya fitar da duk lambobin cikakke daga wani kirtani da aka bayar kuma ya mayar da su a matsayin jerin da aka tsara.\n\nAna ɗauka lambobin cikakke a cikin kirtani suna da tabbatacce kuma an raba su da haruffa marasa lambobi.\n\nIdan ba a sami lambobi ba, yana mayar da jerin da ke ɗauke da sifili kaɗai.\n\nMisali:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "hi": "दिए गए स्ट्रिंग से सभी पूर्णांक संख्याएँ निकालता है और उन्हें एक क्रमबद्ध सूची के रूप में लौटाता है। स्ट्रिंग में पूर्णांक संख्याएँ गैर-नकारात्मक मानी जाती हैं और गैर-अंक वर्णों द्वारा अलग की जाती हैं। यदि कोई पूर्णांक नहीं मिलता है, तो केवल शून्य वाली एक सूची लौटाता है।\n\nउदाहरण:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "hu": "Kivonja az összes egész számot egy adott szövegből, és rendezett listaként adja vissza őket.\nFeltételezzük, hogy a szövegben szereplő egész számok nem negatívak, és nem számjegy karakterek választják el őket.\nHa nem található egész szám, akkor egy nullát tartalmazó listát ad vissza.\n\nPélda:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]"
    },
    "docstring_bertscore": {
      "sq": "0.9950098089372605",
      "hy": "0.9823779098553468",
      "bn": "0.9823779098553468",
      "bg": "0.9914090373898601",
      "zh": "0.9718373900553494",
      "fr": "0.9889990549767638",
      "de": "0.982891568020703",
      "ha": "0.9705979364776917",
      "hi": "0.9781313909392019",
      "hu": "0.9629925778182469"
    }
  },
  {
    "task_id": "Kotlin/39",
    "prompt": {
      "en": "/**\n * Determines whether a given number x is an element of a set M generated from a starting number k.\n * The set M is generated as follows:\n *   (1) k is an element of M.\n *   (2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n *   (3) No other elements are in M except those generated by the above rules.\n * \n * Example:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "sq": "/**\n * Përcakton nëse një numër i dhënë x është një element i një grupi M i gjeneruar nga një numër fillestar k.\n * Grupi M gjenerohet si më poshtë:\n *   (1) k është një element i M.\n *   (2) Nëse y është një element i M, atëherë të dy (2y + 1) dhe (3y + 1) janë elemente të M.\n *   (3) Nuk ka elemente të tjera në M përveç atyre të gjeneruara nga rregullat e mësipërme.\n * \n * Shembull:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "hy": "/**\n * Սահմանում է՝ արդյոք տրված թիվը x հանդիսանում է M բազմության տարր, որը գեներացվել է k սկզբնական թվից:\n * M բազմությունը գեներացվում է հետևյալ կերպ.\n *   (1) k-ն հանդիսանում է M-ի տարր:\n *   (2) Եթե y-ն հանդիսանում է M-ի տարր, ապա և՛ (2y + 1)-ը, և՛ (3y + 1)-ը հանդիսանում են M-ի տարրեր:\n *   (3) M-ում չկան այլ տարրեր, բացի վերը նշված կանոններով գեներացվածներից:\n * \n * Օրինակ:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "bn": "/**\n * নির্ধারণ করে যে প্রদত্ত সংখ্যা x কি k থেকে শুরু করে তৈরি করা সেট M এর একটি উপাদান।\n * সেট M নিম্নলিখিতভাবে তৈরি করা হয়:\n *   (1) k হল M এর একটি উপাদান।\n *   (2) যদি y হয় M এর একটি উপাদান, তাহলে (2y + 1) এবং (3y + 1) উভয়ই M এর উপাদান।\n *   (3) উপরের নিয়ম দ্বারা তৈরি ছাড়া অন্য কোন উপাদান M এ নেই।\n * \n * উদাহরণ:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "bg": "/**\n * Определя дали дадено число x е елемент от множество M, генерирано от начално число k.\n * Множеството M се генерира по следния начин:\n *   (1) k е елемент на M.\n *   (2) Ако y е елемент на M, то и (2y + 1) и (3y + 1) са елементи на M.\n *   (3) Няма други елементи в M освен тези, генерирани от горните правила.\n * \n * Пример:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "zh": "/**\n * 确定给定数字 x 是否是从起始数字 k 生成的集合 M 的元素。\n * 集合 M 的生成规则如下：\n *   (1) k 是 M 的一个元素。\n *   (2) 如果 y 是 M 的一个元素，那么 (2y + 1) 和 (3y + 1) 也是 M 的元素。\n *   (3) 除了通过上述规则生成的元素外，M 中没有其他元素。\n * \n * 示例:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "fr": "/**\n * Détermine si un nombre donné x est un élément d'un ensemble M généré à partir d'un nombre de départ k.\n * L'ensemble M est généré comme suit :\n *   (1) k est un élément de M.\n *   (2) Si y est un élément de M, alors (2y + 1) et (3y + 1) sont des éléments de M.\n *   (3) Aucun autre élément n'est dans M sauf ceux générés par les règles ci-dessus.\n * \n * Exemple :\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "de": "/**\n * Bestimmt, ob eine gegebene Zahl x ein Element einer Menge M ist, die aus einer Startzahl k erzeugt wird.\n * Die Menge M wird wie folgt erzeugt:\n *   (1) k ist ein Element von M.\n *   (2) Wenn y ein Element von M ist, dann sind sowohl (2y + 1) als auch (3y + 1) Elemente von M.\n *   (3) Keine anderen Elemente sind in M außer denen, die durch die obigen Regeln erzeugt werden.\n * \n * Beispiel:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "ha": "/**\n * Yana tantance ko wani adadi x yana cikin wani saitin M da aka samar daga wani adadi farawa k.\n * Ana samar da saitin M kamar haka:\n *   (1) k yana cikin M.\n *   (2) Idan y yana cikin M, to duka (2y + 1) da (3y + 1) suna cikin M.\n *   (3) Babu wasu abubuwa a cikin M sai waɗanda aka samar ta hanyar ƙa'idodin da ke sama.\n * \n * Misali:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "hi": "/**\n * यह निर्धारित करता है कि दिया गया संख्या x, एक सेट M का तत्व है जो प्रारंभिक संख्या k से उत्पन्न होता है।\n * सेट M निम्नलिखित तरीके से उत्पन्न होता है:\n *   (1) k, M का एक तत्व है।\n *   (2) यदि y, M का एक तत्व है, तो (2y + 1) और (3y + 1) दोनों M के तत्व हैं।\n *   (3) उपरोक्त नियमों द्वारा उत्पन्न तत्वों के अलावा M में कोई अन्य तत्व नहीं हैं।\n * \n * उदाहरण:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "hu": "/**\n * Meghatározza, hogy egy adott x szám eleme-e egy M halmaznak, amelyet egy kezdő k számból generálunk.\n * Az M halmaz a következőképpen generálódik:\n *   (1) k eleme M-nek.\n *   (2) Ha y eleme M-nek, akkor mindkettő (2y + 1) és (3y + 1) elemei M-nek.\n *   (3) Nincsenek más elemek M-ben, csak azokat, amelyeket a fenti szabályok generálnak.\n * \n * Példa:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String "
    },
    "prompt_bertscore": {
      "sq": "0.9932445807410034",
      "hy": "0.9776201163384182",
      "bn": "0.9878970536227822",
      "bg": "0.986466517618569",
      "zh": "0.9699629151495232",
      "fr": "0.9942204518030279",
      "de": "0.988619075057844",
      "ha": "0.9670448362217396",
      "hi": "0.9809749834740974",
      "hu": "0.9786527956894185"
    },
    "canonical_solution": "{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}",
    "instruction": {
      "en": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\n请用不超过500个字符的中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nFournir une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Kotlin a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nकृपया निम्नलिखित कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun isElementOfGeneratedSet(k: Int, x: Int): String\n{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9026051680064012",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9122737004336554",
      "hi": "0.8463897907178123",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(isElementOfGeneratedSet(0, 22) == \"YES\")\n    check(isElementOfGeneratedSet(1, 10) == \"YES\")\n    check(isElementOfGeneratedSet(2, 13) == \"NO\")\n    check(isElementOfGeneratedSet(3, 30) == \"NO\")\n}\n\n\nmain()",
    "entry_point": "isElementOfGeneratedSet",
    "signature": "fun isElementOfGeneratedSet(k: Int, x: Int): String",
    "docstring": {
      "en": "Determines whether a given number x is an element of a set M generated from a starting number k.\nThe set M is generated as follows:\n(1) k is an element of M.\n(2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n(3) No other elements are in M except those generated by the above rules.\n\nExample:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "sq": "Përcakton nëse një numër i dhënë x është një element i një bashkësie M të gjeneruar nga një numër fillestar k. Bashkësia M gjenerohet si më poshtë: (1) k është një element i M. (2) Nëse y është një element i M, atëherë si (2y + 1) ashtu edhe (3y + 1) janë elementë të M. (3) Nuk ka elementë të tjerë në M përveç atyre të gjeneruar nga rregullat e mësipërme.\n\nShembull:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "hy": "Սահմանում է՝ արդյոք տրված x թիվը M բազմության տարր է, որը գեներացվել է k մեկնարկային թվից:\nM բազմությունը գեներացվում է հետևյալ կերպ.\n(1) k-ն M-ի տարր է:\n(2) Եթե y-ն M-ի տարր է, ապա և՛ (2y + 1)-ը, և՛ (3y + 1)-ը M-ի տարրեր են:\n(3) M-ում չկան այլ տարրեր, բացի վերը նշված կանոններով գեներացվածներից:\n\nՕրինակ:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "bn": "একটি প্রদত্ত সংখ্যা x একটি সেট M এর উপাদান কিনা তা নির্ধারণ করে যা একটি প্রারম্ভিক সংখ্যা k থেকে উৎপন্ন হয়। \nসেট M নিম্নরূপ উৎপন্ন হয়:\n(1) k হল M এর একটি উপাদান।\n(2) যদি y M এর একটি উপাদান হয়, তাহলে (2y + 1) এবং (3y + 1) উভয়ই M এর উপাদান।\n(3) উপরের নিয়ম দ্বারা উৎপন্ন ছাড়া অন্য কোনো উপাদান M এ নেই।\n\nউদাহরণ:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "bg": "Определя дали дадено число x е елемент от множество M, генерирано от начално число k.  \nМножеството M се генерира по следния начин:  \n(1) k е елемент на M.  \n(2) Ако y е елемент на M, тогава и (2y + 1), и (3y + 1) са елементи на M.  \n(3) Няма други елементи в M, освен тези, генерирани от горните правила.  \n\nПример:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"",
      "zh": "确定给定数字 x 是否是从起始数字 k 生成的集合 M 的元素。  \n集合 M 的生成规则如下：  \n(1) k 是 M 的一个元素。  \n(2) 如果 y 是 M 的一个元素，那么 (2y + 1) 和 (3y + 1) 也是 M 的元素。  \n(3) 除了通过上述规则生成的元素外，M 中没有其他元素。  \n\n示例：  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "fr": "Détermine si un nombre donné x est un élément d'un ensemble M généré à partir d'un nombre de départ k.  \nL'ensemble M est généré comme suit :  \n(1) k est un élément de M.  \n(2) Si y est un élément de M, alors (2y + 1) et (3y + 1) sont tous deux des éléments de M.  \n(3) Aucun autre élément n'est dans M sauf ceux générés par les règles ci-dessus.  \n\nExemple :  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "de": "Bestimmt, ob eine gegebene Zahl x ein Element einer Menge M ist, die von einer Startzahl k erzeugt wird.  \nDie Menge M wird wie folgt erzeugt:  \n(1) k ist ein Element von M.  \n(2) Wenn y ein Element von M ist, dann sind sowohl (2y + 1) als auch (3y + 1) Elemente von M.  \n(3) Keine anderen Elemente sind in M außer denen, die durch die obigen Regeln erzeugt werden.  \n\nBeispiel:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "ha": "Yana tantance ko wani adadi x yana cikin wani saiti M da aka samar daga wata lamba ta farawa k. \nAna samar da saitin M kamar haka:\n(1) k yana cikin M.\n(2) Idan y yana cikin M, to duka (2y + 1) da (3y + 1) suna cikin M.\n(3) Babu wasu abubuwa a cikin M sai waɗanda aka samar ta waɗannan ƙa'idodi.\n\nMisali:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "hi": "निर्धारित करता है कि दिया गया संख्या x, एक सेट M का तत्व है या नहीं, जो एक प्रारंभिक संख्या k से उत्पन्न होता है। सेट M निम्नलिखित रूप से उत्पन्न होता है:\n(1) k, M का एक तत्व है।\n(2) यदि y, M का एक तत्व है, तो (2y + 1) और (3y + 1) दोनों M के तत्व हैं।\n(3) उपरोक्त नियमों द्वारा उत्पन्न तत्वों के अलावा M में कोई अन्य तत्व नहीं हैं।\n\nउदाहरण:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "hu": "Meghatározza, hogy egy adott x szám eleme-e egy M halmaznak, amely egy k kezdőszámból van generálva.  \nAz M halmaz a következőképpen van generálva:  \n(1) k eleme M-nek.  \n(2) Ha y eleme M-nek, akkor mind (2y + 1), mind (3y + 1) elemei M-nek.  \n(3) Nincsenek más elemek M-ben, csak azok, amelyeket a fenti szabályok generálnak.\n\nPélda:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\""
    },
    "docstring_bertscore": {
      "sq": "0.9948258772044222",
      "hy": "0.9729298571510413",
      "bn": "0.9732617685177506",
      "bg": "0.9852592421626388",
      "zh": "0.9638502638035555",
      "fr": "0.9839965488304001",
      "de": "1",
      "ha": "0.9540510325855803",
      "hi": "0.9747046196055881",
      "hu": "0.9780285004018259"
    }
  },
  {
    "task_id": "Kotlin/40",
    "prompt": {
      "en": "/**\n    * Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\n    * The input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\n    * The function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\n    Example:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "sq": "/**\n    * Gjeni autorin që ka publikuar më shumë libra dhe ktheni inicialin e autorit së bashku me ID-të e librave ku ata kanë kontribuar.\n    * Hyrja është një listë çiftesh, ku çdo çift përbëhet nga një ID libri (Int) dhe një varg me shkronja unike të mëdha që përfaqësojnë autorët.\n    * Funksioni kthen një çift me inicialin e autorit më të publikuar (Char) dhe një listë të ID-ve të librave (List<Int>) ku ata kanë kontribuar.\n    Shembull:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "hy": "/**\n    * Գտնել այն հեղինակին, ով հրապարակել է ամենաշատ գրքերը և վերադարձնել հեղինակի սկզբնատառը և այն գրքերի ID-ները, որոնցում նրանք մասնակցել են:\n    * Մուտքը զույգերի ցուցակ է, որտեղ յուրաքանչյուր զույգ բաղկացած է գրքի ID-ից (Int) և հեղինակների եզակի մեծատառերի տողից:\n    * Ֆունկցիան վերադարձնում է զույգ՝ ամենաշատ հրապարակած հեղինակի սկզբնատառով (Char) և այն գրքերի ID-ների ցուցակով (List<Int>), որոնցում նրանք մասնակցել են:\n    Օրինակ:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "bn": "/**\n    * সর্বাধিক বই প্রকাশকারী লেখককে খুঁজুন এবং লেখকের প্রাথমিক অক্ষর সহ তাদের অবদান রাখা বইগুলির আইডি ফেরত দিন।\n    * ইনপুটটি একটি জোড়ার তালিকা, যেখানে প্রতিটি জোড়া একটি বইয়ের আইডি (Int) এবং লেখকদের প্রতিনিধিত্বকারী অনন্য বড় হাতের অক্ষরের একটি স্ট্রিং নিয়ে গঠিত।\n    * ফাংশনটি সর্বাধিক প্রকাশিত লেখকের প্রাথমিক অক্ষর (Char) এবং তারা অবদান রাখা বইগুলির আইডির তালিকা (List<Int>) সহ একটি জোড়া ফেরত দেয়।\n    উদাহরণ:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "bg": "/**\n    * Намерете автора, който е публикувал най-много книги, и върнете инициалите на автора заедно с ID-тата на книгите, към които е допринесъл.\n    * Входът е списък от двойки, където всяка двойка се състои от ID на книга (Int) и низ от уникални главни букви, представляващи автори.\n    * Функцията връща двойка с инициалите на автора с най-много публикации (Char) и списък с ID-та на книги (List<Int>), към които е допринесъл.\n    Пример:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "zh": "/**\n    * 找出出版书籍最多的作者，并返回作者的首字母以及他们参与的书籍ID。\n    * 输入是一个对的列表，其中每对由一个书籍ID（Int）和一个代表作者的唯一大写字母字符串组成。\n    * 函数返回一个对，其中包含出版最多书籍的作者的首字母（Char）和他们参与的书籍ID列表（List<Int>）。\n    示例:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "fr": "/**\n    * Trouver l'auteur qui a publié le plus de livres et retourner l'initiale de l'auteur ainsi que les IDs des livres auxquels il a contribué.\n    * L'entrée est une liste de paires, où chaque paire se compose d'un ID de livre (Int) et d'une chaîne de lettres majuscules uniques représentant les auteurs.\n    * La fonction retourne une paire avec l'initiale de l'auteur le plus publié (Char) et une liste d'IDs de livres (List<Int>) auxquels il a contribué.\n    Exemple:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "de": "/**\n    * Finde den Autor, der die meisten Bücher veröffentlicht hat, und gib das Initial des Autors zusammen mit den IDs der Bücher zurück, zu denen er beigetragen hat.\n    * Die Eingabe ist eine Liste von Paaren, wobei jedes Paar aus einer Buch-ID (Int) und einer Zeichenkette aus einzigartigen Großbuchstaben besteht, die Autoren repräsentieren.\n    * Die Funktion gibt ein Paar zurück mit dem Initial (Char) des am meisten veröffentlichten Autors und einer Liste von Buch-IDs (List<Int>), zu denen er beigetragen hat.\n    Beispiel:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "ha": "/**\n    * Nemo marubucin da ya wallafa mafi yawan littattafai kuma ka dawo da farkon sunan marubucin tare da IDs na littattafan da suka ba da gudummawa.\n    * Shigarwar ita ce jerin ma'aurata, inda kowace ma'aurata ta ƙunshi ID na littafi (Int) da igiyar haruffa na musamman na manyan baƙaƙe da ke wakiltar marubuta.\n    * Aikin yana dawowa da ma'aurata tare da farkon sunan marubucin da ya fi wallafa (Char) da jerin IDs na littattafai (List<Int>) da suka ba da gudummawa.\n    Misali:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "hi": "/**\n    * उस लेखक को खोजें जिसने सबसे अधिक पुस्तकें प्रकाशित की हैं और लेखक के प्रारंभिक अक्षर के साथ उन पुस्तकों के IDs लौटाएं जिनमें उन्होंने योगदान दिया है।\n    * इनपुट एक जोड़ी की सूची है, जहाँ प्रत्येक जोड़ी में एक पुस्तक ID (Int) और अद्वितीय अपरकेस अक्षरों की एक स्ट्रिंग होती है जो लेखकों का प्रतिनिधित्व करती है।\n    * यह फ़ंक्शन सबसे अधिक प्रकाशित लेखक के प्रारंभिक अक्षर (Char) और उन पुस्तकों के IDs (List<Int>) की एक सूची लौटाता है जिनमें उन्होंने योगदान दिया है।\n    उदाहरण:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "hu": "/**\n    * Találd meg azt a szerzőt, aki a legtöbb könyvet publikálta, és add vissza a szerző kezdőbetűjét, valamint azoknak a könyveknek az azonosítóit, amelyekhez hozzájárult.\n    * A bemenet egy párokból álló lista, ahol minden pár egy könyvazonosítóból (Int) és egy egyedi nagybetűkből álló karakterláncból áll, amely a szerzőket jelöli.\n    * A függvény visszaad egy párt a legtöbbet publikáló szerző kezdőbetűjével (Char) és egy könyvazonosítókat tartalmazó listával (List<Int>), amelyekhez hozzájárult.\n    Példa:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9392699527808691",
      "hy": "0.9350971257360882",
      "bn": "0.9447306992162803",
      "bg": "0.9326728419355574",
      "zh": "0.9119658233430513",
      "fr": "0.9536642992337054",
      "de": "0.9874276900323967",
      "ha": "0.9442756370133294",
      "hi": "0.9446961375299803",
      "hu": "0.9334480963127366"
    },
    "canonical_solution": "{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}",
    "instruction": {
      "en": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nՏվեք կարճ բնութագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nकृपया निम्नलिखित Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>\n{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.8872653409398389",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8742320098578537",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"HF\"))) == Pair('F', listOf(307,895)))\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"H\"), Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\"), Pair(834, \"BXPRD\"), Pair(872, \"LJU\"), Pair(791, \"BPJWIA\"), Pair(580, \"AGMVY\"), Pair(619, \"NAFL\"), Pair(233, \"PDJWXK\"))) == Pair('P', listOf(410,567,822,834,791,233)))\n\n \n}\nmain()",
    "entry_point": "findMostPublishedAuthor",
    "signature": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>",
    "docstring": {
      "en": "Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\nThe input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\nThe function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\nExample:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "sq": "Gjeni autorin që ka botuar më shumë libra dhe ktheni inicialin e autorit së bashku me ID-të e librave ku ata kanë kontribuar.\nHyrja është një listë çiftesh, ku çdo çift përbëhet nga një ID libri (Int) dhe një varg shkronjash unike me shkronja të mëdha që përfaqësojnë autorët.\nFunksioni kthen një çift me inicialin e autorit më të botuar (Char) dhe një listë ID-sh librash (List<Int>) ku ata kanë kontribuar.\nShembull:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hy": "Գտնել այն հեղինակին, ով հրատարակել է ամենաշատ գրքերը և վերադարձնել հեղինակի սկզբնատառը և այն գրքերի ID-ները, որոնց նրանք մասնակցել են:\nՄուտքը զույգերի ցուցակ է, որտեղ յուրաքանչյուր զույգ բաղկացած է գրքի ID-ից (Int) և հեղինակներին ներկայացնող եզակի մեծատառերի տողից:\nՖունկցիան վերադարձնում է զույգ՝ ամենաշատ հրատարակված հեղինակի սկզբնատառով (Char) և այն գրքերի ID-ների ցուցակով (List<Int>), որոնց նրանք մասնակցել են:\nՕրինակ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "bn": "সর্বাধিক বই প্রকাশিত হয়েছে এমন লেখককে খুঁজুন এবং লেখকের প্রাথমিক অক্ষর সহ তাদের অবদান রাখা বইয়ের আইডিগুলি ফেরত দিন।\nইনপুট হল একটি জোড়ার তালিকা, যেখানে প্রতিটি জোড়া একটি বইয়ের আইডি (Int) এবং লেখকদের প্রতিনিধিত্বকারী অনন্য বড় হাতের অক্ষরের একটি স্ট্রিং নিয়ে গঠিত।\nফাংশনটি সর্বাধিক প্রকাশিত লেখকের প্রাথমিক (Char) এবং তারা যে বইগুলিতে অবদান রেখেছেন সেই বইয়ের আইডির একটি তালিকা (List<Int>) সহ একটি জোড়া ফেরত দেয়।\nউদাহরণ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "bg": "Намерете автора, който е публикувал най-много книги и върнете инициалите на автора заедно с идентификаторите на книгите, към които е допринесъл.\nВходът е списък от двойки, където всяка двойка се състои от идентификатор на книга (Int) и низ от уникални главни букви, представляващи автори.\nФункцията връща двойка с инициалите на автора с най-много публикации (Char) и списък от идентификатори на книги (List<Int>), към които е допринесъл.\nПример:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "zh": "找到出版最多书籍的作者，并返回作者的首字母以及他们参与的书籍ID。\n输入是一个对的列表，其中每对由一本书的ID（整数）和一个表示作者的唯一大写字母字符串组成。\n函数返回一个对，其中包含出版最多书籍的作者的首字母（字符）和他们参与的书籍ID列表（列表<整数>）。\n示例：\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "fr": "Trouver l'auteur qui a publié le plus de livres et retourner l'initiale de l'auteur ainsi que les IDs des livres auxquels il a contribué.  \nL'entrée est une liste de paires, où chaque paire se compose d'un ID de livre (Int) et d'une chaîne de lettres majuscules uniques représentant les auteurs.  \nLa fonction retourne une paire avec l'initiale de l'auteur le plus publié (Char) et une liste des IDs de livres (List<Int>) auxquels il a contribué.  \nExemple :\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))  \nPair('P', listOf(410, 567, 822))",
      "de": "Finde den Autor, der die meisten Bücher veröffentlicht hat, und gib das Initial des Autors zusammen mit den IDs der Bücher zurück, zu denen er beigetragen hat. Die Eingabe ist eine Liste von Paaren, wobei jedes Paar aus einer Buch-ID (Int) und einer Zeichenkette aus einzigartigen Großbuchstaben besteht, die Autoren darstellen. Die Funktion gibt ein Paar mit dem Initial (Char) des am meisten veröffentlichten Autors und einer Liste von Buch-IDs (List<Int>) zurück, zu denen er beigetragen hat. Beispiel:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "ha": "Nemo marubucin da ya fi wallafa mafi yawan littattafai kuma dawo da farkon sunan marubucin tare da lambobin ID na littattafan da suka ba da gudummawa a kai.\nShigarwa jerin ma'aurata ne, inda kowace ma'aurata ta ƙunshi ID na littafi (Int) da igiyar haruffa na musamman masu manyan baƙaƙe suna wakiltar marubuta.\nAikin yana dawo da ma'aurata tare da farkon sunan marubucin da ya fi wallafa (Char) da jerin IDs na littattafai (List<Int>) da suka ba da gudummawa a kai.\nMisali:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hi": "उस लेखक को खोजें जिसने सबसे अधिक पुस्तकें प्रकाशित की हैं और लेखक के प्रारंभिक अक्षर के साथ उन पुस्तकों के IDs लौटाएं जिनमें उन्होंने योगदान दिया है।\nइनपुट एक जोड़ों की सूची है, जहाँ प्रत्येक जोड़ा एक पुस्तक आईडी (Int) और अद्वितीय अपरकेस अक्षरों की एक स्ट्रिंग होती है जो लेखकों का प्रतिनिधित्व करती है।\nयह फ़ंक्शन सबसे अधिक प्रकाशित लेखक के प्रारंभिक (Char) और पुस्तक आईडी की एक सूची (List<Int>) लौटाता है जिनमें उन्होंने योगदान दिया है।\nउदाहरण:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hu": "Találd meg azt a szerzőt, aki a legtöbb könyvet publikálta, és add vissza a szerző kezdőbetűjét, valamint azoknak a könyveknek az azonosítóit, amelyekhez hozzájárult.\nA bemenet egy párokból álló lista, ahol minden pár egy könyvazonosítóból (Int) és egy egyedi nagybetűs betűkből álló karakterláncból áll, amely a szerzőket jelöli.\nA függvény visszaad egy párt a legtöbbet publikáló szerző kezdőbetűjével (Char) és egy listát a könyvazonosítókkal (List<Int>), amelyekhez hozzájárult.\nPélda:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))"
    },
    "docstring_bertscore": {
      "sq": "0.9842382820041196",
      "hy": "0.9837959321455548",
      "bn": "0.9920170449862078",
      "bg": "0.9688263521092415",
      "zh": "0.961046198714486",
      "fr": "0.9827954309162821",
      "de": "0.9902253989492732",
      "ha": "0.960510492576835",
      "hi": "0.9858060716016279",
      "hu": "0.9738177349542673"
    }
  },
  {
    "task_id": "Kotlin/41",
    "prompt": {
      "en": "/**\n * Counts the number of pairs of students who are considered \"equal competitors\".\n * Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n * is not greater than 5, and the difference in their total scores is not greater than 10.\n * \n * @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n * @return The number of pairs of students who are considered equal competitors.\n * \n * Example:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "sq": "/**\n * Numëron numrin e çifteve të studentëve që konsiderohen \"konkurrentë të barabartë\".\n * Dy studentë konsiderohen konkurrentë të barabartë nëse diferenca në pikët e tyre për secilin lëndë (Matematikë, Anglisht dhe Kinezisht)\n * nuk është më e madhe se 5, dhe diferenca në pikët e tyre totale nuk është më e madhe se 10.\n * \n * @param scores Një listë treshe, secila që përfaqëson pikët në Matematikë, Anglisht dhe Kinezisht të një studenti.\n * @return Numri i çifteve të studentëve që konsiderohen konkurrentë të barabartë.\n * \n * Shembull:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "hy": "/**\n * Հաշվում է ուսանողների զույգերի քանակը, ովքեր համարվում են \"հավասար մրցակիցներ\":\n * Երկու ուսանող համարվում են հավասար մրցակիցներ, եթե նրանց միավորների տարբերությունը յուրաքանչյուր առարկայի համար (Մաթեմատիկա, Անգլերեն և Չինարեն)\n * չի գերազանցում 5-ը, և նրանց ընդհանուր միավորների տարբերությունը չի գերազանցում 10-ը:\n * \n * @param scores Երեքյակների ցուցակ, որոնցից յուրաքանչյուրը ներկայացնում է ուսանողի Մաթեմատիկայի, Անգլերենի և Չինարենի միավորները:\n * @return Ուսանողների զույգերի քանակը, ովքեր համարվում են հավասար մրցակիցներ:\n * \n * Օրինակ:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "bn": "/**\n * শিক্ষার্থীদের মধ্যে \"সমান প্রতিযোগী\" বিবেচিত জোড়াগুলির সংখ্যা গণনা করে।\n * দুইজন শিক্ষার্থীকে সমান প্রতিযোগী হিসেবে বিবেচনা করা হয় যদি তাদের প্রতিটি বিষয়ের (গণিত, ইংরেজি এবং চীনা) স্কোরের পার্থক্য 5 এর বেশি না হয়,\n * এবং তাদের মোট স্কোরের পার্থক্য 10 এর বেশি না হয়।\n * \n * @param scores একটি ট্রিপলগুলির তালিকা, প্রতিটি শিক্ষার্থীর গণিত, ইংরেজি এবং চীনা স্কোর উপস্থাপন করে।\n * @return শিক্ষার্থীদের মধ্যে জোড়াগুলির সংখ্যা যারা সমান প্রতিযোগী হিসেবে বিবেচিত হয়।\n * \n * উদাহরণ:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "bg": "/**\n * Брои броя на двойките ученици, които се считат за \"равни съперници\".\n * Двама ученици се считат за равни съперници, ако разликата в техните оценки по всеки предмет (Математика, Английски и Китайски)\n * не е по-голяма от 5, а разликата в техните общи оценки не е по-голяма от 10.\n * \n * @param scores Списък от тройки, всяка представляваща оценките по Математика, Английски и Китайски на ученик.\n * @return Броят на двойките ученици, които се считат за равни съперници.\n * \n * Пример:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "zh": "/**\n * 计算被认为是“平等竞争者”的学生对数。\n * 如果两个学生在每个科目（数学、英语和语文）的分数差不大于5，并且总分差不大于10，则被认为是平等竞争者。\n * \n * @param scores 一个三元组的列表，每个三元组代表一个学生的数学、英语和语文成绩。\n * @return 被认为是平等竞争者的学生对数。\n * \n * 例子:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "fr": "/**\n * Compte le nombre de paires d'étudiants considérés comme \"compétiteurs égaux\".\n * Deux étudiants sont considérés comme compétiteurs égaux si la différence de leurs scores pour chaque matière (Mathématiques, Anglais et Chinois)\n * n'est pas supérieure à 5, et si la différence de leurs scores totaux n'est pas supérieure à 10.\n * \n * @param scores Une liste de triplets, chacun représentant les scores en Mathématiques, Anglais et Chinois d'un étudiant.\n * @return Le nombre de paires d'étudiants considérés comme compétiteurs égaux.\n * \n * Exemple :\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "de": "/**\n * Zählt die Anzahl der Paare von Schülern, die als \"gleichwertige Konkurrenten\" gelten.\n * Zwei Schüler gelten als gleichwertige Konkurrenten, wenn der Unterschied in ihren Punktzahlen für jedes Fach (Mathematik, Englisch und Chinesisch)\n * nicht größer als 5 ist und der Unterschied in ihren Gesamtpunktzahlen nicht größer als 10 ist.\n * \n * @param scores Eine Liste von Tripeln, die jeweils die Mathematik-, Englisch- und Chinesisch-Punktzahlen eines Schülers darstellen.\n * @return Die Anzahl der Paare von Schülern, die als gleichwertige Konkurrenten gelten.\n * \n * Beispiel:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "ha": "/**\n * Yana ƙididdige adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"gasa daidai\".\n * Ana ɗaukar ɗalibai biyu a matsayin gasa daidai idan bambancin maki a kowanne fanni (Lissafi, Turanci, da Sinanci)\n * bai fi 5 ba, kuma bambancin jimillar maki bai fi 10 ba.\n * \n * @param scores Jerin na uku-uku, kowanne yana wakiltar maki na Lissafi, Turanci, da Sinanci na ɗalibi.\n * @return Adadin ma'aurata na ɗalibai waɗanda ake ɗauka gasa daidai.\n * \n * Misali:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "hi": "/**\n * उन छात्रों की जोड़ी की संख्या गिनता है जिन्हें \"समान प्रतियोगी\" माना जाता है।\n * दो छात्रों को समान प्रतियोगी माना जाता है यदि उनके प्रत्येक विषय (गणित, अंग्रेजी, और चीनी) में उनके अंकों का अंतर 5 से अधिक नहीं है,\n * और उनके कुल अंकों का अंतर 10 से अधिक नहीं है।\n * \n * @param scores एक ट्रिपल की सूची, प्रत्येक छात्र के गणित, अंग्रेजी, और चीनी अंकों का प्रतिनिधित्व करती है।\n * @return उन छात्रों की जोड़ी की संख्या जो समान प्रतियोगी माने जाते हैं।\n * \n * उदाहरण:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "hu": "/**\n * Megszámolja azon diákpárok számát, akiket \"egyenlő versenytársaknak\" tekintünk.\n * Két diákot akkor tekintünk egyenlő versenytársaknak, ha a pontszámuk közötti különbség minden tantárgyban (Matematika, Angol, és Kínai)\n * nem nagyobb, mint 5, és az összpontszámuk közötti különbség nem nagyobb, mint 10.\n * \n * @param scores Hármasok listája, amelyek mindegyike egy diák Matematika, Angol, és Kínai pontszámát képviseli.\n * @return Azon diákpárok száma, akiket egyenlő versenytársaknak tekintünk.\n * \n * Példa:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9467799688574172",
      "hy": "0.9447606924038165",
      "bn": "0.9408554204822897",
      "bg": "0.9494535337861468",
      "zh": "0.9182540639458538",
      "fr": "0.9427658474870831",
      "de": "0.9439365749529028",
      "ha": "0.9372085666864891",
      "hi": "0.9343260425969108",
      "hu": "0.9338592612014788"
    },
    "canonical_solution": "{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}",
    "instruction": {
      "en": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nकोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int\n{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9244352427732785",
      "bn": "0.8678478307810112",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9250790038382126",
      "hi": "0.8905183106900473",
      "hu": "0.9335354936803919"
    },
    "level": "",
    "test": "fun main() {\n    check(countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91))) == 2)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(92, 93, 95), Triple(101, 102, 103))) == 1)\n    check(countEqualCompetitors(listOf(Triple(90, 91, 92), Triple(86, 87, 88), Triple(93, 94, 95))) == 1)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(105, 105, 105), Triple(100, 100, 100))) == 1)\n}\n\n\nmain()",
    "entry_point": "countEqualCompetitors",
    "signature": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int",
    "docstring": {
      "en": "Counts the number of pairs of students who are considered \"equal competitors\".\n  Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n  is not greater than 5, and the difference in their total scores is not greater than 10.\n  \n  @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n  @return The number of pairs of students who are considered equal competitors.\n  \n  Example:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "sq": "Numëron numrin e çifteve të studentëve që konsiderohen \"konkurrentë të barabartë\". Dy studentë konsiderohen konkurrentë të barabartë nëse diferenca në pikët e tyre për secilin lëndë (Matematikë, Anglisht dhe Kinezisht) nuk është më e madhe se 5, dhe diferenca në pikët e tyre totale nuk është më e madhe se 10.\n\n@param scores Një listë treshe, secila që përfaqëson pikët e Matematikës, Anglishtes dhe Kinezishtes të një studenti.\n@return Numri i çifteve të studentëve që konsiderohen konkurrentë të barabartë.\n\nShembull:\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "hy": "Հաշվում է այն ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասար մրցակիցներ\":\n  Երկու ուսանող համարվում են հավասար մրցակիցներ, եթե նրանց գնահատականների տարբերությունը յուրաքանչյուր առարկայի համար (Մաթեմատիկա, Անգլերեն և Չինարեն)\n  չի գերազանցում 5-ը, և նրանց ընդհանուր գնահատականների տարբերությունը չի գերազանցում 10-ը:\n  \n  @param scores Երեքյակների ցուցակ, որոնցից յուրաքանչյուրը ներկայացնում է ուսանողի Մաթեմատիկայի, Անգլերենի և Չինարենի գնահատականները:\n  @return Ուսանողների զույգերի քանակը, որոնք համարվում են հավասար մրցակիցներ:\n  \n  Օրինակ:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "bn": "ছাত্রদের জোড়ার সংখ্যা গণনা করে যারা \"সমান প্রতিযোগী\" হিসাবে বিবেচিত হয়।\n  দুটি ছাত্র সমান প্রতিযোগী হিসাবে বিবেচিত হয় যদি তাদের প্রতিটি বিষয়ের (গণিত, ইংরেজি এবং চীনা) স্কোরের পার্থক্য 5 এর বেশি না হয়, এবং তাদের মোট স্কোরের পার্থক্য 10 এর বেশি না হয়।\n\n  @param scores একটি ট্রিপলসের তালিকা, প্রতিটি ছাত্রের গণিত, ইংরেজি এবং চীনা স্কোর উপস্থাপন করে।\n  @return ছাত্রদের জোড়ার সংখ্যা যারা সমান প্রতিযোগী হিসাবে বিবেচিত হয়।\n\n  উদাহরণ:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "bg": "Брои броя на двойките ученици, които се считат за \"равни съперници\".\n  Двама ученици се считат за равни съперници, ако разликата в техните оценки по всеки предмет (Математика, Английски и Китайски)\n  не е по-голяма от 5, и разликата в техните общи оценки не е по-голяма от 10.\n  \n  @param scores Списък от тройки, всяка представляваща оценките по Математика, Английски и Китайски на ученик.\n  @return Броят на двойките ученици, които се считат за равни съперници.\n  \n  Пример:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "zh": "计算被认为是“平等竞争者”的学生对数。\n两个学生被认为是平等竞争者，如果他们在每个科目（数学、英语和语文）的分数差不大于5，并且他们的总分差不大于10。\n\n@param scores 一个三元组的列表，每个三元组代表一个学生的数学、英语和语文成绩。\n@return 被认为是平等竞争者的学生对数。\n\n例子：\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "fr": "Compte le nombre de paires d'étudiants qui sont considérés comme des \"concurrents égaux\".\n  Deux étudiants sont considérés comme des concurrents égaux si la différence de leurs scores pour chaque matière (Mathématiques, Anglais et Chinois)\n  n'est pas supérieure à 5, et si la différence de leurs scores totaux n'est pas supérieure à 10.\n  \n  @param scores Une liste de triplets, chacun représentant les scores en Mathématiques, Anglais et Chinois d'un étudiant.\n  @return Le nombre de paires d'étudiants qui sont considérés comme des concurrents égaux.\n  \n  Exemple :\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "de": "Zählt die Anzahl der Paare von Schülern, die als \"gleichwertige Konkurrenten\" gelten.\n  Zwei Schüler gelten als gleichwertige Konkurrenten, wenn der Unterschied in ihren Punktzahlen für jedes Fach (Mathematik, Englisch und Chinesisch)\n  nicht größer als 5 ist und der Unterschied in ihren Gesamtpunktzahlen nicht größer als 10 ist.\n  \n  @param scores Eine Liste von Tripeln, die jeweils die Mathematik-, Englisch- und Chinesisch-Punktzahlen eines Schülers darstellen.\n  @return Die Anzahl der Paare von Schülern, die als gleichwertige Konkurrenten gelten.\n  \n  Beispiel:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "ha": "Yana ƙidaya yawan ma'aurata na ɗalibai waɗanda ake ɗauka \"gasa daidai\".\n  Ana ɗaukar ɗalibai biyu a matsayin masu gasa daidai idan bambancin a cikin maki nasu na kowanne fanni (Lissafi, Turanci, da Sinanci)\n  bai fi 5 ba, kuma bambancin a cikin jimlar maki nasu bai fi 10 ba.\n  \n  @param scores Jerin abubuwa uku, kowanne yana wakiltar maki na Lissafi, Turanci, da Sinanci na ɗalibi.\n  @return Yawan ma'aurata na ɗalibai waɗanda ake ɗauka a matsayin masu gasa daidai.\n  \n  Misali:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "hi": "छात्रों के जोड़ों की संख्या की गणना करता है जिन्हें \"समान प्रतिस्पर्धी\" माना जाता है।\n  दो छात्रों को समान प्रतिस्पर्धी माना जाता है यदि उनके प्रत्येक विषय (गणित, अंग्रेजी, और चीनी) के अंकों में अंतर 5 से अधिक नहीं है, और उनके कुल अंकों में अंतर 10 से अधिक नहीं है।\n\n  @param scores ट्रिपल्स की एक सूची, प्रत्येक छात्र के गणित, अंग्रेजी, और चीनी अंकों का प्रतिनिधित्व करती है।\n  @return उन छात्रों के जोड़ों की संख्या जो समान प्रतिस्पर्धी माने जाते हैं।\n\n  उदाहरण:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "hu": "Számolja meg azon diákpárok számát, akik \"egyenlő versenytársaknak\" tekinthetők.\n  Két diák akkor tekinthető egyenlő versenytársnak, ha a pontszámuk közötti különbség minden tantárgyban (matematika, angol és kínai)\n  nem nagyobb, mint 5, és az összpontszámuk közötti különbség nem nagyobb, mint 10.\n  \n  @param scores Egy hármasok listája, amelyek mindegyike egy diák matematika, angol és kínai pontszámát képviseli.\n  @return Azon diákpárok száma, akik egyenlő versenytársaknak tekinthetők.\n  \n  Példa:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2"
    },
    "docstring_bertscore": {
      "sq": "0.9817289844005058",
      "hy": "0.9729592544474345",
      "bn": "0.9801476879370871",
      "bg": "0.9844190356508613",
      "zh": "0.9451134599605345",
      "fr": "0.9728007474033686",
      "de": "0.9812189015820082",
      "ha": "0.9871517924331393",
      "hi": "0.9680079949393778",
      "hu": "0.9704412171070552"
    }
  },
  {
    "task_id": "Kotlin/42",
    "prompt": {
      "en": "/**\n * Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n * Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n * \n * Example:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "sq": "/**\n * Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur parasysh një numër fillestar të cigareve dhe një raport të bishtave të cigareve për cigare të reja.\n * Pjetri ruan bishtat nga cigaret e pira dhe i shkëmben ato për të reja me një normë të caktuar.\n * \n * Shembull:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "hy": "/**\n * Հաշվել ընդհանուր ծխախոտների քանակը, որը կարող է ծխել Պետրոսը՝ հաշվի առնելով սկզբնական ծխախոտների քանակը և ծխախոտի մնացորդները նոր ծխախոտների փոխանակման հարաբերակցությամբ:\n * Պետրոսը պահում է ծխած ծխախոտների մնացորդները և փոխանակում դրանք նորերի հետ տրված հարաբերակցությամբ:\n * \n * Օրինակ:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "bn": "/**\n * প্রদত্ত প্রাথমিক সংখ্যক সিগারেট এবং সিগারেটের বাট থেকে নতুন সিগারেটের অনুপাতের ভিত্তিতে পিটার মোট কত সিগারেট খেতে পারে তা গণনা করুন।\n * পিটার ধূমপান করা সিগারেটের বাট সংগ্রহ করে এবং একটি নির্দিষ্ট হারে সেগুলো নতুন সিগারেটের জন্য বিনিময় করে।\n * \n * উদাহরণ:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "bg": "/**\n * Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид началния брой цигари и съотношението на фасове към нови цигари.\n * Петър събира фасове от изпушени цигари и ги обменя за нови при дадена ставка.\n * \n * Пример:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "zh": "/**\n * 计算 Peter 可以抽的香烟总数，给定初始香烟数量和烟头换新香烟的比例。\n * Peter 保存抽过的香烟烟头，并以给定的比例将它们换成新的香烟。\n * \n * 示例:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "fr": "/**\n * Calculer le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un ratio de mégots de cigarettes pour de nouvelles cigarettes.\n * Peter garde les mégots des cigarettes fumées et les échange contre de nouvelles à un taux donné.\n * \n * Exemple :\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "de": "/**\n * Berechne die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und ein Verhältnis von Zigarettenstummeln zu neuen Zigaretten.\n * Peter spart Stummel von gerauchten Zigaretten und tauscht sie zu einem gegebenen Kurs gegen neue ein.\n * \n * Beispiel:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "ha": "/**\n * Lissafa jimillar adadin sigari da Peter zai iya sha idan aka ba shi adadin farko na sigari da kuma rabo na bututun sigari zuwa sabbin sigari.\n * Peter yana adana bututun sigari daga sigari da aka sha kuma yana musanya su da sabbi a wani kudi da aka bayar.\n * \n * Misali:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "hi": "/**\n * पीटर कुल कितनी सिगरेट पी सकता है यह गणना करें, जब उसे प्रारंभिक संख्या में सिगरेट और सिगरेट के टुकड़ों से नई सिगरेट बनाने का अनुपात दिया गया हो।\n * पीटर पी हुई सिगरेट के टुकड़े बचाता है और उन्हें एक दिए गए दर पर नई सिगरेट के लिए बदलता है।\n * \n * उदाहरण:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "hu": "/**\n * Számítsd ki, hogy összesen hány cigarettát tud elszívni Péter, ha adott számú cigarettával kezd és van egy arány a cigarettacsikkek és az új cigaretták között.\n * Péter megőrzi az elszívott cigaretták csikkjeit, és egy adott arányban új cigarettákra cseréli azokat.\n * \n * Példa:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9260131625202197",
      "hy": "0.8899653237092461",
      "bn": "0.9088977784775865",
      "bg": "0.9866043671030071",
      "zh": "0.9197354493276121",
      "fr": "0.9273580888302069",
      "de": "0.9356103866406824",
      "ha": "0.9306126476234635",
      "hi": "0.9543235534683602",
      "hu": "0.8885224726214087"
    },
    "canonical_solution": "{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}",
    "instruction": {
      "en": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\n请用不超过500个字符的中文为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int\n{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9351026873867572",
      "hy": "0.9417669353008588",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8859374968426207",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(totalCigarettesSmoked(4, 3) == 5)\n    check(totalCigarettesSmoked(10, 3) == 14)\n    check(totalCigarettesSmoked(1, 2) == 1) // Edge case: Not enough cigarettes to exchange\n    check(totalCigarettesSmoked(20, 5) == 24) // More cigarettes, different exchange rate\n}\n\nmain()",
    "entry_point": "totalCigarettesSmoked",
    "signature": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int",
    "docstring": {
      "en": "Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n  Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n  \n  Example:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "sq": "Llogarit numrin total të cigareve që Peter mund të pijë duke pasur parasysh një numër fillestar të cigareve dhe një raport të bishtave të cigareve për cigare të reja.\n  Peter ruan bishtat nga cigaret e tymosura dhe i shkëmben ato për të reja me një normë të caktuar.\n  \n  Shembull:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "hy": "Հաշվարկել ընդհանուր սիգարետների քանակը, որ Պետերը կարող է ծխել տրված սկզբնական սիգարետների քանակով և սիգարետի մնացորդների փոխանակման հարաբերակցությամբ:\n  Պետերը պահպանում է ծխած սիգարետների մնացորդները և փոխանակում դրանք նորերի հետ տրված հարաբերակցությամբ:\n  \n  Օրինակ:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "bn": "সিগারেটের প্রাথমিক সংখ্যা এবং সিগারেটের বাট থেকে নতুন সিগারেট পাওয়ার অনুপাত দেওয়া হলে পিটার মোট কতগুলি সিগারেট খেতে পারে তা গণনা করুন।  \nপিটার ধূমপান করা সিগারেটের বাট সংরক্ষণ করে এবং নির্দিষ্ট হারে সেগুলি নতুন সিগারেটের জন্য বিনিময় করে।\n\nউদাহরণ:\n>>> totalCigarettesSmoked(4, 3)\n    5\n>>> totalCigarettesSmoked(10, 3)\n    14",
      "bg": "Изчислете общия брой цигари, които Петър може да изпуши, като се даде началният брой цигари и съотношението на фасове към нови цигари.\nПетър събира фасове от изпушени цигари и ги обменя за нови при даден курс.\n\nПример:\n>>> totalCigarettesSmoked(4, 3)\n    5\n>>> totalCigarettesSmoked(10, 3)\n    14",
      "zh": "计算彼得可以抽的香烟总数，给定初始香烟数量和烟蒂兑换新香烟的比例。\n彼得保存抽过的香烟的烟蒂，并以给定的比例将它们兑换为新的香烟。\n\n示例：\n>>> totalCigarettesSmoked(4, 3)\n    5\n>>> totalCigarettesSmoked(10, 3)\n    14",
      "fr": "Calculer le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un ratio de mégots de cigarettes pour de nouvelles cigarettes.\n  Peter garde les mégots des cigarettes fumées et les échange contre de nouvelles à un taux donné.\n  \n  Exemple :\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "de": "Berechne die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und ein Verhältnis von Zigarettenstummeln zu neuen Zigaretten.\n  Peter spart Stummel von gerauchten Zigaretten und tauscht sie zu einem gegebenen Kurs gegen neue ein.\n  \n  Beispiel:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "ha": "Ƙididdige jimillar adadin sigari da Peter zai iya shan idan aka ba da adadin sigari na farko da kuma rabo na bututun sigari zuwa sabbin sigari. \n  Peter yana adana bututun daga sigarin da ya sha kuma yana musanya su da sabbi a wani ƙimar musanya da aka bayar.\n  \n  Misali:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "hi": "कुल सिगरेटों की संख्या की गणना करें जो पीटर पी सकता है, दिए गए प्रारंभिक सिगरेटों की संख्या और सिगरेट बट्स से नई सिगरेटों के अनुपात के आधार पर। \n  पीटर धूम्रपान की गई सिगरेटों के बट्स बचाता है और उन्हें एक दिए गए दर पर नई सिगरेटों के लिए बदलता है।\n  \n  उदाहरण:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "hu": "Számítsuk ki, hogy Péter összesen hány cigarettát tud elszívni, ha adott számú cigarettával kezd és van egy arány a cigarettacsikkek és az új cigaretták között. \n  Péter megőrzi az elszívott cigaretták csikkjeit, és egy adott arányban új cigarettákra cseréli őket.\n  \n  Példa:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14"
    },
    "docstring_bertscore": {
      "sq": "0.9882877595822778",
      "hy": "0.9514676458498406",
      "bn": "0.9417961339668709",
      "bg": "0.9736727347761118",
      "zh": "0.9502593772420054",
      "fr": "0.9721923425462587",
      "de": "0.9923408125072947",
      "ha": "0.9632511945743543",
      "hi": "0.9531373328328199",
      "hu": "0.9165994728718332"
    }
  },
  {
    "task_id": "Kotlin/43",
    "prompt": {
      "en": "/**\n * Finds the length of the longest consecutive sequence in a given list of integers.\n * Consecutive sequence means numbers that come sequentially without any gap.\n * \n * Example:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "sq": "/**\n * Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në një listë të dhënë të numrave të plotë.\n * Sekuenca e njëpasnjëshme do të thotë numra që vijnë në mënyrë sekuenciale pa asnjë hendek.\n * \n * Shembull:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "hy": "/**\n * Գտնում է ամենաերկար հաջորդական հաջորդականության երկարությունը տրված ամբողջ թվերի ցուցակում:\n * Հաջորդական հաջորդականություն նշանակում է թվեր, որոնք գալիս են հաջորդաբար առանց որևէ բացի:\n * \n * Օրինակ:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "bn": "/**\n * একটি প্রদত্ত পূর্ণসংখ্যার তালিকায় দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n * ধারাবাহিক ক্রম মানে হল সংখ্যাগুলি কোন ফাঁক ছাড়াই ধারাবাহিকভাবে আসে।\n * \n * উদাহরণ:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/",
      "bg": "/**\n * Намира дължината на най-дългата последователна поредица в даден списък от цели числа.\n * Последователна поредица означава числа, които идват последователно без никаква празнина.\n * \n * Пример:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "zh": "/**\n * 找到给定整数列表中最长连续序列的长度。\n * 连续序列意味着数字按顺序排列且没有间隔。\n * \n * 示例:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "fr": "/**\n * Trouve la longueur de la plus longue séquence consécutive dans une liste donnée d'entiers.\n * Séquence consécutive signifie des nombres qui se suivent sans aucun écart.\n * \n * Exemple :\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "de": "/**\n * Findet die Länge der längsten aufeinanderfolgenden Sequenz in einer gegebenen Liste von ganzen Zahlen.\n * Aufeinanderfolgende Sequenz bedeutet Zahlen, die ohne Lücke nacheinander kommen.\n * \n * Beispiel:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "ha": "/**\n * Nemi tsawon jerin lambobi masu jere mafi tsawo a cikin jerin lambobi na ba a tsaye ba.\n * Jerin lambobi masu jere yana nufin lambobi da suke zuwa a jere ba tare da wani tazara ba.\n * \n * Misali:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "hi": "/**\n * दिए गए पूर्णांकों की सूची में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\n * लगातार अनुक्रम का मतलब है कि संख्या बिना किसी अंतराल के क्रमिक रूप से आती हैं।\n * \n * उदाहरण:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "hu": "/**\n * Megkeresi a leghosszabb egymást követő sorozat hosszát egy adott egész számokat tartalmazó listában.\n * Egymást követő sorozat azt jelenti, hogy a számok megszakítás nélkül követik egymást.\n * \n * Példa:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9920440587180286",
      "hy": "0.9909247765208969",
      "bn": "0.9382380679513929",
      "bg": "0.9868528537096818",
      "zh": "0.9582538528178975",
      "fr": "0.9859270375036782",
      "de": "0.9826665197989904",
      "ha": "0.9647895868754696",
      "hi": "0.9862184282726564",
      "hu": "0.9689896262824522"
    },
    "canonical_solution": "{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}",
    "instruction": {
      "en": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, সর্বাধিক ৫০০ অক্ষর ব্যবহার করে।",
      "bg": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nBayar da takaitaccen bayani a cikin yaren ɗan adam (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nकृपया दिए गए Kotlin कोड का संक्षिप्त प्राकृतिक भाषा में वर्णन (डॉकस्ट्रींग) हिंदी में करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun longestConsecutiveSequence(numbers: List<Int>): Int\n{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.8927018544687637",
      "bn": "0.918534331413494",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9133254483012352",
      "hi": "0.9214555884273742",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9)) == 6)\n    check(longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2)) == 4)\n    check(longestConsecutiveSequence(listOf(1, 2, 3, 4, 5, 6)) == 6)\n    check(longestConsecutiveSequence(listOf(100, 4, 200, 1, 3, 2)) == 4)\n}\n\n\nmain()",
    "entry_point": "longestConsecutiveSequence",
    "signature": "fun longestConsecutiveSequence(numbers: List<Int>): Int",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in a given list of integers.\n  Consecutive sequence means numbers that come sequentially without any gap.\n  \n  Example:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "sq": "Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në një listë të dhënë të numrave të plotë.\n  Sekuenca e njëpasnjëshme do të thotë numra që vijnë në mënyrë sekuenciale pa asnjë hendek.\n  \n  Shembull:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hy": "Գտնում է տրված ամբողջ թվերի ցուցակում ամենաերկար հաջորդական հաջորդականության երկարությունը։  \n  Հաջորդական հաջորդականություն նշանակում է թվեր, որոնք գալիս են հաջորդաբար առանց որևէ բացի։\n  \n  Օրինակ:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "bn": "দেওয়া পূর্ণসংখ্যার তালিকায় দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে। ধারাবাহিক ক্রম মানে এমন সংখ্যা যা কোনো ফাঁক ছাড়াই ধারাবাহিকভাবে আসে।\n\nউদাহরণ:\n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n    6\n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n    4",
      "bg": "Намира дължината на най-дългата последователна поредица в даден списък от цели числа.\n  Последователна поредица означава числа, които идват последователно без никаква празнина.\n  \n  Пример:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "zh": "找到给定整数列表中最长连续序列的长度。  \n连续序列意味着数字按顺序排列且没有间隔。\n\n示例：\n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n    6\n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n    4",
      "fr": "Trouve la longueur de la plus longue séquence consécutive dans une liste donnée d'entiers.\n  Séquence consécutive signifie des nombres qui viennent séquentiellement sans aucun écart.\n  \n  Exemple :\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "de": "Findet die Länge der längsten aufeinanderfolgenden Sequenz in einer gegebenen Liste von ganzen Zahlen.\n  Eine aufeinanderfolgende Sequenz bedeutet Zahlen, die ohne Lücke nacheinander kommen.\n  \n  Beispiel:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "ha": "Yana nemo tsawon jerin lambobi masu jere mafi tsawo a cikin wata takamaiman jerin lambobi.\n  Jerin lambobi masu jere yana nufin lambobi da suke zuwa a jere ba tare da wata tazara ba.\n  \n  Misali:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hi": "दिए गए पूर्णांकों की सूची में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।  \n  लगातार अनुक्रम का मतलब है कि संख्याएँ बिना किसी अंतराल के क्रमिक रूप से आती हैं।\n  \n  उदाहरण:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hu": "Megkeresi a leghosszabb egymást követő sorozat hosszát egy adott egész számokat tartalmazó listában.\n  Egymást követő sorozat olyan számokat jelent, amelyek megszakítás nélkül követik egymást.\n  \n  Példa:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4"
    },
    "docstring_bertscore": {
      "sq": "0.9804748321746515",
      "hy": "0.9818149913554939",
      "bn": "0.9874098132981036",
      "bg": "0.9831555477970984",
      "zh": "0.9565478164751889",
      "fr": "0.9739198309701191",
      "de": "0.9778882673528152",
      "ha": "0.975547408312319",
      "hi": "0.9855361329138015",
      "hu": "0.9538281692980592"
    }
  },
  {
    "task_id": "Kotlin/44",
    "prompt": {
      "en": "/**\n * Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n * Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n * \n * Example:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "sq": "/**\n * Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjët 'b' dhe 'c'.\n * Kthen \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n * \n * Shembull:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "hy": "/**\n * Համեմատում է կողքի երկարությունը 'a' ունեցող քառակուսու մակերեսը 'b' և 'c' կողմերով ուղղանկյան մակերեսի հետ։\n * Վերադարձնում է \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է։\n * \n * Օրինակ:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "bn": "/**\n * একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফল তুলনা করে একটি আয়তক্ষেত্রের বাহুগুলি 'b' এবং 'c' এর ক্ষেত্রফলের সাথে।\n * যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয় তাহলে \"Alice\" ফেরত দেয়, এবং যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয় তাহলে \"Bob\" ফেরত দেয়।\n * \n * উদাহরণ:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */ \nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "bg": "/**\n * Сравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'.\n * Връща \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n * \n * Пример:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */ \nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "zh": "/**\n * 比较边长为 'a' 的正方形的面积与边长为 'b' 和 'c' 的矩形的面积。\n * 如果正方形的面积更大，则返回 \"Alice\"；如果矩形的面积更大，则返回 \"Bob\"。\n * \n * 示例:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "fr": "/**\n * Compare la superficie d'un carré avec une longueur de côté 'a' à la superficie d'un rectangle avec les côtés 'b' et 'c'.\n * Retourne \"Alice\" si la superficie du carré est plus grande, et \"Bob\" si la superficie du rectangle est plus grande.\n * \n * Exemple :\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "de": "/**\n * Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\n * Gibt \"Alice\" zurück, wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n * \n * Beispiel:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "ha": "/**\n * Kwatanta yanki na murabba'i tare da tsawon gefe 'a' da yanki na murabba'i mai bangarori 'b' da 'c'.\n * Yana mayar da \"Alice\" idan yankin murabba'i ya fi girma, kuma \"Bob\" idan yankin murabba'in ya fi girma.\n * \n * Misali:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "hi": "/**\n * एक वर्ग जिसका भुजा लंबाई 'a' है, उसके क्षेत्रफल की तुलना एक आयत के क्षेत्रफल से करता है जिसके भुजाएँ 'b' और 'c' हैं।\n * \"Alice\" लौटाता है यदि वर्ग का क्षेत्रफल बड़ा है, और \"Bob\" लौटाता है यदि आयत का क्षेत्रफल बड़ा है।\n * \n * उदाहरण:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "hu": "/**\n * Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' és 'c' oldalú téglalap területével.\n * \"Alice\"-t ad vissza, ha a négyzet területe nagyobb, és \"Bob\"-ot, ha a téglalap területe nagyobb.\n * \n * Példa:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */ \nfun compareAreas(a: Int, b: Int, c: Int): String "
    },
    "prompt_bertscore": {
      "sq": "0.9992644716990278",
      "hy": "1",
      "bn": "1",
      "bg": "0.9919294489881715",
      "zh": "0.9573810709236302",
      "fr": "0.9967084959558709",
      "de": "0.9992644716990278",
      "ha": "0.9755122507348759",
      "hi": "1",
      "hu": "0.9858223592928728"
    },
    "canonical_solution": "{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}",
    "instruction": {
      "en": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nПредоставете кратко описание на кода на Kotlin на естествен език на български, използвайки най-много 500 знака.",
      "zh": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar Kotlin a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nकृपया Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun compareAreas(a: Int, b: Int, c: Int): String\n{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9244352427732785",
      "bn": "0.8738053517993907",
      "bg": "0.8371354026350158",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9191087704754469",
      "hi": "0.9022003592898521",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(compareAreas(5, 4, 6) == \"Alice\")\n    check(compareAreas(7, 5, 10) == \"Bob\")\n    // Additional test cases for edge cases\n    check(compareAreas(1, 1, 1) == \"Bob\") // Edge case where all sides are equal\n    check(compareAreas(10, 5, 20) == \"Bob\") // Test case where rectangle is clearly larger\n}\n\n\nmain()",
    "entry_point": "compareAreas",
    "signature": "fun compareAreas(a: Int, b: Int, c: Int): String",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n  Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n  \n  Example:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "sq": "Krahason sipërfaqen e një katrori me gjatësi të brinjës 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\nKthen \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\nShembull:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "hy": "Համեմատում է կողմի երկարությունը 'a' ունեցող քառակուսու մակերեսը կողմերի 'b' և 'c' ունեցող ուղղանկյան մակերեսի հետ։ \nՎերադարձնում է \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է։\n\nՕրինակ:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "bn": "একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফলকে একটি আয়তক্ষেত্রের বাহু 'b' এবং 'c' এর ক্ষেত্রফলের সাথে তুলনা করে।  \n\"এলিস\" ফেরত দেয় যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, এবং \"বব\" ফেরত দেয় যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\nউদাহরণ:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "bg": "Сравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'. Връща \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n\nПример:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "zh": "比较边长为 'a' 的正方形的面积与边长为 'b' 和 'c' 的矩形的面积。\n返回 \"Alice\" 如果正方形的面积较大，返回 \"Bob\" 如果矩形的面积较大。\n\n示例：\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "fr": "Compare l'aire d'un carré avec une longueur de côté 'a' à l'aire d'un rectangle avec des côtés 'b' et 'c'.\n  Retourne \"Alice\" si l'aire du carré est plus grande, et \"Bob\" si l'aire du rectangle est plus grande.\n  \n  Exemple :\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "de": "Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\nGibt \"Alice\" zurück, wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n\nBeispiel:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "ha": "Kwatanta yankin murabba'i tare da tsawon gefe 'a' da yankin murabba'i mai gefe 'b' da 'c'. \n  Mayar da \"Alice\" idan yankin murabba'i ya fi girma, da \"Bob\" idan yankin murabba'i ya fi girma.\n  \n  Misali:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "hi": "वर्ग जिसकी भुजा की लंबाई 'a' है, उसके क्षेत्रफल की तुलना आयत जिसकी भुजाएँ 'b' और 'c' हैं, के क्षेत्रफल से करता है।  \n\"एलिस\" लौटाता है यदि वर्ग का क्षेत्रफल बड़ा है, और \"बॉब\" लौटाता है यदि आयत का क्षेत्रफल बड़ा है।\n\nउदाहरण:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "hu": "Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' és 'c' oldalú téglalap területével. \n  \"Alice\"-t ad vissza, ha a négyzet területe nagyobb, és \"Bob\"-ot, ha a téglalap területe nagyobb.\n  \n  Példa:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\""
    },
    "docstring_bertscore": {
      "sq": "0.9984947789725176",
      "hy": "0.9811368672346408",
      "bn": "0.9647609841006005",
      "bg": "0.9896185831352116",
      "zh": "0.9704010937700861",
      "fr": "0.9886091435387923",
      "de": "0.9984947789725176",
      "ha": "0.9667276235032269",
      "hi": "0.9897321997131635",
      "hu": "0.9811368672346408"
    }
  },
  {
    "task_id": "Kotlin/45",
    "prompt": {
      "en": "/**\n    * Finds M positive integers whose sum is N and their product is as large as possible.\n    * Outputs the lexicographically smallest sequence of these M integers.\n    * \n    * Example:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "sq": "/**\n    * Gjen M numra të plotë pozitivë, shuma e të cilëve është N dhe prodhimi i tyre është sa më i madh të jetë e mundur.\n    * Jep sekuencën leksikografikisht më të vogël të këtyre M numrave.\n    * \n    * Shembull:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "hy": "/**\n    * Գտնում է M դրական ամբողջ թվեր, որոնց գումարը N է և նրանց արտադրյալը հնարավորինս մեծ է:\n    * Արդյունքում տալիս է այս M թվերի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը:\n    * \n    * Օրինակ:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "bn": "/**\n    * এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N এবং তাদের গুণফল যত বড় সম্ভব।\n    * এই M পূর্ণসংখ্যার লেক্সিকোগ্রাফিক্যালি ক্ষুদ্রতম ক্রম আউটপুট করে।\n    * \n    * উদাহরণ:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/ \nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "bg": "/**\n    * Намира M положителни цели числа, чиято сума е N и чийто произведение е възможно най-голямо.\n    * Извежда лексикографски най-малката последователност от тези M цели числа.\n    * \n    * Пример:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "zh": "/**\n    * 找到 M 个正整数，其和为 N 且乘积尽可能大。\n    * 输出这些 M 个整数的字典序最小序列。\n    * \n    * 示例:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "fr": "/**\n    * Trouve M entiers positifs dont la somme est N et dont le produit est aussi grand que possible.\n    * Produit la plus petite séquence lexicographique de ces M entiers.\n    * \n    * Exemple :\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "de": "/**\n    * Findet M positive ganze Zahlen, deren Summe N ist und deren Produkt so groß wie möglich ist.\n    * Gibt die lexikographisch kleinste Sequenz dieser M ganzen Zahlen aus.\n    * \n    * Beispiel:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "ha": "/**\n    * Nemi lambobi M masu kyau wadanda jimlarsu ita ce N kuma samfurinsu ya fi girma yadda zai yiwu.\n    * Fitar da jerin lambobi M mafi ƙarancin lexicographically.\n    * \n    * Misali:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "hi": "/**\n    * M धनात्मक पूर्णांक खोजता है जिनका योग N है और उनका गुणनफल यथासंभव बड़ा है।\n    * इन M पूर्णांकों का शब्दकोशानुक्रम में सबसे छोटा अनुक्रम आउटपुट करता है।\n    * \n    * उदाहरण:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "hu": "/**\n    * Megkeresi azt az M pozitív egész számot, amelyek összege N és szorzatuk a lehető legnagyobb.\n    * Kiírja ezeknek az M egész számoknak a lexikografikusan legkisebb sorozatát.\n    * \n    * Példa:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> "
    },
    "prompt_bertscore": {
      "sq": "0.9739333378360295",
      "hy": "0.9873357241659776",
      "bn": "0.9842927067285231",
      "bg": "0.9950096103068795",
      "zh": "0.9848121251749293",
      "fr": "0.9804762225873188",
      "de": "0.9950096103068795",
      "ha": "0.8763819851021752",
      "hi": "0.9329918423274994",
      "hu": "0.9761774638809617"
    },
    "canonical_solution": "{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}",
    "instruction": {
      "en": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fun maxProductPartition(N: Int, M: Int): List<Int>\n{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (dokumentációs komment) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9026051680064012",
      "bn": "0.8738053517993907",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9010135427631687",
      "hi": "0.8761702451159921",
      "hu": "0.8796740850374475"
    },
    "level": "",
    "test": "fun main() {\n    check(maxProductPartition(6, 3) == listOf(2, 2, 2))\n    check(maxProductPartition(8, 3) == listOf(2, 3, 3))\n    check(maxProductPartition(10, 2) == listOf(5, 5))\n    check(maxProductPartition(7, 3) == listOf(2, 2, 3))\n}\n\nmain()",
    "entry_point": "maxProductPartition",
    "signature": "fun maxProductPartition(N: Int, M: Int): List<Int>",
    "docstring": {
      "en": "Finds M positive integers whose sum is N and their product is as large as possible.\n     Outputs the lexicographically smallest sequence of these M integers.\n     \n     Example:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "sq": "Gjen M numra të plotë pozitivë, shuma e të cilëve është N dhe produkti i tyre është sa më i madh të jetë e mundur.\n     Jep sekuencën më të vogël leksikografike të këtyre M numrave.\n     \n     Shembull:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "hy": "Գտնում է M դրական ամբողջ թվեր, որոնց գումարը N է, և նրանց արտադրյալը հնարավորինս մեծ է:\n     Արդյունքում տալիս է այս M ամբողջ թվերի բառարանորեն ամենափոքր հաջորդականությունը:\n     \n     Օրինակ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "bn": "M টি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N এবং তাদের গুণফল যতটা সম্ভব বড় হয়। \n     এই M পূর্ণসংখ্যার লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম ক্রম আউটপুট করে।\n\n     উদাহরণ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "bg": "Намира M положителни цели числа, чиято сума е N и чийто произведение е възможно най-голямо.\n     Извежда лексикографски най-малката последователност от тези M числа.\n     \n     Пример:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "zh": "找到 M 个正整数，其和为 N，并且它们的乘积尽可能大。\n     输出这些 M 个整数的字典序最小序列。\n     \n     示例：\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "fr": "Trouve M entiers positifs dont la somme est N et dont le produit est aussi grand que possible.\n     Produit la séquence lexicographiquement la plus petite de ces M entiers.\n     \n     Exemple:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "de": "Findet M positive ganze Zahlen, deren Summe N ist und deren Produkt so groß wie möglich ist.\n     Gibt die lexikografisch kleinste Sequenz dieser M Zahlen aus.\n     \n     Beispiel:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "ha": "Yana nemo M lambobi masu kyau wadanda jimlarsu ita ce N kuma samfurinsu ya kasance mafi girma yadda zai yiwu. \n     Yana fitar da jerin mafi ƙarancin jerin waɗannan lambobi M.\n     \n     Misali:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "hi": "M धनात्मक पूर्णांकों को खोजता है जिनका योग N है और उनका गुणनफल जितना संभव हो उतना बड़ा है। \n     इन M पूर्णांकों का शब्दकोशीय रूप से सबसे छोटा अनुक्रम आउटपुट करता है।\n     \n     उदाहरण:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "hu": "Megtalálja azt az M pozitív egész számot, amelyek összege N, és a szorzatuk a lehető legnagyobb.\n     Kiírja ezeknek az M egész számoknak a lexikografikusan legkisebb sorozatát.\n     \n     Példa:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.9465592905040875",
      "hy": "0.9724018975982506",
      "bn": "0.9715608965649488",
      "bg": "0.9859439210860661",
      "zh": "0.9836106100000493",
      "fr": "0.9726640897012166",
      "de": "0.9761472720630444",
      "ha": "0.9511931386632504",
      "hi": "0.9778916440692929",
      "hu": "0.950171781243969"
    }
  },
  {
    "task_id": "Kotlin/46",
    "prompt": {
      "en": "/**\n * Calculates the number of characters in the essay title, excluding spaces and newline characters.\n * \n * Example:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.\n */\nfun countTitleCharacters(title: String): Int ",
      "sq": "/**\n * Llogarit numrin e karaktereve në titullin e esesë, duke përjashtuar hapësirat dhe karakteret e reja të rreshtit.\n * \n * Shembull:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Funksioni numëron shkronjat e mëdha dhe të vogla të anglishtes, shifrat, por injoron hapësirat dhe karakteret e reja të rreshtit.\n */\nfun countTitleCharacters(title: String): Int ",
      "hy": "/**\n * Հաշվում է շարադրանքի վերնագրի սիմվոլների քանակը՝ բացի բացատներից և նոր տողերից:\n * \n * Օրինակ:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Ֆունկցիան հաշվում է մեծատառ և փոքրատառ անգլերեն տառերը, թվանշանները, բայց անտեսում է բացատներն ու նոր տողերը:\n */\nfun countTitleCharacters(title: String): Int",
      "bn": "/**\n * প্রবন্ধের শিরোনামে কতগুলি অক্ষর আছে তা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n * \n * উদাহরণ:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * ফাংশনটি বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা গণনা করে, কিন্তু ফাঁকা স্থান এবং নতুন লাইন অক্ষর উপেক্ষা করে।\n */\nfun countTitleCharacters(title: String): Int ",
      "bg": "/**\n * Изчислява броя на символите в заглавието на есето, изключвайки интервалите и символите за нов ред.\n * \n * Пример:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Функцията брои главни и малки английски букви, цифри, но игнорира интервалите и символите за нов ред.\n */\nfun countTitleCharacters(title: String): Int ",
      "zh": "/**\n * 计算文章标题中的字符数量，不包括空格和换行符。\n * \n * 示例:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * 该函数计算大写和小写的英文字母、数字，但忽略空格和换行符。\n */\nfun countTitleCharacters(title: String): Int ",
      "fr": "/**\n * Calcule le nombre de caractères dans le titre de l'essai, en excluant les espaces et les caractères de nouvelle ligne.\n * \n * Exemple:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * La fonction compte les lettres anglaises majuscules et minuscules, les chiffres, mais ignore les espaces et les caractères de nouvelle ligne.\n */",
      "de": "/**\n * Berechnet die Anzahl der Zeichen im Aufsatztitel, ohne Leerzeichen und Zeilenumbrüche.\n * \n * Beispiel:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Die Funktion zählt Groß- und Kleinbuchstaben des englischen Alphabets, Ziffern, ignoriert jedoch Leerzeichen und Zeilenumbrüche.\n */",
      "ha": "/**\n * Lissafa yawan haruffa a cikin taken rubutu, ban da sarari da haruffan sabon layi.\n * \n * Misali:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Aikin yana lissafa manyan da ƙananan haruffan Ingilishi, lambobi, amma yana watsi da sarari da haruffan sabon layi.\n */\nfun countTitleCharacters(title: String): Int",
      "hi": "/**\n * निबंध शीर्षक में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n * \n * उदाहरण:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * यह फ़ंक्शन बड़े और छोटे अंग्रेजी अक्षरों, अंकों की गणना करता है, लेकिन रिक्त स्थान और नई पंक्ति के वर्णों को अनदेखा करता है।\n */ \nfun countTitleCharacters(title: String): Int ",
      "hu": "/**\n * Kiszámítja az esszé címében található karakterek számát, a szóközök és az új sor karakterek kivételével.\n * \n * Példa:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * A függvény számolja a nagy- és kisbetűs angol betűket, számjegyeket, de figyelmen kívül hagyja a szóközöket és az új sor karaktereket.\n */\nfun countTitleCharacters(title: String): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9609004040148064",
      "hy": "0.958802668560697",
      "bn": "0.9790844195074073",
      "bg": "1",
      "zh": "0.9828931570637512",
      "fr": "0.9559239184483583",
      "de": "0.9203823884786426",
      "ha": "0.9734594057468803",
      "hi": "0.9917566405566711",
      "hu": "0.994847527915955"
    },
    "canonical_solution": "{\n    return title.count { it != ' ' && it != '\\n' }\n}",
    "instruction": {
      "en": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Kotlin në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nՏվեք կարճ բնութագիր (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nনিম্নলিখিত Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nДайте кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fun countTitleCharacters(title: String): Int\n{\n    return title.count { it != ' ' && it != '\\n' }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9379911703877666",
      "hy": "0.9001689663830083",
      "bn": "0.8688058251087426",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9250790038382126",
      "hi": "0.8761702451159921",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(countTitleCharacters(\"234\") == 3)\n    check(countTitleCharacters(\"Ca\\n45\") == 4)\n    check(countTitleCharacters(\"Hello, World!\") == 12) // Assuming \",\" is considered a valid character\n    check(countTitleCharacters(\"A B C D E\") == 5)\n    check(countTitleCharacters(\"\\n\\n\\n\\n\") == 0)\n}\n\n\nmain()",
    "entry_point": "countTitleCharacters",
    "signature": "fun countTitleCharacters(title: String): Int",
    "docstring": {
      "en": "Calculates the number of characters in the essay title, excluding spaces and newline characters.\n  \n  Example:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.",
      "sq": "Llogarit numrin e karaktereve në titullin e esesë, duke përjashtuar hapësirat dhe karakteret e reja rresht.\n\n  Shembull:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Funksioni numëron shkronjat e mëdha dhe të vogla të anglishtes, shifrat, por injoron hapësirat dhe karakteret e reja rresht.",
      "hy": "Հաշվում է շարադրանքի վերնագրում գտնվող սիմվոլների քանակը՝ բացի բացատներից և նոր տողերից:\n\n  Օրինակ:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Ֆունկցիան հաշվում է մեծատառ և փոքրատառ անգլերեն տառերը, թվանշանները, բայց անտեսում է բացատներն ու նոր տողերը:",
      "bn": "অ্যাসে শিরোনামের অক্ষরের সংখ্যা গণনা করে, স্পেস এবং নতুন লাইন ক্যারেক্টার বাদ দিয়ে।\n\nউদাহরণ:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nফাংশনটি বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা গণনা করে, কিন্তু স্পেস এবং নতুন লাইন ক্যারেক্টার উপেক্ষা করে।",
      "bg": "Изчислява броя на символите в заглавието на есето, без да включва интервали и знаци за нов ред.\n\n  Пример:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Функцията брои главни и малки английски букви, цифри, но игнорира интервали и знаци за нов ред.",
      "zh": "计算文章标题中的字符数，不包括空格和换行符。\n\n  示例：\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  该函数计算大写和小写的英文字母、数字，但忽略空格和换行符。",
      "fr": "Calcule le nombre de caractères dans le titre de l'essai, en excluant les espaces et les caractères de nouvelle ligne.\n\n  Exemple :\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  La fonction compte les lettres majuscules et minuscules anglaises, les chiffres, mais ignore les espaces et les caractères de nouvelle ligne.",
      "de": "Berechnet die Anzahl der Zeichen im Aufsatztitel, ohne Leerzeichen und Zeilenumbrüche.\n\n  Beispiel:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Die Funktion zählt Groß- und Kleinbuchstaben des englischen Alphabets, Ziffern, ignoriert jedoch Leerzeichen und Zeilenumbrüche.",
      "ha": "Yana ƙididdige adadin haruffa a cikin taken rubutun, ba tare da haɗa sarari da haruffan sabon layi ba.\n\n  Misali:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Aikin yana ƙididdige manyan da ƙananan haruffan Ingilishi, lambobi, amma yana watsi da sarari da haruffan sabon layi.",
      "hi": "निबंध शीर्षक में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं हैं।\n\nउदाहरण:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nयह फ़ंक्शन बड़े और छोटे अक्षरों वाले अंग्रेजी अक्षरों, अंकों की गणना करता है, लेकिन रिक्त स्थान और नई पंक्ति के वर्णों को अनदेखा करता है।",
      "hu": "Számolja ki az esszé címében található karakterek számát, a szóközök és az új sor karakterek kivételével.\n\nPélda:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nA függvény számolja a nagy- és kisbetűs angol betűket, számjegyeket, de figyelmen kívül hagyja a szóközöket és az új sor karaktereket."
    },
    "docstring_bertscore": {
      "sq": "0.9917929899164005",
      "hy": "0.941751442131138",
      "bn": "0.9644417850782774",
      "bg": "0.999999801369619",
      "zh": "0.9738648103545725",
      "fr": "0.9829980339049377",
      "de": "0.9480436553415612",
      "ha": "0.9660018280909254",
      "hi": "0.9643678945765325",
      "hu": "0.989717699695348"
    }
  },
  {
    "task_id": "Kotlin/47",
    "prompt": {
      "en": "/**\n * Counts the number of students who have enrolled in both courses A and B.\n * The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n * and the second list contains the IDs of students enrolled in course B.\n * \n * Example:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "sq": "/**\n * Numëron numrin e studentëve që janë regjistruar në të dyja kurset A dhe B.\n * Funksioni merr dy lista si argumente: lista e parë përmban ID-të e studentëve të regjistruar në kursin A,\n * dhe lista e dytë përmban ID-të e studentëve të regjistruar në kursin B.\n * \n * Shembull:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "hy": "/**\n * Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ A, և՛ B դասընթացներում:\n * Ֆունկցիան ընդունում է երկու ցուցակ որպես արգումենտներ. առաջին ցուցակը պարունակում է A դասընթացում գրանցված ուսանողների ID-ները,\n * իսկ երկրորդ ցուցակը պարունակում է B դասընթացում գրանցված ուսանողների ID-ները:\n * \n * Օրինակ:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "bn": "/**\n * কতজন শিক্ষার্থী উভয় কোর্স A এবং B-তে ভর্তি হয়েছে তা গণনা করে।\n * ফাংশনটি দুটি তালিকা আর্গুমেন্ট হিসাবে নেয়: প্রথম তালিকায় কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি রয়েছে,\n * এবং দ্বিতীয় তালিকায় কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি রয়েছে।\n * \n * উদাহরণ:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "bg": "/**\n * Брои броя на студентите, които са се записали и в двата курса A и B.\n * Функцията приема два списъка като аргументи: първият списък съдържа ID-тата на студентите, записани в курс A,\n * а вторият списък съдържа ID-тата на студентите, записани в курс B.\n * \n * Пример:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "zh": "/**\n * 计算同时注册了课程 A 和课程 B 的学生人数。\n * 该函数接受两个列表作为参数：第一个列表包含注册课程 A 的学生 ID，\n * 第二个列表包含注册课程 B 的学生 ID。\n * \n * 示例:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "fr": "/**\n * Compte le nombre d'étudiants qui se sont inscrits aux deux cours A et B.\n * La fonction prend deux listes comme arguments : la première liste contient les identifiants des étudiants inscrits au cours A,\n * et la deuxième liste contient les identifiants des étudiants inscrits au cours B.\n * \n * Exemple :\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "de": "/**\n * Zählt die Anzahl der Studenten, die sich in beide Kurse A und B eingeschrieben haben.\n * Die Funktion nimmt zwei Listen als Argumente: die erste Liste enthält die IDs der Studenten, die in Kurs A eingeschrieben sind,\n * und die zweite Liste enthält die IDs der Studenten, die in Kurs B eingeschrieben sind.\n * \n * Beispiel:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "ha": "/**\n * Yana ƙididdige yawan ɗaliban da suka yi rajista a duka darussa A da B.\n * Aikin yana ɗaukar jerin abubuwa guda biyu a matsayin hujjoji: jerin farko yana ƙunshe da ID na ɗaliban da suka yi rajista a darasi A,\n * kuma jerin na biyu yana ƙunshe da ID na ɗaliban da suka yi rajista a darasi B.\n * \n * Misali:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "hi": "/**\n * गिनती करता है उन छात्रों की संख्या जो दोनों पाठ्यक्रम A और B में नामांकित हैं।\n * फ़ंक्शन दो सूचियों को तर्क के रूप में लेता है: पहली सूची में पाठ्यक्रम A में नामांकित छात्रों की IDs होती हैं,\n * और दूसरी सूची में पाठ्यक्रम B में नामांकित छात्रों की IDs होती हैं।\n * \n * उदाहरण:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "hu": "/**\n * Megszámolja azon diákok számát, akik mindkét A és B kurzusra beiratkoztak.\n * A függvény két listát vesz át argumentumként: az első lista az A kurzusra beiratkozott diákok azonosítóit tartalmazza,\n * a második lista pedig a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n * \n * Példa:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9984441282253537",
      "hy": "0.9582602089900907",
      "bn": "0.9404490227226923",
      "bg": "0.9984441282253537",
      "zh": "0.9164363973290036",
      "fr": "0.9595934161075969",
      "de": "0.9919858600163853",
      "ha": "0.9384255750310898",
      "hi": "0.9507738299288857",
      "hu": "0.9886311915110871"
    },
    "canonical_solution": "{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}",
    "instruction": {
      "en": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nকোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int\n{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}\n\nAdj meg egy tömör természetes nyelvű leírást (dokumentációs szöveget) a Kotlin kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9363047984527804",
      "hy": "0.9174212067581745",
      "bn": "0.8522390581785277",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9542226492347945",
      "hi": "0.8761702451159921",
      "hu": "0.87817363113911"
    },
    "level": "",
    "test": "fun main() {\n    check(countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6)) == 4)\n    check(countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14)) == 1)\n    check(countCommonStudents(listOf(1, 2, 3), listOf(4, 5, 6)) == 0)\n    check(countCommonStudents(listOf(1, 2, 3, 4), listOf(2, 4)) == 2)\n}\n\n\nmain()",
    "entry_point": "countCommonStudents",
    "signature": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both courses A and B.\n  The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n  and the second list contains the IDs of students enrolled in course B.\n  \n  Example:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "sq": "Numëron numrin e studentëve që janë regjistruar në të dy kurset A dhe B. Funksioni merr dy lista si argumente: lista e parë përmban ID-të e studentëve të regjistruar në kursin A, dhe lista e dytë përmban ID-të e studentëve të regjistruar në kursin B.\n\nShembull:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "hy": "Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ Ա, և՛ Բ դասընթացներում:\n  Ֆունկցիան ընդունում է երկու ցուցակ որպես արգումենտներ. առաջին ցուցակը պարունակում է Ա դասընթացում գրանցված ուսանողների ID-ները,\n  իսկ երկրորդ ցուցակը պարունակում է Բ դասընթացում գրանցված ուսանողների ID-ները:\n  \n  Օրինակ:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "bn": "কতজন ছাত্র উভয় কোর্স A এবং B-তে ভর্তি হয়েছে তা গণনা করে।\nফাংশনটি দুটি তালিকা আর্গুমেন্ট হিসেবে গ্রহণ করে: প্রথম তালিকায় কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি থাকে, এবং দ্বিতীয় তালিকায় কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি থাকে।\n\nউদাহরণ:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "bg": "Брои броя на студентите, които са записани и в двата курса A и B. \nФункцията приема два списъка като аргументи: първият списък съдържа ID-та на студентите, записани в курс A, \nа вторият списък съдържа ID-та на студентите, записани в курс B.\n\nПример:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "zh": "计算同时注册了课程A和课程B的学生人数。\n该函数接受两个列表作为参数：第一个列表包含注册课程A的学生ID，第二个列表包含注册课程B的学生ID。\n\n示例：\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "fr": "Compte le nombre d'étudiants qui se sont inscrits à la fois aux cours A et B.\n  La fonction prend deux listes comme arguments : la première liste contient les identifiants des étudiants inscrits au cours A,\n  et la deuxième liste contient les identifiants des étudiants inscrits au cours B.\n  \n  Exemple :\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "de": "Zählt die Anzahl der Studenten, die sich in beide Kurse A und B eingeschrieben haben.  \nDie Funktion nimmt zwei Listen als Argumente: die erste Liste enthält die IDs der Studenten, die in Kurs A eingeschrieben sind,  \nund die zweite Liste enthält die IDs der Studenten, die in Kurs B eingeschrieben sind.\n\nBeispiel:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "ha": "Yana ƙidaya yawan ɗaliban da suka yi rajista a cikin duka darussan A da B. \n  Aikin yana ɗaukar jerin abubuwa biyu a matsayin hujjoji: jerin farko yana ƙunshe da ID na ɗaliban da suka yi rajista a darasi A, \n  kuma jerin na biyu yana ƙunshe da ID na ɗaliban da suka yi rajista a darasi B.\n\n  Misali:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "hi": "दोनों पाठ्यक्रम A और B में नामांकित छात्रों की संख्या गिनता है। \nयह फ़ंक्शन दो सूचियों को तर्क के रूप में लेता है: पहली सूची में पाठ्यक्रम A में नामांकित छात्रों की ID होती है, \nऔर दूसरी सूची में पाठ्यक्रम B में नामांकित छात्रों की ID होती है।\n\nउदाहरण:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "hu": "Számolja meg azon diákok számát, akik mindkét A és B kurzusra beiratkoztak.\n  A függvény két listát vesz át argumentumként: az első lista az A kurzusra beiratkozott diákok azonosítóit tartalmazza,\n  a második lista pedig a B kurzusra beiratkozott diákok azonosítóit.\n\n  Példa:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1"
    },
    "docstring_bertscore": {
      "sq": "0.9977060177294281",
      "hy": "0.9944002122978645",
      "bn": "0.999999801369619",
      "bg": "0.9977060177294281",
      "zh": "0.9489893345856683",
      "fr": "0.999999801369619",
      "de": "0.9808619627872885",
      "ha": "0.9783383637962403",
      "hi": "0.9889215891281602",
      "hu": "0.9869132373455164"
    }
  },
  {
    "task_id": "Kotlin/48",
    "prompt": {
      "en": "/**\n * Calculates the number of whole apples left after a given time has passed, \n * assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n * \n * @param appleCount The total number of apples initially available.\n * @param timePerApple The time in minutes it takes to eat a single apple.\n * @param timePassed The time in minutes that has elapsed.\n * @return The number of whole apples remaining.\n * \n * Example:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "sq": "/**\n * Llogarit numrin e mollëve të plota të mbetura pasi ka kaluar një kohë e caktuar,\n * duke supozuar se çdo mollë hahet njëra pas tjetrës dhe secila merr një kohë të caktuar për t'u ngrënë.\n * \n * @param appleCount Numri total i mollëve fillimisht të disponueshme.\n * @param timePerApple Koha në minuta që duhet për të ngrënë një mollë të vetme.\n * @param timePassed Koha në minuta që ka kaluar.\n * @return Numri i mollëve të plota të mbetura.\n * \n * Shembull:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "hy": "/**\n * Հաշվում է ամբողջ խնձորների քանակը, որոնք մնացել են որոշակի ժամանակ անց, \n * ենթադրելով, որ յուրաքանչյուր խնձոր ուտվում է մեկը մյուսի հետևից և յուրաքանչյուրի ուտելու համար պահանջվում է որոշակի ժամանակ։\n * \n * @param appleCount Սկզբում առկա խնձորների ընդհանուր քանակը։\n * @param timePerApple Ժամանակը րոպեներով, որը պահանջվում է մեկ խնձոր ուտելու համար։\n * @param timePassed Ժամանակը րոպեներով, որը անցել է։\n * @return Մնացած ամբողջ խնձորների քանակը։\n * \n * Օրինակ:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "bn": "/**\n * একটি নির্দিষ্ট সময় অতিবাহিত হওয়ার পরে কতগুলি সম্পূর্ণ আপেল অবশিষ্ট রয়েছে তা গণনা করে,\n * ধরে নেওয়া হয় প্রতিটি আপেল একটির পর একটি খাওয়া হয় এবং প্রতিটি খেতে একটি নির্দিষ্ট সময় লাগে।\n * \n * @param appleCount প্রাথমিকভাবে উপলব্ধ আপেলের মোট সংখ্যা।\n * @param timePerApple একটি আপেল খেতে যে সময় লাগে, তা মিনিটে।\n * @param timePassed যে সময়টি অতিবাহিত হয়েছে, তা মিনিটে।\n * @return অবশিষ্ট সম্পূর্ণ আপেলের সংখ্যা।\n * \n * উদাহরণ:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "bg": "/**\n * Изчислява броя на целите ябълки, останали след като е изминало дадено време,\n * като се предполага, че всяка ябълка се изяжда една след друга и всяка отнема определено време за ядене.\n * \n * @param appleCount Общият брой на ябълките, налични първоначално.\n * @param timePerApple Времето в минути, необходимо за изяждане на една ябълка.\n * @param timePassed Времето в минути, което е изминало.\n * @return Броят на останалите цели ябълки.\n * \n * Пример:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "zh": "/**\n * 计算在给定时间过去后剩余的完整苹果数量，\n * 假设每个苹果一个接一个地被吃掉，并且每个苹果需要一定的时间来吃。\n * \n * @param appleCount 初始可用的苹果总数。\n * @param timePerApple 吃一个苹果所需的时间（分钟）。\n * @param timePassed 已经过的时间（分钟）。\n * @return 剩余的完整苹果数量。\n * \n * 例子:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "fr": "/**\n * Calcule le nombre de pommes entières restantes après qu'un certain temps se soit écoulé,\n * en supposant que chaque pomme est mangée l'une après l'autre et que chacune prend un certain temps à être mangée.\n * \n * @param appleCount Le nombre total de pommes initialement disponibles.\n * @param timePerApple Le temps en minutes qu'il faut pour manger une seule pomme.\n * @param timePassed Le temps en minutes qui s'est écoulé.\n * @return Le nombre de pommes entières restantes.\n * \n * Exemple:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "de": "/**\n * Berechnet die Anzahl der ganzen Äpfel, die nach einer bestimmten Zeit übrig sind,\n * wobei angenommen wird, dass jeder Apfel nacheinander gegessen wird und jeder eine bestimmte Zeit zum Essen benötigt.\n * \n * @param appleCount Die anfängliche Gesamtanzahl der verfügbaren Äpfel.\n * @param timePerApple Die Zeit in Minuten, die benötigt wird, um einen einzelnen Apfel zu essen.\n * @param timePassed Die Zeit in Minuten, die vergangen ist.\n * @return Die Anzahl der verbleibenden ganzen Äpfel.\n * \n * Beispiel:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "ha": "/**\n * Lissafi adadin cikakkun tuffa da suka rage bayan wani lokaci ya wuce,\n * yana ɗauka kowanne tuffa ana cin sa ɗaya bayan ɗaya kuma kowanne yana ɗaukar wani lokaci don ci.\n * \n * @param appleCount Jimlar adadin tuffa da ake da su a farko.\n * @param timePerApple Lokacin a cikin mintuna da ake ɗauka don cin tuffa guda ɗaya.\n * @param timePassed Lokacin a cikin mintuna da ya shige.\n * @return Adadin cikakkun tuffa da suka rage.\n * \n * Misali:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "hi": "/**\n * यह गणना करता है कि दिए गए समय के बाद कितने पूरे सेब बचे हैं,\n * यह मानते हुए कि प्रत्येक सेब एक के बाद एक खाया जाता है और प्रत्येक को खाने में निश्चित समय लगता है।\n * \n * @param appleCount प्रारंभ में उपलब्ध सेबों की कुल संख्या।\n * @param timePerApple एक सेब को खाने में लगने वाला समय (मिनट में)।\n * @param timePassed वह समय (मिनट में) जो बीत चुका है।\n * @return शेष पूरे सेबों की संख्या।\n * \n * उदाहरण:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "hu": "/**\n * Kiszámítja, hogy hány egész alma marad egy adott idő elteltével, \n * feltételezve, hogy minden almát egymás után esznek meg, és mindegyik elfogyasztása bizonyos időt vesz igénybe.\n * \n * @param appleCount Az eredetileg rendelkezésre álló almák teljes száma.\n * @param timePerApple Az idő percekben, amely egyetlen alma elfogyasztásához szükséges.\n * @param timePassed Az eltelt idő percekben.\n * @return A megmaradt egész almák száma.\n * \n * Példa:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9335227813360056",
      "hy": "0.9304080583309976",
      "bn": "0.9238731187949498",
      "bg": "0.9776226985333716",
      "zh": "0.9154448344668774",
      "fr": "0.9779975140623844",
      "de": "0.9251854697224473",
      "ha": "0.9028796751929914",
      "hi": "0.9137147638480635",
      "hu": "0.9263430875831187"
    },
    "canonical_solution": "{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}",
    "instruction": {
      "en": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nПредоставете кратко описание на естествен език (докстринг) на Kotlin кода на български, използвайки не повече от 500 символа.",
      "zh": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int\n{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Kotlin kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9537445459076436",
      "hy": "0.9417669353008588",
      "bn": "0.8688058251087426",
      "bg": "0.9362722230702906",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9010135427631687",
      "hi": "0.8761702451159921",
      "hu": "0.9423679908338704"
    },
    "level": "",
    "test": "fun main() {\n    check(remainingApples(50, 10, 200) == 30) // Test case based on example 1\n    check(remainingApples(5, 5, 3) == 4) // Test case based on example 2\n    check(remainingApples(10, 0, 100) == 0) // Test for edge case where timePerApple is 0\n    check(remainingApples(100, 1, 10000) == 0) // Test for case where all apples can be eaten\n}\n\n\nmain()",
    "entry_point": "remainingApples",
    "signature": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int",
    "docstring": {
      "en": "Calculates the number of whole apples left after a given time has passed, \n  assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n  \n  @param appleCount The total number of apples initially available.\n  @param timePerApple The time in minutes it takes to eat a single apple.\n  @param timePassed The time in minutes that has elapsed.\n  @return The number of whole apples remaining.\n  \n  Example:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "sq": "Llogarit numrin e mollëve të plota të mbetura pasi ka kaluar një kohë e caktuar, \nduke supozuar se secila mollë hahet njëra pas tjetrës dhe secila merr një kohë të caktuar për t'u ngrënë.\n\n@param appleCount Numri total i mollëve fillimisht në dispozicion.\n@param timePerApple Koha në minuta që duhet për të ngrënë një mollë të vetme.\n@param timePassed Koha në minuta që ka kaluar.\n@return Numri i mollëve të plota të mbetura.\n\nShembull:\n>>> remainingApples(50, 10, 200)\n    30\n>>> remainingApples(5, 5, 3)\n    4",
      "hy": "Հաշվում է ամբողջ խնձորների քանակը, որոնք մնացել են որոշակի ժամանակ անց, \nենթադրելով, որ յուրաքանչյուր խնձոր ուտվում է մեկը մյուսի հետևից և յուրաքանչյուրի ուտելը տևում է որոշակի ժամանակ։\n\n@param appleCount Սկզբում առկա խնձորների ընդհանուր քանակը։\n@param timePerApple Ժամանակը րոպեներով, որը պահանջվում է մեկ խնձոր ուտելու համար։\n@param timePassed Ժամանակը րոպեներով, որը անցել է։\n@return Մնացած ամբողջ խնձորների քանակը։\n\nՕրինակ:\n>>> remainingApples(50, 10, 200)\n    30\n>>> remainingApples(5, 5, 3)\n    4",
      "bn": "পুরো আপেলগুলির সংখ্যা গণনা করে যা একটি নির্দিষ্ট সময় পার হওয়ার পরে অবশিষ্ট থাকে, \n  ধরে নিয়ে যে প্রতিটি আপেল একের পর এক খাওয়া হয় এবং প্রতিটি আপেল খেতে নির্দিষ্ট সময় লাগে।\n  \n  @param appleCount প্রাথমিকভাবে উপলব্ধ আপেলগুলির মোট সংখ্যা।\n  @param timePerApple একটি আপেল খেতে যে সময় লাগে তা মিনিটে।\n  @param timePassed যে সময়টি মিনিটে অতিক্রান্ত হয়েছে।\n  @return অবশিষ্ট পুরো আপেলগুলির সংখ্যা।\n  \n  উদাহরণ:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "bg": "Изчислява броя на целите ябълки, останали след изтичането на дадено време, \n  като се предполага, че всяка ябълка се изяжда една след друга и всяка отнема определено време за ядене.\n  \n  @param appleCount Общият брой на ябълките, налични първоначално.\n  @param timePerApple Времето в минути, необходимо за изяждане на една ябълка.\n  @param timePassed Времето в минути, което е изминало.\n  @return Броят на останалите цели ябълки.\n  \n  Пример:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "zh": "计算在给定时间过去后剩余的完整苹果数量，\n假设每个苹果一个接一个地被吃掉，并且每个苹果需要一定的时间来吃。\n\n@param appleCount 初始可用的苹果总数。\n@param timePerApple 吃一个苹果所需的时间（分钟）。\n@param timePassed 已经过的时间（分钟）。\n@return 剩余的完整苹果数量。\n\n示例：\n>>> remainingApples(50, 10, 200)\n    30\n>>> remainingApples(5, 5, 3)\n    4",
      "fr": "Calcule le nombre de pommes entières restantes après qu'un certain temps se soit écoulé, \n  en supposant que chaque pomme est mangée l'une après l'autre et que chacune prend un certain temps à être mangée.\n  \n  @param appleCount Le nombre total de pommes initialement disponibles.\n  @param timePerApple Le temps en minutes qu'il faut pour manger une seule pomme.\n  @param timePassed Le temps en minutes qui s'est écoulé.\n  @return Le nombre de pommes entières restantes.\n  \n  Exemple:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "de": "Berechnet die Anzahl der ganzen Äpfel, die übrig sind, nachdem eine bestimmte Zeit vergangen ist, \n  wobei angenommen wird, dass jeder Apfel nacheinander gegessen wird und jeder eine bestimmte Zeit zum Essen benötigt.\n  \n  @param appleCount Die anfängliche Gesamtanzahl der verfügbaren Äpfel.\n  @param timePerApple Die Zeit in Minuten, die benötigt wird, um einen einzelnen Apfel zu essen.\n  @param timePassed Die Zeit in Minuten, die vergangen ist.\n  @return Die Anzahl der verbleibenden ganzen Äpfel.\n  \n  Beispiel:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "ha": "Yana ƙididdige adadin cikakkun tuffa da suka rage bayan wani lokaci ya wuce, \n  yana ɗauka kowanne tuffa ana ci ɗaya bayan ɗaya kuma kowanne yana ɗaukar wani lokaci don ci.\n\n  @param appleCount Jimlar adadin tuffa da ake da su a farko.\n  @param timePerApple Lokacin a mintuna da ake ɗauka don cin tuffa guda.\n  @param timePassed Lokacin a mintuna da ya wuce.\n  @return Adadin tuffa cikakku da suka rage.\n\n  Misali:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "hi": "समय बीत जाने के बाद बचे हुए पूरे सेबों की संख्या की गणना करता है, \n  यह मानते हुए कि प्रत्येक सेब एक के बाद एक खाया जाता है और प्रत्येक को खाने में एक निश्चित समय लगता है।\n\n  @param appleCount प्रारंभ में उपलब्ध सेबों की कुल संख्या।\n  @param timePerApple एक सेब को खाने में लगने वाला समय (मिनटों में)।\n  @param timePassed वह समय (मिनटों में) जो बीत चुका है।\n  @return शेष पूरे सेबों की संख्या।\n\n  उदाहरण:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "hu": "Számítja ki a megmaradt egész almák számát egy adott idő elteltével, \n  feltételezve, hogy minden almát egymás után esznek meg, és mindegyik elfogyasztása bizonyos időt vesz igénybe.\n  \n  @param appleCount Az eredetileg rendelkezésre álló almák teljes száma.\n  @param timePerApple Az idő percben, amely egyetlen alma elfogyasztásához szükséges.\n  @param timePassed Az eltelt idő percben.\n  @return A megmaradt egész almák száma.\n  \n  Példa:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4"
    },
    "docstring_bertscore": {
      "sq": "0.9731358368561744",
      "hy": "0.9725907950906147",
      "bn": "0.9611552467936741",
      "bg": "0.9745981537213533",
      "zh": "0.9522258180142508",
      "fr": "0.984115131167878",
      "de": "0.9669778977833309",
      "ha": "0.9550378283185617",
      "hi": "0.9421477097413026",
      "hu": "0.9658872183610683"
    }
  },
  {
    "task_id": "Kotlin/49",
    "prompt": {
      "en": "/**\n * Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n * IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n * \n * Example:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Note:\n * - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n * - The discontinuous ID cannot be the minimum or maximum of the entire ID set.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "sq": "/**\n * Gjen numrat e ID-ve që mungojnë (jokontinuues) dhe ato të dyfishuara nga një listë listash të numrave të ID-ve.\n * ID-të priten të jenë të vazhdueshme, por për shkak të një gabimi, një mungon dhe një tjetër është i dyfishuar.\n * \n * Shembull:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Shënim:\n * - Funksioni supozon që numrat e ID-ve janë numra të plotë pozitivë dhe lista përmban të paktën një ID të dyfishuar dhe një që mungon.\n * - ID-ja jokontinuese nuk mund të jetë minimumi ose maksimumi i të gjithë grupit të ID-ve.\n */",
      "hy": "/**\n * Գտնում է բացակայող (ընդհատվող) և կրկնվող ID համարները ID համարների ցուցակների ցուցակից:\n * ID-ները սպասվում է, որ լինեն շարունակական, բայց սխալի պատճառով մեկը բացակայում է, իսկ մյուսը կրկնվում է:\n * \n * Օրինակ:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Նշում:\n * - Ֆունկցիան ենթադրում է, որ ID համարները դրական ամբողջ թվեր են, և ցուցակը պարունակում է առնվազն մեկ կրկնվող և մեկ բացակայող ID:\n * - Ընդհատվող ID-ն չի կարող լինել ամբողջ ID հավաքածուի նվազագույնը կամ առավելագույնը:\n */",
      "bn": "/**\n * একটি তালিকার তালিকা থেকে অনুপস্থিত (অবিচ্ছিন্ন) এবং সদৃশ আইডি নম্বরগুলি খুঁজে বের করে।\n * আইডিগুলি ধারাবাহিক হওয়ার কথা, কিন্তু একটি ত্রুটির কারণে একটি অনুপস্থিত এবং অন্যটি সদৃশ।\n * \n * উদাহরণ:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * নোট:\n * - ফাংশনটি ধরে নেয় যে আইডি নম্বরগুলি ধনাত্মক পূর্ণসংখ্যা এবং তালিকায় অন্তত একটি সদৃশ এবং একটি অনুপস্থিত আইডি রয়েছে।\n * - অবিচ্ছিন্ন আইডি পুরো আইডি সেটের সর্বনিম্ন বা সর্বাধিক হতে পারে না।\n */",
      "bg": "/**\n * Намира липсващите (несвързани) и дублирани ID номера от списък със списъци от ID номера.\n * Очаква се ID-тата да са свързани, но поради грешка едно липсва, а друго е дублирано.\n * \n * Пример:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Забележка:\n * - Функцията предполага, че ID номерата са положителни цели числа и списъкът съдържа поне едно дублирано и едно липсващо ID.\n * - Несвързаното ID не може да бъде минималното или максималното от целия набор от ID-та.\n */",
      "zh": "/**\n * 查找ID号列表中的缺失（不连续）和重复ID号。\n * ID预计是连续的，但由于错误，一个ID缺失，另一个ID重复。\n * \n * 示例:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * 注意:\n * - 函数假设ID号是正整数，并且列表中至少包含一个重复和一个缺失的ID。\n * - 不连续的ID不能是整个ID集合的最小值或最大值。\n */",
      "fr": "/**\n * Trouve les numéros d'identification manquants (discontinus) et en double à partir d'une liste de listes de numéros d'identification.\n * Les ID sont supposés être continus mais en raison d'une erreur, un est manquant et un autre est dupliqué.\n * \n * Exemple :\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Remarque :\n * - La fonction suppose que les numéros d'identification sont des entiers positifs et que la liste contient au moins un doublon et un ID manquant.\n * - L'ID discontinu ne peut pas être le minimum ou le maximum de l'ensemble entier des ID.\n */",
      "de": "/**\n * Findet die fehlenden (diskontinuierlichen) und doppelten ID-Nummern aus einer Liste von Listen von ID-Nummern.\n * Es wird erwartet, dass die IDs kontinuierlich sind, aber aufgrund eines Fehlers fehlt eine und eine andere ist dupliziert.\n * \n * Beispiel:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Hinweis:\n * - Die Funktion nimmt an, dass ID-Nummern positive ganze Zahlen sind und die Liste mindestens eine doppelte und eine fehlende ID enthält.\n * - Die diskontinuierliche ID kann nicht das Minimum oder Maximum des gesamten ID-Sets sein.\n */",
      "ha": "/**\n * Nemi ID lambobin da suka ɓace (wanda ba su ci gaba ba) da kuma lambobin ID masu maimaitawa daga jerin jerin lambobin ID.\n * Ana sa ran ID za su kasance masu ci gaba amma saboda kuskure, ɗaya ya ɓace kuma wani ya maimaita.\n * \n * Misali:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Lura:\n * - Aikin yana ɗauka cewa lambobin ID lambobi ne masu kyau kuma jerin yana ƙunshe da aƙalla ɗaya mai maimaitawa da ɗaya mai ɓacewa.\n * - ID wanda ba ya ci gaba ba zai iya zama mafi ƙaranci ko mafi girma na dukkan saitin ID ba.\n */",
      "hi": "/**\n * सूची की सूचियों से गायब (अविरल) और डुप्लिकेट आईडी नंबर खोजता है।\n * आईडी निरंतर होने की उम्मीद है लेकिन एक त्रुटि के कारण, एक गायब है और दूसरा डुप्लिकेट है।\n * \n * उदाहरण:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * नोट:\n * - फ़ंक्शन मानता है कि आईडी नंबर सकारात्मक पूर्णांक हैं और सूची में कम से कम एक डुप्लिकेट और एक गायब आईडी है।\n * - अविरल आईडी पूरे आईडी सेट का न्यूनतम या अधिकतम नहीं हो सकता।\n */",
      "hu": "/**\n * Megkeresi a hiányzó (nem folytonos) és duplikált azonosító számokat az azonosító számok listáinak listájából.\n * Az azonosítók várhatóan folytonosak, de egy hiba miatt egy hiányzik, és egy másik duplikált.\n * \n * Példa:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Megjegyzés:\n * - A függvény feltételezi, hogy az azonosító számok pozitív egész számok, és a lista tartalmaz legalább egy duplikált és egy hiányzó azonosítót.\n * - A nem folytonos azonosító nem lehet az egész azonosító halmaz minimuma vagy maximuma.\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9253102096017372",
      "hy": "0.9180943651195018",
      "bn": "0.9180252417469017",
      "bg": "0.9157580745777695",
      "zh": "0.9196075313622256",
      "fr": "0.9378449784273248",
      "de": "0.9436322732091573",
      "ha": "0.8951821520367464",
      "hi": "0.918329146229885",
      "hu": "0.9041999713357303"
    },
    "canonical_solution": "{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}",
    "instruction": {
      "en": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, সর্বাধিক ৫০০ অক্ষরের মধ্যে।",
      "bg": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Kotlin a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nकृपया निम्नलिखित Kotlin कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>\n{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9543706288686655",
      "hy": "0.9244352427732785",
      "bn": "0.8870605530169919",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9250790038382126",
      "hi": "0.8742320098578537",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9))) == Pair(7, 9))\n    // Add more tests to ensure robustness\n    check(findMissingAndDuplicateIds(listOf(listOf(1, 2, 4,7), listOf(3, 5, 5))) == Pair(6, 5))\n    check(findMissingAndDuplicateIds(listOf(listOf(10, 11,17, 12, 14), listOf(13, 15, 12))) == Pair(16, 12))\n}\n\n\nmain()",
    "entry_point": "findMissingAndDuplicateIds",
    "signature": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>",
    "docstring": {
      "en": "Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n  IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n  \n  Example:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Note:\n  - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n  - The discontinuous ID cannot be the minimum or maximum of the entire ID set.",
      "sq": "Gjen ID-të e humbura (të ndërprera) dhe të dyfishuara nga një listë listash të numrave ID.\n  ID-të priten të jenë të vazhdueshme, por për shkak të një gabimi, një mungon dhe një tjetër është i dyfishuar.\n  \n  Shembull:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Shënim:\n  - Funksioni supozon që numrat ID janë numra të plotë pozitivë dhe lista përmban të paktën një ID të dyfishuar dhe një ID të humbur.\n  - ID-ja e ndërprerë nuk mund të jetë minimumi ose maksimumi i të gjithë grupit të ID-ve.",
      "hy": "Գտնում է բացակայող (ընդհատվող) և կրկնվող ID համարները ID համարների ցուցակների ցուցակից:\n  ID-ները սպասվում է, որ կլինեն շարունակական, բայց սխալի պատճառով մեկը բացակայում է, իսկ մյուսը կրկնվում է:\n  \n  Օրինակ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Նշում:\n  - Ֆունկցիան ենթադրում է, որ ID համարները դրական ամբողջ թվեր են, և ցուցակը պարունակում է առնվազն մեկ կրկնվող և մեկ բացակայող ID:\n  - Ընդհատվող ID-ն չի կարող լինել ամբողջ ID հավաքածուի նվազագույնը կամ առավելագույնը:",
      "bn": "অনুপস্থিত (অবিচ্ছিন্ন) এবং সদৃশ আইডি নম্বরগুলি একটি আইডি নম্বরের তালিকার তালিকা থেকে খুঁজে বের করে।\n  আইডিগুলি অবিচ্ছিন্ন হওয়ার কথা, কিন্তু একটি ত্রুটির কারণে একটি অনুপস্থিত এবং অন্যটি সদৃশ হয়েছে।\n  \n  উদাহরণ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  নোট:\n  - ফাংশনটি ধরে নেয় যে আইডি নম্বরগুলি ধনাত্মক পূর্ণসংখ্যা এবং তালিকায় অন্তত একটি সদৃশ এবং একটি অনুপস্থিত আইডি রয়েছে।\n  - অবিচ্ছিন্ন আইডিটি সম্পূর্ণ আইডি সেটের সর্বনিম্ন বা সর্বাধিক হতে পারে না।",
      "bg": "Намира липсващите (несвързани) и дублирани ID номера от списък със списъци от ID номера.\n  Очаква се ID-тата да са свързани, но поради грешка едно липсва, а друго е дублирано.\n  \n  Пример:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Забележка:\n  - Функцията предполага, че ID номерата са положителни цели числа и списъкът съдържа поне един дубликат и едно липсващо ID.\n  - Несвързаното ID не може да бъде минималното или максималното от целия набор от ID-та.",
      "zh": "查找列表中的缺失（不连续）和重复的ID号。\n  ID号预计是连续的，但由于错误，一个ID号缺失，另一个ID号重复。\n  \n  示例：\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  注意：\n  - 该函数假设ID号是正整数，并且列表中至少包含一个重复和一个缺失的ID。\n  - 不连续的ID不能是整个ID集合的最小值或最大值。",
      "fr": "Trouve les numéros d'identification manquants (discontinus) et en double à partir d'une liste de listes de numéros d'identification.\n  Les ID sont censés être continus mais en raison d'une erreur, l'un est manquant et un autre est dupliqué.\n  \n  Exemple:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Remarque:\n  - La fonction suppose que les numéros d'identification sont des entiers positifs et que la liste contient au moins un doublon et un ID manquant.\n  - L'ID discontinu ne peut pas être le minimum ou le maximum de l'ensemble entier des ID.",
      "de": "Findet die fehlenden (diskontinuierlichen) und doppelten ID-Nummern aus einer Liste von Listen von ID-Nummern.\n  IDs sollten kontinuierlich sein, aber aufgrund eines Fehlers fehlt eine und eine andere ist dupliziert.\n  \n  Beispiel:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Hinweis:\n  - Die Funktion nimmt an, dass ID-Nummern positive ganze Zahlen sind und die Liste mindestens eine doppelte und eine fehlende ID enthält.\n  - Die diskontinuierliche ID kann nicht das Minimum oder Maximum des gesamten ID-Sets sein.",
      "ha": "Nemo lambobin ID da suka ɓace (wanda ba su ci gaba ba) da kuma lambobin ID masu maimaitawa daga jerin jerin lambobin ID.\n  Ana sa ran ID za su ci gaba amma saboda kuskure, ɗaya ya ɓace kuma wani ya maimaita.\n  \n  Misali:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Lura:\n  - Aikin yana ɗauka cewa lambobin ID lambobi ne masu kyau kuma jerin yana ɗauke da aƙalla ɗaya mai maimaitawa da ɗaya da ya ɓace.\n  - ID da ba su ci gaba ba ba zai iya zama mafi ƙaranci ko mafi girma na duk saitin ID ba.",
      "hi": "ID नंबरों की सूचियों की सूची से गायब (असतत) और डुप्लिकेट ID नंबरों को ढूँढता है।\n  IDs को निरंतर होने की उम्मीद है लेकिन एक त्रुटि के कारण, एक गायब है और दूसरा डुप्लिकेट है।\n\n  उदाहरण:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n\n  नोट:\n  - फ़ंक्शन मानता है कि ID नंबर सकारात्मक पूर्णांक हैं और सूची में कम से कम एक डुप्लिकेट और एक गायब ID है।\n  - असतत ID पूरे ID सेट का न्यूनतम या अधिकतम नहीं हो सकता।",
      "hu": "Megkeresi a hiányzó (folytonosság nélküli) és duplikált azonosító számokat az azonosító számok listáinak listájából.\nAz azonosítók várhatóan folyamatosak, de egy hiba miatt egy hiányzik és egy másik duplikált.\n\nPélda:\n>>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n    Pair(7, 9)\n\nMegjegyzés:\n- A függvény feltételezi, hogy az azonosító számok pozitív egész számok, és a lista legalább egy duplikált és egy hiányzó azonosítót tartalmaz.\n- A folytonosság nélküli azonosító nem lehet az egész azonosító halmaz minimuma vagy maximuma."
    },
    "docstring_bertscore": {
      "sq": "0.9528981818540538",
      "hy": "0.9552759861454225",
      "bn": "0.9576094958618204",
      "bg": "0.9475115245507687",
      "zh": "0.9433595536959964",
      "fr": "0.9752895860777357",
      "de": "0.984542782378246",
      "ha": "0.9208664507172247",
      "hi": "0.9721728767689174",
      "hu": "0.9375188273416656"
    }
  },
  {
    "task_id": "Kotlin/50",
    "prompt": {
      "en": "/**\n * Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n * \n * @param s The input string of length 8.\n * @return A Triple of integers where the first element is the count of digits,\n * the second element is the count of lowercase letters, and the third element\n * is the count of uppercase letters in the string.\n * \n * Example:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "sq": "/**\n * Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n * \n * @param s Vargu hyrës me gjatësi 8.\n * @return Një Triple e numrave të plotë ku elementi i parë është numri i shifrave,\n * elementi i dytë është numri i shkronjave të vogla, dhe elementi i tretë\n * është numri i shkronjave të mëdha në varg.\n * \n * Shembull:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "hy": "/**\n * Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում։\n * \n * @param s Մուտքային տողը 8 երկարությամբ։\n * @return Երեք ամբողջ թվերի Triple, որտեղ առաջին տարրը թվանշանների քանակն է,\n * երկրորդ տարրը փոքրատառերի քանակն է, և երրորդ տարրը մեծատառերի քանակն է տողում։\n * \n * Օրինակ:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "bn": "/**\n * একটি প্রদত্ত ৮ অক্ষরের দৈর্ঘ্যের স্ট্রিং-এ সংখ্যা, ছোট হাতের অক্ষর এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n * \n * @param s ৮ অক্ষরের দৈর্ঘ্যের ইনপুট স্ট্রিং।\n * @return একটি তিনটি পূর্ণসংখ্যার Triple যেখানে প্রথম উপাদানটি সংখ্যার সংখ্যা,\n * দ্বিতীয় উপাদানটি ছোট হাতের অক্ষরের সংখ্যা, এবং তৃতীয় উপাদানটি\n * স্ট্রিং-এ বড় হাতের অক্ষরের সংখ্যা।\n * \n * উদাহরণ:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "bg": "/**\n * Брои броя на цифрите, малките букви и главните букви в даден низ с дължина 8.\n * \n * @param s Входният низ с дължина 8.\n * @return Тройка от цели числа, където първият елемент е броят на цифрите,\n * вторият елемент е броят на малките букви, а третият елемент\n * е броят на главните букви в низа.\n * \n * Пример:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "zh": "/**\n * 计算给定长度为8的字符串中的数字、小写字母和大写字母的数量。\n * \n * @param s 长度为8的输入字符串。\n * @return 一个整数的Triple，其中第一个元素是数字的数量，\n * 第二个元素是小写字母的数量，第三个元素是字符串中大写字母的数量。\n * \n * 示例:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */ \nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "fr": "/**\n * Compte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n * \n * @param s La chaîne d'entrée de longueur 8.\n * @return Un Triple d'entiers où le premier élément est le compte des chiffres,\n * le deuxième élément est le compte des lettres minuscules, et le troisième élément\n * est le compte des lettres majuscules dans la chaîne.\n * \n * Exemple:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "de": "/**\n * Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n * \n * @param s Der Eingabestring der Länge 8.\n * @return Ein Triple von Ganzzahlen, wobei das erste Element die Anzahl der Ziffern ist,\n * das zweite Element die Anzahl der Kleinbuchstaben und das dritte Element\n * die Anzahl der Großbuchstaben im String.\n * \n * Beispiel:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "ha": "/**\n * Yana ƙidaya adadin lambobi, haruffan ƙaramin baƙi, da haruffan babban baƙi a cikin wata takamaiman ƙirtani mai tsawon haruffa 8.\n * \n * @param s Ƙirtanin shigarwa mai tsawon haruffa 8.\n * @return Triple na lambobi inda na farko shine adadin lambobi,\n * na biyu shine adadin haruffan ƙaramin baƙi, kuma na uku shine adadin haruffan babban baƙi a cikin ƙirtanin.\n * \n * Misali:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */ \nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "hi": "/**\n * एक दिए गए 8 लंबाई के स्ट्रिंग में अंकों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है।\n * \n * @param s इनपुट स्ट्रिंग जिसकी लंबाई 8 है।\n * @return तीन पूर्णांकों का एक ट्रिपल जहां पहला तत्व अंकों की गिनती है,\n * दूसरा तत्व छोटे अक्षरों की गिनती है, और तीसरा तत्व\n * स्ट्रिंग में बड़े अक्षरों की गिनती है।\n * \n * उदाहरण:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "hu": "/**\n * Megszámolja a számjegyek, kisbetűk és nagybetűk számát egy adott, 8 karakter hosszú sztringben.\n * \n * @param s A bemeneti sztring, amely 8 karakter hosszú.\n * @return Egy három egész számot tartalmazó Triple, ahol az első elem a számjegyek száma,\n * a második elem a kisbetűk száma, a harmadik elem pedig a nagybetűk száma a sztringben.\n * \n * Példa:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "sq": "0.9840336927116536",
      "hy": "0.9521122014362988",
      "bn": "0.9518216051888447",
      "bg": "0.9872801076592879",
      "zh": "0.9756145453811088",
      "fr": "0.9706807653465832",
      "de": "0.9872801076592879",
      "ha": "0.9597455669794696",
      "hi": "0.9502556032647657",
      "hu": "0.9541209504797046"
    },
    "canonical_solution": "{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}",
    "instruction": {
      "en": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nProvide a concise natural language description (docstring) of the Kotlin code in English using at most 500 characters.",
      "sq": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Kotlin në shqip duke përdorur jo më shumë se 500 karaktere.",
      "hy": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Kotlin կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nনিচের Kotlin কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nПредоставете кратко описание на Kotlin кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\n请用不超过500个字符的中文，为以下Kotlin代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Kotlin en français en utilisant au maximum 500 caractères.",
      "de": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Kotlin-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nBayar da taƙaitaccen bayanin harshen halitta (docstring) na lambar Kotlin cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nकोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fun countCharacters(s: String): Triple<Int, Int, Int>\n{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Kotlin kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9403179266712092",
      "hy": "0.9417669353008588",
      "bn": "0.8777010894626279",
      "bg": "0.8383597137705134",
      "zh": "0.8774533973774774",
      "fr": "0.9695779694710775",
      "de": "0.9221452331103273",
      "ha": "0.9578788386585037",
      "hi": "0.8761702451159921",
      "hu": "0.9542756835465308"
    },
    "level": "",
    "test": "fun main() {\n    check(countCharacters(\"yLOI2022\") == Triple(4, 1, 3))\n    check(countCharacters(\"IAKIOIOI\") == Triple(0, 0, 8))\n    check(countCharacters(\"1n2s0e1s\") == Triple(4, 4, 0))\n}\n\n\nmain()",
    "entry_point": "countCharacters",
    "signature": "fun countCharacters(s: String): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  @param s The input string of length 8.\n  @return A Triple of integers where the first element is the count of digits,\n  the second element is the count of lowercase letters, and the third element\n  is the count of uppercase letters in the string.\n  \n  Example:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "sq": "Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n\n@param s Vargu hyrës me gjatësi 8.\n@return Një Tresh i numrave të plotë ku elementi i parë është numri i shifrave,\nelementi i dytë është numri i shkronjave të vogla, dhe elementi i tretë\nështë numri i shkronjave të mëdha në varg.\n\nShembull:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "hy": "Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում։\n  \n  @param s Մուտքային տողը 8 երկարությամբ։\n  @return Երեք թվերի տիպ, որտեղ առաջին տարրը թվանշանների քանակն է,\n  երկրորդ տարրը փոքրատառերի քանակն է, և երրորդ տարրը մեծատառերի քանակն է տողում։\n  \n  Օրինակ:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "bn": "একটি প্রদত্ত দৈর্ঘ্য 8 এর স্ট্রিং-এ সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর গণনা করে।\n\n@param s দৈর্ঘ্য 8 এর ইনপুট স্ট্রিং।\n@return পূর্ণসংখ্যার একটি Triple যেখানে প্রথম উপাদানটি সংখ্যা গণনা, দ্বিতীয় উপাদানটি ছোট হাতের অক্ষর গণনা, এবং তৃতীয় উপাদানটি বড় হাতের অক্ষর গণনা করে স্ট্রিং এ।\n\nউদাহরণ:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "bg": "Брои броя на цифрите, малките букви и главните букви в даден низ с дължина 8.\n  \n  @param s Входният низ с дължина 8.\n  @return Тройка от цели числа, където първият елемент е броят на цифрите,\n  вторият елемент е броят на малките букви, а третият елемент\n  е броят на главните букви в низа.\n  \n  Пример:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "zh": "计算给定长度为8的字符串中的数字、小写字母和大写字母的数量。\n\n@param s 长度为8的输入字符串。\n@return 一个整数三元组，其中第一个元素是数字的数量，第二个元素是小写字母的数量，第三个元素是字符串中大写字母的数量。\n\n示例：\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "fr": "Compte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n  \n  @param s La chaîne d'entrée de longueur 8.\n  @return Un Triple d'entiers où le premier élément est le compte des chiffres,\n  le deuxième élément est le compte des lettres minuscules, et le troisième élément\n  est le compte des lettres majuscules dans la chaîne.\n  \n  Exemple:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "de": "Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n  \n  @param s Der Eingabestring der Länge 8.\n  @return Ein Triple von ganzen Zahlen, wobei das erste Element die Anzahl der Ziffern ist,\n  das zweite Element die Anzahl der Kleinbuchstaben und das dritte Element\n  die Anzahl der Großbuchstaben im String.\n  \n  Beispiel:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "ha": "Ya ƙididdige adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani baƙaƙen rubutu mai tsawon haruffa 8.\n\n  @param s Baƙaƙen rubutu na shigarwa mai tsawon haruffa 8.\n  @return Triple na lambobi inda na farko shine adadin lambobi,\n  na biyu shine adadin ƙananan haruffa, kuma na uku shine adadin manyan haruffa a cikin baƙaƙen rubutu.\n\nMisali:  \n>>> countCharacters(\"yLOI2022\")  \nTriple(4, 1, 3)  \n>>> countCharacters(\"IAKIOIOI\")  \nTriple(0, 0, 8)  \n>>> countCharacters(\"1n2s0e1s\")  \nTriple(4, 4, 0)",
      "hi": "एक दिए गए 8 अक्षरों की लंबाई वाले स्ट्रिंग में अंकों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है।\n\n@param s लंबाई 8 की इनपुट स्ट्रिंग।\n@return पूर्णांकों का एक Triple जहाँ पहला तत्व अंकों की गिनती है, दूसरा तत्व छोटे अक्षरों की गिनती है, और तीसरा तत्व बड़े अक्षरों की गिनती है।\n\nउदाहरण:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "hu": "Számolja meg a számjegyek, kisbetűk és nagybetűk számát egy adott, 8 karakter hosszú sztringben.\n\n@param s A bemeneti sztring, amely 8 karakter hosszú.\n@return Egy három egész számot tartalmazó Triple, ahol az első elem a számjegyek száma,\na második elem a kisbetűk száma, és a harmadik elem a nagybetűk száma a sztringben.\n\nPélda:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9798223313729519",
      "hy": "0.969341202056884",
      "bn": "0.930712161444362",
      "bg": "0.9871194156810306",
      "zh": "0.9703836142965551",
      "fr": "0.995251343480599",
      "de": "0.9834556783028421",
      "ha": "0.9677434192718394",
      "hi": "0.978638692932365",
      "hu": "0.9504274185443609"
    }
  }
]