[
  {
    "task_id": "Rust/1",
    "prompt": {
      "en": " /*\n  Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n ",
      "sq": " /*\n  Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n  pragu i dhënë.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "hy": " /*\n  Ստուգել, արդյոք տրված թվերի ցուցակում կան որևէ երկու թիվ, որոնք միմյանց ավելի մոտ են, քան տրված շեմը:\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "bn": " /*\n  প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি নির্দিষ্ট সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "bg": " /*\n  Проверете дали в даден списък от числа има две числа, които са по-близо едно до друго от\n  даден праг.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "zh": " /*\n  检查在给定的数字列表中，是否存在任意两个数字之间的距离小于给定的阈值。\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "fr": " /*\n  Vérifiez si, dans une liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "de": " /*\n  Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der\n  angegebene Schwellenwert.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "ha": " /*\n  Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da suka fi kusa da juna fiye da \n  ƙayyadadden tazara.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "hi": " /*\n  जाँचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n",
      "hu": " /*\n  Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n"
    },
    "prompt_bertscore": {
      "sq": "0.9851049063565748",
      "hy": "0.974613448260693",
      "bn": "0.9526113595838395",
      "bg": "0.9738344199062742",
      "zh": "0.9449235693162652",
      "fr": "0.9744754001458737",
      "de": "0.9746843593067225",
      "ha": "0.9613089867085952",
      "hi": "0.9834181371608265",
      "hu": "0.962987810689102"
    },
    "canonical_solution": "\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n ",
    "instruction": {
      "en": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nরাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\n请用最多500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nBa da takaitaccen bayanin yanayin aiki (docstring) na lambar Rust cikin harshen Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{\n\n  for i in 0..numbers.len(){\n  for j in 1..numbers.len(){\n \n  if i != j {\n  let distance:f32 = numbers[i] - numbers[j];\n \n  if distance.abs() < threshold{\n  return true;\n  }\n \n  }\n  \n  }\n  }\n \n  return false;\n \n }\n \n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9423368058640478",
      "bn": "0.8853060508613108",
      "bg": "0.8316696904400789",
      "zh": "0.856169158897684",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.8782228914736067",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_has_close_elements() {\n  assert_eq!(has_close_elements(vec![11.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.95), true);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 5.9, 4.0, 5.0], 0.8), false);\n  assert_eq!(has_close_elements(vec![1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 1.0), true);\n  assert_eq!(has_close_elements(vec![1.1, 2.2, 3.1, 4.1, 5.1], 0.5), false);\n  }\n \n }\n ",
    "entry_point": "has_close_elements",
    "signature": "fn has_close_elements(numbers:Vec<f32>, threshold: f32) -> bool{",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\n  given threshold.",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se sa pragu i dhënë.",
      "hy": "Ստուգեք, արդյոք տրված թվերի ցանկում որևէ երկու թիվ միմյանց ավելի մոտ են, քան տրված շեմը:",
      "bn": "দেওয়া সংখ্যার তালিকায়, কোনও দুটি সংখ্যা কি দেওয়া থ্রেশহোল্ডের চেয়ে একে অপরের কাছাকাছি আছে কিনা তা পরীক্ষা করুন।",
      "bg": "Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от даден праг.",
      "zh": "检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。",
      "fr": "Vérifiez si, dans la liste donnée de nombres, deux nombres sont plus proches l'un de l'autre que le seuil donné.",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.",
      "ha": "Duba idan a cikin jerin lambobin da aka bayar, akwai kowanne lambobi biyu da suka fi kusa da juna fiye da ƙayyadadden ƙimar da aka bayar.",
      "hi": "दिए गए संख्याओं की सूची में जाँच करें कि क्या कोई दो संख्याएँ एक-दूसरे के अधिक निकट हैं दिए गए सीमा से।",
      "hu": "Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték."
    },
    "docstring_bertscore": {
      "sq": "0.9577258932651068",
      "hy": "0.8972622093869438",
      "bn": "0.8972622093869438",
      "bg": "0.9004686996279899",
      "zh": "0.8121353856172028",
      "fr": "0.9286404465701681",
      "de": "0.8859118735234671",
      "ha": "0.8979474842015142",
      "hi": "0.8826741983125984",
      "hu": "0.8951440150035876"
    }
  },
  {
    "task_id": "Rust/2",
    "prompt": {
      "en": " /*\n  Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n ",
      "sq": " /*\n  Hyrja për këtë funksion është një varg që përmban grupe të shumta të kllapave të folezuara. Qëllimi juaj është të\n  ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n  Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur si duhet) dhe nuk janë të folezuara brenda njëra-tjetrës.\n  Injoroni çdo hapësirë në vargun e hyrjes.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "hy": " /*\n  Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի բազմակի խմբեր։ Ձեր նպատակը\n  այդ խմբերը առանձին տողերի բաժանելն է և վերադարձնել դրանց ցուցակը։\n  Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակված է) և մեկը մյուսի մեջ չեն ներդրված։\n  Անտեսեք մուտքային տողի ցանկացած բացատ։\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "bn": " /*\n  এই ফাংশনের ইনপুট একটি স্ট্রিং যা একাধিক গোষ্ঠীর নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল\n  সেই গোষ্ঠীগুলিকে পৃথক স্ট্রিংয়ে বিভক্ত করা এবং সেইগুলির তালিকা ফেরত দেওয়া।\n  পৃথক গোষ্ঠীগুলি সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়।\n  ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "bg": " /*\n  Входът за тази функция е низ, съдържащ множество групи от вложени скоби. Вашата цел е да\n  разделите тези групи на отделни низове и да върнете списък с тях.\n  Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n  Игнорирайте всички интервали в низа на входа.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "zh": " /*\n  此函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成单独的字符串，并返回这些字符串的列表。\n  分离的组是平衡的（每个开括号都有正确的闭合）且不相互嵌套。\n  忽略输入字符串中的任何空格。\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "fr": " /*\n  L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n  séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n  Les groupes séparés sont équilibrés (chaque accolade ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n  Ignorez tous les espaces dans la chaîne d'entrée.\n \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "de": " /*\n  Die Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n  diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n  Separate Gruppen sind ausgeglichen (jede öffnende Klammer ist korrekt geschlossen) und nicht ineinander verschachtelt.\n  Ignorieren Sie alle Leerzeichen im Eingabestring.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "ha": " /*\n  Shigar da wannan aikin shine wani igiya da ke dauke da kungiyoyi da dama na maƙarƙashiya na baka. Manufarka ita ce\n  raba waɗannan kungiyoyin zuwa igiyoyi daban-daban kuma dawo da jerin waɗannan.\n  Kungiyoyi daban-daban suna daidaitawa (kowanne buɗe baka yana da rufewa daidai) kuma ba a maƙale cikin juna ba\n  Yi watsi da duk wani sarari a cikin igiyar shigarwa.\n\n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{",
      "hi": " /*\n  इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है कि\n  उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करें और उन स्ट्रिंग्स की सूची लौटाएं।\n  अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n  इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n",
      "hu": " /*\n  Ennek a függvénynek a bemenete egy olyan karakterlánc, amely több csoportba rendezett, egymásba ágyazott zárójelet tartalmaz. A célod az,\n  hogy ezeket a csoportokat külön karakterláncokra bontsd, és ezek listáját add vissza.\n  A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően van lezárva), és nincsenek egymásba ágyazva.\n  Hagyd figyelmen kívül a bemeneti karakterláncban található szóközöket.\n \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn separate_paren_groups(paren_string: String) -> Vec<String>{\n"
    },
    "prompt_bertscore": {
      "sq": "0.9616992954073287",
      "hy": "0.9557995758298304",
      "bn": "0.9514398375964958",
      "bg": "0.9501513223147224",
      "zh": "0.944871528156434",
      "fr": "0.9629321941824123",
      "de": "0.9550872872834394",
      "ha": "0.9286237616181612",
      "hi": "0.9512898716588144",
      "hu": "0.9415814145249721"
    },
    "canonical_solution": "\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n ",
    "instruction": {
      "en": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки най-много 500 символа.",
      "zh": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn separate_paren_groups(paren_string: String) -> Vec<String>{\n\n  let mut result:Vec<String> = vec![];\n  let mut current_string:String = String::new();\n  let mut current_depth:u32 = 0;\n \n  for c in paren_string.chars(){\n  if c == '('{\n  current_depth += 1;\n  current_string.push(c);\n  }\n  else if c == ')' {\n  current_depth -= 1;\n  current_string.push(c);\n \n  if current_depth == 0{\n  result.push(current_string.clone());\n  current_string.clear()\n  }\n  \n  }\n \n \n  }\n  return result;\n }\n \n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9258661760382538",
      "bn": "0.8772950889637926",
      "bg": "0.8510137073579235",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9665526301375352",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_separate_paren_groups() {\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()()) ((())) () ((())()())\")),\n  vec![\"(()())\", \"((()))\", \"()\", \"((())()())\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"() (()) ((())) (((())))\")),\n  vec![\"()\", \"(())\", \"((()))\", \"(((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"(()(())((())))\")),\n  vec![\"(()(())((())))\"]\n  );\n  assert_eq!(\n  separate_paren_groups(String::from(\"( ) (( )) (( )( ))\")),\n  vec![\"()\", \"(())\", \"(()())\"]\n  );\n  }\n \n }\n ",
    "entry_point": "separate_paren_groups",
    "signature": "fn separate_paren_groups(paren_string: String) -> Vec<String>{",
    "docstring": {
      "en": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n  separate those group into separate strings and return the list of those.\n  Separate groups are balanced (each open brace is properly closed) and not nested within each other\n  Ignore any spaces in the input string.",
      "sq": "Inputi për këtë funksion është një varg që përmban grupe të shumta të kllapave të folezuara. Qëllimi juaj është të ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre. Grupet e veçanta janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të folezuara brenda njëra-tjetrës. Injoroni çdo hapësirë në vargun hyrës.",
      "hy": "Մուտք այս ֆունկցիայի համար տող է, որը պարունակում է մի քանի խմբեր ներդրված փակագծերով: Ձեր նպատակն է\n  այդ խմբերը բաժանել առանձին տողերի և վերադարձնել դրանց ցանկը:\n  Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակված է) և միմյանց մեջ չեն ներդրված:\n  Անտեսեք մուտքային տողի մեջ եղած ցանկացած բացատներ:",
      "bn": "এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গোষ্ঠী নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল সেই গোষ্ঠীগুলিকে পৃথক স্ট্রিংয়ে বিভক্ত করা এবং সেইগুলির একটি তালিকা ফেরত দেওয়া। পৃথক গোষ্ঠীগুলি ভারসাম্যপূর্ণ (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়। ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।",
      "bg": "Входът за тази функция е низ, съдържащ множество групи вложени скоби. Вашата цел е да\nразделите тези групи на отделни низове и да върнете списък с тях.\nОтделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\nИгнорирайте всички интервали в низа на входа.",
      "zh": "输入此函数的是一个包含多个嵌套括号组的字符串。您的目标是将这些组分离成单独的字符串，并返回这些字符串的列表。  \n分离的组是平衡的（每个打开的括号都正确关闭）并且不相互嵌套。  \n忽略输入字符串中的任何空格。",
      "fr": "L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de séparer ces groupes en chaînes distinctes et de renvoyer la liste de celles-ci. Les groupes séparés sont équilibrés (chaque accolade ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres. Ignorez tous les espaces dans la chaîne d'entrée.",
      "de": "Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es, diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben. Separate Gruppen sind ausgeglichen (jede öffnende Klammer wird ordnungsgemäß geschlossen) und nicht ineinander verschachtelt. Ignorieren Sie alle Leerzeichen im Eingabestring.",
      "ha": "Shigar ɗin wannan aikin shine wani igiyar rubutu da ke ɗauke da rukuni da yawa na kowane irin kowane nau'in baka. Manufarka ita ce raba waɗannan rukunin zuwa igiyoyi daban-daban kuma mayar da jerin waɗannan. Rukuni daban-daban suna daidaituwa (kowace buɗaɗɗiyar baka tana da rufewa daidai) kuma ba a haɗe su cikin juna. Yi watsi da duk wani sarari a cikin igiyar rubutu na shigarwa.",
      "hi": "इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करना और उन स्ट्रिंग्स की सूची लौटाना है।  \nअलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।  \nइनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।",
      "hu": "A függvény bemenete egy olyan karakterlánc, amely több csoportot tartalmaz egymásba ágyazott zárójelekből. A cél az, hogy ezeket a csoportokat különálló karakterláncokra bontsuk, és visszaadjuk ezek listáját. A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva. Figyelmen kívül kell hagyni a bemeneti karakterláncban lévő szóközöket."
    },
    "docstring_bertscore": {
      "sq": "0.9013766390997004",
      "hy": "0.906953782938398",
      "bn": "0.06062885953380332",
      "bg": "0.9033055387299302",
      "zh": "0.4875429525578971",
      "fr": "0.9295249476569165",
      "de": "0.9200272373573523",
      "ha": "0.8578497705516201",
      "hi": "0.8940016916822561",
      "hu": "0.8870814092070005"
    }
  },
  {
    "task_id": "Rust/3",
    "prompt": {
      "en": " /*\n  Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n ",
      "sq": " /*\n  Duke pasur një numër pozitiv me presje lëvizëse, ai mund të dekompozohet në\n  një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n  (pjesa e mbetur gjithmonë më e vogël se 1).\n \n  Kthe pjesën dhjetore të numrit.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "hy": " /*\n  Տրված դրական լողացող կետով թիվը, այն կարող է բաժանվել\n  ամբողջ թվային մասի (տրված թվից փոքրագույն ամբողջ թիվ) և տասնորդական մասի\n  (մնացորդային մասը միշտ փոքր է 1-ից):\n \n  Վերադարձնել թվի տասնորդական մասը:\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "bn": " /*\n  একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট সর্ববৃহৎ পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্ট অংশ যা সর্বদা ১ এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n\n  সংখ্যার দশমিক অংশটি ফেরত দিন।\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "bg": " /*\n  Дадено е положително число с плаваща запетая, което може да бъде разложено на\n  цяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n  (остатъчната част, която винаги е по-малка от 1).\n \n  Върнете десетичната част на числото.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "zh": " /*\n  给定一个正浮点数，它可以被分解为整数部分（小于给定数字的最大整数）和小数部分（剩余部分总是小于1）。\n\n  返回数字的小数部分。\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "fr": " /*\n  Étant donné un nombre à virgule flottante positif, il peut être décomposé en\n  une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n  (partie restante toujours inférieure à 1).\n \n  Retourne la partie décimale du nombre.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "de": " /*\n  Gegeben eine positive Gleitkommazahl, kann sie in einen\n  ganzzahligen Teil (größte ganze Zahl, die kleiner als die gegebene Zahl ist) und Dezimalstellen\n  (Restteil, der immer kleiner als 1 ist) zerlegt werden.\n \n  Gib den Dezimalteil der Zahl zurück.\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{",
      "ha": " /*\n  Idan aka ba da lamba mai kyau mai lamba mai lamba, za a iya raba ta zuwa\n  wani ɓangare na lamba (babban lamba mafi ƙanƙanta fiye da adadin da aka bayar) da kuma ƙananan lambobi\n  (ɓangaren da ya rage koyaushe ya fi ƙasa da 1).\n\n  Mayar da ɓangaren ƙananan lambobin na lambar.\n\n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n\n fn truncate_number(number: &f32) -> f32{",
      "hi": " /*\n  दिए गए एक धनात्मक फ्लोटिंग पॉइंट संख्या को एक पूर्णांक भाग (दी गई संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलवों में विभाजित किया जा सकता है \n  (बचा हुआ भाग हमेशा 1 से छोटा होता है)।\n \n  संख्या के दशमलव भाग को लौटाएं।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n",
      "hu": " /*\n  Adott egy pozitív lebegőpontos szám, amely felbontható egy\n  egész részre (a megadott számnál kisebb legnagyobb egész) és tizedesjegyekre\n  (mindig 1-nél kisebb maradék rész).\n \n  Adja vissza a szám tizedes részét.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn truncate_number(number: &f32) -> f32{\n"
    },
    "prompt_bertscore": {
      "sq": "0.9628386392729449",
      "hy": "0.9515866254480805",
      "bn": "0.9434376154357431",
      "bg": "0.9536080868358725",
      "zh": "0.941819572351833",
      "fr": "0.9700630248615647",
      "de": "0.9341373437349276",
      "ha": "0.9303224486367716",
      "hi": "0.9642475245656253",
      "hu": "0.955136746248317"
    },
    "canonical_solution": "\n  return number % 1.0;\n }\n ",
    "instruction": {
      "en": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nДайте кратко описание на кода на Rust на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\n请用中文为以下 Rust 代码提供简洁的自然语言描述（文档字符串），字数不超过 500 个字符。",
      "fr": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn truncate_number(number: &f32) -> f32{\n\n  return number % 1.0;\n }\n \n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9258661760382538",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8913561336372524",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9665526301375352",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_truncate_number() {\n  assert_eq!(truncate_number(&3.5), 0.5);\n  let t1: f32 = 1.33 - 0.33;\n  assert!(truncate_number(&t1) < 0.000001);\n  let t2: f32 = 123.456 - 0.456;\n  assert!(truncate_number(&t2) < 0.000001);\n  }\n \n }\n ",
    "entry_point": "truncate_number",
    "signature": "fn truncate_number(number: &f32) -> f32{",
    "docstring": {
      "en": "Given a positive floating point number, it can be decomposed into\n  and integer part (largest integer smaller than given number) and decimals\n  (leftover part always smaller than 1).\n \n  Return the decimal part of the number.",
      "sq": "Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n  një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore\n  (pjesa e mbetur gjithmonë më e vogël se 1).\n \n  Kthe pjesën dhjetore të numrit.",
      "hy": "Տրված դրական տասնորդական թիվը կարելի է բաժանել ամբողջ մասի (տրված թվից փոքրագույն ամբողջ թիվ) և տասնորդական մասի (մնացորդային մասը, որը միշտ փոքր է 1-ից):\n\nՎերադարձնել թվի տասնորդական մասը։",
      "bn": "একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্টাংশ যা সর্বদা 1 এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n\n  সংখ্যার দশমিক অংশটি ফেরত দিন।",
      "bg": "Дадено е положително число с плаваща запетая, което може да бъде разложено на\n  цяла част (най-голямото цяло число, по-малко от даденото число) и десетични части\n  (оставащата част, която винаги е по-малка от 1).\n \n  Връща десетичната част на числото.",
      "zh": "给定一个正浮点数，它可以被分解为整数部分（小于给定数字的最大整数）和小数部分（剩余部分总是小于1）。\n\n返回数字的小数部分。",
      "fr": "Étant donné un nombre flottant positif, il peut être décomposé en une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales (la partie restante toujours inférieure à 1).\n\nRetourne la partie décimale du nombre.",
      "de": "Gegeben eine positive Gleitkommazahl, kann sie in einen\n  ganzzahligen Teil (größte ganze Zahl kleiner als die gegebene Zahl) und Dezimalstellen\n  (übrig gebliebener Teil, der immer kleiner als 1 ist) zerlegt werden.\n \n  Gib den Dezimalteil der Zahl zurück.",
      "ha": "An ba da lamba mai kyau mai iyo, za a iya rarraba ta zuwa\n  ɓangaren lamba mai cikakken adadi (mafi girman lamba mai ƙasa da lambar da aka bayar) da kuma kaso\n  (ɓangaren da ya rage koyaushe ƙasa da 1).\n\n  Mayar da ɓangaren kaso na lambar.",
      "hi": "Rust फ़ंक्शन `fn truncate_number(number: &f32) -> f32{` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए धनात्मक फ्लोटिंग पॉइंट संख्या को \n  एक पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलव में विभाजित किया जा सकता है\n  (हमेशा 1 से छोटा बचा हुआ भाग)।\n\n  संख्या के दशमलव भाग को लौटाएं।",
      "hu": "Egy pozitív lebegőpontos szám esetén az felbontható egy egész részre (a megadott számnál kisebb legnagyobb egész szám) és tizedesjegyekre (a maradék rész mindig kisebb, mint 1).\n\n  Visszaadja a szám tizedes részét."
    },
    "docstring_bertscore": {
      "sq": "0.8974522986615941",
      "hy": "0.8517341397499371",
      "bn": "0.9146874568239913",
      "bg": "0.9040635122639593",
      "zh": "0.8868702651119604",
      "fr": "0.9524574210385375",
      "de": "0.8376601841017101",
      "ha": "0.834722043505442",
      "hi": "0.871842486374004",
      "hu": "0.9079954006565449"
    }
  },
  {
    "task_id": "Rust/4",
    "prompt": {
      "en": " /*\n  You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n ",
      "sq": " /*\n  Ju jepet një listë e operacioneve të depozitimit dhe tërheqjes në një llogari bankare që fillon me\n  bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë pikë bilanci i llogarisë bie nën zero, dhe\n  në atë pikë funksioni duhet të kthejë True. Përndryshe duhet të kthejë False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "hy": " /*\n  Ձեզ տրված է բանկային հաշվի վրա ավանդների և հանույթների գործողությունների ցուցակ, որը սկսվում է\n  զրոյական մնացորդով։ Ձեր խնդիրը է հայտնաբերել, արդյոք որևէ պահին հաշվի մնացորդը ընկնում է զրոյից ցածր, և\n  այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "bn": " /*\n  আপনার কাছে একটি ব্যাংক অ্যাকাউন্টে জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে পড়ে কিনা, এবং সেই মুহূর্তে ফাংশনটি True ফেরত দেওয়া উচিত। অন্যথায় এটি False ফেরত দেওয়া উচিত।\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "bg": " /*\n  Получавате списък с операции по депозити и тегления на банкова сметка, която започва с\n  нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и\n  в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "zh": " /*\n  给定一个银行账户的存款和取款操作列表，该账户初始余额为零。你的任务是检测账户余额是否在任何时候低于零，\n  如果是，则函数应返回True。否则应返回False。\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "fr": " /*\n  Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec\n  un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et\n  à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "de": " /*\n  Sie haben eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit\n  einem Kontostand von null beginnt. Ihre Aufgabe ist es zu erkennen, ob zu irgendeinem Zeitpunkt der Kontostand unter null fällt, und\n  in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "ha": " /*\n  An ba ku jerin ajiya da cire kudi a kan asusun banki wanda ke farawa da\n  sifili ma'auni. Aikinku shi ne gano idan a kowane lokaci ma'aunin asusun ya fadi kasa da sifili, kuma\n  a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n",
      "hi": " /*\n  आपके पास जमा और निकासी संचालन की एक सूची है जो एक बैंक खाते पर की जाती है, जो शून्य शेष राशि से शुरू होता है। \n  आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है, और उस बिंदु पर \n  फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{",
      "hu": " /*\n  Adott egy lista a banki számlán végrehajtott befizetési és kifizetési műveletekről, amely kezdetben\n  nulla egyenleggel indul. A feladat az, hogy észleljük, ha bármely ponton a számla egyenlege nulla alá csökken,\n  és ebben az esetben a függvénynek True-t kell visszaadnia. Ellenkező esetben False-t kell visszaadnia.\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn below_zero(operations:Vec<i32>) -> bool{\n"
    },
    "prompt_bertscore": {
      "sq": "0.9798330574135278",
      "hy": "0.9767223070161404",
      "bn": "0.9816642308962884",
      "bg": "0.9775277532112369",
      "zh": "0.9558164594122185",
      "fr": "0.9752077503607494",
      "de": "0.9726410485770166",
      "ha": "0.977095334871724",
      "hi": "0.9708055052258732",
      "hu": "0.9542113273030755"
    },
    "canonical_solution": "\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n ",
    "instruction": {
      "en": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nՏվեք Rust կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nরাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn below_zero(operations:Vec<i32>) -> bool{\n\n \n let mut balance:i32 = 0;\n for op in operations {\n  balance = balance + op;\n  if balance < 0 {\n  return true;\n  }\n  }\n  return false;\n }\n \n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9118512136131942",
      "bn": "0.9071935298083071",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9412908182775181",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n #[test]\n  fn test_below_zero() {\n  assert_eq!(below_zero(vec![]), false);\n  assert_eq!(below_zero(vec![1, 2, -3, 1, 2, -3]), false);\n  assert_eq!(below_zero(vec![1, 2, -4, 5, 6]), true);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -4]), false);\n  assert_eq!(below_zero(vec![1, -1, 2, -2, 5, -5, 4, -5]), true);\n  assert_eq!(below_zero(vec![1, -2, 2, -2, 5, -5, 4, -4]), true);\n  }\n \n }\n ",
    "entry_point": "below_zero",
    "signature": "fn below_zero(operations:Vec<i32>) -> bool{",
    "docstring": {
      "en": "You're given a list of deposit and withdrawal operations on a bank account that starts with\n  zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n  at that point function should return True. Otherwise it should return False.",
      "sq": "Ju jepet një listë e operacioneve të depozitave dhe tërheqjeve në një llogari bankare që fillon me një bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.",
      "hy": "Դուք տրված եք բանկային հաշվի վրա ավանդների և դուրսբերումների գործողությունների ցուցակ, որը սկսվում է զրոյական մնացորդով: Ձեր խնդիրն է հայտնաբերել, արդյոք որևէ պահին հաշվի մնացորդը ընկնում է զրոյից ցածր, և այդ պահին ֆունկցիան պետք է վերադարձնի True: Հակառակ դեպքում այն պետք է վերադարձնի False:",
      "bn": "তোমাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। তোমার কাজ হল সনাক্ত করা যে কোনো সময়ে অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই সময়ে ফাংশনটি True ফেরত দেওয়া উচিত। অন্যথায় এটি False ফেরত দেওয়া উচিত।",
      "bg": "Получавате списък с операции за депозити и тегления по банкова сметка, която започва с нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и в този момент функцията трябва да върне True. В противен случай трябва да върне False.",
      "zh": "您有一个银行账户的存款和取款操作列表，该账户从零余额开始。您的任务是检测账户余额是否在任何时候低于零，并且在那时函数应返回True。否则，它应返回False。",
      "fr": "Vous disposez d'une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde nul. Votre tâche est de détecter si, à un moment donné, le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.",
      "de": "Du hast eine Liste von Einzahlungs- und Abhebungsvorgängen auf einem Bankkonto, das mit einem Kontostand von null beginnt. Deine Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.",
      "ha": "Ana ba ku jerin ajiya da ayyukan cire kudi akan wani asusun banki wanda ya fara da sifili. Ayyukanku shine gano idan a kowane lokaci ma'aunin asusun ya faɗi ƙasa da sifili, kuma a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.",
      "hi": "आपको बैंक खाते पर जमा और निकासी संचालन की एक सूची दी गई है, जो शून्य शेष राशि से शुरू होता है। आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।",
      "hu": "Egy bankszámlán végrehajtott befizetési és kifizetési műveletek listáját kapod, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármelyik ponton a számla egyenlege nulla alá esik, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False értéket kell visszaadnia."
    },
    "docstring_bertscore": {
      "sq": "0.9502478566799053",
      "hy": "0.9521102151324885",
      "bn": "0.9397510355637356",
      "bg": "0.9463703930117233",
      "zh": "0.9234260018072402",
      "fr": "0.9347876596024358",
      "de": "0.9043263002580685",
      "ha": "0.9346001525227389",
      "hi": "0.9374826766123172",
      "hu": "0.9109138768450906"
    }
  },
  {
    "task_id": "Rust/5",
    "prompt": {
      "en": " /*\n  For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n ",
      "sq": " /*\n  Për një listë të dhënë numrash hyrës, llogaritni Devijimin Absolut Mesatar\n  rreth mesatares së këtij grupi të dhënash.\n  Devijimi Absolut Mesatar është diferenca mesatare absolute midis secilit\n  element dhe një pikë qendrore (mesatarja në këtë rast):\n  MAD = mesatarja | x - x_mesatare |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "hy": " /*\n  Տրված թվերի ցուցակի համար հաշվեք միջին բացարձակ շեղումը\n  այս տվյալների հավաքածուի միջինից:\n  Միջին բացարձակ շեղումը միջին բացարձակ տարբերությունն է յուրաքանչյուր\n  տարրի և կենտրոնական կետի (այս դեպքում՝ միջինի) միջև:\n  MAD = միջին | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "bn": " /*\n  প্রদত্ত ইনপুট সংখ্যার একটি তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি হিসাব করুন।\n  গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n  MAD = গড় | x - x_mean |\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{",
      "bg": " /*\n  За даден списък от входни числа, изчислете Средно Абсолютно Отклонение\n  около средната стойност на този набор от данни.\n  Средно Абсолютно Отклонение е средната абсолютна разлика между всеки\n  елемент и централна точка (в случая средна стойност):\n  MAD = средно | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{",
      "zh": " /*\n  对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n  平均绝对偏差是每个元素与中心点（在此情况下为平均值）之间的平均绝对差：\n  MAD = average | x - x_mean |\n  \n */\n",
      "fr": " /*\n  Pour une liste donnée de nombres d'entrée, calculez la Déviation Absolue Moyenne\n  autour de la moyenne de cet ensemble de données.\n  La Déviation Absolue Moyenne est la différence absolue moyenne entre chaque\n  élément et un point central (la moyenne dans ce cas) :\n  MAD = moyenne | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "de": " /*\n  Für eine gegebene Liste von Eingabezahlen berechne die mittlere absolute Abweichung\n  um den Mittelwert dieses Datensatzes.\n  Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n  Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n  MAD = durchschnittliche | x - x_mean |\n  \n */ \n\n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "ha": " /*\n  Don wani jerin lambobin shigarwa, lissafa Matsakaicin Bambanci na Dangi\n  a kusa da matsakaicin wannan bayanan.\n  Matsakaicin Bambanci na Dangi shine matsakaicin bambanci na dangi tsakanin kowanne\n  abu da wani tsakiya (matsakaici a wannan yanayin):\n  MAD = matsakaici | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "hi": " /*\n  दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।\n  माध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्रबिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:\n  MAD = औसत | x - x_mean |\n  \n */\n \n use std::{slice::Iter, cmp::{max, self}, mem::replace, collections::{HashSet, HashMap}, ops::Index, ascii::AsciiExt};\n use rand::Rng;\n use regex::Regex;\n use md5;\n use std::any::{Any, TypeId};\n \n fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n",
      "hu": " /*\n  Egy adott számokból álló lista esetén számítsa ki az átlagos abszolút eltérést\n  ennek az adathalmaznak az átlaga körül.\n  Az átlagos abszolút eltérés az egyes elemek és egy középpont (ebben az esetben az átlag) közötti átlagos abszolút különbség:\n  MAD = átlag | x - x_mean |\n  \n */"
    },
    "prompt_bertscore": {
      "sq": "0.9683760570354355",
      "hy": "0.955779315530965",
      "bn": "0.9689934002596919",
      "bg": "0.9617837133192686",
      "zh": "0.6781299949431585",
      "fr": "0.9802926881152425",
      "de": "0.9770168758712151",
      "ha": "0.9652972861293947",
      "hi": "0.9673761516973058",
      "hu": "0.6742600792294559"
    },
    "canonical_solution": "\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n ",
    "instruction": {
      "en": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nՏվեք կարճ բնութագիր (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nরাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\n请使用不超过500个字符的中文，为Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Rust cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nरस्ट कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों का उपयोग करके प्रदान करें।",
      "hu": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{\n\n  let mean:f32 = numbers.iter().fold(0.0,|acc:f32, x:&f32| acc + x) / numbers.len() as f32;\n  return numbers.iter().map(|x:&f32| (x - mean).abs()).sum::<f32>() / numbers.len() as f32;\n }\n \n \n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8870448612168901",
      "bn": "0.8851102013056104",
      "bg": "0.8316696904400789",
      "zh": "0.8393272888897358",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9675779601644373",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "\n #[cfg(test)]\n mod tests {\n  use super::*;\n \n  #[test]\n  fn test_mean_absolute_deviation() {\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0]) - 2.0 / 3.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0]) - 1.0 < 0.000001);\n  assert!(mean_absolute_deviation(vec![1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0 / 5.0 < 0.000001);\n  }\n \n }\n ",
    "entry_point": "mean_absolute_deviation",
    "signature": "fn mean_absolute_deviation(numbers:Vec<f32>) -> f32{",
    "docstring": {
      "en": "For a given list of input numbers, calculate Mean Absolute Deviation\n  around the mean of this dataset.\n  Mean Absolute Deviation is the average absolute difference between each\n  element and a centerpoint (mean in this case):\n  MAD = average | x - x_mean |",
      "sq": "Për një listë të dhënë numrash hyrës, llogaritni Devijimin Absolut Mesatar\n  rreth mesatares së këtij grupi të dhënash.\n  Devijimi Absolut Mesatar është mesatarja e diferencës absolute midis secilit\n  element dhe një pikë qendrore (mesatarja në këtë rast):\n  MAD = mesatarja | x - x_mean |",
      "hy": "Տրված թվերի ցուցակի համար հաշվարկեք միջին բացարձակ շեղումը\n  այս տվյալների հավաքածուի միջինից:\n  Միջին բացարձակ շեղումը տվյալների այս հավաքածուի միջինից:\n  Միջին բացարձակ շեղումը միջին բացարձակ տարբերությունն է յուրաքանչյուր\n  տարրի և կենտրոնական կետի (այս դեպքում՝ միջինի) միջև:\n  MAD = միջին | x - x_mean |",
      "bn": "প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি (Mean Absolute Deviation) গণনা করুন। গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য: MAD = গড় | x - x_mean |",
      "bg": "За даден списък от входни числа, изчислете Средно Абсолютно Отклонение около средната стойност на този набор от данни. Средното Абсолютно Отклонение е средната абсолютна разлика между всеки елемент и централната точка (в този случай средната стойност): MAD = средно | x - x_mean |",
      "zh": "对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n平均绝对偏差是每个元素与中心点（在此情况下为平均值）之间的平均绝对差：\nMAD = average | x - x_mean |",
      "fr": "Pour une liste donnée de nombres d'entrée, calculez la Déviation Absolue Moyenne autour de la moyenne de cet ensemble de données.  \nLa Déviation Absolue Moyenne est la différence absolue moyenne entre chaque élément et un point central (la moyenne dans ce cas) :  \nMAD = moyenne | x - x_mean |",
      "de": "Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung um den Mittelwert dieses Datensatzes. Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem Element und einem Mittelpunkt (in diesem Fall der Mittelwert): MAD = Durchschnitt | x - x_mean |",
      "ha": "Don wani jerin lambobin shigarwa da aka bayar, lissafa Matsakaicin Bambancin Dangi\n  a kusa da matsakaicin wannan bayanan.\n  Matsakaicin Bambancin Dangi shine matsakaicin bambancin dangi tsakanin kowanne\n  abu da wani tsakiya (matsakaici a wannan yanayin):\n  MAD = matsakaici | x - x_mean |",
      "hi": "दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।  \nमाध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्रबिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:  \nMAD = औसत | x - x_mean |  ",
      "hu": "Egy adott bemeneti számok listájára számítsa ki az átlagos abszolút eltérést\n  az adathalmaz átlagához képest.\n  Az átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag) közötti átlagos abszolút különbség:\n  MAD = átlag | x - x_mean |"
    },
    "docstring_bertscore": {
      "sq": "0.9484623681847827",
      "hy": "1",
      "bn": "0.8753175248902093",
      "bg": "0.9478954770773091",
      "zh": "0.918095159641026",
      "fr": "0.9514287142951577",
      "de": "0.9265180809488104",
      "ha": "0.9323441086549447",
      "hi": "0.9161320955852581",
      "hu": "0.9105410476198881"
    }
  },
  {
    "task_id": "Rust/6",
    "prompt": {
      "en": "/*\n  Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "sq": "/*\n  Përcakton gjatësinë e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që gjendet në 'source'.\n  Funksioni nuk kërkon që karakteret të jenë të pozicionuara në mënyrë të njëpasnjëshme në 'source', por ato duhet të ruajnë rendin e tyre nga 'target'.\n\n  Argumentet:\n  - source: Një varg që përbëhet nga shkronjat e mëdha të anglishtes.\n  - target: Një varg që përbëhet nga shkronjat e mëdha të anglishtes.\n\n  Kthen:\n  - Gjatësinë e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që gjendet në 'source'.\n\n  Shembull:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") kthen 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") kthen 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") kthen 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "hy": "/*\n  Որոշում է 'target'-ից ամենաերկար հարակից նիշերի հաջորդականության երկարությունը, որը պարունակվում է 'source'-ում:\n  Ֆունկցիան չի պահանջում, որ նիշերը 'source'-ում լինեն հաջորդաբար տեղադրված, բայց նրանք պետք է պահեն իրենց կարգը 'target'-ից:\n\n  Արգումենտներ:\n  - source: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n  - target: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - 'target'-ից ամենաերկար հարակից նիշերի հաջորդականության երկարությունը, որը պարունակվում է 'source'-ում:\n\n  Օրինակ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") վերադարձնում է 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "bn": "/*\n  'source' এর মধ্যে 'target' থেকে অক্ষরগুলির সবচেয়ে দীর্ঘ সংলগ্ন ক্রমের দৈর্ঘ্য নির্ধারণ করে।\n  ফাংশনটি 'source' এ অক্ষরগুলিকে পরপর অবস্থান করতে হবে না, তবে তাদের 'target' থেকে তাদের ক্রম বজায় রাখতে হবে।\n\n  আর্গুমেন্ট:\n  - source: বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n  - target: বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n\n  রিটার্ন:\n  - 'source' এর মধ্যে 'target' থেকে অক্ষরগুলির সবচেয়ে দীর্ঘ সংলগ্ন ক্রমের দৈর্ঘ্য।\n\n  উদাহরণ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 রিটার্ন করে\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 রিটার্ন করে\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 রিটার্ন করে\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "bg": "/*\n  Определя дължината на най-дългата непрекъсната последователност от символи от 'target', която е съдържана в 'source'.\n  Функцията не изисква символите да бъдат последователно разположени в 'source', но те трябва да запазят реда си от 'target'.\n\n  Аргументи:\n  - source: Низ, състоящ се от главни английски букви.\n  - target: Низ, състоящ се от главни английски букви.\n\n  Връща:\n  - Дължината на най-дългата непрекъсната последователност от символи от 'target', която е съдържана в 'source'.\n\n  Пример:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") връща 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") връща 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") връща 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "zh": "/*\n  确定在 'source' 中包含的来自 'target' 的最长连续字符序列的长度。\n  函数不要求字符在 'source' 中连续出现，但必须保持来自 'target' 的顺序。\n\n  参数:\n  - source: 一个由大写英文字母组成的字符串。\n  - target: 一个由大写英文字母组成的字符串。\n\n  返回:\n  - 在 'source' 中包含的来自 'target' 的最长连续字符序列的长度。\n\n  示例:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 返回 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 返回 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 返回 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "fr": "/*\n  Détermine la longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n  La fonction ne nécessite pas que les caractères soient positionnés consécutivement dans 'source', mais ils doivent conserver leur ordre de 'target'.\n\n  Arguments :\n  - source : Une chaîne composée de lettres majuscules anglaises.\n  - target : Une chaîne composée de lettres majuscules anglaises.\n\n  Renvoie :\n  - La longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n\n  Exemple :\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") renvoie 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") renvoie 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") renvoie 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "de": "/*\n  Bestimmt die Länge der längsten zusammenhängenden Zeichenfolge aus 'target', die in 'source' enthalten ist.\n  Die Funktion erfordert nicht, dass die Zeichen aufeinanderfolgend in 'source' positioniert sind, aber sie müssen ihre Reihenfolge aus 'target' beibehalten.\n\n  Argumente:\n  - source: Ein String, bestehend aus Großbuchstaben des englischen Alphabets.\n  - target: Ein String, bestehend aus Großbuchstaben des englischen Alphabets.\n\n  Rückgabewert:\n  - Die Länge der längsten zusammenhängenden Zeichenfolge aus 'target', die in 'source' enthalten ist.\n\n  Beispiel:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") gibt 3 zurück\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") gibt 3 zurück\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") gibt 0 zurück\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "ha": "/*\n  Yana tantance tsawon jerin haruffa mafi tsawo na jere daga 'target' wanda yake cikin 'source'.\n  Aikin ba ya bukatar haruffa su kasance a jere a cikin 'source', amma dole ne su kiyaye tsarin su daga 'target'.\n\n  Huɗɗa:\n  - source: Wani kirtani da ya ƙunshi manyan haruffan Ingilishi.\n  - target: Wani kirtani da ya ƙunshi manyan haruffan Ingilishi.\n\n  Komawa:\n  - Tsawon jerin haruffa mafi tsawo na jere daga 'target' wanda yake cikin 'source'.\n\n  Misali:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "hi": "/*\n  'source' में 'target' से वर्णों की सबसे लंबी निरंतर अनुक्रम की लंबाई निर्धारित करता है।\n  फ़ंक्शन को 'source' में वर्णों को लगातार स्थित होने की आवश्यकता नहीं है, लेकिन उन्हें 'target' से अपने क्रम को बनाए रखना चाहिए।\n\n  तर्क:\n  - source: अपरकेस अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n  - target: अपरकेस अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n\n  लौटाता है:\n  - 'source' में 'target' से वर्णों की सबसे लंबी निरंतर अनुक्रम की लंबाई।\n\n  उदाहरण:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 लौटाता है\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 लौटाता है\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 लौटाता है\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize ",
      "hu": "/*\n  Meghatározza a 'target'-ből származó leghosszabb összefüggő karaktersorozat hosszát, amely megtalálható a 'source'-ban.\n  A függvény nem igényli, hogy a karakterek egymás után helyezkedjenek el a 'source'-ban, de meg kell őrizniük a 'target'-beli sorrendjüket.\n\n  Argumentumok:\n  - source: Egy nagybetűs angol betűkből álló string.\n  - target: Egy nagybetűs angol betűkből álló string.\n\n  Visszatér:\n  - A 'target'-ből származó leghosszabb összefüggő karaktersorozat hossza, amely megtalálható a 'source'-ban.\n\n  Példa:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") visszatér 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") visszatér 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") visszatér 0\n*/\n\n\nfn longest_contained_sequence(source: &str, target: &str) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9738950021724898",
      "hy": "0.997290284341922",
      "bn": "0.9637477705269415",
      "bg": "0.9946675687907374",
      "zh": "0.9576174410770618",
      "fr": "0.9965599204308567",
      "de": "0.9666586987610079",
      "ha": "0.9551184722532619",
      "hi": "0.9581499691286163",
      "hu": "0.9725681512271768"
    },
    "canonical_solution": "{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}",
    "instruction": {
      "en": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nՏրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nরাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Rust cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn longest_contained_sequence(source: &str, target: &str) -> usize\n{\n    let mut max_length = 0;\n    let mut start_index = 0;\n\n    for target_char in target.chars() {\n        if let Some(pos) = source[start_index..].find(target_char) {\n            max_length += 1;\n            start_index += pos + 1;\n        } else {\n            break;\n        }\n    }\n    max_length\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9423368058640478",
      "bn": "0.8851102013056104",
      "bg": "0.8316696904400789",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_contained_sequence(\"ABCDEABCD\", \"AABZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"XYZ\", \"XYZ\"), 3);\n        assert_eq!(longest_contained_sequence(\"ABCDEF\", \"FED\"), 1);\n        assert_eq!(longest_contained_sequence(\"ABCD\", \"BCD\"), 3);\n    }\n    \n\n}",
    "entry_point": "longest_contained_sequence",
    "signature": "fn longest_contained_sequence(source: &str, target: &str) -> usize",
    "docstring": {
      "en": "Determines the length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n  The function does not require the characters to be consecutively positioned in 'source', but they must retain their order from 'target'.\n\n  Arguments:\n  - source: A string consisting of uppercase English letters.\n  - target: A string consisting of uppercase English letters.\n\n  Returns:\n  - The length of the longest contiguous sequence of characters from 'target' that is contained in 'source'.\n\n  Example:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "sq": "Përcakton gjatësinë e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që përmbahet në 'source'.\n  Funksioni nuk kërkon që karakteret të jenë të pozicionuara në mënyrë të njëpasnjëshme në 'source', por ato duhet të ruajnë rendin e tyre nga 'target'.\n\n  Argumentet:\n  - source: Një varg që përbëhet nga shkronja të mëdha të anglishtes.\n  - target: Një varg që përbëhet nga shkronja të mëdha të anglishtes.\n\n  Kthen:\n  - Gjatësia e sekuencës më të gjatë të pandërprerë të karaktereve nga 'target' që përmbahet në 'source'.\n\n  Shembull:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") kthen 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") kthen 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") kthen 0",
      "hy": "Որոշում է 'target'-ից ամենաերկար անընդմեջ հաջորդականության երկարությունը, որը պարունակվում է 'source'-ում:\n  Ֆունկցիան չի պահանջում, որ նիշերը անընդմեջ տեղակայված լինեն 'source'-ում, բայց նրանք պետք է պահպանեն իրենց կարգը 'target'-ից:\n\n  Արգումենտներ:\n  - source: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n  - target: Տող, որը բաղկացած է մեծատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - Ամենաերկար անընդմեջ հաջորդականության երկարությունը 'target'-ից, որը պարունակվում է 'source'-ում:\n\n  Օրինակ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") վերադարձնում է 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") վերադարձնում է 0",
      "bn": "নির্ধারণ করে 'target' থেকে 'source' এ অন্তর্ভুক্ত সবচেয়ে দীর্ঘ সংলগ্ন অক্ষরগুলির ক্রমের দৈর্ঘ্য। \n  ফাংশনটি 'source' এ অক্ষরগুলিকে ধারাবাহিকভাবে অবস্থান করতে হবে না, তবে তাদের 'target' থেকে তাদের ক্রম বজায় রাখতে হবে।\n\n  আর্গুমেন্টস:\n  - source: একটি স্ট্রিং যা বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত।\n  - target: একটি স্ট্রিং যা বড় হাতের ইংরেজি অক্ষর নিয়ে গঠিত।\n\n  রিটার্নস:\n  - 'target' থেকে 'source' এ অন্তর্ভুক্ত সবচেয়ে দীর্ঘ সংলগ্ন অক্ষরগুলির ক্রমের দৈর্ঘ্য।\n\n  উদাহরণ:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") returns 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") returns 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") returns 0",
      "bg": "Определя дължината на най-дългата непрекъсната последователност от символи от 'target', която се съдържа в 'source'. \n  Функцията не изисква символите да са последователно разположени в 'source', но те трябва да запазят реда си от 'target'.\n\n  Аргументи:\n  - source: Низ, състоящ се от главни английски букви.\n  - target: Низ, състоящ се от главни английски букви.\n\n  Връща:\n  - Дължината на най-дългата непрекъсната последователност от символи от 'target', която се съдържа в 'source'.\n\n  Пример:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") връща 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") връща 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") връща 0",
      "zh": "确定在“source”中包含的来自“target”的最长连续字符序列的长度。  \n该函数不要求字符在“source”中连续出现，但它们必须保持来自“target”的顺序。\n\n参数：\n- source: 一个由大写英文字母组成的字符串。\n- target: 一个由大写英文字母组成的字符串。\n\n返回：\n- 在“source”中包含的来自“target”的最长连续字符序列的长度。\n\n示例：\n- longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 返回 3\n- longest_contained_sequence(\"XYZ\", \"XYZ\") 返回 3\n- longest_contained_sequence(\"ABCDEF\", \"FED\") 返回 0",
      "fr": "Détermine la longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n  La fonction ne nécessite pas que les caractères soient positionnés consécutivement dans 'source', mais ils doivent conserver leur ordre de 'target'.\n\n  Arguments:\n  - source: Une chaîne de caractères composée de lettres majuscules anglaises.\n  - target: Une chaîne de caractères composée de lettres majuscules anglaises.\n\n  Renvoie:\n  - La longueur de la plus longue séquence contiguë de caractères de 'target' qui est contenue dans 'source'.\n\n  Exemple:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") renvoie 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") renvoie 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") renvoie 0",
      "de": "Bestimmt die Länge der längsten zusammenhängenden Zeichenfolge von Zeichen aus 'target', die in 'source' enthalten ist.\n  Die Funktion erfordert nicht, dass die Zeichen in 'source' aufeinanderfolgend positioniert sind, aber sie müssen ihre Reihenfolge aus 'target' beibehalten.\n\n  Argumente:\n  - source: Ein String bestehend aus Großbuchstaben des englischen Alphabets.\n  - target: Ein String bestehend aus Großbuchstaben des englischen Alphabets.\n\n  Rückgabewert:\n  - Die Länge der längsten zusammenhängenden Zeichenfolge von Zeichen aus 'target', die in 'source' enthalten ist.\n\n  Beispiel:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") gibt 3 zurück\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") gibt 3 zurück\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") gibt 0 zurück",
      "ha": "Yana tantance tsawon mafi tsawo jerin haruffa masu jere daga 'target' da aka ƙunsa a cikin 'source'. \n  Aikin ba ya buƙatar haruffa su kasance a jere a cikin 'source', amma dole ne su kiyaye tsari daga 'target'.\n\n  Huɗɗa:\n  - source: Wani kirtani da ya ƙunshi manyan haruffan Ingilishi.\n  - target: Wani kirtani da ya ƙunshi manyan haruffan Ingilishi.\n\n  Dawowa:\n  - Tsawon mafi tsawo jerin haruffa masu jere daga 'target' da aka ƙunsa a cikin 'source'.\n\n  Misali:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") yana dawowa 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") yana dawowa 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") yana dawowa 0",
      "hi": "'Target' से वर्णों के सबसे लंबे निरंतर अनुक्रम की लंबाई निर्धारित करता है जो 'source' में निहित है। \n  फ़ंक्शन को वर्णों को 'source' में लगातार स्थित होने की आवश्यकता नहीं है, लेकिन उन्हें 'target' से अपने क्रम को बनाए रखना चाहिए।\n\n  तर्क:\n  - source: बड़े अक्षरों वाले अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n  - target: बड़े अक्षरों वाले अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n\n  वापसी:\n  - 'target' से वर्णों के सबसे लंबे निरंतर अनुक्रम की लंबाई जो 'source' में निहित है।\n\n  उदाहरण:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") 3 लौटाता है\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") 3 लौटाता है\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") 0 लौटाता है",
      "hu": "Meghatározza a 'target'-ből a 'source'-ben található leghosszabb összefüggő karaktersorozat hosszát.\n  A függvény nem igényli, hogy a karakterek egymás után helyezkedjenek el a 'source'-ben, de meg kell őrizniük a 'target'-ből származó sorrendjüket.\n\n  Argumentumok:\n  - source: Egy nagybetűs angol betűkből álló karakterlánc.\n  - target: Egy nagybetűs angol betűkből álló karakterlánc.\n\n  Visszatérési érték:\n  - A 'target'-ből a 'source'-ben található leghosszabb összefüggő karaktersorozat hossza.\n\n  Példa:\n  - longest_contained_sequence(\"ABCDEABCD\", \"AABZ\") visszaadja 3\n  - longest_contained_sequence(\"XYZ\", \"XYZ\") visszaadja 3\n  - longest_contained_sequence(\"ABCDEF\", \"FED\") visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9920754423182321",
      "hy": "0.9774494928411092",
      "bn": "0.9442601438436087",
      "bg": "0.9920903395968097",
      "zh": "0.9465914686258151",
      "fr": "0.9891394866561554",
      "de": "0.9619813505483983",
      "ha": "0.9438231570053319",
      "hi": "0.9803216881508736",
      "hu": "0.9592440252673564"
    }
  },
  {
    "task_id": "Rust/7",
    "prompt": {
      "en": "/*\n  Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "sq": "/*\n  Llogarit rezultatin më të lartë, rezultatin më të ulët, dhe rezultatin mesatar nga një listë e rezultateve të studentëve.\n  \n  Funksioni merr një vektor të rezultateve të tëra, secili duke variuar nga 0 në 100, që përfaqëson rezultatet e studentëve në një provim. Ai kthen një tuple që përmban rezultatin më të lartë, rezultatin më të ulët, dhe rezultatin mesatar të llogaritur nga këto rezultate.\n\n  Argumentet:\n  - scores: Një Vec<i32> që përmban rezultatet e provimit të studentëve.\n\n  Kthen:\n  - Një tuple (i32, i32, f64), ku elementi i parë është rezultati më i lartë, i dyti është rezultati më i ulët, dhe i treti është rezultati mesatar i rrumbullakosur në dy vende dhjetore.\n\n  Shembull:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) kthen (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) kthen (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) kthen (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "hy": "/*\n  Հաշվում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը ուսանողների միավորների ցուցակից:\n  \n  Ֆունկցիան ընդունում է ամբողջ թվերի միավորների վեկտոր, որոնցից յուրաքանչյուրը տատանվում է 0-ից 100-ի սահմաններում, ներկայացնելով ուսանողների միավորները քննության ժամանակ: Այն վերադարձնում է տյուպլ, որը պարունակում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը, հաշվարկված այս միավորներից:\n\n  Արգումենտներ:\n  - scores: A Vec<i32>, որը պարունակում է ուսանողների քննության միավորները:\n\n  Վերադարձնում է:\n  - Տյուպլ (i32, i32, f64), որտեղ առաջին տարրը ամենաբարձր միավորն է, երկրորդը՝ ամենացածր միավորը, իսկ երրորդը՝ միջին միավորը, կլորացված մինչև երկու տասնորդական:\n\n  Օրինակ:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) վերադարձնում է (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) վերադարձնում է (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) վերադարձնում է (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "bn": "/*\n  ছাত্রদের স্কোরের একটি তালিকা থেকে সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং গড় স্কোর হিসাব করে।\n\n  ফাংশনটি পূর্ণসংখ্যার স্কোরের একটি ভেক্টর নেয়, প্রতিটি 0 থেকে 100 এর মধ্যে, যা একটি পরীক্ষায় ছাত্রদের স্কোর উপস্থাপন করে। এটি একটি টুপল প্রদান করে যা এই স্কোরগুলি থেকে হিসাব করা সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং গড় স্কোর ধারণ করে।\n\n  আর্গুমেন্টসমূহ:\n  - scores: একটি Vec<i32> যা ছাত্রদের পরীক্ষার স্কোর ধারণ করে।\n\n  রিটার্নস:\n  - একটি টুপল (i32, i32, f64), যেখানে প্রথম উপাদানটি সর্বোচ্চ স্কোর, দ্বিতীয়টি সর্বনিম্ন স্কোর এবং তৃতীয়টি গড় স্কোর যা দুই দশমিক স্থানে গোল করা হয়।\n\n  উদাহরণ:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) প্রদান করে (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) প্রদান করে (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) প্রদান করে (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "bg": "/*\n  Изчислява най-високия резултат, най-ниския резултат и средния резултат от списък с резултати на ученици.\n  \n  Функцията приема вектор от цели числа, всяко от които е в диапазона от 0 до 100, представляващи резултатите на учениците на изпит. Тя връща кортеж, съдържащ най-високия резултат, най-ниския резултат и средния резултат, изчислени от тези резултати.\n\n  Аргументи:\n  - scores: Vec<i32>, съдържащ резултатите от изпита на учениците.\n\n  Връща:\n  - Кортеж (i32, i32, f64), където първият елемент е най-високият резултат, вторият е най-ниският резултат, а третият е средният резултат, закръглен до два десетични знака.\n\n  Пример:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) връща (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) връща (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) връща (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "zh": "/*\n  计算学生成绩列表中的最高分、最低分和平均分。\n  \n  该函数接收一个整数分数的向量，每个分数范围从0到100，表示学生在考试中的成绩。它返回一个包含最高分、最低分和从这些分数计算出的平均分的元组。\n\n  参数:\n  - scores: 一个包含学生考试成绩的 Vec<i32>。\n\n  返回:\n  - 一个元组 (i32, i32, f64)，其中第一个元素是最高分，第二个是最低分，第三个是四舍五入到小数点后两位的平均分。\n\n  示例:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) 返回 (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) 返回 (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) 返回 (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "fr": "/*\n  Calcule le score le plus élevé, le score le plus bas et le score moyen à partir d'une liste de scores d'étudiants.\n  \n  La fonction prend un vecteur de scores entiers, chacun allant de 0 à 100, représentant les scores des étudiants à un examen. Elle renvoie un tuple contenant le score le plus élevé, le score le plus bas et le score moyen calculé à partir de ces scores.\n\n  Arguments :\n  - scores : Un Vec<i32> contenant les scores d'examen des étudiants.\n\n  Renvoie :\n  - Un tuple (i32, i32, f64), où le premier élément est le score le plus élevé, le second est le score le plus bas, et le troisième est le score moyen arrondi à deux décimales.\n\n  Exemple :\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) renvoie (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) renvoie (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) renvoie (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "de": "/*\n  Berechnet die höchste Punktzahl, die niedrigste Punktzahl und die durchschnittliche Punktzahl aus einer Liste von Schülerpunkten.\n  \n  Die Funktion nimmt einen Vektor von Ganzzahlwerten, die jeweils von 0 bis 100 reichen und die Punktzahlen der Schüler in einer Prüfung darstellen. Sie gibt ein Tupel zurück, das die höchste Punktzahl, die niedrigste Punktzahl und die durchschnittliche Punktzahl, berechnet aus diesen Punktzahlen, enthält.\n\n  Argumente:\n  - scores: Ein Vec<i32>, der die Prüfungspunkte der Schüler enthält.\n\n  Rückgabewerte:\n  - Ein Tupel (i32, i32, f64), wobei das erste Element die höchste Punktzahl ist, das zweite die niedrigste Punktzahl und das dritte die durchschnittliche Punktzahl, gerundet auf zwei Dezimalstellen.\n\n  Beispiel:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) gibt (99, 10, 71.29) zurück\n  - exam_statistics(vec![100, 85, 76, 90]) gibt (100, 76, 87.75) zurück\n  - exam_statistics(vec![50, 50, 50, 50]) gibt (50, 50, 50.00) zurück\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "ha": "/*\n  Lissafa mafi girman maki, mafi ƙananan maki, da matsakaicin maki daga jerin maki na ɗalibai.\n  \n  Aikin yana karɓar vector na maki na integers, kowanne yana tsakanin 0 zuwa 100, wanda ke wakiltar maki na ɗalibai a jarrabawa. Yana dawowa da tuple wanda ke ɗauke da mafi girman maki, mafi ƙananan maki, da matsakaicin maki da aka lissafa daga waɗannan maki.\n\n  Huɗɗa:\n  - scores: A Vec<i32> wanda ke ɗauke da maki na jarrabawar ɗalibai.\n\n  Dawowa:\n  - A tuple (i32, i32, f64), inda na farko shine mafi girman maki, na biyu shine mafi ƙananan maki, kuma na uku shine matsakaicin maki da aka zagaye zuwa wurare biyu na goma.\n\n  Misali:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "hi": "/*\n  एक सूची में छात्र अंकों से उच्चतम स्कोर, न्यूनतम स्कोर, और औसत स्कोर की गणना करता है।\n\n  यह फ़ंक्शन पूर्णांक अंकों के एक वेक्टर को लेता है, प्रत्येक 0 से 100 तक की सीमा में, जो एक परीक्षा में छात्रों के अंक दर्शाता है। यह एक ट्यूपल लौटाता है जिसमें उच्चतम स्कोर, न्यूनतम स्कोर, और इन अंकों से गणना किया गया औसत स्कोर शामिल होता है।\n\n  तर्क:\n  - scores: एक Vec<i32> जिसमें छात्रों के परीक्षा अंक होते हैं।\n\n  लौटाता है:\n  - एक ट्यूपल (i32, i32, f64), जहाँ पहला तत्व उच्चतम स्कोर है, दूसरा न्यूनतम स्कोर है, और तीसरा औसत स्कोर है जो दो दशमलव स्थानों तक गोल किया गया है।\n\n  उदाहरण:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
      "hu": "/*\n  Kiszámítja a legmagasabb pontszámot, legalacsonyabb pontszámot és az átlagpontszámot egy diákpontszámok listájából.\n  \n  A függvény egy egész számokat tartalmazó vektort vesz át, ahol minden érték 0 és 100 között van, és a diákok vizsgapontszámait képviseli. Egy tuple-t ad vissza, amely tartalmazza a legmagasabb pontszámot, legalacsonyabb pontszámot és az ezekből a pontszámokból számított átlagpontszámot.\n\n  Argumentumok:\n  - scores: Egy Vec<i32>, amely a diákok vizsgapontszámait tartalmazza.\n\n  Visszatér:\n  - Egy tuple (i32, i32, f64), ahol az első elem a legmagasabb pontszám, a második a legalacsonyabb pontszám, és a harmadik az átlagpontszám, két tizedesjegyre kerekítve.\n\n  Példa:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) visszaadja (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) visszaadja (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) visszaadja (50, 50, 50.00)\n*/\nfn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)"
    },
    "prompt_bertscore": {
      "sq": "0.9909909204377816",
      "hy": "0.9811831481134219",
      "bn": "0.9802595168416097",
      "bg": "0.9689510919885315",
      "zh": "0.9696268325448122",
      "fr": "0.983033787373524",
      "de": "0.9726581307897856",
      "ha": "0.9691405853720387",
      "hi": "0.9835476441692612",
      "hu": "0.9841939874291488"
    },
    "canonical_solution": "{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}",
    "instruction": {
      "en": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nRust կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nBa da bayanin takaitaccen harshe na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)\n{\n    let mut highest = i32::MIN;\n    let mut lowest = i32::MAX;\n    let mut sum = 0;\n\n    for &score in &scores {\n        highest = highest.max(score);\n        lowest = lowest.min(score);\n        sum += score;\n    }\n    let average = (sum as f64) / (scores.len() as f64);\n    (highest, lowest, (average * 100.0).round() / 100.0)\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8922225593593266",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.940499077578713",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]), (99, 10, 71.29));\n        assert_eq!(exam_statistics(vec![100, 85, 76, 90]), (100, 76, 87.75));\n        assert_eq!(exam_statistics(vec![50, 50, 50, 50]), (50, 50, 50.00));\n    }\n}",
    "entry_point": "exam_statistics",
    "signature": "fn exam_statistics(scores: Vec<i32>) -> (i32, i32, f64)",
    "docstring": {
      "en": "Calculates the highest score, lowest score, and average score from a list of student scores.\n  \n  The function takes a vector of integer scores, each ranging from 0 to 100, representing the scores of students in an exam. It returns a tuple containing the highest score, lowest score, and the average score calculated from these scores.\n\n  Arguments:\n  - scores: A Vec<i32> containing the exam scores of students.\n\n  Returns:\n  - A tuple (i32, i32, f64), where the first element is the highest score, the second is the lowest score, and the third is the average score rounded to two decimal places.\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "sq": "Llogarit rezultatin më të lartë, rezultatin më të ulët dhe rezultatin mesatar nga një listë e rezultateve të studentëve.\n\nFunksioni merr një vektor të rezultateve të plota, secili duke variuar nga 0 deri në 100, që përfaqësojnë rezultatet e studentëve në një provim. Ai kthen një tuple që përmban rezultatin më të lartë, rezultatin më të ulët dhe rezultatin mesatar të llogaritur nga këto rezultate.\n\nArgumentet:\n- scores: Një Vec<i32> që përmban rezultatet e provimit të studentëve.\n\nKthen:\n- Një tuple (i32, i32, f64), ku elementi i parë është rezultati më i lartë, i dyti është rezultati më i ulët, dhe i treti është rezultati mesatar i rrumbullakosur në dy vende dhjetore.\n\nShembull:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) kthen (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) kthen (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) kthen (50, 50, 50.00)",
      "hy": "Հաշվում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը ուսանողների միավորների ցուցակից:\n\nՖունկցիան ընդունում է ամբողջ թվերի միավորների վեկտոր, որոնցից յուրաքանչյուրը տատանվում է 0-ից մինչև 100, ներկայացնելով ուսանողների քննության միավորները: Այն վերադարձնում է տյուփլ, որը պարունակում է ամենաբարձր միավորը, ամենացածր միավորը և միջին միավորը, հաշվարկված այս միավորներից:\n\nԱրձանագրություններ:\n- scores: A Vec<i32>, որը պարունակում է ուսանողների քննության միավորները:\n\nՎերադարձնում է:\n- Տյուփլ (i32, i32, f64), որտեղ առաջին տարրը ամենաբարձր միավորն է, երկրորդը՝ ամենացածր միավորը, իսկ երրորդը՝ միջին միավորը, կլորացված մինչև երկու տասնորդական թվանշան:\n\nՕրինակ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) վերադարձնում է (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) վերադարձնում է (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) վերադարձնում է (50, 50, 50.00)",
      "bn": "সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং গড় স্কোর গণনা করে একটি ছাত্রের স্কোরের তালিকা থেকে।\n\nফাংশনটি একটি পূর্ণসংখ্যার স্কোরের ভেক্টর নেয়, প্রতিটি 0 থেকে 100 এর মধ্যে, যা একটি পরীক্ষায় ছাত্রদের স্কোর উপস্থাপন করে। এটি একটি টুপল প্রদান করে যা সর্বোচ্চ স্কোর, সর্বনিম্ন স্কোর এবং এই স্কোরগুলি থেকে গণনা করা গড় স্কোর ধারণ করে।\n\nআর্গুমেন্টস:\n- scores: একটি Vec<i32> যা ছাত্রদের পরীক্ষার স্কোর ধারণ করে।\n\nরিটার্নস:\n- একটি টুপল (i32, i32, f64), যেখানে প্রথম উপাদানটি সর্বোচ্চ স্কোর, দ্বিতীয়টি সর্বনিম্ন স্কোর, এবং তৃতীয়টি গড় স্কোর যা দুই দশমিক স্থানে রাউন্ড করা হয়।\n\nউদাহরণ:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) প্রদান করে (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) প্রদান করে (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) প্রদান করে (50, 50, 50.00)",
      "bg": "Изчислява най-високата оценка, най-ниската оценка и средната оценка от списък с оценки на ученици.\n\nФункцията приема вектор от цели числа, всяко от които е в диапазона от 0 до 100, представляващи оценките на учениците на изпит. Тя връща кортеж, съдържащ най-високата оценка, най-ниската оценка и средната оценка, изчислена от тези оценки.\n\nАргументи:\n- scores: Vec<i32>, съдържащ изпитните оценки на учениците.\n\nВръща:\n- Кортеж (i32, i32, f64), където първият елемент е най-високата оценка, вторият е най-ниската оценка, а третият е средната оценка, закръглена до два знака след десетичната запетая.\n\nПример:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) връща (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) връща (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) връща (50, 50, 50.00)",
      "zh": "计算学生成绩列表中的最高分、最低分和平均分。\n\n该函数接受一个整数分数的向量，每个分数范围从0到100，表示学生在考试中的分数。它返回一个包含最高分、最低分和从这些分数计算出的平均分的元组。\n\n参数：\n- scores: 一个 Vec<i32>，包含学生的考试成绩。\n\n返回：\n- 一个元组 (i32, i32, f64)，其中第一个元素是最高分，第二个是最低分，第三个是平均分，四舍五入到小数点后两位。\n\n示例：\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) 返回 (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) 返回 (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) 返回 (50, 50, 50.00)",
      "fr": "Calcule le score le plus élevé, le score le plus bas et le score moyen à partir d'une liste de scores d'étudiants.\n\n  La fonction prend un vecteur de scores entiers, chacun allant de 0 à 100, représentant les scores des étudiants à un examen. Elle retourne un tuple contenant le score le plus élevé, le score le plus bas et le score moyen calculé à partir de ces scores.\n\n  Arguments:\n  - scores: Un Vec<i32> contenant les scores d'examen des étudiants.\n\n  Retourne:\n  - Un tuple (i32, i32, f64), où le premier élément est le score le plus élevé, le second est le score le plus bas, et le troisième est le score moyen arrondi à deux décimales.\n\n  Exemple:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "de": "Berechnet die höchste Punktzahl, die niedrigste Punktzahl und die durchschnittliche Punktzahl aus einer Liste von Schülernoten.\n\nDie Funktion nimmt einen Vektor von Ganzzahlen entgegen, die jeweils von 0 bis 100 reichen und die Noten der Schüler in einer Prüfung darstellen. Sie gibt ein Tupel zurück, das die höchste Punktzahl, die niedrigste Punktzahl und die durchschnittliche Punktzahl enthält, die aus diesen Noten berechnet werden.\n\nArgumente:\n- scores: Ein Vec<i32>, das die Prüfungsergebnisse der Schüler enthält.\n\nRückgabewerte:\n- Ein Tupel (i32, i32, f64), wobei das erste Element die höchste Punktzahl ist, das zweite die niedrigste Punktzahl und das dritte die durchschnittliche Punktzahl, gerundet auf zwei Dezimalstellen.\n\nBeispiel:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) gibt (99, 10, 71.29) zurück\n- exam_statistics(vec![100, 85, 76, 90]) gibt (100, 76, 87.75) zurück\n- exam_statistics(vec![50, 50, 50, 50]) gibt (50, 50, 50.00) zurück",
      "ha": "Lissafa mafi girman maki, mafi ƙanƙanta maki, da matsakaicin maki daga jerin maki na ɗalibai.\n\n  Aikin yana ɗaukar jerin maki na ɗalibai, kowanne yana tsakanin 0 zuwa 100, wanda ke wakiltar maki na ɗalibai a jarrabawa. Yana dawowa da tuple wanda ke ɗauke da mafi girman maki, mafi ƙarancin maki, da matsakaicin maki da aka ƙididdige daga waɗannan maki.\n\n  Huɗɗa:\n  - scores: A Vec<i32> wanda ke ɗauke da maki na jarrabawar ɗalibai.\n\n  Dawowa:\n  - A tuple (i32, i32, f64), inda na farko shine mafi girman maki, na biyu shine mafi ƙarancin maki, kuma na uku shine matsakaicin maki da aka zagaye zuwa wurare biyu na goma.\n\n  Misali:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "hi": "एक सूची में छात्रों के अंकों से उच्चतम स्कोर, न्यूनतम स्कोर, और औसत स्कोर की गणना करता है।\n\n  यह फ़ंक्शन छात्रों के स्कोर की एक सूची लेता है, जिसमें प्रत्येक स्कोर 0 से 100 के बीच होता है, जो परीक्षा में छात्रों के स्कोर का प्रतिनिधित्व करता है। यह एक टपल लौटाता है जिसमें सबसे उच्च स्कोर, सबसे निम्न स्कोर, और इन स्कोरों से गणना की गई औसत स्कोर शामिल होता है।\n\n  Arguments:\n  - scores: छात्रों के परीक्षा स्कोर वाली एक Vec<i32>।\n\n  Returns:\n  - एक टपल (i32, i32, f64), जहाँ पहला तत्व सबसे उच्च स्कोर है, दूसरा सबसे निम्न स्कोर है, और तीसरा औसत स्कोर है जो दो दशमलव स्थानों तक गोल किया गया है।\n\n  Example:\n  - exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) returns (99, 10, 71.29)\n  - exam_statistics(vec![100, 85, 76, 90]) returns (100, 76, 87.75)\n  - exam_statistics(vec![50, 50, 50, 50]) returns (50, 50, 50.00)",
      "hu": "Kiszámítja a legmagasabb pontszámot, legalacsonyabb pontszámot és az átlagos pontszámot egy hallgatói pontszámok listájából.\n\nA függvény egy egész számokat tartalmazó vektort vesz át, amelyek mindegyike 0 és 100 között van, és a hallgatók vizsgaeredményeit képviselik. Egy olyan tuple-t ad vissza, amely tartalmazza a legmagasabb pontszámot, a legalacsonyabb pontszámot és az ezen pontszámokból számított átlagos pontszámot.\n\nArgumentumok:\n- scores: Egy Vec<i32>, amely a hallgatók vizsgaeredményeit tartalmazza.\n\nVisszatérési érték:\n- Egy tuple (i32, i32, f64), ahol az első elem a legmagasabb pontszám, a második a legalacsonyabb pontszám, és a harmadik az átlagos pontszám, két tizedesjegyre kerekítve.\n\nPélda:\n- exam_statistics(vec![80, 92, 56, 74, 88, 99, 10]) visszaadja (99, 10, 71.29)\n- exam_statistics(vec![100, 85, 76, 90]) visszaadja (100, 76, 87.75)\n- exam_statistics(vec![50, 50, 50, 50]) visszaadja (50, 50, 50.00)"
    },
    "docstring_bertscore": {
      "sq": "0.9908532695837244",
      "hy": "0.9889140411736809",
      "bn": "0.9695144077491464",
      "bg": "0.9501026578713688",
      "zh": "0.9846550085435307",
      "fr": "0.981485066292595",
      "de": "0.9796969956025189",
      "ha": "0.9782630828818281",
      "hi": "0.9767006563046076",
      "hu": "0.9780153907966775"
    }
  },
  {
    "task_id": "Rust/8",
    "prompt": {
      "en": "/*\n  Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "sq": "/*\n  Llogarit shumën e pikëve për të gjitha nënvargjet jo-bosh të një vargu të dhënë, ku pika e një nënvargu përcaktohet si numri i karaktereve që shfaqen saktësisht një herë në të.\n\n  Argumentet:\n  - s: Një varg që përbëhet nga shkronja të vogla të anglishtes.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson shumën totale të pikëve për të gjitha nënvargjet jo-bosh.\n\n  Shembull:\n  - sum_of_unique_chars_scores(\"abc\") kthen 10 (Pikët: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") kthen 4 (Pikët: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "hy": "/*\n  Հաշվում է տրված տողի բոլոր ոչ դատարկ ենթատողերի գնահատականների գումարը, որտեղ ենթատողի գնահատականը սահմանվում է որպես այն սիմվոլների քանակը, որոնք հայտնվում են հենց մեկ անգամ:\n\n  Փաստարկներ:\n  - s: Տող, որը բաղկացած է փոքրատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է ոչ դատարկ ենթատողերի գնահատականների ընդհանուր գումարը:\n\n  Օրինակ:\n  - sum_of_unique_chars_scores(\"abc\") վերադարձնում է 10 (Գնահատականներ: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") վերադարձնում է 4 (Գնահատականներ: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "bn": "/*\n  প্রদত্ত স্ট্রিং-এর সমস্ত নন-এম্পটি সাবস্ট্রিং-এর স্কোরের যোগফল গণনা করে, যেখানে একটি সাবস্ট্রিং-এর স্কোর সংজ্ঞায়িত করা হয় সেই চরিত্রগুলির গণনা হিসাবে যা এতে ঠিক একবার উপস্থিত হয়।\n\n  আর্গুমেন্টসমূহ:\n  - s: ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n\n  রিটার্ন:\n  - একটি পূর্ণসংখ্যা যা সমস্ত নন-এম্পটি সাবস্ট্রিং-এর স্কোরের মোট যোগফল উপস্থাপন করে।\n\n  উদাহরণ:\n  - sum_of_unique_chars_scores(\"abc\") 10 রিটার্ন করে (স্কোরসমূহ: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 রিটার্ন করে (স্কোরসমূহ: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "bg": "/*\n  Изчислява сумата от точките за всички непразни поднизове на даден низ, където точката на подниза е дефинирана като броя на символите, които се появяват точно веднъж в него.\n\n  Аргументи:\n  - s: Низ, състоящ се от малки английски букви.\n\n  Връща:\n  - Цяло число, представляващо общата сума от точките за всички непразни поднизове.\n\n  Пример:\n  - sum_of_unique_chars_scores(\"abc\") връща 10 (Точки: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") връща 4 (Точки: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "zh": "/*\n  计算给定字符串的所有非空子字符串的分数总和，其中子字符串的分数定义为在其中恰好出现一次的字符的计数。\n\n  参数:\n  - s: 一个由小写英文字母组成的字符串。\n\n  返回:\n  - 一个整数，表示所有非空子字符串的分数总和。\n\n  示例:\n  - sum_of_unique_chars_scores(\"abc\") 返回 10 (分数: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 返回 4 (分数: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "fr": "/*\n  Calcule la somme des scores pour toutes les sous-chaînes non vides d'une chaîne donnée, où le score d'une sous-chaîne est défini comme le nombre de caractères qui apparaissent exactement une fois dans celle-ci.\n\n  Arguments:\n  - s: Une chaîne composée de lettres minuscules anglaises.\n\n  Renvoie:\n  - Un entier représentant la somme totale des scores pour toutes les sous-chaînes non vides.\n\n  Exemple:\n  - sum_of_unique_chars_scores(\"abc\") renvoie 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") renvoie 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "de": "/*\n  Berechnet die Summe der Punktzahlen für alle nicht-leeren Teilstrings eines gegebenen Strings, wobei die Punktzahl eines Teilstrings als die Anzahl der Zeichen definiert ist, die genau einmal darin vorkommen.\n\n  Argumente:\n  - s: Ein String, bestehend aus Kleinbuchstaben des englischen Alphabets.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Gesamtsumme der Punktzahlen für alle nicht-leeren Teilstrings darstellt.\n\n  Beispiel:\n  - sum_of_unique_chars_scores(\"abc\") gibt 10 zurück (Punktzahlen: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") gibt 4 zurück (Punktzahlen: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "ha": "/*\n  Lissafi jimillar maki na dukkan ƙananan kirtani marasa komai na kirtani da aka bayar, inda maki na ƙananan kirtani aka bayyana shi da ƙidayar haruffa waɗanda suka bayyana sau ɗaya kawai a ciki.\n\n  Huɗɗa:\n  - s: Wani kirtani da ya ƙunshi ƙananan haruffan Ingilishi.\n\n  Mayarwa:\n  - Wani cikakken lamba da ke wakiltar jimillar maki na dukkan ƙananan kirtani marasa komai.\n\n  Misali:\n  - sum_of_unique_chars_scores(\"abc\") yana mayar da 10 (Maki: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") yana mayar da 4 (Maki: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "hi": "/*\n  दिए गए स्ट्रिंग के सभी गैर-खाली उपस्ट्रिंग्स के स्कोर का योग गणना करता है, जहाँ उपस्ट्रिंग का स्कोर उन वर्णों की गिनती के रूप में परिभाषित किया गया है जो उसमें केवल एक बार प्रकट होते हैं।\n\n  तर्क:\n  - s: छोटे अक्षरों वाले अंग्रेजी अक्षरों से बना एक स्ट्रिंग।\n\n  लौटाता है:\n  - एक पूर्णांक जो सभी गैर-खाली उपस्ट्रिंग्स के स्कोर के कुल योग का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - sum_of_unique_chars_scores(\"abc\") 10 लौटाता है (स्कोर: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 लौटाता है (स्कोर: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 ",
      "hu": "/*\n  Kiszámítja az összes nem üres részsztring pontszámának összegét egy adott sztring esetén, ahol a részsztring pontszámát az egyszer pontosan egyszer előforduló karakterek száma határozza meg.\n\n  Argumentumok:\n  - s: Egy sztring, amely kisbetűs angol betűkből áll.\n\n  Visszatérési érték:\n  - Egy egész szám, amely az összes nem üres részsztring pontszámának összegét jelenti.\n\n  Példa:\n  - sum_of_unique_chars_scores(\"abc\") visszaadja 10 (Pontszámok: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") visszaadja 4 (Pontszámok: a=0, a=0, b=1, aa=0, ab=1, aab=1)\n*/\n\nfn sum_of_unique_chars_scores(s: &str) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9966989616975812",
      "hy": "0.9824398825342296",
      "bn": "0.9930572722916875",
      "bg": "0.9886977326887338",
      "zh": "0.9738443514253259",
      "fr": "0.9957938030512052",
      "de": "0.9783331994063333",
      "ha": "0.9667800619238202",
      "hi": "0.9873367173178828",
      "hu": "0.9741432901487834"
    },
    "canonical_solution": "{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}",
    "instruction": {
      "en": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nՏվեք Rust կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn sum_of_unique_chars_scores(s: &str) -> i32\n{\n    let mut total_score = 0;\n    let s_chars: Vec<char> = s.chars().collect();\n    let n = s_chars.len();\n\n    for i in 0..n {\n        let mut char_count = [0; 26];\n        for j in i..n {\n            let index = (s_chars[j] as usize) - ('a' as usize);\n            char_count[index] += 1;\n\n            let mut score = 0;\n            for &count in char_count.iter() {\n                if count == 1 {\n                    score += 1;\n                }\n            }\n\n            total_score += score;\n        }\n    }\n    total_score\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9358390102092535",
      "hy": "0.9450334119169774",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.912043289191655",
      "hi": "0.9047321021265228",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(sum_of_unique_chars_scores(\"abc\"), 10); // a=1, b=1, c=1, ab=2, bc=2, abc=3\n        assert_eq!(sum_of_unique_chars_scores(\"aab\"), 6);  // a=1, a=1, b=1, aa=0, ab=2, aab=1\n        assert_eq!(sum_of_unique_chars_scores(\"ababc\"), 21);\n    }\n\n\n}",
    "entry_point": "sum_of_unique_chars_scores",
    "signature": "fn sum_of_unique_chars_scores(s: &str) -> i32",
    "docstring": {
      "en": "Calculates the sum of scores for all non-empty substrings of a given string, where the score of a substring is defined as the count of characters that appear exactly once in it.\n\n  Arguments:\n  - s: A string consisting of lowercase English letters.\n\n  Returns:\n  - An integer representing the total sum of scores for all non-empty substrings.\n\n  Example:\n  - sum_of_unique_chars_scores(\"abc\") returns 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") returns 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "sq": "Llogarit shumën e pikëve për të gjitha nënvargjet jo bosh të një vargu të dhënë, ku pika e një nënvargu përcaktohet si numri i karaktereve që shfaqen saktësisht një herë në të.\n\n  Argumentet:\n  - s: Një varg që përbëhet nga shkronjat e vogla të anglishtes.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson shumën totale të pikëve për të gjitha nënvargjet jo bosh.\n\n  Shembull:\n  - sum_of_unique_chars_scores(\"abc\") kthen 10 (Pikët: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") kthen 4 (Pikët: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hy": "Հաշվում է տրված տողի բոլոր ոչ դատարկ ենթատողերի միավորների գումարը, որտեղ ենթատողի միավորը սահմանվում է որպես այնպիսի սիմվոլների քանակը, որոնք հայտնվում են հենց մեկ անգամ:\n\n  Արձանագրություններ:\n  - s: Տող, որը բաղկացած է փոքրատառ անգլերեն տառերից:\n\n  Վերադարձնում է:\n  - Թիվ, որը ներկայացնում է բոլոր ոչ դատարկ ենթատողերի միավորների ընդհանուր գումարը:\n\n  Օրինակ:\n  - sum_of_unique_chars_scores(\"abc\") վերադարձնում է 10 (Միավորներ: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") վերադարձնում է 4 (Միավորներ: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "bn": "প্রদত্ত স্ট্রিংয়ের সমস্ত অ-খালি সাবস্ট্রিংয়ের স্কোরের যোগফল গণনা করে, যেখানে একটি সাবস্ট্রিংয়ের স্কোর সংজ্ঞায়িত করা হয় এতে ঠিক একবার উপস্থিত হওয়া অক্ষরের সংখ্যা হিসাবে।\n\n  আর্গুমেন্টস:\n  - s: ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা সমস্ত অ-খালি সাবস্ট্রিংয়ের জন্য স্কোরের মোট যোগফল উপস্থাপন করে।\n\n  উদাহরণ:\n  - sum_of_unique_chars_scores(\"abc\") 10 রিটার্ন করে (স্কোর: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 রিটার্ন করে (স্কোর: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "bg": "Изчислява сумата от точките за всички непразни поднизове на даден низ, където точката на подниза се дефинира като броя на символите, които се появяват точно веднъж в него.\n\nАргументи:\n- s: Низ, състоящ се от малки английски букви.\n\nВръща:\n- Цяло число, представляващо общата сума от точките за всички непразни поднизове.\n\nПример:\n- sum_of_unique_chars_scores(\"abc\") връща 10 (Точки: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n- sum_of_unique_chars_scores(\"aab\") връща 4 (Точки: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "zh": "计算给定字符串的所有非空子字符串的分数总和，其中子字符串的分数定义为其中恰好出现一次的字符的数量。\n\n参数：\n- s: 一个由小写英文字母组成的字符串。\n\n返回：\n- 一个整数，表示所有非空子字符串的分数总和。\n\n示例：\n- sum_of_unique_chars_scores(\"abc\") 返回 10 （分数：a=1, b=1, c=1, ab=2, bc=2, abc=3）\n- sum_of_unique_chars_scores(\"aab\") 返回 4 （分数：a=0, a=0, b=1, aa=0, ab=1, aab=1）",
      "fr": "Calcule la somme des scores pour toutes les sous-chaînes non vides d'une chaîne donnée, où le score d'une sous-chaîne est défini comme le nombre de caractères qui apparaissent exactement une fois dans celle-ci.\n\n  Arguments:\n  - s: Une chaîne composée de lettres minuscules anglaises.\n\n  Retourne:\n  - Un entier représentant la somme totale des scores pour toutes les sous-chaînes non vides.\n\n  Exemple:\n  - sum_of_unique_chars_scores(\"abc\") retourne 10 (Scores: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") retourne 4 (Scores: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "de": "Berechnet die Summe der Punktzahlen für alle nicht-leeren Teilstrings eines gegebenen Strings, wobei die Punktzahl eines Teilstrings als die Anzahl der Zeichen definiert ist, die genau einmal darin vorkommen.\n\n  Argumente:\n  - s: Ein String, bestehend aus englischen Kleinbuchstaben.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Gesamtsumme der Punktzahlen für alle nicht-leeren Teilstrings darstellt.\n\n  Beispiel:\n  - sum_of_unique_chars_scores(\"abc\") gibt 10 zurück (Punktzahlen: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") gibt 4 zurück (Punktzahlen: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "ha": "Lissafa jimillar maki na dukkan ƙananan rubutattun kirtani marasa komai na wani kirtani da aka bayar, inda maki na kowane ƙaramin kirtani aka ayyana shi a matsayin adadin haruffa da suka bayyana sau ɗaya kawai a ciki.\n\n  Huɗɗa:\n  - s: Wani igiyar haruffa da ya ƙunshi ƙananan haruffan Ingilishi.\n\n  Komawa:\n  - Wani lamba wanda ke wakiltar jimlar maki na dukkan ƙananan igiyoyi marasa komai.\n\n  Misali:\n  - sum_of_unique_chars_scores(\"abc\") yana dawowa 10 (Maki: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") yana dawowa 4 (Maki: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hi": "गणना करता है कि दिए गए स्ट्रिंग के सभी गैर-खाली उपस्ट्रिंग्स के लिए स्कोर का योग, जहाँ उपस्ट्रिंग का स्कोर उन वर्णों की गिनती के रूप में परिभाषित किया गया है जो उसमें केवल एक बार प्रकट होते हैं।\n\n  तर्क:\n  - s: एक स्ट्रिंग जो छोटे अंग्रेजी अक्षरों से बनी होती है।\n\n  वापसी:\n  - एक पूर्णांक जो सभी गैर-खाली उपस्ट्रिंग्स के लिए स्कोर के कुल योग का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - sum_of_unique_chars_scores(\"abc\") 10 लौटाता है (स्कोर: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") 4 लौटाता है (स्कोर: a=0, a=0, b=1, aa=0, ab=1, aab=1)",
      "hu": "Kiszámítja az összes nem üres részsztring pontszámának összegét egy adott sztring esetén, ahol a részsztring pontszámát az egyszer pontosan egyszer előforduló karakterek száma határozza meg.\n\n  Argumentumok:\n  - s: Egy sztring, amely kisbetűs angol betűkből áll.\n\n  Visszatér:\n  - Egy egész szám, amely az összes nem üres részsztring pontszámának összegét jelenti.\n\n  Példa:\n  - sum_of_unique_chars_scores(\"abc\") visszatér 10 (Pontszámok: a=1, b=1, c=1, ab=2, bc=2, abc=3)\n  - sum_of_unique_chars_scores(\"aab\") visszatér 4 (Pontszámok: a=0, a=0, b=1, aa=0, ab=1, aab=1)"
    },
    "docstring_bertscore": {
      "sq": "0.9946780962009323",
      "hy": "0.9746257633443172",
      "bn": "0.9814250799175225",
      "bg": "0.9774578353171126",
      "zh": "0.9639543461232178",
      "fr": "0.9935621907202783",
      "de": "0.9737212005890843",
      "ha": "0.9816264911238918",
      "hi": "0.9968389961162107",
      "hu": "0.9789868919903192"
    }
  },
  {
    "task_id": "Rust/9",
    "prompt": {
      "en": "/*\n  Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "sq": "/*\n  Gjeneron një sekuencë numrash të plotë ku secili numër pasues është gjysma e numrit të mëparshëm, i rrumbullakosur poshtë, duke filluar nga një vlerë fillestare.\n\n  Argumentet:\n  - initial_value: Një numër i plotë që përfaqëson vlerën fillestare të sekuencës.\n\n  Kthen:\n  - Një vektor numrash të plotë që përfaqëson sekuencën ku secili element është gjysma e paraardhësit të tij, duke ndaluar kur vlera bëhet më pak se 1.\n\n  Shembull:\n  - generate_dividing_sequence(20) kthen [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) kthen [5, 2, 1]\n  - generate_dividing_sequence(1) kthen [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "hy": "/*\n  Գեներացնում է ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր հաջորդ ամբողջ թիվը նախորդի կեսն է, կլորացված ներքև, սկսելով սկզբնական արժեքից։\n\n  Արգումենտներ:\n  - initial_value: Ամբողջ թիվ, որը ներկայացնում է հաջորդականության մեկնարկային արժեքը։\n\n  Վերադարձնում է:\n  - Ամբողջ թվերի վեկտոր, որը ներկայացնում է հաջորդականությունը, որտեղ յուրաքանչյուր տարր նախորդի կեսն է, կանգ առնելով, երբ արժեքը դառնում է պակաս քան 1։\n\n  Օրինակ:\n  - generate_dividing_sequence(20) վերադարձնում է [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) վերադարձնում է [5, 2, 1]\n  - generate_dividing_sequence(1) վերադարձնում է [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "bn": "/*\n  একটি পূর্ণসংখ্যার ক্রম তৈরি করে যেখানে প্রতিটি পরবর্তী পূর্ণসংখ্যা পূর্ববর্তীটির অর্ধেক হয়, নিচের দিকে পূর্ণসংখ্যায় পরিণত হয়, একটি প্রাথমিক মান থেকে শুরু করে।\n\n  আর্গুমেন্ট:\n  - initial_value: ক্রমের প্রারম্ভিক মান উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - পূর্ণসংখ্যার একটি ভেক্টর যা ক্রমকে উপস্থাপন করে যেখানে প্রতিটি উপাদান তার পূর্বসূরির অর্ধেক, যখন মান 1 এর চেয়ে কম হয়ে যায় তখন থামে।\n\n  উদাহরণ:\n  - generate_dividing_sequence(20) রিটার্ন করে [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) রিটার্ন করে [5, 2, 1]\n  - generate_dividing_sequence(1) রিটার্ন করে [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "bg": "/*\n  Генерира последователност от цели числа, където всяко следващо число е половината от предишното, закръглено надолу, започвайки от начална стойност.\n\n  Аргументи:\n  - initial_value: Цяло число, представляващо началната стойност на последователността.\n\n  Връща:\n  - Вектор от цели числа, представляващ последователността, където всеки елемент е половината от своя предшественик, спирайки когато стойността стане по-малка от 1.\n\n  Пример:\n  - generate_dividing_sequence(20) връща [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) връща [5, 2, 1]\n  - generate_dividing_sequence(1) връща [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "zh": "/*\n  生成一个整数序列，其中每个后续整数是前一个整数的一半，向下取整，从初始值开始。\n\n  参数:\n  - initial_value: 表示序列起始值的整数。\n\n  返回:\n  - 一个整数向量，表示序列，其中每个元素是其前一个元素的一半，当值小于1时停止。\n\n  示例:\n  - generate_dividing_sequence(20) 返回 [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) 返回 [5, 2, 1]\n  - generate_dividing_sequence(1) 返回 [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "fr": "/*\n  Génère une séquence d'entiers où chaque entier suivant est la moitié de celui qui le précède, arrondi à l'entier inférieur, en commençant par une valeur initiale.\n\n  Arguments:\n  - initial_value: Un entier représentant la valeur de départ de la séquence.\n\n  Retourne:\n  - Un vecteur d'entiers représentant la séquence où chaque élément est la moitié de son prédécesseur, s'arrêtant lorsque la valeur devient inférieure à 1.\n\n  Exemple:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "de": "/*\n  Erzeugt eine Sequenz von ganzen Zahlen, bei der jede nachfolgende Zahl die Hälfte der vorherigen ist, abgerundet, beginnend mit einem Anfangswert.\n\n  Argumente:\n  - initial_value: Eine ganze Zahl, die den Startwert der Sequenz darstellt.\n\n  Rückgabewert:\n  - Ein Vektor von ganzen Zahlen, der die Sequenz darstellt, bei der jedes Element die Hälfte seines Vorgängers ist und endet, wenn der Wert kleiner als 1 wird.\n\n  Beispiel:\n  - generate_dividing_sequence(20) gibt [20, 10, 5, 2, 1] zurück\n  - generate_dividing_sequence(5) gibt [5, 2, 1] zurück\n  - generate_dividing_sequence(1) gibt [1] zurück\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "ha": "/*\n  Yana ƙirƙirar jerin lambobi inda kowanne lamba na gaba ya kasance rabin wanda ya gabace shi, an zagaye ƙasa, farawa daga wata ƙima ta farko.\n\n  Huɗɗa:\n  - initial_value: Wani lamba wanda ke wakiltar ƙimar farawa na jerin.\n\n  Komawa:\n  - Wani vector na lambobi wanda ke wakiltar jerin inda kowanne abu ya kasance rabin wanda ya gabace shi, yana tsayawa lokacin da ƙimar ta zama ƙasa da 1.\n\n  Misali:\n  - generate_dividing_sequence(20) yana dawowa [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) yana dawowa [5, 2, 1]\n  - generate_dividing_sequence(1) yana dawowa [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "hi": "/*\n  एक अनुक्रम उत्पन्न करता है जहाँ प्रत्येक अगला पूर्णांक पिछले वाले का आधा होता है, नीचे की ओर गोल करते हुए, एक प्रारंभिक मान से शुरू होता है।\n\n  तर्क:\n  - initial_value: अनुक्रम के प्रारंभिक मान का प्रतिनिधित्व करने वाला एक पूर्णांक।\n\n  लौटाता है:\n  - पूर्णांकों का एक वेक्टर जो अनुक्रम का प्रतिनिधित्व करता है जहाँ प्रत्येक तत्व अपने पूर्ववर्ती का आधा होता है, जब मान 1 से कम हो जाता है तब रुक जाता है।\n\n  उदाहरण:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
      "hu": "/*\n  Generál egy egész számokból álló sorozatot, ahol minden következő egész szám az előző fele, lefelé kerekítve, egy kezdőértéktől indulva.\n\n  Argumentumok:\n  - initial_value: Egy egész szám, amely a sorozat kezdőértékét jelenti.\n\n  Visszatér:\n  - Egy egész számokat tartalmazó vektor, amely a sorozatot képviseli, ahol minden elem az elődjének a fele, és a sorozat akkor áll meg, amikor az érték kisebb lesz, mint 1.\n\n  Példa:\n  - generate_dividing_sequence(20) visszaadja [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) visszaadja [5, 2, 1]\n  - generate_dividing_sequence(1) visszaadja [1]\n*/\n\n\nfn generate_dividing_sequence(initial_value: i32) -> Vec<i32>"
    },
    "prompt_bertscore": {
      "sq": "0.9912449686951252",
      "hy": "0.9877077588696559",
      "bn": "0.9872366076058412",
      "bg": "0.9928314295484509",
      "zh": "0.9813456277651085",
      "fr": "0.9829922736238877",
      "de": "0.9875919573575126",
      "ha": "0.973673727928017",
      "hi": "0.9854797218855876",
      "hu": "0.976446608047264"
    },
    "canonical_solution": "{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}",
    "instruction": {
      "en": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nনিচের Rust কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nFournir une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>\n{\n    let mut sequence = Vec::new();\n    let mut current = initial_value;\n    while current >= 1 {\n        sequence.push(current);\n        current /= 2;\n    }\n    sequence\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9258661760382538",
      "bn": "0.8706957931842895",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9228718230441529",
      "hi": "0.9115359871984918",
      "hu": "0.9325771020918986"
    },
    "level": "",
    "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(generate_dividing_sequence(20), vec![20, 10, 5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(5), vec![5, 2, 1]);\n        assert_eq!(generate_dividing_sequence(1), vec![1]);\n        assert_eq!(generate_dividing_sequence(15), vec![15, 7, 3, 1]);        \n    }\n    \n\n}\n ",
    "entry_point": "generate_dividing_sequence",
    "signature": "fn generate_dividing_sequence(initial_value: i32) -> Vec<i32>",
    "docstring": {
      "en": "Generates a sequence of integers where each subsequent integer is half of the previous one, rounded down, starting from an initial value.\n\n  Arguments:\n  - initial_value: An integer representing the starting value of the sequence.\n\n  Returns:\n  - A vector of integers representing the sequence where each element is half of its predecessor, stopping when the value becomes less than 1.\n\n  Example:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "sq": "Gjeneron një sekuencë të numrave të plotë ku çdo numër pasues është gjysma e numrit të mëparshëm, i rrumbullakosur poshtë, duke filluar nga një vlerë fillestare.\n\n  Argumentet:\n  - initial_value: Një numër i plotë që përfaqëson vlerën fillestare të sekuencës.\n\n  Kthen:\n  - Një vektor të numrave të plotë që përfaqëson sekuencën ku çdo element është gjysma e paraardhësit të tij, duke ndaluar kur vlera bëhet më pak se 1.\n\n  Shembull:\n  - generate_dividing_sequence(20) kthen [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) kthen [5, 2, 1]\n  - generate_dividing_sequence(1) kthen [1]",
      "hy": "Ստեղծում է ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր հաջորդ ամբողջ թիվը նախորդի կեսն է, կլորացված ներքև, սկսելով սկզբնական արժեքից:\n\n  Արգումենտներ:\n  - initial_value: Ամբողջ թիվ, որը ներկայացնում է հաջորդականության մեկնարկային արժեքը:\n\n  Վերադարձնում է:\n  - Ամբողջ թվերի վեկտոր, որը ներկայացնում է հաջորդականությունը, որտեղ յուրաքանչյուր տարր նախորդի կեսն է, կանգ առնելով, երբ արժեքը դառնում է պակաս քան 1:\n\n  Օրինակ:\n  - generate_dividing_sequence(20) վերադարձնում է [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) վերադարձնում է [5, 2, 1]\n  - generate_dividing_sequence(1) վերադարձնում է [1]",
      "bn": "একটি পূর্ণসংখ্যার ক্রম তৈরি করে যেখানে প্রতিটি পরবর্তী পূর্ণসংখ্যা পূর্ববর্তীটির অর্ধেক হয়, নিচের দিকে গোল করে, একটি প্রাথমিক মান থেকে শুরু করে।\n\nArguments:\n- initial_value: পূর্ণসংখ্যা যা ক্রমের শুরুর মানকে উপস্থাপন করে।\n\nReturns:\n- পূর্ণসংখ্যার একটি ভেক্টর যা ক্রমকে উপস্থাপন করে যেখানে প্রতিটি উপাদান তার পূর্বসূরীর অর্ধেক, যখন মান 1 এর কম হয়ে যায় তখন থামে।\n\nExample:\n- generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n- generate_dividing_sequence(5) returns [5, 2, 1]\n- generate_dividing_sequence(1) returns [1]",
      "bg": "Генерира последователност от цели числа, където всяко следващо число е половината от предишното, закръглено надолу, започвайки от начална стойност.\n\nАргументи:\n- initial_value: Цяло число, представляващо началната стойност на последователността.\n\nВръща:\n- Вектор от цели числа, представляващ последователността, където всеки елемент е половината от предшественика си, спирайки когато стойността стане по-малка от 1.\n\nПример:\n- generate_dividing_sequence(20) връща [20, 10, 5, 2, 1]\n- generate_dividing_sequence(5) връща [5, 2, 1]\n- generate_dividing_sequence(1) връща [1]",
      "zh": "生成一个整数序列，其中每个后续整数是前一个整数的一半，向下取整，从初始值开始。\n\n  参数:\n  - initial_value: 一个整数，表示序列的起始值。\n\n  返回:\n  - 一个整数向量，表示序列，其中每个元素是其前一个元素的一半，当值小于1时停止。\n\n  示例:\n  - generate_dividing_sequence(20) 返回 [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) 返回 [5, 2, 1]\n  - generate_dividing_sequence(1) 返回 [1]",
      "fr": "Génère une séquence d'entiers où chaque entier suivant est la moitié de celui qui le précède, arrondi à l'entier inférieur, en commençant par une valeur initiale.\n\n  Arguments:\n  - initial_value: Un entier représentant la valeur de départ de la séquence.\n\n  Retourne:\n  - Un vecteur d'entiers représentant la séquence où chaque élément est la moitié de son prédécesseur, s'arrêtant lorsque la valeur devient inférieure à 1.\n\n  Exemple:\n  - generate_dividing_sequence(20) retourne [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) retourne [5, 2, 1]\n  - generate_dividing_sequence(1) retourne [1]",
      "de": "Erzeugt eine Folge von ganzen Zahlen, bei der jede nachfolgende Zahl die Hälfte der vorherigen ist, abgerundet, beginnend mit einem Anfangswert.\n\n  Argumente:\n  - initial_value: Eine ganze Zahl, die den Startwert der Folge darstellt.\n\n  Rückgabewerte:\n  - Ein Vektor von ganzen Zahlen, der die Folge darstellt, bei der jedes Element die Hälfte seines Vorgängers ist, und endet, wenn der Wert kleiner als 1 wird.\n\n  Beispiel:\n  - generate_dividing_sequence(20) gibt [20, 10, 5, 2, 1] zurück\n  - generate_dividing_sequence(5) gibt [5, 2, 1] zurück\n  - generate_dividing_sequence(1) gibt [1] zurück",
      "ha": "Yana samar da jerin lambobi inda kowanne lamba na gaba rabin wanda ya gabace shi ne, an zagaye kasa, farawa daga wata kima ta farko.\n\n  Huɗɗa:\n  - initial_value: Wani lamba wanda ke wakiltar ƙimar farawa na jerin.\n\n  Dawowa:\n  - Wani vector na lambobi wanda ke wakiltar jerin inda kowane abu yake rabin wanda ya gabace shi, yana tsayawa lokacin da ƙimar ta zama ƙasa da 1.\n\n  Misali:\n  - generate_dividing_sequence(20) returns [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) returns [5, 2, 1]\n  - generate_dividing_sequence(1) returns [1]",
      "hi": "आधारिक मान से शुरू होकर प्रत्येक क्रमिक पूर्णांक अपने पूर्ववर्ती का आधा होता है, नीचे की ओर पूर्णांकित, का अनुक्रम उत्पन्न करता है।\n\n  तर्क:\n  - initial_value: अनुक्रम के प्रारंभिक मान का प्रतिनिधित्व करने वाला एक पूर्णांक।\n\n  वापसी:\n  - पूर्णांकों का एक वेक्टर जो अनुक्रम का प्रतिनिधित्व करता है, जहाँ प्रत्येक तत्व अपने पूर्ववर्ती का आधा होता है, अनुक्रम तब रुकता है जब मान 1 से कम हो जाता है।\n\n  उदाहरण:\n  - generate_dividing_sequence(20) [20, 10, 5, 2, 1] लौटाता है\n  - generate_dividing_sequence(5) [5, 2, 1] लौटाता है\n  - generate_dividing_sequence(1) [1] लौटाता है",
      "hu": "Generál egy egész számokból álló sorozatot, ahol minden következő egész szám az előző fele, lefelé kerekítve, egy kezdeti értéktől kezdve.\n\n  Argumentumok:\n  - initial_value: Egy egész szám, amely a sorozat kezdő értékét jelenti.\n\n  Visszatér:\n  - Egy egész számokból álló vektor, amely a sorozatot képviseli, ahol minden elem az elődjének fele, és megáll, amikor az érték kisebb lesz, mint 1.\n\n  Példa:\n  - generate_dividing_sequence(20) visszaadja [20, 10, 5, 2, 1]\n  - generate_dividing_sequence(5) visszaadja [5, 2, 1]\n  - generate_dividing_sequence(1) visszaadja [1]"
    },
    "docstring_bertscore": {
      "sq": "0.9918605242459524",
      "hy": "0.9798082286158984",
      "bn": "0.9797460573066346",
      "bg": "0.9919826819302888",
      "zh": "0.9756073946873915",
      "fr": "0.9766271630636247",
      "de": "0.9754429287318948",
      "ha": "0.9689941947812161",
      "hi": "0.998628059958192",
      "hu": "0.9902961113649216"
    }
  },
  {
    "task_id": "Rust/10",
    "prompt": {
      "en": "/*\n  Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "sq": "/*\n  Zgjeron një varg të kompresuar ku karakteret e njëpasnjëshme përfaqësohen nga karakteri i ndjekur nga numri i tij.\n  Numri është një shifër e vetme (1-9), dhe specifikon sa herë shfaqet karakteri në mënyrë të njëpasnjëshme. Nëse një karakter shfaqet vetëm një herë, nuk ndiqet nga një numër.\n\n  Argumentet:\n  - compressed: Një varg që përmban formatin e kompresuar, i përbërë nga karaktere dhe numra njëshifrorë.\n\n  Kthen:\n  - Një varg që përfaqëson formën e zgjeruar të vargut të kompresuar.\n\n  Shembull:\n  - expand_compressed_string(\"a3b2c\") kthen \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") kthen \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") kthen \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "hy": "/*\n  Ընդլայնում է սեղմված տողը, որտեղ հաջորդական նիշերը ներկայացված են նիշով, որին հաջորդում է դրա քանակը:\n  Քանակը միանիշ թիվ է (1-9), և այն նշում է, թե քանի անգամ է նիշը հաջորդաբար հայտնվում: Եթե նիշը հայտնվում է միայն մեկ անգամ, ապա դրան չի հաջորդում քանակ:\n\n  Փաստարկներ:\n  - compressed: Տող, որը պարունակում է սեղմված ձևաչափը, բաղկացած նիշերից և միանիշ քանակներից:\n\n  Վերադարձնում է:\n  - Տող, որը ներկայացնում է սեղմված տողի ընդլայնված ձևը:\n\n  Օրինակ:\n  - expand_compressed_string(\"a3b2c\") վերադարձնում է \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") վերադարձնում է \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") վերադարձնում է \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "bn": "/*\n  একটি সংকুচিত স্ট্রিং প্রসারিত করে যেখানে পরপর অক্ষরগুলি অক্ষর দ্বারা উপস্থাপিত হয় এবং তারপরে তার সংখ্যা থাকে।\n  সংখ্যা একটি একক অঙ্ক (1-9), এবং এটি নির্দিষ্ট করে যে অক্ষরটি পরপর কতবার প্রদর্শিত হয়। যদি কোনো অক্ষর শুধুমাত্র একবার প্রদর্শিত হয়, তবে এটি সংখ্যার দ্বারা অনুসরণ করা হয় না।\n\n  আর্গুমেন্ট:\n  - compressed: একটি স্ট্রিং যা সংকুচিত ফরম্যাট ধারণ করে, যা অক্ষর এবং একক-অঙ্কের সংখ্যা নিয়ে গঠিত।\n\n  রিটার্নস:\n  - একটি স্ট্রিং যা সংকুচিত স্ট্রিংয়ের প্রসারিত রূপ উপস্থাপন করে।\n\n  উদাহরণ:\n  - expand_compressed_string(\"a3b2c\") রিটার্ন করে \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") রিটার্ন করে \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") রিটার্ন করে \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "bg": "/*\n  Разширява компресирана низ, където последователни символи са представени от символа, последван от неговата бройка.\n  Бройката е едноцифрено число (1-9), и тя указва колко пъти символът се появява последователно. Ако символ се появява само веднъж, не е последван от бройка.\n\n  Аргументи:\n  - compressed: Низ, съдържащ компресирания формат, състоящ се от символи и едноцифрени бройки.\n\n  Връща:\n  - Низ, представляващ разширената форма на компресирания низ.\n\n  Пример:\n  - expand_compressed_string(\"a3b2c\") връща \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") връща \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") връща \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "zh": "/*\n  展开一个压缩字符串，其中连续字符由字符后跟其计数表示。\n  计数是一个单一数字（1-9），它指定字符连续出现的次数。如果字符只出现一次，则不跟随计数。\n\n  参数:\n  - compressed: 一个包含压缩格式的字符串，由字符和单一数字计数组成。\n\n  返回:\n  - 一个字符串，表示压缩字符串的展开形式。\n\n  示例:\n  - expand_compressed_string(\"a3b2c\") 返回 \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") 返回 \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") 返回 \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "fr": "/*\n  Développe une chaîne compressée où les caractères consécutifs sont représentés par le caractère suivi de son nombre.\n  Le nombre est un chiffre unique (1-9), et il spécifie combien de fois le caractère apparaît consécutivement. Si un caractère apparaît une seule fois, il n'est pas suivi d'un nombre.\n\n  Arguments:\n  - compressed: Une chaîne contenant le format compressé, composée de caractères et de chiffres uniques.\n\n  Renvoie:\n  - Une chaîne représentant la forme développée de la chaîne compressée.\n\n  Exemple:\n  - expand_compressed_string(\"a3b2c\") renvoie \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") renvoie \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") renvoie \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "de": "/*\n  Erweitert einen komprimierten String, bei dem aufeinanderfolgende Zeichen durch das Zeichen gefolgt von seiner Anzahl dargestellt werden.\n  Die Anzahl ist eine einstellige Ziffer (1-9) und gibt an, wie oft das Zeichen hintereinander erscheint. Wenn ein Zeichen nur einmal vorkommt, folgt keine Anzahl.\n\n  Argumente:\n  - compressed: Ein String, der das komprimierte Format enthält, bestehend aus Zeichen und einstelligen Ziffern.\n\n  Rückgabewert:\n  - Ein String, der die erweiterte Form des komprimierten Strings darstellt.\n\n  Beispiel:\n  - expand_compressed_string(\"a3b2c\") gibt \"aaabbc\" zurück\n  - expand_compressed_string(\"H3el5o2\") gibt \"HHHellllloo\" zurück\n  - expand_compressed_string(\"x9y1z2\") gibt \"xxxxxxxxxyzz\" zurück\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "ha": "/*\n  Faɗaɗa wani matsejen zare inda haruffa masu jere suna wakilta ta harafin da aka biyo baya da adadinsa.\n  Adadin yana da lamba guda ɗaya (1-9), kuma yana nuna sau nawa harafin ya bayyana a jere. Idan harafi ya bayyana sau ɗaya kawai, ba a biyo shi da adadi.\n\n  Huɗɗa:\n  - compressed: Wani zare da ke ɗauke da tsarin matsejen, wanda ya ƙunshi haruffa da lambobi guda ɗaya.\n\n  Komawa:\n  - Wani zare da ke wakiltar faɗaɗa tsarin matsejen zaren.\n\n  Misali:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String",
      "hi": "/*\n  एक संकुचित स्ट्रिंग का विस्तार करता है जहाँ लगातार वर्णों को वर्ण के बाद उसकी गिनती द्वारा दर्शाया जाता है।\n  गिनती एकल अंक (1-9) होती है, और यह निर्दिष्ट करती है कि वर्ण कितनी बार लगातार प्रकट होता है। यदि कोई वर्ण केवल एक बार प्रकट होता है, तो उसके बाद गिनती नहीं होती है।\n\n  तर्क:\n  - compressed: एक स्ट्रिंग जिसमें संकुचित प्रारूप होता है, जिसमें वर्ण और एकल-अंक गिनती शामिल होती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग जो संकुचित स्ट्रिंग के विस्तारित रूप का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - expand_compressed_string(\"a3b2c\") \"aaabbc\" लौटाता है\n  - expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" लौटाता है\n  - expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" लौटाता है\n*/\n\nfn expand_compressed_string(compressed: &str) -> String ",
      "hu": "/*\n  Kibont egy tömörített karakterláncot, ahol az egymást követő karaktereket a karakter és a hozzá tartozó szám jelöli.\n  A szám egyjegyű (1-9), és azt adja meg, hogy a karakter hányszor jelenik meg egymás után. Ha egy karakter csak egyszer jelenik meg, akkor nem követi szám.\n\n  Argumentumok:\n  - compressed: Egy karakterlánc, amely a tömörített formátumot tartalmazza, karakterekből és egyjegyű számokból áll.\n\n  Visszatér:\n  - Egy karakterlánc, amely a tömörített karakterlánc kibővített formáját képviseli.\n\n  Példa:\n  - expand_compressed_string(\"a3b2c\") visszaadja \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") visszaadja \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") visszaadja \"xxxxxxxxxyzz\"\n*/\n\nfn expand_compressed_string(compressed: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9823751290300123",
      "hy": "0.9890499043543087",
      "bn": "0.991158564479375",
      "bg": "0.9887362669826546",
      "zh": "0.9628674406781949",
      "fr": "0.9661742392616637",
      "de": "0.9670835691460414",
      "ha": "0.9715442116129419",
      "hi": "0.9823860537009692",
      "hu": "0.9711968070765119"
    },
    "canonical_solution": "{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}",
    "instruction": {
      "en": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nরাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn expand_compressed_string(compressed: &str) -> String\n{\n    let mut expanded = String::new();\n    let mut chars = compressed.chars().peekable();\n\n    while let Some(ch) = chars.next() {\n        if ch.is_digit(10) {\n            let count = ch.to_digit(10).unwrap_or(0) as usize;\n            if let Some(prev_ch) = expanded.chars().last() {\n                expanded.extend(std::iter::repeat(prev_ch).take(count - 1));\n            }\n        } else {\n            expanded.push(ch);\n        }\n    }\n    expanded\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9319271834851525",
      "bn": "0.9147228130318156",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9368581826943435",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(expand_compressed_string(\"a3b2c\"), \"aaabbc\");\n        assert_eq!(expand_compressed_string(\"H3el5o2\"), \"HHHellllloo\");\n        assert_eq!(expand_compressed_string(\"x9y1z2\"), \"xxxxxxxxxyzz\");\n        assert_eq!(expand_compressed_string(\"r4s\"), \"rrrrs\");\n        \n    }\n    \n\n}\n ",
    "entry_point": "expand_compressed_string",
    "signature": "fn expand_compressed_string(compressed: &str) -> String",
    "docstring": {
      "en": "Expands a compressed string where consecutive characters are represented by the character followed by its count.\n  The count is a single digit (1-9), and it specifies how many times the character appears consecutively. If a character appears only once, it's not followed by a count.\n\n  Arguments:\n  - compressed: A string containing the compressed format, consisting of characters and single-digit counts.\n\n  Returns:\n  - A string representing the expanded form of the compressed string.\n\n  Example:\n  - expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "sq": "Zgjeron një varg të kompresuar ku karakteret e njëpasnjëshme përfaqësohen nga karakteri i ndjekur nga numri i tij.\n  Numri është një shifër e vetme (1-9), dhe specifikon sa herë shfaqet karakteri në mënyrë të njëpasnjëshme. Nëse një karakter shfaqet vetëm një herë, nuk ndiqet nga një numër.\n\n  Argumentet:\n  - compressed: Një varg që përmban formatin e kompresuar, i përbërë nga karaktere dhe numra njëshifrorë.\n\n  Kthen:\n  - Një varg që përfaqëson formën e zgjeruar të vargut të kompresuar.\n\n  Shembull:\n  - expand_compressed_string(\"a3b2c\") kthen \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") kthen \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") kthen \"xxxxxxxxxyzz\"",
      "hy": "Ընդլայնում է սեղմված տողը, որտեղ հաջորդական նիշերը ներկայացված են նիշով, որին հաջորդում է նրա քանակը:\n  Քանակը մեկանիշ թիվ է (1-9), և այն նշում է, թե քանի անգամ է նիշը հաջորդաբար հայտնվում: Եթե նիշը հայտնվում է միայն մեկ անգամ, ապա այն չի հետևվում քանակով:\n\n  Արգումենտներ:\n  - compressed: Տող, որը պարունակում է սեղմված ձևաչափը, բաղկացած նիշերից և մեկանիշ քանակներից:\n\n  Վերադարձնում է:\n  - Տող, որը ներկայացնում է սեղմված տողի ընդլայնված ձևը:\n\n  Օրինակ:\n  - expand_compressed_string(\"a3b2c\") վերադարձնում է \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") վերադարձնում է \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") վերադարձնում է \"xxxxxxxxxyzz\"",
      "bn": "সংকুচিত স্ট্রিং প্রসারিত করে যেখানে পরপর অক্ষরগুলি অক্ষর এবং তারপরে তার গণনা দ্বারা উপস্থাপিত হয়। গণনা একটি একক সংখ্যা (1-9), এবং এটি নির্দিষ্ট করে যে অক্ষরটি পরপর কতবার উপস্থিত হয়। যদি কোনো অক্ষর একবারই উপস্থিত হয়, তবে তার পরে কোনো গণনা থাকে না।\n\nArguments:\n- compressed: সংকুচিত ফরম্যাট ধারণকারী একটি স্ট্রিং, যা অক্ষর এবং একক-সংখ্যার গণনা নিয়ে গঠিত।\n\nReturns:\n- সংকুচিত স্ট্রিংয়ের প্রসারিত ফর্ম উপস্থাপনকারী একটি স্ট্রিং।\n\nExample:\n- expand_compressed_string(\"a3b2c\") returns \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") returns \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") returns \"xxxxxxxxxyzz\"",
      "bg": "Разширява компресиран низ, където последователни символи са представени от символа, последван от неговия брой. Броят е едноцифрено число (1-9) и указва колко пъти символът се появява последователно. Ако символът се появява само веднъж, не е последван от брой.\n\nАргументи:\n- compressed: Низ, съдържащ компресирания формат, състоящ се от символи и едноцифрени числа.\n\nВръща:\n- Низ, представляващ разширената форма на компресирания низ.\n\nПример:\n- expand_compressed_string(\"a3b2c\") връща \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") връща \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") връща \"xxxxxxxxxyzz\"",
      "zh": "扩展一个压缩字符串，其中连续字符由字符后跟其计数表示。计数是一个单一数字（1-9），它指定字符连续出现的次数。如果一个字符只出现一次，则后面不跟计数。\n\n参数：\n- compressed: 一个包含压缩格式的字符串，由字符和单一数字计数组成。\n\n返回：\n- 一个字符串，表示压缩字符串的扩展形式。\n\n示例：\n- expand_compressed_string(\"a3b2c\") 返回 \"aaabbc\"\n- expand_compressed_string(\"H3el5o2\") 返回 \"HHHellllloo\"\n- expand_compressed_string(\"x9y1z2\") 返回 \"xxxxxxxxxyzz\"",
      "fr": "Développe une chaîne compressée où les caractères consécutifs sont représentés par le caractère suivi de son compte.\n  Le compte est un chiffre unique (1-9), et il spécifie combien de fois le caractère apparaît consécutivement. Si un caractère apparaît une seule fois, il n'est pas suivi d'un compte.\n\n  Arguments:\n  - compressed: Une chaîne contenant le format compressé, composé de caractères et de chiffres uniques.\n\n  Renvoie:\n  - Une chaîne représentant la forme développée de la chaîne compressée.\n\n  Exemple:\n  - expand_compressed_string(\"a3b2c\") renvoie \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") renvoie \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") renvoie \"xxxxxxxxxyzz\"",
      "de": "Erweitert einen komprimierten String, bei dem aufeinanderfolgende Zeichen durch das Zeichen gefolgt von seiner Anzahl dargestellt werden.\n  Die Anzahl ist eine einstellige Zahl (1-9) und gibt an, wie oft das Zeichen hintereinander erscheint. Wenn ein Zeichen nur einmal erscheint, folgt keine Anzahl.\n\n  Argumente:\n  - compressed: Ein String, der das komprimierte Format enthält, bestehend aus Zeichen und einstelligen Zahlen.\n\n  Rückgabewert:\n  - Ein String, der die erweiterte Form des komprimierten Strings darstellt.\n\n  Beispiel:\n  - expand_compressed_string(\"a3b2c\") gibt \"aaabbc\" zurück\n  - expand_compressed_string(\"H3el5o2\") gibt \"HHHellllloo\" zurück\n  - expand_compressed_string(\"x9y1z2\") gibt \"xxxxxxxxxyzz\" zurück",
      "ha": "Yana faɗaɗa wani matsewar kirtani inda haruffa masu jere suna wakilta ta hanyar harafin da aka bi da adadinsa.\n  Adadin yana da lamba ɗaya (1-9), kuma yana bayyana sau nawa harafin ya bayyana a jere. Idan harafi ya bayyana sau ɗaya kawai, ba a bi shi da adadi.\n\n  Huɗɗa:\n  - compressed: Wani kirtani da ke ɗauke da tsarin matsewa, wanda ya ƙunshi haruffa da lambobi ɗaya.\n\n  Komawa:\n  - Wani kirtani da ke wakiltar faɗaɗa tsarin matsewar kirtani.\n\n  Misali:\n  - expand_compressed_string(\"a3b2c\") yana dawowa \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") yana dawowa \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") yana dawowa \"xxxxxxxxxyzz\"",
      "hi": "संपीड़ित स्ट्रिंग का विस्तार करता है जहाँ लगातार वर्णों को वर्ण के बाद उसकी गिनती द्वारा दर्शाया जाता है। \n  गिनती एकल अंक (1-9) होती है, और यह निर्दिष्ट करती है कि वर्ण कितनी बार लगातार प्रकट होता है। यदि कोई वर्ण केवल एक बार प्रकट होता है, तो उसके बाद गिनती नहीं होती है।\n\n  तर्क:\n  - compressed: एक स्ट्रिंग जिसमें संपीड़ित प्रारूप होता है, जिसमें वर्ण और एकल-अंक गिनती शामिल होती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग जो संपीड़ित स्ट्रिंग के विस्तारित रूप का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - expand_compressed_string(\"a3b2c\") \"aaabbc\" लौटाता है\n  - expand_compressed_string(\"H3el5o2\") \"HHHellllloo\" लौटाता है\n  - expand_compressed_string(\"x9y1z2\") \"xxxxxxxxxyzz\" लौटाता है",
      "hu": "Kibont egy tömörített karakterláncot, ahol az egymást követő karaktereket a karakter és annak száma képviseli.\n  A szám egyjegyű (1-9), és azt jelzi, hogy a karakter hányszor jelenik meg egymás után. Ha egy karakter csak egyszer jelenik meg, akkor nem követi szám.\n\n  Argumentumok:\n  - compressed: Egy karakterlánc, amely a tömörített formátumot tartalmazza, karakterekből és egyjegyű számokból áll.\n\n  Visszatér:\n  - Egy karakterlánc, amely a tömörített karakterlánc kibővített formáját képviseli.\n\n  Példa:\n  - expand_compressed_string(\"a3b2c\") visszaadja \"aaabbc\"\n  - expand_compressed_string(\"H3el5o2\") visszaadja \"HHHellllloo\"\n  - expand_compressed_string(\"x9y1z2\") visszaadja \"xxxxxxxxxyzz\""
    },
    "docstring_bertscore": {
      "sq": "0.9791015017201763",
      "hy": "0.986911052411325",
      "bn": "0.978171712906552",
      "bg": "0.9836473566205408",
      "zh": "0.9526721404804361",
      "fr": "0.9757130660501021",
      "de": "0.9692254005447406",
      "ha": "0.9724873086620955",
      "hi": "0.9753322916096583",
      "hu": "0.9607089243274888"
    }
  },
  {
    "task_id": "Rust/11",
    "prompt": {
      "en": "/*\n  Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin e shtigjeve të dallueshme nga këndi i sipërm i majtë deri te këndi i poshtëm i djathtë i një rrjeti,\n  me kufizimin që mund të lëvizet vetëm djathtas ose poshtë dhe nuk mund të hyhet në qeliza ku numrat e rreshtave dhe kolonave janë çift.\n\n  Argumentet:\n  - rows: Numri i rreshtave në rrjet.\n  - cols: Numri i kolonave në rrjet.\n\n  Kthen:\n  - Numri i shtigjeve të dallueshme që plotësojnë kufizimet e dhëna.\n\n  Shembull:\n  - count_walking_paths(3, 4) kthen 2\n  - count_walking_paths(2, 2) kthen 0\n  - count_walking_paths(4, 5) kthen 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32",
      "hy": "/*\n  Հաշվում է տարբեր ուղիների քանակը ցանցի վերին ձախ անկյունից մինչև ներքևի աջ անկյուն,\n  պայմանով, որ կարելի է շարժվել միայն աջ կամ ներքև և չի կարելի մտնել այն բջիջները, որտեղ և՛ տողի, և՛ սյունակի համարները զույգ են:\n\n  Արգումենտներ:\n  - rows: Ցանցի տողերի քանակը:\n  - cols: Ցանցի սյունակների քանակը:\n\n  Վերադարձնում է:\n  - Տարբեր ուղիների քանակը, որը բավարարում է տրված պայմաններին:\n\n  Օրինակ:\n  - count_walking_paths(3, 4) վերադարձնում է 2\n  - count_walking_paths(2, 2) վերադարձնում է 0\n  - count_walking_paths(4, 5) վերադարձնում է 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "bn": "/*\n  একটি গ্রিডের উপরের-বাম কোণ থেকে নিচের-ডান কোণে যাওয়ার বিভিন্ন পথের সংখ্যা গণনা করে,\n  যেখানে শর্ত হল যে শুধুমাত্র ডান বা নিচে সরানো যায় এবং এমন কোষে প্রবেশ করা যায় না যেখানে সারি এবং কলাম উভয়ের সংখ্যা জোড়।\n\n  আর্গুমেন্ট:\n  - rows: গ্রিডের সারির সংখ্যা।\n  - cols: গ্রিডের কলামের সংখ্যা।\n\n  রিটার্নস:\n  - প্রদত্ত শর্তগুলি পূরণ করে এমন বিভিন্ন পথের সংখ্যা।\n\n  উদাহরণ:\n  - count_walking_paths(3, 4) রিটার্ন করে 2\n  - count_walking_paths(2, 2) রিটার্ন করে 0\n  - count_walking_paths(4, 5) রিটার্ন করে 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "bg": "/*\n  Изчислява броя на различните пътища от горния ляв ъгъл до долния десен ъгъл на мрежа,\n  с ограничението, че може да се движи само надясно или надолу и не може да влиза в клетки, където и редовете, и колоните са четни.\n\n  Аргументи:\n  - rows: Броят на редовете в мрежата.\n  - cols: Броят на колоните в мрежата.\n\n  Връща:\n  - Броят на различните пътища, които отговарят на дадените ограничения.\n\n  Пример:\n  - count_walking_paths(3, 4) връща 2\n  - count_walking_paths(2, 2) връща 0\n  - count_walking_paths(4, 5) връща 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "zh": "/*\n  计算从网格的左上角到右下角的不同路径数量，\n  条件是只能向右或向下移动，并且不能进入行号和列号均为偶数的单元格。\n\n  参数：\n  - rows: 网格的行数。\n  - cols: 网格的列数。\n\n  返回：\n  - 满足给定约束条件的不同路径数量。\n\n  示例：\n  - count_walking_paths(3, 4) 返回 2\n  - count_walking_paths(2, 2) 返回 0\n  - count_walking_paths(4, 5) 返回 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre de chemins distincts du coin supérieur gauche au coin inférieur droit d'une grille,\n  avec la contrainte que l'on ne peut se déplacer que vers la droite ou vers le bas et ne peut pas entrer dans les cellules où les numéros de ligne et de colonne sont pairs.\n\n  Arguments:\n  - rows: Le nombre de lignes dans la grille.\n  - cols: Le nombre de colonnes dans la grille.\n\n  Renvoie:\n  - Le nombre de chemins distincts satisfaisant les contraintes données.\n\n  Exemple:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "de": "/*\n  Berechnet die Anzahl der verschiedenen Pfade von der oberen linken Ecke zur unteren rechten Ecke eines Gitters,\n  mit der Einschränkung, dass man sich nur nach rechts oder unten bewegen kann und keine Zellen betreten darf, in denen sowohl die Zeilen- als auch die Spaltennummern gerade sind.\n\n  Argumente:\n  - rows: Die Anzahl der Zeilen im Gitter.\n  - cols: Die Anzahl der Spalten im Gitter.\n\n  Rückgabewert:\n  - Die Anzahl der verschiedenen Pfade, die die gegebenen Einschränkungen erfüllen.\n\n  Beispiel:\n  - count_walking_paths(3, 4) gibt 2 zurück\n  - count_walking_paths(2, 2) gibt 0 zurück\n  - count_walking_paths(4, 5) gibt 3 zurück\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "ha": "/*\n  Lissafa adadin hanyoyi daban-daban daga saman hagu zuwa ƙasan dama na grid,\n  tare da ƙuntatawa cewa mutum zai iya motsawa kawai dama ko ƙasa kuma ba zai iya shiga sel inda lambobin layi da ginshiƙi duka biyun suke lamba mai ma'ana ba.\n\n  Huɗɗa:\n  - rows: Yawan layuka a cikin grid.\n  - cols: Yawan ginshiƙai a cikin grid.\n\n  Dawowa:\n  - Adadin hanyoyi daban-daban da suka cika ƙuntatawar da aka bayar.\n\n  Misali:\n  - count_walking_paths(3, 4) yana dawowa 2\n  - count_walking_paths(2, 2) yana dawowa 0\n  - count_walking_paths(4, 5) yana dawowa 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "hi": "/*\n  एक ग्रिड के शीर्ष-बाएँ कोने से निचले-दाएँ कोने तक विभिन्न पथों की संख्या की गणना करता है,\n  इस बाधा के साथ कि कोई केवल दाएँ या नीचे की ओर जा सकता है और उन कोशिकाओं में प्रवेश नहीं कर सकता जहाँ पंक्ति और स्तंभ संख्या दोनों सम हैं।\n\n  तर्क:\n  - rows: ग्रिड में पंक्तियों की संख्या।\n  - cols: ग्रिड में स्तंभों की संख्या।\n\n  लौटाता है:\n  - दी गई बाधाओं को संतोषजनक बनाने वाले विभिन्न पथों की संख्या।\n\n  उदाहरण:\n  - count_walking_paths(3, 4) 2 लौटाता है\n  - count_walking_paths(2, 2) 0 लौटाता है\n  - count_walking_paths(4, 5) 3 लौटाता है\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja a különböző utak számát a rács bal felső sarkából a jobb alsó sarkába,\n  azzal a megszorítással, hogy csak jobbra vagy lefelé lehet mozogni, és nem lehet belépni olyan cellákba, ahol mind a sor, mind az oszlop száma páros.\n\n  Argumentumok:\n  - rows: A rács sorainak száma.\n  - cols: A rács oszlopainak száma.\n\n  Visszatér:\n  - A megadott megszorításoknak megfelelő különböző utak száma.\n\n  Példa:\n  - count_walking_paths(3, 4) visszaadja 2\n  - count_walking_paths(2, 2) visszaadja 0\n  - count_walking_paths(4, 5) visszaadja 3\n*/\n\nfn count_walking_paths(rows: i32, cols: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9818201557454008",
      "hy": "0.9766770192892644",
      "bn": "0.9667033905967407",
      "bg": "0.9754081684152136",
      "zh": "0.9707262517038403",
      "fr": "0.9890040207362897",
      "de": "0.9768410879839993",
      "ha": "0.9571466870740091",
      "hi": "0.9902021591946921",
      "hu": "0.9703192580530997"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}",
    "instruction": {
      "en": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\n请用最多500个字符的中文为以下Rust代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn count_walking_paths(rows: i32, cols: i32) -> i32\n{\n    let mut dp = vec![vec![0; cols as usize]; rows as usize];\n\n    for i in 0..rows as usize {\n        for j in 0..cols as usize {\n            if (i + 1) % 2 == 0 && (j + 1) % 2 == 0 {\n                dp[i][j] = 0;\n            } else if i == 0 || j == 0 {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n            }\n        }\n    }\n\n    dp[(rows - 1) as usize][(cols - 1) as usize]\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9217118216189092",
      "bn": "0.8911046675748622",
      "bg": "0.8316696904400789",
      "zh": "0.856169158897684",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9361141132869868",
      "hi": "0.9115359871984918",
      "hu": "0.9325771020918986"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n    #[test]\n    fn main() {\n        assert_eq!(count_walking_paths(3, 4), 2);\n        assert_eq!(count_walking_paths(2, 2), 0);\n        assert_eq!(count_walking_paths(4, 5), 3);\n        assert_eq!(count_walking_paths(1, 1), 1);        \n    }\n    \n\n}",
    "entry_point": "count_walking_paths",
    "signature": "fn count_walking_paths(rows: i32, cols: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of distinct paths from the top-left corner to the bottom-right corner of a grid,\n  with the constraint that one can only move right or down and cannot enter cells where both row and column numbers are even.\n\n  Arguments:\n  - rows: The number of rows in the grid.\n  - cols: The number of columns in the grid.\n\n  Returns:\n  - The number of distinct paths satisfying the given constraints.\n\n  Example:\n  - count_walking_paths(3, 4) returns 2\n  - count_walking_paths(2, 2) returns 0\n  - count_walking_paths(4, 5) returns 3",
      "sq": "Llogarit numrin e shtigjeve të dallueshme nga këndi i sipërm i majtë deri në këndin e poshtëm të djathtë të një rrjeti,\n  me kufizimin që mund të lëvizet vetëm djathtas ose poshtë dhe nuk mund të hyhet në qeliza ku numrat e rreshtave dhe kolonave janë të dyja çift.\n\n  Argumentet:\n  - rows: Numri i rreshtave në rrjet.\n  - cols: Numri i kolonave në rrjet.\n\n  Kthen:\n  - Numri i shtigjeve të dallueshme që plotësojnë kufizimet e dhëna.\n\n  Shembull:\n  - count_walking_paths(3, 4) kthen 2\n  - count_walking_paths(2, 2) kthen 0\n  - count_walking_paths(4, 5) kthen 3",
      "hy": "Հաշվում է տարբեր ուղիների քանակը ցանցի վերևի ձախ անկյունից դեպի ներքևի աջ անկյուն,\n  սահմանափակմամբ, որ կարելի է շարժվել միայն աջ կամ ներքև և չի կարելի մտնել այն բջիջները, որտեղ և՛ տողի, և՛ սյունակի համարները զույգ են:\n\n  Արձանագրություններ:\n  - rows: Տողերի քանակը ցանցում:\n  - cols: Սյունակների քանակը ցանցում:\n\n  Վերադարձնում է:\n  - Տարբեր ուղիների քանակը, որոնք բավարարում են տրված սահմանափակումները:\n\n  Օրինակ:\n  - count_walking_paths(3, 4) վերադարձնում է 2\n  - count_walking_paths(2, 2) վերադարձնում է 0\n  - count_walking_paths(4, 5) վերադարձնում է 3",
      "bn": "শীর্ষ-বাম কোণ থেকে গ্রিডের নীচের-ডান কোণে ভিন্ন পথের সংখ্যা গণনা করে, \n  শর্তসাপেক্ষে যে একজন কেবল ডান বা নিচে যেতে পারে এবং এমন কোষে প্রবেশ করতে পারে না যেখানে সারি এবং কলামের উভয় সংখ্যাই জোড়।\n\n  আর্গুমেন্টসমূহ:\n  - rows: গ্রিডের সারির সংখ্যা।\n  - cols: গ্রিডের কলামের সংখ্যা।\n\n  রিটার্নস:\n  - প্রদত্ত শর্তগুলি পূরণকারী ভিন্ন পথের সংখ্যা।\n\n  উদাহরণ:\n  - count_walking_paths(3, 4) রিটার্ন করে 2\n  - count_walking_paths(2, 2) রিটার্ন করে 0\n  - count_walking_paths(4, 5) রিটার্ন করে 3",
      "bg": "Изчислява броя на различните пътища от горния ляв ъгъл до долния десен ъгъл на мрежа,\n  с ограничението, че може да се движите само надясно или надолу и не може да влизате в клетки, където и редовете, и колоните са четни.\n\n  Аргументи:\n  - rows: Броят на редовете в мрежата.\n  - cols: Броят на колоните в мрежата.\n\n  Връща:\n  - Броят на различните пътища, които удовлетворяват дадените ограничения.\n\n  Пример:\n  - count_walking_paths(3, 4) връща 2\n  - count_walking_paths(2, 2) връща 0\n  - count_walking_paths(4, 5) връща 3",
      "zh": "计算从网格的左上角到右下角的不同路径数量，限制条件是只能向右或向下移动，并且不能进入行号和列号均为偶数的单元格。\n\n参数:\n- rows: 网格的行数。\n- cols: 网格的列数。\n\n返回:\n- 满足给定约束条件的不同路径数量。\n\n示例:\n- count_walking_paths(3, 4) 返回 2\n- count_walking_paths(2, 2) 返回 0\n- count_walking_paths(4, 5) 返回 3",
      "fr": "Calcule le nombre de chemins distincts du coin supérieur gauche au coin inférieur droit d'une grille, avec la contrainte que l'on ne peut se déplacer que vers la droite ou vers le bas et ne peut pas entrer dans les cellules où les numéros de ligne et de colonne sont tous deux pairs.\n\nArguments:\n- rows: Le nombre de lignes dans la grille.\n- cols: Le nombre de colonnes dans la grille.\n\nReturns:\n- Le nombre de chemins distincts satisfaisant les contraintes données.\n\nExample:\n- count_walking_paths(3, 4) returns 2\n- count_walking_paths(2, 2) returns 0\n- count_walking_paths(4, 5) returns 3",
      "de": "Berechnet die Anzahl der unterschiedlichen Wege vom oberen linken zum unteren rechten Eckpunkt eines Gitters,\n  mit der Einschränkung, dass man sich nur nach rechts oder unten bewegen kann und keine Zellen betreten darf, in denen sowohl die Zeilen- als auch die Spaltennummer gerade sind.\n\n  Argumente:\n  - rows: Die Anzahl der Zeilen im Gitter.\n  - cols: Die Anzahl der Spalten im Gitter.\n\n  Rückgabewert:\n  - Die Anzahl der unterschiedlichen Wege, die die gegebenen Einschränkungen erfüllen.\n\n  Beispiel:\n  - count_walking_paths(3, 4) gibt 2 zurück\n  - count_walking_paths(2, 2) gibt 0 zurück\n  - count_walking_paths(4, 5) gibt 3 zurück",
      "ha": "Yana ƙididdige adadin hanyoyin daban-daban daga saman hagu zuwa ƙasan dama na grid,\ntare da ƙuntatawa cewa mutum zai iya motsawa kawai dama ko ƙasa kuma ba zai iya shiga sel inda lambobin layi da ginshiƙai duka biyun suke ma'aurata ba.\n\nHuɗɗa:\n- rows: Adadin layuka a cikin grid.\n- cols: Adadin ginshiƙai a cikin grid.\n\nDawowa:\n- Adadin hanyoyin daban-daban da suka cika ƙuntatawar da aka bayar.\n\nMisali:\n- count_walking_paths(3, 4) yana dawowa 2\n- count_walking_paths(2, 2) yana dawowa 0\n- count_walking_paths(4, 5) yana dawowa 3",
      "hi": "ऊपरी-बाएँ कोने से निचले-दाएँ कोने तक ग्रिड में विभिन्न पथों की संख्या की गणना करता है,\n  इस बाधा के साथ कि कोई केवल दाएँ या नीचे की ओर जा सकता है और उन कोशिकाओं में प्रवेश नहीं कर सकता जहाँ पंक्ति और स्तंभ दोनों संख्याएँ सम हैं।\n\n  तर्क:\n  - rows: ग्रिड में पंक्तियों की संख्या।\n  - cols: ग्रिड में स्तंभों की संख्या।\n\n  वापसी:\n  - दिए गए बाधाओं को संतुष्ट करने वाले विभिन्न पथों की संख्या।\n\n  उदाहरण:\n  - count_walking_paths(3, 4) 2 लौटाता है\n  - count_walking_paths(2, 2) 0 लौटाता है\n  - count_walking_paths(4, 5) 3 लौटाता है",
      "hu": "Számítja a különböző utak számát a rács bal felső sarkától a jobb alsó sarokig, azzal a megkötéssel, hogy csak jobbra vagy lefelé lehet mozogni, és nem lehet belépni olyan cellákba, ahol mind a sor, mind az oszlop száma páros.\n\nÉrvek:\n- rows: A rács sorainak száma.\n- cols: A rács oszlopainak száma.\n\nVisszatér:\n- A megadott megkötéseket kielégítő különböző utak száma.\n\nPélda:\n- count_walking_paths(3, 4) visszaadja 2\n- count_walking_paths(2, 2) visszaadja 0\n- count_walking_paths(4, 5) visszaadja 3"
    },
    "docstring_bertscore": {
      "sq": "0.9801919825120579",
      "hy": "0.974084296925616",
      "bn": "0.9717460200800734",
      "bg": "0.9738411733392294",
      "zh": "0.9641333120965302",
      "fr": "0.9853986806901254",
      "de": "0.9691775306229112",
      "ha": "0.9485896902590261",
      "hi": "0.978798193128336",
      "hu": "0.9694639556323635"
    }
  },
  {
    "task_id": "Rust/12",
    "prompt": {
      "en": "/*\n  Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "sq": "/*\n  Numëron numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave në një varg të dhënë.\n\n  Argumentet:\n  - input: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla angleze, si dhe shifra.\n\n  Kthen:\n  - Një treshe që përmban tre vlera usize që përfaqësojnë numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave, përkatësisht.\n\n  Shembull:\n  - count_character_types(\"Rust3IsFun!\") kthen (3, 6, 1)\n  - count_character_types(\"1234\") kthen (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") kthen (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "hy": "/*\n  Հաշվում է մեծատառերի, փոքրատառերի և թվանշանների քանակը տրված տողում։\n\n  Արգումենտներ:\n  - input: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, ինչպես նաև թվանշաններ։\n\n  Վերադարձնում է:\n  - Եռյակ, որը պարունակում է երեք usize արժեքներ, որոնք ներկայացնում են մեծատառերի, փոքրատառերի և թվանշանների քանակները, համապատասխանաբար։\n\n  Օրինակ:\n  - count_character_types(\"Rust3IsFun!\") վերադարձնում է (3, 6, 1)\n  - count_character_types(\"1234\") վերադարձնում է (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") վերադարձնում է (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "bn": "/*\n  প্রদত্ত স্ট্রিং-এ বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার সংখ্যা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - input: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, পাশাপাশি সংখ্যা থাকতে পারে।\n\n  রিটার্ন:\n  - একটি টিউপল যা তিনটি usize মান ধারণ করে, যথাক্রমে বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - count_character_types(\"Rust3IsFun!\") (3, 6, 1) রিটার্ন করে\n  - count_character_types(\"1234\") (0, 0, 4) রিটার্ন করে\n  - count_character_types(\"HelloWorld!\") (2, 8, 0) রিটার্ন করে\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "bg": "/*\n  Брои броя на главните букви, малките букви и цифрите в даден низ.\n\n  Аргументи:\n  - input: Низ, който може да съдържа главни и малки английски букви, както и цифри.\n\n  Връща:\n  - Кортеж, съдържащ три стойности от тип usize, представляващи броя на главните букви, малките букви и цифрите, съответно.\n\n  Пример:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "zh": "/*\n  统计给定字符串中大写字母、小写字母和数字的数量。\n\n  参数:\n  - input: 一个字符串，可能包含大写和小写的英文字母，以及数字。\n\n  返回:\n  - 一个包含三个 usize 值的元组，分别表示大写字母、小写字母和数字的数量。\n\n  示例:\n  - count_character_types(\"Rust3IsFun!\") 返回 (3, 6, 1)\n  - count_character_types(\"1234\") 返回 (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") 返回 (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "fr": "/*\n  Compte le nombre de lettres majuscules, de lettres minuscules et de chiffres dans une chaîne donnée.\n\n  Arguments:\n  - input: Une chaîne qui peut contenir des lettres anglaises majuscules et minuscules, ainsi que des chiffres.\n\n  Renvoie:\n  - Un tuple contenant trois valeurs usize représentant les comptes des lettres majuscules, des lettres minuscules et des chiffres, respectivement.\n\n  Exemple:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "de": "/*\n  Zählt die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern in einem gegebenen String.\n\n  Argumente:\n  - input: Ein String, der Groß- und Kleinbuchstaben des englischen Alphabets sowie Ziffern enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält, die die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern darstellen.\n\n  Beispiel:\n  - count_character_types(\"Rust3IsFun!\") gibt (3, 6, 1) zurück\n  - count_character_types(\"1234\") gibt (0, 0, 4) zurück\n  - count_character_types(\"HelloWorld!\") gibt (2, 8, 0) zurück\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "ha": "/*\n  Yana ƙidaya adadin manyan haruffa, ƙananan haruffa, da lambobi a cikin wata kirtani da aka bayar.\n\n  Huɗɗa:\n  - input: Wani kirtani wanda zai iya ƙunsar manyan da ƙananan haruffan Turanci, da kuma lambobi.\n\n  Mayarwa:\n  - Wani tuple wanda ke ɗauke da ƙimar usize guda uku da ke wakiltar ƙididdigar manyan haruffa, ƙananan haruffa, da lambobi, bi da bi.\n\n  Misali:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "hi": "/*\n  गिने हुए अपरकेस अक्षरों, लोअरकेस अक्षरों, और अंकों की संख्या एक दिए गए स्ट्रिंग में।\n\n  तर्क:\n  - input: एक स्ट्रिंग जिसमें अपरकेस और लोअरकेस अंग्रेजी अक्षर, साथ ही अंक हो सकते हैं।\n\n  लौटाता है:\n  - एक ट्यूपल जिसमें तीन usize मान होते हैं जो क्रमशः अपरकेस अक्षरों, लोअरकेस अक्षरों, और अंकों की गिनती को दर्शाते हैं।\n\n  उदाहरण:\n  - count_character_types(\"Rust3IsFun!\") लौटाता है (3, 6, 1)\n  - count_character_types(\"1234\") लौटाता है (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") लौटाता है (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)",
      "hu": "/*\n  Megszámolja a nagybetűk, kisbetűk és számjegyek számát egy adott sztringben.\n\n  Argumentumok:\n  - input: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, valamint számjegyeket.\n\n  Visszatér:\n  - Egy hármas tuple, amely három usize értéket tartalmaz, amelyek a nagybetűk, kisbetűk és számjegyek számát jelölik, ebben a sorrendben.\n\n  Példa:\n  - count_character_types(\"Rust3IsFun!\") visszaadja (3, 6, 1)\n  - count_character_types(\"1234\") visszaadja (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") visszaadja (2, 8, 0)\n*/\n\nfn count_character_types(input: &str) -> (usize, usize, usize)"
    },
    "prompt_bertscore": {
      "sq": "0.9969905510969405",
      "hy": "0.9984983543193763",
      "bn": "0.996617920502119",
      "bg": "0.9958907346771503",
      "zh": "0.9876710122491645",
      "fr": "0.999999801369619",
      "de": "0.9806837913355002",
      "ha": "0.9819101353080096",
      "hi": "0.9821484917652515",
      "hu": "0.975877134744837"
    },
    "canonical_solution": "{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}",
    "instruction": {
      "en": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn count_character_types(input: &str) -> (usize, usize, usize)\n{\n    let mut upper_count = 0;\n    let mut lower_count = 0;\n    let mut digit_count = 0;\n\n    for ch in input.chars() {\n        if ch.is_uppercase() {\n            upper_count += 1;\n        } else if ch.is_lowercase() {\n            lower_count += 1;\n        } else if ch.is_numeric() {\n            digit_count += 1;\n        }\n    }\n\n    (upper_count, lower_count, digit_count)\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9258661760382538",
      "bn": "0.8781885284176876",
      "bg": "0.8316696904400789",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9536426485221726",
      "hi": "0.9115359871984918",
      "hu": "0.9307939971613484"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_character_types(\"Rust3IsFun!\"), (3, 6, 1));\n        assert_eq!(count_character_types(\"1234\"), (0, 0, 4));\n        assert_eq!(count_character_types(\"HelloWorld!\"), (2, 8, 0));\n        assert_eq!(count_character_types(\"NoDigitsHere\"), (3, 9, 0));        \n    }\n    \n\n}",
    "entry_point": "count_character_types",
    "signature": "fn count_character_types(input: &str) -> (usize, usize, usize)",
    "docstring": {
      "en": "Counts the number of uppercase letters, lowercase letters, and digits in a given string.\n\n  Arguments:\n  - input: A string that may contain uppercase and lowercase English letters, as well as digits.\n\n  Returns:\n  - A tuple containing three usize values representing the counts of uppercase letters, lowercase letters, and digits, respectively.\n\n  Example:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "sq": "Numëron numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave në një varg të dhënë.\n\n  Argumentet:\n  - input: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla të anglishtes, si dhe shifra.\n\n  Kthen:\n  - Një tuple që përmban tre vlera usize që përfaqësojnë numrin e shkronjave të mëdha, shkronjave të vogla dhe shifrave, përkatësisht.\n\n  Shembull:\n  - count_character_types(\"Rust3IsFun!\") kthen (3, 6, 1)\n  - count_character_types(\"1234\") kthen (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") kthen (2, 8, 0)",
      "hy": "Հաշվում է մեծատառերի, փոքրատառերի և թվանշանների քանակը տրված տողում։\n\n  Արգումենտներ:\n  - input: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, ինչպես նաև թվանշաններ։\n\n  Վերադարձնում է:\n  - Եռյակ, որը պարունակում է երեք usize արժեքներ, որոնք ներկայացնում են մեծատառերի, փոքրատառերի և թվանշանների քանակները համապատասխանաբար։\n\n  Օրինակ:\n  - count_character_types(\"Rust3IsFun!\") վերադարձնում է (3, 6, 1)\n  - count_character_types(\"1234\") վերադարձնում է (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") վերադարձնում է (2, 8, 0)",
      "bn": "প্রদত্ত স্ট্রিং-এ বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার সংখ্যা গণনা করে।\n\n  আর্গুমেন্টস:\n  - input: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, পাশাপাশি সংখ্যা থাকতে পারে।\n\n  রিটার্নস:\n  - একটি টিউপল যা তিনটি usize মান ধারণ করে যা যথাক্রমে বড় হাতের অক্ষর, ছোট হাতের অক্ষর এবং সংখ্যার গণনা উপস্থাপন করে।\n\n  উদাহরণ:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "bg": "Брои броя на главните букви, малките букви и цифрите в даден низ.\n\n  Аргументи:\n  - input: Низ, който може да съдържа главни и малки английски букви, както и цифри.\n\n  Връща:\n  - Кортеж, съдържащ три usize стойности, представляващи броя на главните букви, малките букви и цифрите, съответно.\n\n  Пример:\n  - count_character_types(\"Rust3IsFun!\") връща (3, 6, 1)\n  - count_character_types(\"1234\") връща (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") връща (2, 8, 0)",
      "zh": "计算给定字符串中大写字母、小写字母和数字的数量。\n\n  参数:\n  - input: 一个字符串，可能包含大写和小写的英文字母，以及数字。\n\n  返回:\n  - 一个元组，包含三个 usize 值，分别表示大写字母、小写字母和数字的数量。\n\n  示例:\n  - count_character_types(\"Rust3IsFun!\") 返回 (3, 6, 1)\n  - count_character_types(\"1234\") 返回 (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") 返回 (2, 8, 0)",
      "fr": "Compte le nombre de lettres majuscules, de lettres minuscules et de chiffres dans une chaîne donnée.\n\n  Arguments:\n  - input: Une chaîne qui peut contenir des lettres anglaises majuscules et minuscules, ainsi que des chiffres.\n\n  Renvoie:\n  - Un tuple contenant trois valeurs usize représentant les comptes des lettres majuscules, des lettres minuscules et des chiffres, respectivement.\n\n  Exemple:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "de": "Zählt die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern in einem gegebenen String.\n\n  Argumente:\n  - input: Ein String, der Groß- und Kleinbuchstaben des englischen Alphabets sowie Ziffern enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält, die die Anzahl der Großbuchstaben, Kleinbuchstaben und Ziffern darstellen.\n\n  Beispiel:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "ha": "Yana ƙididdige adadin haruffan manyan baki, haruffan ƙananan baki, da lambobi a cikin kirtani da aka bayar.\n\n  Huɗɗa:\n  - input: Wani kirtani wanda zai iya ƙunsar manyan haruffa da ƙananan haruffan Ingilishi, da kuma lambobi.\n\n  Komawa:\n  - Wani tuple wanda ke ɗauke da ƙimomi uku na usize waɗanda ke wakiltar ƙididdigar manyan haruffa, ƙananan haruffa, da lambobi, bi da bi.\n\n  Misali:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "hi": "दिए गए स्ट्रिंग में बड़े अक्षरों, छोटे अक्षरों, और अंकों की संख्या गिनता है।\n\n  तर्क:\n  - input: एक स्ट्रिंग जिसमें बड़े और छोटे अंग्रेजी अक्षर, साथ ही अंक हो सकते हैं।\n\n  रिटर्न:\n  - एक ट्यूपल जिसमें तीन usize मान होते हैं जो क्रमशः बड़े अक्षरों, छोटे अक्षरों और अंकों की गिनती का प्रतिनिधित्व करते हैं।\n\n  उदाहरण:\n  - count_character_types(\"Rust3IsFun!\") returns (3, 6, 1)\n  - count_character_types(\"1234\") returns (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") returns (2, 8, 0)",
      "hu": "Számolja meg a nagybetűk, kisbetűk és számjegyek számát egy adott sztringben.\n\n  Argumentumok:\n  - input: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, valamint számjegyeket.\n\n  Visszatérési érték:\n  - Egy hármas, amely három usize értéket tartalmaz, és a nagybetűk, kisbetűk és számjegyek számát képviseli, ebben a sorrendben.\n\n  Példa:\n  - count_character_types(\"Rust3IsFun!\") visszaadja (3, 6, 1)\n  - count_character_types(\"1234\") visszaadja (0, 0, 4)\n  - count_character_types(\"HelloWorld!\") visszaadja (2, 8, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.996532310807893",
      "hy": "0.998212326570686",
      "bn": "0.9923501481352034",
      "bg": "0.996532310807893",
      "zh": "0.9603351019503811",
      "fr": "1",
      "de": "0.977619520447275",
      "ha": "0.9911561809148026",
      "hi": "0.99391376649471",
      "hu": "0.9636669279618604"
    }
  },
  {
    "task_id": "Rust/13",
    "prompt": {
      "en": "/*\n  Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "sq": "/*\n  Konverton një sekuencë të dhënë numrash në vargun më të madh të mundshëm leksikografik të shkronjave të mëdha të alfabetit anglez, ku secila shkronjë korrespondon me pozicionin e saj në alfabet (A=1, B=2, ..., Z=26).\n\n  Funksioni interpreton sekuencën e numrave si një numër me një shifër ose dy shifra (që përfaqëson një shkronjë) për të maksimizuar rendin leksikografik të vargut rezultues.\n\n  Argumentet:\n  - encoded_sequence: Një varg që përbëhet nga shifra që përfaqësojnë pozicionet e koduara të shkronjave.\n\n  Kthen:\n  - Një varg i shkronjave të mëdha të alfabetit anglez që përfaqëson interpretimin më të madh të mundshëm leksikografik të sekuencës së koduar.\n\n  Shembuj:\n  - max_lexicographic_string(\"123242526\") kthen \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") kthen \"WRS\"\n  - max_lexicographic_string(\"102\") kthen \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "hy": "/*\n  Վերածում է տրված թվերի հաջորդականությունը լեքսիկոգրաֆիկորեն հնարավոր ամենամեծ մեծատառ անգլերեն տառերի տողին, որտեղ յուրաքանչյուր տառ համապատասխանում է այբուբենի իր դիրքին (A=1, B=2, ..., Z=26):\n\n  Ֆունկցիան մեկնաբանում է թվերի հաջորդականությունը որպես մեկանիշ կամ երկնիշ թիվ (ներկայացնող տառ)՝ առավելագույնի հասցնելու համար ստացված տողի լեքսիկոգրաֆիկ կարգը:\n\n  Արգումենտներ:\n  - encoded_sequence: Թվերից բաղկացած տող, որը ներկայացնում է կոդավորված տառերի դիրքերը:\n\n  Վերադարձնում է.\n  - Մեծատառ անգլերեն տառերի տող, որը ներկայացնում է կոդավորված հաջորդականության լեքսիկոգրաֆիկորեն հնարավոր ամենամեծ մեկնաբանումը:\n\n  Օրինակներ:\n  - max_lexicographic_string(\"123242526\") վերադարձնում է \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") վերադարձնում է \"WRS\"\n  - max_lexicographic_string(\"102\") վերադարձնում է \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "bn": "/*\n  প্রদত্ত সংখ্যার একটি ক্রমকে লেক্সিকোগ্রাফিকভাবে সর্বোচ্চ সম্ভাব্য বড় অক্ষরযুক্ত ইংরেজি অক্ষরের স্ট্রিংয়ে রূপান্তর করে, যেখানে প্রতিটি অক্ষর তার বর্ণমালায় অবস্থানকে নির্দেশ করে (A=1, B=2, ..., Z=26)।\n\n  ফাংশনটি সংখ্যার ক্রমকে একক-অঙ্ক বা দ্বৈত-অঙ্কের সংখ্যা (যা একটি অক্ষরকে উপস্থাপন করে) হিসেবে ব্যাখ্যা করে যাতে ফলস্বরূপ স্ট্রিংয়ের লেক্সিকোগ্রাফিক ক্রম সর্বাধিক হয়।\n\n  আর্গুমেন্টসমূহ:\n  - encoded_sequence: একটি স্ট্রিং যা এনকোড করা অক্ষর অবস্থানগুলি উপস্থাপনকারী সংখ্যা নিয়ে গঠিত।\n\n  রিটার্ন করে:\n  - বড় অক্ষরযুক্ত ইংরেজি অক্ষরের একটি স্ট্রিং যা এনকোড করা ক্রমের লেক্সিকোগ্রাফিকভাবে সর্বোচ্চ সম্ভাব্য ব্যাখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - max_lexicographic_string(\"123242526\") রিটার্ন করে \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") রিটার্ন করে \"WRS\"\n  - max_lexicographic_string(\"102\") রিটার্ন করে \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "bg": "/*\n  Преобразува дадена последователност от числа в лексикографски най-голямата възможна низ от главни английски букви, където всяка буква съответства на позицията си в азбуката (A=1, B=2, ..., Z=26).\n\n  Функцията интерпретира последователността от числа като едноцифрено или двуцифрено число (представляващо буква), за да максимизира лексикографския ред на получения низ.\n\n  Аргументи:\n  - encoded_sequence: Низ, състоящ се от цифри, представляващи кодираните позиции на буквите.\n\n  Връща:\n  - Низ от главни английски букви, който представлява лексикографски най-голямата възможна интерпретация на кодираната последователност.\n\n  Примери:\n  - max_lexicographic_string(\"123242526\") връща \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") връща \"WRS\"\n  - max_lexicographic_string(\"102\") връща \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "zh": "/*\n  将给定的数字序列转换为按字典序排列可能最大的由大写英文字母组成的字符串，其中每个字母对应字母表中的位置 (A=1, B=2, ..., Z=26)。\n\n  该函数将数字序列解释为单个数字或双位数字（代表一个字母），以最大化结果字符串的字典序。\n\n  参数:\n  - encoded_sequence: 一个由数字组成的字符串，表示编码的字母位置。\n\n  返回:\n  - 一个由大写英文字母组成的字符串，表示编码序列按字典序排列可能最大的解释。\n\n  示例:\n  - max_lexicographic_string(\"123242526\") 返回 \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") 返回 \"WRS\"\n  - max_lexicographic_string(\"102\") 返回 \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "fr": "/*\n  Convertit une séquence donnée de nombres en la chaîne lexicographiquement la plus grande possible de lettres majuscules anglaises, où chaque lettre correspond à sa position dans l'alphabet (A=1, B=2, ..., Z=26).\n\n  La fonction interprète la séquence de nombres comme un nombre à un chiffre ou à deux chiffres (représentant une lettre) pour maximiser l'ordre lexicographique de la chaîne résultante.\n\n  Arguments :\n  - encoded_sequence : Une chaîne composée de chiffres représentant les positions des lettres encodées.\n\n  Renvoie :\n  - Une chaîne de lettres majuscules anglaises qui représente l'interprétation lexicographiquement la plus grande possible de la séquence encodée.\n\n  Exemples :\n  - max_lexicographic_string(\"123242526\") renvoie \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") renvoie \"WRS\"\n  - max_lexicographic_string(\"102\") renvoie \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "de": "/*\n  Konvertiert eine gegebene Sequenz von Zahlen in die lexikographisch größtmögliche Zeichenkette aus Großbuchstaben des englischen Alphabets, wobei jeder Buchstabe seiner Position im Alphabet entspricht (A=1, B=2, ..., Z=26).\n\n  Die Funktion interpretiert die Zahlenfolge entweder als einstellige oder zweistellige Zahl (die einen Buchstaben darstellt), um die lexikographische Reihenfolge der resultierenden Zeichenkette zu maximieren.\n\n  Argumente:\n  - encoded_sequence: Ein String, der aus Ziffern besteht, die die kodierten Buchstabenpositionen darstellen.\n\n  Rückgabewert:\n  - Ein String aus Großbuchstaben des englischen Alphabets, der die lexikographisch größtmögliche Interpretation der kodierten Sequenz darstellt.\n\n  Beispiele:\n  - max_lexicographic_string(\"123242526\") gibt \"LCXYZ\" zurück\n  - max_lexicographic_string(\"231819\") gibt \"WRS\" zurück\n  - max_lexicographic_string(\"102\") gibt \"JB\" zurück\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "ha": "/*\n  Canza jerin lambobi da aka bayar zuwa mafi girman yuwuwar jeri na manyan haruffan Ingilishi, inda kowane harafi ya dace da matsayinsa a haruffa (A=1, B=2, ..., Z=26).\n\n  Aikin yana fassara jerin lambobi a matsayin lamba guda ko lambobi biyu (wakiltar harafi) don kara girman oda na lexicographic na sakamakon jeri.\n\n  Huɗɗa:\n  - encoded_sequence: Wani jeri na lambobi da ke wakiltar matsayi na haruffa da aka loda.\n\n  Mayarwa:\n  - Wani jeri na manyan haruffan Ingilishi wanda ke wakiltar mafi girman yuwuwar fassarar lexicographic na jerin da aka loda.\n\n  Misalai:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "hi": "/*\n  दिए गए संख्याओं के अनुक्रम को अंग्रेजी के बड़े अक्षरों की वर्णानुक्रम में सबसे बड़ी संभव स्ट्रिंग में परिवर्तित करता है, जहाँ प्रत्येक अक्षर वर्णमाला में अपनी स्थिति के अनुरूप होता है (A=1, B=2, ..., Z=26)।\n\n  यह फ़ंक्शन संख्याओं के अनुक्रम को या तो एकल-अंकीय या दोहरे-अंकीय संख्या (जो एक अक्षर का प्रतिनिधित्व करता है) के रूप में व्याख्या करता है ताकि परिणामी स्ट्रिंग का वर्णानुक्रम अधिकतम हो सके।\n\n  तर्क:\n  - encoded_sequence: अंकों से बना एक स्ट्रिंग जो एन्कोडेड अक्षर स्थितियों का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - अंग्रेजी के बड़े अक्षरों की एक स्ट्रिंग जो एन्कोडेड अनुक्रम की वर्णानुक्रम में सबसे बड़ी संभव व्याख्या का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String ",
      "hu": "/*\n  Egy adott számok sorozatát átalakítja a lehetséges legnagyobb lexikografikus sorrendű nagybetűs angol betűk sorozatává, ahol minden betű az ábécében elfoglalt helyének felel meg (A=1, B=2, ..., Z=26).\n\n  A függvény a számok sorozatát egyjegyű vagy kétjegyű számként értelmezi (amely egy betűt képvisel) annak érdekében, hogy maximalizálja a kapott sztring lexikografikus sorrendjét.\n\n  Argumentumok:\n  - encoded_sequence: Egy számjegyekből álló sztring, amely a kódolt betűpozíciókat képviseli.\n\n  Visszatér:\n  - Egy nagybetűs angol betűkből álló sztring, amely a kódolt sorozat lehetséges legnagyobb lexikografikus értelmezését képviseli.\n\n  Példák:\n  - max_lexicographic_string(\"123242526\") visszatér \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") visszatér \"WRS\"\n  - max_lexicographic_string(\"102\") visszatér \"JB\"\n*/\n\n\nfn max_lexicographic_string(encoded_sequence: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9813053057977584",
      "hy": "0.9779409044037894",
      "bn": "0.9687306122655828",
      "bg": "0.9911984891859631",
      "zh": "0.9702668196325066",
      "fr": "0.9816459569012332",
      "de": "0.976030676029377",
      "ha": "0.9371815529546683",
      "hi": "0.9516035090304684",
      "hu": "0.9762042789824015"
    },
    "canonical_solution": "{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}",
    "instruction": {
      "en": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nՏրամադրեք կարճ բնական լեզվով նկարագրություն (docstring) այս Rust կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nরাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nДайте кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\n请用中文为以下 Rust 代码提供简洁的自然语言描述（文档字符串），并且不超过 500 个字符。",
      "fr": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nFournir une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Rust cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn max_lexicographic_string(encoded_sequence: &str) -> String\n{\n    let mut result = String::new();\n    let chars: Vec<char> = encoded_sequence.chars().collect();\n    let mut i = 0;\n    while i < chars.len() {\n        let num = if i < chars.len() - 1 && (chars[i] == '1' || (chars[i] == '2' && chars[i + 1] <= '6')) {\n            i += 1;\n            chars[i - 1].to_digit(10).unwrap() * 10 + chars[i].to_digit(10).unwrap()\n        } else {\n            chars[i].to_digit(10).unwrap()\n        };\n        result.push((num as u8 + 64) as char); // 64 is 'A' - 1 in ASCII\n        i += 1;\n    }\n    result\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.8931094440106473",
      "bn": "0.909578683423774",
      "bg": "0.8316696904400789",
      "zh": "0.8871262996731144",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "   \n#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_lexicographic_string(\"123242526\"), \"LCXYZ\");\n        assert_eq!(max_lexicographic_string(\"231819\"), \"WRS\");\n        assert_eq!(max_lexicographic_string(\"102\"), \"JB\");\n        assert_eq!(max_lexicographic_string(\"26\"), \"Z\");   \n    }\n    \n\n}",
    "entry_point": "max_lexicographic_string",
    "signature": "fn max_lexicographic_string(encoded_sequence: &str) -> String",
    "docstring": {
      "en": "Converts a given sequence of numbers into the lexicographically largest possible string of uppercase English letters, where each letter corresponds to its position in the alphabet (A=1, B=2, ..., Z=26).\n\n  The function interprets the sequence of numbers as either a single-digit or double-digit number (representing a letter) to maximize the lexicographic order of the resulting string.\n\n  Arguments:\n  - encoded_sequence: A string consisting of digits representing the encoded letter positions.\n\n  Returns:\n  - A string of uppercase English letters that represents the lexicographically largest possible interpretation of the encoded sequence.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "sq": "Konverton një sekuencë të dhënë numrash në vargun më të madh të mundshëm leksikografik të shkronjave të mëdha të anglishtes, ku secila shkronjë korrespondon me pozicionin e saj në alfabet (A=1, B=2, ..., Z=26).\n\n  Funksioni interpreton sekuencën e numrave si një numër njëshifror ose dyshifror (që përfaqëson një shkronjë) për të maksimizuar rendin leksikografik të vargut rezultues.\n\n  Argumentet:\n  - encoded_sequence: Një varg që përbëhet nga shifrat që përfaqësojnë pozicionet e shkronjave të koduara.\n\n  Kthen:\n  - Një varg i shkronjave të mëdha të anglishtes që përfaqëson interpretimin më të madh të mundshëm leksikografik të sekuencës së koduar.\n\n  Shembuj:\n  - max_lexicographic_string(\"123242526\") kthen \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") kthen \"WRS\"\n  - max_lexicographic_string(\"102\") kthen \"JB\"",
      "hy": "Վերածում է տրված թվերի հաջորդականությունը լեքսիկոգրաֆիկորեն հնարավոր ամենամեծ մեծատառ անգլերեն տառերի տողի, որտեղ յուրաքանչյուր տառ համապատասխանում է այբուբենի իր դիրքին (A=1, B=2, ..., Z=26):\n\nՖունկցիան մեկնաբանում է թվերի հաջորդականությունը որպես մեկանիշ կամ երկնիշ թիվ (ներկայացնող տառ)՝ առավելագույնի հասցնելու համար ստացված տողի լեքսիկոգրաֆիկ կարգը:\n\nԱրգումենտներ:\n- encoded_sequence: Թվանշաններից բաղկացած տող, որը ներկայացնում է կոդավորված տառերի դիրքերը:\n\nՎերադարձնում է:\n- Մեծատառ անգլերեն տառերի տող, որը ներկայացնում է կոդավորված հաջորդականության լեքսիկոգրաֆիկորեն հնարավոր ամենամեծ մեկնաբանությունը:\n\nՕրինակներ:\n- max_lexicographic_string(\"123242526\") վերադարձնում է \"LCXYZ\"\n- max_lexicographic_string(\"231819\") վերադարձնում է \"WRS\"\n- max_lexicographic_string(\"102\") վերադարձնում է \"JB\"",
      "bn": "একটি প্রদত্ত সংখ্যার ক্রমকে বৃহত্তম লেক্সিকোগ্রাফিক সম্ভাব্য স্ট্রিংয়ে রূপান্তর করে, যেখানে প্রতিটি অক্ষর বর্ণমালায় তার অবস্থানের সাথে সম্পর্কিত (A=1, B=2, ..., Z=26)।\n\nফাংশনটি সংখ্যার ক্রমকে একক-সংখ্যা বা দ্বিগুণ-সংখ্যা (যা একটি অক্ষর প্রতিনিধিত্ব করে) হিসাবে ব্যাখ্যা করে যাতে ফলাফল স্ট্রিংয়ের লেক্সিকোগ্রাফিক ক্রম সর্বাধিক হয়।\n\nArguments:\n- encoded_sequence: একটি স্ট্রিং যা সংখ্যার সমন্বয়ে গঠিত যা এনকোড করা অক্ষরের অবস্থানগুলি প্রতিনিধিত্ব করে।\n\nReturns:\n- একটি বড় হাতের ইংরেজি অক্ষরের স্ট্রিং যা এনকোড করা ক্রমের লেক্সিকোগ্রাফিকভাবে বৃহত্তম সম্ভাব্য ব্যাখ্যা প্রতিনিধিত্ব করে।\n\nExamples:\n- max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n- max_lexicographic_string(\"231819\") returns \"WRS\"\n- max_lexicographic_string(\"102\") returns \"JB\"",
      "bg": "Преобразува дадена последователност от числа в лексикографски най-голямата възможна поредица от главни английски букви, където всяка буква съответства на позицията си в азбуката (A=1, B=2, ..., Z=26).\n\nФункцията интерпретира последователността от числа като едноцифрено или двуцифрено число (представляващо буква), за да максимизира лексикографския ред на получената поредица.\n\nАргументи:\n- encoded_sequence: Низ, състоящ се от цифри, представляващи позициите на кодираните букви.\n\nВръща:\n- Низ от главни английски букви, който представлява лексикографски най-голямата възможна интерпретация на кодираната последователност.\n\nПримери:\n- max_lexicographic_string(\"123242526\") връща \"LCXYZ\"\n- max_lexicographic_string(\"231819\") връща \"WRS\"\n- max_lexicographic_string(\"102\") връща \"JB\"",
      "zh": "将给定的数字序列转换为按字典序排列的可能的最大大写英文字母字符串，其中每个字母对应于其在字母表中的位置（A=1, B=2, ..., Z=26）。\n\n该函数将数字序列解释为单个数字或双位数字（代表一个字母），以最大化结果字符串的字典序。\n\n参数:\n- encoded_sequence: 一个由数字组成的字符串，表示编码的字母位置。\n\n返回:\n- 一个大写英文字母字符串，表示编码序列的按字典序排列的最大可能解释。\n\n示例:\n- max_lexicographic_string(\"123242526\") 返回 \"LCXYZ\"\n- max_lexicographic_string(\"231819\") 返回 \"WRS\"\n- max_lexicographic_string(\"102\") 返回 \"JB\"",
      "fr": "Convertit une séquence donnée de nombres en la chaîne lexicographiquement la plus grande possible de lettres majuscules anglaises, où chaque lettre correspond à sa position dans l'alphabet (A=1, B=2, ..., Z=26).\n\n  La fonction interprète la séquence de nombres soit comme un nombre à un chiffre, soit comme un nombre à deux chiffres (représentant une lettre) pour maximiser l'ordre lexicographique de la chaîne résultante.\n\n  Arguments:\n  - encoded_sequence: Une chaîne composée de chiffres représentant les positions des lettres encodées.\n\n  Returns:\n  - Une chaîne de lettres majuscules anglaises qui représente l'interprétation lexicographiquement la plus grande possible de la séquence encodée.\n\n  Examples:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "de": "Konvertiert eine gegebene Sequenz von Zahlen in die lexikografisch größtmögliche Zeichenkette aus Großbuchstaben des englischen Alphabets, wobei jeder Buchstabe seiner Position im Alphabet entspricht (A=1, B=2, ..., Z=26).\n\n  Die Funktion interpretiert die Zahlenfolge entweder als einstellige oder zweistellige Zahl (die einen Buchstaben darstellt), um die lexikografische Reihenfolge der resultierenden Zeichenkette zu maximieren.\n\n  Argumente:\n  - encoded_sequence: Ein String bestehend aus Ziffern, die die kodierten Buchstabenpositionen darstellen.\n\n  Rückgabewert:\n  - Ein String aus Großbuchstaben des englischen Alphabets, der die lexikografisch größtmögliche Interpretation der kodierten Sequenz darstellt.\n\n  Beispiele:\n  - max_lexicographic_string(\"123242526\") gibt \"LCXYZ\" zurück\n  - max_lexicographic_string(\"231819\") gibt \"WRS\" zurück\n  - max_lexicographic_string(\"102\") gibt \"JB\" zurück",
      "ha": "Canza jerin lambobi da aka bayar zuwa mafi girman yiwuwar jeri na manyan haruffan Ingilishi, inda kowace harafi ta dace da matsayinta a haruffa (A=1, B=2, ..., Z=26).\n\n  Aikin wannan aiki yana fassara jerin lambobi a matsayin ko dai lamba guda ɗaya ko lambobi biyu (wakiltar harafi) don haɓaka oda na lexicographic na sakamakon kirtani.\n\n  Huɗɗa:\n  - encoded_sequence: Wani kirtani mai ƙunshe da lambobi da ke wakiltar matsayi na haruffan da aka lamba.\n\n  Dawowa:\n  - Wani kirtani na manyan haruffan Ingilishi wanda ke wakiltar mafi girman fassarar lexicographically na jerin lambobin da aka lamba.\n\n  Misalai:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "hi": "दिए गए संख्याओं के अनुक्रम को बड़े अक्षरों में अंग्रेजी अक्षरों की वर्णक्रमानुसार सबसे बड़ी संभव स्ट्रिंग में बदलता है, जहाँ प्रत्येक अक्षर वर्णमाला में उसकी स्थिति के अनुसार होता है (A=1, B=2, ..., Z=26)।\n\n  यह फ़ंक्शन संख्याओं के अनुक्रम को या तो एकल अंक या दोहरे अंक संख्या (जो एक अक्षर का प्रतिनिधित्व करती है) के रूप में व्याख्यायित करता है ताकि परिणामी स्ट्रिंग का वर्णक्रमानुसार क्रम अधिकतम हो सके।\n\n  तर्क:\n  - encoded_sequence: एक स्ट्रिंग जिसमें अंक होते हैं जो एन्कोडेड अक्षर स्थितियों का प्रतिनिधित्व करते हैं।\n\n  वापसी:\n  - बड़े अक्षरों में अंग्रेजी अक्षरों की एक स्ट्रिंग जो एन्कोडेड अनुक्रम की वर्णक्रमानुसार सबसे बड़ी संभव व्याख्या का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - max_lexicographic_string(\"123242526\") returns \"LCXYZ\"\n  - max_lexicographic_string(\"231819\") returns \"WRS\"\n  - max_lexicographic_string(\"102\") returns \"JB\"",
      "hu": "Átalakít egy adott számokból álló sorozatot a lehető legnagyobb lexikografikus sorrendű nagybetűs angol betűk sorozatává, ahol minden betű az ábécében elfoglalt helyének felel meg (A=1, B=2, ..., Z=26).\n\nA függvény a számok sorozatát vagy egyjegyű, vagy kétjegyű számként értelmezi (amely egy betűt jelöl), hogy maximalizálja a kapott sztring lexikografikus sorrendjét.\n\nArgok:\n- encoded_sequence: Egy számjegyekből álló sztring, amely a kódolt betűpozíciókat jelöli.\n\nVisszatér:\n- Egy nagybetűs angol betűkből álló sztring, amely az encoded_sequence lehető legnagyobb lexikografikus értelmezését képviseli.\n\nPéldák:\n- max_lexicographic_string(\"123242526\") visszaadja \"LCXYZ\"\n- max_lexicographic_string(\"231819\") visszaadja \"WRS\"\n- max_lexicographic_string(\"102\") visszaadja \"JB\""
    },
    "docstring_bertscore": {
      "sq": "0.9778731714438565",
      "hy": "0.981525189629564",
      "bn": "0.9733430083435939",
      "bg": "0.9892604525582057",
      "zh": "0.955466671311216",
      "fr": "0.9683959200735389",
      "de": "0.9753396409337566",
      "ha": "0.9532155932029476",
      "hi": "0.9564522752619111",
      "hu": "0.9700173398739267"
    }
  },
  {
    "task_id": "Rust/14",
    "prompt": {
      "en": "/*\n    Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "sq": "/*\n    Llogarit shumën maksimale të numrave përgjatë një rruge nga maja në fund të një trekëndëshi numerik të dhënë.\n\n    Rruga lëviz poshtë ose te numri më i afërt majtas ose djathtas në rreshtin tjetër. Dallimi midis numrit të lëvizjeve majtas dhe djathtas nuk duhet të kalojë një.\n\n    Argumentet:\n    - triangle: Një vektor i vektorëve të i32, që përfaqëson rreshtat e trekëndëshit numerik. Çdo vektor i brendshëm përfaqëson një rresht në trekëndësh.\n\n    Kthen:\n    - Shuma maksimale e arritshme në çdo rrugë të vlefshme nga maja në fund të trekëndëshit.\n\n    Shembuj:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) kthen 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) kthen 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "hy": "/*\n    Հաշվում է թվերի առավելագույն գումարը ուղու երկայնքով, որը սկսվում է տրված թվային եռանկյունու վերևից և հասնում է ներքև:\n\n    Ուղին շարժվում է ներքև դեպի հաջորդ շարքի ամենամոտ ձախ կամ աջ թիվը: Ձախ և աջ շարժումների քանակների տարբերությունը չպետք է գերազանցի մեկ:\n\n    Փաստարկներ:\n    - triangle: i32-ի վեկտորների վեկտոր, որը ներկայացնում է թվային եռանկյունու շարքերը: Յուրաքանչյուր ներքին վեկտոր ներկայացնում է եռանկյունու մեկ շարք:\n\n    Վերադարձնում է:\n    - Առավելագույն գումարը, որը հնարավոր է ստանալ ցանկացած վավեր ուղու վրա, սկսած եռանկյունու վերևից մինչև ներքև:\n\n    Օրինակներ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) վերադարձնում է 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) վերադարձնում է 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "bn": "/*\n    একটি প্রদত্ত সংখ্যাসূচক ত্রিভুজের শীর্ষ থেকে নিচ পর্যন্ত একটি পথ বরাবর সংখ্যাগুলির সর্বাধিক যোগফল গণনা করে।\n\n    পথটি পরবর্তী সারির নিকটতম বাম বা ডান সংখ্যায় নিচে চলে যায়। বামে এবং ডানে যাওয়ার চলাফেরার সংখ্যার মধ্যে পার্থক্য একের বেশি হতে পারবে না।\n\n    আর্গুমেন্টসমূহ:\n    - triangle: i32 এর ভেক্টরের ভেক্টর, যা সংখ্যাসূচক ত্রিভুজের সারিগুলিকে উপস্থাপন করে। প্রতিটি অভ্যন্তরীণ ভেক্টর ত্রিভুজের একটি সারি উপস্থাপন করে।\n\n    রিটার্নস:\n    - ত্রিভুজের শীর্ষ থেকে নিচ পর্যন্ত যেকোনো বৈধ পথে অর্জনযোগ্য সর্বাধিক যোগফল।\n\n    উদাহরণসমূহ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 রিটার্ন করে\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 রিটার্ন করে\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "bg": "/*\n    Изчислява максималната сума на числата по път от върха до дъното на даден числов триъгълник.\n\n    Пътят се движи надолу към най-близкото ляво или дясно число на следващия ред. Разликата между броя на ходовете наляво и надясно не трябва да надвишава едно.\n\n    Аргументи:\n    - triangle: Вектор от вектори от i32, представляващ редовете на числовия триъгълник. Всеки вътрешен вектор представлява ред в триъгълника.\n\n    Връща:\n    - Максималната сума, която може да бъде постигната по всеки валиден път от върха до дъното на триъгълника.\n\n    Примери:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) връща 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) връща 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "zh": "/*\n    计算从给定数值三角形的顶部到底部路径上的最大和。\n\n    路径向下移动到下一行中最近的左侧或右侧数字。向左和向右的移动次数之差不得超过一。\n\n    参数：\n    - triangle: 一个i32的向量的向量，表示数值三角形的各行。每个内部向量表示三角形中的一行。\n\n    返回值：\n    - 从三角形顶部到底部的任何有效路径上可以达到的最大和。\n\n    示例：\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 返回 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 返回 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "fr": "/*\n    Calcule la somme maximale des nombres le long d'un chemin du haut vers le bas d'un triangle numérique donné.\n\n    Le chemin se déplace vers le bas soit vers le nombre le plus proche à gauche soit à droite sur la ligne suivante. La différence entre le nombre de mouvements vers la gauche et vers la droite ne doit pas dépasser un.\n\n    Arguments :\n    - triangle : Un vecteur de vecteurs de i32, représentant les lignes du triangle numérique. Chaque vecteur interne représente une ligne dans le triangle.\n\n    Renvoie :\n    - La somme maximale réalisable sur un chemin valide du haut vers le bas du triangle.\n\n    Exemples :\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) renvoie 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) renvoie 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "de": "/*\n    Berechnet die maximale Summe von Zahlen entlang eines Pfades von der Spitze bis zum Boden eines gegebenen numerischen Dreiecks.\n\n    Der Pfad bewegt sich nach unten entweder zur nächstgelegenen linken oder rechten Zahl in der nächsten Reihe. Der Unterschied zwischen der Anzahl der Bewegungen nach links und nach rechts darf nicht mehr als eins betragen.\n\n    Argumente:\n    - triangle: Ein Vektor von Vektoren von i32, der die Reihen des numerischen Dreiecks darstellt. Jeder innere Vektor repräsentiert eine Reihe im Dreieck.\n\n    Rückgabewert:\n    - Die maximale Summe, die auf einem gültigen Pfad von der Spitze bis zum Boden des Dreiecks erreichbar ist.\n\n    Beispiele:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) gibt 27 zurück\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) gibt 11 zurück\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "ha": "/*\n    Lissafa mafi girman jimillar lambobi a kan hanya daga saman zuwa ƙasan wani alwatika na lambobi da aka bayar.\n\n    Hanyar tana motsawa ƙasa zuwa ko dai mafi kusa hagu ko dama lamba a kan layi na gaba. Bambanci tsakanin yawan motsi zuwa hagu da dama bai kamata ya wuce ɗaya ba.\n\n    Huɗɗa:\n    - triangle: Wata vector na vectors na i32, yana wakiltar layukan alwatika na lambobi. Kowace vector ta ciki tana wakiltar layi a cikin alwatikan.\n\n    Mayarwa:\n    - Mafi girman jimilla da za a iya samu a kan kowace hanya mai inganci daga saman zuwa ƙasan alwatikan.\n\n    Misalai:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "hi": "/*\n    दिए गए संख्यात्मक त्रिभुज के शीर्ष से नीचे तक के पथ के साथ संख्याओं का अधिकतम योगफल गणना करता है।\n\n    पथ अगले पंक्ति में या तो निकटतम बाएं या दाएं संख्या की ओर नीचे की ओर चलता है। बाएं और दाएं की ओर जाने वाले चालों की संख्या के बीच का अंतर एक से अधिक नहीं होना चाहिए।\n\n    तर्क:\n    - triangle: i32 के वेक्टर का एक वेक्टर, जो संख्यात्मक त्रिभुज की पंक्तियों का प्रतिनिधित्व करता है। प्रत्येक आंतरिक वेक्टर त्रिभुज में एक पंक्ति का प्रतिनिधित्व करता है।\n\n    लौटाता है:\n    - त्रिभुज के शीर्ष से नीचे तक किसी भी मान्य पथ पर प्राप्त किया जा सकने वाला अधिकतम योगफल।\n\n    उदाहरण:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 ",
      "hu": "/*\n    Kiszámítja a maximális összeget a számok mentén egy adott numerikus háromszög tetejétől az aljáig vezető úton.\n\n    Az út lefelé mozog a következő sorban lévő legközelebbi bal vagy jobb szám felé. A balra és jobbra történő mozgások számának különbsége nem haladhatja meg az egyet.\n\n    Argumentumok:\n    - triangle: Vektorok vektora i32 típusú elemekkel, amely a numerikus háromszög sorait képviseli. Minden belső vektor egy sort képvisel a háromszögben.\n\n    Visszatér:\n    - A maximális összeg, amely bármely érvényes úton elérhető a háromszög tetejétől az aljáig.\n\n    Példák:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) visszatér 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) visszatér 11\n*/\n\nfn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9707838545143403",
      "hy": "0.9628384406425639",
      "bn": "0.9804005444121445",
      "bg": "0.9864039490485429",
      "zh": "0.968629509401636",
      "fr": "0.9926359772535126",
      "de": "0.9765862452051315",
      "ha": "0.9586618396205432",
      "hi": "0.9785834736864373",
      "hu": "0.9542299985588928"
    },
    "canonical_solution": "{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}",
    "instruction": {
      "en": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nরাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nДайте кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nBa da taƙaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32\n{\n    let n = triangle.len();\n    let mut dp = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n    let mut kt = vec![vec![0i32; n + 1]; n + 1]; // Explicitly specifying type as i32\n\n    for i in 1..=n {\n        for j in 1..=i {\n            dp[i][j] = triangle[i - 1][j - 1];\n        }\n    }\n\n    for i in 2..=n {\n        for j in 1..=i {\n            if dp[i - 1][j] > dp[i - 1][j - 1] {\n                dp[i][j] += dp[i - 1][j];\n                kt[i][j] = kt[i - 1][j] - 1;\n            } else {\n                dp[i][j] += dp[i - 1][j - 1];\n                kt[i][j] = kt[i - 1][j - 1] + 1;\n            }\n        }\n    }\n\n    let mut maxx = i32::MIN;\n    for i in 1..=n {\n        if dp[n][i] > maxx && kt[n][i].abs() <= 1 {\n            maxx = dp[n][i];\n        }\n    }\n    maxx\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9487354849587057",
      "bn": "0.8851102013056104",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9536426485221726",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]), 27);\n        assert_eq!(max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]), 8);      \n    }\n    \n\n}",
    "entry_point": "max_triangle_path_sum",
    "signature": "fn max_triangle_path_sum(triangle: Vec<Vec<i32>>) -> i32",
    "docstring": {
      "en": "Calculates the maximum sum of numbers along a path from the top to the bottom of a given numerical triangle.\n\n    The path moves down to either the nearest left or right number on the next row. The difference between the number of moves to the left and to the right must not exceed one.\n\n    Arguments:\n    - triangle: A vector of vectors of i32, representing the rows of the numerical triangle. Each inner vector represents a row in the triangle.\n\n    Returns:\n    - The maximum sum achievable on any valid path from the top to the bottom of the triangle.\n\n    Examples:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "sq": "Llogarit shumën maksimale të numrave përgjatë një rruge nga maja në fund të një trekëndëshi numerik të dhënë.\n\n    Rruga lëviz poshtë ose te numri më i afërt majtas ose djathtas në rreshtin tjetër. Diferenca midis numrit të lëvizjeve majtas dhe djathtas nuk duhet të kalojë një.\n\n    Argumentet:\n    - triangle: Një vektor i vektorëve të i32, që përfaqëson rreshtat e trekëndëshit numerik. Çdo vektor i brendshëm përfaqëson një rresht në trekëndësh.\n\n    Kthen:\n    - Shuma maksimale e arritshme në çdo rrugë të vlefshme nga maja në fund të trekëndëshit.\n\n    Shembuj:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) kthen 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) kthen 11",
      "hy": "Հաշվում է առավելագույն գումարը թվերի, որոնք գտնվում են ուղու երկայնքով, սկսած վերևից մինչև ներքև տրված թվային եռանկյունու մեջ:\n\nՈւղին շարժվում է ներքև դեպի հաջորդ շարքի ամենամոտ ձախ կամ աջ թիվը: Ձախ և աջ շարժումների քանակների տարբերությունը չպետք է գերազանցի մեկին:\n\nԱրձանագրություններ:\n- եռանկյունի: i32 վեկտորների վեկտոր, որը ներկայացնում է թվային եռանկյունու շարքերը: Յուրաքանչյուր ներքին վեկտոր ներկայացնում է եռանկյունու մի շարք:\n\nՎերադարձնում է:\n- Առավելագույն գումարը, որը հնարավոր է հասնել ցանկացած վավեր ուղու վրա, սկսած եռանկյունու վերևից մինչև ներքև:\n\nՕրինակներ:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) վերադարձնում է 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) վերադարձնում է 11",
      "bn": "শীর্ষ থেকে প্রদত্ত সংখ্যাসূচক ত্রিভুজের নীচ পর্যন্ত একটি পথে সংখ্যাগুলির সর্বাধিক যোগফল গণনা করে।\n\n    পথটি পরবর্তী সারিতে নিকটতম বাম বা ডান সংখ্যায় নিচে চলে যায়। বাম দিকে এবং ডান দিকে চলার মধ্যে পার্থক্য একটির বেশি হতে পারবে না।\n\n    আর্গুমেন্টসমূহ:\n    - triangle: i32 এর ভেক্টরের একটি ভেক্টর, যা সংখ্যাসূচক ত্রিভুজের সারিগুলি উপস্থাপন করে। প্রতিটি অভ্যন্তরীণ ভেক্টর ত্রিভুজের একটি সারি উপস্থাপন করে।\n\n    রিটার্নস:\n    - ত্রিভুজের শীর্ষ থেকে নীচ পর্যন্ত যেকোনো বৈধ পথে অর্জনযোগ্য সর্বাধিক যোগফল।\n\n    উদাহরণসমূহ:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 রিটার্ন করে\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 রিটার্ন করে",
      "bg": "Изчислява максималната сума от числа по път от върха до дъното на даден числов триъгълник.\n\nПътят се движи надолу към най-близкото ляво или дясно число на следващия ред. Разликата между броя на ходовете наляво и надясно не трябва да надвишава едно.\n\nАргументи:\n- triangle: Вектор от вектори от i32, представляващ редовете на числовия триъгълник. Всеки вътрешен вектор представлява ред в триъгълника.\n\nВръща:\n- Максималната сума, която може да се постигне по валиден път от върха до дъното на триъгълника.\n\nПримери:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) връща 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) връща 11",
      "zh": "计算从给定的数字三角形的顶部到底部路径上的最大数字和。\n\n路径向下移动到下一行中最接近的左侧或右侧数字。向左和向右移动的次数之差不得超过一。\n\n参数:\n- triangle: 一个i32的向量的向量，表示数字三角形的行。每个内部向量表示三角形中的一行。\n\n返回值:\n- 从三角形顶部到底部的任何有效路径上可达到的最大和。\n\n示例:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 返回 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 返回 11",
      "fr": "Calcule la somme maximale de nombres le long d'un chemin du sommet à la base d'un triangle numérique donné.\n\nLe chemin descend vers le nombre le plus proche à gauche ou à droite sur la ligne suivante. La différence entre le nombre de mouvements vers la gauche et vers la droite ne doit pas dépasser un.\n\nArguments:\n- triangle: Un vecteur de vecteurs de i32, représentant les lignes du triangle numérique. Chaque vecteur interne représente une ligne dans le triangle.\n\nReturns:\n- La somme maximale réalisable sur un chemin valide du sommet à la base du triangle.\n\nExamples:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "de": "Berechnet die maximale Summe von Zahlen entlang eines Pfades von der Spitze bis zum Boden eines gegebenen numerischen Dreiecks.\n\n    Der Pfad bewegt sich entweder zum nächstgelegenen linken oder rechten Wert in der nächsten Zeile. Der Unterschied zwischen der Anzahl der Bewegungen nach links und nach rechts darf nicht mehr als eins betragen.\n\n    Argumente:\n    - triangle: Ein Vektor von Vektoren von i32, der die Reihen des numerischen Dreiecks darstellt. Jeder innere Vektor repräsentiert eine Reihe im Dreieck.\n\n    Rückgabewerte:\n    - Die maximale Summe, die auf einem gültigen Pfad von der Spitze bis zum Boden des Dreiecks erreichbar ist.\n\n    Beispiele:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) gibt 27 zurück\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) gibt 11 zurück",
      "ha": "Lissafa mafi girman jimlar lambobi tare da hanya daga saman zuwa kasan wani alwatika na lambobi.\n\n    Hanyar tana motsawa ƙasa zuwa ko dai mafi kusa hagu ko dama lamba a kan layi na gaba. Bambanci tsakanin adadin motsi zuwa hagu da dama bai kamata ya wuce ɗaya ba.\n\n    Huɗɗa:\n    - triangle: Wata vector na vectors na i32, wanda ke wakiltar layukan alwatika na lambobi. Kowanne vector na ciki yana wakiltar layi a cikin alwatika.\n\n    Komawa:\n    - Mafi girman jimlar da za a iya samu akan kowace hanya mai inganci daga saman zuwa ƙasan alwatika.\n\n    Misalai:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) returns 27\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) returns 11",
      "hi": "गणना करता है कि दिए गए संख्यात्मक त्रिभुज के शीर्ष से नीचे तक के पथ के साथ संख्याओं का अधिकतम योगफल क्या है।\n\n    पथ अगले पंक्ति में या तो निकटतम बाएँ या दाएँ संख्या की ओर नीचे की ओर चलता है। बाएँ और दाएँ की ओर जाने वाले चालों की संख्या के बीच का अंतर एक से अधिक नहीं होना चाहिए।\n\n    तर्क:\n    - triangle: i32 के वेक्टर का एक वेक्टर, जो संख्यात्मक त्रिभुज की पंक्तियों का प्रतिनिधित्व करता है। प्रत्येक आंतरिक वेक्टर त्रिभुज में एक पंक्ति का प्रतिनिधित्व करता है।\n\n    लौटाता है:\n    - त्रिभुज के शीर्ष से नीचे तक किसी भी मान्य पथ पर प्राप्त होने योग्य अधिकतम योगफल।\n\n    उदाहरण:\n    - max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) 27 लौटाता है\n    - max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) 11 लौटाता है",
      "hu": "Kiszámítja a maximális összeget egy adott számháromszög tetejétől az aljáig vezető út mentén.\n\nAz út lefelé halad a következő sor legközelebbi bal vagy jobb számához. A balra és jobbra tett lépések közötti különbség nem haladhatja meg az egyet.\n\nArgumentumok:\n- triangle: Vektorok vektora i32 típusban, amely a számháromszög sorait képviseli. Minden belső vektor a háromszög egy sorát jelenti.\n\nVisszatérési érték:\n- A háromszög tetejétől az aljáig bármely érvényes úton elérhető maximális összeg.\n\nPéldák:\n- max_triangle_path_sum(vec![vec![7], vec![3, 8], vec![8, 1, 0], vec![2, 7, 4, 4], vec![4, 5, 2, 6, 5]]) visszaadja 27\n- max_triangle_path_sum(vec![vec![3], vec![3, 1], vec![5, 2, 3]]) visszaadja 11"
    },
    "docstring_bertscore": {
      "sq": "0.9680725498132141",
      "hy": "0.952289975627325",
      "bn": "0.9591107442816821",
      "bg": "0.9813132510129998",
      "zh": "0.9617781516685996",
      "fr": "0.969272475945046",
      "de": "0.9759224224717129",
      "ha": "0.9806055309653725",
      "hi": "0.9750524214027801",
      "hu": "0.9601481907618272"
    }
  },
  {
    "task_id": "Rust/15",
    "prompt": {
      "en": "/*\n    Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "sq": "/*\n    Llogarit numrin e seksioneve të dallueshme të formuara në një plan nga një grup i dhënë vijash.\n\n    Çdo vijë përfaqësohet nga një dyshe (pjerrësia, intercepti y), duke ndjekur ekuacionin y = pjerrësia * x + intercepti y.\n    Kjo funksion supozon që vijat nuk mbivendosen dhe vijat paralele nuk kontribuojnë në seksione të reja.\n\n    Argumentet:\n    - lines: Një segment dysheve, ku çdo dyshe përfaqëson një vijë në plan me pjerrësinë dhe interceptin y si (i32, i32).\n\n    Kthen:\n    - Një numër të plotë që përfaqëson numrin total të seksioneve të dallueshme të formuara në plan.\n\n    Shembull:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) kthen 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) kthen 2 (Vija paralele)\n    - count_plane_sections(&[]) kthen 0 (Pa vija)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize",
      "hy": "/*\n    Հաշվում է հարթության վրա տրված գծերի հավաքածուով ձևավորված տարբեր հատվածների քանակը։\n\n    Յուրաքանչյուր գիծ ներկայացված է (թեքություն, y-հատվող) տուփով, հետևելով հավասարմանը y = թեքություն * x + y-հատվող։\n    Այս ֆունկցիան ենթադրում է, որ գծերը չեն համընկնում, և զուգահեռ գծերը նոր հատվածներ չեն ստեղծում։\n\n    Արգումենտներ:\n    - lines: Տուփերի շերտ, որտեղ յուրաքանչյուր տուփ ներկայացնում է հարթության վրա գիծ իր թեքությամբ և y-հատվողով որպես (i32, i32)։\n\n    Վերադարձնում է:\n    - Թիվ, որը ներկայացնում է հարթության վրա ձևավորված տարբեր հատվածների ընդհանուր քանակը։\n\n    Օրինակ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) վերադարձնում է 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) վերադարձնում է 2 (զուգահեռ գծեր)\n    - count_plane_sections(&[]) վերադարձնում է 0 (գծեր չկան)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "bn": "/*\n    একটি নির্দিষ্ট রেখার সেট দ্বারা সমতলে গঠিত পৃথক বিভাগগুলির সংখ্যা গণনা করে।\n\n    প্রতিটি রেখা একটি টুপল (ঢাল, y-অবস্থান) দ্বারা উপস্থাপিত হয়, যা সমীকরণ y = slope * x + y-intercept অনুসরণ করে।\n    এই ফাংশনটি ধরে নেয় যে রেখাগুলি ওভারল্যাপ করছে না এবং সমান্তরাল রেখাগুলি নতুন বিভাগে অবদান রাখে না।\n\n    আর্গুমেন্টসমূহ:\n    - lines: টুপলের একটি স্লাইস, যেখানে প্রতিটি টুপল সমতলে একটি রেখাকে তার ঢাল এবং y-অবস্থান হিসাবে (i32, i32) দিয়ে উপস্থাপন করে।\n\n    রিটার্নস:\n    - একটি পূর্ণসংখ্যা যা সমতলে গঠিত মোট পৃথক বিভাগগুলির সংখ্যা উপস্থাপন করে।\n\n    উদাহরণ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 রিটার্ন করে\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 রিটার্ন করে (সমান্তরাল রেখা)\n    - count_plane_sections(&[]) 0 রিটার্ন করে (কোনো রেখা নেই)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "bg": "/*\n    Изчислява броя на различните сечения, образувани на равнина от даден набор от прави линии.\n\n    Всяка линия е представена чрез кортеж (наклон, пресечна точка с y-оста), следвайки уравнението y = наклон * x + пресечна точка с y-оста.\n    Тази функция приема, че линиите не се припокриват и успоредните линии не допринасят за нови сечения.\n\n    Аргументи:\n    - lines: Срез от кортежи, където всеки кортеж представлява линия на равнината с нейния наклон и пресечна точка с y-оста като (i32, i32).\n\n    Връща:\n    - Цяло число, представляващо общия брой на различните сечения, образувани на равнината.\n\n    Пример:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) връща 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) връща 2 (Успоредни линии)\n    - count_plane_sections(&[]) връща 0 (Няма линии)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "zh": "/*\n    计算由给定直线集合在平面上形成的不同区域的数量。\n\n    每条直线由一个元组 (斜率, y-截距) 表示，遵循方程 y = 斜率 * x + y-截距。\n    此函数假设直线不重叠且平行线不产生新区域。\n\n    参数:\n    - lines: 一个元组的切片，其中每个元组表示平面上的一条直线，其斜率和y-截距为 (i32, i32)。\n\n    返回:\n    - 一个整数，表示平面上形成的不同区域的总数。\n\n    示例:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 返回 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) 返回 2 (平行线)\n    - count_plane_sections(&[]) 返回 0 (没有直线)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "fr": "/*\n    Calcule le nombre de sections distinctes formées sur un plan par un ensemble donné de lignes.\n\n    Chaque ligne est représentée par un tuple (pente, ordonnée à l'origine), suivant l'équation y = pente * x + ordonnée à l'origine.\n    Cette fonction suppose que les lignes ne se chevauchent pas et que les lignes parallèles ne contribuent pas à de nouvelles sections.\n\n    Arguments:\n    - lines: Une tranche de tuples, où chaque tuple représente une ligne sur le plan avec sa pente et son ordonnée à l'origine comme (i32, i32).\n\n    Renvoie:\n    - Un entier représentant le nombre total de sections distinctes formées sur le plan.\n\n    Exemple:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) renvoie 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) renvoie 2 (Lignes parallèles)\n    - count_plane_sections(&[]) renvoie 0 (Aucune ligne)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "de": "/*\n    Berechnet die Anzahl der unterschiedlichen Abschnitte, die auf einer Ebene durch eine gegebene Menge von Linien gebildet werden.\n\n    Jede Linie wird durch ein Tupel (Steigung, y-Achsenabschnitt) dargestellt, entsprechend der Gleichung y = Steigung * x + y-Achsenabschnitt.\n    Diese Funktion nimmt an, dass sich Linien nicht überlappen und parallele Linien nicht zu neuen Abschnitten beitragen.\n\n    Argumente:\n    - lines: Ein Slice von Tupeln, wobei jedes Tupel eine Linie auf der Ebene mit ihrer Steigung und ihrem y-Achsenabschnitt als (i32, i32) darstellt.\n\n    Rückgabewerte:\n    - Eine ganze Zahl, die die Gesamtzahl der unterschiedlichen Abschnitte auf der Ebene darstellt.\n\n    Beispiel:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) gibt 6 zurück\n    - count_plane_sections(&[(0, 1), (0, 2)]) gibt 2 zurück (Parallele Linien)\n    - count_plane_sections(&[]) gibt 0 zurück (Keine Linien)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "ha": "/*\n    Lissafa adadin sassan daban-daban da aka samar a kan wani fili ta hanyar wani saiti na layuka.\n\n    Kowanne layi ana wakilta shi da wani tuple (zube, y-intercept), yana bin daidaiton y = zube * x + y-intercept.\n    Wannan aiki yana dauka cewa layuka ba sa maimaita juna kuma layuka masu layi daya ba sa bayar da gudummawa ga sabbin sassa.\n\n    Hujojji:\n    - lines: Wani yanki na tuples, inda kowanne tuple ke wakiltar layi a kan fili tare da zubensa da y-intercept dinsa a matsayin (i32, i32).\n\n    Komawa:\n    - Wani cikakken lamba da ke wakiltar adadin sassan daban-daban da aka samar a kan fili.\n\n    Misali:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Layuka masu layi daya)\n    - count_plane_sections(&[]) returns 0 (Babu layi)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "hi": "/*\n    दिए गए रेखाओं के सेट द्वारा एक समतल पर बने विशिष्ट खंडों की संख्या की गणना करता है।\n\n    प्रत्येक रेखा को एक टपल (ढलान, y-अवरोध) द्वारा दर्शाया गया है, जो समीकरण y = slope * x + y-intercept का पालन करता है।\n    यह फ़ंक्शन मानता है कि रेखाएँ ओवरलैप नहीं हो रही हैं और समानांतर रेखाएँ नए खंडों में योगदान नहीं करती हैं।\n\n    तर्क:\n    - lines: टपल्स का एक स्लाइस, जहाँ प्रत्येक टपल समतल पर एक रेखा को उसके ढलान और y-अवरोध के रूप में (i32, i32) के रूप में दर्शाता है।\n\n    लौटाता है:\n    - एक पूर्णांक जो समतल पर बने विशिष्ट खंडों की कुल संख्या का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 लौटाता है\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 लौटाता है (समानांतर रेखाएँ)\n    - count_plane_sections(&[]) 0 लौटाता है (कोई रेखाएँ नहीं)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize ",
      "hu": "/*\n    Kiszámítja, hogy hány különálló szakasz alakul ki egy síkon egy adott egyeneskészlet által.\n\n    Minden egyenes egy (meredekség, y-metszet) párként van ábrázolva, az y = meredekség * x + y-metszet egyenlet szerint.\n    Ez a függvény feltételezi, hogy az egyenesek nem fedik át egymást, és a párhuzamos egyenesek nem járulnak hozzá új szakaszokhoz.\n\n    Argumentumok:\n    - lines: Egy párokból álló szelet, ahol minden pár egy egyenest ábrázol a síkon a meredekségével és y-metszetével (i32, i32) formában.\n\n    Visszatér:\n    - Egy egész szám, amely a síkon kialakult különálló szakaszok teljes számát jelenti.\n\n    Példa:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) visszaadja a 6-ot\n    - count_plane_sections(&[(0, 1), (0, 2)]) visszaadja a 2-t (Párhuzamos egyenesek)\n    - count_plane_sections(&[]) visszaadja a 0-t (Nincsenek egyenesek)\n*/\n\nuse std::collections::HashSet;\n\nfn count_plane_sections(lines: &[(i32, i32)]) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9805165445546689",
      "hy": "0.9660483076000876",
      "bn": "0.9746684688762397",
      "bg": "0.9947039181504668",
      "zh": "0.9698872369743489",
      "fr": "0.9870548608071943",
      "de": "0.9870381758551874",
      "ha": "0.9803306265180202",
      "hi": "0.9830182942038033",
      "hu": "0.9609742945165514"
    },
    "canonical_solution": "{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}",
    "instruction": {
      "en": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nনিচের Rust কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize\n{\n    let unique_lines: HashSet<(i32, i32)> = lines.iter().cloned().collect();\n    let unique_lines: Vec<(i32, i32)> = unique_lines.into_iter().collect();\n\n    if unique_lines.is_empty() {\n        return 0;\n    }\n\n    let mut ans = 2;\n    for i in 1..unique_lines.len() {\n        let (k1, b1) = unique_lines[i];\n        let mut intersections = HashSet::new();\n\n        for j in 0..i {\n            let (k2, b2) = unique_lines[j];\n            if k1 == k2 {\n                continue;\n            }\n\n            let x = (b2 - b1) as f64 / (k1 - k2) as f64;\n            let y = k1 as f64 * x + b1 as f64;\n            // Store the intersection as a string to avoid floating-point hashing issues\n            intersections.insert(format!(\"{},{}\", x, y));\n        }\n\n        ans += intersections.len() + 1;\n    }\n\n    ans\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9359474623972985",
      "bn": "0.8706957931842895",
      "bg": "0.8316696904400789",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9021419619578278",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_plane_sections(&[(1, 1), (2, 2), (3, 3)]), 6);\n        assert_eq!(count_plane_sections(&[(0, 1), (0, 2)]), 3);\n    }\n    \n\n}\n ",
    "entry_point": "count_plane_sections",
    "signature": "fn count_plane_sections(lines: &[(i32, i32)]) -> usize",
    "docstring": {
      "en": "Calculates the number of distinct sections formed on a plane by a given set of lines.\n\n    Each line is represented by a tuple (slope, y-intercept), following the equation y = slope * x + y-intercept.\n    This function assumes lines are not overlapping and parallel lines do not contribute to new sections.\n\n    Arguments:\n    - lines: A slice of tuples, where each tuple represents a line on the plane with its slope and y-intercept as (i32, i32).\n\n    Returns:\n    - An integer representing the total number of distinct sections formed on the plane.\n\n    Example:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Parallel lines)\n    - count_plane_sections(&[]) returns 0 (No lines)",
      "sq": "Llogarit numrin e seksioneve të dallueshme të formuara në një plan nga një grup i dhënë vijash.\n\n    Çdo vijë përfaqësohet nga një dyshe (pjerrësia, prerja në boshtin y), duke ndjekur ekuacionin y = pjerrësia * x + prerja në boshtin y.\n    Kjo funksion supozon se vijat nuk mbivendosen dhe vijat paralele nuk kontribuojnë në seksione të reja.\n\n    Argumentet:\n    - lines: Një segment dysheve, ku çdo dyshe përfaqëson një vijë në plan me pjerrësinë dhe prerjen në boshtin y si (i32, i32).\n\n    Kthen:\n    - Një numër i plotë që përfaqëson numrin total të seksioneve të dallueshme të formuara në plan.\n\n    Shembull:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) kthen 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) kthen 2 (Vija paralele)\n    - count_plane_sections(&[]) kthen 0 (Pa vija)",
      "hy": "Հաշվում է հարթության վրա տրված գծերի հավաքածուով ձևավորված տարբեր հատվածների քանակը:\n\n    Յուրաքանչյուր գիծ ներկայացված է (թեքություն, y-հատված) զույգով, հետևելով հավասարմանը y = թեքություն * x + y-հատված:\n    Այս ֆունկցիան ենթադրում է, որ գծերը չեն համընկնում և զուգահեռ գծերը չեն նպաստում նոր հատվածների ձևավորմանը:\n\n    Արգումենտներ:\n    - lines: Զույգերի մի կտոր, որտեղ յուրաքանչյուր զույգ ներկայացնում է հարթության վրա գիծ իր թեքությամբ և y-հատվածով որպես (i32, i32):\n\n    Վերադարձնում է.\n    - Թիվ, որը ներկայացնում է հարթության վրա ձևավորված տարբեր հատվածների ընդհանուր քանակը:\n\n    Օրինակ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) վերադարձնում է 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) վերադարձնում է 2 (Զուգահեռ գծեր)\n    - count_plane_sections(&[]) վերադարձնում է 0 (Գծեր չկան)",
      "bn": "প্লেনে প্রদত্ত রেখাগুলির সেট দ্বারা গঠিত পৃথক বিভাগগুলির সংখ্যা গণনা করে।\n\n    প্রতিটি রেখা একটি টুপল (ঢাল, y-অবস্থান) দ্বারা উপস্থাপিত হয়, যা সমীকরণ y = slope * x + y-intercept অনুসরণ করে।\n    এই ফাংশনটি ধরে নেয় যে রেখাগুলি ওভারল্যাপ করছে না এবং সমান্তরাল রেখাগুলি নতুন বিভাগে অবদান রাখে না।\n\n    আর্গুমেন্টস:\n    - lines: টুপলের একটি স্লাইস, যেখানে প্রতিটি টুপল প্লেনে একটি রেখাকে তার ঢাল এবং y-অবস্থান হিসাবে (i32, i32) দিয়ে উপস্থাপন করে।\n\n    রিটার্নস:\n    - একটি পূর্ণসংখ্যা যা প্লেনে গঠিত মোট পৃথক বিভাগের সংখ্যা উপস্থাপন করে।\n\n    উদাহরণ:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 রিটার্ন করে\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 রিটার্ন করে (সমান্তরাল রেখা)\n    - count_plane_sections(&[]) 0 রিটার্ন করে (কোনো রেখা নেই)",
      "bg": "Изчислява броя на различните секции, образувани на равнината от даден набор от прави линии.\n\n    Всяка линия е представена от кортеж (наклон, y-пресечна точка), следвайки уравнението y = наклон * x + y-пресечна точка.\n    Тази функция предполага, че линиите не се припокриват и паралелните линии не допринасят за нови секции.\n\n    Аргументи:\n    - lines: Срез от кортежи, където всеки кортеж представлява линия на равнината с нейния наклон и y-пресечна точка като (i32, i32).\n\n    Връща:\n    - Цяло число, представляващо общия брой на различните секции, образувани на равнината.\n\n    Пример:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) връща 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) връща 2 (Паралелни линии)\n    - count_plane_sections(&[]) връща 0 (Няма линии)",
      "zh": "计算给定的一组直线在平面上形成的不同区域的数量。\n\n每条直线由一个元组 (斜率, y-截距) 表示，遵循方程 y = 斜率 * x + y-截距。\n此函数假设直线不重叠且平行线不形成新的区域。\n\n参数:\n- lines: 一个元组切片，其中每个元组表示平面上的一条直线，其斜率和 y-截距为 (i32, i32)。\n\n返回:\n- 一个整数，表示在平面上形成的不同区域的总数。\n\n示例:\n- count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 返回 6\n- count_plane_sections(&[(0, 1), (0, 2)]) 返回 2 (平行线)\n- count_plane_sections(&[]) 返回 0 (无直线)",
      "fr": "Calcule le nombre de sections distinctes formées sur un plan par un ensemble donné de lignes.\n\n    Chaque ligne est représentée par un tuple (pente, ordonnée à l'origine), suivant l'équation y = pente * x + ordonnée à l'origine.\n    Cette fonction suppose que les lignes ne se chevauchent pas et que les lignes parallèles ne contribuent pas à de nouvelles sections.\n\n    Arguments:\n    - lines: Une tranche de tuples, où chaque tuple représente une ligne sur le plan avec sa pente et son ordonnée à l'origine comme (i32, i32).\n\n    Retourne:\n    - Un entier représentant le nombre total de sections distinctes formées sur le plan.\n\n    Exemple:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) retourne 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) retourne 2 (Lignes parallèles)\n    - count_plane_sections(&[]) retourne 0 (Pas de lignes)",
      "de": "Berechnet die Anzahl der unterschiedlichen Abschnitte, die auf einer Ebene durch eine gegebene Menge von Linien gebildet werden.\n\n    Jede Linie wird durch ein Tupel (Steigung, y-Achsenabschnitt) dargestellt, gemäß der Gleichung y = Steigung * x + y-Achsenabschnitt.\n    Diese Funktion geht davon aus, dass sich Linien nicht überlappen und parallele Linien nicht zu neuen Abschnitten beitragen.\n\n    Argumente:\n    - lines: Ein Slice von Tupeln, wobei jedes Tupel eine Linie auf der Ebene mit ihrer Steigung und ihrem y-Achsenabschnitt als (i32, i32) darstellt.\n\n    Rückgabewert:\n    - Eine ganze Zahl, die die Gesamtanzahl der unterschiedlichen Abschnitte darstellt, die auf der Ebene gebildet werden.\n\n    Beispiel:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) gibt 6 zurück\n    - count_plane_sections(&[(0, 1), (0, 2)]) gibt 2 zurück (Parallele Linien)\n    - count_plane_sections(&[]) gibt 0 zurück (Keine Linien)",
      "ha": "Lissafa adadin sassan daban-daban da aka samar a kan wani fili ta hanyar wani saiti na layuka.\n\n    Kowanne layi ana wakilta shi da wani tuple (slope, y-intercept), bisa ga daidaiton y = slope * x + y-intercept.\n    Wannan aikin yana ɗauka cewa layuka ba sa maimaita juna kuma layuka masu layi ɗaya ba sa ƙara sabbin sassa.\n\n    Huɗɗa:\n    - lines: Wani yanki na tuples, inda kowanne tuple ke wakiltar wani layi a kan faifai tare da gangara da y-intercept a matsayin (i32, i32).\n\n    Komawa:\n    - Wani cikakken lamba wanda ke wakiltar jimlar adadin sassa daban-daban da aka kafa a kan faifai.\n\n    Misali:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) returns 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) returns 2 (Layuka masu layi ɗaya)\n    - count_plane_sections(&[]) returns 0 (Babu layi)",
      "hi": "विमान पर दिए गए रेखाओं के सेट द्वारा निर्मित विभिन्न खंडों की संख्या की गणना करता है।\n\n    प्रत्येक रेखा को एक टपल (ढलान, y-अवरोध) द्वारा दर्शाया जाता है, जो समीकरण y = slope * x + y-intercept का अनुसरण करता है।\n    यह फ़ंक्शन मानता है कि रेखाएँ ओवरलैप नहीं कर रही हैं और समानांतर रेखाएँ नए खंडों में योगदान नहीं करती हैं।\n\n    तर्क:\n    - lines: टपल का एक स्लाइस, जहाँ प्रत्येक टपल विमान पर एक रेखा का प्रतिनिधित्व करता है, जिसमें उसका ढलान और y-अवरोध (i32, i32) के रूप में होता है।\n\n    वापसी:\n    - एक पूर्णांक जो विमान पर निर्मित विभिन्न खंडों की कुल संख्या का प्रतिनिधित्व करता है।\n\n    उदाहरण:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) 6 लौटाता है\n    - count_plane_sections(&[(0, 1), (0, 2)]) 2 लौटाता है (समानांतर रेखाएँ)\n    - count_plane_sections(&[]) 0 लौटाता है (कोई रेखाएँ नहीं)",
      "hu": "Számítja a síkon képződött különálló szakaszok számát a megadott egyenesek halmazával.\n\n    Minden egyenes egy (meredekség, y-metszet) párként van ábrázolva, az y = meredekség * x + y-metszet egyenlet alapján.\n    Ez a függvény feltételezi, hogy az egyenesek nem fedik egymást, és a párhuzamos egyenesek nem járulnak hozzá új szakaszokhoz.\n\n    Argumentumok:\n    - lines: Egy vágás tuple-ökből, ahol minden tuple egy egyenest ábrázol a síkon a meredekségével és y-metszetével mint (i32, i32).\n\n    Visszatér:\n    - Egy egész szám, amely a síkon képződött különálló szakaszok teljes számát képviseli.\n\n    Példa:\n    - count_plane_sections(&[(1, 1), (2, 2), (3, 3)]) visszaadja 6\n    - count_plane_sections(&[(0, 1), (0, 2)]) visszaadja 2 (Párhuzamos egyenesek)\n    - count_plane_sections(&[]) visszaadja 0 (Nincsenek egyenesek)"
    },
    "docstring_bertscore": {
      "sq": "0.9726070827818596",
      "hy": "0.9498265616417303",
      "bn": "0.9697807710901142",
      "bg": "0.9869485935533406",
      "zh": "0.9661233898841188",
      "fr": "0.9858098455788676",
      "de": "0.9829920749935067",
      "ha": "0.9747636128287553",
      "hi": "0.9796278722299188",
      "hu": "0.9658431224164785"
    }
  },
  {
    "task_id": "Rust/16",
    "prompt": {
      "en": "/*\n  Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "sq": "/*\n  Llogarit numrin e peshave të ndryshme që mund të maten duke përdorur një grup të dhënë peshash në një peshore.\n  Peshat mund të vendosen në njërën anë të peshores, dhe e njëjta peshë nuk mund të përdoret më shumë se një herë.\n\n  Argumentet:\n  - weights: Një varg i numrave të plotë që përfaqësojnë peshat.\n\n  Kthen:\n  - Numri total i peshave të ndryshme që mund të maten.\n\n  Shembull:\n  - distinct_weights_count(&[1, 4, 6]) kthen 10\n  - distinct_weights_count(&[2, 3]) kthen 5 (pesha: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) kthen 1 (vetëm zero mund të matet)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "hy": "/*\n  Հաշվում է տարբեր քաշերի քանակը, որոնք կարող են չափվել տրված քաշերի հավաքածուով հավասարակշռության կշեռքի վրա:\n  Քաշերը կարող են տեղադրվել կշեռքի երկու կողմերում, և նույն քաշը չի կարող օգտագործվել մեկից ավելի անգամ:\n\n  Արգումենտներ:\n  - weights: ամբողջ թվերի շերտ, որը ներկայացնում է քաշերը:\n\n  Վերադարձնում է:\n  - Տարբեր քաշերի ընդհանուր քանակը, որոնք կարող են չափվել:\n\n  Օրինակ:\n  - distinct_weights_count(&[1, 4, 6]) վերադարձնում է 10\n  - distinct_weights_count(&[2, 3]) վերադարձնում է 5 (քաշեր: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) վերադարձնում է 1 (կարող է չափվել միայն զրոն)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "bn": "/*\n  একটি প্রদত্ত সেটের ওজন ব্যবহার করে একটি ভারসাম্য স্কেলে মাপা যেতে পারে এমন ভিন্ন ভিন্ন ওজনের সংখ্যা গণনা করে।\n  ওজনগুলি স্কেলের যেকোনো পাশে রাখা যেতে পারে, এবং একই ওজন একাধিকবার ব্যবহার করা যাবে না।\n\n  আর্গুমেন্ট:\n  - weights: ওজনগুলি উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্নস:\n  - মাপা যেতে পারে এমন ভিন্ন ভিন্ন ওজনের মোট সংখ্যা।\n\n  উদাহরণ:\n  - distinct_weights_count(&[1, 4, 6]) 10 রিটার্ন করে\n  - distinct_weights_count(&[2, 3]) 5 রিটার্ন করে (ওজন: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 রিটার্ন করে (শুধুমাত্র শূন্য মাপা যেতে পারে)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "bg": "/*\n  Изчислява броя на различните тежести, които могат да бъдат измерени с даден набор от тежести на везна.\n  Тежестите могат да бъдат поставени от двете страни на везната и една и съща тежест не може да се използва повече от веднъж.\n\n  Аргументи:\n  - weights: Масив от цели числа, представляващи тежестите.\n\n  Връща:\n  - Общият брой на различните тежести, които могат да бъдат измерени.\n\n  Пример:\n  - distinct_weights_count(&[1, 4, 6]) връща 10\n  - distinct_weights_count(&[2, 3]) връща 5 (тежести: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) връща 1 (само нула може да бъде измерена)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "zh": "/*\n  计算使用给定的一组砝码在天平上可以测量的不同重量的数量。\n  砝码可以放在天平的任一侧，并且同一砝码不能重复使用。\n\n  参数：\n  - weights: 一个表示砝码的整数切片。\n\n  返回：\n  - 可以测量的不同重量的总数。\n\n  示例：\n  - distinct_weights_count(&[1, 4, 6]) 返回 10\n  - distinct_weights_count(&[2, 3]) 返回 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 返回 1 (只能测量零)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "fr": "/*\n  Calcule le nombre de poids distincts qui peuvent être mesurés en utilisant un ensemble donné de poids sur une balance.\n  Les poids peuvent être placés de chaque côté de la balance, et le même poids ne peut pas être utilisé plus d'une fois.\n\n  Arguments:\n  - weights: Une tranche d'entiers représentant les poids.\n\n  Renvoie:\n  - Le nombre total de poids distincts qui peuvent être mesurés.\n\n  Exemple:\n  - distinct_weights_count(&[1, 4, 6]) renvoie 10\n  - distinct_weights_count(&[2, 3]) renvoie 5 (poids: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) renvoie 1 (seul zéro peut être mesuré)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "de": "/*\n  Berechnet die Anzahl der unterschiedlichen Gewichte, die mit einem gegebenen Satz von Gewichten auf einer Waage gemessen werden können.\n  Die Gewichte können auf beiden Seiten der Waage platziert werden, und dasselbe Gewicht kann nicht mehr als einmal verwendet werden.\n\n  Argumente:\n  - weights: Ein Slice von Ganzzahlen, das die Gewichte darstellt.\n\n  Rückgabe:\n  - Die Gesamtanzahl der unterschiedlichen Gewichte, die gemessen werden können.\n\n  Beispiel:\n  - distinct_weights_count(&[1, 4, 6]) gibt 10 zurück\n  - distinct_weights_count(&[2, 3]) gibt 5 zurück (Gewichte: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) gibt 1 zurück (nur null kann gemessen werden)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "ha": "/*\n  Lissafa adadin nau'ikan nauyi daban-daban da za a iya auna amfani da saitin nauyi da aka bayar akan ma'aunin ma'auni.\n  Ana iya sanya nauyin a kowane gefe na ma'aunin, kuma ba za a iya amfani da nauyi ɗaya fiye da sau ɗaya ba.\n\n  Huɗɗa:\n  - weights: Wani yanki na lambobi masu nuna nauyin.\n\n  Mayarwa:\n  - Jimlar adadin nau'ikan nauyi daban-daban da za a iya auna.\n\n  Misali:\n  - distinct_weights_count(&[1, 4, 6]) yana mayar da 10\n  - distinct_weights_count(&[2, 3]) yana mayar da 5 (nauyi: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) yana mayar da 1 (kawai sifili za a iya auna)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "hi": "/*\n  एक तराजू पर दिए गए वजन के सेट का उपयोग करके मापे जा सकने वाले भिन्न-भिन्न वजन की संख्या की गणना करता है।\n  वजन को तराजू के किसी भी तरफ रखा जा सकता है, और एक ही वजन को एक से अधिक बार उपयोग नहीं किया जा सकता।\n\n  तर्क:\n  - weights: पूर्णांकों का एक स्लाइस जो वजन का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - भिन्न-भिन्न वजन की कुल संख्या जो मापी जा सकती है।\n\n  उदाहरण:\n  - distinct_weights_count(&[1, 4, 6]) 10 लौटाता है\n  - distinct_weights_count(&[2, 3]) 5 लौटाता है (वजन: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 लौटाता है (केवल शून्य मापा जा सकता है)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 ",
      "hu": "/*\n  Számolja ki a különböző súlyok számát, amelyeket egy adott súlykészlettel lehet mérni egy mérleg segítségével.\n  A súlyok a mérleg mindkét oldalára helyezhetők, és ugyanazt a súlyt nem lehet többször használni.\n\n  Argumentumok:\n  - weights: Egész számokat tartalmazó szelet, amely a súlyokat reprezentálja.\n\n  Visszatér:\n  - A mérhető különböző súlyok teljes száma.\n\n  Példa:\n  - distinct_weights_count(&[1, 4, 6]) visszaadja 10\n  - distinct_weights_count(&[2, 3]) visszaadja 5 (súlyok: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) visszaadja 1 (csak a nulla mérhető)\n*/\n\n\nfn distinct_weights_count(weights: &[i32]) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9739947146237693",
      "hy": "0.9880194099374997",
      "bn": "0.9776896369717804",
      "bg": "0.9747258730563587",
      "zh": "0.9585206134196274",
      "fr": "0.9840944736082503",
      "de": "0.9839764871619155",
      "ha": "0.9553941712221382",
      "hi": "0.9870232785766098",
      "hu": "0.9610624864057309"
    },
    "canonical_solution": "{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}",
    "instruction": {
      "en": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段Rust代码，字数不超过500个字符。",
      "fr": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn distinct_weights_count(weights: &[i32]) -> i32\n{\n    let sum: i32 = weights.iter().sum();\n    let n = weights.len();\n    let mut f = vec![vec![false; (2 * sum + 1) as usize]; n + 1];\n\n    f[0][(sum + 0) as usize] = true; // Offset by sum to handle negative indices\n\n    for i in 1..=n {\n        for j in 0..=(2 * sum) as usize {\n            let weight = weights[i - 1] as usize;\n            f[i][j] |= f[i - 1][j]; // Case when not choosing the weight\n\n            if j >= weight {\n                f[i][j] |= f[i - 1][j - weight]; // Case when adding the weight to one side\n            }\n\n            if j + weight <= 2 * sum as usize {\n                f[i][j] |= f[i - 1][j + weight]; // Case when adding the weight to the other side\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in sum + 1..=2 * sum {\n        if f[n][i as usize] {\n            ans += 1;\n        }\n    }\n    ans\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9104262392596499",
      "bn": "0.8781885284176876",
      "bg": "0.8316696904400789",
      "zh": "0.8959071529275238",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9536426485221726",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(distinct_weights_count(&[1, 4, 6]), 10);\n        assert_eq!(distinct_weights_count(&[2, 3]), 4);\n        assert_eq!(distinct_weights_count(&[]), 0);\n        assert_eq!(distinct_weights_count(&[1, 2, 2]), 5);  \n        \n    }\n    \n\n}",
    "entry_point": "distinct_weights_count",
    "signature": "fn distinct_weights_count(weights: &[i32]) -> i32",
    "docstring": {
      "en": "Calculates the number of distinct weights that can be measured using a given set of weights on a balance scale.\n  The weights can be placed on either side of the scale, and the same weight can't be used more than once.\n\n  Arguments:\n  - weights: A slice of integers representing the weights.\n\n  Returns:\n  - The total number of distinct weights that can be measured.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (weights: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (only zero can be measured)",
      "sq": "Llogarit numrin e peshave të dallueshme që mund të maten duke përdorur një grup të caktuar peshash në një peshore. Peshat mund të vendosen në secilën anë të peshores, dhe e njëjta peshë nuk mund të përdoret më shumë se një herë.\n\nArgumentet:\n- weights: Një segment i numrave të plotë që përfaqësojnë peshat.\n\nKthen:\n- Numri total i peshave të dallueshme që mund të maten.\n\nShembull:\n- distinct_weights_count(&[1, 4, 6]) kthen 10\n- distinct_weights_count(&[2, 3]) kthen 5 (pesha: 1, 2, 3, 5)\n- distinct_weights_count(&[]) kthen 1 (vetëm zero mund të matet)",
      "hy": "Հաշվում է տարբեր քաշերի քանակը, որոնք կարելի է չափել տրված քաշերի հավաքածուով հավասարակշռության կշեռքի վրա:\n  Քաշերը կարող են տեղադրվել կշեռքի երկու կողմերում, և նույն քաշը չի կարող օգտագործվել ավելի քան մեկ անգամ:\n\n  Արձանագրություններ:\n  - weights: Integer-ների շերտ, որը ներկայացնում է քաշերը:\n\n  Վերադարձնում է:\n  - Տարբեր քաշերի ընդհանուր քանակը, որոնք կարելի է չափել:\n\n  Օրինակ:\n  - distinct_weights_count(&[1, 4, 6]) վերադարձնում է 10\n  - distinct_weights_count(&[2, 3]) վերադարձնում է 5 (քաշեր: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) վերադարձնում է 1 (կարելի է չափել միայն զրոն)",
      "bn": "ব্যালেন্স স্কেলে প্রদত্ত ওজন সেট ব্যবহার করে কতগুলি স্বতন্ত্র ওজন পরিমাপ করা যেতে পারে তা গণনা করে। \n  ওজনগুলি স্কেলের যেকোনো পাশে রাখা যেতে পারে, এবং একই ওজন একাধিকবার ব্যবহার করা যাবে না।\n\n  আর্গুমেন্টস:\n  - weights: পূর্ণসংখ্যার একটি স্লাইস যা ওজনগুলি উপস্থাপন করে।\n\n  রিটার্নস:\n  - মোট কতগুলি স্বতন্ত্র ওজন পরিমাপ করা যেতে পারে।\n\n  উদাহরণ:\n  - distinct_weights_count(&[1, 4, 6]) 10 রিটার্ন করে\n  - distinct_weights_count(&[2, 3]) 5 রিটার্ন করে (ওজন: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 রিটার্ন করে (শুধুমাত্র শূন্য পরিমাপ করা যেতে পারে)",
      "bg": "Изчислява броя на различните тежести, които могат да бъдат измерени с даден набор от тежести на везна. \nТежестите могат да бъдат поставени от двете страни на везната и една и съща тежест не може да се използва повече от веднъж.\n\nАргументи:\n- weights: Срез от цели числа, представляващи тежестите.\n\nВръща:\n- Общият брой на различните тежести, които могат да бъдат измерени.\n\nПример:\n- distinct_weights_count(&[1, 4, 6]) връща 10\n- distinct_weights_count(&[2, 3]) връща 5 (тежести: 1, 2, 3, 5)\n- distinct_weights_count(&[]) връща 1 (може да се измери само нула)",
      "zh": "计算使用给定的一组砝码在天平上可以测量的不同重量的数量。  \n砝码可以放在天平的任一侧，并且同一个砝码不能被多次使用。\n\n参数:\n- weights: 一个整数切片，表示砝码。\n\n返回:\n- 可以测量的不同重量的总数。\n\n示例:\n- distinct_weights_count(&[1, 4, 6]) 返回 10\n- distinct_weights_count(&[2, 3]) 返回 5 (weights: 1, 2, 3, 5)\n- distinct_weights_count(&[]) 返回 1 (只有零可以被测量)",
      "fr": "Calcule le nombre de poids distincts qui peuvent être mesurés en utilisant un ensemble donné de poids sur une balance.  \nLes poids peuvent être placés de chaque côté de la balance, et le même poids ne peut pas être utilisé plus d'une fois.\n\nArguments:\n- weights: Une tranche d'entiers représentant les poids.\n\nReturns:\n- Le nombre total de poids distincts qui peuvent être mesurés.\n\nExample:\n- distinct_weights_count(&[1, 4, 6]) retourne 10\n- distinct_weights_count(&[2, 3]) retourne 5 (poids : 1, 2, 3, 5)\n- distinct_weights_count(&[]) retourne 1 (seul zéro peut être mesuré)",
      "de": "Berechnet die Anzahl der unterschiedlichen Gewichte, die mit einem gegebenen Satz von Gewichten auf einer Waage gemessen werden können. Die Gewichte können auf beiden Seiten der Waage platziert werden, und dasselbe Gewicht kann nicht mehr als einmal verwendet werden.\n\nArgumente:\n- weights: Ein Slice von ganzen Zahlen, das die Gewichte darstellt.\n\nRückgabewerte:\n- Die Gesamtanzahl der unterschiedlichen Gewichte, die gemessen werden können.\n\nBeispiel:\n- distinct_weights_count(&[1, 4, 6]) gibt 10 zurück\n- distinct_weights_count(&[2, 3]) gibt 5 zurück (Gewichte: 1, 2, 3, 5)\n- distinct_weights_count(&[]) gibt 1 zurück (nur Null kann gemessen werden)",
      "ha": "Lissafa yawan nau'ikan nauyi daban-daban da za a iya aunawa ta amfani da saitin nauyi da aka bayar akan ma'aunin ma'auni.\n  Ana iya sanya nauyin a ko wanne ɓangaren ma'aunin, kuma ba za a iya amfani da nauyi ɗaya fiye da sau ɗaya ba.\n\n  Arguments:\n  - weights: Wani yanki na lambobi masu nuna nauyin.\n\n  Returns:\n  - Jimlar adadin nau'ikan nauyi daban-daban da za a iya auna.\n\n  Example:\n  - distinct_weights_count(&[1, 4, 6]) returns 10\n  - distinct_weights_count(&[2, 3]) returns 5 (nauyi: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) returns 1 (ana iya auna sifili kawai)",
      "hi": "विभिन्न भारों की संख्या की गणना करता है जो एक बैलेंस स्केल का उपयोग करके मापे जा सकते हैं। दिए गए भारों का सेट बैलेंस स्केल पर रखा जाता है।\n  भारों को स्केल के किसी भी तरफ रखा जा सकता है, और एक ही भार का उपयोग एक से अधिक बार नहीं किया जा सकता।\n\n  तर्क:\n  - weights: पूर्णांकों का एक स्लाइस जो भारों का प्रतिनिधित्व करता है।\n\n  वापसी:\n  - मापे जा सकने वाले विभिन्न भारों की कुल संख्या।\n\n  उदाहरण:\n  - distinct_weights_count(&[1, 4, 6]) 10 लौटाता है\n  - distinct_weights_count(&[2, 3]) 5 लौटाता है (भार: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) 1 लौटाता है (केवल शून्य मापा जा सकता है)",
      "hu": "Számítja ki a különböző mérhető súlyok számát egy adott súlykészlet segítségével egy mérlegen.\n  A súlyok a mérleg bármelyik oldalára helyezhetők, és ugyanazt a súlyt nem lehet többször használni.\n\n  Argumentumok:\n  - weights: Egész számokat tartalmazó szelet, amely a súlyokat képviseli.\n\n  Visszatérési érték:\n  - A különböző mérhető súlyok teljes száma.\n\n  Példa:\n  - distinct_weights_count(&[1, 4, 6]) visszaadja 10\n  - distinct_weights_count(&[2, 3]) visszaadja 5 (súlyok: 1, 2, 3, 5)\n  - distinct_weights_count(&[]) visszaadja 1 (csak a nulla mérhető)"
    },
    "docstring_bertscore": {
      "sq": "0.9896306995884547",
      "hy": "0.9756387782875952",
      "bn": "0.9672754460941211",
      "bg": "0.9734937688027994",
      "zh": "0.9650060939907975",
      "fr": "0.9880748278138084",
      "de": "0.9773142255516244",
      "ha": "0.9811132302192976",
      "hi": "0.9800916741696353",
      "hu": "0.9485608888537761"
    }
  },
  {
    "task_id": "Rust/17",
    "prompt": {
      "en": "/*\n  Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "sq": "/*\n  Gjen ëndrrën me vlerën më të lartë që është brenda aftësisë së përdoruesit.\n\n  Kjo funksion merr një varg me vlera ëndrrash dhe pikët e aftësisë së përdoruesit. Ajo kthen vlerën më të lartë të ëndrrës që nuk tejkalon aftësinë e përdoruesit.\n\n  Argumentet:\n  - dreams: Një varg me numra të plotë 32-bitësh pa shenjë, secila që përfaqëson aftësinë e kërkuar për një ëndërr.\n  - ability: Një numër i plotë 32-bitësh pa shenjë që përfaqëson pikët e aftësisë së përdoruesit.\n\n  Kthen:\n  - Vlera e ëndrrës që është më e larta por ende brenda aftësisë së përdoruesit.\n\n  Shembuj:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) kthen 98\n  - max_dream_within_ability(&[20, 40, 60], 50) kthen 40\n  - max_dream_within_ability(&[10, 20, 30], 5) kthen 0 (Asnjë ëndërr brenda aftësisë)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "hy": "/*\n  Գտնում է ամենաբարձր արժեք ունեցող երազանքը, որը գտնվում է օգտագործողի կարողությունների սահմաններում:\n\n  Այս ֆունկցիան ընդունում է երազանքների արժեքների զանգված և օգտագործողի կարողության միավոր: Այն վերադարձնում է ամենաբարձր երազանքի արժեքը, որը չի գերազանցում օգտագործողի կարողությունը:\n\n  Արգումենտներ:\n  - dreams: Անստորագիր 32-բիթանոց ամբողջ թվերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է երազանքի համար պահանջվող կարողությունը:\n  - ability: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է օգտագործողի կարողության միավորը:\n\n  Վերադարձնում է:\n  - Երազանքի արժեքը, որը ամենաբարձրն է, բայց դեռ գտնվում է օգտագործողի կարողության սահմաններում:\n\n  Օրինակներ:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) վերադարձնում է 98\n  - max_dream_within_ability(&[20, 40, 60], 50) վերադարձնում է 40\n  - max_dream_within_ability(&[10, 20, 30], 5) վերադարձնում է 0 (Ոչ մի երազանք չի գտնվում կարողության սահմաններում)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32",
      "bn": "/*\n  এমন একটি স্বপ্ন খুঁজে বের করে যার মান ব্যবহারকারীর ক্ষমতার মধ্যে সর্বোচ্চ।\n\n  এই ফাংশনটি স্বপ্নের মানগুলির একটি অ্যারে এবং ব্যবহারকারীর ক্ষমতা স্কোর গ্রহণ করে। এটি এমন সর্বোচ্চ স্বপ্নের মান ফেরত দেয় যা ব্যবহারকারীর ক্ষমতা অতিক্রম করে না।\n\n  আর্গুমেন্টসমূহ:\n  - dreams: স্বপ্নের জন্য প্রয়োজনীয় ক্ষমতা উপস্থাপনকারী প্রতিটি ৩২-বিট পূর্ণসংখ্যার একটি অ্যারে।\n  - ability: ব্যবহারকারীর ক্ষমতা স্কোর উপস্থাপনকারী একটি ৩২-বিট পূর্ণসংখ্যা।\n\n  ফেরত দেয়:\n  - এমন স্বপ্নের মান যা সর্বোচ্চ কিন্তু এখনও ব্যবহারকারীর ক্ষমতার মধ্যে।\n\n  উদাহরণসমূহ:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 ফেরত দেয়\n  - max_dream_within_ability(&[20, 40, 60], 50) 40 ফেরত দেয়\n  - max_dream_within_ability(&[10, 20, 30], 5) 0 ফেরত দেয় (ক্ষমতার মধ্যে কোনো স্বপ্ন নেই)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "bg": "/*\n  Намира мечтата с най-висока стойност, която е в рамките на възможностите на потребителя.\n\n  Тази функция приема масив от стойности на мечти и оценка на възможностите на потребителя. Тя връща най-високата стойност на мечта, която не надвишава възможностите на потребителя.\n\n  Аргументи:\n  - dreams: Масив от беззнакови 32-битови цели числа, всяко от които представлява необходимите възможности за мечта.\n  - ability: Беззнаково 32-битово цяло число, представляващо оценката на възможностите на потребителя.\n\n  Връща:\n  - Стойността на мечтата, която е най-висока, но все пак в рамките на възможностите на потребителя.\n\n  Примери:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) връща 98\n  - max_dream_within_ability(&[20, 40, 60], 50) връща 40\n  - max_dream_within_ability(&[10, 20, 30], 5) връща 0 (Няма мечта в рамките на възможностите)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "zh": "/*\n  找到在用户能力范围内的最高价值梦想。\n\n  此函数接受一个梦想值数组和用户的能力分数。它返回不超过用户能力的最高梦想值。\n\n  参数:\n  - dreams: 一个无符号32位整数数组，每个整数代表一个梦想所需的能力。\n  - ability: 一个无符号32位整数，代表用户的能力分数。\n\n  返回:\n  - 在用户能力范围内的最高梦想值。\n\n  示例:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 返回 98\n  - max_dream_within_ability(&[20, 40, 60], 50) 返回 40\n  - max_dream_within_ability(&[10, 20, 30], 5) 返回 0 (没有在能力范围内的梦想)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "fr": "/*\n  Trouve le rêve de la plus haute valeur qui est à la portée de l'utilisateur.\n\n  Cette fonction prend un tableau de valeurs de rêves et le score de capacité de l'utilisateur. Elle renvoie la valeur du rêve la plus élevée qui ne dépasse pas la capacité de l'utilisateur.\n\n  Arguments :\n  - dreams : Un tableau d'entiers non signés de 32 bits, chacun représentant la capacité requise pour un rêve.\n  - ability : Un entier non signé de 32 bits représentant le score de capacité de l'utilisateur.\n\n  Renvoie :\n  - La valeur du rêve qui est la plus élevée mais toujours à la portée de l'utilisateur.\n\n  Exemples :\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) renvoie 98\n  - max_dream_within_ability(&[20, 40, 60], 50) renvoie 40\n  - max_dream_within_ability(&[10, 20, 30], 5) renvoie 0 (Aucun rêve à la portée)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "de": "/*\n  Findet den höchstbewerteten Traum, der innerhalb der Fähigkeiten des Benutzers liegt.\n\n  Diese Funktion nimmt ein Array von Traumwerten und die Fähigkeitsbewertung des Benutzers. Sie gibt den höchsten Traumwert zurück, der die Fähigkeiten des Benutzers nicht überschreitet.\n\n  Argumente:\n  - dreams: Ein Array von 32-Bit-Unsigned-Integern, die jeweils die erforderliche Fähigkeit für einen Traum darstellen.\n  - ability: Ein 32-Bit-Unsigned-Integer, das die Fähigkeitsbewertung des Benutzers darstellt.\n\n  Rückgabewert:\n  - Der Wert des Traums, der der höchste ist, aber immer noch innerhalb der Fähigkeiten des Benutzers liegt.\n\n  Beispiele:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) gibt 98 zurück\n  - max_dream_within_ability(&[20, 40, 60], 50) gibt 40 zurück\n  - max_dream_within_ability(&[10, 20, 30], 5) gibt 0 zurück (Kein Traum innerhalb der Fähigkeiten)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "ha": "/*\n  Nemi mafarkin da ya fi kima wanda yake cikin ikon mai amfani.\n\n  Wannan aikin yana daukar jerin kimar mafarki da kuma maki ikon mai amfani. Yana dawo da mafi girman kimar mafarki wanda bai wuce ikon mai amfani ba.\n\n  Hujojji:\n  - dreams: Jerin lambobin 32-bit marasa alama, kowanne yana wakiltar ikon da ake bukata don mafarki.\n  - ability: Lamba 32-bit maras alama wanda yake wakiltar maki ikon mai amfani.\n\n  Komawa:\n  - Kimar mafarkin da ya fi kima amma har yanzu yana cikin ikon mai amfani.\n\n  Misalai:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) yana dawowa 98\n  - max_dream_within_ability(&[20, 40, 60], 50) yana dawowa 40\n  - max_dream_within_ability(&[10, 20, 30], 5) yana dawowa 0 (Babu mafarki cikin ikon)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32",
      "hi": "/*\n  उपयोगकर्ता की क्षमता के भीतर सबसे उच्च-मूल्य वाले सपने को खोजता है।\n\n  यह फ़ंक्शन सपनों के मूल्यों की एक array और उपयोगकर्ता की क्षमता स्कोर लेता है। यह सबसे उच्च सपना मूल्य लौटाता है जो उपयोगकर्ता की क्षमता से अधिक नहीं होता।\n\n  तर्क:\n  - dreams: unsigned 32-bit पूर्णांकों की एक array, प्रत्येक एक सपने के लिए आवश्यक क्षमता का प्रतिनिधित्व करता है।\n  - ability: unsigned 32-bit पूर्णांक जो उपयोगकर्ता की क्षमता स्कोर का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - उस सपने का मूल्य जो सबसे उच्च है लेकिन फिर भी उपयोगकर्ता की क्षमता के भीतर है।\n\n  उदाहरण:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 लौटाता है\n  - max_dream_within_ability(&[20, 40, 60], 50) 40 लौटाता है\n  - max_dream_within_ability(&[10, 20, 30], 5) 0 लौटाता है (क्षमता के भीतर कोई सपना नहीं)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 ",
      "hu": "/*\n  Megtalálja a legmagasabb értékű álmot, amely a felhasználó képességein belül van.\n\n  Ez a függvény egy álomértékeket tartalmazó tömböt és a felhasználó képességpontszámát veszi át. Visszaadja a legmagasabb álomértéket, amely nem haladja meg a felhasználó képességeit.\n\n  Argumentumok:\n  - dreams: Egy 32 bites előjel nélküli egész számokat tartalmazó tömb, amelyek mindegyike egy álomhoz szükséges képességet képvisel.\n  - ability: Egy 32 bites előjel nélküli egész szám, amely a felhasználó képességpontszámát képviseli.\n\n  Visszatér:\n  - Az álom értéke, amely a legmagasabb, de még mindig a felhasználó képességein belül van.\n\n  Példák:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) visszaadja 98\n  - max_dream_within_ability(&[20, 40, 60], 50) visszaadja 40\n  - max_dream_within_ability(&[10, 20, 30], 5) visszaadja 0 (Nincs álom a képességen belül)\n*/\n\n\nfn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32 "
    },
    "prompt_bertscore": {
      "sq": "0.9802813661835236",
      "hy": "0.9820360669695858",
      "bn": "0.9629798654738606",
      "bg": "0.9503185690955538",
      "zh": "0.955005252936072",
      "fr": "0.9675771656429132",
      "de": "0.9825171497524523",
      "ha": "0.9673920421277886",
      "hi": "0.9872540870793722",
      "hu": "0.983199047850545"
    },
    "canonical_solution": "{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}",
    "instruction": {
      "en": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nরাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\n请用中文为以下 Rust 代码提供一个简洁的自然语言描述（文档字符串），不超过 500 个字符。",
      "fr": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Rust a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32\n{\n    let mut max_dream = 0;\n    for &dream in dreams {\n        if dream <= ability && dream > max_dream {\n            max_dream = dream;\n        }\n    }\n    max_dream\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9217118216189092",
      "bn": "0.893130101570275",
      "bg": "0.8316696904400789",
      "zh": "0.8563483235013775",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_dream_within_ability(&[50, 69, 240, 135, 98], 100), 98);\n        assert_eq!(max_dream_within_ability(&[20, 40, 60], 50), 40);\n        assert_eq!(max_dream_within_ability(&[10, 20, 30], 5), 0); // No dream within ability\n        assert_eq!(max_dream_within_ability(&[120, 200, 300, 400], 350), 300);\n    \n    }\n    \n\n}",
    "entry_point": "max_dream_within_ability",
    "signature": "fn max_dream_within_ability(dreams: &[u32], ability: u32) -> u32",
    "docstring": {
      "en": "Finds the highest-valued dream that is within the user's ability.\n\n  This function takes an array of dream values and the user's ability score. It returns the highest dream value that does not exceed the user's ability.\n\n  Arguments:\n  - dreams: An array of unsigned 32-bit integers, each representing the ability required for a dream.\n  - ability: An unsigned 32-bit integer representing the user's ability score.\n\n  Returns:\n  - The value of the dream that is the highest but still within the user's ability.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (No dream within ability)",
      "sq": "Gjen ëndrrën me vlerën më të lartë që është brenda aftësisë së përdoruesit.\n\nKjo funksion merr një varg me vlera ëndrrash dhe pikët e aftësisë së përdoruesit. Ajo kthen vlerën më të lartë të ëndrrës që nuk e tejkalon aftësinë e përdoruesit.\n\nArgumentet:\n- dreams: Një varg i numrave të plotë 32-bit pa shenjë, secili që përfaqëson aftësinë e kërkuar për një ëndërr.\n- ability: Një numër i plotë 32-bit pa shenjë që përfaqëson pikët e aftësisë së përdoruesit.\n\nKthen:\n- Vlera e ëndrrës që është më e larta por ende brenda aftësisë së përdoruesit.\n\nShembuj:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) kthen 98\n- max_dream_within_ability(&[20, 40, 60], 50) kthen 40\n- max_dream_within_ability(&[10, 20, 30], 5) kthen 0 (Asnjë ëndërr brenda aftësisë)",
      "hy": "Գտնում է ամենաբարձր արժեք ունեցող երազանքը, որը գտնվում է օգտագործողի կարողությունների սահմաններում:\n\nԱյս ֆունկցիան ընդունում է երազանքների արժեքների զանգված և օգտագործողի կարողության միավոր: Այն վերադարձնում է ամենաբարձր երազանքի արժեքը, որը չի գերազանցում օգտագործողի կարողությունը:\n\nԱրգումենտներ:\n- dreams: Անստորագիր 32-բիթանոց ամբողջ թվերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է երազանքի համար պահանջվող կարողությունը:\n- ability: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է օգտագործողի կարողության միավորը:\n\nՎերադարձնում է:\n- Երազանքի արժեքը, որը ամենաբարձրն է, բայց դեռ գտնվում է օգտագործողի կարողության սահմաններում:\n\nՕրինակներ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) վերադարձնում է 98\n- max_dream_within_ability(&[20, 40, 60], 50) վերադարձնում է 40\n- max_dream_within_ability(&[10, 20, 30], 5) վերադարձնում է 0 (Ոչ մի երազանք կարողության սահմաններում)",
      "bn": "ব্যবহারকারীর ক্ষমতার মধ্যে সর্বোচ্চ মূল্যের স্বপ্ন খুঁজে বের করে।\n\nএই ফাংশনটি স্বপ্নের মানগুলির একটি অ্যারে এবং ব্যবহারকারীর ক্ষমতা স্কোর নেয়। এটি সর্বোচ্চ স্বপ্নের মান ফেরত দেয় যা ব্যবহারকারীর ক্ষমতা অতিক্রম করে না।\n\nআর্গুমেন্টস:\n- dreams: একটি আনসাইনড ৩২-বিট পূর্ণসংখ্যার অ্যারে, প্রতিটি একটি স্বপ্নের জন্য প্রয়োজনীয় ক্ষমতা উপস্থাপন করে।\n- ability: একটি আনসাইনড ৩২-বিট পূর্ণসংখ্যা যা ব্যবহারকারীর ক্ষমতা স্কোর উপস্থাপন করে।\n\nরিটার্নস:\n- সেই স্বপ্নের মান যা সর্বোচ্চ কিন্তু এখনও ব্যবহারকারীর ক্ষমতার মধ্যে।\n\nউদাহরণসমূহ:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 ফেরত দেয়\n- max_dream_within_ability(&[20, 40, 60], 50) 40 ফেরত দেয়\n- max_dream_within_ability(&[10, 20, 30], 5) 0 ফেরত দেয় (ক্ষমতার মধ্যে কোনো স্বপ্ন নেই)",
      "bg": "Намира мечтата с най-висока стойност, която е в рамките на възможностите на потребителя.\n\n  Тази функция приема масив от стойности на мечти и оценка на способностите на потребителя. Връща стойността на мечтата с най-висока стойност, която не надвишава способностите на потребителя.\n\n  Аргументи:\n  - dreams: Масив от беззнакови 32-битови цели числа, всяко от които представлява необходимата способност за мечта.\n  - ability: Беззнаково 32-битово цяло число, представляващо оценката на способностите на потребителя.\n\n  Връща:\n  - Стойността на мечтата, която е най-високата, но все още в рамките на възможностите на потребителя.\n\n  Примери:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) връща 98\n  - max_dream_within_ability(&[20, 40, 60], 50) връща 40\n  - max_dream_within_ability(&[10, 20, 30], 5) връща 0 (Няма мечта в рамките на възможностите)",
      "zh": "找到在用户能力范围内的最高价值梦想。\n\n此函数接受一个梦想值数组和用户的能力分数。它返回不超过用户能力的最高梦想值。\n\n参数：\n- dreams: 一个无符号32位整数数组，每个整数代表一个梦想所需的能力。\n- ability: 一个无符号32位整数，代表用户的能力分数。\n\n返回：\n- 在用户能力范围内的最高梦想值。\n\n示例：\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 返回 98\n- max_dream_within_ability(&[20, 40, 60], 50) 返回 40\n- max_dream_within_ability(&[10, 20, 30], 5) 返回 0 （没有在能力范围内的梦想）",
      "fr": "Trouve le rêve de plus grande valeur qui est à la portée de l'utilisateur.\n\n  Cette fonction prend un tableau de valeurs de rêves et le score de capacité de l'utilisateur. Elle renvoie la valeur du rêve la plus élevée qui ne dépasse pas la capacité de l'utilisateur.\n\n  Arguments:\n  - dreams: Un tableau d'entiers non signés de 32 bits, chacun représentant la capacité requise pour un rêve.\n  - ability: Un entier non signé de 32 bits représentant le score de capacité de l'utilisateur.\n\n  Renvoie:\n  - La valeur du rêve qui est la plus élevée mais toujours à la portée de la capacité de l'utilisateur.\n\n  Exemples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) renvoie 98\n  - max_dream_within_ability(&[20, 40, 60], 50) renvoie 40\n  - max_dream_within_ability(&[10, 20, 30], 5) renvoie 0 (Aucun rêve à la portée de la capacité)",
      "de": "Findet den höchstbewerteten Traum, der innerhalb der Fähigkeit des Benutzers liegt.\n\n  Diese Funktion nimmt ein Array von Traumwerten und die Fähigkeitsbewertung des Benutzers. Sie gibt den höchsten Traumwert zurück, der die Fähigkeit des Benutzers nicht überschreitet.\n\n  Argumente:\n  - dreams: Ein Array von 32-Bit-Unsigned-Integern, wobei jeder Wert die erforderliche Fähigkeit für einen Traum darstellt.\n  - ability: Ein 32-Bit-Unsigned-Integer, das die Fähigkeitsbewertung des Benutzers darstellt.\n\n  Rückgabewerte:\n  - Der Wert des Traums, der der höchste ist, aber dennoch innerhalb der Fähigkeit des Benutzers liegt.\n\n  Beispiele:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) gibt 98 zurück\n  - max_dream_within_ability(&[20, 40, 60], 50) gibt 40 zurück\n  - max_dream_within_ability(&[10, 20, 30], 5) gibt 0 zurück (Kein Traum innerhalb der Fähigkeit)",
      "ha": "Nemi mafarki mafi girma wanda yake cikin ikon mai amfani.\n\n  Wannan aikin yana ɗaukar jerin ƙimomin mafarki da ƙimar ƙarfin mai amfani. Yana mayar da mafi girman ƙimar mafarki wanda ba ya wuce ƙarfin mai amfani.\n\n  Arguments:\n  - dreams: Jerin lambobin ɓangarorin 32-bit marasa alama, kowanne yana wakiltar ƙarfin da ake buƙata don mafarki.\n  - ability: Lambar ɓangare 32-bit marasa alama wanda ke wakiltar ƙimar ƙarfin mai amfani.\n\n  Returns:\n  - Ƙimar mafarkin da ita ce mafi girma amma har yanzu tana cikin ƙarfin mai amfani.\n\n  Examples:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) returns 98\n  - max_dream_within_ability(&[20, 40, 60], 50) returns 40\n  - max_dream_within_ability(&[10, 20, 30], 5) returns 0 (Babu mafarki cikin ƙarfin)",
      "hi": "उपयोगकर्ता की क्षमता के भीतर सबसे उच्च मूल्य वाला सपना खोजता है।\n\nयह फ़ंक्शन सपनों के मूल्यों की एक array और उपयोगकर्ता की क्षमता स्कोर लेता है। यह सबसे उच्च सपना मूल्य लौटाता है जो उपयोगकर्ता की क्षमता से अधिक नहीं होता।\n\nआर्गुमेंट्स:\n- dreams: unsigned 32-बिट पूर्णांकों की एक array, प्रत्येक सपना के लिए आवश्यक क्षमता को दर्शाती है।\n- ability: unsigned 32-बिट पूर्णांक जो उपयोगकर्ता की क्षमता स्कोर को दर्शाता है।\n\nरिटर्न्स:\n- उस सपने का मूल्य जो सबसे उच्च है लेकिन फिर भी उपयोगकर्ता की क्षमता के भीतर है।\n\nउदाहरण:\n- max_dream_within_ability(&[50, 69, 240, 135, 98], 100) 98 लौटाता है\n- max_dream_within_ability(&[20, 40, 60], 50) 40 लौटाता है\n- max_dream_within_ability(&[10, 20, 30], 5) 0 लौटाता है (क्षमता के भीतर कोई सपना नहीं)",
      "hu": "Megtalálja a legmagasabb értékű álmot, amely a felhasználó képességein belül van.\n\n  Ez a függvény egy álomértékek tömbjét és a felhasználó képességpontszámát veszi át. Visszaadja a legmagasabb álomértéket, amely nem haladja meg a felhasználó képességeit.\n\n  Argumentumok:\n  - dreams: Egy 32 bites előjel nélküli egész számokat tartalmazó tömb, ahol minden elem egy álomhoz szükséges képességet jelöl.\n  - ability: Egy 32 bites előjel nélküli egész szám, amely a felhasználó képességpontszámát jelöli.\n\n  Visszatérési érték:\n  - Az álom értéke, amely a legmagasabb, de még a felhasználó képességein belül van.\n\n  Példák:\n  - max_dream_within_ability(&[50, 69, 240, 135, 98], 100) visszaadja 98\n  - max_dream_within_ability(&[20, 40, 60], 50) visszaadja 40\n  - max_dream_within_ability(&[10, 20, 30], 5) visszaadja 0 (Nincs álom a képességen belül)"
    },
    "docstring_bertscore": {
      "sq": "0.9726001307185234",
      "hy": "0.9860438321677267",
      "bn": "0.9667820482276305",
      "bg": "0.9733161932421541",
      "zh": "0.9458100567068238",
      "fr": "0.962720056935467",
      "de": "0.9839830419644897",
      "ha": "0.9729687887057241",
      "hi": "0.9806782296848312",
      "hu": "0.9877784712853044"
    }
  },
  {
    "task_id": "Rust/18",
    "prompt": {
      "en": "/*\n  Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "sq": "/*\n  Llogarit vlerën e polinomit f(x) = ax^3 + bx^2 + cx + d për një grup të dhënë koeficientësh dhe vlerën e x.\n  Kjo funksion përdor numra realë si për koeficientët ashtu edhe për vlerën e x, duke ofruar vlerën e polinomit si një numër me presje të lëvizshme me precizion të dyfishtë.\n\n  Argumentet:\n  - x: Vlera në të cilën vlerësohet polinomi.\n  - a: Koeficienti i x^3.\n  - b: Koeficienti i x^2.\n  - c: Koeficienti i x.\n  - d: Termi konstant në polinom.\n\n  Kthen:\n  - Vlera e llogaritur e polinomit në x, si një numër me presje të lëvizshme me precizion të dyfishtë.\n\n  Shembull:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) kthen 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "hy": "/*\n  Հաշվում է բազմապատկի արժեքը f(x) = ax^3 + bx^2 + cx + d տրված գործակիցների և x-ի արժեքի համար:\n  Այս ֆունկցիան օգտագործում է իրական թվեր ինչպես գործակիցների, այնպես էլ x-ի արժեքի համար, տրամադրելով բազմապատկի արժեքը որպես կրկնակի ճշգրտության լողացող կետային թիվ:\n\n  Արգումենտներ:\n  - x: Արժեքը, որի համար հաշվվում է բազմապատկը:\n  - a: x^3-ի գործակիցը:\n  - b: x^2-ի գործակիցը:\n  - c: x-ի գործակիցը:\n  - d: Բազմապատկի հաստատուն անդամը:\n\n  Վերադարձնում է:\n  - Բազմապատկի հաշվարկված արժեքը x-ում, որպես կրկնակի ճշգրտության լողացող կետային թիվ:\n\n  Օրինակ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) վերադարձնում է 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "bn": "/*\n  প্রদত্ত সেটের সহগ এবং x এর মানের জন্য পলিনোমিয়াল f(x) = ax^3 + bx^2 + cx + d এর মান গণনা করে।\n  এই ফাংশনটি সহগ এবং x এর মান উভয়ের জন্য বাস্তব সংখ্যা ব্যবহার করে, পলিনোমিয়ালের মানকে ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যা হিসাবে প্রদান করে।\n\n  আর্গুমেন্ট:\n  - x: যে মানে পলিনোমিয়ালটি মূল্যায়ন করা হয়।\n  - a: x^3 এর সহগ।\n  - b: x^2 এর সহগ।\n  - c: x এর সহগ।\n  - d: পলিনোমিয়ালের ধ্রুবক পদ।\n\n  রিটার্নস:\n  - x এ পলিনোমিয়ালের গণিত মান, একটি ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যা হিসাবে।\n\n  উদাহরণ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 রিটার্ন করে\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "bg": "/*\n  Изчислява стойността на полинома f(x) = ax^3 + bx^2 + cx + d за даден набор от коефициенти и стойността на x.\n  Тази функция използва реални числа както за коефициентите, така и за стойността на x, предоставяйки стойността на полинома като число с двойна точност.\n\n  Аргументи:\n  - x: Стойността, при която се оценява полиномът.\n  - a: Коефициентът на x^3.\n  - b: Коефициентът на x^2.\n  - c: Коефициентът на x.\n  - d: Константният член в полинома.\n\n  Връща:\n  - Изчислената стойност на полинома при x, като число с двойна точност.\n\n  Пример:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) връща 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "zh": "/*\n  计算多项式 f(x) = ax^3 + bx^2 + cx + d 的值，给定一组系数和 x 的值。\n  此函数对系数和 x 的值使用实数，提供多项式值作为双精度浮点数。\n\n  参数：\n  - x: 多项式被求值的点。\n  - a: x^3 的系数。\n  - b: x^2 的系数。\n  - c: x 的系数。\n  - d: 多项式中的常数项。\n\n  返回：\n  - 多项式在 x 处的计算值，作为双精度浮点数。\n\n  示例：\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 返回 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "fr": "/*\n  Calcule la valeur du polynôme f(x) = ax^3 + bx^2 + cx + d pour un ensemble donné de coefficients et la valeur de x.\n  Cette fonction utilise des nombres réels pour les coefficients et la valeur de x, fournissant la valeur du polynôme comme un nombre à virgule flottante en double précision.\n\n  Arguments :\n  - x : La valeur à laquelle le polynôme est évalué.\n  - a : Le coefficient de x^3.\n  - b : Le coefficient de x^2.\n  - c : Le coefficient de x.\n  - d : Le terme constant dans le polynôme.\n\n  Renvoie :\n  - La valeur calculée du polynôme en x, comme un nombre à virgule flottante en double précision.\n\n  Exemple :\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) renvoie 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "de": "/*\n  Berechnet den Wert des Polynoms f(x) = ax^3 + bx^2 + cx + d für einen gegebenen Satz von Koeffizienten und den Wert von x.\n  Diese Funktion verwendet reelle Zahlen sowohl für die Koeffizienten als auch für den Wert von x und liefert den Wert des Polynoms als Gleitkommazahl mit doppelter Genauigkeit.\n\n  Argumente:\n  - x: Der Wert, bei dem das Polynom ausgewertet wird.\n  - a: Der Koeffizient von x^3.\n  - b: Der Koeffizient von x^2.\n  - c: Der Koeffizient von x.\n  - d: Der konstante Term im Polynom.\n\n  Rückgabewert:\n  - Der berechnete Wert des Polynoms bei x, als Gleitkommazahl mit doppelter Genauigkeit.\n\n  Beispiel:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) gibt 33.0838692 zurück\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "ha": "/*\n  Lissafa darajar polinomial f(x) = ax^3 + bx^2 + cx + d don saitin abubuwan da aka bayar da kuma darajar x.\n  Wannan aikin yana amfani da lambobi na ainihi don duka abubuwan da aka bayar da kuma darajar x, yana bayar da darajar polinomial a matsayin lamba mai nuni mai tsawo sau biyu.\n\n  Huɗɗa:\n  - x: Darajar inda aka auna polinomial.\n  - a: Abun x^3.\n  - b: Abun x^2.\n  - c: Abun x.\n  - d: Kalmar da ba ta canzawa a cikin polinomial.\n\n  Dawowa:\n  - An ƙididdige darajar polinomial a x, a matsayin lamba mai nuni mai tsawo sau biyu.\n\n  Misali:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "hi": "/*\n  दिए गए गुणांक और x के मान के लिए बहुपद f(x) = ax^3 + bx^2 + cx + d का मान गणना करता है।\n  यह फ़ंक्शन गुणांकों और x के मान के लिए वास्तविक संख्याओं का उपयोग करता है, जो बहुपद के मान को डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में प्रदान करता है।\n\n  तर्क:\n  - x: वह मान जिस पर बहुपद का मूल्यांकन किया जाता है।\n  - a: x^3 का गुणांक।\n  - b: x^2 का गुणांक।\n  - c: x का गुणांक।\n  - d: बहुपद में स्थिर पद।\n\n  लौटाता है:\n  - x पर बहुपद का गणना किया गया मान, एक डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में।\n\n  उदाहरण:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 लौटाता है\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 ",
      "hu": "/*\n  Kiszámítja az f(x) = ax^3 + bx^2 + cx + d polinom értékét adott együtthatók és az x értéke alapján.\n  Ez a függvény valós számokat használ mind az együtthatókhoz, mind az x értékéhez, és a polinom értékét dupla pontosságú lebegőpontos számként adja vissza.\n\n  Argumentumok:\n  - x: Az érték, amelynél a polinomot kiértékeljük.\n  - a: Az x^3 együtthatója.\n  - b: Az x^2 együtthatója.\n  - c: Az x együtthatója.\n  - d: A polinom konstans tagja.\n\n  Visszatérési érték:\n  - A polinom számított értéke x-nél, dupla pontosságú lebegőpontos számként.\n\n  Példa:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) visszaadja 33.0838692\n*/\n\n\n\nfn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64 "
    },
    "prompt_bertscore": {
      "sq": "0.9793688582130493",
      "hy": "0.9695142091187654",
      "bn": "0.9681043306741797",
      "bg": "0.9777287671568442",
      "zh": "0.9563497819852971",
      "fr": "0.9746607222913793",
      "de": "0.9848141114787397",
      "ha": "0.9618933572895998",
      "hi": "0.9605152597059797",
      "hu": "0.9783463090114817"
    },
    "canonical_solution": "{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}",
    "instruction": {
      "en": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nՏվեք կարճ բնութագիր (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64\n{\n    a * x.powi(3) + b * x.powi(2) + c * x + d\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8923625937779561",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9361141132869868",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert!((polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) - 33.0838692).abs() < 1e-7);\n        assert!((polynomial_value(0.0, 1.0, 1.0, 1.0, 1.0) - 1.0).abs() < 1e-7);\n        assert!((polynomial_value(1.0, 1.0, 1.0, 1.0, 1.0) - 4.0).abs() < 1e-7);\n    }\n    \n\n}",
    "entry_point": "polynomial_value",
    "signature": "fn polynomial_value(x: f64, a: f64, b: f64, c: f64, d: f64) -> f64",
    "docstring": {
      "en": "Calculates the value of the polynomial f(x) = ax^3 + bx^2 + cx + d for a given set of coefficients and the value of x.\n  This function uses real numbers for both the coefficients and the value of x, providing the polynomial's value as a double-precision floating-point number.\n\n  Arguments:\n  - x: The value at which the polynomial is evaluated.\n  - a: The coefficient of x^3.\n  - b: The coefficient of x^2.\n  - c: The coefficient of x.\n  - d: The constant term in the polynomial.\n\n  Returns:\n  - The computed value of the polynomial at x, as a double-precision floating-point number.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "sq": "Llogarit vlerën e polinomit f(x) = ax^3 + bx^2 + cx + d për një grup të dhënë koeficientësh dhe vlerën e x. Kjo funksion përdor numra realë si për koeficientët ashtu edhe për vlerën e x, duke ofruar vlerën e polinomit si një numër me presje të lëvizshme me precizion të dyfishtë.\n\nArguments:\n- x: Vlera në të cilën vlerësohet polinomi.\n- a: Koeficienti i x^3.\n- b: Koeficienti i x^2.\n- c: Koeficienti i x.\n- d: Termi konstant në polinom.\n\nReturns:\n- Vlera e llogaritur e polinomit në x, si një numër me presje të lëvizshme me precizion të dyfishtë.\n\nExample:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) kthen 33.0838692",
      "hy": "Հաշվում է բազմապատկի f(x) = ax^3 + bx^2 + cx + d արժեքը տրված գործակիցների և x-ի արժեքի համար։ \n  Այս ֆունկցիան օգտագործում է իրական թվեր ինչպես գործակիցների, այնպես էլ x-ի արժեքի համար՝ ապահովելով բազմապատկի արժեքը որպես կրկնակի ճշգրտության լողացող կետային թիվ։\n\n  Արգումենտներ:\n  - x: Արժեքը, որի համար բազմապատիկը գնահատվում է։\n  - a: x^3-ի գործակիցը։\n  - b: x^2-ի գործակիցը։\n  - c: x-ի գործակիցը։\n  - d: Բազմապատկի հաստատուն անդամը։\n\n  Վերադարձնում է:\n  - Բազմապատկի հաշվարկված արժեքը x-ում, որպես կրկնակի ճշգրտության լողացող կետային թիվ։\n\n  Օրինակ:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) վերադարձնում է 33.0838692",
      "bn": "প্রদত্ত সেটের গুণাঙ্ক এবং x এর মানের জন্য বহুপদী f(x) = ax^3 + bx^2 + cx + d এর মান গণনা করে।\n  এই ফাংশনটি গুণাঙ্ক এবং x এর মান উভয়ের জন্য বাস্তব সংখ্যা ব্যবহার করে, পলিনোমিয়ালের মানকে ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যা হিসাবে প্রদান করে।\n\n  Arguments:\n  - x: যে মানে পলিনোমিয়ালটি মূল্যায়ন করা হয়।\n  - a: x^3 এর গুণাঙ্ক।\n  - b: x^2 এর গুণাঙ্ক।\n  - c: x এর গুণাঙ্ক।\n  - d: পলিনোমিয়ালের ধ্রুবক পদ।\n\n  Returns:\n  - x এ পলিনোমিয়ালের গণনা করা মান, ডাবল-প্রিসিশন ফ্লোটিং-পয়েন্ট সংখ্যা হিসাবে।\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "bg": "Изчислява стойността на полинома f(x) = ax^3 + bx^2 + cx + d за даден набор от коефициенти и стойността на x. Тази функция използва реални числа както за коефициентите, така и за стойността на x, като предоставя стойността на полинома като число с двойна точност.\n\nАргументи:\n- x: Стойността, при която се оценява полиномът.\n- a: Коефициентът на x^3.\n- b: Коефициентът на x^2.\n- c: Коефициентът на x.\n- d: Константният член в полинома.\n\nВръща:\n- Изчислената стойност на полинома при x, като число с двойна точност.\n\nПример:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) връща 33.0838692",
      "zh": "计算多项式 f(x) = ax^3 + bx^2 + cx + d 的值，给定一组系数和 x 的值。\n此函数使用实数作为系数和 x 的值，提供多项式值作为双精度浮点数。\n\n参数：\n- x: 计算多项式的值所用的 x。\n- a: x^3 的系数。\n- b: x^2 的系数。\n- c: x 的系数。\n- d: 多项式中的常数项。\n\n返回：\n- 在 x 处计算的多项式值，作为双精度浮点数。\n\n示例：\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 返回 33.0838692",
      "fr": "Calcule la valeur du polynôme f(x) = ax^3 + bx^2 + cx + d pour un ensemble donné de coefficients et la valeur de x.\n  Cette fonction utilise des nombres réels pour les coefficients ainsi que pour la valeur de x, fournissant la valeur du polynôme en tant que nombre à virgule flottante en double précision.\n\n  Arguments:\n  - x: La valeur à laquelle le polynôme est évalué.\n  - a: Le coefficient de x^3.\n  - b: Le coefficient de x^2.\n  - c: Le coefficient de x.\n  - d: Le terme constant dans le polynôme.\n\n  Retourne:\n  - La valeur calculée du polynôme en x, en tant que nombre à virgule flottante en double précision.\n\n  Exemple:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) retourne 33.0838692",
      "de": "Berechnet den Wert des Polynoms f(x) = ax^3 + bx^2 + cx + d für einen gegebenen Satz von Koeffizienten und den Wert von x. Diese Funktion verwendet reelle Zahlen sowohl für die Koeffizienten als auch für den Wert von x und liefert den Wert des Polynoms als Gleitkommazahl mit doppelter Genauigkeit.\n\nArgumente:\n- x: Der Wert, bei dem das Polynom ausgewertet wird.\n- a: Der Koeffizient von x^3.\n- b: Der Koeffizient von x^2.\n- c: Der Koeffizient von x.\n- d: Der konstante Term im Polynom.\n\nRückgabewert:\n- Der berechnete Wert des Polynoms bei x, als Gleitkommazahl mit doppelter Genauigkeit.\n\nBeispiel:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) gibt 33.0838692 zurück.",
      "ha": "Lissafi darajar polinomial f(x) = ax^3 + bx^2 + cx + d don saitin abubuwan da aka bayar da kuma darajar x. Wannan aiki yana amfani da lambobi na gaske don duka abubuwan da ke cikin lissafin da kuma darajar x, yana bayar da darajar polynomial a matsayin lamba mai tsawon ninki biyu.\n\n  Arguments:\n  - x: Darajar da ake tantance polynomial a kai.\n  - a: Abun da ke tare da x^3.\n  - b: Abun da ke tare da x^2.\n  - c: Abun da ke tare da x.\n  - d: Abun da ke tsaye a cikin polynomial.\n\n  Returns:\n  - Darajar da aka lissafa na polynomial a x, a matsayin lamba mai tsawon ninki biyu.\n\n  Example:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) returns 33.0838692",
      "hi": "Polynomial f(x) = ax^3 + bx^2 + cx + d के मान की गणना दिए गए गुणांक और x के मान के लिए करता है। यह फ़ंक्शन गुणांक और x के मान दोनों के लिए वास्तविक संख्याओं का उपयोग करता है, और बहुपद के मान को डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में प्रदान करता है।\n\nArguments:\n- x: वह मान जिस पर बहुपद का मूल्यांकन किया जाता है।\n- a: x^3 का गुणांक।\n- b: x^2 का गुणांक।\n- c: x का गुणांक।\n- d: बहुपद में स्थिरांक पद।\n\nReturns:\n- x पर बहुपद का गणना किया गया मान, डबल-प्रिसिजन फ्लोटिंग-पॉइंट संख्या के रूप में।\n\nExample:\n- polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) 33.0838692 लौटाता है।",
      "hu": "Kiszámítja az f(x) = ax^3 + bx^2 + cx + d polinom értékét adott együtthatók és az x értéke alapján.\n  Ez a függvény valós számokat használ mind az együtthatók, mind az x értékére, és a polinom értékét dupla pontosságú lebegőpontos számként adja meg.\n\n  Argumentumok:\n  - x: Az érték, amelynél a polinomot kiértékeljük.\n  - a: Az x^3 együtthatója.\n  - b: Az x^2 együtthatója.\n  - c: Az x együtthatója.\n  - d: A polinom konstans tagja.\n\n  Visszatérési érték:\n  - A polinom x-nél számított értéke, dupla pontosságú lebegőpontos számként.\n\n  Példa:\n  - polynomial_value(2.31, 1.2, 2.0, 2.0, 3.0) visszaadja 33.0838692"
    },
    "docstring_bertscore": {
      "sq": "0.991317270153822",
      "hy": "0.9552589039326536",
      "bn": "0.9760872856879719",
      "bg": "0.9900134603327089",
      "zh": "0.9598005875950162",
      "fr": "0.9769562936049995",
      "de": "0.9809296957472214",
      "ha": "0.9585247846576291",
      "hi": "0.9570310841922468",
      "hu": "0.9626489472590565"
    }
  },
  {
    "task_id": "Rust/19",
    "prompt": {
      "en": "/*\n  Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin minimal të kovave që një gjirafë ka nevojë të pijë për të shuar etjen e saj, duke pasur parasysh madhësinë e kovave.\n  \n  Një gjirafë ka nevojë të pijë 20 litra ujë për të shuar etjen e saj. Kjo funksion përcakton sa kova uji do t'i duheshin, bazuar në vëllimin e secilës kovë. Kovat janë në formë cilindrike, me lartësi dhe rreze të dhënë.\n\n  Argumentet:\n  - height: Lartësia e kovës në centimetra (numër i plotë).\n  - radius: Rrezja e bazës së kovës në centimetra (numër i plotë).\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin minimal të kovave të nevojshme që gjirafa të shuajë etjen e saj.\n\n  Shembull:\n  - min_buckets_needed(23, 11) kthen 3\n  - min_buckets_needed(30, 10) kthen 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "hy": "/*\n  Հաշվում է, թե նվազագույն քանի դույլ է անհրաժեշտ ընձուղտին խմելու համար, որպեսզի հագեցնի իր ծարավը՝ հաշվի առնելով դույլերի չափսերը։\n  \n  Ընձուղտին անհրաժեշտ է խմել 20 լիտր ջուր, որպեսզի հագեցնի իր ծարավը։ Այս ֆունկցիան որոշում է, թե քանի դույլ ջուր է անհրաժեշտ՝ հաշվի առնելով յուրաքանչյուր դույլի ծավալը։ Դույլերը գլանաձև են՝ տրված բարձրությամբ և շառավղով։\n\n  Փաստարկներ:\n  - height: Դույլի բարձրությունը սանտիմետրերով (ամբողջ թիվ)։\n  - radius: Դույլի հիմքի շառավիղը սանտիմետրերով (ամբողջ թիվ)։\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է նվազագույն դույլերի քանակը, որը անհրաժեշտ է ընձուղտին ծարավը հագեցնելու համար։\n\n  Օրինակ:\n  - min_buckets_needed(23, 11) վերադարձնում է 3\n  - min_buckets_needed(30, 10) վերադարձնում է 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32",
      "bn": "/*\n  একটি জিরাফের তৃষ্ণা মেটানোর জন্য ন্যূনতম কতগুলি বালতি প্রয়োজন তা গণনা করে, বালতির আকার দেওয়া হলে।\n  \n  একটি জিরাফের তৃষ্ণা মেটানোর জন্য 20 লিটার পানি পান করতে হয়। এই ফাংশনটি নির্ধারণ করে যে এটি কতগুলি বালতি পানি প্রয়োজন হবে, প্রতিটি বালতির আয়তনের ভিত্তিতে। বালতিগুলি নলাকার আকৃতির, প্রদত্ত উচ্চতা এবং ব্যাসার্ধ সহ।\n\n  আর্গুমেন্টসমূহ:\n  - height: বালতির উচ্চতা সেন্টিমিটারে (পূর্ণসংখ্যা)।\n  - radius: বালতির ভিত্তির ব্যাসার্ধ সেন্টিমিটারে (পূর্ণসংখ্যা)।\n\n  রিটার্ন করে:\n  - একটি পূর্ণসংখ্যা যা জিরাফের তৃষ্ণা মেটানোর জন্য প্রয়োজনীয় ন্যূনতম বালতির সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - min_buckets_needed(23, 11) রিটার্ন করে 3\n  - min_buckets_needed(30, 10) রিটার্ন করে 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "bg": "/*\n  Изчислява минималния брой кофи, които жирафът трябва да изпие, за да утоли жаждата си, като се има предвид размерът на кофите.\n  \n  Жирафът трябва да изпие 20 литра вода, за да утоли жаждата си. Тази функция определя колко кофи вода ще са му необходими, въз основа на обема на всяка кофа. Кофите са с цилиндрична форма, с дадена височина и радиус.\n\n  Аргументи:\n  - height: Височината на кофата в сантиметри (цяло число).\n  - radius: Радиусът на основата на кофата в сантиметри (цяло число).\n\n  Връща:\n  - Цяло число, представляващо минималния брой кофи, необходими на жирафа, за да утоли жаждата си.\n\n  Пример:\n  - min_buckets_needed(23, 11) връща 3\n  - min_buckets_needed(30, 10) връща 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "zh": "/*\n  计算长颈鹿需要喝多少桶水才能解渴，给定桶的大小。\n  \n  长颈鹿需要喝20升水才能解渴。此函数根据每个桶的体积确定需要多少桶水。桶是圆柱形的，给定高度和半径。\n\n  参数:\n  - height: 桶的高度，以厘米为单位（整数）。\n  - radius: 桶底的半径，以厘米为单位（整数）。\n\n  返回:\n  - 一个整数，表示长颈鹿解渴所需的最少桶数。\n\n  示例:\n  - min_buckets_needed(23, 11) 返回 3\n  - min_buckets_needed(30, 10) 返回 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre minimum de seaux dont une girafe a besoin pour étancher sa soif, étant donné la taille des seaux.\n  \n  Une girafe a besoin de boire 20 litres d'eau pour étancher sa soif. Cette fonction détermine combien de seaux d'eau elle aurait besoin, en fonction du volume de chaque seau. Les seaux sont de forme cylindrique, avec une hauteur et un rayon donnés.\n\n  Arguments :\n  - height : La hauteur du seau en centimètres (entier).\n  - radius : Le rayon de la base du seau en centimètres (entier).\n\n  Renvoie :\n  - Un entier représentant le nombre minimum de seaux nécessaires pour que la girafe étanche sa soif.\n\n  Exemple :\n  - min_buckets_needed(23, 11) renvoie 3\n  - min_buckets_needed(30, 10) renvoie 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "de": "/*\n  Berechnet die minimale Anzahl an Eimern, die eine Giraffe benötigt, um ihren Durst zu stillen, basierend auf der Größe der Eimer.\n  \n  Eine Giraffe muss 20 Liter Wasser trinken, um ihren Durst zu stillen. Diese Funktion bestimmt, wie viele Eimer Wasser sie benötigt, basierend auf dem Volumen jedes Eimers. Die Eimer sind zylindrisch geformt, mit gegebener Höhe und Radius.\n\n  Argumente:\n  - height: Die Höhe des Eimers in Zentimetern (Ganzzahl).\n  - radius: Der Radius der Basis des Eimers in Zentimetern (Ganzzahl).\n\n  Rückgabewert:\n  - Eine Ganzzahl, die die minimale Anzahl an Eimern darstellt, die benötigt werden, damit die Giraffe ihren Durst stillen kann.\n\n  Beispiel:\n  - min_buckets_needed(23, 11) gibt 3 zurück\n  - min_buckets_needed(30, 10) gibt 3 zurück\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "ha": "/*\n  Lissafin adadin ƙaramin guga da giwa ke buƙata don shan ruwa har ta koshi, la'akari da girman gugan.\n\n  Giwa na buƙatar shan lita 20 na ruwa don ta koshi. Wannan aikin yana tantancewa nawa ne adadin guga na ruwa da za ta buƙata, bisa ga girman kowanne guga. Gugunan suna da siffar silinda, tare da tsayin da aka bayar da kuma radius.\n\n  Huɗoɗi:\n  - height: Tsayin guga a cikin santimita (lamba).\n  - radius: Radius na tushen guga a cikin santimita (lamba).\n\n  Komawa:\n  - Lamba mai wakiltar ƙaramin adadin guga da ake buƙata don giwa ta koshi.\n\n  Misali:\n  - min_buckets_needed(23, 11) yana dawowa 3\n  - min_buckets_needed(30, 10) yana dawowa 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32",
      "hi": "/*\n  गणना करता है कि जिराफ को अपनी प्यास बुझाने के लिए न्यूनतम कितने बाल्टियों की आवश्यकता होगी, बाल्टियों के आकार को देखते हुए।\n\n  एक जिराफ को अपनी प्यास बुझाने के लिए 20 लीटर पानी पीने की आवश्यकता होती है। यह फ़ंक्शन निर्धारित करता है कि उसे कितनी बाल्टियों की आवश्यकता होगी, प्रत्येक बाल्टी के आयतन के आधार पर। बाल्टियाँ बेलनाकार आकार की होती हैं, जिनकी ऊँचाई और त्रिज्या दी गई होती है।\n\n  तर्क:\n  - height: बाल्टी की ऊँचाई सेंटीमीटर में (पूर्णांक)।\n  - radius: बाल्टी के आधार की त्रिज्या सेंटीमीटर में (पूर्णांक)।\n\n  लौटाता है:\n  - एक पूर्णांक जो जिराफ की प्यास बुझाने के लिए आवश्यक न्यूनतम बाल्टियों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - min_buckets_needed(23, 11) 3 लौटाता है\n  - min_buckets_needed(30, 10) 3 लौटाता है\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja a minimum vödrök számát, amire egy zsiráfnak szüksége van, hogy oltsa a szomját, figyelembe véve a vödrök méretét.\n\n  Egy zsiráfnak 20 liter vizet kell innia, hogy oltsa a szomját. Ez a függvény meghatározza, hány vödör vízre lenne szüksége, a vödrök térfogata alapján. A vödrök henger alakúak, adott magassággal és sugárral.\n\n  Argumentumok:\n  - height: A vödör magassága centiméterben (egész szám).\n  - radius: A vödör alapjának sugara centiméterben (egész szám).\n\n  Visszatér:\n  - Egy egész szám, amely a minimum vödrök számát jelenti, amire a zsiráfnak szüksége van, hogy oltsa a szomját.\n\n  Példa:\n  - min_buckets_needed(23, 11) visszaadja 3\n  - min_buckets_needed(30, 10) visszaadja 3\n*/\n\nfn min_buckets_needed(height: i32, radius: i32) -> i32"
    },
    "prompt_bertscore": {
      "sq": "0.9926715320917178",
      "hy": "0.9725961581109027",
      "bn": "0.9799931535006419",
      "bg": "0.9876424094742955",
      "zh": "0.9633928180360322",
      "fr": "0.9918106680203126",
      "de": "0.9846146865761807",
      "ha": "0.9190797704398158",
      "hi": "0.9702699977186031",
      "hu": "0.9766941015020335"
    },
    "canonical_solution": "{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}",
    "instruction": {
      "en": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Rust a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn min_buckets_needed(height: i32, radius: i32) -> i32\n{\n    const PI: f64 = 3.14159;\n    let bucket_volume = PI * (radius as f64).powi(2) * height as f64;\n    let total_volume = 20000.0; // 20 liters in cubic centimeters\n    (total_volume / bucket_volume).ceil() as i32\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9423368058640478",
      "bn": "0.8706957931842895",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(min_buckets_needed(23, 11), 3);\n        assert_eq!(min_buckets_needed(30, 10), 3);\n        assert_eq!(min_buckets_needed(50, 5), 6);\n        assert_eq!(min_buckets_needed(40, 8), 3);    \n    }\n    \n\n}",
    "entry_point": "min_buckets_needed",
    "signature": "fn min_buckets_needed(height: i32, radius: i32) -> i32",
    "docstring": {
      "en": "Calculates the minimum number of buckets a giraffe needs to drink to quench its thirst, given the size of the buckets.\n  \n  A giraffe needs to drink 20 liters of water to quench its thirst. This function determines how many buckets of water it would need, based on the volume of each bucket. The buckets are cylindrical in shape, with given height and radius.\n\n  Arguments:\n  - height: The height of the bucket in centimeters (integer).\n  - radius: The radius of the bucket's base in centimeters (integer).\n\n  Returns:\n  - An integer representing the minimum number of buckets needed for the giraffe to quench its thirst.\n\n  Example:\n  - min_buckets_needed(23, 11) returns 3\n  - min_buckets_needed(30, 10) returns 3",
      "sq": "Llogarit numrin minimal të kovave që një gjirafë ka nevojë të pijë për të shuar etjen e saj, duke pasur parasysh madhësinë e kovave.\n\nNjë gjirafë ka nevojë të pijë 20 litra ujë për të shuar etjen e saj. Kjo funksion përcakton sa kova uji do të nevojiten, bazuar në vëllimin e secilës kovë. Kovat janë në formë cilindrike, me lartësi dhe rreze të dhënë.\n\nArgumentet:\n- height: Lartësia e kovës në centimetra (numër i plotë).\n- radius: Rrezja e bazës së kovës në centimetra (numër i plotë).\n\nKthen:\n- Një numër i plotë që përfaqëson numrin minimal të kovave të nevojshme që gjirafa të shuajë etjen e saj.\n\nShembull:\n- min_buckets_needed(23, 11) kthen 3\n- min_buckets_needed(30, 10) kthen 3",
      "hy": "Հաշվում է այն նվազագույն դույլերի քանակը, որոնք անհրաժեշտ են ընձուղտին խմելու համար, որպեսզի հագեցնի իր ծարավը, հաշվի առնելով դույլերի չափը։\n\n  Ընձուղտը պետք է խմի 20 լիտր ջուր, որպեսզի հագեցնի իր ծարավը։ Այս ֆունկցիան որոշում է, թե քանի դույլ ջուր է անհրաժեշտ, հաշվի առնելով յուրաքանչյուր դույլի ծավալը։ Դույլերը գլանաձև են, տրված բարձրությամբ և շառավղով։\n\n  Արգումենտներ:\n  - height: Դույլի բարձրությունը սանտիմետրերով (ամբողջ թիվ)։\n  - radius: Դույլի հիմքի շառավիղը սանտիմետրերով (ամբողջ թիվ)։\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է նվազագույն դույլերի քանակը, որոնք անհրաժեշտ են ընձուղտի ծարավը հագեցնելու համար։\n\n  Օրինակ:\n  - min_buckets_needed(23, 11) վերադարձնում է 3\n  - min_buckets_needed(30, 10) վերադարձնում է 3",
      "bn": "জিরাফের তৃষ্ণা মেটাতে ন্যূনতম কতগুলো বালতি প্রয়োজন তা গণনা করে, বালতির আকার দেওয়া হলে।\n\nএকটি জিরাফের তৃষ্ণা মেটাতে ২০ লিটার পানি প্রয়োজন। এই ফাংশনটি নির্ধারণ করে কতগুলো বালতি পানি প্রয়োজন হবে, প্রতিটি বালতির আয়তনের ভিত্তিতে। বালতিগুলো নলাকার আকৃতির, প্রদত্ত উচ্চতা এবং ব্যাসার্ধ সহ।\n\nআর্গুমেন্টসমূহ:\n- height: বালতির উচ্চতা সেন্টিমিটারে (পূর্ণসংখ্যা)।\n- radius: বালতির ভিত্তির ব্যাসার্ধ সেন্টিমিটারে (পূর্ণসংখ্যা)।\n\nফেরত দেয়:\n- একটি পূর্ণসংখ্যা যা জিরাফের তৃষ্ণা মেটাতে প্রয়োজনীয় ন্যূনতম বালতির সংখ্যা নির্দেশ করে।\n\nউদাহরণ:\n- min_buckets_needed(23, 11) ফেরত দেয় 3\n- min_buckets_needed(30, 10) ফেরত দেয় 3",
      "bg": "Изчислява минималния брой кофи, които жирафът трябва да изпие, за да утоли жаждата си, като се има предвид размерът на кофите.\n\nЖирафът трябва да изпие 20 литра вода, за да утоли жаждата си. Тази функция определя колко кофи вода ще са му нужни, въз основа на обема на всяка кофа. Кофите са с цилиндрична форма, с дадена височина и радиус.\n\nАргументи:\n- height: Височината на кофата в сантиметри (цяло число).\n- radius: Радиусът на основата на кофата в сантиметри (цяло число).\n\nВръща:\n- Цяло число, представляващо минималния брой кофи, необходими на жирафа, за да утоли жаждата си.\n\nПример:\n- min_buckets_needed(23, 11) връща 3\n- min_buckets_needed(30, 10) връща 3",
      "zh": "计算长颈鹿需要喝多少桶水才能解渴，给定桶的大小。\n\n长颈鹿需要喝20升水才能解渴。此函数根据每个桶的体积来确定需要多少桶水。桶是圆柱形的，具有给定的高度和半径。\n\n参数:\n- height: 桶的高度，单位为厘米 (整数)。\n- radius: 桶底的半径，单位为厘米 (整数)。\n\n返回:\n- 一个整数，表示长颈鹿解渴所需的最少桶数。\n\n示例:\n- min_buckets_needed(23, 11) 返回 3\n- min_buckets_needed(30, 10) 返回 3",
      "fr": "Calcule le nombre minimum de seaux dont une girafe a besoin pour boire afin d'étancher sa soif, étant donné la taille des seaux.\n\nUne girafe a besoin de boire 20 litres d'eau pour étancher sa soif. Cette fonction détermine combien de seaux d'eau elle aurait besoin, en fonction du volume de chaque seau. Les seaux sont de forme cylindrique, avec une hauteur et un rayon donnés.\n\nArguments:\n- height: La hauteur du seau en centimètres (entier).\n- radius: Le rayon de la base du seau en centimètres (entier).\n\nRetourne:\n- Un entier représentant le nombre minimum de seaux nécessaires pour que la girafe étanche sa soif.\n\nExemple:\n- min_buckets_needed(23, 11) retourne 3\n- min_buckets_needed(30, 10) retourne 3",
      "de": "Berechnet die minimale Anzahl von Eimern, die eine Giraffe benötigt, um ihren Durst zu stillen, basierend auf der Größe der Eimer.\n\nEine Giraffe muss 20 Liter Wasser trinken, um ihren Durst zu stillen. Diese Funktion bestimmt, wie viele Eimer Wasser sie benötigt, basierend auf dem Volumen jedes Eimers. Die Eimer sind zylindrisch geformt, mit gegebener Höhe und Radius.\n\nArgumente:\n- height: Die Höhe des Eimers in Zentimetern (Ganzzahl).\n- radius: Der Radius der Basis des Eimers in Zentimetern (Ganzzahl).\n\nRückgabe:\n- Eine Ganzzahl, die die minimale Anzahl von Eimern darstellt, die benötigt werden, damit die Giraffe ihren Durst stillen kann.\n\nBeispiel:\n- min_buckets_needed(23, 11) gibt 3 zurück\n- min_buckets_needed(30, 10) gibt 3 zurück",
      "ha": "Yana ƙididdige mafi ƙarancin adadin guga da giwa ke buƙata don shan ruwa har ta koshi, la'akari da girman gugan.\n\n  Giwa tana buƙatar shan lita 20 na ruwa don koshi. Wannan aikin yana tantance yawan guga na ruwa da za ta buƙata, dangane da girman kowanne guga. Gugunan suna da siffar silinda, tare da tsawo da kuma radius da aka bayar.\n\n  Huɗodi:\n  - height: Tsawon gugan a cikin santimita (adadi mai cikakken lamba).\n  - radius: Radius na tushen gugan a cikin santimita (adadi mai cikakken lamba).\n\n  Dawowa:\n  - Adadi mai cikakken lamba da ke wakiltar mafi ƙarancin adadin guga da ake buƙata don giwa ta koshi.\n\n  Misali:\n  - min_buckets_needed(23, 11) yana dawowa 3\n  - min_buckets_needed(30, 10) yana dawowa 3",
      "hi": "गिरगिट को अपनी प्यास बुझाने के लिए कम से कम कितनी बाल्टियों की आवश्यकता है, यह बाल्टियों के आकार के आधार पर गणना करता है।\n\n  एक गिरगिट को अपनी प्यास बुझाने के लिए 20 लीटर पानी पीने की आवश्यकता होती है। यह फ़ंक्शन यह निर्धारित करता है कि उसे कितनी बाल्टियों की आवश्यकता होगी, प्रत्येक बाल्टी के आयतन के आधार पर। बाल्टियाँ बेलनाकार आकार की होती हैं, जिनकी दी गई ऊँचाई और त्रिज्या होती है।\n\n  तर्क:\n  - height: बाल्टी की ऊँचाई सेंटीमीटर में (पूर्णांक)।\n  - radius: बाल्टी के आधार की त्रिज्या सेंटीमीटर में (पूर्णांक)।\n\n  लौटाता है:\n  - एक पूर्णांक जो गिरगिट को अपनी प्यास बुझाने के लिए आवश्यक न्यूनतम बाल्टियों की संख्या को दर्शाता है।\n\n  उदाहरण:\n  - min_buckets_needed(23, 11) 3 लौटाता है\n  - min_buckets_needed(30, 10) 3 लौटाता है",
      "hu": "Kiszámítja a minimum számú vödröt, amelyre egy zsiráfnak szüksége van, hogy oltsa a szomját, adott a vödrök mérete.\n\nEgy zsiráfnak 20 liter vizet kell innia, hogy oltsa a szomját. Ez a függvény meghatározza, hány vödör vízre lenne szüksége, a vödör térfogata alapján. A vödrök henger alakúak, adott magassággal és sugárral.\n\nÉrvek:\n- height: A vödör magassága centiméterben (egész szám).\n- radius: A vödör alapjának sugara centiméterben (egész szám).\n\nVisszatérési érték:\n- Egy egész szám, amely a minimum számú vödröt jelenti, amelyre a zsiráfnak szüksége van, hogy oltsa a szomját.\n\nPélda:\n- min_buckets_needed(23, 11) visszaadja 3\n- min_buckets_needed(30, 10) visszaadja 3"
    },
    "docstring_bertscore": {
      "sq": "0.9862456406348581",
      "hy": "0.9708202038740698",
      "bn": "0.964205812185608",
      "bg": "0.9868874153959819",
      "zh": "0.9605706775822885",
      "fr": "0.9849948651254814",
      "de": "0.9815968951971176",
      "ha": "0.9164781097090209",
      "hi": "0.9454086247067524",
      "hu": "0.9719547806105411"
    }
  },
  {
    "task_id": "Rust/20",
    "prompt": {
      "en": "/*\n  Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "sq": "/*\n  Llogarit sipërfaqen e një trekëndëshi duke dhënë koordinatat e kulmeve të tij.\n\n  Argumentet:\n  - x1, y1: Koordinatat x dhe y të kulmit të parë.\n  - x2, y2: Koordinatat x dhe y të kulmit të dytë.\n  - x3, y3: Koordinatat x dhe y të kulmit të tretë.\n\n  Kthen:\n  - Sipërfaqja e trekëndëshit, e rrumbullakosur në dy vende dhjetore.\n\n  Shembuj:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) kthen 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "hy": "/*\n  Հաշվում է եռանկյան մակերեսը, եթե տրված են նրա գագաթների կոորդինատները:\n\n  Արգումենտներ:\n  - x1, y1: Առաջին գագաթի x և y կոորդինատները:\n  - x2, y2: Երկրորդ գագաթի x և y կոորդինատները:\n  - x3, y3: Երրորդ գագաթի x և y կոորդինատները:\n\n  Վերադարձնում է:\n  - Եռանկյան մակերեսը՝ կլորացված մինչև երկու տասնորդական թվանշան:\n\n  Օրինակներ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) վերադարձնում է 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "bn": "/*\n  প্রদত্ত শীর্ষবিন্দুগুলির স্থানাঙ্ক অনুযায়ী একটি ত্রিভুজের ক্ষেত্রফল গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - x1, y1: প্রথম শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n  - x2, y2: দ্বিতীয় শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n  - x3, y3: তৃতীয় শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n\n  রিটার্ন করে:\n  - ত্রিভুজের ক্ষেত্রফল, দুই দশমিক স্থান পর্যন্ত গোলাকার।\n\n  উদাহরণ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) রিটার্ন করে 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "bg": "/*\n  Изчислява площта на триъгълник, като се използват координатите на неговите върхове.\n\n  Аргументи:\n  - x1, y1: x и y координатите на първия връх.\n  - x2, y2: x и y координатите на втория връх.\n  - x3, y3: x и y координатите на третия връх.\n\n  Връща:\n  - Площта на триъгълника, закръглена до два десетични знака.\n\n  Примери:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) връща 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "zh": "/*\n  计算给定顶点坐标的三角形面积。\n\n  参数:\n  - x1, y1: 第一个顶点的 x 和 y 坐标。\n  - x2, y2: 第二个顶点的 x 和 y 坐标。\n  - x3, y3: 第三个顶点的 x 和 y 坐标。\n\n  返回:\n  - 三角形的面积，四舍五入到小数点后两位。\n\n  示例:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 返回 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "fr": "/*\n  Calcule la surface d'un triangle étant donné les coordonnées de ses sommets.\n\n  Arguments :\n  - x1, y1 : Les coordonnées x et y du premier sommet.\n  - x2, y2 : Les coordonnées x et y du deuxième sommet.\n  - x3, y3 : Les coordonnées x et y du troisième sommet.\n\n  Renvoie :\n  - La surface du triangle, arrondie à deux décimales.\n\n  Exemples :\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) renvoie 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "de": "/*\n  Berechnet die Fläche eines Dreiecks anhand der Koordinaten seiner Eckpunkte.\n\n  Argumente:\n  - x1, y1: Die x- und y-Koordinaten des ersten Eckpunkts.\n  - x2, y2: Die x- und y-Koordinaten des zweiten Eckpunkts.\n  - x3, y3: Die x- und y-Koordinaten des dritten Eckpunkts.\n\n  Rückgabewert:\n  - Die Fläche des Dreiecks, gerundet auf zwei Dezimalstellen.\n\n  Beispiele:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) gibt 6.00 zurück\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "ha": "/*\n  Lissafi yankin wani kusurwar kusurwa idan an bayar da daidaitattun wuraren kololuwarta.\n\n  Huɗa:\n  - x1, y1: Daidaitattun x da y na kololuwa ta farko.\n  - x2, y2: Daidaitattun x da y na kololuwa ta biyu.\n  - x3, y3: Daidaitattun x da y na kololuwa ta uku.\n\n  Komawa:\n  - Yankin kusurwar, an zagaye zuwa wurare biyu na goma.\n\n  Misalai:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) yana dawowa 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "hi": "/*\n  त्रिभुज के शीर्षों के निर्देशांक दिए जाने पर त्रिभुज का क्षेत्रफल गणना करता है।\n\n  तर्क:\n  - x1, y1: पहले शीर्ष के x और y निर्देशांक।\n  - x2, y2: दूसरे शीर्ष के x और y निर्देशांक।\n  - x3, y3: तीसरे शीर्ष के x और y निर्देशांक।\n\n  लौटाता है:\n  - त्रिभुज का क्षेत्रफल, दो दशमलव स्थानों तक गोल किया गया।\n\n  उदाहरण:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 लौटाता है\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 ",
      "hu": "/*\n  Számítja a háromszög területét a csúcsok koordinátái alapján.\n\n  Argumentumok:\n  - x1, y1: Az első csúcs x és y koordinátái.\n  - x2, y2: A második csúcs x és y koordinátái.\n  - x3, y3: A harmadik csúcs x és y koordinátái.\n\n  Visszatér:\n  - A háromszög területe, két tizedesjegyre kerekítve.\n\n  Példák:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) visszatér 6.00\n*/\n\n\nfn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32 "
    },
    "prompt_bertscore": {
      "sq": "0.9981640593880945",
      "hy": "1",
      "bn": "0.9769914511824427",
      "bg": "0.9775821779356404",
      "zh": "0.9897854326552809",
      "fr": "0.9981640593880945",
      "de": "0.9870894224934943",
      "ha": "0.9879036084253563",
      "hi": "0.9798783451404037",
      "hu": "0.9935087591477798"
    },
    "canonical_solution": "{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}",
    "instruction": {
      "en": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Rust կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 अक्षरों का हो।",
      "hu": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32\n{\n    let side_a = ((x2 - x1).powi(2) + (y2 - y1).powi(2)).sqrt();\n    let side_b = ((x3 - x2).powi(2) + (y3 - y2).powi(2)).sqrt();\n    let side_c = ((x1 - x3).powi(2) + (y1 - y3).powi(2)).sqrt();\n    let s = (side_a + side_b + side_c) / 2.0;\n    let area = (s * (s - side_a) * (s - side_b) * (s - side_c)).sqrt();\n\n    (area * 100.0).round() / 100.0 // rounding to two decimal places\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8912488732314935",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9412908182775181",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0), 6.00);\n        assert_eq!(triangle_area(1.0, 2.0, 4.0, 5.0, 6.0, 3.0), 6.00); // Example test case, replace with correct area\n        assert_eq!(triangle_area(0.0, 0.0, 7.0, 8.0, 9.0, 10.0), 1.00); \n    }\n    \n\n}",
    "entry_point": "triangle_area",
    "signature": "fn triangle_area(x1: f32, y1: f32, x2: f32, y2: f32, x3: f32, y3: f32) -> f32",
    "docstring": {
      "en": "Calculates the area of a triangle given the coordinates of its vertices.\n\n  Arguments:\n  - x1, y1: The x and y coordinates of the first vertex.\n  - x2, y2: The x and y coordinates of the second vertex.\n  - x3, y3: The x and y coordinates of the third vertex.\n\n  Returns:\n  - The area of the triangle, rounded to two decimal places.\n\n  Examples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) returns 6.00",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke dhënë koordinatat e kulmeve të tij.\n\n  Argumentet:\n  - x1, y1: Koordinatat x dhe y të kulmit të parë.\n  - x2, y2: Koordinatat x dhe y të kulmit të dytë.\n  - x3, y3: Koordinatat x dhe y të kulmit të tretë.\n\n  Kthen:\n  - Sipërfaqja e trekëndëshit, e rrumbullakosur në dy vende dhjetore.\n\n  Shembuj:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) kthen 6.00",
      "hy": "Հաշվում է եռանկյան մակերեսը՝ հաշվի առնելով նրա գագաթների կոորդինատները։\n\n  Արգումենտներ:\n  - x1, y1: Առաջին գագաթի x և y կոորդինատները։\n  - x2, y2: Երկրորդ գագաթի x և y կոորդինատները։\n  - x3, y3: Երրորդ գագաթի x և y կոորդինատները։\n\n  Վերադարձնում է:\n  - Եռանկյան մակերեսը՝ կլորացված մինչև երկու տասնորդական։\n\n  Օրինակներ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) վերադարձնում է 6.00",
      "bn": "ত্রিভুজের শীর্ষবিন্দুগুলির স্থানাঙ্ক দেওয়া থাকলে তার ক্ষেত্রফল গণনা করে।\n\n  আর্গুমেন্টস:\n  - x1, y1: প্রথম শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n  - x2, y2: দ্বিতীয় শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n  - x3, y3: তৃতীয় শীর্ষবিন্দুর x এবং y স্থানাঙ্ক।\n\n  রিটার্নস:\n  - ত্রিভুজের ক্ষেত্রফল, দুই দশমিক স্থান পর্যন্ত গোলাকার।\n\n  উদাহরণ:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) রিটার্ন করে 6.00",
      "bg": "Изчислява площта на триъгълник, като се дадат координатите на неговите върхове.\n\n  Аргументи:\n  - x1, y1: x и y координатите на първия връх.\n  - x2, y2: x и y координатите на втория връх.\n  - x3, y3: x и y координатите на третия връх.\n\n  Връща:\n  - Площта на триъгълника, закръглена до два десетични знака.\n\n  Примери:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) връща 6.00",
      "zh": "计算给定顶点坐标的三角形面积。\n\n  参数：\n  - x1, y1: 第一个顶点的 x 和 y 坐标。\n  - x2, y2: 第二个顶点的 x 和 y 坐标。\n  - x3, y3: 第三个顶点的 x 和 y 坐标。\n\n  返回：\n  - 三角形的面积，四舍五入到小数点后两位。\n\n  示例：\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 返回 6.00",
      "fr": "Calcule la surface d'un triangle étant donné les coordonnées de ses sommets.\n\n  Arguments:\n  - x1, y1 : Les coordonnées x et y du premier sommet.\n  - x2, y2 : Les coordonnées x et y du deuxième sommet.\n  - x3, y3 : Les coordonnées x et y du troisième sommet.\n\n  Renvoie:\n  - La surface du triangle, arrondie à deux décimales.\n\n  Exemples:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) renvoie 6.00",
      "de": "Berechnet die Fläche eines Dreiecks, gegeben die Koordinaten seiner Eckpunkte.\n\n  Argumente:\n  - x1, y1: Die x- und y-Koordinaten des ersten Eckpunkts.\n  - x2, y2: Die x- und y-Koordinaten des zweiten Eckpunkts.\n  - x3, y3: Die x- und y-Koordinaten des dritten Eckpunkts.\n\n  Rückgabewert:\n  - Die Fläche des Dreiecks, gerundet auf zwei Dezimalstellen.\n\n  Beispiele:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) gibt 6.00 zurück",
      "ha": "Yana lissafin yankin wani alwatika idan an ba da daidaitattun wuraren kololuwansa.\n\n  Huɗɗa:\n  - x1, y1: Daidaitattun x da y na kololuwa na farko.\n  - x2, y2: Daidaitattun x da y na kololuwa na biyu.\n  - x3, y3: Daidaitattun x da y na kololuwa na uku.\n\n  Komawa:\n  - Yankin alwatika, an zagaye zuwa wurare biyu na goma.\n\n  Misalai:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) yana komawa 6.00",
      "hi": "त्रिभुज के क्षेत्रफल की गणना करता है जब इसके शीर्षों के निर्देशांक दिए गए हों।\n\n  तर्क:\n  - x1, y1: पहले शीर्ष का x और y निर्देशांक।\n  - x2, y2: दूसरे शीर्ष का x और y निर्देशांक।\n  - x3, y3: तीसरे शीर्ष का x और y निर्देशांक।\n\n  वापसी:\n  - त्रिभुज का क्षेत्रफल, दो दशमलव स्थानों तक गोल किया गया।\n\n  उदाहरण:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) 6.00 लौटाता है।",
      "hu": "Számítja egy háromszög területét a csúcsainak koordinátái alapján.\n\n  Argumentumok:\n  - x1, y1: Az első csúcs x és y koordinátái.\n  - x2, y2: A második csúcs x és y koordinátái.\n  - x3, y3: A harmadik csúcs x és y koordinátái.\n\n  Visszatérési érték:\n  - A háromszög területe, két tizedesjegyre kerekítve.\n\n  Példák:\n  - triangle_area(0.0, 0.0, 4.0, 0.0, 0.0, 3.0) visszaadja 6.00"
    },
    "docstring_bertscore": {
      "sq": "0.99799621671612",
      "hy": "0.9954730149858338",
      "bn": "0.5602321377583765",
      "bg": "0.9817853954287197",
      "zh": "0.9865461684013639",
      "fr": "0.99799621671612",
      "de": "0.9857190714947346",
      "ha": "0.986210483057415",
      "hi": "0.9755853467150967",
      "hu": "0.9857190714947346"
    }
  },
  {
    "task_id": "Rust/21",
    "prompt": {
      "en": "/*\n  Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "sq": "/*\n  Llogarit postën bazuar në peshën e një pakete dhe nëse është zgjedhur shërbimi ekspres.\n  Posta llogaritet si më poshtë:\n  - Për peshë deri në dhe duke përfshirë 1000 gram, tarifa bazë është 8 njësi.\n  - Për çdo 500 gram shtesë ose pjesë të saj, shtohet një tarifë shtesë prej 4 njësi.\n  - Nëse është zgjedhur shërbimi ekspres (i shënuar me 'y'), shtohet një tarifë shtesë prej 5 njësi.\n  - Nëse nuk është zgjedhur shërbimi ekspres (i shënuar me 'n'), nuk shtohet asnjë tarifë shtesë.\n\n  Argumentet:\n  - weight: Pesha e paketës në gram.\n  - express: Një karakter që tregon nëse është zgjedhur shërbimi ekspres ('y' për po, 'n' për jo).\n\n  Kthen:\n  - Koston totale të postës si një numër i plotë pa shenjë.\n\n  Shembuj:\n  - calculate_postage(1200, 'y') kthen 17.\n  - calculate_postage(1000, 'n') kthen 8.\n  - calculate_postage(1500, 'y') kthen 17.\n  - calculate_postage(2000, 'n') kthen 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "hy": "/*\n  Հաշվում է փոստային ծախսերը փաթեթի քաշի և արդյոք ընտրված է արագ առաքման ծառայությունը:\n  Փոստային ծախսերը հաշվարկվում են հետևյալ կերպ.\n  - Մինչև և ներառյալ 1000 գրամ քաշի դեպքում հիմնական վճարը կազմում է 8 միավոր:\n  - Յուրաքանչյուր լրացուցիչ 500 գրամի կամ դրա մասի համար ավելացվում է 4 միավոր լրացուցիչ վճար:\n  - Եթե ընտրված է արագ առաքման ծառայությունը (նշված է 'y' տառով), ավելացվում է 5 միավոր լրացուցիչ վճար:\n  - Եթե արագ առաքման ծառայությունը ընտրված չէ (նշված է 'n' տառով), լրացուցիչ վճար չի ավելացվում:\n\n  Արգումենտներ:\n  - weight: Փաթեթի քաշը գրամներով:\n  - express: Նիշ, որը ցույց է տալիս արդյոք ընտրված է արագ առաքման ծառայությունը ('y' այո-ի համար, 'n' ոչ-ի համար):\n\n  Վերադարձնում է:\n  - Ընդհանուր փոստային ծախսերը որպես անստորակետ ամբողջ թիվ:\n\n  Օրինակներ:\n  - calculate_postage(1200, 'y') վերադարձնում է 17:\n  - calculate_postage(1000, 'n') վերադարձնում է 8:\n  - calculate_postage(1500, 'y') վերադարձնում է 17:\n  - calculate_postage(2000, 'n') վերադարձնում է 16:\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "bn": "/*\n  একটি প্যাকেজের ওজন এবং এক্সপ্রেস পরিষেবা নির্বাচন করা হয়েছে কিনা তার উপর ভিত্তি করে ডাকমাশুল গণনা করে।\n  ডাকমাশুল নিম্নরূপ গণনা করা হয়:\n  - ওজন ১০০০ গ্রাম পর্যন্ত এবং সহ, বেস ফি ৮ ইউনিট।\n  - প্রতিটি অতিরিক্ত ৫০০ গ্রাম বা তার অংশের জন্য, অতিরিক্ত ৪ ইউনিট ফি যোগ করা হয়।\n  - যদি এক্সপ্রেস পরিষেবা (যা 'y' দ্বারা নির্দেশিত) নির্বাচন করা হয়, অতিরিক্ত ৫ ইউনিট ফি যোগ করা হয়।\n  - যদি এক্সপ্রেস পরিষেবা নির্বাচন না করা হয় (যা 'n' দ্বারা নির্দেশিত), কোন অতিরিক্ত ফি যোগ করা হয় না।\n\n  আর্গুমেন্ট:\n  - weight: প্যাকেজের ওজন গ্রামে।\n  - express: একটি চরিত্র যা নির্দেশ করে যে এক্সপ্রেস পরিষেবা নির্বাচন করা হয়েছে কিনা ('y' হ্যাঁ এর জন্য, 'n' না এর জন্য)।\n\n  রিটার্ন:\n  - মোট ডাকমাশুল খরচ একটি আনসাইনড পূর্ণসংখ্যা হিসাবে।\n\n  উদাহরণ:\n  - calculate_postage(1200, 'y') ১৭ রিটার্ন করে।\n  - calculate_postage(1000, 'n') ৮ রিটার্ন করে।\n  - calculate_postage(1500, 'y') ১৭ রিটার্ন করে।\n  - calculate_postage(2000, 'n') ১৬ রিটার্ন করে।\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "bg": "/*\n  Изчислява пощенските разходи въз основа на теглото на пратката и дали е избрана експресна услуга.\n  Пощенските разходи се изчисляват по следния начин:\n  - За тегло до и включително 1000 грама, основната такса е 8 единици.\n  - За всеки допълнителни 500 грама или част от тях, се добавя допълнителна такса от 4 единици.\n  - Ако е избрана експресна услуга (обозначена с 'y'), се добавя допълнителна такса от 5 единици.\n  - Ако експресна услуга не е избрана (обозначена с 'n'), не се добавя допълнителна такса.\n\n  Аргументи:\n  - weight: Теглото на пратката в грамове.\n  - express: Символ, указващ дали е избрана експресна услуга ('y' за да, 'n' за не).\n\n  Връща:\n  - Общата стойност на пощенските разходи като беззнаков цяло число.\n\n  Примери:\n  - calculate_postage(1200, 'y') връща 17.\n  - calculate_postage(1000, 'n') връща 8.\n  - calculate_postage(1500, 'y') връща 17.\n  - calculate_postage(2000, 'n') връща 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "zh": "/*\n  根据包裹的重量和是否选择快递服务计算邮资。\n  邮资计算如下：\n  - 对于重量不超过1000克的包裹，基本费用为8单位。\n  - 每增加500克或不足500克的部分，增加4单位费用。\n  - 如果选择了快递服务（用'y'表示），则增加5单位费用。\n  - 如果未选择快递服务（用'n'表示），则不增加费用。\n\n  参数:\n  - weight: 包裹的重量，单位为克。\n  - express: 一个字符，表示是否选择快递服务（'y'表示是，'n'表示否）。\n\n  返回:\n  - 总邮资成本，作为无符号整数返回。\n\n  示例:\n  - calculate_postage(1200, 'y') 返回 17。\n  - calculate_postage(1000, 'n') 返回 8。\n  - calculate_postage(1500, 'y') 返回 17。\n  - calculate_postage(2000, 'n') 返回 16。\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "fr": "/*\n  Calcule les frais de port en fonction du poids d'un colis et si le service express est choisi.\n  Les frais de port sont calculés comme suit :\n  - Pour un poids allant jusqu'à 1000 grammes inclus, le tarif de base est de 8 unités.\n  - Pour chaque tranche supplémentaire de 500 grammes ou partie de celle-ci, un tarif supplémentaire de 4 unités est ajouté.\n  - Si le service express (indiqué par 'y') est choisi, un tarif supplémentaire de 5 unités est ajouté.\n  - Si le service express n'est pas choisi (indiqué par 'n'), aucun tarif supplémentaire n'est ajouté.\n\n  Arguments :\n  - weight : Le poids du colis en grammes.\n  - express : Un caractère indiquant si le service express est choisi ('y' pour oui, 'n' pour non).\n\n  Renvoie :\n  - Le coût total des frais de port en tant qu'entier non signé.\n\n  Exemples :\n  - calculate_postage(1200, 'y') renvoie 17.\n  - calculate_postage(1000, 'n') renvoie 8.\n  - calculate_postage(1500, 'y') renvoie 17.\n  - calculate_postage(2000, 'n') renvoie 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "de": "/*\n  Berechnet das Porto basierend auf dem Gewicht eines Pakets und ob der Expressdienst gewählt wurde.\n  Das Porto wird wie folgt berechnet:\n  - Für ein Gewicht bis einschließlich 1000 Gramm beträgt die Grundgebühr 8 Einheiten.\n  - Für je weitere 500 Gramm oder einen Teil davon wird eine zusätzliche Gebühr von 4 Einheiten hinzugefügt.\n  - Wenn der Expressdienst (angegeben durch 'y') gewählt wird, wird eine zusätzliche Gebühr von 5 Einheiten hinzugefügt.\n  - Wenn der Expressdienst nicht gewählt wird (angegeben durch 'n'), wird keine zusätzliche Gebühr hinzugefügt.\n\n  Argumente:\n  - weight: Das Gewicht des Pakets in Gramm.\n  - express: Ein Zeichen, das angibt, ob der Expressdienst gewählt wurde ('y' für ja, 'n' für nein).\n\n  Rückgabewert:\n  - Die gesamten Portokosten als vorzeichenloser Ganzzahlwert.\n\n  Beispiele:\n  - calculate_postage(1200, 'y') gibt 17 zurück.\n  - calculate_postage(1000, 'n') gibt 8 zurück.\n  - calculate_postage(1500, 'y') gibt 17 zurück.\n  - calculate_postage(2000, 'n') gibt 16 zurück.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "ha": "/*\n  Lissafa kuɗin aikawa bisa nauyin kunshin da kuma ko an zaɓi sabis na gaggawa.\n  Ana lissafa kuɗin aikawa kamar haka:\n  - Don nauyi har zuwa da kuma har da gram 1000, kuɗin asali yana daidai da raka'a 8.\n  - Don kowane gram 500 na ƙarin ko wani ɓangare na shi, ana ƙara kuɗi na ƙarin raka'a 4.\n  - Idan an zaɓi sabis na gaggawa (wanda aka nuna da 'y'), ana ƙara kuɗi na ƙarin raka'a 5.\n  - Idan ba a zaɓi sabis na gaggawa ba (wanda aka nuna da 'n'), ba a ƙara wani kuɗi ba.\n\n  Huɗɗa:\n  - weight: Nauyin kunshin a cikin gram.\n  - express: Alamar harafi da ke nuna ko an zaɓi sabis na gaggawa ('y' don eh, 'n' don a'a).\n\n  Komawa:\n  - Jimillar kuɗin aikawa a matsayin cikakken lamba mara alama.\n\n  Misalai:\n  - calculate_postage(1200, 'y') yana dawowa 17.\n  - calculate_postage(1000, 'n') yana dawowa 8.\n  - calculate_postage(1500, 'y') yana dawowa 17.\n  - calculate_postage(2000, 'n') yana dawowa 16.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "hi": "/*\n  पैकेज के वजन और क्या एक्सप्रेस सेवा चुनी गई है, के आधार पर डाक शुल्क की गणना करता है।\n  डाक शुल्क की गणना निम्नलिखित रूप से की जाती है:\n  - 1000 ग्राम तक और उसके सहित वजन के लिए, आधार शुल्क 8 यूनिट है।\n  - प्रत्येक अतिरिक्त 500 ग्राम या उसके हिस्से के लिए, अतिरिक्त शुल्क 4 यूनिट जोड़ा जाता है।\n  - यदि एक्सप्रेस सेवा (जिसे 'y' द्वारा दर्शाया गया है) चुनी जाती है, तो अतिरिक्त शुल्क 5 यूनिट जोड़ा जाता है।\n  - यदि एक्सप्रेस सेवा नहीं चुनी जाती है (जिसे 'n' द्वारा दर्शाया गया है), तो कोई अतिरिक्त शुल्क नहीं जोड़ा जाता है।\n\n  तर्क:\n  - weight: पैकेज का वजन ग्राम में।\n  - express: एक चरित्र जो दर्शाता है कि क्या एक्सप्रेस सेवा चुनी गई है ('y' हाँ के लिए, 'n' नहीं के लिए)।\n\n  रिटर्न करता है:\n  - कुल डाक लागत एक बिना चिह्नित पूर्णांक के रूप में।\n\n  उदाहरण:\n  - calculate_postage(1200, 'y') 17 लौटाता है।\n  - calculate_postage(1000, 'n') 8 लौटाता है।\n  - calculate_postage(1500, 'y') 17 लौटाता है।\n  - calculate_postage(2000, 'n') 16 लौटाता है।\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 ",
      "hu": "/*\n  Kiszámítja a postaköltséget egy csomag súlya és az expressz szolgáltatás választása alapján.\n  A postaköltség a következőképpen kerül kiszámításra:\n  - 1000 grammig bezárólag az alapdíj 8 egység.\n  - Minden további 500 gramm vagy annak töredéke esetén további 4 egység díj kerül felszámításra.\n  - Ha az expressz szolgáltatás (amit 'y' jelöl) van választva, további 5 egység díj kerül felszámításra.\n  - Ha az expressz szolgáltatás nincs választva (amit 'n' jelöl), nem kerül felszámításra további díj.\n\n  Argumentumok:\n  - weight: A csomag súlya grammban.\n  - express: Egy karakter, amely jelzi, hogy az expressz szolgáltatás van-e választva ('y' az igen, 'n' a nem esetén).\n\n  Visszatér:\n  - A teljes postaköltség mint előjelnélküli egész szám.\n\n  Példák:\n  - calculate_postage(1200, 'y') visszaadja a 17-et.\n  - calculate_postage(1000, 'n') visszaadja a 8-at.\n  - calculate_postage(1500, 'y') visszaadja a 17-et.\n  - calculate_postage(2000, 'n') visszaadja a 16-ot.\n*/\n\n\nfn calculate_postage(weight: u32, express: char) -> u32 "
    },
    "prompt_bertscore": {
      "sq": "0.9752784627763978",
      "hy": "0.9431364917780943",
      "bn": "0.9794010363347769",
      "bg": "0.987343470750838",
      "zh": "0.9551115201899256",
      "fr": "0.948845526189799",
      "de": "0.972369719476523",
      "ha": "0.957237659788523",
      "hi": "0.9876892862442197",
      "hu": "0.9734033919794285"
    },
    "canonical_solution": "{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}",
    "instruction": {
      "en": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nনিচের রাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\n请用中文为以下Rust代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn calculate_postage(weight: u32, express: char) -> u32\n{\n    let base_fee = 8;\n    let extra_weight_fee = ((weight.saturating_sub(1000) + 499) / 500) * 4; // Adding 499 to round up\n    let express_fee = if express == 'y' { 5 } else { 0 };\n\n    base_fee + extra_weight_fee + express_fee\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9217118216189092",
      "bn": "0.8690823185991431",
      "bg": "0.8316696904400789",
      "zh": "0.8627098587147819",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9665526301375352",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_postage(1200, 'y'), 17);\n        assert_eq!(calculate_postage(1000, 'n'), 8);\n        assert_eq!(calculate_postage(1500, 'y'), 17);\n        assert_eq!(calculate_postage(2000, 'n'), 16);\n        \n    }\n    \n\n}",
    "entry_point": "calculate_postage",
    "signature": "fn calculate_postage(weight: u32, express: char) -> u32",
    "docstring": {
      "en": "Calculates the postage based on the weight of a package and whether express service is chosen.\n  The postage is calculated as follows:\n  - For weight up to and including 1000 grams, the base fee is 8 units.\n  - For each additional 500 grams or part thereof, an additional fee of 4 units is added.\n  - If express service (denoted by 'y') is chosen, an additional fee of 5 units is added.\n  - If express service is not chosen (denoted by 'n'), no additional fee is added.\n\n  Arguments:\n  - weight: The weight of the package in grams.\n  - express: A character indicating whether express service is chosen ('y' for yes, 'n' for no).\n\n  Returns:\n  - The total postage cost as an unsigned integer.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "sq": "Llogarit postën bazuar në peshën e një pakete dhe nëse është zgjedhur shërbimi ekspres.\n  Posta llogaritet si më poshtë:\n  - Për peshë deri në dhe duke përfshirë 1000 gramë, tarifa bazë është 8 njësi.\n  - Për çdo 500 gramë shtesë ose pjesë të tyre, shtohet një tarifë shtesë prej 4 njësi.\n  - Nëse shërbimi ekspres (i shënuar me 'y') është zgjedhur, shtohet një tarifë shtesë prej 5 njësi.\n  - Nëse shërbimi ekspres nuk është zgjedhur (i shënuar me 'n'), nuk shtohet asnjë tarifë shtesë.\n\n  Argumentet:\n  - weight: Pesha e paketës në gramë.\n  - express: Një karakter që tregon nëse është zgjedhur shërbimi ekspres ('y' për po, 'n' për jo).\n\n  Kthen:\n  - Koston totale të postës si një numër i plotë pa shenjë.\n\n  Shembuj:\n  - calculate_postage(1200, 'y') kthen 17.\n  - calculate_postage(1000, 'n') kthen 8.\n  - calculate_postage(1500, 'y') kthen 17.\n  - calculate_postage(2000, 'n') kthen 16.",
      "hy": "Հաշվում է փոստային վճարը փաթեթի քաշի և արդյոք արագ առաքման ծառայություն ընտրված է, թե ոչ։\n  Փոստային վճարը հաշվարկվում է հետևյալ կերպ․\n  - Մինչև 1000 գրամ քաշի համար, հիմնական վճարը կազմում է 8 միավոր։\n  - Յուրաքանչյուր լրացուցիչ 500 գրամի կամ դրա մասի համար, ավելացվում է լրացուցիչ 4 միավոր։\n  - Եթե արագ առաքման ծառայությունը (նշված 'y' տառով) ընտրված է, ավելացվում է լրացուցիչ 5 միավոր։\n  - Եթե արագ առաքման ծառայությունը ընտրված չէ (նշված 'n' տառով), լրացուցիչ վճար չի ավելացվում։\n\n  Արգումենտներ:\n  - weight: Փաթեթի քաշը գրամներով։\n  - express: Սիմվոլ, որը ցույց է տալիս արդյոք արագ առաքման ծառայությունը ընտրված է ('y' այո, 'n' ոչ)։\n\n  Վերադարձնում է:\n  - Ընդհանուր փոստային վճարը որպես անստորակետ ամբողջ թիվ։\n\n  Օրինակներ:\n  - calculate_postage(1200, 'y') վերադարձնում է 17։\n  - calculate_postage(1000, 'n') վերադարձնում է 8։\n  - calculate_postage(1500, 'y') վերադարձնում է 17։\n  - calculate_postage(2000, 'n') վերադարձնում է 16։",
      "bn": "প্যাকেজের ওজন এবং এক্সপ্রেস পরিষেবা বেছে নেওয়া হয়েছে কিনা তার উপর ভিত্তি করে ডাকমাশুল গণনা করে।\n  ডাকমাশুল নিম্নরূপ গণনা করা হয়:\n  - ওজন ১০০০ গ্রাম পর্যন্ত এবং এর মধ্যে হলে, বেস ফি ৮ ইউনিট।\n  - প্রতিটি অতিরিক্ত ৫০০ গ্রাম বা তার অংশের জন্য, অতিরিক্ত ফি ৪ ইউনিট যোগ করা হয়।\n  - যদি এক্সপ্রেস পরিষেবা (যা 'y' দ্বারা চিহ্নিত) বেছে নেওয়া হয়, অতিরিক্ত ফি ৫ ইউনিট যোগ করা হয়।\n  - যদি এক্সপ্রেস পরিষেবা বেছে না নেওয়া হয় (যা 'n' দ্বারা চিহ্নিত), অতিরিক্ত ফি যোগ করা হয় না।\n\n  আর্গুমেন্টসমূহ:\n  - weight: প্যাকেজের ওজন গ্রামে।\n  - express: একটি চরিত্র যা নির্দেশ করে যে এক্সপ্রেস পরিষেবা বেছে নেওয়া হয়েছে কিনা ('y' হ্যাঁ এর জন্য, 'n' না এর জন্য)।\n\n  রিটার্নস:\n  - মোট ডাকমাশুল একটি অসম্পূর্ণ পূর্ণসংখ্যা হিসাবে।\n\n  উদাহরণসমূহ:\n  - calculate_postage(1200, 'y') রিটার্ন করে 17।\n  - calculate_postage(1000, 'n') রিটার্ন করে 8।\n  - calculate_postage(1500, 'y') রিটার্ন করে 17।\n  - calculate_postage(2000, 'n') রিটার্ন করে 16।",
      "bg": "Изчислява пощенските разходи на базата на теглото на пакет и дали е избрана експресна услуга.\n  Пощенските разходи се изчисляват, както следва:\n  - За тегло до и включително 1000 грама, основната такса е 8 единици.\n  - За всеки допълнителни 500 грама или част от тях, се добавя допълнителна такса от 4 единици.\n  - Ако е избрана експресна услуга (обозначено с 'y'), се добавя допълнителна такса от 5 единици.\n  - Ако експресната услуга не е избрана (обозначено с 'n'), не се добавя допълнителна такса.\n\n  Аргументи:\n  - weight: Теглото на пакета в грамове.\n  - express: Символ, указващ дали е избрана експресна услуга ('y' за да, 'n' за не).\n\n  Връща:\n  - Общата стойност на пощенските разходи като беззнаков цяло число.\n\n  Примери:\n  - calculate_postage(1200, 'y') връща 17.\n  - calculate_postage(1000, 'n') връща 8.\n  - calculate_postage(1500, 'y') връща 17.\n  - calculate_postage(2000, 'n') връща 16.",
      "zh": "根据包裹的重量和是否选择快递服务计算邮费。\n  邮费计算如下：\n  - 重量最多为1000克，基本费用为8个单位。\n  - 每增加500克或其一部分，增加4个单位的费用。\n  - 如果选择快递服务（用'y'表示），则增加5个单位的费用。\n  - 如果不选择快递服务（用'n'表示），则不增加费用。\n\n  参数:\n  - weight: 包裹的重量，单位为克。\n  - express: 一个字符，表示是否选择快递服务（'y'表示是，'n'表示否）。\n\n  返回:\n  - 总邮费作为无符号整数。\n\n  示例:\n  - calculate_postage(1200, 'y') 返回 17。\n  - calculate_postage(1000, 'n') 返回 8。\n  - calculate_postage(1500, 'y') 返回 17。\n  - calculate_postage(2000, 'n') 返回 16。",
      "fr": "Calcule l'affranchissement en fonction du poids d'un colis et si le service express est choisi.\n  L'affranchissement est calculé comme suit :\n  - Pour un poids allant jusqu'à et y compris 1000 grammes, les frais de base sont de 8 unités.\n  - Pour chaque tranche supplémentaire de 500 grammes ou fraction de celle-ci, des frais supplémentaires de 4 unités sont ajoutés.\n  - Si le service express (indiqué par 'y') est choisi, des frais supplémentaires de 5 unités sont ajoutés.\n  - Si le service express n'est pas choisi (indiqué par 'n'), aucun frais supplémentaire n'est ajouté.\n\n  Arguments:\n  - weight: Le poids du colis en grammes.\n  - express: Un caractère indiquant si le service express est choisi ('y' pour oui, 'n' pour non).\n\n  Returns:\n  - Le coût total de l'affranchissement en tant qu'entier non signé.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "de": "Berechnet das Porto basierend auf dem Gewicht eines Pakets und ob der Expressdienst gewählt wurde.\n  Das Porto wird wie folgt berechnet:\n  - Für ein Gewicht bis einschließlich 1000 Gramm beträgt die Grundgebühr 8 Einheiten.\n  - Für je weitere 500 Gramm oder einen Teil davon wird eine zusätzliche Gebühr von 4 Einheiten hinzugefügt.\n  - Wenn der Expressdienst (angegeben durch 'y') gewählt wird, wird eine zusätzliche Gebühr von 5 Einheiten hinzugefügt.\n  - Wenn der Expressdienst nicht gewählt wird (angegeben durch 'n'), wird keine zusätzliche Gebühr hinzugefügt.\n\n  Argumente:\n  - weight: Das Gewicht des Pakets in Gramm.\n  - express: Ein Zeichen, das angibt, ob der Expressdienst gewählt wurde ('y' für ja, 'n' für nein).\n\n  Rückgabewerte:\n  - Die gesamten Portokosten als vorzeichenlose Ganzzahl.\n\n  Beispiele:\n  - calculate_postage(1200, 'y') gibt 17 zurück.\n  - calculate_postage(1000, 'n') gibt 8 zurück.\n  - calculate_postage(1500, 'y') gibt 17 zurück.\n  - calculate_postage(2000, 'n') gibt 16 zurück.",
      "ha": "Lissafa kuɗin aika bisa nauyin kunshin da kuma ko an zaɓi sabis na gaggawa.\n  Ana lissafin kuɗin aikawa bisa nauyin kunshin da kuma ko an zaɓi sabis na gaggawa. Ana lissafin kuɗin aikawa kamar haka:\n  - Don nauyi har zuwa da kuma ciki har da gram 1000, kuɗin asali yana da raka'a 8.\n  - Don kowane karin gram 500 ko wani ɓangare na shi, ana ƙara kuɗin karin raka'a 4.\n  - Idan an zaɓi sabis na gaggawa (wanda aka nuna da 'y'), ana ƙara kuɗin karin raka'a 5.\n  - Idan ba a zaɓi sabis na gaggawa ba (wanda aka nuna da 'n'), ba a ƙara wani karin kuɗi ba.\n\n  Arguments:\n  - weight: Nauyin kunshin a cikin gram.\n  - express: Wata alama da ke nuna ko an zaɓi sabis na gaggawa ('y' don eh, 'n' don a'a).\n\n  Returns:\n  - Jimillar kuɗin aikawa a matsayin cikakken lamba mara alama.\n\n  Examples:\n  - calculate_postage(1200, 'y') returns 17.\n  - calculate_postage(1000, 'n') returns 8.\n  - calculate_postage(1500, 'y') returns 17.\n  - calculate_postage(2000, 'n') returns 16.",
      "hi": "पैकेज के वजन और क्या एक्सप्रेस सेवा चुनी गई है, के आधार पर डाक शुल्क की गणना करता है।\nडाक शुल्क की गणना इस प्रकार की जाती है:\n- 1000 ग्राम तक और उसके समावेशी वजन के लिए, आधार शुल्क 8 इकाइयाँ है।\n- प्रत्येक अतिरिक्त 500 ग्राम या उसके हिस्से के लिए, अतिरिक्त शुल्क 4 इकाइयाँ जोड़ी जाती हैं।\n- यदि एक्सप्रेस सेवा (जिसे 'y' द्वारा दर्शाया गया है) चुनी जाती है, तो अतिरिक्त शुल्क 5 इकाइयाँ जोड़ी जाती हैं।\n- यदि एक्सप्रेस सेवा नहीं चुनी जाती (जिसे 'n' द्वारा दर्शाया गया है), तो कोई अतिरिक्त शुल्क नहीं जोड़ा जाता।\n\nआर्गुमेंट्स:\n- weight: पैकेज का वजन ग्राम में।\n- express: एक चरित्र जो दर्शाता है कि एक्सप्रेस सेवा चुनी गई है या नहीं ('y' हाँ के लिए, 'n' नहीं के लिए)।\n\nरिटर्न्स:\n- कुल डाक लागत एक असाइन किए गए पूर्णांक के रूप में।\n\nउदाहरण:\n- calculate_postage(1200, 'y') 17 लौटाता है।\n- calculate_postage(1000, 'n') 8 लौटाता है।\n- calculate_postage(1500, 'y') 17 लौटाता है।\n- calculate_postage(2000, 'n') 16 लौटाता है।",
      "hu": "Kiszámítja a postaköltséget a csomag súlya és az expressz szolgáltatás választása alapján.\n  A postaköltség a következőképpen kerül kiszámításra:\n  - 1000 grammig bezárólag az alapdíj 8 egység.\n  - Minden további 500 gramm vagy annak töredéke esetén további 4 egység díj kerül felszámításra.\n  - Ha az expressz szolgáltatás (jelölve 'y'-nal) van választva, további 5 egység díj kerül felszámításra.\n  - Ha az expressz szolgáltatás nincs választva (jelölve 'n'-nel), nem kerül felszámításra további díj.\n\n  Argumentumok:\n  - weight: A csomag súlya grammban.\n  - express: Egy karakter, amely jelzi, hogy az expressz szolgáltatás van-e választva ('y' az igen, 'n' a nem esetén).\n\n  Visszatérési érték:\n  - A teljes postaköltség mint előjelnélküli egész szám.\n\n  Példák:\n  - calculate_postage(1200, 'y') visszatér 17.\n  - calculate_postage(1000, 'n') visszatér 8.\n  - calculate_postage(1500, 'y') visszatér 17.\n  - calculate_postage(2000, 'n') visszatér 16."
    },
    "docstring_bertscore": {
      "sq": "0.9780668360653656",
      "hy": "0.9451237887403483",
      "bn": "0.987315265236731",
      "bg": "0.9688201945674295",
      "zh": "0.9550177666500772",
      "fr": "0.9494130131884158",
      "de": "0.9727916104058411",
      "ha": "0.9662167461632052",
      "hi": "0.9687874205545587",
      "hu": "0.9538698816780765"
    }
  },
  {
    "task_id": "Rust/22",
    "prompt": {
      "en": "/*\n  Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "sq": "/*\n  Llogarit numrin e pacientëve që nuk mund të shërbehen bazuar në stokun e disponueshëm të ilaçeve dhe kërkesat e tyre.\n\n  Argumentet:\n  - total_medicine: Sasia totale e ilaçeve e disponueshme në fillim të ditës.\n  - num_patients: Numri i pacientëve që vijnë për të marrë ilaçe.\n  - patient_requests: Një varg i usize, secili që përfaqëson sasinë e ilaçeve të kërkuar nga një pacient, sipas radhës që ata arrijnë.\n\n  Kthen:\n  - Numrin e pacientëve që nuk mund të shërbehen sepse stoku i ilaçeve është i pamjaftueshëm.\n\n  Shembull:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) kthen 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) kthen 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) kthen 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "hy": "/*\n  Հաշվում է այն հիվանդների քանակը, որոնք չեն կարող սպասարկվել առկա դեղորայքի պաշարների և նրանց պահանջների հիման վրա:\n\n  Փաստարկներ:\n  - total_medicine: Օրվա սկզբում առկա դեղորայքի ընդհանուր քանակը:\n  - num_patients: Հիվանդների քանակը, որոնք գալիս են դեղորայք ստանալու:\n  - patient_requests: usize տիպի զանգված, որը ներկայացնում է յուրաքանչյուր հիվանդի պահանջած դեղորայքի քանակը՝ ըստ նրանց ժամանման կարգի:\n\n  Վերադարձնում է:\n  - Այն հիվանդների քանակը, որոնք չեն կարող սպասարկվել, քանի որ դեղորայքի պաշարը բավարար չէ:\n\n  Օրինակ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) վերադարձնում է 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) վերադարձնում է 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) վերադարձնում է 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "bn": "/*\n  উপলব্ধ ওষুধের মজুদ এবং রোগীদের অনুরোধের ভিত্তিতে কতজন রোগীকে সেবা দেওয়া যাবে না তা গণনা করে।\n\n  আর্গুমেন্ট:\n  - total_medicine: দিনের শুরুতে উপলব্ধ মোট ওষুধের পরিমাণ।\n  - num_patients: ওষুধ নিতে আসা রোগীর সংখ্যা।\n  - patient_requests: একটি usize এর অ্যারে, প্রতিটি রোগী যে পরিমাণ ওষুধ চায় তা তাদের আগমনের ক্রম অনুযায়ী উপস্থাপন করে।\n\n  রিটার্ন:\n  - কতজন রোগীকে সেবা দেওয়া যাবে না কারণ ওষুধের মজুদ অপর্যাপ্ত।\n\n  উদাহরণ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 রিটার্ন করে\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 রিটার্ন করে\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 রিটার্ন করে\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "bg": "/*\n  Изчислява броя на пациентите, които не могат да бъдат обслужени въз основа на наличния запас от лекарства и техните заявки.\n\n  Аргументи:\n  - total_medicine: Общото количество лекарства, налично в началото на деня.\n  - num_patients: Броят на пациентите, които идват да получат лекарства.\n  - patient_requests: Масив от usize, всеки представляващ количеството лекарства, заявено от пациент, в реда на пристигане.\n\n  Връща:\n  - Броят на пациентите, които не могат да бъдат обслужени, защото запасът от лекарства е недостатъчен.\n\n  Пример:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) връща 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) връща 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) връща 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "zh": "/*\n  计算由于药品库存不足而无法服务的患者数量。\n\n  参数:\n  - total_medicine: 一天开始时可用的药品总量。\n  - num_patients: 前来领取药品的患者数量。\n  - patient_requests: 一个usize数组，每个元素表示患者到达时请求的药品数量。\n\n  返回:\n  - 因药品库存不足而无法服务的患者数量。\n\n  示例:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 返回 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 返回 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 返回 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "fr": "/*\n  Calcule le nombre de patients qui ne peuvent pas être servis en fonction du stock de médicaments disponible et de leurs demandes.\n\n  Arguments:\n  - total_medicine: La quantité totale de médicaments disponible au début de la journée.\n  - num_patients: Le nombre de patients venant chercher des médicaments.\n  - patient_requests: Un tableau de usize, chacun représentant la quantité de médicaments demandée par un patient, dans l'ordre de leur arrivée.\n\n  Retourne:\n  - Le nombre de patients qui ne peuvent pas être servis parce que le stock de médicaments est insuffisant.\n\n  Exemple:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) retourne 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) retourne 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) retourne 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "de": "/*\n  Berechnet die Anzahl der Patienten, die nicht bedient werden können, basierend auf dem verfügbaren Medikamentenbestand und ihren Anfragen.\n\n  Argumente:\n  - total_medicine: Die Gesamtmenge an verfügbaren Medikamenten zu Beginn des Tages.\n  - num_patients: Die Anzahl der Patienten, die kommen, um Medikamente zu erhalten.\n  - patient_requests: Ein Array von usize, das die Menge an Medikamenten darstellt, die von einem Patienten in der Reihenfolge ihrer Ankunft angefordert wird.\n\n  Rückgabewert:\n  - Die Anzahl der Patienten, die nicht bedient werden können, weil der Medikamentenbestand unzureichend ist.\n\n  Beispiel:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) gibt 2 zurück\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) gibt 1 zurück\n  - count_unserved_patients(10, 3, &[5, 10, 5]) gibt 1 zurück\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "ha": "/*\n  Lissafa yawan marasa lafiya da ba za a iya yi wa hidima ba bisa ga adadin magungunan da ake da su da kuma bukatunsu.\n\n  Huɗodi:\n  - total_medicine: Jimillar adadin magunguna da ake da su a farkon rana.\n  - num_patients: Yawan marasa lafiya da ke zuwa don samun magani.\n  - patient_requests: Jeri na usize, kowanne yana wakiltar adadin magunguna da marasa lafiya ke bukata, a cikin tsarin isowarsu.\n\n  Mayarwa:\n  - Yawan marasa lafiya da ba za a iya yi wa hidima ba saboda rashin isasshen adadin magunguna.\n\n  Misali:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize",
      "hi": "/*\n  उपलब्ध दवा स्टॉक और उनकी मांगों के आधार पर उन मरीजों की संख्या की गणना करता है जिन्हें सेवा नहीं दी जा सकती।\n\n  तर्क:\n  - total_medicine: दिन की शुरुआत में उपलब्ध दवा की कुल मात्रा।\n  - num_patients: दवा लेने आने वाले मरीजों की संख्या।\n  - patient_requests: usize की एक array, प्रत्येक मरीज द्वारा मांगी गई दवा की मात्रा को दर्शाती है, जिस क्रम में वे आते हैं।\n\n  लौटाता है:\n  - उन मरीजों की संख्या जिन्हें सेवा नहीं दी जा सकती क्योंकि दवा का स्टॉक अपर्याप्त है।\n\n  उदाहरण:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 लौटाता है\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 लौटाता है\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 लौटाता है\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize ",
      "hu": "/*\n  Kiszámítja azon betegek számát, akiket nem lehet kiszolgálni a rendelkezésre álló gyógyszerkészlet és a kéréseik alapján.\n\n  Argumentumok:\n  - total_medicine: A nap elején rendelkezésre álló gyógyszer teljes mennyisége.\n  - num_patients: A betegek száma, akik gyógyszerért jönnek.\n  - patient_requests: Egy usize tömb, amelynek minden eleme egy beteg által kért gyógyszermennyiséget képvisel, az érkezési sorrendjükben.\n\n  Visszatér:\n  - Azon betegek száma, akiket nem lehet kiszolgálni, mert a gyógyszerkészlet nem elegendő.\n\n  Példa:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) visszatér 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) visszatér 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) visszatér 1\n*/\n\nfn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9908179133759002",
      "hy": "0.9828069514783822",
      "bn": "0.9630885162922868",
      "bg": "0.9870693608250098",
      "zh": "0.9609375478960599",
      "fr": "0.9862805995819203",
      "de": "0.9811678535740822",
      "ha": "0.9597900601848214",
      "hi": "0.9804311334908239",
      "hu": "0.986056941772875"
    },
    "canonical_solution": "{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}",
    "instruction": {
      "en": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nՏրամադրել կարճ բնութագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nরাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nFournir une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize\n{\n    let mut medicine_left = total_medicine;\n    let mut unserved_patients = 0;\n\n    for &request in patient_requests.iter() {\n        if medicine_left >= request {\n            medicine_left -= request;\n        } else {\n            unserved_patients += 1;\n        }\n    }\n\n    unserved_patients\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8870448612168901",
      "bn": "0.8851102013056104",
      "bg": "0.8316696904400789",
      "zh": "0.8871262996731144",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9536426485221726",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]), 2);\n        assert_eq!(count_unserved_patients(50, 4, &[10, 15, 10, 20]), 1);\n        assert_eq!(count_unserved_patients(10, 3, &[5, 10, 5]), 1);\n        assert_eq!(count_unserved_patients(20, 5, &[4, 5, 7, 3, 2]), 1);\n        \n    }\n    \n\n}",
    "entry_point": "count_unserved_patients",
    "signature": "fn count_unserved_patients(total_medicine: usize, num_patients: usize, patient_requests: &[usize]) -> usize",
    "docstring": {
      "en": "Calculates the number of patients who cannot be served based on the available medicine stock and their requests.\n\n  Arguments:\n  - total_medicine: The total amount of medicine available at the beginning of the day.\n  - num_patients: The number of patients coming to get medicine.\n  - patient_requests: An array of usize, each representing the amount of medicine requested by a patient, in the order they arrive.\n\n  Returns:\n  - The number of patients who cannot be served because the medicine stock is insufficient.\n\n  Example:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "sq": "Llogarit numrin e pacientëve që nuk mund të shërbehen bazuar në stokun e disponueshëm të ilaçeve dhe kërkesat e tyre.\n\n  Argumentet:\n  - total_medicine: Sasia totale e ilaçeve në dispozicion në fillim të ditës.\n  - num_patients: Numri i pacientëve që vijnë për të marrë ilaçe.\n  - patient_requests: Një varg i usize, secili që përfaqëson sasinë e ilaçeve të kërkuara nga një pacient, sipas renditjes së mbërritjes së tyre.\n\n  Kthen:\n  - Numri i pacientëve që nuk mund të shërbehen sepse stoku i ilaçeve është i pamjaftueshëm.\n\n  Shembull:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) kthen 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) kthen 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) kthen 1",
      "hy": "Հաշվում է այն հիվանդների քանակը, որոնք չեն կարող սպասարկվել առկա դեղամիջոցների պաշարների և նրանց պահանջների հիման վրա։\n\n  Արգումենտներ:\n  - total_medicine: Օրվա սկզբում առկա դեղամիջոցների ընդհանուր քանակը։\n  - num_patients: Դեղամիջոց ստանալու համար եկող հիվանդների քանակը։\n  - patient_requests: usize տիպի զանգված, որը ներկայացնում է յուրաքանչյուր հիվանդի պահանջած դեղամիջոցի քանակը՝ ըստ նրանց ժամանման կարգի։\n\n  Վերադարձնում է:\n  - Այն հիվանդների քանակը, որոնք չեն կարող սպասարկվել, քանի որ դեղամիջոցների պաշարը բավարար չէ։\n\n  Օրինակ:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) վերադարձնում է 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) վերադարձնում է 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) վերադարձնում է 1",
      "bn": "রোগীদের সংখ্যা গণনা করে যারা উপলব্ধ ওষুধের মজুদ এবং তাদের অনুরোধের ভিত্তিতে সেবা পেতে পারে না।\n\nআর্গুমেন্টস:\n- total_medicine: দিনের শুরুতে উপলব্ধ মোট ওষুধের পরিমাণ।\n- num_patients: ওষুধ নিতে আসা রোগীদের সংখ্যা।\n- patient_requests: একটি usize এর অ্যারে, প্রতিটি রোগীর অনুরোধ করা ওষুধের পরিমাণ উপস্থাপন করে, তারা আসার ক্রম অনুযায়ী।\n\nরিটার্নস:\n- রোগীদের সংখ্যা যারা সেবা পেতে পারে না কারণ ওষুধের মজুদ অপর্যাপ্ত।\n\nউদাহরণ:\n- count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) রিটার্ন করে 2\n- count_unserved_patients(50, 4, &[10, 15, 10, 20]) রিটার্ন করে 1\n- count_unserved_patients(10, 3, &[5, 10, 5]) রিটার্ন করে 1",
      "bg": "Изчислява броя на пациентите, които не могат да бъдат обслужени въз основа на наличния запас от лекарства и техните заявки.\n\nАргументи:\n- total_medicine: Общото количество лекарства, налично в началото на деня.\n- num_patients: Броят на пациентите, които идват да получат лекарства.\n- patient_requests: Масив от usize, всеки представляващ количеството лекарства, заявено от пациент, в реда на пристигането им.\n\nВръща:\n- Броят на пациентите, които не могат да бъдат обслужени, защото запасът от лекарства е недостатъчен.\n\nПример:\n- count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) връща 2\n- count_unserved_patients(50, 4, &[10, 15, 10, 20]) връща 1\n- count_unserved_patients(10, 3, &[5, 10, 5]) връща 1",
      "zh": "计算基于可用药品库存和患者请求无法服务的患者数量。\n\n参数：\n- total_medicine: 一天开始时可用的药品总量。\n- num_patients: 前来领取药品的患者数量。\n- patient_requests: 一个usize数组，每个元素代表患者请求的药品数量，按照他们到达的顺序排列。\n\n返回：\n- 因药品库存不足而无法服务的患者数量。\n\n示例：\n- count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 返回 2\n- count_unserved_patients(50, 4, &[10, 15, 10, 20]) 返回 1\n- count_unserved_patients(10, 3, &[5, 10, 5]) 返回 1",
      "fr": "Calcule le nombre de patients qui ne peuvent pas être servis en fonction du stock de médicaments disponible et de leurs demandes.\n\n  Arguments:\n  - total_medicine: La quantité totale de médicaments disponible au début de la journée.\n  - num_patients: Le nombre de patients venant chercher des médicaments.\n  - patient_requests: Un tableau de usize, chacun représentant la quantité de médicaments demandée par un patient, dans l'ordre de leur arrivée.\n\n  Retourne:\n  - Le nombre de patients qui ne peuvent pas être servis parce que le stock de médicaments est insuffisant.\n\n  Exemple:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) retourne 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) retourne 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) retourne 1",
      "de": "Berechnet die Anzahl der Patienten, die aufgrund des verfügbaren Medikamentenbestands und ihrer Anfragen nicht bedient werden können.\n\n  Argumente:\n  - total_medicine: Die Gesamtmenge an verfügbaren Medikamenten zu Beginn des Tages.\n  - num_patients: Die Anzahl der Patienten, die kommen, um Medikamente zu erhalten.\n  - patient_requests: Ein Array von usize, das jeweils die Menge an Medikamenten darstellt, die von einem Patienten in der Reihenfolge seiner Ankunft angefordert wird.\n\n  Rückgabewert:\n  - Die Anzahl der Patienten, die nicht bedient werden können, weil der Medikamentenbestand nicht ausreicht.\n\n  Beispiel:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) gibt 2 zurück\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) gibt 1 zurück\n  - count_unserved_patients(10, 3, &[5, 10, 5]) gibt 1 zurück",
      "ha": "Lissafa adadin marasa lafiya waɗanda ba za a iya yi wa hidima ba bisa ga adadin magungunan da ake da su da buƙatunsu.\n\n  Huɗɗa:\n  - total_medicine: Jimillar adadin magani da ake da shi a farkon rana.\n  - num_patients: Yawan marasa lafiya da ke zuwa don samun magani.\n  - patient_requests: Jeri na usize, kowanne yana wakiltar adadin magani da mara lafiya ke nema, a cikin tsari da suka iso.\n\n  Komawa:\n  - Yawan marasa lafiya da ba za a iya bauta musu ba saboda adadin magani bai isa ba.\n\n  Misali:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) returns 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) returns 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) returns 1",
      "hi": "मरीजों की संख्या की गणना करता है जिन्हें उपलब्ध दवा स्टॉक और उनकी मांगों के आधार पर सेवा नहीं दी जा सकती।\n\n  तर्क:\n  - total_medicine: दिन की शुरुआत में उपलब्ध कुल दवा की मात्रा।\n  - num_patients: दवा लेने आने वाले मरीजों की संख्या।\n  - patient_requests: usize का एक array, प्रत्येक मरीज द्वारा मांगी गई दवा की मात्रा को दर्शाता है, जिस क्रम में वे आते हैं।\n\n  वापसी:\n  - उन मरीजों की संख्या जिन्हें सेवा नहीं दी जा सकती क्योंकि दवा का स्टॉक अपर्याप्त है।\n\n  उदाहरण:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) 2 लौटाता है\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) 1 लौटाता है\n  - count_unserved_patients(10, 3, &[5, 10, 5]) 1 लौटाता है",
      "hu": "Számítja azon betegek számát, akiket nem lehet kiszolgálni a rendelkezésre álló gyógyszerkészlet és az ő igényeik alapján.\n\n  Argumentumok:\n  - total_medicine: A nap elején rendelkezésre álló teljes gyógyszermennyiség.\n  - num_patients: Azoknak a betegeknek a száma, akik gyógyszert szeretnének kapni.\n  - patient_requests: Egy usize tömb, amely minden egyes beteg által igényelt gyógyszermennyiséget képvisel, az érkezésük sorrendjében.\n\n  Visszatér:\n  - Azoknak a betegeknek a száma, akiket nem lehet kiszolgálni, mert a gyógyszerkészlet nem elegendő.\n\n  Példa:\n  - count_unserved_patients(30, 6, &[10, 5, 20, 6, 7, 8]) visszatér 2\n  - count_unserved_patients(50, 4, &[10, 15, 10, 20]) visszatér 1\n  - count_unserved_patients(10, 3, &[5, 10, 5]) visszatér 1"
    },
    "docstring_bertscore": {
      "sq": "0.979970708267585",
      "hy": "0.9754808671346724",
      "bn": "0.9696357709119587",
      "bg": "0.9755958741252916",
      "zh": "0.9643947096779721",
      "fr": "0.9849040910413485",
      "de": "0.9804915171266585",
      "ha": "0.9810949562242425",
      "hi": "0.9704684294692569",
      "hu": "0.9816119911060762"
    }
  },
  {
    "task_id": "Rust/23",
    "prompt": {
      "en": "/*\n  Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "sq": "/*\n  Përcakton nëse një sekuencë është një \"Jolly Jumper\". Një sekuencë konsiderohet \"Jolly Jumper\" nëse diferencat absolute midis elementeve të njëpasnjëshme, kur renditen, formojnë një sekuencë numrash të njëpasnjëshëm duke filluar nga 1. Për shembull, një sekuencë e [3, 1, 4, 2] është një Jolly Jumper sepse diferencat absolute janë 2, 3, 2, duke formuar një sekuencë të njëpasnjëshme 1, 2, 3. Një sekuencë me një element të vetëm është gjithmonë një Jolly Jumper.\n\n  Argumentet:\n  - sequence: Një pjesë e numrave të plotë, që përfaqëson sekuencën.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca është një Jolly Jumper.\n\n  Shembuj:\n  - is_jolly_jumper(&[1, 4, 2, 3]) kthen true.\n  - is_jolly_jumper(&[1, 3]) kthen false.\n  - is_jolly_jumper(&[5]) kthen true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "hy": "/*\n  Որոշում է, արդյոք հաջորդականությունը \"Jolly Jumper\" է։ Հաջորդականությունը համարվում է \"Jolly Jumper\", եթե հաջորդական տարրերի միջև բացարձակ տարբերությունները, երբ դասավորված են, կազմում են հաջորդական թվերի հաջորդականություն սկսած 1-ից։ Օրինակ, [3, 1, 4, 2] հաջորդականությունը Jolly Jumper է, քանի որ բացարձակ տարբերությունները 2, 3, 2 են, որոնք կազմում են հաջորդական հաջորդականություն 1, 2, 3։ Միայն մեկ տարր ունեցող հաջորդականությունը միշտ Jolly Jumper է։\n\n  Փոփոխականներ:\n  - sequence: Թվերի հաջորդականություն, որը ներկայացնում է հաջորդականությունը։\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս, արդյոք հաջորդականությունը Jolly Jumper է։\n\n  Օրինակներ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) վերադարձնում է true.\n  - is_jolly_jumper(&[1, 3]) վերադարձնում է false.\n  - is_jolly_jumper(&[5]) վերադարձնում է true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "bn": "/*\n  একটি ক্রম \"Jolly Jumper\" কিনা তা নির্ধারণ করে। একটি ক্রমকে \"Jolly Jumper\" বিবেচনা করা হয় যদি পরপর উপাদানগুলির মধ্যে পার্থক্যের মানগুলি, যখন সাজানো হয়, 1 থেকে শুরু করে ধারাবাহিক সংখ্যার একটি ক্রম গঠন করে। উদাহরণস্বরূপ, [3, 1, 4, 2] এর একটি ক্রম একটি Jolly Jumper কারণ পার্থক্যের মানগুলি 2, 3, 2, যা একটি ধারাবাহিক ক্রম 1, 2, 3 গঠন করে। একটি একক উপাদানযুক্ত ক্রম সর্বদা একটি Jolly Jumper হয়।\n\n  আর্গুমেন্টসমূহ:\n  - sequence: পূর্ণসংখ্যার একটি স্লাইস, যা ক্রমকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি বুলিয়ান মান যা নির্দেশ করে যে ক্রমটি একটি Jolly Jumper কিনা।\n\n  উদাহরণসমূহ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true রিটার্ন করে।\n  - is_jolly_jumper(&[1, 3]) false রিটার্ন করে।\n  - is_jolly_jumper(&[5]) true রিটার্ন করে।\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "bg": "/*\n  Определя дали една последователност е \"Jolly Jumper\". Последователност се счита за \"Jolly Jumper\", ако абсолютните разлики между последователните елементи, когато са сортирани, образуват последователност от поредни числа, започващи от 1. Например, последователност от [3, 1, 4, 2] е Jolly Jumper, защото абсолютните разлики са 2, 3, 2, образувайки поредна последователност 1, 2, 3. Последователност с един елемент винаги е Jolly Jumper.\n\n  Аргументи:\n  - sequence: Срез от цели числа, представляващи последователността.\n\n  Връща:\n  - Булева стойност, указваща дали последователността е Jolly Jumper.\n\n  Примери:\n  - is_jolly_jumper(&[1, 4, 2, 3]) връща true.\n  - is_jolly_jumper(&[1, 3]) връща false.\n  - is_jolly_jumper(&[5]) връща true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "zh": "/*\n  判断一个序列是否为“Jolly Jumper”。如果连续元素之间的绝对差在排序后形成从1开始的连续数字序列，则该序列被认为是“Jolly Jumper”。例如，[3, 1, 4, 2]的序列是一个Jolly Jumper，因为绝对差是2, 3, 2，形成了连续的序列1, 2, 3。单个元素的序列总是一个Jolly Jumper。\n\n  参数:\n  - sequence: 整数切片，表示序列。\n\n  返回:\n  - 一个布尔值，指示序列是否为Jolly Jumper。\n\n  示例:\n  - is_jolly_jumper(&[1, 4, 2, 3]) 返回 true.\n  - is_jolly_jumper(&[1, 3]) 返回 false.\n  - is_jolly_jumper(&[5]) 返回 true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "fr": "/*\n  Détermine si une séquence est un \"Jolly Jumper\". Une séquence est considérée comme un \"Jolly Jumper\" si les différences absolues entre les éléments successifs, une fois triées, forment une séquence de nombres consécutifs commençant par 1. Par exemple, une séquence de [3, 1, 4, 2] est un Jolly Jumper car les différences absolues sont 2, 3, 2, formant une séquence consécutive 1, 2, 3. Une séquence avec un seul élément est toujours un Jolly Jumper.\n\n  Arguments :\n  - sequence : Une tranche d'entiers, représentant la séquence.\n\n  Renvoie :\n  - Une valeur booléenne indiquant si la séquence est un Jolly Jumper.\n\n  Exemples :\n  - is_jolly_jumper(&[1, 4, 2, 3]) renvoie true.\n  - is_jolly_jumper(&[1, 3]) renvoie false.\n  - is_jolly_jumper(&[5]) renvoie true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "de": "/*\n  Bestimmt, ob eine Sequenz ein \"Jolly Jumper\" ist. Eine Sequenz wird als \"Jolly Jumper\" betrachtet, wenn die absoluten Differenzen zwischen aufeinanderfolgenden Elementen, wenn sortiert, eine Sequenz von aufeinanderfolgenden Zahlen bilden, beginnend mit 1. Zum Beispiel ist eine Sequenz von [3, 1, 4, 2] ein Jolly Jumper, weil die absoluten Differenzen 2, 3, 2 sind, was eine aufeinanderfolgende Sequenz 1, 2, 3 bildet. Eine Sequenz mit einem einzigen Element ist immer ein Jolly Jumper.\n\n  Argumente:\n  - sequence: Ein Slice von ganzen Zahlen, das die Sequenz darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Sequenz ein Jolly Jumper ist.\n\n  Beispiele:\n  - is_jolly_jumper(&[1, 4, 2, 3]) gibt true zurück.\n  - is_jolly_jumper(&[1, 3]) gibt false zurück.\n  - is_jolly_jumper(&[5]) gibt true zurück.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "ha": "/*\n  Yana tantancewa idan jerin lambobi \"Jolly Jumper\" ne. Ana ɗaukar jerin lambobi a matsayin \"Jolly Jumper\" idan bambance-bambancen ƙima tsakanin abubuwa masu zuwa, idan an jera su, suna samar da jerin lambobi masu jere daga 1. Alal misali, jerin lambobi na [3, 1, 4, 2] Jolly Jumper ne saboda bambance-bambancen ƙima su ne 2, 3, 2, suna samar da jerin lambobi masu jere 1, 2, 3. Jerin lambobi da ke da abu guda koyaushe Jolly Jumper ne.\n\n  Huɗa:\n  - sequence: Yanke na lambobi, yana wakiltar jerin lambobi.\n\n  Komawa:\n  - Ƙimar boolean da ke nuna idan jerin lambobi Jolly Jumper ne.\n\n  Misalai:\n  - is_jolly_jumper(&[1, 4, 2, 3]) yana dawowa da true.\n  - is_jolly_jumper(&[1, 3]) yana dawowa da false.\n  - is_jolly_jumper(&[5]) yana dawowa da true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "hi": "/*\n  यह निर्धारित करता है कि कोई अनुक्रम \"Jolly Jumper\" है या नहीं। यदि क्रमिक तत्वों के बीच के परिपूर्ण अंतर, जब क्रमबद्ध होते हैं, तो 1 से शुरू होने वाले क्रमिक संख्याओं का अनुक्रम बनाते हैं, तो एक अनुक्रम को \"Jolly Jumper\" माना जाता है। उदाहरण के लिए, [3, 1, 4, 2] का अनुक्रम एक Jolly Jumper है क्योंकि परिपूर्ण अंतर 2, 3, 2 हैं, जो एक क्रमिक अनुक्रम 1, 2, 3 बनाते हैं। एकल तत्व वाला अनुक्रम हमेशा एक Jolly Jumper होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों का एक स्लाइस, जो अनुक्रम का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक boolean मान जो यह इंगित करता है कि अनुक्रम एक Jolly Jumper है या नहीं।\n\n  उदाहरण:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true लौटाता है।\n  - is_jolly_jumper(&[1, 3]) false लौटाता है।\n  - is_jolly_jumper(&[5]) true लौटाता है।\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool ",
      "hu": "/*\n  Meghatározza, hogy egy sorozat \"Jolly Jumper\"-e. Egy sorozat akkor tekinthető \"Jolly Jumper\"-nek, ha az egymást követő elemek közötti abszolút különbségek, ha sorba rendezzük őket, egy egymást követő számokból álló sorozatot alkotnak, kezdve 1-től. Például a [3, 1, 4, 2] sorozat Jolly Jumper, mert az abszolút különbségek 2, 3, 2, amelyek egy egymást követő sorozatot alkotnak: 1, 2, 3. Egy egyetlen elemet tartalmazó sorozat mindig Jolly Jumper.\n\n  Argumentumok:\n  - sequence: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatér:\n  - Egy logikai érték, amely jelzi, hogy a sorozat Jolly Jumper-e.\n\n  Példák:\n  - is_jolly_jumper(&[1, 4, 2, 3]) visszaadja true.\n  - is_jolly_jumper(&[1, 3]) visszaadja false.\n  - is_jolly_jumper(&[5]) visszaadja true.\n*/\n\n\nfn is_jolly_jumper(sequence: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "sq": "0.997033852520006",
      "hy": "0.975279455928303",
      "bn": "0.9867241412227712",
      "bg": "0.9926651759195246",
      "zh": "0.970718902379742",
      "fr": "0.9975469147942191",
      "de": "0.9894334596200871",
      "ha": "0.9819899847211857",
      "hi": "0.9782759938565954",
      "hu": "0.9881481224244103"
    },
    "canonical_solution": "{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}",
    "instruction": {
      "en": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nՏվեք կարճ բնութագիր (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nনিচের রাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\n请用不超过500个字符的中文，提供一个简洁的自然语言描述（文档字符串）来说明这段Rust代码。",
      "fr": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn is_jolly_jumper(sequence: &[i32]) -> bool\n{\n    let n = sequence.len();\n    // A sequence with a single element or empty is always a Jolly Jumper\n    if n <= 1 {\n        return true;\n    }\n\n    // Calculate absolute differences\n    let mut diffs: Vec<i32> = Vec::new();\n    for i in 0..n-1 {\n        diffs.push((sequence[i] - sequence[i + 1]).abs());\n    }\n\n    // Sort the differences\n    diffs.sort_unstable();\n\n    // Check if differences are consecutive numbers starting from 1\n    for i in 1..n {\n        if diffs[i - 1] != i as i32 {\n            return false;\n        }\n    }\n    true\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.8870448612168901",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8811070046062331",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9230891246810051",
      "hi": "0.9047321021265228",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_jolly_jumper(&[1, 4, 2, 3]), true);\n        assert_eq!(is_jolly_jumper(&[1, 3]), false);\n        assert_eq!(is_jolly_jumper(&[5]), true);\n        assert_eq!(is_jolly_jumper(&[10, 7, 8, 9]), false);\n    }\n    \n\n}",
    "entry_point": "is_jolly_jumper",
    "signature": "fn is_jolly_jumper(sequence: &[i32]) -> bool",
    "docstring": {
      "en": "Determines if a sequence is a \"Jolly Jumper\". A sequence is considered a \"Jolly Jumper\" if the absolute differences between successive elements, when sorted, form a sequence of consecutive numbers starting from 1. For example, a sequence of [3, 1, 4, 2] is a Jolly Jumper because the absolute differences are 2, 3, 2, forming a consecutive sequence 1, 2, 3. A sequence with a single element is always a Jolly Jumper.\n\n  Arguments:\n  - sequence: A slice of integers, representing the sequence.\n\n  Returns:\n  - A boolean value indicating whether the sequence is a Jolly Jumper.\n\n  Examples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) returns true.\n  - is_jolly_jumper(&[1, 3]) returns false.\n  - is_jolly_jumper(&[5]) returns true.",
      "sq": "Përcakton nëse një sekuencë është një \"Jolly Jumper\". Një sekuencë konsiderohet \"Jolly Jumper\" nëse diferencat absolute midis elementeve të njëpasnjëshme, kur renditen, formojnë një sekuencë numrash të njëpasnjëshëm duke filluar nga 1. Për shembull, një sekuencë e [3, 1, 4, 2] është një Jolly Jumper sepse diferencat absolute janë 2, 3, 2, duke formuar një sekuencë të njëpasnjëshme 1, 2, 3. Një sekuencë me një element të vetëm është gjithmonë një Jolly Jumper.\n\n  Argumentet:\n  - sequence: Një pjesë e numrave të plotë, që përfaqëson sekuencën.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca është një Jolly Jumper.\n\n  Shembuj:\n  - is_jolly_jumper(&[1, 4, 2, 3]) kthen true.\n  - is_jolly_jumper(&[1, 3]) kthen false.\n  - is_jolly_jumper(&[5]) kthen true.",
      "hy": "Որոշում է՝ արդյոք հաջորդականությունը \"Jolly Jumper\" է: Հաջորդականությունը համարվում է \"Jolly Jumper\", եթե հաջորդական տարրերի միջև բացարձակ տարբերությունները, երբ դասավորված են, կազմում են հաջորդական թվերի հաջորդականություն սկսած 1-ից: Օրինակ, [3, 1, 4, 2] հաջորդականությունը Jolly Jumper է, քանի որ բացարձակ տարբերությունները 2, 3, 2 են, որոնք կազմում են հաջորդական հաջորդականություն 1, 2, 3: Միայն մեկ տարր ունեցող հաջորդականությունը միշտ Jolly Jumper է:\n\n  Արգումենտներ:\n  - sequence: Թվերի հաջորդականություն, որը ներկայացնում է հաջորդականությունը:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս՝ արդյոք հաջորդականությունը Jolly Jumper է:\n\n  Օրինակներ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) վերադարձնում է true:\n  - is_jolly_jumper(&[1, 3]) վերադարձնում է false:\n  - is_jolly_jumper(&[5]) վերադարձնում է true:",
      "bn": "নির্ধারণ করে যদি একটি সিকোয়েন্স \"Jolly Jumper\" হয়। একটি সিকোয়েন্সকে \"Jolly Jumper\" বিবেচনা করা হয় যদি ধারাবাহিক উপাদানগুলির মধ্যে পার্থক্যের মান, যখন সাজানো হয়, ১ থেকে শুরু করে ধারাবাহিক সংখ্যার একটি সিকোয়েন্স গঠন করে। উদাহরণস্বরূপ, [3, 1, 4, 2] এর একটি সিকোয়েন্স একটি Jolly Jumper কারণ মানের পার্থক্যগুলি 2, 3, 2, যা একটি ধারাবাহিক সিকোয়েন্স 1, 2, 3 গঠন করে। একটি একক উপাদান সহ সিকোয়েন্স সর্বদা একটি Jolly Jumper হয়।\n\n  আর্গুমেন্টস:\n  - sequence: পূর্ণসংখ্যার একটি স্লাইস, যা সিকোয়েন্সকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি বুলিয়ান মান যা নির্দেশ করে যে সিকোয়েন্সটি একটি Jolly Jumper কিনা।\n\n  উদাহরণ:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true রিটার্ন করে।\n  - is_jolly_jumper(&[1, 3]) false রিটার্ন করে।\n  - is_jolly_jumper(&[5]) true রিটার্ন করে।",
      "bg": "Определя дали дадена последователност е \"Jolly Jumper\". Последователност се счита за \"Jolly Jumper\", ако абсолютните разлики между последователните елементи, когато са сортирани, образуват последователност от поредни числа, започващи от 1. Например, последователност от [3, 1, 4, 2] е Jolly Jumper, защото абсолютните разлики са 2, 3, 2, образувайки поредна последователност 1, 2, 3. Последователност с един елемент винаги е Jolly Jumper.\n\n  Аргументи:\n  - sequence: Списък от цели числа, представляващи последователността.\n\n  Връща:\n  - Булева стойност, указваща дали последователността е Jolly Jumper.\n\n  Примери:\n  - is_jolly_jumper(&[1, 4, 2, 3]) връща true.\n  - is_jolly_jumper(&[1, 3]) връща false.\n  - is_jolly_jumper(&[5]) връща true.",
      "zh": "确定一个序列是否为“Jolly Jumper”。如果一个序列中相邻元素之间的绝对差值在排序后形成从1开始的连续数字序列，则该序列被认为是“Jolly Jumper”。例如，[3, 1, 4, 2] 的序列是一个 Jolly Jumper，因为绝对差值是 2, 3, 2，形成了连续序列 1, 2, 3。单个元素的序列总是 Jolly Jumper。\n\n  参数:\n  - sequence: 整数切片，表示序列。\n\n  返回:\n  - 一个布尔值，指示该序列是否为 Jolly Jumper。\n\n  示例:\n  - is_jolly_jumper(&[1, 4, 2, 3]) 返回 true。\n  - is_jolly_jumper(&[1, 3]) 返回 false。\n  - is_jolly_jumper(&[5]) 返回 true。",
      "fr": "Détermine si une séquence est un \"Jolly Jumper\". Une séquence est considérée comme un \"Jolly Jumper\" si les différences absolues entre les éléments successifs, une fois triées, forment une séquence de nombres consécutifs commençant à partir de 1. Par exemple, une séquence de [3, 1, 4, 2] est un Jolly Jumper car les différences absolues sont 2, 3, 2, formant une séquence consécutive 1, 2, 3. Une séquence avec un seul élément est toujours un Jolly Jumper.\n\n  Arguments:\n  - sequence: Une tranche d'entiers, représentant la séquence.\n\n  Retourne:\n  - Une valeur booléenne indiquant si la séquence est un Jolly Jumper.\n\n  Exemples:\n  - is_jolly_jumper(&[1, 4, 2, 3]) retourne true.\n  - is_jolly_jumper(&[1, 3]) retourne false.\n  - is_jolly_jumper(&[5]) retourne true.",
      "de": "Bestimmt, ob eine Sequenz ein \"Jolly Jumper\" ist. Eine Sequenz wird als \"Jolly Jumper\" betrachtet, wenn die absoluten Differenzen zwischen aufeinanderfolgenden Elementen, wenn sie sortiert sind, eine Sequenz von aufeinanderfolgenden Zahlen bilden, die bei 1 beginnt. Zum Beispiel ist eine Sequenz von [3, 1, 4, 2] ein Jolly Jumper, weil die absoluten Differenzen 2, 3, 2 sind und eine aufeinanderfolgende Sequenz 1, 2, 3 bilden. Eine Sequenz mit einem einzigen Element ist immer ein Jolly Jumper.\n\n  Argumente:\n  - sequence: Ein Ausschnitt von ganzen Zahlen, der die Sequenz darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Sequenz ein Jolly Jumper ist.\n\n  Beispiele:\n  - is_jolly_jumper(&[1, 4, 2, 3]) gibt true zurück.\n  - is_jolly_jumper(&[1, 3]) gibt false zurück.\n  - is_jolly_jumper(&[5]) gibt true zurück.",
      "ha": "Yana tantancewa idan jerin lambobi \"Jolly Jumper\". Ana ɗaukar jerin lambobi a matsayin \"Jolly Jumper\" idan bambance-bambancen ƙima tsakanin abubuwan da ke jere, idan an tsara su, suna samar da jerin lambobi masu jere daga 1. Alal misali, jerin lambobi na [3, 1, 4, 2] yana da Jolly Jumper saboda bambance-bambancen ƙima sune 2, 3, 2, suna samar da jerin lambobi masu jere 1, 2, 3. Jerin lambobi da ke da abu guda koyaushe yana da Jolly Jumper.\n\n  Huɗɗa:\n  - sequence: Wani yanki na lambobin tsaka-tsaki, yana wakiltar jerin.\n\n  Komawa:\n  - Wata ƙima ta boolean da ke nuna ko jerin yana da Jolly Jumper.\n\n  Misalai:\n  - is_jolly_jumper(&[1, 4, 2, 3]) yana dawowa da true.\n  - is_jolly_jumper(&[1, 3]) yana dawowa da false.\n  - is_jolly_jumper(&[5]) yana dawowa da true.",
      "hi": "निर्धारित करता है कि क्या एक अनुक्रम \"Jolly Jumper\" है। एक अनुक्रम को \"Jolly Jumper\" माना जाता है यदि क्रमिक तत्वों के बीच के परम अंतर, जब क्रमबद्ध होते हैं, तो 1 से शुरू होने वाले क्रमिक संख्याओं का अनुक्रम बनाते हैं। उदाहरण के लिए, [3, 1, 4, 2] का अनुक्रम एक Jolly Jumper है क्योंकि परम अंतर 2, 3, 2 हैं, जो एक क्रमिक अनुक्रम 1, 2, 3 बनाते हैं। एकल तत्व वाला अनुक्रम हमेशा एक Jolly Jumper होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों का एक स्लाइस, जो अनुक्रम का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक बूलियन मान जो इंगित करता है कि अनुक्रम एक Jolly Jumper है या नहीं।\n\n  उदाहरण:\n  - is_jolly_jumper(&[1, 4, 2, 3]) true लौटाता है।\n  - is_jolly_jumper(&[1, 3]) false लौटाता है।\n  - is_jolly_jumper(&[5]) true लौटाता है।",
      "hu": "Meghatározza, hogy egy sorozat \"Jolly Jumper\"-e. Egy sorozat akkor tekinthető \"Jolly Jumper\"-nek, ha az egymást követő elemek közötti abszolút különbségek, amikor sorba rendezzük őket, egy egymást követő számokból álló sorozatot alkotnak, amely 1-től kezdődik. Például a [3, 1, 4, 2] sorozat egy Jolly Jumper, mert az abszolút különbségek 2, 3, 2, amelyek egy egymást követő sorozatot alkotnak: 1, 2, 3. Egyetlen elemből álló sorozat mindig Jolly Jumper.\n\n  Argumentumok:\n  - sequence: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatérési érték:\n  - Egy logikai érték, amely jelzi, hogy a sorozat Jolly Jumper-e.\n\n  Példák:\n  - is_jolly_jumper(&[1, 4, 2, 3]) visszaadja, hogy true.\n  - is_jolly_jumper(&[1, 3]) visszaadja, hogy false.\n  - is_jolly_jumper(&[5]) visszaadja, hogy true."
    },
    "docstring_bertscore": {
      "sq": "0.9947249729708565",
      "hy": "0.9752079489911304",
      "bn": "0.9774691572488315",
      "bg": "0.9897226654548739",
      "zh": "0.967889611232281",
      "fr": "0.9968109892324849",
      "de": "0.984252384761173",
      "ha": "0.9731966177527711",
      "hi": "0.9899008369066622",
      "hu": "0.9802519688871304"
    }
  },
  {
    "task_id": "Rust/24",
    "prompt": {
      "en": "/*\n  Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "sq": "/*\n  Llogarit transpozimin e një matrice katrore të dhënë.\n\n  Argumentet:\n  - matrix: Një matricë katrore e përfaqësuar si një vektor vektorësh të i32.\n\n  Kthen:\n  - Një matricë e re që është transpozimi i matricës hyrëse. Në matricën e transpozuar, rreshtat dhe kolonat e matricës origjinale janë ndërruar, në mënyrë që elementi në (i, j) në matricën origjinale të zhvendoset në pozicionin (j, i) në matricën e transpozuar.\n\n  Shembull:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) kthen vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "hy": "/*\n  Հաշվում է տրված քառակուսի մատրիցի տրանսպոնացվածը։\n\n  Արգումենտներ:\n  - matrix: Քառակուսի մատրից, որը ներկայացված է i32 վեկտորների վեկտորով։\n\n  Վերադարձնում է:\n  - Նոր մատրից, որը տրված մատրիցի տրանսպոնացվածն է։ Տրանսպոնացված մատրիցում սկզբնական մատրիցի տողերն ու սյունակները փոխվում են տեղերով, այնպես որ սկզբնական մատրիցի (i, j) դիրքի տարրը տեղափոխվում է տրանսպոնացված մատրիցի (j, i) դիրք։\n\n  Օրինակ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) վերադարձնում է vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "bn": "/*\n  প্রদত্ত একটি বর্গাকার ম্যাট্রিক্সের ট্রান্সপোজ গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - matrix: একটি বর্গাকার ম্যাট্রিক্স যা i32 এর ভেক্টরের ভেক্টর হিসেবে উপস্থাপিত।\n\n  রিটার্নস:\n  - একটি নতুন ম্যাট্রিক্স যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ। ট্রান্সপোজ ম্যাট্রিক্সে, মূল ম্যাট্রিক্সের সারি এবং কলামগুলি অদলবদল করা হয়, যাতে মূল ম্যাট্রিক্সের (i, j) অবস্থানের উপাদানটি ট্রান্সপোজ ম্যাট্রিক্সের (j, i) অবস্থানে চলে যায়।\n\n  উদাহরণ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) রিটার্ন করে vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "bg": "/*\n  Изчислява транспонираната матрица на дадена квадратна матрица.\n\n  Аргументи:\n  - matrix: Квадратна матрица, представена като вектор от вектори от i32.\n\n  Връща:\n  - Нова матрица, която е транспонираната на входната матрица. В транспонираната матрица редовете и колоните на оригиналната матрица са разменени, така че елементът на позиция (i, j) в оригиналната матрица се премества на позиция (j, i) в транспонираната матрица.\n\n  Пример:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) връща vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "zh": "/*\n  计算给定方阵的转置。\n\n  参数:\n  - matrix: 一个由i32向量的向量表示的方阵。\n\n  返回:\n  - 一个新的矩阵，它是输入矩阵的转置。在转置矩阵中，原始矩阵的行和列被交换，因此原始矩阵中位置(i, j)的元素移动到转置矩阵中的位置(j, i)。\n\n  示例:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) 返回 vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "fr": "/*\n  Calcule la transposée d'une matrice carrée donnée.\n\n  Arguments:\n  - matrix: Une matrice carrée représentée comme un vecteur de vecteurs de i32.\n\n  Retourne:\n  - Une nouvelle matrice qui est la transposée de la matrice d'entrée. Dans la matrice transposée, les lignes et les colonnes de la matrice originale sont échangées, de sorte que l'élément à la position (i, j) dans la matrice originale se déplace à la position (j, i) dans la matrice transposée.\n\n  Exemple:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) retourne vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "de": "/*\n  Berechnet die Transponierte einer gegebenen quadratischen Matrix.\n\n  Argumente:\n  - matrix: Eine quadratische Matrix, dargestellt als Vektor von Vektoren von i32.\n\n  Rückgabewert:\n  - Eine neue Matrix, die die Transponierte der Eingabematrix ist. In der transponierten Matrix werden die Zeilen und Spalten der ursprünglichen Matrix vertauscht, sodass das Element an Position (i, j) in der ursprünglichen Matrix zur Position (j, i) in der transponierten Matrix wechselt.\n\n  Beispiel:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) gibt vec![vec![1, 3], vec![2, 4]] zurück\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "ha": "/*\n  Lissafi transpose na matrix mai murabba'i da aka bayar.\n\n  Huɗɗa:\n  - matrix: Matrix mai murabba'i da aka wakilta a matsayin vector na vectors na i32.\n\n  Dawowa:\n  - Sabon matrix wanda shine transpose na matrix ɗin da aka shigar. A cikin matrix ɗin da aka transpose, an sauya layuka da ginshikai na matrix ɗin asali, don haka abin da ke a (i, j) a cikin matrix ɗin asali yana motsawa zuwa matsayi (j, i) a cikin matrix ɗin da aka transpose.\n\n  Misali:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) yana dawowa vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "hi": "/*\n  दिए गए वर्ग मैट्रिक्स का ट्रांसपोज़ गणना करता है।\n\n  तर्क:\n  - matrix: i32 के वेक्टर के वेक्टर के रूप में प्रदर्शित एक वर्ग मैट्रिक्स।\n\n  लौटाता है:\n  - एक नया मैट्रिक्स जो इनपुट मैट्रिक्स का ट्रांसपोज़ है। ट्रांसपोज़ मैट्रिक्स में, मूल मैट्रिक्स की पंक्तियाँ और स्तंभ बदल जाते हैं, ताकि मूल मैट्रिक्स में (i, j) पर स्थित तत्व ट्रांसपोज़ मैट्रिक्स में स्थिति (j, i) पर चला जाए।\n\n  उदाहरण:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] लौटाता है\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> ",
      "hu": "/*\n  Egy adott négyzetes mátrix transzponáltját számítja ki.\n\n  Argumentumok:\n  - matrix: Egy négyzetes mátrix, amely vektorok vektoraként van ábrázolva i32 típusú elemekkel.\n\n  Visszatér:\n  - Egy új mátrix, amely a bemeneti mátrix transzponáltja. A transzponált mátrixban az eredeti mátrix sorai és oszlopai felcserélődnek, így az eredeti mátrix (i, j) pozíciójában lévő elem a transzponált mátrix (j, i) pozíciójába kerül.\n\n  Példa:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) visszaadja vec![vec![1, 3], vec![2, 4]]\n*/\n\nfn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>> "
    },
    "prompt_bertscore": {
      "sq": "0.9860501883399198",
      "hy": "0.9788462616805464",
      "bn": "0.9820122313238615",
      "bg": "0.9918055036304056",
      "zh": "0.9782932746997454",
      "fr": "0.9847944470710173",
      "de": "0.9727342062257219",
      "ha": "0.9767086015198491",
      "hi": "0.9851903174204197",
      "hu": "0.975017462455718"
    },
    "canonical_solution": "{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}",
    "instruction": {
      "en": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\n将以下 Rust 代码的自然语言描述（文档字符串）用中文简明扼要地描述，字数不超过 500 个字符。",
      "fr": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>\n{\n    let n = matrix.len();\n    let mut transposed = vec![vec![0; n]; n];\n\n    for i in 0..n {\n        for j in 0..n {\n            transposed[j][i] = matrix[i][j];\n        }\n    }\n\n    transposed\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9423368058640478",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8416018053829664",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9228718230441529",
      "hi": "0.9115359871984918",
      "hu": "0.9435041566133898"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![3, 4]]),\n            vec![vec![1, 3], vec![2, 4]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2, 3], vec![4, 5, 6], vec![7, 8, 9]]),\n            vec![vec![1, 4, 7], vec![2, 5, 8], vec![3, 6, 9]]\n        );\n        assert_eq!(\n            transpose_matrix(vec![vec![1, 2], vec![1, 2]]),\n            vec![vec![1, 1], vec![2, 2]]\n        );\n    }\n    \n\n}",
    "entry_point": "transpose_matrix",
    "signature": "fn transpose_matrix(matrix: Vec<Vec<i32>>) -> Vec<Vec<i32>>",
    "docstring": {
      "en": "Computes the transpose of a given square matrix.\n\n  Arguments:\n  - matrix: A square matrix represented as a vector of vectors of i32.\n\n  Returns:\n  - A new matrix which is the transpose of the input matrix. In the transposed matrix, the rows and columns of the original matrix are switched, so that element at (i, j) in the original matrix moves to position (j, i) in the transposed matrix.\n\n  Example:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]",
      "sq": "Llogarit transpozimin e një matrice katrore të dhënë.\n\n  Argumentet:\n  - matrix: Një matricë katrore e përfaqësuar si një vektor vektorësh të i32.\n\n  Kthen:\n  - Një matricë e re që është transpozimi i matricës hyrëse. Në matricën e transpozuar, rreshtat dhe kolonat e matricës origjinale janë ndërruar, në mënyrë që elementi në (i, j) në matricën origjinale të zhvendoset në pozicionin (j, i) në matricën e transpozuar.\n\n  Shembull:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) kthen vec![vec![1, 3], vec![2, 4]]",
      "hy": "Հաշվում է տրված քառակուսի մատրիցի տրանսպոզիցիան։\n\n  Արգումենտներ:\n  - matrix: Քառակուսի մատրից, որը ներկայացված է որպես i32 վեկտորների վեկտոր։\n\n  Վերադարձնում է:\n  - Նոր մատրից, որը տրված մատրիցի տրանսպոզիցիան է։ Տրանսպոզված մատրիցում սկզբնական մատրիցի տողերը և սյունակները փոխվում են, այնպես որ սկզբնական մատրիցի (i, j) դիրքում գտնվող տարրը տեղափոխվում է տրանսպոզված մատրիցի (j, i) դիրք։\n\n  Օրինակ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) վերադարձնում է vec![vec![1, 3], vec![2, 4]]",
      "bn": "একটি প্রদত্ত বর্গাকার ম্যাট্রিক্সের ট্রান্সপোজ গণনা করে।\n\n  আর্গুমেন্টস:\n  - matrix: একটি বর্গাকার ম্যাট্রিক্স যা i32 এর ভেক্টর অফ ভেক্টর হিসেবে উপস্থাপিত।\n\n  রিটার্নস:\n  - একটি নতুন ম্যাট্রিক্স যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ। ট্রান্সপোজ ম্যাট্রিক্সে, মূল ম্যাট্রিক্সের সারি এবং কলামগুলি অদলবদল করা হয়, যাতে মূল ম্যাট্রিক্সের (i, j) অবস্থানের উপাদানটি ট্রান্সপোজ ম্যাট্রিক্সের (j, i) অবস্থানে চলে যায়।\n\n  উদাহরণ:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) রিটার্ন করে vec![vec![1, 3], vec![2, 4]]",
      "bg": "Изчислява транспонираната матрица на дадена квадратна матрица.\n\n  Аргументи:\n  - matrix: Квадратна матрица, представена като вектор от вектори от i32.\n\n  Връща:\n  - Нова матрица, която е транспонираната на входната матрица. В транспонираната матрица редовете и колоните на оригиналната матрица са разменени, така че елементът на позиция (i, j) в оригиналната матрица се премества на позиция (j, i) в транспонираната матрица.\n\n  Пример:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) връща vec![vec![1, 3], vec![2, 4]]",
      "zh": "计算给定方阵的转置。\n\n  参数:\n  - matrix: 以i32向量的向量表示的方阵。\n\n  返回:\n  - 一个新矩阵，它是输入矩阵的转置。在转置矩阵中，原矩阵的行和列被交换，因此原矩阵中位置(i, j)的元素移动到转置矩阵中的位置(j, i)。\n\n  示例:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) 返回 vec![vec![1, 3], vec![2, 4]]",
      "fr": "Calcule la transposée d'une matrice carrée donnée.\n\n  Arguments:\n  - matrix: Une matrice carrée représentée comme un vecteur de vecteurs de i32.\n\n  Renvoie:\n  - Une nouvelle matrice qui est la transposée de la matrice d'entrée. Dans la matrice transposée, les lignes et les colonnes de la matrice originale sont inversées, de sorte que l'élément à la position (i, j) dans la matrice originale se déplace à la position (j, i) dans la matrice transposée.\n\n  Exemple:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) renvoie vec![vec![1, 3], vec![2, 4]]",
      "de": "Berechnet die Transponierte einer gegebenen quadratischen Matrix.\n\n  Argumente:\n  - matrix: Eine quadratische Matrix, dargestellt als Vektor von Vektoren von i32.\n\n  Rückgabewerte:\n  - Eine neue Matrix, die die Transponierte der Eingabematrix ist. In der transponierten Matrix werden die Zeilen und Spalten der ursprünglichen Matrix vertauscht, sodass das Element an Position (i, j) in der ursprünglichen Matrix an die Position (j, i) in der transponierten Matrix verschoben wird.\n\n  Beispiel:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) gibt vec![vec![1, 3], vec![2, 4]] zurück.",
      "ha": "Lissafi juyawar matrix mai kusurwa.\n\n  Huɗɗa:\n  - matrix: Wani matrix mai siffar murabba'i wanda aka wakilta a matsayin vector na vectors na i32.\n\n  Komawa:\n  - Sabon matrix wanda shine transpose na matrix ɗin da aka shigar. A cikin matrix ɗin da aka transpose, an sauya layuka da ginshiƙai na matrix na asali, don haka abin da ke a (i, j) a cikin matrix na asali yana matsawa zuwa matsayi (j, i) a cikin matrix ɗin da aka transpose.\n\n  Misali:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) returns vec![vec![1, 3], vec![2, 4]]",
      "hi": "दिए गए वर्ग मैट्रिक्स का ट्रांसपोज़ गणना करता है।\n\n  तर्क:\n  - matrix: एक वर्ग मैट्रिक्स जो i32 के वेक्टर के रूप में दर्शाया गया है।\n\n  रिटर्न:\n  - एक नया मैट्रिक्स जो इनपुट मैट्रिक्स का ट्रांसपोज़ है। ट्रांसपोज़ मैट्रिक्स में, मूल मैट्रिक्स की पंक्तियाँ और स्तंभ स्विच हो जाते हैं, ताकि मूल मैट्रिक्स में (i, j) पर स्थित तत्व ट्रांसपोज़ मैट्रिक्स में स्थिति (j, i) पर चला जाए।\n\n  उदाहरण:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) vec![vec![1, 3], vec![2, 4]] लौटाता है।",
      "hu": "Kiszámítja a megadott négyzetes mátrix transzponáltját.\n\n  Argumentumok:\n  - matrix: Egy négyzetes mátrix, amely i32 vektorok vektoraként van ábrázolva.\n\n  Visszatér:\n  - Egy új mátrix, amely a bemeneti mátrix transzponáltja. A transzponált mátrixban az eredeti mátrix sorai és oszlopai felcserélődnek, így az eredeti mátrix (i, j) pozíciójában lévő elem a transzponált mátrix (j, i) pozíciójába kerül.\n\n  Példa:\n  - transpose_matrix(vec![vec![1, 2], vec![3, 4]]) visszaadja vec![vec![1, 3], vec![2, 4]]"
    },
    "docstring_bertscore": {
      "sq": "0.9806428734770071",
      "hy": "0.9669963704087671",
      "bn": "0.9698830657363472",
      "bg": "0.9744513658697685",
      "zh": "0.9728954940951222",
      "fr": "0.9763071695197775",
      "de": "0.9620113437359346",
      "ha": "0.9367435729644864",
      "hi": "0.986341777739279",
      "hu": "0.9587353328615261"
    }
  },
  {
    "task_id": "Rust/25",
    "prompt": {
      "en": "/*\n    Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "sq": "/*\n    Transformon një fjalëkalim të dhënë sipas një algoritmi specifik.\n\n    Algoritmi funksionon si më poshtë:\n    - Shkronjat e vogla transformohen në numra bazuar në hartën e tastierës së telefonit (p.sh., abc -> 2, def -> 3, ...).\n    - Shkronjat e mëdha fillimisht konvertohen në shkronja të vogla dhe pastaj zhvendosen në shkronjën e ardhshme në alfabet (p.sh., A -> b, Z -> a).\n    - Numrat dhe simbolet e tjera mbeten të pandryshuara.\n\n    Argumentet:\n    - input: Një varg që përfaqëson fjalëkalimin që do të transformohet. Gjatësia e fjalëkalimit nuk e kalon 100 karaktere.\n\n    Kthen:\n    - Një varg i ri që përfaqëson fjalëkalimin e transformuar.\n\n    Shembuj:\n    - transform_password(\"YUANzi1987\") kthen \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "hy": "/*\n    Տրված գաղտնաբառը փոխակերպում է հատուկ ալգորիթմի համաձայն:\n\n    Ալգորիթմը գործում է հետևյալ կերպ.\n    - Փոքրատառերը փոխակերպվում են թվերի՝ հիմնվելով հեռախոսի ստեղնաշարի համապատասխանության վրա (օրինակ՝ abc -> 2, def -> 3, ...):\n    - Մեծատառերը նախ փոխակերպվում են փոքրատառերի, ապա տեղափոխվում են այբուբենի հաջորդ տառին (օրինակ՝ A -> b, Z -> a):\n    - Թվերը և այլ նշանները մնում են անփոփոխ:\n\n    Արգումենտներ:\n    - input: Տող, որը ներկայացնում է փոխակերպվող գաղտնաբառը: Գաղտնաբառի երկարությունը չի գերազանցում 100 նիշը:\n\n    Վերադարձնում է:\n    - Նոր տող, որը ներկայացնում է փոխակերպված գաղտնաբառը:\n\n    Օրինակներ:\n    - transform_password(\"YUANzi1987\") վերադարձնում է \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "bn": "/*\n    একটি নির্দিষ্ট অ্যালগরিদম অনুযায়ী প্রদত্ত পাসওয়ার্ড রূপান্তর করে। \n\n    অ্যালগরিদমটি নিম্নরূপ কাজ করে:\n    - ছোট হাতের অক্ষরগুলি টেলিফোন কীপ্যাড ম্যাপিং অনুযায়ী সংখ্যায় রূপান্তরিত হয় (যেমন, abc -> 2, def -> 3, ...).\n    - বড় হাতের অক্ষরগুলি প্রথমে ছোট হাতের অক্ষরে রূপান্তরিত হয় এবং তারপর বর্ণমালায় পরবর্তী অক্ষরে স্থানান্তরিত হয় (যেমন, A -> b, Z -> a).\n    - সংখ্যা এবং অন্যান্য প্রতীক অপরিবর্তিত থাকে।\n\n    আর্গুমেন্টসমূহ:\n    - input: একটি স্ট্রিং যা রূপান্তরিত পাসওয়ার্ডকে উপস্থাপন করে। পাসওয়ার্ডের দৈর্ঘ্য ১০০ অক্ষর অতিক্রম করে না।\n\n    রিটার্নস:\n    - একটি নতুন স্ট্রিং যা রূপান্তরিত পাসওয়ার্ডকে উপস্থাপন করে।\n\n    উদাহরণসমূহ:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "bg": "/*\n    Преобразува дадена парола според специфичен алгоритъм.\n\n    Алгоритъмът работи по следния начин:\n    - Малките букви се преобразуват в числа според телефонната клавиатурна подредба (например, abc -> 2, def -> 3, ...).\n    - Главните букви първо се преобразуват в малки и след това се изместват към следващата буква в азбуката (например, A -> b, Z -> a).\n    - Числата и другите символи остават непроменени.\n\n    Аргументи:\n    - input: Низ, представляващ паролата, която трябва да бъде преобразувана. Дължината на паролата не надвишава 100 символа.\n\n    Връща:\n    - Нов низ, представляващ преобразуваната парола.\n\n    Примери:\n    - transform_password(\"YUANzi1987\") връща \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "zh": "/*\n    根据特定算法转换给定密码。\n\n    算法如下：\n    - 小写字母根据电话键盘映射转换为数字（例如，abc -> 2，def -> 3，...）。\n    - 大写字母首先转换为小写，然后在字母表中移到下一个字母（例如，A -> b，Z -> a）。\n    - 数字和其他符号保持不变。\n\n    参数：\n    - input：表示要转换的密码的字符串。密码长度不超过100个字符。\n\n    返回：\n    - 表示转换后密码的新字符串。\n\n    示例：\n    - transform_password(\"YUANzi1987\") 返回 \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "fr": "/*\n    Transforme un mot de passe donné selon un algorithme spécifique.\n\n    L'algorithme fonctionne comme suit :\n    - Les lettres minuscules sont transformées en chiffres selon la correspondance du clavier téléphonique (par exemple, abc -> 2, def -> 3, ...).\n    - Les lettres majuscules sont d'abord converties en minuscules puis décalées à la lettre suivante dans l'alphabet (par exemple, A -> b, Z -> a).\n    - Les chiffres et autres symboles restent inchangés.\n\n    Arguments :\n    - input : Une chaîne de caractères représentant le mot de passe à transformer. La longueur du mot de passe ne dépasse pas 100 caractères.\n\n    Renvoie :\n    - Une nouvelle chaîne de caractères représentant le mot de passe transformé.\n\n    Exemples :\n    - transform_password(\"YUANzi1987\") renvoie \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "de": "/*\n    Transformiert ein gegebenes Passwort nach einem spezifischen Algorithmus.\n\n    Der Algorithmus funktioniert wie folgt:\n    - Kleinbuchstaben werden basierend auf der Zuordnung der Telefontastatur in Zahlen umgewandelt (z.B., abc -> 2, def -> 3, ...).\n    - Großbuchstaben werden zuerst in Kleinbuchstaben umgewandelt und dann auf den nächsten Buchstaben im Alphabet verschoben (z.B., A -> b, Z -> a).\n    - Zahlen und andere Symbole bleiben unverändert.\n\n    Argumente:\n    - input: Ein String, der das zu transformierende Passwort darstellt. Die Passwortlänge überschreitet nicht 100 Zeichen.\n\n    Rückgabewerte:\n    - Ein neuer String, der das transformierte Passwort darstellt.\n\n    Beispiele:\n    - transform_password(\"YUANzi1987\") gibt \"zvbo941987\" zurück\n*/\n\nfn transform_password(input: &str) -> String ",
      "ha": "/*\n    Canza wani kalmar sirri bisa ga wata takamaiman hanya.\n\n    Hanyar tana aiki kamar haka:\n    - Haruffan ƙananan suna ana canza su zuwa lambobi bisa ga taswirar maɓallan wayar tarho (e.g., abc -> 2, def -> 3, ...).\n    - Haruffan manyan suna ana fara canza su zuwa ƙananan suna sannan a matsar da su zuwa harafin gaba a cikin haruffa (e.g., A -> b, Z -> a).\n    - Lambobi da sauran alamomi suna kasancewa a yadda suke.\n\n    Huɗa:\n    - input: Wani igiyar rubutu da ke wakiltar kalmar sirri da za a canza. Tsawon kalmar sirri ba ya wuce haruffa 100.\n\n    Komawa:\n    - Sabon igiyar rubutu da ke wakiltar kalmar sirri da aka canza.\n\n    Misalai:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "hi": "/*\n    एक दिए गए पासवर्ड को एक विशेष एल्गोरिदम के अनुसार रूपांतरित करता है।\n\n    एल्गोरिदम इस प्रकार कार्य करता है:\n    - छोटे अक्षरों को टेलीफोन कीपैड मैपिंग के आधार पर संख्याओं में बदला जाता है (जैसे, abc -> 2, def -> 3, ...).\n    - बड़े अक्षरों को पहले छोटे अक्षरों में बदला जाता है और फिर वर्णमाला में अगले अक्षर में शिफ्ट किया जाता है (जैसे, A -> b, Z -> a).\n    - संख्याएँ और अन्य प्रतीक अपरिवर्तित रहते हैं।\n\n    तर्क:\n    - input: एक स्ट्रिंग जो रूपांतरित किए जाने वाले पासवर्ड का प्रतिनिधित्व करती है। पासवर्ड की लंबाई 100 वर्णों से अधिक नहीं होती है।\n\n    लौटाता है:\n    - एक नई स्ट्रिंग जो रूपांतरित पासवर्ड का प्रतिनिधित्व करती है।\n\n    उदाहरण:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String ",
      "hu": "/*\n    Egy adott jelszót egy specifikus algoritmus szerint alakít át.\n\n    Az algoritmus a következőképpen működik:\n    - A kisbetűket a telefon billentyűzetének megfelelően számokká alakítja (pl. abc -> 2, def -> 3, ...).\n    - A nagybetűket először kisbetűkké alakítja, majd az ábécében a következő betűre tolja (pl. A -> b, Z -> a).\n    - A számok és más szimbólumok változatlanok maradnak.\n\n    Argumentumok:\n    - input: Egy string, amely az átalakítandó jelszót képviseli. A jelszó hossza nem haladja meg a 100 karaktert.\n\n    Visszatér:\n    - Egy új string, amely az átalakított jelszót képviseli.\n\n    Példák:\n    - transform_password(\"YUANzi1987\") visszaadja \"zvbo941987\"\n*/\n\nfn transform_password(input: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9927440321807955",
      "hy": "0.9731926451451505",
      "bn": "0.9894382267492319",
      "bg": "0.9815903403945434",
      "zh": "0.9776203149687992",
      "fr": "0.9856823248742432",
      "de": "0.9948979800327379",
      "ha": "0.9731086244939727",
      "hi": "0.9913754688554651",
      "hu": "0.9736749197103032"
    },
    "canonical_solution": "{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}",
    "instruction": {
      "en": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\n请为以下 Rust 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过 500 个字符。",
      "fr": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn transform_password(input: &str) -> String\n{\n    let mut transformed = String::with_capacity(input.len());\n\n    for c in input.chars() {\n        transformed.push(match c {\n            'a'..='z' => transform_lowercase(c),\n            'A'..='Z' => shift_uppercase(c),\n            _ => c,\n        });\n    }\n\n    transformed\n}\n\nfn transform_lowercase(c: char) -> char {\n    match c {\n        'a' | 'b' | 'c' => '2',\n        'd' | 'e' | 'f' => '3',\n        'g' | 'h' | 'i' => '4',\n        'j' | 'k' | 'l' => '5',\n        'm' | 'n' | 'o' => '6',\n        'p' | 'q' | 'r' | 's' => '7',\n        't' | 'u' | 'v' => '8',\n        'w' | 'x' | 'y' | 'z' => '9',\n        _ => c,\n    }\n}\n\nfn shift_uppercase(c: char) -> char {\n    let lowercase = c.to_ascii_lowercase();\n    if lowercase == 'z' {\n        'a'\n    } else {\n        char::from_u32(lowercase as u32 + 1).unwrap()\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9394052200703539",
      "hy": "0.9232088988007692",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.874171030330876",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9361141132869868",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(transform_password(\"YUANzi1987\"), \"zvbo941987\");\n        assert_eq!(transform_password(\"ABcdE\"), \"bc23f\");\n        assert_eq!(transform_password(\"Zebra123!\"), \"a3272123!\");\n    }\n    \n\n}",
    "entry_point": "transform_password",
    "signature": "fn transform_password(input: &str) -> String",
    "docstring": {
      "en": "Transforms a given password according to a specific algorithm. \n\n    The algorithm works as follows:\n    - Lowercase letters are transformed to numbers based on the telephone keypad mapping (e.g., abc -> 2, def -> 3, ...).\n    - Uppercase letters are first converted to lowercase and then shifted to the next letter in the alphabet (e.g., A -> b, Z -> a).\n    - Numbers and other symbols remain unchanged.\n\n    Arguments:\n    - input: A string representing the password to be transformed. The password length does not exceed 100 characters.\n\n    Returns:\n    - A new string representing the transformed password.\n\n    Examples:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "sq": "Transformon një fjalëkalim të dhënë sipas një algoritmi specifik.\n\n    Algoritmi funksionon si më poshtë:\n    - Shkronjat e vogla transformohen në numra bazuar në hartën e tastierës së telefonit (p.sh., abc -> 2, def -> 3, ...).\n    - Shkronjat e mëdha fillimisht konvertohen në të vogla dhe pastaj zhvendosen në shkronjën tjetër në alfabet (p.sh., A -> b, Z -> a).\n    - Numrat dhe simbolet e tjera mbeten të pandryshuara.\n\n    Argumentet:\n    - input: Një varg që përfaqëson fjalëkalimin që do të transformohet. Gjatësia e fjalëkalimit nuk i kalon 100 karaktere.\n\n    Kthen:\n    - Një varg i ri që përfaqëson fjalëkalimin e transformuar.\n\n    Shembuj:\n    - transform_password(\"YUANzi1987\") kthen \"zvbo941987\"",
      "hy": "Փոխակերպում է տրված գաղտնաբառը ըստ հատուկ ալգորիթմի:\n\n    Ալգորիթմը գործում է հետևյալ կերպ.\n    - Փոքրատառ տառերը փոխակերպվում են թվերի՝ հիմնված հեռախոսի ստեղնաշարի քարտեզագրման վրա (օրինակ՝ abc -> 2, def -> 3, ...):\n    - Մեծատառ տառերը նախ փոխակերպվում են փոքրատառերի, ապա տեղափոխվում են այբուբենի հաջորդ տառին (օրինակ՝ A -> b, Z -> a):\n    - Թվերը և այլ սիմվոլները մնում են անփոփոխ:\n\n    Արգումենտներ:\n    - input: Տող, որը ներկայացնում է փոխակերպվող գաղտնաբառը: Գաղտնաբառի երկարությունը չի գերազանցում 100 նիշը:\n\n    Վերադարձնում է.\n    - Նոր տող, որը ներկայացնում է փոխակերպված գաղտնաբառը:\n\n    Օրինակներ.\n    - transform_password(\"YUANzi1987\") վերադարձնում է \"zvbo941987\"",
      "bn": "একটি নির্দিষ্ট অ্যালগরিদম অনুযায়ী প্রদত্ত পাসওয়ার্ড রূপান্তর করে।\n\n    অ্যালগরিদমটি নিম্নরূপ কাজ করে:\n    - ছোট হাতের অক্ষরগুলি টেলিফোন কীপ্যাড ম্যাপিং অনুযায়ী সংখ্যায় রূপান্তরিত হয় (যেমন, abc -> 2, def -> 3, ...)।\n    - বড় হাতের অক্ষরগুলি প্রথমে ছোট হাতের অক্ষরে রূপান্তরিত হয় এবং তারপর বর্ণমালায় পরবর্তী অক্ষরে স্থানান্তরিত হয় (যেমন, A -> b, Z -> a)।\n    - সংখ্যা এবং অন্যান্য প্রতীক অপরিবর্তিত থাকে।\n\n    আর্গুমেন্টসমূহ:\n    - input: একটি স্ট্রিং যা রূপান্তরিত হওয়ার জন্য পাসওয়ার্ডকে উপস্থাপন করে। পাসওয়ার্ডের দৈর্ঘ্য ১০০ অক্ষর অতিক্রম করে না।\n\n    রিটার্নস:\n    - একটি নতুন স্ট্রিং যা রূপান্তরিত পাসওয়ার্ডকে উপস্থাপন করে।\n\n    উদাহরণ:\n    - transform_password(\"YUANzi1987\") রিটার্ন করে \"zvbo941987\"",
      "bg": "Трансформира дадена парола според специфичен алгоритъм.\n\n    Алгоритъмът работи по следния начин:\n    - Малките букви се трансформират в числа според телефонната клавиатура (напр. abc -> 2, def -> 3, ...).\n    - Главните букви първо се преобразуват в малки и след това се изместват към следващата буква в азбуката (напр. A -> b, Z -> a).\n    - Числата и другите символи остават непроменени.\n\n    Аргументи:\n    - input: Низ, представляващ паролата, която трябва да бъде трансформирана. Дължината на паролата не надвишава 100 символа.\n\n    Връща:\n    - Нов низ, представляващ трансформираната парола.\n\n    Примери:\n    - transform_password(\"YUANzi1987\") връща \"zvbo941987\"",
      "zh": "根据特定算法转换给定的密码。\n\n    该算法的工作原理如下：\n    - 小写字母根据电话键盘映射转换为数字（例如，abc -> 2, def -> 3, ...）。\n    - 大写字母首先转换为小写字母，然后在字母表中移到下一个字母（例如，A -> b, Z -> a）。\n    - 数字和其他符号保持不变。\n\n    参数：\n    - input: 一个字符串，表示要转换的密码。密码长度不超过100个字符。\n\n    返回：\n    - 一个新的字符串，表示转换后的密码。\n\n    示例：\n    - transform_password(\"YUANzi1987\") 返回 \"zvbo941987\"",
      "fr": "Transforme un mot de passe donné selon un algorithme spécifique.\n\n    L'algorithme fonctionne comme suit :\n    - Les lettres minuscules sont transformées en chiffres selon le mappage du clavier téléphonique (par exemple, abc -> 2, def -> 3, ...).\n    - Les lettres majuscules sont d'abord converties en minuscules puis décalées à la lettre suivante dans l'alphabet (par exemple, A -> b, Z -> a).\n    - Les chiffres et autres symboles restent inchangés.\n\n    Arguments :\n    - input : Une chaîne de caractères représentant le mot de passe à transformer. La longueur du mot de passe ne dépasse pas 100 caractères.\n\n    Retourne :\n    - Une nouvelle chaîne de caractères représentant le mot de passe transformé.\n\n    Exemples :\n    - transform_password(\"YUANzi1987\") retourne \"zvbo941987\"",
      "de": "Transformiert ein gegebenes Passwort gemäß einem spezifischen Algorithmus.\n\n    Der Algorithmus funktioniert wie folgt:\n    - Kleinbuchstaben werden basierend auf der Zuordnung der Telefontastatur in Zahlen umgewandelt (z.B. abc -> 2, def -> 3, ...).\n    - Großbuchstaben werden zuerst in Kleinbuchstaben umgewandelt und dann auf den nächsten Buchstaben im Alphabet verschoben (z.B. A -> b, Z -> a).\n    - Zahlen und andere Symbole bleiben unverändert.\n\n    Argumente:\n    - input: Ein String, der das zu transformierende Passwort darstellt. Die Passwortlänge überschreitet nicht 100 Zeichen.\n\n    Rückgabewert:\n    - Ein neuer String, der das transformierte Passwort darstellt.\n\n    Beispiele:\n    - transform_password(\"YUANzi1987\") gibt \"zvbo941987\" zurück.",
      "ha": "Canza kalmar sirri da aka bayar bisa ga wani takamaiman hanya.\n\n    Algoritmin yana aiki kamar haka:\n    - Haruffan ƙananan suna canzawa zuwa lambobi bisa ga taswirar maɓallin wayar tarho (misali, abc -> 2, def -> 3, ...).\n    - Haruffan manya suna fara canzawa zuwa ƙananan sannan kuma a matsar da su zuwa harafin gaba a cikin haruffa (misali, A -> b, Z -> a).\n    - Lambobi da sauran alamomi suna kasancewa ba a canza su ba.\n\n    Huɗa:\n    - input: Wani kirtani mai wakiltar kalmar sirri da za a canza. Tsawon kalmar sirri ba ya wuce haruffa 100.\n\n    Komawa:\n    - Sabon kirtani mai wakiltar kalmar sirri da aka canza.\n\n    Misalai:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "hi": "एक दिए गए पासवर्ड को एक विशेष एल्गोरिदम के अनुसार परिवर्तित करता है।\n\n    एल्गोरिदम इस प्रकार कार्य करता है:\n    - छोटे अक्षरों को टेलीफोन कीपैड मैपिंग के आधार पर संख्याओं में परिवर्तित किया जाता है (जैसे, abc -> 2, def -> 3, ...).\n    - बड़े अक्षरों को पहले छोटे अक्षरों में परिवर्तित किया जाता है और फिर वर्णमाला में अगले अक्षर में स्थानांतरित किया जाता है (जैसे, A -> b, Z -> a).\n    - संख्याएं और अन्य प्रतीक अपरिवर्तित रहते हैं।\n\n    तर्क:\n    - input: एक स्ट्रिंग जो परिवर्तित किए जाने वाले पासवर्ड का प्रतिनिधित्व करती है। पासवर्ड की लंबाई 100 वर्णों से अधिक नहीं होती है।\n\n    लौटाता है:\n    - एक नई स्ट्रिंग जो परिवर्तित पासवर्ड का प्रतिनिधित्व करती है।\n\n    उदाहरण:\n    - transform_password(\"YUANzi1987\") returns \"zvbo941987\"",
      "hu": "Átalakít egy adott jelszót egy meghatározott algoritmus szerint.\n\n    Az algoritmus a következőképpen működik:\n    - A kisbetűk számokká alakulnak a telefon billentyűzetének megfelelően (pl. abc -> 2, def -> 3, ...).\n    - A nagybetűk először kisbetűkké alakulnak, majd az ábécé következő betűjére tolódnak (pl. A -> b, Z -> a).\n    - A számok és más szimbólumok változatlanok maradnak.\n\n    Argumentumok:\n    - input: Egy string, amely a átalakítandó jelszót képviseli. A jelszó hossza nem haladja meg a 100 karaktert.\n\n    Visszatérési érték:\n    - Egy új string, amely az átalakított jelszót képviseli.\n\n    Példák:\n    - transform_password(\"YUANzi1987\") visszaadja \"zvbo941987\""
    },
    "docstring_bertscore": {
      "sq": "0.9916964555512175",
      "hy": "0.9780849114300397",
      "bn": "0.9884103145273764",
      "bg": "0.9860211883042888",
      "zh": "0.9930735599829325",
      "fr": "0.9820448067063513",
      "de": "0.9823550673615278",
      "ha": "0.9691268798757473",
      "hi": "0.9844325425167717",
      "hu": "0.9838493637180532"
    }
  },
  {
    "task_id": "Rust/26",
    "prompt": {
      "en": "/*\n  Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "sq": "/*\n  Përcakton nëse sekuenca e dhënë e numrave formon një sekuencë aritmetike.\n\n  Një sekuencë aritmetike është një sekuencë numrash e tillë që diferenca midis numrave të njëpasnjëshëm është konstante.\n\n  Argumentet:\n  - sequence: Një segment array i numrave të plotë që përfaqëson sekuencën që do të kontrollohet.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca formon një sekuencë aritmetike (`true`) apo jo (`false`).\n\n  Shembuj:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) kthen true (pasi diferenca është 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) kthen false (pasi diferenca nuk është konstante)\n  - is_arithmetic_sequence(&[10, 10, 10]) kthen true (pasi diferenca është 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "hy": "/*\n  Սահմանում է, արդյոք տրված թվերի հաջորդականությունը կազմում է թվաբանական հաջորդականություն:\n\n  Թվաբանական հաջորդականությունը թվերի հաջորդականություն է, որի դեպքում հաջորդական թվերի տարբերությունը հաստատուն է:\n\n  Արգումենտներ:\n  - sequence: Ամբողջ թվերի զանգվածի հատված, որը ներկայացնում է ստուգվող հաջորդականությունը:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս, արդյոք հաջորդականությունը կազմում է թվաբանական հաջորդականություն (`true`) թե ոչ (`false`):\n\n  Օրինակներ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) վերադարձնում է true (քանի որ տարբերությունը 2 է)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) վերադարձնում է false (քանի որ տարբերությունը հաստատուն չէ)\n  - is_arithmetic_sequence(&[10, 10, 10]) վերադարձնում է true (քանի որ տարբերությունը 0 է)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "bn": "/*\n  প্রদত্ত সংখ্যার ক্রমটি একটি গাণিতিক ক্রম গঠন করে কিনা তা নির্ধারণ করে।\n\n  একটি গাণিতিক ক্রম হল এমন একটি সংখ্যার ক্রম যেখানে পরপর সংখ্যার মধ্যে পার্থক্য ধ্রুবক।\n\n  আর্গুমেন্ট:\n  - sequence: একটি পূর্ণসংখ্যার অ্যারে স্লাইস যা যাচাই করার জন্য ক্রমকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি বুলিয়ান মান যা নির্দেশ করে যে ক্রমটি একটি গাণিতিক ক্রম গঠন করে কিনা (`true`) বা না করে (`false`)।\n\n  উদাহরণ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) রিটার্ন করে true (যেহেতু পার্থক্য 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) রিটার্ন করে false (যেহেতু পার্থক্য ধ্রুবক নয়)\n  - is_arithmetic_sequence(&[10, 10, 10]) রিটার্ন করে true (যেহেতু পার্থক্য 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "bg": "/*\n  Определя дали дадената последователност от числа образува аритметична прогресия.\n\n  Аритметична прогресия е последователност от числа, при която разликата между последователните числа е постоянна.\n\n  Аргументи:\n  - sequence: Срез от масив от цели числа, представляващ последователността, която трябва да бъде проверена.\n\n  Връща:\n  - Булева стойност, указваща дали последователността образува аритметична прогресия (`true`) или не (`false`).\n\n  Примери:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) връща true (тъй като разликата е 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) връща false (тъй като разликата не е постоянна)\n  - is_arithmetic_sequence(&[10, 10, 10]) връща true (тъй като разликата е 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "zh": "/*\n  确定给定的数字序列是否构成等差数列。\n\n  等差数列是指连续数字之间的差是恒定的数列。\n\n  参数:\n  - sequence: 整数数组切片，表示要检查的序列。\n\n  返回:\n  - 一个布尔值，指示序列是否构成等差数列（`true`）或不是（`false`）。\n\n  示例:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) 返回 true (因为差是 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) 返回 false (因为差不是恒定的)\n  - is_arithmetic_sequence(&[10, 10, 10]) 返回 true (因为差是 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "fr": "/*\n  Détermine si la séquence de nombres donnée forme une séquence arithmétique.\n\n  Une séquence arithmétique est une séquence de nombres telle que la différence entre les nombres consécutifs est constante.\n\n  Arguments :\n  - sequence : Une tranche de tableau d'entiers représentant la séquence à vérifier.\n\n  Renvoie :\n  - Une valeur booléenne indiquant si la séquence forme une séquence arithmétique (`true`) ou non (`false`).\n\n  Exemples :\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) renvoie true (car la différence est de 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) renvoie false (car la différence n'est pas constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) renvoie true (car la différence est de 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "de": "/*\n  Bestimmt, ob die gegebene Zahlenfolge eine arithmetische Folge bildet.\n\n  Eine arithmetische Folge ist eine Zahlenfolge, bei der der Unterschied zwischen aufeinanderfolgenden Zahlen konstant ist.\n\n  Argumente:\n  - sequence: Ein Array-Slice von Ganzzahlen, das die zu überprüfende Folge darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Folge eine arithmetische Folge bildet (`true`) oder nicht (`false`).\n\n  Beispiele:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) gibt true zurück (da der Unterschied 2 ist)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) gibt false zurück (da der Unterschied nicht konstant ist)\n  - is_arithmetic_sequence(&[10, 10, 10]) gibt true zurück (da der Unterschied 0 ist)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "ha": "/*\n  Yana tantance ko jerin lambobin da aka bayar suna samar da jerin lissafi.\n\n  Jerin lissafi jerin lambobi ne wanda bambanci tsakanin lambobin da ke biye da juna yake daidai.\n\n  Huɗɗa:\n  - sequence: Wani yanki na jerin lambobi da ke wakiltar jerin da za a duba.\n\n  Dawowa:\n  - Ƙimar boolean da ke nuna ko jerin yana samar da jerin lissafi (`true`) ko a'a (`false`).\n\n  Misalai:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) yana dawowa true (domin bambancin shine 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) yana dawowa false (domin bambancin ba daidai bane)\n  - is_arithmetic_sequence(&[10, 10, 10]) yana dawowa true (domin bambancin shine 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "hi": "/*\n  यह निर्धारित करता है कि दिए गए संख्याओं का अनुक्रम एक अंकगणितीय अनुक्रम बनाता है या नहीं।\n\n  एक अंकगणितीय अनुक्रम वह अनुक्रम होता है जिसमें लगातार संख्याओं के बीच का अंतर स्थिर होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों की एक array slice जो जाँच के लिए अनुक्रम का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - एक boolean मान जो इंगित करता है कि अनुक्रम एक अंकगणितीय अनुक्रम बनाता है (`true`) या नहीं (`false`)।\n\n  उदाहरण:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true लौटाता है (क्योंकि अंतर 2 है)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false लौटाता है (क्योंकि अंतर स्थिर नहीं है)\n  - is_arithmetic_sequence(&[10, 10, 10]) true लौटाता है (क्योंकि अंतर 0 है)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool ",
      "hu": "/*\n  Meghatározza, hogy a megadott számok sorozata számtani sorozatot alkot-e.\n\n  Egy számtani sorozat olyan számok sorozata, amelyben az egymást követő számok közötti különbség állandó.\n\n  Argumentumok:\n  - sequence: Egész számokat tartalmazó tömb szelete, amely a vizsgálandó sorozatot képviseli.\n\n  Visszatérési érték:\n  - Egy logikai érték, amely jelzi, hogy a sorozat számtani sorozatot alkot-e (`true`) vagy sem (`false`).\n\n  Példák:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) visszaadja a true értéket (mivel a különbség 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) visszaadja a false értéket (mivel a különbség nem állandó)\n  - is_arithmetic_sequence(&[10, 10, 10]) visszaadja a true értéket (mivel a különbség 0)\n*/\n\n\nfn is_arithmetic_sequence(sequence: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "sq": "0.9911597562616613",
      "hy": "0.9859184963972937",
      "bn": "0.9857305920568347",
      "bg": "0.9781089457061449",
      "zh": "0.9675567067136666",
      "fr": "0.988681246367108",
      "de": "0.990440912912696",
      "ha": "0.9612950825819228",
      "hi": "0.9860535650563974",
      "hu": "0.9724434113478868"
    },
    "canonical_solution": "{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}",
    "instruction": {
      "en": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nনিচের রাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\n将以下 Rust 代码的自然语言描述（文档字符串）翻译成中文，字数不超过 500 个字符。",
      "fr": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Rust a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool\n{\n    if sequence.len() < 2 {\n        return true;\n    }\n\n    let common_difference = sequence[1] - sequence[0];\n\n    for i in 1..sequence.len() - 1 {\n        if sequence[i + 1] - sequence[i] != common_difference {\n            return false;\n        }\n    }\n\n    true\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9337555761425785",
      "bn": "0.8911046675748622",
      "bg": "0.8316696904400789",
      "zh": "0.7915938261320987",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9068067964564321",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(is_arithmetic_sequence(&[5, 7, 9, 11]), true);  // True, as 2 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[1, 2, 4, 8]), false);  // False, as difference changes\n        assert_eq!(is_arithmetic_sequence(&[10, 10, 10]), true);   // True, as 0 is the constant difference\n        assert_eq!(is_arithmetic_sequence(&[3, 6, 9, 12, 16]), false); // False, last difference is not 3\n    }\n}",
    "entry_point": "is_arithmetic_sequence",
    "signature": "fn is_arithmetic_sequence(sequence: &[i32]) -> bool",
    "docstring": {
      "en": "Determines whether the given sequence of numbers forms an arithmetic sequence.\n\n  An arithmetic sequence is a sequence of numbers such that the difference between consecutive numbers is constant.\n\n  Arguments:\n  - sequence: An array slice of integers representing the sequence to be checked.\n\n  Returns:\n  - A boolean value indicating whether the sequence forms an arithmetic sequence (`true`) or not (`false`).\n\n  Examples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) returns true (as the difference is 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) returns false (as the difference is not constant)\n  - is_arithmetic_sequence(&[10, 10, 10]) returns true (as the difference is 0)",
      "sq": "Përcakton nëse sekuenca e dhënë e numrave formon një sekuencë aritmetike.\n\n  Një sekuencë aritmetike është një sekuencë numrash e tillë që diferenca midis numrave të njëpasnjëshëm është konstante.\n\n  Argumentet:\n  - sequence: Një pjesë e vargut të numrave të plotë që përfaqëson sekuencën që do të kontrollohet.\n\n  Kthen:\n  - Një vlerë boolean që tregon nëse sekuenca formon një sekuencë aritmetike (`true`) apo jo (`false`).\n\n  Shembuj:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) kthen true (pasi diferenca është 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) kthen false (pasi diferenca nuk është konstante)\n  - is_arithmetic_sequence(&[10, 10, 10]) kthen true (pasi diferenca është 0)",
      "hy": "Սահմանում է՝ արդյոք տրված թվերի հաջորդականությունը կազմում է թվաբանական հաջորդականություն։\n\n  Թվաբանական հաջորդականությունը այնպիսի թվերի հաջորդականություն է, որ հաջորդական թվերի տարբերությունը հաստատուն է։\n\n  Արգումենտներ:\n  - sequence: Թվերի զանգվածի հատված, որը ներկայացնում է ստուգվող հաջորդականությունը։\n\n  Վերադարձնում է:\n  - Բուլյան արժեք, որը ցույց է տալիս՝ արդյոք հաջորդականությունը կազմում է թվաբանական հաջորդականություն (`true`) թե ոչ (`false`)։\n\n  Օրինակներ:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) վերադարձնում է true (քանի որ տարբերությունը 2 է)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) վերադարձնում է false (քանի որ տարբերությունը հաստատուն չէ)\n  - is_arithmetic_sequence(&[10, 10, 10]) վերադարձնում է true (քանի որ տարբերությունը 0 է)",
      "bn": "নির্ধারণ করে যে প্রদত্ত সংখ্যার ক্রম একটি গাণিতিক ক্রম গঠন করে কিনা।\n\nএকটি গাণিতিক ক্রম হল এমন একটি সংখ্যার ক্রম যাতে পরপর সংখ্যার মধ্যে পার্থক্য ধ্রুবক হয়।\n\nArguments:\n- sequence: পূর্ণসংখ্যার একটি অ্যারে স্লাইস যা যাচাই করার জন্য ক্রমকে উপস্থাপন করে।\n\nReturns:\n- একটি বুলিয়ান মান যা নির্দেশ করে যে ক্রমটি একটি গাণিতিক ক্রম গঠন করে কিনা (`true`) বা না করে (`false`)।\n\nExamples:\n- is_arithmetic_sequence(&[5, 7, 9, 11]) true রিটার্ন করে (যেহেতু পার্থক্য 2)\n- is_arithmetic_sequence(&[1, 2, 4, 8]) false রিটার্ন করে (যেহেতু পার্থক্য ধ্রুবক নয়)\n- is_arithmetic_sequence(&[10, 10, 10]) true রিটার্ন করে (যেহেতু পার্থক্য 0)",
      "bg": "Определя дали дадената последователност от числа формира аритметична прогресия.\n\n  Аритметична прогресия е последователност от числа, при която разликата между последователните числа е постоянна.\n\n  Аргументи:\n  - sequence: Масив от цели числа, представляващ последователността, която трябва да бъде проверена.\n\n  Връща:\n  - Булева стойност, указваща дали последователността формира аритметична прогресия (`true`) или не (`false`).\n\n  Примери:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) връща true (тъй като разликата е 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) връща false (тъй като разликата не е постоянна)\n  - is_arithmetic_sequence(&[10, 10, 10]) връща true (тъй като разликата е 0)",
      "zh": "确定给定的数字序列是否构成等差数列。\n\n等差数列是指相邻数字之间的差是恒定的数列。\n\n参数:\n- sequence: 整数数组切片，表示要检查的序列。\n\n返回:\n- 一个布尔值，指示序列是否构成等差数列（`true`）或不是（`false`）。\n\n示例:\n- is_arithmetic_sequence(&[5, 7, 9, 11]) 返回 true （因为差为 2）\n- is_arithmetic_sequence(&[1, 2, 4, 8]) 返回 false （因为差不是恒定的）\n- is_arithmetic_sequence(&[10, 10, 10]) 返回 true （因为差为 0）",
      "fr": "Détermine si la séquence de nombres donnée forme une suite arithmétique.\n\n  Une suite arithmétique est une séquence de nombres telle que la différence entre les nombres consécutifs est constante.\n\n  Arguments:\n  - sequence: Une tranche de tableau d'entiers représentant la séquence à vérifier.\n\n  Renvoie:\n  - Une valeur booléenne indiquant si la séquence forme une suite arithmétique (`true`) ou non (`false`).\n\n  Exemples:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) renvoie true (car la différence est de 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) renvoie false (car la différence n'est pas constante)\n  - is_arithmetic_sequence(&[10, 10, 10]) renvoie true (car la différence est de 0)",
      "de": "Bestimmt, ob die gegebene Zahlenfolge eine arithmetische Folge bildet.\n\n  Eine arithmetische Folge ist eine Zahlenfolge, bei der der Unterschied zwischen aufeinanderfolgenden Zahlen konstant ist.\n\n  Argumente:\n  - sequence: Ein Array-Slice von ganzen Zahlen, das die zu überprüfende Folge darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert, der angibt, ob die Folge eine arithmetische Folge bildet (`true`) oder nicht (`false`).\n\n  Beispiele:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) gibt true zurück (da der Unterschied 2 ist)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) gibt false zurück (da der Unterschied nicht konstant ist)\n  - is_arithmetic_sequence(&[10, 10, 10]) gibt true zurück (da der Unterschied 0 ist)",
      "ha": "Yana tantance ko jerin lambobin da aka bayar suna samar da jerin lissafi.\n\n  Jerin lissafi jerin lambobi ne inda bambanci tsakanin lambobi masu zuwa jere ya kasance mai ɗorewa.\n\n  Huɗɗa:\n  - sequence: Yankan jerin lambobi na integers wanda ke wakiltar jerin da za a duba.\n\n  Dawowa:\n  - Ƙimar boolean da ke nuna ko jerin yana samar da jerin lissafi (`true`) ko a'a (`false`).\n\n  Misalai:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) yana dawowa true (domin bambancin shine 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) yana dawowa false (domin bambancin ba mai ɗorewa bane)\n  - is_arithmetic_sequence(&[10, 10, 10]) yana dawowa true (domin bambancin shine 0)",
      "hi": "यह निर्धारित करता है कि दिए गए संख्याओं का अनुक्रम एक अंकगणितीय अनुक्रम बनाता है या नहीं।\n\n  एक अंकगणितीय अनुक्रम संख्याओं का ऐसा अनुक्रम होता है जिसमें लगातार संख्याओं के बीच का अंतर स्थिर होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों का एक सरणी खंड जो जाँच के लिए अनुक्रम का प्रतिनिधित्व करता है।\n\n  वापसी मान:\n  - एक बूलियन मान जो यह दर्शाता है कि अनुक्रम एक अंकगणितीय अनुक्रम बनाता है (`true`) या नहीं (`false`)।\n\n  उदाहरण:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) true लौटाता है (क्योंकि अंतर 2 है)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) false लौटाता है (क्योंकि अंतर स्थिर नहीं है)\n  - is_arithmetic_sequence(&[10, 10, 10]) true लौटाता है (क्योंकि अंतर 0 है)",
      "hu": "Meghatározza, hogy a megadott számok sorozata számtani sorozatot alkot-e.\n\n  Egy számtani sorozat olyan számok sorozata, amelyben az egymást követő számok közötti különbség állandó.\n\n  Argumentumok:\n  - sequence: Egész számokat tartalmazó tömbszelet, amely a vizsgálandó sorozatot képviseli.\n\n  Visszatérési érték:\n  - Egy logikai érték, amely jelzi, hogy a sorozat számtani sorozatot alkot-e (`true`) vagy sem (`false`).\n\n  Példák:\n  - is_arithmetic_sequence(&[5, 7, 9, 11]) visszaadja true (mivel a különbség 2)\n  - is_arithmetic_sequence(&[1, 2, 4, 8]) visszaadja false (mivel a különbség nem állandó)\n  - is_arithmetic_sequence(&[10, 10, 10]) visszaadja true (mivel a különbség 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9918662845270023",
      "hy": "0.9814318333504776",
      "bn": "0.9786591518616116",
      "bg": "0.9781357608075847",
      "zh": "0.9641857505171234",
      "fr": "0.9843667958606491",
      "de": "0.9871071005974065",
      "ha": "0.9577691946881725",
      "hi": "0.9781276169619623",
      "hu": "0.9859224690049143"
    }
  },
  {
    "task_id": "Rust/27",
    "prompt": {
      "en": "/*\n  Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "sq": "/*\n  Llogarit ditën e vitit për një datë të dhënë në formatin YYYY/MM/DD.\n\n  Argumentet:\n  - date: Një varg që përfaqëson një datë në formatin YYYY/MM/DD.\n\n  Kthen:\n  - Ok(usize): Dita e vitit si një numër nëse data është e vlefshme.\n  - Err(String): Një mesazh gabimi nëse data është e pavlefshme.\n\n  Shembull:\n  - day_of_year(\"1985/1/20\") kthen Ok(20)\n  - day_of_year(\"2006/3/12\") kthen Ok(71)\n  - day_of_year(\"2024/2/30\") kthen Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "hy": "/*\n  Հաշվում է տարվա օրը տրված ամսաթվի համար YYYY/MM/DD ձևաչափով:\n\n  Արգումենտներ:\n  - date: Տող, որը ներկայացնում է ամսաթիվ YYYY/MM/DD ձևաչափով:\n\n  Վերադարձնում է:\n  - Ok(usize): Տարվա օրը որպես թիվ, եթե ամսաթիվը վավեր է:\n  - Err(String): Սխալի հաղորդագրություն, եթե ամսաթիվը անվավեր է:\n\n  Օրինակ:\n  - day_of_year(\"1985/1/20\") վերադարձնում է Ok(20)\n  - day_of_year(\"2006/3/12\") վերադարձնում է Ok(71)\n  - day_of_year(\"2024/2/30\") վերադարձնում է Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "bn": "/*\n  প্রদত্ত তারিখের স্ট্রিং থেকে বছরের দিনের হিসাব করে, ফরম্যাট YYYY/MM/DD এ।\n\n  আর্গুমেন্টসমূহ:\n  - date: YYYY/MM/DD ফরম্যাটে একটি তারিখ নির্দেশক স্ট্রিং।\n\n  রিটার্নস:\n  - Ok(usize): যদি তারিখটি বৈধ হয় তবে বছরের দিনের সংখ্যা।\n  - Err(String): যদি তারিখটি অবৈধ হয় তবে একটি ত্রুটি বার্তা।\n\n  উদাহরণ:\n  - day_of_year(\"1985/1/20\") Ok(20) রিটার্ন করে\n  - day_of_year(\"2006/3/12\") Ok(71) রিটার্ন করে\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") রিটার্ন করে\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "bg": "/*\n  Изчислява деня от годината за дадена дата във формат YYYY/MM/DD.\n\n  Аргументи:\n  - date: Низ, представляващ дата във формат YYYY/MM/DD.\n\n  Връща:\n  - Ok(usize): Денят от годината като число, ако датата е валидна.\n  - Err(String): Съобщение за грешка, ако датата е невалидна.\n\n  Пример:\n  - day_of_year(\"1985/1/20\") връща Ok(20)\n  - day_of_year(\"2006/3/12\") връща Ok(71)\n  - day_of_year(\"2024/2/30\") връща Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "zh": "/*\n  计算给定日期字符串（格式为 YYYY/MM/DD）在一年中的第几天。\n\n  参数:\n  - date: 表示日期的字符串，格式为 YYYY/MM/DD。\n\n  返回:\n  - Ok(usize): 如果日期有效，则返回一年中的第几天作为数字。\n  - Err(String): 如果日期无效，则返回错误信息。\n\n  示例:\n  - day_of_year(\"1985/1/20\") 返回 Ok(20)\n  - day_of_year(\"2006/3/12\") 返回 Ok(71)\n  - day_of_year(\"2024/2/30\") 返回 Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "fr": "/*\n  Calcule le jour de l'année pour une date donnée sous forme de chaîne au format AAAA/MM/JJ.\n\n  Arguments :\n  - date : Une chaîne représentant une date au format AAAA/MM/JJ.\n\n  Renvoie :\n  - Ok(usize) : Le jour de l'année en tant que nombre si la date est valide.\n  - Err(String) : Un message d'erreur si la date est invalide.\n\n  Exemple :\n  - day_of_year(\"1985/1/20\") renvoie Ok(20)\n  - day_of_year(\"2006/3/12\") renvoie Ok(71)\n  - day_of_year(\"2024/2/30\") renvoie Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "de": "/*\n  Berechnet den Tag des Jahres für ein gegebenes Datum im Format JJJJ/MM/TT.\n\n  Argumente:\n  - date: Ein String, der ein Datum im Format JJJJ/MM/TT repräsentiert.\n\n  Rückgabewerte:\n  - Ok(usize): Der Tag des Jahres als Zahl, wenn das Datum gültig ist.\n  - Err(String): Eine Fehlermeldung, wenn das Datum ungültig ist.\n\n  Beispiel:\n  - day_of_year(\"1985/1/20\") gibt Ok(20) zurück\n  - day_of_year(\"2006/3/12\") gibt Ok(71) zurück\n  - day_of_year(\"2024/2/30\") gibt Err(\"Invalid\") zurück\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "ha": "/*\n  Lissafa ranar shekara don wata takamaiman kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Huɗɗa:\n  - date: Wani kirtani da ke wakiltar kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Mayarwa:\n  - Ok(usize): Ranar shekara a matsayin lamba idan kwanan wata ya inganta.\n  - Err(String): Saƙon kuskure idan kwanan wata bai inganta ba.\n\n  Misali:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "hi": "/*\n  दिए गए तारीख स्ट्रिंग के लिए वर्ष का दिन गणना करता है, जो YYYY/MM/DD प्रारूप में है।\n\n  तर्क:\n  - date: YYYY/MM/DD प्रारूप में एक तारीख को दर्शाने वाली एक स्ट्रिंग।\n\n  रिटर्न करता है:\n  - Ok(usize): यदि तारीख मान्य है तो वर्ष का दिन एक संख्या के रूप में।\n  - Err(String): यदि तारीख अमान्य है तो एक त्रुटि संदेश।\n\n  उदाहरण:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> ",
      "hu": "/*\n  Kiszámítja az év napját egy adott dátum karakterlánc alapján, amelynek formátuma ÉÉÉÉ/HH/NN.\n\n  Argumentumok:\n  - date: Egy karakterlánc, amely egy dátumot jelöl az ÉÉÉÉ/HH/NN formátumban.\n\n  Visszatér:\n  - Ok(usize): Az év napja számként, ha a dátum érvényes.\n  - Err(String): Hibaüzenet, ha a dátum érvénytelen.\n\n  Példa:\n  - day_of_year(\"1985/1/20\") visszaadja Ok(20)\n  - day_of_year(\"2006/3/12\") visszaadja Ok(71)\n  - day_of_year(\"2024/2/30\") visszaadja Err(\"Invalid\")\n*/\n\nfn day_of_year(date: &str) -> Result<usize, String> "
    },
    "prompt_bertscore": {
      "sq": "0.9947823771509755",
      "hy": "0.9943614793735627",
      "bn": "0.9738866596964864",
      "bg": "0.9947686716546842",
      "zh": "0.9420658740243162",
      "fr": "0.9933349575643743",
      "de": "0.9908302284595244",
      "ha": "0.9741303791740161",
      "hi": "0.9794284473273598",
      "hu": "0.9917967638936401"
    },
    "canonical_solution": "{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "instruction": {
      "en": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nরাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, अधिकतम 500 वर्णों का उपयोग करते हुए।",
      "hu": "fn day_of_year(date: &str) -> Result<usize, String>\n{\n    let parts: Vec<&str> = date.split('/').collect();\n    if parts.len() != 3 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let year = parts[0].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let month = parts[1].parse::<usize>().map_err(|_| \"Invalid\")?;\n    let day = parts[2].parse::<usize>().map_err(|_| \"Invalid\")?;\n\n    if month == 0 || month > 12 {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let days_in_month = [31, 28 + is_leap_year(year) as usize, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    if day == 0 || day > days_in_month[month - 1] {\n        return Err(\"Invalid\".to_string());\n    }\n\n    let day_of_year = days_in_month[..month - 1].iter().sum::<usize>() + day;\n    Ok(day_of_year)\n}\n\nfn is_leap_year(year: usize) -> bool {\n    (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9423368058640478",
      "bn": "0.8967072361023323",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9536426485221726",
      "hi": "0.9147661144548812",
      "hu": "0.9315990460956828"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(day_of_year(\"1985/1/20\"), Ok(20));\n        assert_eq!(day_of_year(\"2006/3/12\"), Ok(71));\n        assert_eq!(day_of_year(\"2024/2/30\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/13/10\"), Err(\"Invalid\".to_string()));\n        assert_eq!(day_of_year(\"2024/2/29\"), Ok(60)); // Leap year case\n\n    }\n    \n\n}",
    "entry_point": "day_of_year",
    "signature": "fn day_of_year(date: &str) -> Result<usize, String>",
    "docstring": {
      "en": "Calculates the day of the year for a given date string in the format YYYY/MM/DD.\n\n  Arguments:\n  - date: A string representing a date in the format YYYY/MM/DD.\n\n  Returns:\n  - Ok(usize): The day of the year as a number if the date is valid.\n  - Err(String): An error message if the date is invalid.\n\n  Example:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "sq": "Llogarit ditën e vitit për një datë të dhënë në formatin YYYY/MM/DD.\n\n  Argumentet:\n  - date: Një varg që përfaqëson një datë në formatin YYYY/MM/DD.\n\n  Kthen:\n  - Ok(usize): Dita e vitit si një numër nëse data është e vlefshme.\n  - Err(String): Një mesazh gabimi nëse data është e pavlefshme.\n\n  Shembull:\n  - day_of_year(\"1985/1/20\") kthen Ok(20)\n  - day_of_year(\"2006/3/12\") kthen Ok(71)\n  - day_of_year(\"2024/2/30\") kthen Err(\"Invalid\")",
      "hy": "Հաշվում է տարվա օրը տրված ամսաթվի տողի համար YYYY/MM/DD ձևաչափով:\n\n  Արհամարհանքներ:\n  - date: Տող, որը ներկայացնում է ամսաթիվը YYYY/MM/DD ձևաչափով:\n\n  Վերադարձնում է:\n  - Ok(usize): Տարվա օրը որպես թիվ, եթե ամսաթիվը վավեր է:\n  - Err(String): Սխալի հաղորդագրություն, եթե ամսաթիվը անվավեր է:\n\n  Օրինակ:\n  - day_of_year(\"1985/1/20\") վերադարձնում է Ok(20)\n  - day_of_year(\"2006/3/12\") վերադարձնում է Ok(71)\n  - day_of_year(\"2024/2/30\") վերադարձնում է Err(\"Invalid\")",
      "bn": "প্রদত্ত তারিখের স্ট্রিং থেকে বছরের দিনের হিসাব করে YYYY/MM/DD ফরম্যাটে।\n\n  আর্গুমেন্টস:\n  - date: YYYY/MM/DD ফরম্যাটে একটি তারিখ উপস্থাপনকারী একটি স্ট্রিং।\n\n  রিটার্নস:\n  - Ok(usize): বছরের দিনের সংখ্যা যদি তারিখটি বৈধ হয়।\n  - Err(String): একটি ত্রুটি বার্তা যদি তারিখটি অবৈধ হয়।\n\n  উদাহরণ:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "bg": "Изчислява деня от годината за даден низ с дата във формат YYYY/MM/DD.\n\nАргументи:\n- date: Низ, представляващ дата във формат YYYY/MM/DD.\n\nВръща:\n- Ok(usize): Денят от годината като число, ако датата е валидна.\n- Err(String): Съобщение за грешка, ако датата е невалидна.\n\nПример:\n- day_of_year(\"1985/1/20\") връща Ok(20)\n- day_of_year(\"2006/3/12\") връща Ok(71)\n- day_of_year(\"2024/2/30\") връща Err(\"Invalid\")",
      "zh": "计算给定日期字符串（格式为 YYYY/MM/DD）在一年中的第几天。\n\n  参数:\n  - date: 一个表示日期的字符串，格式为 YYYY/MM/DD。\n\n  返回:\n  - Ok(usize): 如果日期有效，则返回一年中的第几天作为数字。\n  - Err(String): 如果日期无效，则返回错误信息。\n\n  示例:\n  - day_of_year(\"1985/1/20\") 返回 Ok(20)\n  - day_of_year(\"2006/3/12\") 返回 Ok(71)\n  - day_of_year(\"2024/2/30\") 返回 Err(\"Invalid\")",
      "fr": "Calcule le jour de l'année pour une date donnée sous la forme AAAA/MM/JJ.\n\n  Arguments:\n  - date: Une chaîne de caractères représentant une date au format AAAA/MM/JJ.\n\n  Retourne:\n  - Ok(usize): Le jour de l'année en tant que nombre si la date est valide.\n  - Err(String): Un message d'erreur si la date est invalide.\n\n  Exemple:\n  - day_of_year(\"1985/1/20\") retourne Ok(20)\n  - day_of_year(\"2006/3/12\") retourne Ok(71)\n  - day_of_year(\"2024/2/30\") retourne Err(\"Invalid\")",
      "de": "Berechnet den Tag des Jahres für einen gegebenen Datumsstring im Format YYYY/MM/DD.\n\n  Argumente:\n  - date: Ein String, der ein Datum im Format YYYY/MM/DD darstellt.\n\n  Rückgaben:\n  - Ok(usize): Der Tag des Jahres als Zahl, wenn das Datum gültig ist.\n  - Err(String): Eine Fehlermeldung, wenn das Datum ungültig ist.\n\n  Beispiel:\n  - day_of_year(\"1985/1/20\") gibt Ok(20) zurück\n  - day_of_year(\"2006/3/12\") gibt Ok(71) zurück\n  - day_of_year(\"2024/2/30\") gibt Err(\"Invalid\") zurück",
      "ha": "Lissafa ranar shekara don takamaiman kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Huɗɗa:\n  - date: Wani kirtani da ke wakiltar kwanan wata a cikin tsarin YYYY/MM/DD.\n\n  Mayarwa:\n  - Ok(usize): Ranar shekara a matsayin lamba idan kwanan wata ya dace.\n  - Err(String): Saƙon kuskure idan kwanan wata ba daidai ba ne.\n\n  Misali:\n  - day_of_year(\"1985/1/20\") returns Ok(20)\n  - day_of_year(\"2006/3/12\") returns Ok(71)\n  - day_of_year(\"2024/2/30\") returns Err(\"Invalid\")",
      "hi": "दिए गए दिनांक स्ट्रिंग के लिए वर्ष का दिन गणना करता है, जो प्रारूप YYYY/MM/DD में है।\n\n  तर्क:\n  - date: YYYY/MM/DD प्रारूप में एक तिथि का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n\n  वापसी:\n  - Ok(usize): यदि तिथि मान्य है तो वर्ष का दिन एक संख्या के रूप में।\n  - Err(String): यदि तिथि अमान्य है तो एक त्रुटि संदेश।\n\n  उदाहरण:\n  - day_of_year(\"1985/1/20\") Ok(20) लौटाता है\n  - day_of_year(\"2006/3/12\") Ok(71) लौटाता है\n  - day_of_year(\"2024/2/30\") Err(\"Invalid\") लौटाता है",
      "hu": "Számítja az év napját egy adott dátum karakterlánc alapján, amely az YYYY/MM/DD formátumban van.\n\n  Argumentumok:\n  - date: Egy karakterlánc, amely egy dátumot reprezentál az YYYY/MM/DD formátumban.\n\n  Visszatér:\n  - Ok(usize): Az év napja számként, ha a dátum érvényes.\n  - Err(String): Hibaüzenet, ha a dátum érvénytelen.\n\n  Példa:\n  - day_of_year(\"1985/1/20\") visszatér Ok(20)\n  - day_of_year(\"2006/3/12\") visszatér Ok(71)\n  - day_of_year(\"2024/2/30\") visszatér Err(\"Invalid\")"
    },
    "docstring_bertscore": {
      "sq": "0.9972136130148426",
      "hy": "0.9708571491249423",
      "bn": "1",
      "bg": "0.984582508454453",
      "zh": "0.9475033807051463",
      "fr": "0.9888316095655514",
      "de": "0.9900257754163331",
      "ha": "0.9875820258384609",
      "hi": "0.9984407515088761",
      "hu": "0.9653278752080741"
    }
  },
  {
    "task_id": "Rust/28",
    "prompt": {
      "en": "/*\n  Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "sq": "/*\n  Heq numrat e përsëritur nga një vektor i dhënë dhe pastaj rendit numrat e mbetur në rend rritës.\n\n  Argumentet:\n  - numbers: Një vektor i numrave të plotë që variojnë nga 1 deri në 1000, me një gjatësi që nuk e kalon 100.\n\n  Kthen:\n  - Një vektor që përmban elementet unike të vektorit origjinal, të renditura në rend rritës.\n\n  Shembuj:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) kthen vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) kthen vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) kthen vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "hy": "/*\n  Հեռացնում է կրկնվող թվերը տրված վեկտորից, ապա մնացած թվերը դասավորում է աճման կարգով։\n\n  Արգումենտներ:\n  - numbers: Վեկտոր, որը պարունակում է ամբողջ թվեր 1-ից 1000 միջակայքում, և որի երկարությունը չի գերազանցում 100-ը։\n\n  Վերադարձնում է:\n  - Վեկտոր, որը պարունակում է սկզբնական վեկտորի եզակի տարրերը, դասավորված աճման կարգով։\n\n  Օրինակներ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) վերադարձնում է vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) վերադարձնում է vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) վերադարձնում է vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>",
      "bn": "/*\n  প্রদত্ত ভেক্টর থেকে সদৃশ সংখ্যা সরিয়ে ফেলুন এবং তারপর অবশিষ্ট সংখ্যাগুলোকে ঊর্ধ্বক্রমে সাজান।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: 1 থেকে 1000 এর মধ্যে পূর্ণসংখ্যার একটি ভেক্টর, যার দৈর্ঘ্য 100 অতিক্রম করবে না।\n\n  রিটার্নস:\n  - মূল ভেক্টরের অনন্য উপাদানগুলোকে ঊর্ধ্বক্রমে সাজানো একটি ভেক্টর।\n\n  উদাহরণসমূহ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "bg": "/*\n  Премахва дублиращите се числа от даден вектор и след това сортира останалите числа във възходящ ред.\n\n  Аргументи:\n  - numbers: Вектор от цели числа в диапазона от 1 до 1000, с дължина, която не надвишава 100.\n\n  Връща:\n  - Вектор, съдържащ уникалните елементи на оригиналния вектор, сортирани във възходящ ред.\n\n  Примери:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) връща vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) връща vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) връща vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "zh": "/*\n  从给定的向量中移除重复数字，然后将剩余数字按升序排序。\n\n  参数:\n  - numbers: 一个整数向量，范围从1到1000，长度不超过100。\n\n  返回:\n  - 一个包含原始向量中唯一元素的向量，按升序排序。\n\n  示例:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) 返回 vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) 返回 vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) 返回 vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "fr": "/*\n  Supprime les nombres dupliqués d'un vecteur donné, puis trie les nombres restants par ordre croissant.\n\n  Arguments :\n  - numbers : Un vecteur d'entiers allant de 1 à 1000, avec une longueur ne dépassant pas 100.\n\n  Renvoie :\n  - Un vecteur contenant les éléments uniques du vecteur original, triés par ordre croissant.\n\n  Exemples :\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "de": "/*\n  Entfernt doppelte Zahlen aus einem gegebenen Vektor und sortiert dann die verbleibenden Zahlen in aufsteigender Reihenfolge.\n\n  Argumente:\n  - numbers: Ein Vektor von ganzen Zahlen im Bereich von 1 bis 1000, mit einer Länge von höchstens 100.\n\n  Rückgabewerte:\n  - Ein Vektor, der die einzigartigen Elemente des ursprünglichen Vektors enthält, sortiert in aufsteigender Reihenfolge.\n\n  Beispiele:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) gibt vec![2, 3, 5] zurück\n  - dedup_and_sort(vec![7, 5, 7, 5]) gibt vec![5, 7] zurück\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) gibt vec![1, 2, 3, 4, 5] zurück\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "ha": "/*\n  Yana cire lambobi masu maimaituwa daga wani vector da aka bayar sannan yana tsara sauran lambobin a cikin tsari mai hawa.\n\n  Huɗɗa:\n  - numbers: Wani vector na lambobi masu ɗaukar daraja daga 1 zuwa 1000, tare da tsawon da bai wuce 100 ba.\n\n  Komawa:\n  - Wani vector da ke ɗauke da abubuwan da ba su maimaita ba na vector na asali, an tsara su a cikin tsari mai hawa.\n\n  Misalai:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "hi": "/*\n  दिए गए वेक्टर से डुप्लिकेट संख्याओं को हटाता है और फिर शेष संख्याओं को आरोही क्रम में क्रमबद्ध करता है।\n\n  तर्क:\n  - numbers: 1 से 1000 तक की पूर्णांकों का एक वेक्टर, जिसकी लंबाई 100 से अधिक नहीं है।\n\n  वापसी:\n  - मूल वेक्टर के अद्वितीय तत्वों वाला एक वेक्टर, जो आरोही क्रम में क्रमबद्ध है।\n\n  उदाहरण:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> ",
      "hu": "/*\n  Eltávolítja az ismétlődő számokat egy adott vektorból, majd a megmaradt számokat növekvő sorrendbe rendezi.\n\n  Argumentumok:\n  - numbers: Egy egész számokat tartalmazó vektor 1 és 1000 között, amelynek hossza nem haladja meg a 100-at.\n\n  Visszatér:\n  - Egy vektor, amely az eredeti vektor egyedi elemeit tartalmazza, növekvő sorrendben rendezve.\n\n  Példák:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]\n*/\n\nfn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32> "
    },
    "prompt_bertscore": {
      "sq": "0.9944891987085681",
      "hy": "0.9784968708403061",
      "bn": "0.9761119158552202",
      "bg": "0.9902796250432957",
      "zh": "0.9803320169306874",
      "fr": "0.9989619576287116",
      "de": "0.9708859505301923",
      "ha": "0.991220537158258",
      "hi": "0.9884849995506455",
      "hu": "0.9923396207250085"
    },
    "canonical_solution": "{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}",
    "instruction": {
      "en": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nՏրամադրել համառոտ բնական լեզվով նկարագրություն (docstring) այս Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nনিচের Rust কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\n请用最多500个字符的中文，对该Rust代码提供一个简洁的自然语言描述（文档字符串）。",
      "fr": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 अक्षर हों।",
      "hu": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>\n{\n    numbers.sort_unstable();\n    numbers.dedup();\n    numbers\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9232088988007692",
      "bn": "0.8706957931842895",
      "bg": "0.8316696904400789",
      "zh": "0.900946802955141",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9536426485221726",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(dedup_and_sort(vec![10, 20, 20, 10, 30]), vec![10, 20, 30]);\n        assert_eq!(dedup_and_sort(vec![5, 4, 3, 2, 1]), vec![1, 2, 3, 4, 5]);\n        assert_eq!(dedup_and_sort(vec![1, 1, 1, 1, 1]), vec![1]);\n        assert_eq!(dedup_and_sort(vec![50]), vec![50]);\n    }\n    \n\n}",
    "entry_point": "dedup_and_sort",
    "signature": "fn dedup_and_sort(mut numbers: Vec<i32>) -> Vec<i32>",
    "docstring": {
      "en": "Removes duplicate numbers from a given vector and then sorts the remaining numbers in ascending order.\n\n  Arguments:\n  - numbers: A vector of integers ranging from 1 to 1000, with a length not exceeding 100.\n\n  Returns:\n  - A vector containing the unique elements of the original vector, sorted in ascending order.\n\n  Examples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "sq": "Heq numrat e dyfishtë nga një vektor i dhënë dhe pastaj rendit numrat e mbetur në rend rritës.\n\n  Argumentet:\n  - numbers: Një vektor i numrave të plotë që variojnë nga 1 deri në 1000, me një gjatësi që nuk e kalon 100.\n\n  Kthen:\n  - Një vektor që përmban elementet unike të vektorit origjinal, të renditura në rend rritës.\n\n  Shembuj:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) kthen vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) kthen vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) kthen vec![1, 2, 3, 4, 5]",
      "hy": "Հեռացնում է կրկնվող թվերը տրված վեկտորից և ապա դասավորում մնացած թվերը աճման կարգով։\n\n  Արձանագրություններ:\n  - numbers: 1-ից մինչև 1000 միջակայքում գտնվող ամբողջ թվերի վեկտոր, որի երկարությունը չի գերազանցում 100-ը։\n\n  Վերադարձնում է:\n  - Վեկտոր, որը պարունակում է սկզբնական վեկտորի եզակի տարրերը, դասավորված աճման կարգով։\n\n  Օրինակներ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) վերադարձնում է vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) վերադարձնում է vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) վերադարձնում է vec![1, 2, 3, 4, 5]",
      "bn": "ডুপ্লিকেট সংখ্যা একটি প্রদত্ত ভেক্টর থেকে সরিয়ে দেয় এবং তারপর অবশিষ্ট সংখ্যাগুলি ঊর্ধ্বক্রমে সাজায়।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি ভেক্টর যা 1 থেকে 1000 এর মধ্যে রয়েছে, যার দৈর্ঘ্য 100 অতিক্রম করে না।\n\n  রিটার্নস:\n  - একটি ভেক্টর যা মূল ভেক্টরের অনন্য উপাদানগুলি ঊর্ধ্বক্রমে সাজানো অবস্থায় ধারণ করে।\n\n  উদাহরণসমূহ:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) রিটার্ন করে vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) রিটার্ন করে vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) রিটার্ন করে vec![1, 2, 3, 4, 5]",
      "bg": "Премахва дублиращите се числа от даден вектор и след това сортира останалите числа във възходящ ред.\n\n  Аргументи:\n  - numbers: Вектор от цели числа в диапазона от 1 до 1000, с дължина, която не надвишава 100.\n\n  Връща:\n  - Вектор, съдържащ уникалните елементи на оригиналния вектор, сортирани във възходящ ред.\n\n  Примери:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) връща vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) връща vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) връща vec![1, 2, 3, 4, 5]",
      "zh": "删除给定向量中的重复数字，然后将剩余数字按升序排序。\n\n  参数:\n  - numbers: 一个整数向量，范围从1到1000，长度不超过100。\n\n  返回值:\n  - 一个包含原始向量中唯一元素的向量，按升序排序。\n\n  示例:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) 返回 vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) 返回 vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) 返回 vec![1, 2, 3, 4, 5]",
      "fr": "Supprime les numéros en double d'un vecteur donné, puis trie les numéros restants par ordre croissant.\n\n  Arguments:\n  - numbers: Un vecteur d'entiers allant de 1 à 1000, avec une longueur ne dépassant pas 100.\n\n  Retourne:\n  - Un vecteur contenant les éléments uniques du vecteur original, triés par ordre croissant.\n\n  Exemples:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) retourne vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) retourne vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) retourne vec![1, 2, 3, 4, 5]",
      "de": "Entfernt doppelte Zahlen aus einem gegebenen Vektor und sortiert dann die verbleibenden Zahlen in aufsteigender Reihenfolge.\n\n  Argumente:\n  - numbers: Ein Vektor von ganzen Zahlen im Bereich von 1 bis 1000, mit einer Länge von maximal 100.\n\n  Rückgabewerte:\n  - Ein Vektor, der die einzigartigen Elemente des ursprünglichen Vektors enthält, sortiert in aufsteigender Reihenfolge.\n\n  Beispiele:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) gibt vec![2, 3, 5] zurück\n  - dedup_and_sort(vec![7, 5, 7, 5]) gibt vec![5, 7] zurück\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) gibt vec![1, 2, 3, 4, 5] zurück",
      "ha": "Yana cire lambobi masu maimaituwa daga wani vector da aka bayar sannan yana tsara sauran lambobin cikin tsari mai hawa.\n\n  Huɗɗa:\n  - numbers: Wani vector na lambobi masu ɗauke da ƙima daga 1 zuwa 1000, tare da tsawon da bai wuce 100 ba.\n\n  Dawowa:\n  - Wani vector da ke ɗauke da abubuwan da ba su maimaita ba na vector na asali, an jera su a cikin tsari mai hawa.\n\n  Misalai:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) returns vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) returns vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) returns vec![1, 2, 3, 4, 5]",
      "hi": "डुप्लिकेट संख्याओं को दिए गए वेक्टर से हटाता है और फिर शेष संख्याओं को आरोही क्रम में क्रमबद्ध करता है।\n\n  तर्क:\n  - numbers: पूर्णांकों का एक वेक्टर जो 1 से 1000 तक की सीमा में होता है, जिसकी लंबाई 100 से अधिक नहीं होती।\n\n  वापसी:\n  - मूल वेक्टर के अद्वितीय तत्वों वाला एक वेक्टर, जो आरोही क्रम में क्रमबद्ध होता है।\n\n  उदाहरण:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) vec![2, 3, 5] लौटाता है\n  - dedup_and_sort(vec![7, 5, 7, 5]) vec![5, 7] लौटाता है\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) vec![1, 2, 3, 4, 5] लौटाता है",
      "hu": "Eltávolítja az ismétlődő számokat egy adott vektorból, majd a megmaradt számokat növekvő sorrendbe rendezi.\n\n  Argumentumok:\n  - numbers: Egy 1-től 1000-ig terjedő egész számokat tartalmazó vektor, amelynek hossza nem haladja meg a 100-at.\n\n  Visszatérési érték:\n  - Egy vektor, amely az eredeti vektor egyedi elemeit tartalmazza, növekvő sorrendbe rendezve.\n\n  Példák:\n  - dedup_and_sort(vec![2, 3, 2, 5, 3]) visszaadja vec![2, 3, 5]\n  - dedup_and_sort(vec![7, 5, 7, 5]) visszaadja vec![5, 7]\n  - dedup_and_sort(vec![1, 2, 3, 4, 5]) visszaadja vec![1, 2, 3, 4, 5]"
    },
    "docstring_bertscore": {
      "sq": "0.9899487068284916",
      "hy": "0.9865231272771638",
      "bn": "0.9940593625640086",
      "bg": "0.9896372543910289",
      "zh": "0.9682066253204127",
      "fr": "0.998878532868677",
      "de": "0.969165016908906",
      "ha": "0.990566248683129",
      "hi": "0.996920037311673",
      "hu": "0.9917359829970435"
    }
  },
  {
    "task_id": "Rust/29",
    "prompt": {
      "en": "/*\n  Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "sq": "/*\n  Llogarit numrin e kombinimeve C(n, m), i cili përfaqëson numrin e mënyrave për të zgjedhur m elemente nga një grup prej n elementesh të dallueshme.\n\n  Argumentet:\n  - n: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin total të elementeve (n ≤ 20).\n  - m: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin e elementeve për të zgjedhur (m ≤ n).\n\n  Kthen:\n  - Numrin e kombinimeve C(n, m).\n\n  Shembull:\n  - calculate_combinations(5, 2) kthen 10\n  - calculate_combinations(18, 13) kthen 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "hy": "/*\n  Հաշվում է համակցությունների թիվը C(n, m), որը ներկայացնում է n տարբեր տարրերից m տարր ընտրելու եղանակների թիվը։\n\n  Արգումենտներ:\n  - n: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է տարրերի ընդհանուր քանակը (n ≤ 20)։\n  - m: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է ընտրելու տարրերի քանակը (m ≤ n)։\n\n  Վերադարձնում է:\n  - Համակցությունների թիվը C(n, m)։\n\n  Օրինակ:\n  - calculate_combinations(5, 2) վերադարձնում է 10\n  - calculate_combinations(18, 13) վերադարձնում է 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "bn": "/*\n  C(n, m) সংখ্যা গণনা করে, যা n পৃথক উপাদানের একটি সেট থেকে m উপাদান বেছে নেওয়ার উপায়ের সংখ্যা উপস্থাপন করে।\n\n  আর্গুমেন্ট:\n  - n: একটি 32-বিট স্বাক্ষরহীন পূর্ণসংখ্যা যা মোট উপাদানের সংখ্যা উপস্থাপন করে (n ≤ 20)।\n  - m: একটি 32-বিট স্বাক্ষরহীন পূর্ণসংখ্যা যা বেছে নেওয়ার উপাদানের সংখ্যা উপস্থাপন করে (m ≤ n)।\n\n  রিটার্নস:\n  - C(n, m) সংখ্যা।\n\n  উদাহরণ:\n  - calculate_combinations(5, 2) 10 রিটার্ন করে\n  - calculate_combinations(18, 13) 8568 রিটার্ন করে\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "bg": "/*\n  Изчислява числото на комбинациите C(n, m), което представлява броя начини за избиране на m елемента от множество от n различни елемента.\n\n  Аргументи:\n  - n: Неподписано 32-битово цяло число, представляващо общия брой елементи (n ≤ 20).\n  - m: Неподписано 32-битово цяло число, представляващо броя на елементите за избиране (m ≤ n).\n\n  Връща:\n  - Числото на комбинациите C(n, m).\n\n  Пример:\n  - calculate_combinations(5, 2) връща 10\n  - calculate_combinations(18, 13) връща 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "zh": "/*\n  计算组合数 C(n, m)，表示从 n 个不同元素的集合中选择 m 个元素的方法数。\n\n  参数:\n  - n: 一个无符号 32 位整数，表示元素的总数 (n ≤ 20)。\n  - m: 一个无符号 32 位整数，表示要选择的元素数量 (m ≤ n)。\n\n  返回:\n  - 组合数 C(n, m)。\n\n  示例:\n  - calculate_combinations(5, 2) 返回 10\n  - calculate_combinations(18, 13) 返回 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "fr": "/*\n  Calcule le nombre de combinaisons C(n, m), qui représente le nombre de façons de choisir m éléments parmi un ensemble de n éléments distincts.\n\n  Arguments :\n  - n : Un entier non signé de 32 bits représentant le nombre total d'éléments (n ≤ 20).\n  - m : Un entier non signé de 32 bits représentant le nombre d'éléments à choisir (m ≤ n).\n\n  Renvoie :\n  - Le nombre de combinaisons C(n, m).\n\n  Exemple :\n  - calculate_combinations(5, 2) renvoie 10\n  - calculate_combinations(18, 13) renvoie 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "de": "/*\n  Berechnet die Kombinationszahl C(n, m), die die Anzahl der Möglichkeiten darstellt, m Elemente aus einer Menge von n verschiedenen Elementen auszuwählen.\n\n  Argumente:\n  - n: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Gesamtanzahl der Elemente darstellt (n ≤ 20).\n  - m: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Anzahl der auszuwählenden Elemente darstellt (m ≤ n).\n\n  Rückgabewert:\n  - Die Kombinationszahl C(n, m).\n\n  Beispiel:\n  - calculate_combinations(5, 2) gibt 10 zurück\n  - calculate_combinations(18, 13) gibt 8568 zurück\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "ha": "/*\n  Lissafi adadin haɗuwa C(n, m), wanda ke wakiltar adadin hanyoyin zaɓar m abubuwa daga saitin abubuwa n daban-daban.\n\n  Huɗɗa:\n  - n: Baƙaƙen lamba 32-bit marasa alama wanda ke wakiltar jimlar adadin abubuwa (n ≤ 20).\n  - m: Baƙaƙen lamba 32-bit marasa alama wanda ke wakiltar adadin abubuwan da za a zaɓa (m ≤ n).\n\n  Dawowa:\n  - Lambar haɗuwa C(n, m).\n\n  Misali:\n  - calculate_combinations(5, 2) yana dawowa 10\n  - calculate_combinations(18, 13) yana dawowa 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "hi": "/*\n  संयोजन संख्या C(n, m) की गणना करता है, जो n भिन्न तत्वों के सेट से m तत्वों को चुनने के तरीकों की संख्या का प्रतिनिधित्व करता है।\n\n  तर्क:\n  - n: एक असाइन 32-बिट पूर्णांक जो कुल तत्वों की संख्या का प्रतिनिधित्व करता है (n ≤ 20)।\n  - m: एक असाइन 32-बिट पूर्णांक जो चुने जाने वाले तत्वों की संख्या का प्रतिनिधित्व करता है (m ≤ n)।\n\n  लौटाता है:\n  - संयोजन संख्या C(n, m)।\n\n  उदाहरण:\n  - calculate_combinations(5, 2) 10 लौटाता है\n  - calculate_combinations(18, 13) 8568 लौटाता है\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 ",
      "hu": "/*\n  Számítja a kombinációs számot C(n, m), amely azt jelenti, hogy hányféleképpen lehet m elemet kiválasztani n különböző elemből.\n\n  Argumentumok:\n  - n: Egy 32 bites előjelnélküli egész szám, amely az elemek teljes számát jelenti (n ≤ 20).\n  - m: Egy 32 bites előjelnélküli egész szám, amely a kiválasztandó elemek számát jelenti (m ≤ n).\n\n  Visszatér:\n  - A kombinációs szám C(n, m).\n\n  Példa:\n  - calculate_combinations(5, 2) visszaadja 10\n  - calculate_combinations(18, 13) visszaadja 8568\n*/\n\nfn calculate_combinations(n: u32, m: u32) -> u64 "
    },
    "prompt_bertscore": {
      "sq": "0.9697823601331624",
      "hy": "0.960556574825235",
      "bn": "0.983762760871922",
      "bg": "0.9680127620685226",
      "zh": "0.9844504192510648",
      "fr": "0.9792564334173836",
      "de": "0.986831202998149",
      "ha": "0.9679478099339243",
      "hi": "0.991966791499806",
      "hu": "0.9646185661173985"
    },
    "canonical_solution": "{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}",
    "instruction": {
      "en": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nՏվեք կարճ բնութագիր (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nПредоставете кратко описание на Rust кода на български език, като използвате максимум 500 знака.",
      "zh": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn calculate_combinations(n: u32, m: u32) -> u64\n{\n    if m > n {\n        return 0;\n    }\n\n    let mut result = 1u64;\n    for i in 0..m {\n        result = result * (n - i) as u64 / (i + 1) as u64;\n    }\n\n    result\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.8870448612168901",
      "bn": "0.8772950889637926",
      "bg": "0.8449290628956817",
      "zh": "0.856169158897684",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9230891246810051",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_combinations(5, 2), 10);\n        assert_eq!(calculate_combinations(18, 13), 8568);\n        assert_eq!(calculate_combinations(10, 0), 1);\n        assert_eq!(calculate_combinations(20, 20), 1);\n        assert_eq!(calculate_combinations(15, 5), 3003);\n    }\n    \n\n}",
    "entry_point": "calculate_combinations",
    "signature": "fn calculate_combinations(n: u32, m: u32) -> u64",
    "docstring": {
      "en": "Computes the combination number C(n, m), which represents the number of ways to choose m elements from a set of n distinct elements.\n\n  Arguments:\n  - n: An unsigned 32-bit integer representing the total number of elements (n ≤ 20).\n  - m: An unsigned 32-bit integer representing the number of elements to choose (m ≤ n).\n\n  Returns:\n  - The combination number C(n, m).\n\n  Example:\n  - calculate_combinations(5, 2) returns 10\n  - calculate_combinations(18, 13) returns 8568",
      "sq": "Llogarit numrin e kombinimeve C(n, m), i cili përfaqëson numrin e mënyrave për të zgjedhur m elemente nga një grup prej n elementesh të dallueshme.\n\n  Argumentet:\n  - n: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin total të elementeve (n ≤ 20).\n  - m: Një numër i plotë 32-bitësh pa shenjë që përfaqëson numrin e elementeve për të zgjedhur (m ≤ n).\n\n  Kthen:\n  - Numrin e kombinimeve C(n, m).\n\n  Shembull:\n  - calculate_combinations(5, 2) kthen 10\n  - calculate_combinations(18, 13) kthen 8568",
      "hy": "Հաշվում է համակցման թիվը C(n, m), որը ներկայացնում է n տարբեր տարրերից m տարր ընտրելու եղանակների քանակը։\n\n  Արգումենտներ:\n  - n: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է տարրերի ընդհանուր քանակը (n ≤ 20)։\n  - m: Անստորագիր 32-բիթանոց ամբողջ թիվ, որը ներկայացնում է ընտրելու տարրերի քանակը (m ≤ n)։\n\n  Վերադարձնում է:\n  - Համակցման թիվը C(n, m)։\n\n  Օրինակ:\n  - calculate_combinations(5, 2) վերադարձնում է 10\n  - calculate_combinations(18, 13) վերադարձնում է 8568",
      "bn": "সংযুক্তি সংখ্যা C(n, m) গণনা করে, যা n ভিন্ন উপাদান থেকে m উপাদান বেছে নেওয়ার উপায়ের সংখ্যা উপস্থাপন করে।\n\n  আর্গুমেন্টসমূহ:\n  - n: একটি অপরিবর্তনীয় ৩২-বিট পূর্ণসংখ্যা যা মোট উপাদানের সংখ্যা উপস্থাপন করে (n ≤ 20)।\n  - m: একটি অপরিবর্তনীয় ৩২-বিট পূর্ণসংখ্যা যা বেছে নেওয়ার উপাদানের সংখ্যা উপস্থাপন করে (m ≤ n)।\n\n  রিটার্নস:\n  - সংযুক্তি সংখ্যা C(n, m)।\n\n  উদাহরণ:\n  - calculate_combinations(5, 2) 10 রিটার্ন করে\n  - calculate_combinations(18, 13) 8568 রিটার্ন করে",
      "bg": "Изчислява числото на комбинациите C(n, m), което представлява броя начини да се изберат m елемента от множество с n различни елемента.\n\n  Аргументи:\n  - n: Неподписано 32-битово цяло число, представляващо общия брой елементи (n ≤ 20).\n  - m: Неподписано 32-битово цяло число, представляващо броя елементи, които да се изберат (m ≤ n).\n\n  Връща:\n  - Числото на комбинациите C(n, m).\n\n  Пример:\n  - calculate_combinations(5, 2) връща 10\n  - calculate_combinations(18, 13) връща 8568",
      "zh": "计算组合数 C(n, m)，表示从 n 个不同元素的集合中选择 m 个元素的方法数。\n\n  参数:\n  - n: 一个无符号 32 位整数，表示元素的总数 (n ≤ 20)。\n  - m: 一个无符号 32 位整数，表示要选择的元素数量 (m ≤ n)。\n\n  返回:\n  - 组合数 C(n, m)。\n\n  示例:\n  - calculate_combinations(5, 2) 返回 10\n  - calculate_combinations(18, 13) 返回 8568",
      "fr": "Calcule le nombre de combinaisons C(n, m), qui représente le nombre de façons de choisir m éléments parmi un ensemble de n éléments distincts.\n\n  Arguments:\n  - n: Un entier non signé de 32 bits représentant le nombre total d'éléments (n ≤ 20).\n  - m: Un entier non signé de 32 bits représentant le nombre d'éléments à choisir (m ≤ n).\n\n  Retourne:\n  - Le nombre de combinaisons C(n, m).\n\n  Exemple:\n  - calculate_combinations(5, 2) retourne 10\n  - calculate_combinations(18, 13) retourne 8568",
      "de": "Berechnet die Kombinationszahl C(n, m), die die Anzahl der Möglichkeiten darstellt, m Elemente aus einer Menge von n verschiedenen Elementen auszuwählen.\n\n  Argumente:\n  - n: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Gesamtanzahl der Elemente darstellt (n ≤ 20).\n  - m: Eine 32-Bit-Ganzzahl ohne Vorzeichen, die die Anzahl der auszuwählenden Elemente darstellt (m ≤ n).\n\n  Rückgabewert:\n  - Die Kombinationszahl C(n, m).\n\n  Beispiel:\n  - calculate_combinations(5, 2) gibt 10 zurück\n  - calculate_combinations(18, 13) gibt 8568 zurück",
      "ha": "Yana ƙididdige adadin haɗuwa C(n, m), wanda ke wakiltar yawan hanyoyin zaɓar abubuwa m daga saitin abubuwa n na musamman.\n\n  Huɗa:\n  - n: Baƙaƙen lamba 32-bit wanda ke wakiltar jimlar yawan abubuwa (n ≤ 20).\n  - m: Baƙaƙen lamba 32-bit wanda ke wakiltar yawan abubuwan da za a zaɓa (m ≤ n).\n\n  Komawa:\n  - Lambar haɗuwa C(n, m).\n\n  Misali:\n  - calculate_combinations(5, 2) yana dawowa 10\n  - calculate_combinations(18, 13) yana dawowa 8568",
      "hi": "संयोजन संख्या C(n, m) की गणना करता है, जो n भिन्न तत्वों के सेट से m तत्वों को चुनने के तरीकों की संख्या का प्रतिनिधित्व करता है।\n\n  तर्क:\n  - n: एक असाइन 32-बिट पूर्णांक जो कुल तत्वों की संख्या का प्रतिनिधित्व करता है (n ≤ 20)।\n  - m: एक असाइन 32-बिट पूर्णांक जो चुने जाने वाले तत्वों की संख्या का प्रतिनिधित्व करता है (m ≤ n)।\n\n  लौटाता है:\n  - संयोजन संख्या C(n, m)।\n\n  उदाहरण:\n  - calculate_combinations(5, 2) 10 लौटाता है\n  - calculate_combinations(18, 13) 8568 लौटाता है",
      "hu": "Kiszámítja a C(n, m) kombinációs számot, amely azt jelenti, hogy hányféleképpen lehet m elemet kiválasztani egy n különböző elemből álló halmazból.\n\n  Argumentumok:\n  - n: Egy 32 bites előjelnélküli egész szám, amely az elemek teljes számát jelöli (n ≤ 20).\n  - m: Egy 32 bites előjelnélküli egész szám, amely a kiválasztandó elemek számát jelöli (m ≤ n).\n\n  Visszatér:\n  - A C(n, m) kombinációs szám.\n\n  Példa:\n  - calculate_combinations(5, 2) visszaadja 10\n  - calculate_combinations(18, 13) visszaadja 8568"
    },
    "docstring_bertscore": {
      "sq": "0.9669933909530516",
      "hy": "0.963562647011817",
      "bn": "0.9640266475819145",
      "bg": "0.9537467308418349",
      "zh": "0.9793031115569267",
      "fr": "0.9736773032748756",
      "de": "0.9795140570215858",
      "ha": "0.9512515359952747",
      "hi": "0.9740527146950315",
      "hu": "0.9351602901972573"
    }
  },
  {
    "task_id": "Rust/30",
    "prompt": {
      "en": "/*\n  Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "sq": "/*\n  Përcakton nëse Yuanzi mund të fitojë një garë me kuaj kundër një kundërshtari duke rregulluar në mënyrë optimale kuajt e tij.\n\n  Funksioni krahason shpejtësitë e kuajve të Yuanzi-t me ato të kuajve të kundërshtarit. Çdo kalë ka një shpejtësi të caktuar dhe nuk ka barazime. Yuanzi fiton nëse fiton më shumë se gjysmën e garave individuale.\n\n  Argumentet:\n  - yuanzi_horses: Një varg i numrave të plotë që përfaqësojnë shpejtësitë e kuajve të Yuanzi-t.\n  - opponent_horses: Një varg i numrave të plotë që përfaqësojnë shpejtësitë e kuajve të kundërshtarit.\n\n  Kthen:\n  - Një vlerë boolean: `true` nëse Yuanzi mund të fitojë garën, `false` përndryshe.\n\n  Shembuj:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) kthen true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) kthen false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "hy": "/*\n  Որոշում է՝ արդյոք Յուանցին կարող է հաղթել ձիարշավում մրցակցի դեմ՝ իր ձիերին օպտիմալ դասավորելով:\n\n  Ֆունկցիան համեմատում է Յուանցիի ձիերի արագությունները մրցակցի ձիերի արագությունների հետ: Յուրաքանչյուր ձի ունի հաստատուն արագություն և ոչ մի հավասարություն չկա: Յուանցին հաղթում է, եթե նա հաղթում է անհատական մրցավազքերի կեսից ավելիում:\n\n  Արգումենտներ:\n  - yuanzi_horses: Թվերի զանգված, որը ներկայացնում է Յուանցիի ձիերի արագությունները:\n  - opponent_horses: Թվերի զանգված, որը ներկայացնում է մրցակցի ձիերի արագությունները:\n\n  Վերադարձնում է:\n  - Բուլյան արժեք: `true`, եթե Յուանցին կարող է հաղթել մրցավազքում, `false`՝ հակառակ դեպքում:\n\n  Օրինակներ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) վերադարձնում է true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) վերադարձնում է false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "bn": "/*\n  ইউয়ানজি তার ঘোড়াগুলিকে সঠিকভাবে সাজিয়ে প্রতিপক্ষের বিরুদ্ধে ঘোড়দৌড়ে জিততে পারে কিনা তা নির্ধারণ করে।\n\n  ফাংশনটি ইউয়ানজির ঘোড়াগুলির গতি প্রতিপক্ষের ঘোড়াগুলির গতির সাথে তুলনা করে। প্রতিটি ঘোড়ার একটি নির্দিষ্ট গতি থাকে এবং কোন টাই হয় না। ইউয়ানজি জিতবে যদি সে অর্ধেকের বেশি ব্যক্তিগত দৌড়ে জেতে।\n\n  আর্গুমেন্টসমূহ:\n  - yuanzi_horses: ইউয়ানজির ঘোড়াগুলির গতির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n  - opponent_horses: প্রতিপক্ষের ঘোড়াগুলির গতির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n\n  রিটার্ন করে:\n  - একটি বুলিয়ান মান: `true` যদি ইউয়ানজি দৌড় জিততে পারে, অন্যথায় `false`।\n\n  উদাহরণসমূহ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) রিটার্ন করে true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) রিটার্ন করে false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool",
      "bg": "/*\n  Определя дали Юанзи може да спечели конно състезание срещу противник, като оптимално подреди своите коне.\n\n  Функцията сравнява скоростите на конете на Юанзи със скоростите на конете на противника. Всеки кон има фиксирана скорост и няма равенства. Юанзи печели, ако спечели повече от половината от индивидуалните състезания.\n\n  Аргументи:\n  - yuanzi_horses: Масив от цели числа, представляващи скоростите на конете на Юанзи.\n  - opponent_horses: Масив от цели числа, представляващи скоростите на конете на противника.\n\n  Връща:\n  - Булева стойност: `true`, ако Юанзи може да спечели състезанието, `false` в противен случай.\n\n  Примери:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) връща true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) връща false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "zh": "/*\n  判断元子是否可以通过最佳安排他的马匹赢得赛马比赛。\n\n  该函数比较元子的马匹速度与对手马匹速度。每匹马都有固定的速度，且没有平局。如果元子赢得超过一半的单场比赛，他就获胜。\n\n  参数:\n  - yuanzi_horses: 一个整数数组，表示元子马匹的速度。\n  - opponent_horses: 一个整数数组，表示对手马匹的速度。\n\n  返回:\n  - 一个布尔值：如果元子可以赢得比赛，返回 `true`，否则返回 `false`。\n\n  示例:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) 返回 true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) 返回 false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "fr": "/*\n  Détermine si Yuanzi peut gagner une course de chevaux contre un adversaire en arrangeant de manière optimale ses chevaux.\n\n  La fonction compare les vitesses des chevaux de Yuanzi à celles des chevaux de l'adversaire. Chaque cheval a une vitesse fixe et il n'y a pas d'égalité. Yuanzi gagne s'il remporte plus de la moitié des courses individuelles.\n\n  Arguments :\n  - yuanzi_horses : Un tableau d'entiers représentant les vitesses des chevaux de Yuanzi.\n  - opponent_horses : Un tableau d'entiers représentant les vitesses des chevaux de l'adversaire.\n\n  Renvoie :\n  - Une valeur booléenne : `true` si Yuanzi peut gagner la course, `false` sinon.\n\n  Exemples :\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) renvoie true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) renvoie false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "de": "/*\n  Bestimmt, ob Yuanzi ein Pferderennen gegen einen Gegner gewinnen kann, indem er seine Pferde optimal anordnet.\n\n  Die Funktion vergleicht die Geschwindigkeiten von Yuanzis Pferden mit denen der gegnerischen Pferde. Jedes Pferd hat eine feste Geschwindigkeit und es gibt keine Unentschieden. Yuanzi gewinnt, wenn er mehr als die Hälfte der Einzelrennen gewinnt.\n\n  Argumente:\n  - yuanzi_horses: Ein Array von ganzen Zahlen, das die Geschwindigkeiten von Yuanzis Pferden darstellt.\n  - opponent_horses: Ein Array von ganzen Zahlen, das die Geschwindigkeiten der gegnerischen Pferde darstellt.\n\n  Rückgabewert:\n  - Ein boolescher Wert: `true`, wenn Yuanzi das Rennen gewinnen kann, `false` andernfalls.\n\n  Beispiele:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) gibt true zurück\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) gibt false zurück\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "ha": "/*\n  Yana tantance ko Yuanzi zai iya cin tseren doki da abokin hamayya ta hanyar tsara dokinsa yadda ya dace.\n\n  Aikin yana kwatanta saurin dokin Yuanzi da na dokin abokin hamayya. Kowanne doki yana da saurin da aka kayyade kuma babu daidaito. Yuanzi yana cin nasara idan ya ci fiye da rabin tseren mutum daya.\n\n  Huɗɗa:\n  - yuanzi_horses: Jerin lambobi da ke wakiltar saurin dokin Yuanzi.\n  - opponent_horses: Jerin lambobi da ke wakiltar saurin dokin abokin hamayya.\n\n  Mayarwa:\n  - Ƙimar boolean: `true` idan Yuanzi zai iya cin tseren, `false` in ba haka ba.\n\n  Misalai:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "hi": "/*\n  यह निर्धारित करता है कि क्या युआन्ज़ी अपने घोड़ों को सही ढंग से व्यवस्थित करके एक घुड़दौड़ में प्रतिद्वंद्वी को हरा सकता है।\n\n  यह फ़ंक्शन युआन्ज़ी के घोड़ों की गति की तुलना प्रतिद्वंद्वी के घोड़ों की गति से करता है। प्रत्येक घोड़े की एक निश्चित गति होती है और कोई टाई नहीं होती। युआन्ज़ी जीतता है यदि वह आधे से अधिक व्यक्तिगत दौड़ जीतता है।\n\n  तर्क:\n  - yuanzi_horses: युआन्ज़ी के घोड़ों की गति का प्रतिनिधित्व करने वाली पूर्णांकों की एक श्रृंखला।\n  - opponent_horses: प्रतिद्वंद्वी के घोड़ों की गति का प्रतिनिधित्व करने वाली पूर्णांकों की एक श्रृंखला।\n\n  लौटाता है:\n  - एक बूलियन मान: `true` यदि युआन्ज़ी दौड़ जीत सकता है, अन्यथा `false`।\n\n  उदाहरण:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool ",
      "hu": "/*\n  Meghatározza, hogy Yuanzi meg tudja-e nyerni a lóversenyt egy ellenféllel szemben azáltal, hogy optimálisan rendezi a lovait.\n\n  A függvény összehasonlítja Yuanzi lovainak sebességét az ellenfél lovainak sebességével. Minden lónak fix sebessége van, és nincs döntetlen. Yuanzi nyer, ha több mint a versenyek felét megnyeri.\n\n  Argumentumok:\n  - yuanzi_horses: Egész számokat tartalmazó tömb, amely Yuanzi lovainak sebességét reprezentálja.\n  - opponent_horses: Egész számokat tartalmazó tömb, amely az ellenfél lovainak sebességét reprezentálja.\n\n  Visszatérési érték:\n  - Egy logikai érték: `true`, ha Yuanzi meg tudja nyerni a versenyt, `false` egyébként.\n\n  Példák:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) visszaadja true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) visszaadja false\n*/\n\nfn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool "
    },
    "prompt_bertscore": {
      "sq": "0.997654373830359",
      "hy": "0.9885306845382835",
      "bn": "0.9649741144994509",
      "bg": "0.9943074519099211",
      "zh": "0.9590374496710802",
      "fr": "1",
      "de": "0.9963350708395253",
      "ha": "0.9593399637413963",
      "hi": "0.9785038229036424",
      "hu": "0.9876128135475213"
    },
    "canonical_solution": "{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}",
    "instruction": {
      "en": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) տվյալ Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nরাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nBa da taƙaitaccen bayanin yaren ɗan adam (docstring) na lambar Rust cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nरस्ट कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों का उपयोग करके प्रदान करें।",
      "hu": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool\n{\n    let mut yuanzi_horses = yuanzi_horses.to_vec();\n    let mut opponent_horses = opponent_horses.to_vec();\n    yuanzi_horses.sort_unstable();\n    opponent_horses.sort_unstable();\n\n    let mut yuanzi_points = 0;\n\n    for &yuanzi_speed in &yuanzi_horses {\n        if let Some(pos) = opponent_horses.iter().position(|&op_speed| yuanzi_speed > op_speed) {\n            yuanzi_points += 1;\n            opponent_horses.remove(pos);\n        }\n    }\n\n    yuanzi_points > yuanzi_horses.len() / 2\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9143235659659354",
      "bn": "0.9217916710320851",
      "bg": "0.8316696904400789",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.8874460945865806",
      "hi": "0.961450411539892",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]), true);\n        assert_eq!(can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]), false);\n    }\n    \n\n}",
    "entry_point": "can_win_horse_race",
    "signature": "fn can_win_horse_race(yuanzi_horses: &[i32], opponent_horses: &[i32]) -> bool",
    "docstring": {
      "en": "Determines if Yuanzi can win a horse race against an opponent by optimally arranging his horses.\n\n  The function compares the speeds of Yuanzi's horses to those of the opponent's horses. Each horse has a fixed speed and there are no ties. Yuanzi wins if he wins more than half of the individual races.\n\n  Arguments:\n  - yuanzi_horses: An array of integers representing the speeds of Yuanzi's horses.\n  - opponent_horses: An array of integers representing the speeds of the opponent's horses.\n\n  Returns:\n  - A boolean value: `true` if Yuanzi can win the race, `false` otherwise.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "sq": "Determinon nëse Yuanzi mund të fitojë një garë kuajsh kundër një kundërshtari duke rregulluar në mënyrë optimale kuajt e tij.\n\n  Funksioni krahason shpejtësitë e kuajve të Yuanzi me ato të kuajve të kundërshtarit. Çdo kalë ka një shpejtësi të fiksuar dhe nuk ka barazime. Yuanzi fiton nëse fiton më shumë se gjysmën e garave individuale.\n\n  Argumentet:\n  - yuanzi_horses: Një varg me numra të plotë që përfaqëson shpejtësitë e kuajve të Yuanzi.\n  - opponent_horses: Një varg me numra të plotë që përfaqëson shpejtësitë e kuajve të kundërshtarit.\n\n  Kthen:\n  - Një vlerë boolean: `true` nëse Yuanzi mund të fitojë garën, `false` përndryshe.\n\n  Shembuj:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) kthen true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) kthen false",
      "hy": "Սահմանում է՝ արդյոք Յուանցին կարող է հաղթել ձիարշավում մրցակցի դեմ՝ օպտիմալ կերպով դասավորելով իր ձիերին։\n\n  Ֆունկցիան համեմատում է Յուանցիի ձիերի արագությունները մրցակցի ձիերի արագությունների հետ։ Յուրաքանչյուր ձի ունի ֆիքսված արագություն և ոչ մի հավասարություն չկա։ Յուանցին հաղթում է, եթե նա հաղթում է անհատական մրցավազքերի կեսից ավելին։\n\n  Արգումենտներ:\n  - yuanzi_horses: ամբողջ թվերի զանգված, որը ներկայացնում է Յուանցիի ձիերի արագությունները։\n  - opponent_horses: ամբողջ թվերի զանգված, որը ներկայացնում է մրցակցի ձիերի արագությունները։\n\n  Վերադարձնում է:\n  - Բուլյան արժեք՝ `true`, եթե Յուանցին կարող է հաղթել մրցավազքը, `false`՝ հակառակ դեպքում։\n\n  Օրինակներ:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) վերադարձնում է true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) վերադարձնում է false",
      "bn": "Yuanzi তার ঘোড়াগুলিকে যথাযথভাবে সাজিয়ে প্রতিপক্ষের বিরুদ্ধে ঘোড়দৌড় জিততে পারে কিনা তা নির্ধারণ করে।\n\n  ফাংশনটি Yuanzi এর ঘোড়াগুলির গতি প্রতিপক্ষের ঘোড়াগুলির গতির সাথে তুলনা করে। প্রতিটি ঘোড়ার একটি নির্দিষ্ট গতি থাকে এবং কোনো সমতা নেই। Yuanzi জিতবে যদি সে অর্ধেকের বেশি ব্যক্তিগত দৌড়ে জেতে।\n\n  Arguments:\n  - yuanzi_horses: Yuanzi এর ঘোড়াগুলির গতির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n  - opponent_horses: প্রতিপক্ষের ঘোড়াগুলির গতির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n\n  Returns:\n  - একটি বুলিয়ান মান: `true` যদি Yuanzi দৌড় জিততে পারে, অন্যথায় `false`।\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "bg": "Определя дали Юанзи може да спечели конно състезание срещу противник, като оптимално подреди своите коне.\n\nФункцията сравнява скоростите на конете на Юанзи с тези на конете на противника. Всеки кон има фиксирана скорост и няма равенства. Юанзи печели, ако спечели повече от половината от индивидуалните състезания.\n\nАргументи:\n- yuanzi_horses: Масив от цели числа, представляващи скоростите на конете на Юанзи.\n- opponent_horses: Масив от цели числа, представляващи скоростите на конете на противника.\n\nВръща:\n- Булева стойност: `true`, ако Юанзи може да спечели състезанието, `false` в противен случай.\n\nПримери:\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) връща true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) връща false",
      "zh": "确定元子是否可以通过最佳安排他的马匹赢得赛马。\n\n该函数比较元子的马匹速度与对手马匹速度。每匹马都有固定速度，且没有平局。如果元子赢得超过一半的单场比赛，他就获胜。\n\n参数：\n- yuanzi_horses: 一个整数数组，表示元子马匹的速度。\n- opponent_horses: 一个整数数组，表示对手马匹的速度。\n\n返回：\n- 一个布尔值：如果元子可以赢得比赛，返回 `true`，否则返回 `false`。\n\n示例：\n- can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) 返回 true\n- can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) 返回 false",
      "fr": "Détermine si Yuanzi peut gagner une course de chevaux contre un adversaire en arrangeant de manière optimale ses chevaux.\n\n  La fonction compare les vitesses des chevaux de Yuanzi à celles des chevaux de l'adversaire. Chaque cheval a une vitesse fixe et il n'y a pas d'égalité. Yuanzi gagne s'il remporte plus de la moitié des courses individuelles.\n\n  Arguments:\n  - yuanzi_horses: Un tableau d'entiers représentant les vitesses des chevaux de Yuanzi.\n  - opponent_horses: Un tableau d'entiers représentant les vitesses des chevaux de l'adversaire.\n\n  Renvoie:\n  - Une valeur booléenne: `true` si Yuanzi peut gagner la course, `false` sinon.\n\n  Exemples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) renvoie true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) renvoie false",
      "de": "Bestimmt, ob Yuanzi ein Pferderennen gegen einen Gegner gewinnen kann, indem er seine Pferde optimal anordnet.\n\n  Die Funktion vergleicht die Geschwindigkeiten von Yuanzis Pferden mit denen der Pferde des Gegners. Jedes Pferd hat eine feste Geschwindigkeit und es gibt keine Unentschieden. Yuanzi gewinnt, wenn er mehr als die Hälfte der einzelnen Rennen gewinnt.\n\n  Argumente:\n  - yuanzi_horses: Ein Array von ganzen Zahlen, das die Geschwindigkeiten von Yuanzis Pferden darstellt.\n  - opponent_horses: Ein Array von ganzen Zahlen, das die Geschwindigkeiten der Pferde des Gegners darstellt.\n\n  Rückgabewerte:\n  - Ein boolescher Wert: `true`, wenn Yuanzi das Rennen gewinnen kann, `false` andernfalls.\n\n  Beispiele:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) gibt true zurück\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) gibt false zurück",
      "ha": "Yana tantance ko Yuanzi zai iya cin gasa tseren doki da abokin hamayya ta hanyar tsara dokinsa cikin hikima.\n\n  Aikin yana kwatanta saurin dawakan Yuanzi da na abokin hamayyarsa. Kowane doki yana da sauri mai tsayi kuma babu daidaito. Yuanzi yana cin nasara idan ya ci fiye da rabin tseren guda.\n\n  Arguments:\n  - yuanzi_horses: Jeri na lambobi da ke wakiltar saurin dawakan Yuanzi.\n  - opponent_horses: Jeri na lambobi da ke wakiltar saurin dawakan abokin hamayya.\n\n  Returns:\n  - Kima na boolean: `true` idan Yuanzi zai iya cin nasarar tseren, `false` in ba haka ba.\n\n  Examples:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) returns true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) returns false",
      "hi": "Yuanzi यह निर्धारित करता है कि वह अपने घोड़ों को सही ढंग से व्यवस्थित करके एक प्रतिद्वंद्वी के खिलाफ घुड़दौड़ जीत सकता है या नहीं।\n\n  फ़ंक्शन Yuanzi के घोड़ों की गति की तुलना प्रतिद्वंद्वी के घोड़ों की गति से करता है। प्रत्येक घोड़े की एक निश्चित गति होती है और कोई टाई नहीं होती। Yuanzi जीतता है यदि वह व्यक्तिगत दौड़ों में से आधे से अधिक जीतता है।\n\n  तर्क:\n  - yuanzi_horses: Yuanzi के घोड़ों की गति का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी।\n  - opponent_horses: प्रतिद्वंद्वी के घोड़ों की गति का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी।\n\n  लौटाता है:\n  - एक boolean मान: `true` यदि Yuanzi दौड़ जीत सकता है, अन्यथा `false`।\n\n  उदाहरण:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) true लौटाता है\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) false लौटाता है",
      "hu": "Meghatározza, hogy Yuanzi meg tudja-e nyerni a lóversenyt egy ellenféllel szemben azáltal, hogy optimálisan rendezi el a lovait.\n\n  A függvény összehasonlítja Yuanzi lovainak sebességét az ellenfél lovainak sebességével. Minden lónak rögzített sebessége van, és nincs döntetlen. Yuanzi nyer, ha több mint a versenyek felét megnyeri.\n\n  Argumentumok:\n  - yuanzi_horses: Egész számokat tartalmazó tömb, amely Yuanzi lovainak sebességét jelöli.\n  - opponent_horses: Egész számokat tartalmazó tömb, amely az ellenfél lovainak sebességét jelöli.\n\n  Visszatérési érték:\n  - Egy logikai érték: `true`, ha Yuanzi meg tudja nyerni a versenyt, `false` egyébként.\n\n  Példák:\n  - can_win_horse_race(&[2, 3, 3, 4, 5], &[1, 2, 3, 4, 5]) visszaadja true\n  - can_win_horse_race(&[2, 2, 1, 2], &[2, 2, 3, 1]) visszaadja false"
    },
    "docstring_bertscore": {
      "sq": "0.999083916682667",
      "hy": "0.9893555965107214",
      "bn": "0.9770985129578205",
      "bg": "0.9931460600720101",
      "zh": "0.9564363848314283",
      "fr": "0.9925892991139693",
      "de": "0.9954535492084925",
      "ha": "0.970878601206094",
      "hi": "0.9828961365194668",
      "hu": "0.9858561264576488"
    }
  },
  {
    "task_id": "Rust/31",
    "prompt": {
      "en": "/*\n  Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin e mënyrave të ndryshme për të ngjitur një shkallë me një numër të caktuar hapash, ku në çdo hap, mund të ngjitesh ose një hap ose dy hapa. Fillon në nivelin 0.\n\n  Argumentet:\n  - stairs: Një numër i plotë që përfaqëson numrin e hapave në shkallë.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin e mënyrave të ndryshme për të ngjitur shkallën.\n\n  Shembull:\n  - count_ways_to_climb(2) kthen 2 (1 hap + 1 hap, 2 hapa)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "hy": "/*\n  Հաշվում է տարբեր եղանակների քանակը, որոնցով կարելի է բարձրանալ աստիճանների տրված քանակով աստիճանավանդակի վրա, որտեղ յուրաքանչյուր քայլում կարելի է բարձրանալ կամ մեկ քայլ կամ երկու քայլ: Դուք սկսում եք մակարդակ 0-ից:\n\n  Փաստարկներ:\n  - stairs: Ամբողջ թիվ, որը ներկայացնում է աստիճանավանդակի աստիճանների քանակը:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է տարբեր եղանակների քանակը, որոնցով կարելի է բարձրանալ աստիճանավանդակի վրա:\n\n  Օրինակ:\n  - count_ways_to_climb(2) վերադարձնում է 2 (1 քայլ + 1 քայլ, 2 քայլ)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "bn": "/*\n  একটি নির্দিষ্ট সংখ্যক ধাপের সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা গণনা করে, যেখানে প্রতিটি ধাপে, একজন হয় এক ধাপ বা দুই ধাপ উঠতে পারে। আপনি স্তর 0 থেকে শুরু করেন।\n\n  আর্গুমেন্ট:\n  - stairs: সিঁড়ির ধাপের সংখ্যা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n\n  রিটার্ন:\n  - সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা নির্দেশ করে এমন একটি পূর্ণসংখ্যা।\n\n  উদাহরণ:\n  - count_ways_to_climb(2) রিটার্ন করে 2 (1 ধাপ + 1 ধাপ, 2 ধাপ)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "bg": "/*\n  Изчислява броя на различните начини за изкачване на стълбище с даден брой стъпала, където на всяка стъпка може да се изкачат или едно, или две стъпала. Започвате от ниво 0.\n\n  Аргументи:\n  - stairs: Цяло число, представляващо броя на стъпалата в стълбището.\n\n  Връща:\n  - Цяло число, представляващо броя на различните начини за изкачване на стълбището.\n\n  Пример:\n  - count_ways_to_climb(2) връща 2 (1 стъпка + 1 стъпка, 2 стъпки)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "zh": "/*\n  计算爬楼梯的不同方式数量，对于给定的台阶数，每一步可以选择爬一个台阶或两个台阶。你从第0层开始。\n\n  参数:\n  - stairs: 一个整数，表示楼梯的台阶数。\n\n  返回:\n  - 一个整数，表示爬楼梯的不同方式数量。\n\n  示例:\n  - count_ways_to_climb(2) 返回 2 (1步 + 1步, 2步)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre de façons différentes de monter un escalier d'un nombre donné de marches, où à chaque marche, on peut soit monter d'une marche, soit de deux marches. Vous commencez au niveau 0.\n\n  Arguments:\n  - stairs: Un entier représentant le nombre de marches dans l'escalier.\n\n  Retourne:\n  - Un entier représentant le nombre de façons différentes de monter l'escalier.\n\n  Exemple:\n  - count_ways_to_climb(2) retourne 2 (1 marche + 1 marche, 2 marches)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "de": "/*\n  Berechnet die Anzahl der verschiedenen Möglichkeiten, eine Treppe mit einer bestimmten Anzahl von Stufen zu erklimmen, wobei man bei jedem Schritt entweder eine oder zwei Stufen steigen kann. Man beginnt auf Ebene 0.\n\n  Argumente:\n  - stairs: Eine ganze Zahl, die die Anzahl der Stufen in der Treppe darstellt.\n\n  Rückgabe:\n  - Eine ganze Zahl, die die Anzahl der verschiedenen Möglichkeiten darstellt, die Treppe zu erklimmen.\n\n  Beispiel:\n  - count_ways_to_climb(2) gibt 2 zurück (1 Schritt + 1 Schritt, 2 Schritte)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "ha": "/*\n  Lissafa adadin hanyoyi daban-daban don hawa matakala na adadin matakai da aka bayar, inda a kowane mataki, za a iya hawa mataki daya ko matakai biyu. Ka fara a matakin 0.\n\n  Huɗɗa:\n  - stairs: Wani cikakken lamba da ke wakiltar adadin matakan da ke cikin matakalar.\n\n  Komawa:\n  - Wani cikakken lamba da ke wakiltar adadin hanyoyi daban-daban don hawa matakalar.\n\n  Misali:\n  - count_ways_to_climb(2) yana dawowa da 2 (mataki 1 + mataki 1, matakai 2)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "hi": "/*\n  एक दी गई संख्या के सीढ़ियों को चढ़ने के विभिन्न तरीकों की गणना करता है, जहाँ प्रत्येक कदम पर, आप या तो एक कदम या दो कदम चढ़ सकते हैं। आप स्तर 0 से शुरू करते हैं।\n\n  तर्क:\n  - stairs: सीढ़ियों में कदमों की संख्या को दर्शाने वाला एक पूर्णांक।\n\n  वापसी:\n  - एक पूर्णांक जो सीढ़ियों को चढ़ने के विभिन्न तरीकों की संख्या को दर्शाता है।\n\n  उदाहरण:\n  - count_ways_to_climb(2) 2 लौटाता है (1 कदम + 1 कदम, 2 कदम)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja, hogy hány különböző módon lehet megmászni egy adott lépcsőfokszámú lépcsőt, ahol minden lépésnél vagy egy lépcsőt, vagy két lépcsőt lehet megmászni. A 0. szinten kezdünk.\n\n  Argumentumok:\n  - stairs: Egy egész szám, amely a lépcsőfokok számát jelöli a lépcsőn.\n\n  Visszatér:\n  - Egy egész szám, amely a lépcső megmászásának különböző módjainak számát jelöli.\n\n  Példa:\n  - count_ways_to_climb(2) visszaadja a 2-t (1 lépés + 1 lépés, 2 lépés)\n*/\n\n\nfn count_ways_to_climb(stairs: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9877391424698595",
      "hy": "0.9802273387198821",
      "bn": "0.9877891973258802",
      "bg": "0.9845926386038858",
      "zh": "0.942918395619718",
      "fr": "0.9959970019310039",
      "de": "0.9599181767805889",
      "ha": "0.9691697840380509",
      "hi": "0.9732850082723317",
      "hu": "0.973901556975064"
    },
    "canonical_solution": "{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}",
    "instruction": {
      "en": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\n请用中文为以下 Rust 代码提供简洁的自然语言描述（文档字符串），字数不超过 500 个字符。",
      "fr": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn count_ways_to_climb(stairs: i32) -> i32\n{\n    if stairs <= 1 {\n        return 1;\n    }\n\n    let mut ways = vec![0; (stairs + 1) as usize];\n    ways[1] = 1;\n    ways[2] = 2;\n\n    for i in 3..=stairs as usize {\n        ways[i] = ways[i - 1] + ways[i - 2];\n    }\n\n    ways[stairs as usize]\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9258661760382538",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8627098587147819",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9665526301375352",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n  \n    #[test]\n    fn main() {\n      \n        assert_eq!(count_ways_to_climb(2), 2); // 2 ways: (1+1), (2)\n        assert_eq!(count_ways_to_climb(3), 3); // 3 ways: (1+1+1), (1+2), (2+1)\n        assert_eq!(count_ways_to_climb(4), 5); // 5 ways: (1+1+1+1), (1+1+2), (1+2+1), (2+1+1), (2+2)\n        assert_eq!(count_ways_to_climb(10), 89); \n        assert_eq!(count_ways_to_climb(24), 75025); \n        println!(\"All test cases passed.\");\n    }\n    \n\n}",
    "entry_point": "count_ways_to_climb",
    "signature": "fn count_ways_to_climb(stairs: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of different ways to climb a staircase of a given number of steps, where at each step, one can either climb one step or two steps. You start at level 0.\n\n  Arguments:\n  - stairs: An integer representing the number of steps in the staircase.\n\n  Returns:\n  - An integer representing the number of different ways to climb the staircase.\n\n  Example:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)",
      "sq": "Llogarit numrin e mënyrave të ndryshme për të ngjitur një shkallë me një numër të caktuar hapash, ku në çdo hap, mund të ngjiteni ose një hap ose dy hapa. Ju filloni në nivelin 0.\n\n  Argumentet:\n  - stairs: Një numër i plotë që përfaqëson numrin e hapave në shkallë.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin e mënyrave të ndryshme për të ngjitur shkallën.\n\n  Shembull:\n  - count_ways_to_climb(2) kthen 2 (1 hap + 1 hap, 2 hapa)",
      "hy": "Հաշվում է աստիճանների որոշակի քանակով աստիճան բարձրանալու տարբեր եղանակների քանակը, որտեղ յուրաքանչյուր քայլում կարելի է բարձրանալ մեկ կամ երկու քայլ: Դուք սկսում եք մակարդակ 0-ից:\n\n  Արհամարհանքներ:\n  - stairs: Անկախ թիվ, որը ներկայացնում է աստիճանների քանակը աստիճանավանդակում:\n\n  Վերադարձնում է:\n  - Անկախ թիվ, որը ներկայացնում է աստիճան բարձրանալու տարբեր եղանակների քանակը:\n\n  Օրինակ:\n  - count_ways_to_climb(2) վերադարձնում է 2 (1 քայլ + 1 քայլ, 2 քայլ)",
      "bn": "একটি নির্দিষ্ট সংখ্যক ধাপের সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা গণনা করে, যেখানে প্রতিটি ধাপে, আপনি হয় এক ধাপ বা দুই ধাপ উঠতে পারেন। আপনি স্তর 0 থেকে শুরু করেন।\n\n  আর্গুমেন্টসমূহ:\n  - stairs: সিঁড়ির ধাপের সংখ্যা নির্দেশকারী একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - সিঁড়ি বেয়ে ওঠার বিভিন্ন উপায়ের সংখ্যা নির্দেশকারী একটি পূর্ণসংখ্যা।\n\n  উদাহরণ:\n  - count_ways_to_climb(2) 2 রিটার্ন করে (1 ধাপ + 1 ধাপ, 2 ধাপ)",
      "bg": "Изчислява броя на различните начини за изкачване на стълбище с даден брой стъпала, където на всяка стъпка може да се изкачи или едно стъпало, или две стъпала. Започвате от ниво 0.\n\nАргументи:\n- stairs: Цяло число, представляващо броя на стъпалата в стълбището.\n\nВръща:\n- Цяло число, представляващо броя на различните начини за изкачване на стълбището.\n\nПример:\n- count_ways_to_climb(2) връща 2 (1 стъпало + 1 стъпало, 2 стъпала)",
      "zh": "计算爬一个给定台阶数的楼梯的不同方式的数量，其中每一步可以选择爬一个台阶或两个台阶。你从0级开始。\n\n  参数:\n  - stairs: 一个整数，表示楼梯的台阶数。\n\n  返回:\n  - 一个整数，表示爬楼梯的不同方式的数量。\n\n  示例:\n  - count_ways_to_climb(2) 返回 2 (1步 + 1步, 2步)",
      "fr": "Calcule le nombre de façons différentes de monter un escalier d'un nombre donné de marches, où à chaque marche, on peut soit monter d'une marche, soit de deux marches. Vous commencez au niveau 0.\n\n  Arguments:\n  - stairs: Un entier représentant le nombre de marches dans l'escalier.\n\n  Retours:\n  - Un entier représentant le nombre de façons différentes de monter l'escalier.\n\n  Exemple:\n  - count_ways_to_climb(2) retourne 2 (1 marche + 1 marche, 2 marches)",
      "de": "Berechnet die Anzahl der verschiedenen Möglichkeiten, eine Treppe mit einer gegebenen Anzahl von Stufen zu erklimmen, wobei man bei jedem Schritt entweder eine Stufe oder zwei Stufen steigen kann. Man beginnt auf Ebene 0.\n\n  Argumente:\n  - stairs: Ein Integer, der die Anzahl der Stufen in der Treppe darstellt.\n\n  Rückgabewert:\n  - Ein Integer, der die Anzahl der verschiedenen Möglichkeiten darstellt, die Treppe zu erklimmen.\n\n  Beispiel:\n  - count_ways_to_climb(2) gibt 2 zurück (1 Schritt + 1 Schritt, 2 Schritte)",
      "ha": "Lissafa adadin hanyoyi daban-daban don hawa matakala na adadin matakai da aka bayar, inda a kowane mataki, za a iya hawa mataki daya ko matakai biyu. Ka fara a matakin 0.\n\n  Huɗɗa:\n  - stairs: Lamba mai ɗauke da adadin matakan da ke cikin matakalar.\n\n  Komawa:\n  - Lamba mai ɗauke da adadin hanyoyin daban-daban na hawa matakalar.\n\n  Misali:\n  - count_ways_to_climb(2) returns 2 (1 step + 1 step, 2 steps)",
      "hi": "सीढ़ियों की एक निश्चित संख्या के साथ एक सीढ़ी चढ़ने के विभिन्न तरीकों की संख्या की गणना करता है, जहाँ प्रत्येक कदम पर, आप या तो एक कदम या दो कदम चढ़ सकते हैं। आप स्तर 0 से शुरू करते हैं।\n\n  तर्क:\n  - stairs: एक पूर्णांक जो सीढ़ी में चरणों की संख्या का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक पूर्णांक जो सीढ़ी चढ़ने के विभिन्न तरीकों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - count_ways_to_climb(2) 2 लौटाता है (1 कदम + 1 कदम, 2 कदम)",
      "hu": "Kiszámítja, hány különböző módon lehet megmászni egy adott lépcsőfokszámú lépcsőt, ahol minden lépésnél egy vagy két lépcsőfokot lehet megmászni. A 0. szinten kezd.\n\n  Argumentumok:\n  - stairs: Egy egész szám, amely a lépcsőfokok számát jelöli a lépcsőn.\n\n  Visszatér:\n  - Egy egész szám, amely a lépcső megmászásának különböző módjainak számát jelöli.\n\n  Példa:\n  - count_ways_to_climb(2) visszaadja 2 (1 lépés + 1 lépés, 2 lépés)"
    },
    "docstring_bertscore": {
      "sq": "0.9879236700938409",
      "hy": "0.943727019900911",
      "bn": "0.9785771175142443",
      "bg": "0.988539424275049",
      "zh": "0.9378642455742853",
      "fr": "0.9935588140038006",
      "de": "0.9741206462853454",
      "ha": "0.9876328752160058",
      "hi": "0.9635296743685652",
      "hu": "0.9461387899874366"
    }
  },
  {
    "task_id": "Rust/32",
    "prompt": {
      "en": "/*\n  Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "sq": "/*\n  Gjen të gjitha intervalet e numrave natyrorë të njëpasnjëshëm, shuma e të cilëve është e barabartë me shumën e dhënë.\n\n  Funksioni identifikon të gjitha sekuencat e mundshme të vazhdueshme të numrave natyrorë ku shuma e të gjithë numrave në sekuencë është e barabartë me shumën e synuar. Funksioni kthen një vektor të tufa, ku çdo tufë përfaqëson fillimin dhe fundin e një sekuence.\n\n  Argumentet:\n  - target_sum: Një numër i plotë që përfaqëson shumën e synuar (10 <= target_sum <= 2,000,000).\n\n  Kthen:\n  - Një vektor të tufa. Çdo tufë përmban dy numra të plotë: numri i parë dhe i fundit në një sekuencë të vazhdueshme që shuma e tyre është e barabartë me shumën e synuar.\n\n  Shembull:\n  - find_sum_sequence_ranges(10000) kthen vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "hy": "/*\n  Գտնում է բոլոր հաջորդական բնական թվերի միջակայքերը, որոնց գումարը հավասար է տրված թիրախային գումարին։\n\n  Ֆունկցիան հայտնաբերում է բոլոր հնարավոր շարունակական հաջորդականությունները բնական թվերի, որտեղ հաջորդականության բոլոր թվերի գումարը հավասար է թիրախային գումարին։ Ֆունկցիան վերադարձնում է տուփերի վեկտոր, որտեղ յուրաքանչյուր տուփ ներկայացնում է հաջորդականության սկիզբն ու վերջը։\n\n  Արգումենտներ:\n  - target_sum: Թվային արժեք, որը ներկայացնում է թիրախային գումարը (10 <= target_sum <= 2,000,000)։\n\n  Վերադարձնում է:\n  - Տուփերի վեկտոր։ Յուրաքանչյուր տուփ պարունակում է երկու ամբողջ թիվ՝ շարունակական հաջորդականության առաջին և վերջին թիվը, որի գումարը հավասար է թիրախային գումարին։\n\n  Օրինակ:\n  - find_sum_sequence_ranges(10000) վերադարձնում է vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "bn": "/*\n  এমন সমস্ত পরিসরের ধারাবাহিক প্রাকৃতিক সংখ্যা খুঁজে বের করে যাদের যোগফল প্রদত্ত লক্ষ্য যোগফলের সমান।\n\n  ফাংশনটি সমস্ত সম্ভাব্য ধারাবাহিক প্রাকৃতিক সংখ্যার ক্রম সনাক্ত করে যেখানে ক্রমের সমস্ত সংখ্যার যোগফল লক্ষ্য যোগফলের সমান। ফাংশনটি একটি টুপলের ভেক্টর ফেরত দেয়, প্রতিটি টুপল একটি ক্রমের শুরু এবং শেষ উপস্থাপন করে।\n\n  আর্গুমেন্টসমূহ:\n  - target_sum: একটি পূর্ণসংখ্যা যা লক্ষ্য যোগফলকে উপস্থাপন করে (10 <= target_sum <= 2,000,000)।\n\n  ফেরত দেয়:\n  - একটি টুপলের ভেক্টর। প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে: একটি ধারাবাহিক ক্রমের প্রথম এবং শেষ সংখ্যা যা লক্ষ্য যোগফলের সমান হয়।\n\n  উদাহরণ:\n  - find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] ফেরত দেয়\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "bg": "/*\n  Намира всички диапазони от последователни естествени числа, чиято сума е равна на дадената целева сума.\n\n  Функцията идентифицира всички възможни непрекъснати последователности от естествени числа, при които сумата на всички числа в последователността е равна на целевата сума. Функцията връща вектор от кортежи, като всеки кортеж представлява началото и края на последователността.\n\n  Аргументи:\n  - target_sum: Цяло число, представляващо целевата сума (10 <= target_sum <= 2,000,000).\n\n  Връща:\n  - Вектор от кортежи. Всеки кортеж съдържа две цели числа: първото и последното число в непрекъсната последователност, която се сумира до целевата сума.\n\n  Пример:\n  - find_sum_sequence_ranges(10000) връща vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "zh": "/*\n  查找所有连续自然数的范围，其和等于给定的目标和。\n\n  该函数识别所有可能的连续自然数序列，其中序列中所有数字的和等于目标和。函数返回一个元组的向量，每个元组表示一个序列的开始和结束。\n\n  参数:\n  - target_sum: 表示目标和的整数 (10 <= target_sum <= 2,000,000)。\n\n  返回:\n  - 一个元组的向量。每个元组包含两个整数：在连续序列中，第一个和最后一个数字的和等于目标和。\n\n  示例:\n  - find_sum_sequence_ranges(10000) 返回 vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "fr": "/*\n  Trouve toutes les plages de nombres naturels consécutifs dont la somme est égale à la somme cible donnée.\n\n  La fonction identifie toutes les séquences contiguës possibles de nombres naturels où la somme de tous les nombres dans la séquence est égale à la somme cible. La fonction renvoie un vecteur de tuples, chaque tuple représentant le début et la fin d'une séquence.\n\n  Arguments :\n  - target_sum : Un entier représentant la somme cible (10 <= target_sum <= 2,000,000).\n\n  Renvoie :\n  - Un vecteur de tuples. Chaque tuple contient deux entiers : le premier et le dernier nombre dans une séquence contiguë qui s'additionne à la somme cible.\n\n  Exemple :\n  - find_sum_sequence_ranges(10000) renvoie vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "de": "/*\n  Findet alle Bereiche aufeinanderfolgender natürlicher Zahlen, deren Summe der gegebenen Zielsumme entspricht.\n\n  Die Funktion identifiziert alle möglichen zusammenhängenden Sequenzen natürlicher Zahlen, bei denen die Summe aller Zahlen in der Sequenz der Zielsumme entspricht. Die Funktion gibt einen Vektor von Tupeln zurück, wobei jedes Tupel den Anfang und das Ende einer Sequenz darstellt.\n\n  Argumente:\n  - target_sum: Eine ganze Zahl, die die Zielsumme darstellt (10 <= target_sum <= 2,000,000).\n\n  Rückgabewert:\n  - Ein Vektor von Tupeln. Jedes Tupel enthält zwei ganze Zahlen: die erste und die letzte Zahl in einer zusammenhängenden Sequenz, die sich zur Zielsumme addieren.\n\n  Beispiel:\n  - find_sum_sequence_ranges(10000) gibt vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] zurück\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "ha": "/*\n  Nemi dukkan jerin lambobi masu jere na lambobin halitta da jimlarsu ta yi daidai da adadin da aka bayar.\n\n  Aikin yana gano dukkan yiwuwar jerin lambobi masu jere na lambobin halitta inda jimlar dukkan lambobin a cikin jerin ta yi daidai da adadin da aka nufa. Aikin yana dawowa da vector na tuples, kowanne tuple yana wakiltar farkon da ƙarshen jerin.\n\n  Huɗɗa:\n  - target_sum: Wani lamba mai nuna adadin da aka nufa (10 <= target_sum <= 2,000,000).\n\n  Dawowa:\n  - Wani vector na tuples. Kowanne tuple yana ƙunshe da lambobi biyu: na farko da na ƙarshe a cikin jerin lambobi masu jere da jimlarsu ta yi daidai da adadin da aka nufa.\n\n  Misali:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "hi": "/*\n  उन सभी लगातार प्राकृतिक संख्याओं की श्रेणियों को खोजता है जिनका योग दिए गए लक्ष्य योग के बराबर होता है।\n\n  यह फ़ंक्शन सभी संभावित निरंतर प्राकृतिक संख्याओं के अनुक्रमों की पहचान करता है जहाँ अनुक्रम में सभी संख्याओं का योग लक्ष्य योग के बराबर होता है। फ़ंक्शन एक टपल के वेक्टर को लौटाता है, प्रत्येक टपल अनुक्रम की शुरुआत और अंत का प्रतिनिधित्व करता है।\n\n  तर्क:\n  - target_sum: एक पूर्णांक जो लक्ष्य योग का प्रतिनिधित्व करता है (10 <= target_sum <= 2,000,000)।\n\n  लौटाता है:\n  - टपल का एक वेक्टर। प्रत्येक टपल में दो पूर्णांक होते हैं: एक निरंतर अनुक्रम में पहली और अंतिम संख्या जो लक्ष्य योग के बराबर होती है।\n\n  उदाहरण:\n  - find_sum_sequence_ranges(10000) लौटाता है vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> ",
      "hu": "/*\n  Megkeresi az összes olyan egymást követő természetes számokból álló tartományt, amelyek összege megegyezik a megadott célszámmal.\n\n  A függvény azonosítja az összes lehetséges összefüggő természetes számokból álló sorozatot, ahol a sorozat összes számának összege megegyezik a célszámmal. A függvény egy vektorral tér vissza, amely tartalmazza a párokat, ahol minden pár egy sorozat kezdetét és végét jelöli.\n\n  Argumentumok:\n  - target_sum: Egy egész szám, amely a célszámot jelöli (10 <= target_sum <= 2,000,000).\n\n  Visszatér:\n  - Egy vektor párokkal. Minden pár két egész számot tartalmaz: az első és az utolsó számot egy összefüggő sorozatban, amely összege megegyezik a célszámmal.\n\n  Példa:\n  - find_sum_sequence_ranges(10000) visszatér vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]\n\n*/\nfn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)> "
    },
    "prompt_bertscore": {
      "sq": "0.9654456630240278",
      "hy": "0.9753485793009031",
      "bn": "0.9805695788664052",
      "bg": "0.9901997756301196",
      "zh": "0.9665528287679163",
      "fr": "0.9945734179901269",
      "de": "0.9796288653818239",
      "ha": "0.938910431791196",
      "hi": "0.9867239425923902",
      "hu": "0.9549162665253683"
    },
    "canonical_solution": "{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}",
    "instruction": {
      "en": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nՏրամադրել համառոտ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nনিচের রাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nДайте кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Rust a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>\n{\n    let mut result = Vec::new();\n    let mut start = 1;\n    let mut end = 1;\n    let mut sum = 1;\n\n    while start <= target_sum / 2 {\n        if sum < target_sum {\n            end += 1;\n            sum += end;\n        } else if sum > target_sum {\n            sum -= start;\n            start += 1;\n        } else {\n            result.push((start, end));\n            sum -= start;\n            start += 1;\n        }\n    }\n    // print!(\"{}\", result);\n    result\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9277247605135973",
      "bn": "0.8840433575290719",
      "bg": "0.8316696904400789",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_sum_sequence_ranges(10000), vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]);\n        assert_eq!(find_sum_sequence_ranges(15), vec![(1, 5), (4, 6), (7, 8)]);\n        assert_eq!(find_sum_sequence_ranges(28), vec![(1, 7)]);\n        assert_eq!(find_sum_sequence_ranges(21334), vec![(5332, 5335)]);\n        println!(\"All test cases passed!\");\n    }\n    \n\n}",
    "entry_point": "find_sum_sequence_ranges",
    "signature": "fn find_sum_sequence_ranges(target_sum: i32) -> Vec<(i32, i32)>",
    "docstring": {
      "en": "Finds all ranges of consecutive natural numbers whose sum equals the given target sum.\n\n  The function identifies all possible contiguous sequences of natural numbers where the sum of all numbers in the sequence equals the target sum. The function returns a vector of tuples, each tuple representing the start and end of a sequence.\n\n  Arguments:\n  - target_sum: An integer representing the target sum (10 <= target_sum <= 2,000,000).\n\n  Returns:\n  - A vector of tuples. Each tuple contains two integers: the first and last number in a contiguous sequence that sums up to the target sum.\n\n  Example:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "sq": "Gjen të gjitha intervalet e numrave natyrorë të njëpasnjëshëm, shuma e të cilëve është e barabartë me shumën e dhënë të synuar.\n\n  Funksioni identifikon të gjitha sekuencat e mundshme të njëpasnjëshme të numrave natyrorë ku shuma e të gjithë numrave në sekuencë është e barabartë me shumën e synuar. Funksioni kthen një vektor të torkave, ku secila torkë përfaqëson fillimin dhe fundin e një sekuence.\n\n  Argumentet:\n  - target_sum: Një numër i plotë që përfaqëson shumën e synuar (10 <= target_sum <= 2,000,000).\n\n  Kthen:\n  - Një vektor të torkave. Secila torkë përmban dy numra të plotë: numrin e parë dhe të fundit në një sekuencë të njëpasnjëshme që e ka shumën të barabartë me shumën e synuar.\n\n  Shembull:\n  - find_sum_sequence_ranges(10000) kthen vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "hy": "Գտնում է բոլոր հաջորդական բնական թվերի միջակայքերը, որոնց գումարը հավասար է տրված թիրախային գումարին։\n\n  Ֆունկցիան հայտնաբերում է բոլոր հնարավոր հաջորդական բնական թվերի հաջորդականությունները, որտեղ հաջորդականության բոլոր թվերի գումարը հավասար է թիրախային գումարին։ Ֆունկցիան վերադարձնում է տուփերի վեկտոր, որտեղ յուրաքանչյուր տուփ ներկայացնում է հաջորդականության սկիզբն ու վերջը։\n\n  Արգումենտներ:\n  - target_sum: Թիվ, որը ներկայացնում է թիրախային գումարը (10 <= target_sum <= 2,000,000)։\n\n  Վերադարձնում է:\n  - Տուփերի վեկտոր։ Յուրաքանչյուր տուփ պարունակում է երկու ամբողջ թիվ՝ հաջորդականության առաջին և վերջին թիվը, որը գումարվում է մինչև թիրախային գումարը։\n\n  Օրինակ:\n  - find_sum_sequence_ranges(10000) վերադարձնում է vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "bn": "সকল পরিসরের ধারাবাহিক প্রাকৃতিক সংখ্যা খুঁজে বের করে যাদের যোগফল প্রদত্ত লক্ষ্য যোগফলের সমান।\n\nফাংশনটি সমস্ত সম্ভাব্য ধারাবাহিক প্রাকৃতিক সংখ্যার ক্রম সনাক্ত করে যেখানে ক্রমের সমস্ত সংখ্যার যোগফল লক্ষ্য যোগফলের সমান। ফাংশনটি টুপলের একটি ভেক্টর ফেরত দেয়, প্রতিটি টুপল একটি ক্রমের শুরু এবং শেষকে উপস্থাপন করে।\n\nআর্গুমেন্টস:\n- target_sum: একটি পূর্ণসংখ্যা যা লক্ষ্য যোগফলকে উপস্থাপন করে (10 <= target_sum <= 2,000,000)।\n\nফেরত:\n- টুপলের একটি ভেক্টর। প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে: একটি ধারাবাহিক ক্রমের প্রথম এবং শেষ সংখ্যা যা লক্ষ্য যোগফলে যুক্ত হয়।\n\nউদাহরণ:\n- find_sum_sequence_ranges(10000) ফেরত দেয় vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "bg": "Намира всички диапазони от последователни естествени числа, чиято сума е равна на дадената целева сума.\n\nФункцията идентифицира всички възможни съседни последователности от естествени числа, където сумата на всички числа в последователността е равна на целевата сума. Функцията връща вектор от наредени двойки, като всяка двойка представлява началото и края на последователност.\n\nАргументи:\n- target_sum: Цяло число, представляващо целевата сума (10 <= target_sum <= 2,000,000).\n\nВръща:\n- Вектор от наредени двойки. Всяка двойка съдържа две цели числа: първото и последното число в съседна последователност, която се сумира до целевата сума.\n\nПример:\n- find_sum_sequence_ranges(10000) връща vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "zh": "找到所有连续自然数的范围，其和等于给定的目标和。\n\n该函数识别所有可能的连续自然数序列，其中序列中所有数字的和等于目标和。函数返回一个元组的向量，每个元组表示一个序列的开始和结束。\n\n参数：\n- target_sum: 一个整数，表示目标和 (10 <= target_sum <= 2,000,000)。\n\n返回：\n- 一个元组的向量。每个元组包含两个整数：一个连续序列中第一个和最后一个数字，其和等于目标和。\n\n示例：\n- find_sum_sequence_ranges(10000) 返回 vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "fr": "Trouve toutes les plages de nombres naturels consécutifs dont la somme est égale à la somme cible donnée.\n\n  La fonction identifie toutes les séquences contiguës possibles de nombres naturels où la somme de tous les nombres de la séquence est égale à la somme cible. La fonction renvoie un vecteur de tuples, chaque tuple représentant le début et la fin d'une séquence.\n\n  Arguments:\n  - target_sum: Un entier représentant la somme cible (10 <= target_sum <= 2,000,000).\n\n  Renvoie:\n  - Un vecteur de tuples. Chaque tuple contient deux entiers : le premier et le dernier nombre dans une séquence contiguë dont la somme est égale à la somme cible.\n\n  Exemple:\n  - find_sum_sequence_ranges(10000) renvoie vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "de": "Findet alle Bereiche von aufeinanderfolgenden natürlichen Zahlen, deren Summe der gegebenen Zielsumme entspricht.\n\n  Die Funktion identifiziert alle möglichen zusammenhängenden Sequenzen von natürlichen Zahlen, bei denen die Summe aller Zahlen in der Sequenz der Zielsumme entspricht. Die Funktion gibt einen Vektor von Tupeln zurück, wobei jedes Tupel den Anfang und das Ende einer Sequenz darstellt.\n\n  Argumente:\n  - target_sum: Ein ganzzahliger Wert, der die Zielsumme darstellt (10 <= target_sum <= 2,000,000).\n\n  Rückgabewert:\n  - Ein Vektor von Tupeln. Jedes Tupel enthält zwei ganze Zahlen: die erste und die letzte Zahl in einer zusammenhängenden Sequenz, die sich zur Zielsumme addieren.\n\n  Beispiel:\n  - find_sum_sequence_ranges(10000) gibt vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] zurück.",
      "ha": "Nemo dukkan jerin lambobi masu jere na lambobi na halitta waɗanda jimlar su ta yi daidai da adadin da aka ba.\n\n  Aikin yana gano dukkan yiwuwar jerin lambobi masu jere na lambobi na halitta inda jimlar duk lambobin a cikin jerin ta yi daidai da adadin da aka nufa. Aikin yana mayar da vector na tuples, kowace tuple tana wakiltar farkon da ƙarshen jerin.\n\n  Huɗaɗɗa:\n  - target_sum: Wani cikakken lamba da ke wakiltar adadin da aka nufa (10 <= target_sum <= 2,000,000).\n\n  Komawa:\n  - Wani vector na tuples. Kowace tuple tana ƙunshe da lambobi biyu: na farko da na ƙarshe a cikin jerin lambobi masu jere waɗanda jimlarsu ta yi daidai da adadin da aka nufa.\n\n  Misali:\n  - find_sum_sequence_ranges(10000) returns vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]",
      "hi": "सभी लगातार प्राकृतिक संख्याओं की श्रेणियों को खोजता है जिनका योग दिए गए लक्ष्य योग के बराबर होता है।\n\nयह फ़ंक्शन सभी संभावित सतत प्राकृतिक संख्याओं के अनुक्रमों की पहचान करता है जहाँ अनुक्रम में सभी संख्याओं का योग लक्ष्य योग के बराबर होता है। फ़ंक्शन एक टपल के वेक्टर को लौटाता है, प्रत्येक टपल एक अनुक्रम की शुरुआत और अंत का प्रतिनिधित्व करता है।\n\nआर्ग्युमेंट्स:\n- target_sum: एक पूर्णांक जो लक्ष्य योग का प्रतिनिधित्व करता है (10 <= target_sum <= 2,000,000)।\n\nरिटर्न:\n- टपल का एक वेक्टर। प्रत्येक टपल में दो पूर्णांक होते हैं: एक सतत अनुक्रम में पहली और अंतिम संख्या जो लक्ष्य योग के बराबर होती है।\n\nउदाहरण:\n- find_sum_sequence_ranges(10000) vec![(18, 142), (297, 328), (388, 412), (1998, 2002)] लौटाता है।",
      "hu": "Megtalálja az összes olyan egymást követő természetes számokból álló tartományt, amelyek összege megegyezik a megadott célösszeggel.\n\nA függvény azonosítja az összes lehetséges összefüggő természetes számokból álló sorozatot, ahol a sorozat összes számának összege megegyezik a célösszeggel. A függvény egy vektorral tér vissza, amelyben minden elem egy-egy tuple, és minden tuple egy sorozat kezdetét és végét jelöli.\n\nArgumentumok:\n- target_sum: Egy egész szám, amely a célösszeget jelöli (10 <= target_sum <= 2,000,000).\n\nVisszatérési érték:\n- Egy tuple-öket tartalmazó vektor. Minden tuple két egész számot tartalmaz: az első és az utolsó számot egy összefüggő sorozatban, amely összege a célösszeggel egyenlő.\n\nPélda:\n- find_sum_sequence_ranges(10000) visszaadja a vec![(18, 142), (297, 328), (388, 412), (1998, 2002)]"
    },
    "docstring_bertscore": {
      "sq": "0.9602816703778827",
      "hy": "0.9751439900084372",
      "bn": "0.9874143817968675",
      "bg": "0.9822305261126189",
      "zh": "0.9637509486130381",
      "fr": "0.9696872161806468",
      "de": "0.9805006541241861",
      "ha": "0.9634351263071926",
      "hi": "0.9757728537947936",
      "hu": "0.952278057804463"
    }
  },
  {
    "task_id": "Rust/33",
    "prompt": {
      "en": "/*\n  Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "sq": "/*\n  Konverton një varg binar (që përbëhet nga '0' dhe '1') në formën e tij të përmbysur.\n  Çdo '0' në vargun hyrës zëvendësohet me një '1', dhe çdo '1' zëvendësohet me një '0'.\n\n  Argumentet:\n  - input: Një varg që përbëhet nga shifrat binare ('0' dhe '1').\n\n  Kthen:\n  - Një varg i ri që përfaqëson sekuencën binare të përmbysur të vargut hyrës.\n\n  Shembull:\n  - invert_binary_string(\"0110\") kthen \"1001\"\n  - invert_binary_string(\"1111\") kthen \"0000\"\n  - invert_binary_string(\"0000\") kthen \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "hy": "/*\n  Տեքստային տող, որը բաղկացած է '0'-երից և '1'-երից, փոխակերպում է իր հակադարձ ձևին։ \n  Մուտքային տողում յուրաքանչյուր '0' փոխարինվում է '1'-ով, իսկ յուրաքանչյուր '1' փոխարինվում է '0'-ով։\n\n  Արգումենտներ:\n  - input: Տող, որը բաղկացած է բինար թվանշաններից ('0' և '1')։\n\n  Վերադարձնում է:\n  - Նոր տող, որը ներկայացնում է մուտքային տողի հակադարձ բինար հաջորդականությունը։\n\n  Օրինակ:\n  - invert_binary_string(\"0110\") վերադարձնում է \"1001\"\n  - invert_binary_string(\"1111\") վերադարձնում է \"0000\"\n  - invert_binary_string(\"0000\") վերադարձնում է \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String",
      "bn": "/*\n  একটি বাইনারি স্ট্রিং (যা '0' এবং '1' নিয়ে গঠিত) তার বিপরীত রূপে রূপান্তর করে। \n  ইনপুট স্ট্রিংয়ের প্রতিটি '0' কে '1' দিয়ে এবং প্রতিটি '1' কে '0' দিয়ে প্রতিস্থাপন করা হয়।\n\n  আর্গুমেন্টসমূহ:\n  - input: একটি স্ট্রিং যা বাইনারি অঙ্ক ('0' এবং '1') নিয়ে গঠিত।\n\n  রিটার্নস:\n  - একটি নতুন স্ট্রিং যা ইনপুট স্ট্রিংয়ের বিপরীত বাইনারি ক্রমকে উপস্থাপন করে।\n\n  উদাহরণ:\n  - invert_binary_string(\"0110\") রিটার্ন করে \"1001\"\n  - invert_binary_string(\"1111\") রিটার্ন করে \"0000\"\n  - invert_binary_string(\"0000\") রিটার্ন করে \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "bg": "/*\n  Преобразува двоична низ (състояща се от '0' и '1') в нейната инвертирана форма. \n  Всеки '0' в входната низ се заменя с '1', а всеки '1' се заменя с '0'.\n\n  Аргументи:\n  - input: Низ, състоящ се от двоични цифри ('0' и '1').\n\n  Връща:\n  - Нова низ, представляваща инвертираната двоична последователност на входната низ.\n\n  Пример:\n  - invert_binary_string(\"0110\") връща \"1001\"\n  - invert_binary_string(\"1111\") връща \"0000\"\n  - invert_binary_string(\"0000\") връща \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "zh": "/*\n  将二进制字符串（由'0'和'1'组成）转换为其反转形式。\n  输入字符串中的每个'0'都被替换为'1'，每个'1'都被替换为'0'。\n\n  参数:\n  - input: 一个由二进制数字（'0'和'1'）组成的字符串。\n\n  返回:\n  - 一个新字符串，表示输入字符串的反转二进制序列。\n\n  示例:\n  - invert_binary_string(\"0110\") 返回 \"1001\"\n  - invert_binary_string(\"1111\") 返回 \"0000\"\n  - invert_binary_string(\"0000\") 返回 \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "fr": "/*\n  Convertit une chaîne binaire (composée de '0' et de '1') en sa forme inversée.\n  Chaque '0' dans la chaîne d'entrée est remplacé par un '1', et chaque '1' est remplacé par un '0'.\n\n  Arguments :\n  - input : Une chaîne composée de chiffres binaires ('0' et '1').\n\n  Renvoie :\n  - Une nouvelle chaîne représentant la séquence binaire inversée de la chaîne d'entrée.\n\n  Exemple :\n  - invert_binary_string(\"0110\") renvoie \"1001\"\n  - invert_binary_string(\"1111\") renvoie \"0000\"\n  - invert_binary_string(\"0000\") renvoie \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "de": "/*\n  Konvertiert einen Binärstring (bestehend aus '0' und '1') in seine invertierte Form.\n  Jedes '0' im Eingabestring wird durch ein '1' ersetzt, und jedes '1' wird durch ein '0' ersetzt.\n\n  Argumente:\n  - input: Ein String, der aus Binärziffern ('0' und '1') besteht.\n\n  Rückgabewerte:\n  - Ein neuer String, der die invertierte Binärsequenz des Eingabestrings darstellt.\n\n  Beispiel:\n  - invert_binary_string(\"0110\") gibt \"1001\" zurück\n  - invert_binary_string(\"1111\") gibt \"0000\" zurück\n  - invert_binary_string(\"0000\") gibt \"1111\" zurück\n*/\nfn invert_binary_string(input: &str) -> String ",
      "ha": "/*\n  Canza wani igiyar binary (wanda ya ƙunshi '0's da '1's) zuwa sifar da aka juya. \n  Duk wani '0' a cikin igiyar shigarwa ana maye gurbinsa da '1', kuma duk wani '1' ana maye gurbinsa da '0'.\n\n  Huɗɗa:\n  - input: Wani igiya wanda ya ƙunshi lambobin binary ('0' da '1').\n\n  Komawa:\n  - Sabuwar igiya wanda ke wakiltar jerin lambobin binary da aka juya daga igiyar shigarwa.\n\n  Misali:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String ",
      "hi": "/*\n  एक बाइनरी स्ट्रिंग (जो '0' और '1' से बनी होती है) को उसके उल्टे रूप में परिवर्तित करता है। \n  इनपुट स्ट्रिंग में हर '0' को '1' से और हर '1' को '0' से बदल दिया जाता है।\n\n  तर्क:\n  - input: एक स्ट्रिंग जो बाइनरी अंकों ('0' और '1') से बनी होती है।\n\n  लौटाता है:\n  - एक नई स्ट्रिंग जो इनपुट स्ट्रिंग के उल्टे बाइनरी अनुक्रम का प्रतिनिधित्व करती है।\n\n  उदाहरण:\n  - invert_binary_string(\"0110\") \"1001\" लौटाता है\n  - invert_binary_string(\"1111\") \"0000\" लौटाता है\n  - invert_binary_string(\"0000\") \"1111\" लौटाता है\n*/\nfn invert_binary_string(input: &str) -> String ",
      "hu": "/*\n  Egy bináris karakterláncot (amely '0'-kból és '1'-ekből áll) alakít át annak invertált formájára. \n  Az input karakterlánc minden '0'-ját '1'-re, és minden '1'-jét '0'-ra cseréli.\n\n  Argumentumok:\n  - input: Egy karakterlánc, amely bináris számjegyekből ('0' és '1') áll.\n\n  Visszatérési érték:\n  - Egy új karakterlánc, amely az input karakterlánc invertált bináris sorozatát képviseli.\n\n  Példa:\n  - invert_binary_string(\"0110\") visszaadja \"1001\"\n  - invert_binary_string(\"1111\") visszaadja \"0000\"\n  - invert_binary_string(\"0000\") visszaadja \"1111\"\n*/\nfn invert_binary_string(input: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9857019892819656",
      "hy": "0.9638772775353762",
      "bn": "0.9672327405621987",
      "bg": "0.9769878758355841",
      "zh": "0.961262904460195",
      "fr": "0.9815559773386244",
      "de": "0.9813221893801464",
      "ha": "0.9737503992550964",
      "hi": "0.9746162290860275",
      "hu": "0.9763371627073137"
    },
    "canonical_solution": "{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}",
    "instruction": {
      "en": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nরাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供一个简洁的自然语言描述（文档字符串）。",
      "fr": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nBa da takaitaccen bayani a cikin harshen hausa (docstring) na lambar Rust da ke ƙasa ta amfani da haruffa 500 kacal.",
      "hi": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn invert_binary_string(input: &str) -> String\n{\n    input.chars().map(|c| match c {\n        '0' => '1',\n        '1' => '0',\n         _  => c, // Handles non-binary characters conservatively\n    }).collect()\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9217118216189092",
      "bn": "0.9071935298083071",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.8599183073397175",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n   \n        assert_eq!(invert_binary_string(\"0110100100100\"), \"1001011011011\");\n        assert_eq!(invert_binary_string(\"1000000010000000000\"), \"0111111101111111111\");\n        assert_eq!(invert_binary_string(\"11110000\"), \"00001111\");\n        assert_eq!(invert_binary_string(\"0000\"), \"1111\");\n        println!(\"All test cases passed!\");\n        \n        \n    }\n    \n\n}",
    "entry_point": "invert_binary_string",
    "signature": "fn invert_binary_string(input: &str) -> String",
    "docstring": {
      "en": "Converts a binary string (consisting of '0's and '1's) into its inverted form. \n  Every '0' in the input string is replaced with a '1', and every '1' is replaced with a '0'.\n\n  Arguments:\n  - input: A string consisting of binary digits ('0' and '1').\n\n  Returns:\n  - A new string representing the inverted binary sequence of the input string.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "sq": "Konverton një varg binar (i përbërë nga '0' dhe '1') në formën e tij të përmbysur. \n  Çdo '0' në vargun hyrës zëvendësohet me një '1', dhe çdo '1' zëvendësohet me një '0'.\n\n  Argumentet:\n  - input: Një varg që përbëhet nga shifrat binare ('0' dhe '1').\n\n  Kthen:\n  - Një varg i ri që përfaqëson sekuencën binare të përmbysur të vargut hyrës.\n\n  Shembull:\n  - invert_binary_string(\"0110\") kthen \"1001\"\n  - invert_binary_string(\"1111\") kthen \"0000\"\n  - invert_binary_string(\"0000\") kthen \"1111\"",
      "hy": "Վերածում է երկբայական տողը (կազմված '0'-ներից և '1'-ներից) իր հակադարձ ձևին։ \n  Մուտքային տողի յուրաքանչյուր '0' փոխարինվում է '1'-ով, և յուրաքանչյուր '1' փոխարինվում է '0'-ով։\n\n  Արգումենտներ:\n  - input: Տող, որը կազմված է երկբայական թվանշաններից ('0' և '1')։\n\n  Վերադարձնում է:\n  - Նոր տող, որը ներկայացնում է մուտքային տողի հակադարձված երկբայական հաջորդականությունը։\n\n  Օրինակ:\n  - invert_binary_string(\"0110\") վերադարձնում է \"1001\"\n  - invert_binary_string(\"1111\") վերադարձնում է \"0000\"\n  - invert_binary_string(\"0000\") վերադարձնում է \"1111\"",
      "bn": "একটি বাইনারি স্ট্রিং (যা '0' এবং '1' নিয়ে গঠিত) তার বিপরীত রূপে রূপান্তর করে। ইনপুট স্ট্রিংয়ের প্রতিটি '0' কে '1' দিয়ে প্রতিস্থাপন করা হয়, এবং প্রতিটি '1' কে '0' দিয়ে প্রতিস্থাপন করা হয়।\n\nArguments:\n- input: একটি স্ট্রিং যা বাইনারি ডিজিট ('0' এবং '1') নিয়ে গঠিত।\n\nReturns:\n- একটি নতুন স্ট্রিং যা ইনপুট স্ট্রিংয়ের বিপরীত বাইনারি ক্রমকে উপস্থাপন করে।\n\nExample:\n- invert_binary_string(\"0110\") returns \"1001\"\n- invert_binary_string(\"1111\") returns \"0000\"\n- invert_binary_string(\"0000\") returns \"1111\"",
      "bg": "Преобразува двоична низ (състояща се от '0' и '1') в нейната инвертирана форма. \n  Всеки '0' в входната низ се заменя с '1', а всеки '1' се заменя с '0'.\n\n  Аргументи:\n  - input: Низ, състоящ се от двоични цифри ('0' и '1').\n\n  Връща:\n  - Нов низ, представляващ инвертираната двоична последователност на входната низ.\n\n  Пример:\n  - invert_binary_string(\"0110\") връща \"1001\"\n  - invert_binary_string(\"1111\") връща \"0000\"\n  - invert_binary_string(\"0000\") връща \"1111\"",
      "zh": "将二进制字符串（由 '0' 和 '1' 组成）转换为其反转形式。输入字符串中的每个 '0' 都替换为 '1'，每个 '1' 都替换为 '0'。\n\nArguments:\n- input: 一个由二进制数字（'0' 和 '1'）组成的字符串。\n\nReturns:\n- 一个新字符串，表示输入字符串的反转二进制序列。\n\nExample:\n- invert_binary_string(\"0110\") returns \"1001\"\n- invert_binary_string(\"1111\") returns \"0000\"\n- invert_binary_string(\"0000\") returns \"1111\"",
      "fr": "Convertit une chaîne binaire (composée de '0' et de '1') en sa forme inversée. \n  Chaque '0' dans la chaîne d'entrée est remplacé par un '1', et chaque '1' est remplacé par un '0'.\n\n  Arguments:\n  - input: Une chaîne composée de chiffres binaires ('0' et '1').\n\n  Renvoie:\n  - Une nouvelle chaîne représentant la séquence binaire inversée de la chaîne d'entrée.\n\n  Exemple:\n  - invert_binary_string(\"0110\") renvoie \"1001\"\n  - invert_binary_string(\"1111\") renvoie \"0000\"\n  - invert_binary_string(\"0000\") renvoie \"1111\"",
      "de": "Konvertiert einen Binärstring (bestehend aus '0' und '1') in seine invertierte Form. \n  Jedes '0' im Eingabestring wird durch eine '1' ersetzt, und jede '1' wird durch eine '0' ersetzt.\n\n  Argumente:\n  - input: Ein String, der aus Binärziffern ('0' und '1') besteht.\n\n  Rückgabewert:\n  - Ein neuer String, der die invertierte Binärsequenz des Eingabestrings darstellt.\n\n  Beispiel:\n  - invert_binary_string(\"0110\") gibt \"1001\" zurück\n  - invert_binary_string(\"1111\") gibt \"0000\" zurück\n  - invert_binary_string(\"0000\") gibt \"1111\" zurück",
      "ha": "Canza wani igiyar binary (wanda ya ƙunshi '0's da '1's) zuwa nau'in da aka juya. \n  Kowanne '0' a cikin igiyar shigarwa ana maye gurbinsa da '1', kuma kowanne '1' ana maye gurbinsa da '0'.\n\n  Arguments:\n  - input: Wani igiya wanda ya ƙunshi lambobin binary ('0' da '1').\n\n  Returns:\n  - Sabuwar igiya wadda ke wakiltar jujjuyawar jerin lambobin binary na igiyar shigarwa.\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "hi": "एक बाइनरी स्ट्रिंग (जिसमें '0' और '1' होते हैं) को उसके उल्टे रूप में परिवर्तित करता है। \n  इनपुट स्ट्रिंग में हर '0' को '1' से और हर '1' को '0' से बदल दिया जाता है।\n\n  Arguments:\n  - input: एक स्ट्रिंग जो बाइनरी अंकों ('0' और '1') से बनी होती है।\n\n  Returns:\n  - एक नई स्ट्रिंग जो इनपुट स्ट्रिंग के उल्टे बाइनरी अनुक्रम का प्रतिनिधित्व करती है।\n\n  Example:\n  - invert_binary_string(\"0110\") returns \"1001\"\n  - invert_binary_string(\"1111\") returns \"0000\"\n  - invert_binary_string(\"0000\") returns \"1111\"",
      "hu": "Bináris karakterláncot (csak '0' és '1' karakterekből álló) alakít át annak invertált formájára. \n  Az input karakterlánc minden '0' karakterét '1'-re, és minden '1' karakterét '0'-ra cseréli.\n\n  Argumentumok:\n  - input: Egy karakterlánc, amely bináris számjegyekből ('0' és '1') áll.\n\n  Visszatérési érték:\n  - Egy új karakterlánc, amely az input karakterlánc invertált bináris sorozatát képviseli.\n\n  Példa:\n  - invert_binary_string(\"0110\") visszaadja \"1001\"\n  - invert_binary_string(\"1111\") visszaadja \"0000\"\n  - invert_binary_string(\"0000\") visszaadja \"1111\""
    },
    "docstring_bertscore": {
      "sq": "0.9842221929432557",
      "hy": "0.9705613884875813",
      "bn": "0.9540830120769269",
      "bg": "0.9761645529061944",
      "zh": "0.9628350639260862",
      "fr": "0.9795567625535083",
      "de": "0.9774953764591282",
      "ha": "0.9851315228276335",
      "hi": "0.9878166083184631",
      "hu": "0.9602761087272137"
    }
  },
  {
    "task_id": "Rust/34",
    "prompt": {
      "en": "/*\n  Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "sq": "/*\n  Llogarit distancën totale minimale nga të gjithë banorët te një zyrë postare e vendosur brenda qytetit të tyre. Qyteti është i vendosur në një rrjet, me rrugë që shkojnë veri-jug dhe lindje-perëndim, duke formuar blloqe.\n\n  Distanca midis dy pikave (x1, y1) dhe (x2, y2) përcaktohet si |x1 - x2| + |y1 - y2|.\n\n  Argumentet:\n  - residents: Një listë tuplesh, secila që përfaqëson koordinatat (x, y) të vendndodhjes së një banori.\n\n  Kthen:\n  - Distancën totale minimale nga të gjithë banorët te zyra postare.\n\n  Shembuj:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) kthen 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) kthen 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "hy": "/*\n  Հաշվում է բոլոր բնակիչներից փոստային գրասենյակ հասնելու նվազագույն ընդհանուր հեռավորությունը, որը գտնվում է նրանց քաղաքում։ Քաղաքը դասավորված է ցանցի տեսքով, որտեղ փողոցները անցնում են հյուսիս-հարավ և արևելք-արևմուտք ուղղություններով՝ ձևավորելով բլոկներ։\n\n  Երկու կետերի (x1, y1) և (x2, y2) միջև հեռավորությունը սահմանված է որպես |x1 - x2| + |y1 - y2|։\n\n  Արգումենտներ:\n  - residents: Կոորդինատների զույգերի շերտ, որոնցից յուրաքանչյուրը ներկայացնում է բնակչի գտնվելու վայրի (x, y) կոորդինատները։\n\n  Վերադարձնում է:\n  - Բոլոր բնակիչներից փոստային գրասենյակ հասնելու նվազագույն ընդհանուր հեռավորությունը։\n\n  Օրինակներ:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) վերադարձնում է 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) վերադարձնում է 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
      "bn": "/*\n  একটি শহরের মধ্যে অবস্থিত একটি ডাকঘরের সাথে সমস্ত বাসিন্দাদের ন্যূনতম মোট দূরত্ব গণনা করে। শহরটি একটি গ্রিডে বিন্যস্ত, যেখানে রাস্তা উত্তর-দক্ষিণ এবং পূর্ব-পশ্চিমে চলে, ব্লক তৈরি করে।\n\n  দুটি বিন্দুর মধ্যে দূরত্ব (x1, y1) এবং (x2, y2) হিসাবে সংজ্ঞায়িত করা হয় |x1 - x2| + |y1 - y2|।\n\n  আর্গুমেন্টসমূহ:\n  - residents: টাপলগুলির একটি স্লাইস, প্রতিটি একটি বাসিন্দার অবস্থানের (x, y) স্থানাঙ্ক উপস্থাপন করে।\n\n  রিটার্ন করে:\n  - সমস্ত বাসিন্দাদের ডাকঘরের সাথে ন্যূনতম মোট দূরত্ব।\n\n  উদাহরণসমূহ:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 রিটার্ন করে\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 রিটার্ন করে\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "bg": "/*\n  Изчислява минималното общо разстояние от всички жители до пощенска станция, разположена в техния град. Градът е разположен в мрежа, с улици, които вървят север-юг и изток-запад, образувайки блокове.\n\n  Разстоянието между две точки (x1, y1) и (x2, y2) се определя като |x1 - x2| + |y1 - y2|.\n\n  Аргументи:\n  - residents: Списък от кортежи, всеки представляващ (x, y) координатите на местоположението на жител.\n\n  Връща:\n  - Минималното общо разстояние от всички жители до пощенската станция.\n\n  Примери:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) връща 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) връща 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "zh": "/*\n  计算所有居民到位于其城市内的邮局的最小总距离。城市布局为网格状，街道呈南北和东西走向，形成街区。\n\n  两点 (x1, y1) 和 (x2, y2) 之间的距离定义为 |x1 - x2| + |y1 - y2|。\n\n  参数：\n  - residents: 一个元组数组，每个元组表示居民位置的 (x, y) 坐标。\n\n  返回：\n  - 所有居民到邮局的最小总距离。\n\n  示例：\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 返回 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 返回 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "fr": "/*\n  Calcule la distance totale minimale de tous les résidents à un bureau de poste situé dans leur ville. La ville est disposée en grille, avec des rues orientées nord-sud et est-ouest, formant des blocs.\n\n  La distance entre deux points (x1, y1) et (x2, y2) est définie comme |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: Une tranche de tuples, chacun représentant les coordonnées (x, y) de l'emplacement d'un résident.\n\n  Retourne:\n  - La distance totale minimale de tous les résidents au bureau de poste.\n\n  Exemples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) retourne 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) retourne 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
      "de": "/*\n  Berechnet die minimale Gesamtdistanz von allen Bewohnern zu einem Postamt, das sich innerhalb ihrer Stadt befindet. Die Stadt ist in einem Raster angelegt, mit Straßen, die von Nord nach Süd und von Ost nach West verlaufen und Blöcke bilden.\n\n  Die Entfernung zwischen zwei Punkten (x1, y1) und (x2, y2) ist definiert als |x1 - x2| + |y1 - y2|.\n\n  Argumente:\n  - residents: Ein Slice von Tupeln, die jeweils die (x, y) Koordinaten des Standorts eines Bewohners darstellen.\n\n  Rückgabewert:\n  - Die minimale Gesamtdistanz von allen Bewohnern zum Postamt.\n\n  Beispiele:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) gibt 10 zurück\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) gibt 2 zurück\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "ha": "/*\n  Lissafi na mafi ƙarancin jimillar nesa daga duk mazauna zuwa ofishin gidan waya da ke cikin birninsu. Birnin yana shimfiɗa a cikin grid, tare da tituna suna gudana daga arewa-kudu da gabas-yamma, suna samar da tubalan.\n\n  Nesa tsakanin wurare biyu (x1, y1) da (x2, y2) ana ayyana shi azaman |x1 - x2| + |y1 - y2|.\n\n  Huɗa:\n  - mazauna: Wani yanki na tuples, kowanne yana wakiltar (x, y) daidaitattun wurin zama na mazaunin.\n\n  Dawowa:\n  - Mafi ƙarancin jimillar nesa daga duk mazauna zuwa ofishin gidan waya.\n\n  Misalai:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "hi": "/*\n  सभी निवासियों से उनके शहर में स्थित एक डाकघर तक न्यूनतम कुल दूरी की गणना करता है। शहर एक ग्रिड में बिछा हुआ है, जिसमें सड़कें उत्तर-दक्षिण और पूर्व-पश्चिम दिशा में चलती हैं, जो ब्लॉकों का निर्माण करती हैं।\n\n  दो बिंदुओं (x1, y1) और (x2, y2) के बीच की दूरी को |x1 - x2| + |y1 - y2| के रूप में परिभाषित किया गया है।\n\n  तर्क:\n  - residents: ट्यूपल का एक स्लाइस, प्रत्येक निवासी के स्थान के (x, y) निर्देशांक का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - सभी निवासियों से डाकघर तक न्यूनतम कुल दूरी।\n\n  उदाहरण:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 लौटाता है\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 लौटाता है\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32 ",
      "hu": "/*\n  Kiszámítja a minimális össztávolságot az összes lakos és egy postahivatal között, amely a városukon belül helyezkedik el. A város egy rácson van elrendezve, észak-déli és kelet-nyugati utcákkal, amelyek blokkokat alkotnak.\n\n  A távolság két pont között (x1, y1) és (x2, y2) úgy van meghatározva, mint |x1 - x2| + |y1 - y2|.\n\n  Argumentumok:\n  - residents: Egy tuple szelet, amely az egyes lakosok helyzetének (x, y) koordinátáit képviseli.\n\n  Visszatér:\n  - A minimális össztávolság az összes lakos és a postahivatal között.\n\n  Példák:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) visszaadja 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) visszaadja 2\n*/\n\nfn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32"
    },
    "prompt_bertscore": {
      "sq": "0.9914002976530946",
      "hy": "0.9725045895052457",
      "bn": "0.9818571009962733",
      "bg": "0.9948965896200707",
      "zh": "0.9763359709250276",
      "fr": "0.9821606082184946",
      "de": "0.9844543918586856",
      "ha": "0.9855081260300755",
      "hi": "0.9900599398418711",
      "hu": "0.9674705011282974"
    },
    "canonical_solution": "{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}",
    "instruction": {
      "en": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nДайте кратко описание на Rust кода на български език, използвайки максимум 500 знака.",
      "zh": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Rust a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32\n{\n    let mut x_coords: Vec<i32> = residents.iter().map(|&(x, _)| x).collect();\n    let mut y_coords: Vec<i32> = residents.iter().map(|&(_, y)| y).collect();\n    \n    x_coords.sort_unstable();\n    y_coords.sort_unstable();\n\n    let median_x = x_coords[x_coords.len() / 2];\n    let median_y = y_coords[y_coords.len() / 2];\n\n    residents.iter().fold(0, |acc, &(x, y)| acc + (x - median_x).abs() + (y - median_y).abs())\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9423368058640478",
      "bn": "0.8772950889637926",
      "bg": "0.8449290628956817",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]), 10);\n        assert_eq!(minimum_distance_to_post_office(&[(0, 0), (1, 1)]), 2);\n    \n    }\n\n}",
    "entry_point": "minimum_distance_to_post_office",
    "signature": "fn minimum_distance_to_post_office(residents: &[(i32, i32)]) -> i32",
    "docstring": {
      "en": "Calculates the minimum total distance from all residents to a post office located within their city. The city is laid out in a grid, with streets running north-south and east-west, forming blocks. \n\n  The distance between two points (x1, y1) and (x2, y2) is defined as |x1 - x2| + |y1 - y2|.\n\n  Arguments:\n  - residents: A slice of tuples, each representing the (x, y) coordinates of a resident's location.\n\n  Returns:\n  - The minimum total distance from all residents to the post office.\n\n  Examples:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "sq": "Llogarit distancën totale minimale nga të gjithë banorët deri te një zyrë postare e vendosur brenda qytetit të tyre. Qyteti është i shtrirë në një rrjetë, me rrugë që shkojnë nga veriu në jug dhe nga lindja në perëndim, duke formuar blloqe.\n\nDistanca midis dy pikave (x1, y1) dhe (x2, y2) përcaktohet si |x1 - x2| + |y1 - y2|.\n\nArgumentet:\n- residents: Një pjesë e tupleve, secila që përfaqëson koordinatat (x, y) të vendndodhjes së një banori.\n\nKthen:\n- Distanca totale minimale nga të gjithë banorët deri te zyra postare.\n\nShembuj:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) kthen 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) kthen 2",
      "hy": "Հաշվում է բնակիչներից փոստային գրասենյակ գտնվելու նվազագույն ընդհանուր հեռավորությունը, որը գտնվում է նրանց քաղաքի ներսում։ Քաղաքը դասավորված է ցանցաձև, հյուսիս-հարավ և արևելք-արևմուտք ուղղություններով փողոցներով, ձևավորելով բլոկներ։\n\nԵրկու կետերի (x1, y1) և (x2, y2) միջև հեռավորությունը սահմանվում է որպես |x1 - x2| + |y1 - y2|։\n\nԱրգումենտներ:\n- residents: Կտրվածք, որը պարունակում է տուփեր, որոնցից յուրաքանչյուրը ներկայացնում է բնակչի գտնվելու վայրի (x, y) կոորդինատները։\n\nՎերադարձնում է:\n- Բոլոր բնակիչներից փոստային գրասենյակ գտնվելու նվազագույն ընդհանուր հեռավորությունը։\n\nՕրինակներ:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) վերադարձնում է 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) վերադարձնում է 2",
      "bn": "শহরের সকল বাসিন্দার কাছ থেকে একটি ডাকঘরের ন্যূনতম মোট দূরত্ব গণনা করে। শহরটি একটি গ্রিডে সাজানো, যেখানে রাস্তা উত্তর-দক্ষিণ এবং পূর্ব-পশ্চিমে চলে, ব্লক তৈরি করে।\n\nদুটি বিন্দুর (x1, y1) এবং (x2, y2) মধ্যে দূরত্বকে সংজ্ঞায়িত করা হয় |x1 - x2| + |y1 - y2| হিসাবে।\n\nআর্গুমেন্টস:\n- residents: টুপলের একটি স্লাইস, প্রতিটি একটি বাসিন্দার অবস্থানের (x, y) স্থানাঙ্ক উপস্থাপন করে।\n\nরিটার্নস:\n- সকল বাসিন্দার কাছ থেকে ডাকঘরের ন্যূনতম মোট দূরত্ব।\n\nউদাহরণ:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) রিটার্ন করে 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) রিটার্ন করে 2",
      "bg": "Изчислява минималното общо разстояние от всички жители до пощенска станция, разположена в техния град. Градът е разположен в мрежа, с улици, които вървят от север на юг и от изток на запад, образувайки блокове.\n\nРазстоянието между две точки (x1, y1) и (x2, y2) се определя като |x1 - x2| + |y1 - y2|.\n\nАргументи:\n- residents: Срез от кортежи, всеки представляващ (x, y) координатите на местоположението на жител.\n\nВръща:\n- Минималното общо разстояние от всички жители до пощенската станция.\n\nПримери:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) връща 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) връща 2",
      "zh": "计算所有居民到位于城市内的邮局的最小总距离。城市布局为网格状，街道呈南北和东西走向，形成街区。\n\n两个点 (x1, y1) 和 (x2, y2) 之间的距离定义为 |x1 - x2| + |y1 - y2|。\n\n参数：\n- residents: 一个元组的切片，每个元组代表一个居民位置的 (x, y) 坐标。\n\n返回：\n- 所有居民到邮局的最小总距离。\n\n示例：\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 返回 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 返回 2",
      "fr": "Calcule la distance totale minimale de tous les résidents à un bureau de poste situé dans leur ville. La ville est disposée en grille, avec des rues orientées nord-sud et est-ouest, formant des blocs.\n\nLa distance entre deux points (x1, y1) et (x2, y2) est définie comme |x1 - x2| + |y1 - y2|.\n\nArguments:\n- residents: Une tranche de tuples, chacun représentant les coordonnées (x, y) de l'emplacement d'un résident.\n\nReturns:\n- La distance totale minimale de tous les résidents au bureau de poste.\n\nExamples:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "de": "Berechnet die minimale Gesamtdistanz von allen Bewohnern zu einem Postamt, das sich innerhalb ihrer Stadt befindet. Die Stadt ist in einem Raster angelegt, mit Straßen, die von Nord nach Süd und von Ost nach West verlaufen und Blöcke bilden.\n\n  Die Entfernung zwischen zwei Punkten (x1, y1) und (x2, y2) wird definiert als |x1 - x2| + |y1 - y2|.\n\n  Argumente:\n  - residents: Ein Slice von Tupeln, die jeweils die (x, y)-Koordinaten des Standorts eines Bewohners darstellen.\n\n  Rückgabewerte:\n  - Die minimale Gesamtdistanz von allen Bewohnern zum Postamt.\n\n  Beispiele:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) gibt 10 zurück\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) gibt 2 zurück",
      "ha": "Lissafa mafi ƙarancin jimillar nesa daga duk mazauna zuwa ofishin gidan waya da ke cikin birninsu. Birnin yana shimfiɗa a cikin grid, tare da tituna suna gudana arewa-kudu da gabas-yamma, suna samar da tubalan.\n\n  Nisan tsakanin wurare biyu (x1, y1) da (x2, y2) an ayyana shi a matsayin |x1 - x2| + |y1 - y2|.\n\n  Huɗa:\n  - residents: Wani yanki na tuples, kowanne yana wakiltar (x, y) da ke nuna wurin zama na mazaunin.\n\n  Dawowa:\n  - Mafi ƙarancin nisan jimla daga duk mazauna zuwa ofishin gidan waya.\n\n  Misalai:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) returns 10\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) returns 2",
      "hi": "सभी निवासियों से उनके शहर में स्थित एक डाकघर तक की न्यूनतम कुल दूरी की गणना करता है। शहर एक ग्रिड में व्यवस्थित है, जिसमें सड़कें उत्तर-दक्षिण और पूर्व-पश्चिम दिशा में चलती हैं, जो ब्लॉक बनाती हैं।\n\n  दो बिंदुओं (x1, y1) और (x2, y2) के बीच की दूरी को |x1 - x2| + |y1 - y2| के रूप में परिभाषित किया गया है।\n\n  तर्क:\n  - residents: ट्यूपल्स का एक स्लाइस, प्रत्येक निवासी के स्थान के (x, y) निर्देशांक का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - सभी निवासियों से डाकघर तक की न्यूनतम कुल दूरी।\n\n  उदाहरण:\n  - minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) 10 लौटाता है\n  - minimum_distance_to_post_office(&[(0, 0), (1, 1)]) 2 लौटाता है",
      "hu": "Kiszámítja a minimális össztávolságot az összes lakos és egy postahivatal között, amely a városukban található. A város egy rácsos elrendezésű, ahol az utcák észak-déli és kelet-nyugati irányban futnak, blokkokat alkotva.\n\nA két pont (x1, y1) és (x2, y2) közötti távolságot |x1 - x2| + |y1 - y2| képlettel határozzuk meg.\n\nArgumentumok:\n- residents: Egy szelet tuple-ökből, amelyek mindegyike egy lakos helyének (x, y) koordinátáit jelöli.\n\nVisszatérési érték:\n- A minimális össztávolság az összes lakos és a postahivatal között.\n\nPéldák:\n- minimum_distance_to_post_office(&[(1, 2), (2, 2), (1, 3), (3, -2), (3, 3)]) visszaadja 10\n- minimum_distance_to_post_office(&[(0, 0), (1, 1)]) visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9874682106301279",
      "hy": "0.9886979313191149",
      "bn": "0.990111186480178",
      "bg": "0.9984949776028986",
      "zh": "0.9735402483119615",
      "fr": "0.9806387022390053",
      "de": "0.983170842336438",
      "ha": "0.990081789183785",
      "hi": "0.9693803322419479",
      "hu": "0.9763405394237914"
    }
  },
  {
    "task_id": "Rust/35",
    "prompt": {
      "en": "/*\n  Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "sq": "/*\n  Llogarit numrin maksimal të raketave që mund të kapen nga sistemi, duke pasur parasysh lartësitë e tyre në rendin që detektohen.\n  Sistemi i kapjes mund të kapë çdo lartësi për raketën e parë, por kapjet e mëtejshme duhet të jenë në lartësi më të vogla ose të barabarta me kapjen e mëparshme.\n\n  Argumentet:\n  - heights: Një segment i numrave të plotë që përfaqësojnë lartësitë e raketave hyrëse.\n\n  Kthen:\n  - Një numër i plotë që përfaqëson numrin maksimal të raketave që mund të kapen.\n\n  Shembull:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) kthen 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) kthen 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) kthen 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "hy": "/*\n  Հաշվում է առավելագույն հրթիռների քանակը, որոնք կարող են որսալ համակարգը, հաշվի առնելով դրանց բարձրությունները հայտնաբերման կարգով:\n  Որսման համակարգը կարող է որսալ ցանկացած բարձրություն առաջին հրթիռի համար, բայց հաջորդ որսումները պետք է լինեն նախորդ որսման բարձրությունից փոքր կամ հավասար:\n\n  Արգումենտներ:\n  - heights: Մուտքային հրթիռների բարձրությունները ներկայացնող ամբողջ թվերի կտոր:\n\n  Վերադարձնում է:\n  - Մի ամբողջ թիվ, որը ներկայացնում է առավելագույն հրթիռների քանակը, որոնք կարող են որսալ:\n\n  Օրինակ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) վերադարձնում է 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) վերադարձնում է 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) վերադարձնում է 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "bn": "/*\n  সিস্টেম দ্বারা সর্বাধিক সংখ্যক ক্ষেপণাস্ত্র আটকানো যেতে পারে তা গণনা করে, তাদের উচ্চতা প্রদর্শনের ক্রম অনুযায়ী।\n  প্রতিরক্ষা ব্যবস্থা প্রথম ক্ষেপণাস্ত্রের জন্য যেকোনো উচ্চতা আটকাতে পারে, কিন্তু পরবর্তী আটকানো উচ্চতা অবশ্যই আগের আটকানোর উচ্চতা থেকে কম বা সমান হতে হবে।\n\n  আর্গুমেন্ট:\n  - heights: আসন্ন ক্ষেপণাস্ত্রের উচ্চতা উপস্থাপনকারী পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্ন:\n  - একটি পূর্ণসংখ্যা যা আটকানো যেতে পারে এমন ক্ষেপণাস্ত্রের সর্বাধিক সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "bg": "/*\n  Изчислява максималния брой ракети, които могат да бъдат прихванати от системата, като се имат предвид техните височини в реда, в който са засечени.\n  Системата за прихващане може да прихване всяка височина за първата ракета, но следващите прихващания трябва да бъдат на височини, по-малки или равни на предишното прихващане.\n\n  Аргументи:\n  - heights: Срез от цели числа, представляващи височините на входящите ракети.\n\n  Връща:\n  - Цяло число, представляващо максималния брой ракети, които могат да бъдат прихванати.\n\n  Пример:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) връща 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) връща 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) връща 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "zh": "/*\n  计算系统可以拦截的导弹的最大数量，给定它们被检测到的高度顺序。\n  拦截系统可以拦截第一个导弹的任何高度，但后续的拦截必须在小于或等于上一次拦截的高度。\n\n  参数:\n  - heights: 一个整数切片，表示来袭导弹的高度。\n\n  返回:\n  - 一个整数，表示可以拦截的导弹的最大数量。\n\n  示例:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 返回 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 返回 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 返回 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "fr": "/*\n  Calcule le nombre maximum de missiles qui peuvent être interceptés par le système, étant donné leurs hauteurs dans l'ordre où ils sont détectés.\n  Le système d'interception peut intercepter n'importe quelle hauteur pour le premier missile, mais les interceptions suivantes doivent être à des hauteurs inférieures ou égales à l'interception précédente.\n\n  Arguments :\n  - heights: Une tranche d'entiers représentant les hauteurs des missiles entrants.\n\n  Renvoie :\n  - Un entier représentant le nombre maximum de missiles qui peuvent être interceptés.\n\n  Exemple :\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) renvoie 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) renvoie 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) renvoie 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "de": "/*\n  Berechnet die maximale Anzahl von Raketen, die vom System abgefangen werden können, basierend auf ihren Höhen in der Reihenfolge, in der sie erkannt werden.\n  Das Abfangsystem kann jede Höhe für die erste Rakete abfangen, aber nachfolgende Abfänge müssen in Höhen erfolgen, die kleiner oder gleich dem vorherigen Abfang sind.\n\n  Argumente:\n  - heights: Ein Slice von ganzen Zahlen, das die Höhen der ankommenden Raketen darstellt.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die maximale Anzahl von Raketen darstellt, die abgefangen werden können.\n\n  Beispiel:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) gibt 5 zurück\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) gibt 5 zurück\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) gibt 1 zurück\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "ha": "/*\n  Lissafa yawan makamai masu linzami mafi girma da tsarin zai iya tarewa, la'akari da tsayinsu a jere yadda aka gano su.\n  Tsarin tarewa zai iya tare kowane tsayi don makami na farko, amma tarewa na gaba dole ne su kasance a tsayi daidai ko ƙasa da wanda aka tare a baya.\n\n  Huɗa:\n  - heights: Wani yanki na lambobi masu tsayi da ke wakiltar tsayin makamai masu linzami da ke zuwa.\n\n  Mayar da:\n  - Wani lamba mai tsayi da ke wakiltar yawan makamai masu linzami mafi girma da za a iya tarewa.\n\n  Misali:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "hi": "/*\n  यह प्रणाली द्वारा अवरोधित किए जा सकने वाले अधिकतम मिसाइलों की संख्या की गणना करता है, दिए गए क्रम में उनकी ऊँचाईयों के आधार पर।\n  अवरोधन प्रणाली पहले मिसाइल के लिए किसी भी ऊँचाई को अवरोधित कर सकती है, लेकिन उसके बाद के अवरोधन पिछले अवरोधन के बराबर या उससे कम ऊँचाई पर होने चाहिए।\n\n  तर्क:\n  - heights: आने वाली मिसाइलों की ऊँचाईयों का एक स्लाइस जो पूर्णांकों का प्रतिनिधित्व करता है।\n\n  लौटाता है:\n  - एक पूर्णांक जो दर्शाता है कि कितनी अधिकतम मिसाइलें अवरोधित की जा सकती हैं।\n\n  उदाहरण:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 ",
      "hu": "/*\n  Kiszámítja a maximális számú elfogható rakétát a rendszer által, figyelembe véve a magasságukat az észlelés sorrendjében.\n  Az elfogórendszer bármilyen magasságot elfoghat az első rakétánál, de a további elfogásoknak kisebb vagy egyenlő magasságon kell történniük, mint az előző elfogás.\n\n  Argumentumok:\n  - heights: Egész számok szelete, amely a bejövő rakéták magasságát képviseli.\n\n  Visszatér:\n  - Egy egész szám, amely a maximálisan elfogható rakéták számát képviseli.\n\n  Példa:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) visszatér 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) visszatér 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) visszatér 1\n*/\n\nfn max_missiles_intercepted(heights: &[i32]) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.999100204373912",
      "hy": "0.9756193125102537",
      "bn": "0.9686589066980291",
      "bg": "0.9792119402120317",
      "zh": "0.9650209912693751",
      "fr": "0.999100204373912",
      "de": "0.9683043514678819",
      "ha": "0.9662920270776174",
      "hi": "0.9585768258174603",
      "hu": "0.9923469700491068"
    },
    "canonical_solution": "{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}",
    "instruction": {
      "en": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nՏրամադրել կարճ բնութագիր (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nরাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\n请用不超过500个字符的中文为以下Rust代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn max_missiles_intercepted(heights: &[i32]) -> i32\n{\n    let n = heights.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut dp = vec![1; n];\n\n    for i in 1..n {\n        for j in 0..i {\n            if heights[i] <= heights[j] {\n                dp[i] = dp[i].max(dp[j] + 1);\n            }\n        }\n    }\n\n    *dp.iter().max().unwrap_or(&1)\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8870448612168901",
      "bn": "0.9147228130318156",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9536426485221726",
      "hi": "0.9115359871984918",
      "hu": "0.9307939971613484"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]), 5);\n        assert_eq!(max_missiles_intercepted(&[500, 400, 300, 200, 100]), 5);\n        assert_eq!(max_missiles_intercepted(&[100, 200, 300, 400, 500]), 1);\n    }\n    \n\n}",
    "entry_point": "max_missiles_intercepted",
    "signature": "fn max_missiles_intercepted(heights: &[i32]) -> i32",
    "docstring": {
      "en": "Calculates the maximum number of missiles that can be intercepted by the system, given their heights in the order they are detected.\n  The interception system can intercept any height for the first missile, but subsequent interceptions must be at heights less than or equal to the previous interception.\n\n  Arguments:\n  - heights: A slice of integers representing the heights of incoming missiles.\n\n  Returns:\n  - An integer representing the maximum number of missiles that can be intercepted.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "sq": "Llogarit numrin maksimal të raketave që mund të kapen nga sistemi, duke pasur parasysh lartësitë e tyre në rendin që ato zbulohen. Sistemi i kapjes mund të kapë çdo lartësi për raketën e parë, por kapjet pasuese duhet të jenë në lartësi më të vogla ose të barabarta me kapjen e mëparshme.\n\nArgumentet:\n- heights: Një segment i numrave të plotë që përfaqëson lartësitë e raketave hyrëse.\n\nKthen:\n- Një numër i plotë që përfaqëson numrin maksimal të raketave që mund të kapen.\n\nShembull:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) kthen 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) kthen 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) kthen 1",
      "hy": "Հաշվարկում է առավելագույն հրթիռների քանակը, որոնք կարող են որսալ համակարգը՝ հաշվի առնելով դրանց բարձրությունները հայտնաբերման կարգով:\n  Որսման համակարգը կարող է որսալ ցանկացած բարձրություն առաջին հրթիռի համար, բայց հաջորդ որսումները պետք է լինեն նախորդ որսումից փոքր կամ հավասար բարձրություններում:\n\n  Արհգումենտներ:\n  - heights: Մուտքային հրթիռների բարձրությունները ներկայացնող ամբողջ թվերի շերտ:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է առավելագույն հրթիռների քանակը, որոնք կարող են որսալ:\n\n  Օրինակ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) վերադարձնում է 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) վերադարձնում է 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) վերադարձնում է 1",
      "bn": "মিসাইলগুলির উচ্চতা তাদের সনাক্তকরণের ক্রমে দেওয়া হলে, সিস্টেম দ্বারা আটকানো যেতে পারে এমন সর্বাধিক মিসাইলের সংখ্যা গণনা করে।\n  প্রতিরক্ষা ব্যবস্থা প্রথম মিসাইলের জন্য যেকোনো উচ্চতা আটকাতে পারে, কিন্তু পরবর্তী আটকগুলি অবশ্যই পূর্ববর্তী আটকানোর উচ্চতার সমান বা তার চেয়ে কম উচ্চতায় হতে হবে।\n\n  আর্গুমেন্টস:\n  - heights: আসন্ন মিসাইলগুলির উচ্চতাগুলির প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা আটকানো যেতে পারে এমন সর্বাধিক মিসাইলের সংখ্যা প্রতিনিধিত্ব করে।\n\n  উদাহরণ:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 রিটার্ন করে\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 রিটার্ন করে\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 রিটার্ন করে",
      "bg": "Изчислява максималния брой ракети, които могат да бъдат прихванати от системата, предвид техните височини в реда, в който са засечени. Системата за прихващане може да прихване всяка височина за първата ракета, но следващите прихващания трябва да бъдат на височини, по-малки или равни на предишното прихващане.\n\nАргументи:\n- heights: Списък от цели числа, представляващи височините на пристигащите ракети.\n\nВръща:\n- Цяло число, представляващо максималния брой ракети, които могат да бъдат прихванати.\n\nПример:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) връща 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) връща 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) връща 1",
      "zh": "计算系统可以拦截的导弹最大数量，给定导弹按检测顺序的高度。拦截系统可以拦截第一个导弹的任何高度，但后续的拦截必须在小于或等于上一次拦截的高度。\n\n参数：\n- heights: 一个整数切片，表示来袭导弹的高度。\n\n返回：\n- 一个整数，表示可以拦截的导弹最大数量。\n\n示例：\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 返回 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) 返回 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) 返回 1",
      "fr": "Calcule le nombre maximum de missiles qui peuvent être interceptés par le système, étant donné leurs hauteurs dans l'ordre où ils sont détectés.  \nLe système d'interception peut intercepter n'importe quelle hauteur pour le premier missile, mais les interceptions suivantes doivent être à des hauteurs inférieures ou égales à l'interception précédente.\n\nArguments:\n- heights: Une tranche d'entiers représentant les hauteurs des missiles entrants.\n\nRetours:\n- Un entier représentant le nombre maximum de missiles qui peuvent être interceptés.\n\nExemple:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) retourne 5\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) retourne 5\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) retourne 1",
      "de": "Berechnet die maximale Anzahl von Raketen, die vom System abgefangen werden können, basierend auf deren Höhen in der Reihenfolge, in der sie erkannt werden.\n  Das Abfangsystem kann für die erste Rakete jede Höhe abfangen, aber nachfolgende Abfangvorgänge müssen in Höhen erfolgen, die kleiner oder gleich der vorherigen Abfanghöhe sind.\n\n  Argumente:\n  - heights: Ein Slice von ganzen Zahlen, das die Höhen der ankommenden Raketen darstellt.\n\n  Rückgabewerte:\n  - Eine ganze Zahl, die die maximale Anzahl von Raketen darstellt, die abgefangen werden können.\n\n  Beispiel:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) gibt 5 zurück\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) gibt 5 zurück\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) gibt 1 zurück",
      "ha": "Lissafa yawan makamai masu linzami mafi girma da tsarin zai iya tarewa, la'akari da tsayinsu a cikin tsari da aka gano su.\n  Tsarin kakkabo makamai na iya kakkabo kowanne tsawo don makami na farko, amma kakkabo na gaba dole ne ya kasance a tsawo daidai ko ƙasa da kakkabo na baya.\n\n  Arguments:\n  - heights: Wani yanki na lambobi masu ɗauke da tsayin makaman da ke shigowa.\n\n  Returns:\n  - Wani lamba mai ɗauke da yawan makaman da za a iya kakkabo.\n\n  Example:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) returns 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) returns 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) returns 1",
      "hi": "मिसाइलों की अधिकतम संख्या की गणना करता है जिन्हें सिस्टम द्वारा अवरोधित किया जा सकता है, उनके ऊँचाई के क्रम में जब वे पता लगाए जाते हैं। अवरोधन प्रणाली पहले मिसाइल के लिए किसी भी ऊँचाई को अवरोधित कर सकती है, लेकिन बाद के अवरोधन पिछले अवरोधन के बराबर या उससे कम ऊँचाई पर ही होने चाहिए।\n\nआर्गुमेंट्स:\n- heights: आने वाली मिसाइलों की ऊँचाई का प्रतिनिधित्व करने वाले पूर्णांकों का एक स्लाइस।\n\nरिटर्न्स:\n- एक पूर्णांक जो अवरोधित की जा सकने वाली मिसाइलों की अधिकतम संख्या का प्रतिनिधित्व करता है।\n\nउदाहरण:\n- max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) 5 लौटाता है\n- max_missiles_intercepted(&[500, 400, 300, 200, 100]) 5 लौटाता है\n- max_missiles_intercepted(&[100, 200, 300, 400, 500]) 1 लौटाता है",
      "hu": "Kiszámítja a rendszer által elfogható rakéták maximális számát, figyelembe véve azok magasságát az észlelésük sorrendjében. Az elfogórendszer az első rakétát bármilyen magasságban elfoghatja, de a további elfogásoknak az előző elfogás magasságánál kisebb vagy azzal egyenlő magasságban kell történniük.\n\n  Argumentumok:\n  - heights: Egész számok szelete, amely a bejövő rakéták magasságát jelenti.\n\n  Visszatérési érték:\n  - Egy egész szám, amely az elfogható rakéták maximális számát jelenti.\n\n  Példa:\n  - max_missiles_intercepted(&[300, 250, 275, 252, 200, 138, 245]) visszatér 5\n  - max_missiles_intercepted(&[500, 400, 300, 200, 100]) visszatér 5\n  - max_missiles_intercepted(&[100, 200, 300, 400, 500]) visszatér 1"
    },
    "docstring_bertscore": {
      "sq": "0.9778576782741358",
      "hy": "0.989860514939312",
      "bn": "0.9516817694005962",
      "bg": "0.9944458972855025",
      "zh": "0.9648005115464264",
      "fr": "0.9981304908536996",
      "de": "0.9652756354178619",
      "ha": "0.9682161595787023",
      "hi": "0.97313305603084",
      "hu": "0.9732774603178523"
    }
  },
  {
    "task_id": "Rust/36",
    "prompt": {
      "en": "/*\n  Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "sq": "/*\n  Llogarit numrin e rrugëve që një ushtar mund të ndjekë për të lëvizur nga origjina (0, 0) në një pikë të dhënë (n, m) në një tabelë shahu,\n  duke shmangur pikat e kontrollit të një kali të palëvizshëm të vendosur në (horse_x, horse_y).\n\n  Ushtari mund të lëvizë vetëm një hap djathtas ose një hap poshtë në një kohë. Pikat e kontrollit të kalit përfshijnë pozicionin e tij aktual dhe të gjitha pikat që ai mund të arrijë me një lëvizje. Ushtari duhet të shmangë këto pika kontrolli.\n\n  Argumentet:\n  - n: koordinata x e pikës së destinacionit, një numër i plotë që nuk e kalon 15.\n  - m: koordinata y e pikës së destinacionit, një numër i plotë që nuk e kalon 15.\n  - horse_x: koordinata x e pozicionit të kalit, një numër i plotë.\n  - horse_y: koordinata y e pozicionit të kalit, një numër i plotë.\n\n  Kthen:\n  - Numri total i rrugëve të vlefshme nga (0, 0) në (n, m) duke shmangur pikat e kontrollit të kalit.\n\n  Shembuj:\n  - count_paths(6, 6, 3, 3) kthen 6\n  - count_paths(5, 5, 1, 1) kthen 12\n  - count_paths(7, 7, 2, 2) kthen 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "hy": "/*\n  Հաշվում է այն ուղիների քանակը, որոնք զինվորը կարող է անցնել՝ շախմատի տախտակի սկզբնակետից (0, 0) մինչև տրված կետ (n, m),\n  խուսափելով անշարժ ձիու վերահսկողության կետերից, որը գտնվում է (horse_x, horse_y) կետում:\n\n  Զինվորը կարող է շարժվել միայն մեկ քայլ աջ կամ մեկ քայլ ներքև: Ձիու վերահսկողության կետերը ներառում են իր\n  ընթացիկ դիրքը և բոլոր այն կետերը, որոնց կարող է հասնել մեկ քայլով: Զինվորը պետք է խուսափի այս վերահսկողության կետերից:\n\n  Արգումենտներ:\n  - n: նպատակակետի x-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n  - m: նպատակակետի y-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n  - horse_x: ձիու դիրքի x-կոորդինատը, ամբողջ թիվ:\n  - horse_y: ձիու դիրքի y-կոորդինատը, ամբողջ թիվ:\n\n  Վերադարձնում է:\n  - Ընդհանուր վավեր ուղիների քանակը (0, 0) կետից (n, m) կետ՝ խուսափելով ձիու վերահսկողության կետերից:\n\n  Օրինակներ:\n  - count_paths(6, 6, 3, 3) վերադարձնում է 6\n  - count_paths(5, 5, 1, 1) վերադարձնում է 12\n  - count_paths(7, 7, 2, 2) վերադարձնում է 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
      "bn": "/*\n  একটি দাবার বোর্ডে মূল বিন্দু (0, 0) থেকে একটি নির্দিষ্ট বিন্দু (n, m) পর্যন্ত একটি পানের যাওয়ার পথের সংখ্যা গণনা করে,\n  একটি স্থির ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি (horse_x, horse_y) এ এড়িয়ে।\n\n  পান শুধুমাত্র এক ধাপ ডানে বা এক ধাপ নিচে যেতে পারে। ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি তার বর্তমান অবস্থান এবং সমস্ত বিন্দু\n  যেখানে এটি এক ধাপে পৌঁছাতে পারে অন্তর্ভুক্ত করে। পানকে এই নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে যেতে হবে।\n\n  আর্গুমেন্টসমূহ:\n  - n: গন্তব্য বিন্দুর x-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করে না।\n  - m: গন্তব্য বিন্দুর y-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করে না।\n  - horse_x: ঘোড়ার অবস্থানের x-সমন্বয়, একটি পূর্ণসংখ্যা।\n  - horse_y: ঘোড়ার অবস্থানের y-সমন্বয়, একটি পূর্ণসংখ্যা।\n\n  রিটার্ন করে:\n  - মোট বৈধ পথের সংখ্যা (0, 0) থেকে (n, m) পর্যন্ত ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে।\n\n  উদাহরণসমূহ:\n  - count_paths(6, 6, 3, 3) 6 রিটার্ন করে\n  - count_paths(5, 5, 1, 1) 12 রিটার্ন করে\n  - count_paths(7, 7, 2, 2) 28 রিটার্ন করে\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "bg": "/*\n  Изчислява броя на пътищата, които пешка може да извърви, за да се премести от началната точка (0, 0) до дадена точка (n, m) на шахматна дъска,\n  избягвайки контролните точки на неподвижен кон, разположен на (horse_x, horse_y).\n\n  Пешката може да се движи само с една стъпка надясно или с една стъпка надолу наведнъж. Контролните точки на коня включват неговата \n  текуща позиция и всички точки, до които може да достигне с едно движение. Пешката трябва да избягва тези контролни точки.\n\n  Аргументи:\n  - n: x-координата на крайната точка, цяло число, което не надвишава 15.\n  - m: y-координата на крайната точка, цяло число, което не надвишава 15.\n  - horse_x: x-координата на позицията на коня, цяло число.\n  - horse_y: y-координата на позицията на коня, цяло число.\n\n  Връща:\n  - Общият брой на валидните пътища от (0, 0) до (n, m), избягвайки контролните точки на коня.\n\n  Примери:\n  - count_paths(6, 6, 3, 3) връща 6\n  - count_paths(5, 5, 1, 1) връща 12\n  - count_paths(7, 7, 2, 2) връща 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "zh": "/*\n  计算一个棋子从棋盘的原点 (0, 0) 移动到给定点 (n, m) 的路径数量，\n  避开位于 (horse_x, horse_y) 的静止马的控制点。\n\n  棋子每次只能向右移动一步或向下移动一步。马的控制点包括它的当前位置以及它可以一步到达的所有点。棋子必须避开这些控制点。\n\n  参数:\n  - n: 目的地的 x 坐标，一个不超过 15 的整数。\n  - m: 目的地的 y 坐标，一个不超过 15 的整数。\n  - horse_x: 马的位置的 x 坐标，一个整数。\n  - horse_y: 马的位置的 y 坐标，一个整数。\n\n  返回:\n  - 从 (0, 0) 到 (n, m) 避开马的控制点的有效路径总数。\n\n  示例:\n  - count_paths(6, 6, 3, 3) 返回 6\n  - count_paths(5, 5, 1, 1) 返回 12\n  - count_paths(7, 7, 2, 2) 返回 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "fr": "/*\n  Calcule le nombre de chemins qu'un pion peut emprunter pour se déplacer de l'origine (0, 0) à un point donné (n, m) sur un échiquier,\n  en évitant les points de contrôle d'un cheval stationnaire situé à (horse_x, horse_y).\n\n  Le pion ne peut se déplacer qu'un pas à la fois soit vers la droite, soit vers le bas. Les points de contrôle du cheval incluent sa \n  position actuelle et tous les points qu'il peut atteindre en un mouvement. Le pion doit éviter ces points de contrôle.\n\n  Arguments :\n  - n : coordonnée x du point de destination, un entier ne dépassant pas 15.\n  - m : coordonnée y du point de destination, un entier ne dépassant pas 15.\n  - horse_x : coordonnée x de la position du cheval, un entier.\n  - horse_y : coordonnée y de la position du cheval, un entier.\n\n  Renvoie :\n  - Le nombre total de chemins valides de (0, 0) à (n, m) en évitant les points de contrôle du cheval.\n\n  Exemples :\n  - count_paths(6, 6, 3, 3) renvoie 6\n  - count_paths(5, 5, 1, 1) renvoie 12\n  - count_paths(7, 7, 2, 2) renvoie 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "de": "/*\n  Berechnet die Anzahl der Pfade, die ein Bauer nehmen kann, um sich vom Ursprung (0, 0) zu einem gegebenen Punkt (n, m) auf einem Schachbrett zu bewegen,\n  wobei die Kontrollpunkte eines stationären Pferdes an (horse_x, horse_y) vermieden werden.\n\n  Der Bauer kann sich nur entweder einen Schritt nach rechts oder einen Schritt nach unten bewegen. Die Kontrollpunkte des Pferdes umfassen seine \n  aktuelle Position und alle Punkte, die es in einem Zug erreichen kann. Der Bauer muss diese Kontrollpunkte vermeiden.\n\n  Argumente:\n  - n: x-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n  - m: y-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n  - horse_x: x-Koordinate der Position des Pferdes, eine ganze Zahl.\n  - horse_y: y-Koordinate der Position des Pferdes, eine ganze Zahl.\n\n  Rückgabe:\n  - Die Gesamtanzahl der gültigen Pfade von (0, 0) zu (n, m), die die Kontrollpunkte des Pferdes vermeiden.\n\n  Beispiele:\n  - count_paths(6, 6, 3, 3) gibt 6 zurück\n  - count_paths(5, 5, 1, 1) gibt 12 zurück\n  - count_paths(7, 7, 2, 2) gibt 28 zurück\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize ",
      "ha": "/*\n  Lissafa adadin hanyoyin da pawn zai iya bi don motsawa daga asali (0, 0) zuwa wani matsayi (n, m) akan allo na catur, \n  yana kaucewa wuraren iko na doki mai tsayawa a matsayi (horse_x, horse_y).\n\n  Pawn zai iya motsawa ne kawai ko dai mataki daya zuwa dama ko mataki daya kasa a lokaci guda. Wuraren iko na doki sun hada da \n  matsayinsa na yanzu da duk wuraren da zai iya kaiwa a motsi daya. Pawn dole ne ya kauce wa wadannan wuraren iko.\n\n  Hujojji:\n  - n: x-kwatance na wurin da ake nufi, cikakken lamba da ba zai wuce 15 ba.\n  - m: y-kwatance na wurin da ake nufi, cikakken lamba da ba zai wuce 15 ba.\n  - horse_x: x-kwatance na wurin doki, cikakken lamba.\n  - horse_y: y-kwatance na wurin doki, cikakken lamba.\n\n  Dawo da:\n  - Jimillar adadin hanyoyin da suka dace daga (0, 0) zuwa (n, m) suna kaucewa wuraren iko na doki.\n\n  Misalai:\n  - count_paths(6, 6, 3, 3) yana dawowa 6\n  - count_paths(5, 5, 1, 1) yana dawowa 12\n  - count_paths(7, 7, 2, 2) yana dawowa 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
      "hi": "/*\n  गणना करता है कि एक प्यादा कितने रास्ते ले सकता है ताकि वह उत्पत्ति बिंदु (0, 0) से एक दिए गए बिंदु (n, m) तक शतरंज की बिसात पर जा सके,\n  एक स्थिर घोड़े के नियंत्रण बिंदुओं से बचते हुए जो (horse_x, horse_y) पर स्थित है।\n\n  प्यादा केवल एक समय में या तो एक कदम दाईं ओर या एक कदम नीचे की ओर बढ़ सकता है। घोड़े के नियंत्रण बिंदुओं में उसकी \n  वर्तमान स्थिति और सभी बिंदु शामिल हैं जहां वह एक चाल में पहुंच सकता है। प्यादे को इन नियंत्रण बिंदुओं से बचना चाहिए।\n\n  तर्क:\n  - n: गंतव्य बिंदु का x-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n  - m: गंतव्य बिंदु का y-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n  - horse_x: घोड़े की स्थिति का x-निर्देशांक, एक पूर्णांक।\n  - horse_y: घोड़े की स्थिति का y-निर्देशांक, एक पूर्णांक।\n\n  लौटाता है:\n  - (0, 0) से (n, m) तक घोड़े के नियंत्रण बिंदुओं से बचते हुए कुल वैध रास्तों की संख्या।\n\n  उदाहरण:\n  - count_paths(6, 6, 3, 3) 6 लौटाता है\n  - count_paths(5, 5, 1, 1) 12 लौटाता है\n  - count_paths(7, 7, 2, 2) 28 लौटाता है\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
      "hu": "/*\n  Kiszámítja, hogy hány útvonalon tud egy gyalog eljutni az origóból (0, 0) egy adott pontba (n, m) a sakktáblán,\n  elkerülve egy helyhez kötött ló (horse_x, horse_y) kontrollpontjait.\n\n  A gyalog csak egy lépést tehet jobbra vagy egy lépést lefelé egyszerre. A ló kontrollpontjai közé tartozik a jelenlegi\n  pozíciója és minden pont, amit egy lépéssel elérhet. A gyalognak el kell kerülnie ezeket a kontrollpontokat.\n\n  Argumentumok:\n  - n: a célpont x-koordinátája, egy legfeljebb 15-ös egész szám.\n  - m: a célpont y-koordinátája, egy legfeljebb 15-ös egész szám.\n  - horse_x: a ló pozíciójának x-koordinátája, egy egész szám.\n  - horse_y: a ló pozíciójának y-koordinátája, egy egész szám.\n\n  Visszatér:\n  - Az összes érvényes útvonal száma (0, 0)-tól (n, m)-ig, elkerülve a ló kontrollpontjait.\n\n  Példák:\n  - count_paths(6, 6, 3, 3) visszatér 6\n  - count_paths(5, 5, 1, 1) visszatér 12\n  - count_paths(7, 7, 2, 2) visszatér 28\n*/\n\n\nfn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9641438395067251",
      "hy": "0.9475935588981361",
      "bn": "0.9624707758072683",
      "bg": "0.9690202153611316",
      "zh": "0.9471579624725266",
      "fr": "0.9770925540463895",
      "de": "0.965065881735489",
      "ha": "0.9480567649467095",
      "hi": "0.9825419785500816",
      "hu": "0.9541717998572495"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}",
    "instruction": {
      "en": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nՏվեք կարճ բնութագիր (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\n请用不超过500个字符的中文对Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar Rust a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize\n{\n    let mut dp = vec![vec![0; m+1]; n+1];\n    dp[0][0] = 1;\n    let horse_controls = get_horse_control_points(horse_x, horse_y, n, m);\n\n    for i in 0..=n {\n        for j in 0..=m {\n            if horse_controls.contains(&(i, j)) {\n                dp[i][j] = 0;\n            } else {\n                if i > 0 {\n                    dp[i][j] += dp[i - 1][j];\n                }\n                if j > 0 {\n                    dp[i][j] += dp[i][j - 1];\n                }\n            }\n        }\n    }\n    dp[n][m]\n}\n\nfn get_horse_control_points(x: usize, y: usize, n: usize, m: usize) -> Vec<(usize, usize)> {\n    let moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2), (2, -1), (2, 1)];\n    let mut controls = vec![(x, y)];\n    for (dx, dy) in moves.iter() {\n        let new_x = x as isize + dx;\n        let new_y = y as isize + dy;\n        if new_x >= 0 && new_x <= n as isize && new_y >= 0 && new_y <= m as isize {\n            controls.push((new_x as usize, new_y as usize));\n        }\n    }\n    controls\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8870448612168901",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.9173103710055571",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_paths(6, 6, 3, 3), 6);\n        assert_eq!(count_paths(5, 5, 1, 1), 10);\n        assert_eq!(count_paths(7, 7, 2, 2), 0);\n    }\n    \n\n}",
    "entry_point": "count_paths",
    "signature": "fn count_paths(n: usize, m: usize, horse_x: usize, horse_y: usize) -> usize",
    "docstring": {
      "en": "Calculates the number of paths a pawn can take to move from the origin (0, 0) to a given point (n, m) on a chessboard,\n  avoiding the control points of a stationary horse located at (horse_x, horse_y).\n\n  The pawn can only move either one step to the right or one step down at a time. The horse's control points include its \n  current position and all the points it can reach in one move. The pawn must avoid these control points.\n\n  Arguments:\n  - n: x-coordinate of the destination point, an integer not exceeding 15.\n  - m: y-coordinate of the destination point, an integer not exceeding 15.\n  - horse_x: x-coordinate of the horse's position, an integer.\n  - horse_y: y-coordinate of the horse's position, an integer.\n\n  Returns:\n  - The total number of valid paths from (0, 0) to (n, m) avoiding the horse's control points.\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28",
      "sq": "Llogarit numrin e rrugëve që një ushtar mund të marrë për të lëvizur nga origjina (0, 0) në një pikë të dhënë (n, m) në një tabelë shahu,\nduke shmangur pikat e kontrollit të një kali të palëvizshëm të vendosur në (horse_x, horse_y).\n\nUshtari mund të lëvizë vetëm një hap djathtas ose një hap poshtë në një kohë. Pikat e kontrollit të kalit përfshijnë pozicionin e tij aktual dhe të gjitha pikat që ai mund të arrijë me një lëvizje. Ushtari duhet të shmangë këto pika kontrolli.\n\nArgumentet:\n- n: koordinata x e pikës së destinacionit, një numër i plotë që nuk tejkalon 15.\n- m: koordinata y e pikës së destinacionit, një numër i plotë që nuk tejkalon 15.\n- horse_x: koordinata x e pozicionit të kalit, një numër i plotë.\n- horse_y: koordinata y e pozicionit të kalit, një numër i plotë.\n\nKthen:\n- Numri total i rrugëve të vlefshme nga (0, 0) në (n, m) duke shmangur pikat e kontrollit të kalit.\n\nShembuj:\n- count_paths(6, 6, 3, 3) kthen 6\n- count_paths(5, 5, 1, 1) kthen 12\n- count_paths(7, 7, 2, 2) kthen 28",
      "hy": "Հաշվում է ուղիների քանակը, որով զինվորը կարող է շարժվել սկզբնակետից (0, 0) մինչև տրված կետը (n, m) շախմատի տախտակի վրա՝ խուսափելով (horse_x, horse_y) տեղակայված անշարժ ձիու վերահսկման կետերից:\n\nԶինվորը կարող է շարժվել միայն մեկ քայլ աջ կամ մեկ քայլ ներքև: Ձիու վերահսկման կետերը ներառում են նրա ընթացիկ դիրքը և բոլոր այն կետերը, որոնք նա կարող է հասնել մեկ քայլով: Զինվորը պետք է խուսափի այս վերահսկման կետերից:\n\nԱրձանագրումներ:\n- n: նպատակակետի x-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n- m: նպատակակետի y-կոորդինատը, ամբողջ թիվ, որը չի գերազանցում 15-ը:\n- horse_x: ձիու դիրքի x-կոորդինատը, ամբողջ թիվ:\n- horse_y: ձիու դիրքի y-կոորդինատը, ամբողջ թիվ:\n\nՎերադարձնում է:\n- Ընդհանուր վավեր ուղիների քանակը (0, 0) կետից (n, m) կետ՝ խուսափելով ձիու վերահսկման կետերից:\n\nՕրինակներ:\n- count_paths(6, 6, 3, 3) վերադարձնում է 6\n- count_paths(5, 5, 1, 1) վերադարձնում է 12\n- count_paths(7, 7, 2, 2) վերադարձնում է 28",
      "bn": "একটি দাবার গুটির কতগুলি পথ আছে তা গণনা করে যা মূল বিন্দু (0, 0) থেকে একটি নির্দিষ্ট বিন্দু (n, m) পর্যন্ত যেতে পারে, একটি স্থির ঘোড়ার নিয়ন্ত্রণ বিন্দু (horse_x, horse_y) এড়িয়ে।\n\n  গুটি কেবলমাত্র এক ধাপ ডানদিকে বা এক ধাপ নিচে যেতে পারে। ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এর বর্তমান অবস্থান এবং সমস্ত বিন্দু অন্তর্ভুক্ত করে যা এটি এক ধাপে পৌঁছাতে পারে। গুটিকে এই নিয়ন্ত্রণ বিন্দুগুলি এড়াতে হবে।\n\n  আর্গুমেন্টসমূহ:\n  - n: গন্তব্য বিন্দুর x-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করে না।\n  - m: গন্তব্য বিন্দুর y-সমন্বয়, একটি পূর্ণসংখ্যা যা 15 অতিক্রম করে না।\n  - horse_x: ঘোড়ার অবস্থানের x-সমন্বয়, একটি পূর্ণসংখ্যা।\n  - horse_y: ঘোড়ার অবস্থানের y-সমন্বয়, একটি পূর্ণসংখ্যা।\n\n  রিটার্নস:\n  - মোট বৈধ পথের সংখ্যা (0, 0) থেকে (n, m) পর্যন্ত, ঘোড়ার নিয়ন্ত্রণ বিন্দুগুলি এড়িয়ে।\n\n  উদাহরণ:\n  - count_paths(6, 6, 3, 3) 6 রিটার্ন করে\n  - count_paths(5, 5, 1, 1) 12 রিটার্ন করে\n  - count_paths(7, 7, 2, 2) 28 রিটার্ন করে",
      "bg": "Изчислява броя на пътищата, по които пешката може да се движи от началната точка (0, 0) до дадена точка (n, m) на шахматната дъска, като избягва контролните точки на неподвижен кон, разположен на (horse_x, horse_y).\n\nПешката може да се движи само с една стъпка надясно или с една стъпка надолу наведнъж. Контролните точки на коня включват неговата текуща позиция и всички точки, които може да достигне с едно движение. Пешката трябва да избягва тези контролни точки.\n\nАргументи:\n- n: x-координата на крайната точка, цяло число, което не надвишава 15.\n- m: y-координата на крайната точка, цяло число, което не надвишава 15.\n- horse_x: x-координата на позицията на коня, цяло число.\n- horse_y: y-координата на позицията на коня, цяло число.\n\nВръща:\n- Общият брой на валидните пътища от (0, 0) до (n, m), избягвайки контролните точки на коня.\n\nПримери:\n- count_paths(6, 6, 3, 3) връща 6\n- count_paths(5, 5, 1, 1) връща 12\n- count_paths(7, 7, 2, 2) връща 28",
      "zh": "计算一个兵从原点 (0, 0) 移动到棋盘上给定点 (n, m) 的路径数量，避开位于 (horse_x, horse_y) 的静止马的控制点。\n\n兵只能每次向右移动一步或向下移动一步。马的控制点包括其当前位置及其一步之内可以到达的所有点。兵必须避开这些控制点。\n\n参数:\n- n: 目的地点的 x 坐标，一个不超过 15 的整数。\n- m: 目的地点的 y 坐标，一个不超过 15 的整数。\n- horse_x: 马的位置的 x 坐标，一个整数。\n- horse_y: 马的位置的 y 坐标，一个整数。\n\n返回:\n- 从 (0, 0) 到 (n, m) 的所有有效路径的总数，避开马的控制点。\n\n示例:\n- count_paths(6, 6, 3, 3) 返回 6\n- count_paths(5, 5, 1, 1) 返回 12\n- count_paths(7, 7, 2, 2) 返回 28",
      "fr": "Calcule le nombre de chemins qu'un pion peut emprunter pour se déplacer de l'origine (0, 0) à un point donné (n, m) sur un échiquier, en évitant les points de contrôle d'un cheval stationnaire situé à (horse_x, horse_y).\n\nLe pion ne peut se déplacer qu'un pas à la fois vers la droite ou vers le bas. Les points de contrôle du cheval incluent sa position actuelle et tous les points qu'il peut atteindre en un mouvement. Le pion doit éviter ces points de contrôle.\n\nArguments:\n- n: coordonnée x du point de destination, un entier ne dépassant pas 15.\n- m: coordonnée y du point de destination, un entier ne dépassant pas 15.\n- horse_x: coordonnée x de la position du cheval, un entier.\n- horse_y: coordonnée y de la position du cheval, un entier.\n\nRetourne:\n- Le nombre total de chemins valides de (0, 0) à (n, m) en évitant les points de contrôle du cheval.\n\nExemples:\n- count_paths(6, 6, 3, 3) retourne 6\n- count_paths(5, 5, 1, 1) retourne 12\n- count_paths(7, 7, 2, 2) retourne 28",
      "de": "Berechnet die Anzahl der Pfade, die ein Bauer nehmen kann, um vom Ursprung (0, 0) zu einem gegebenen Punkt (n, m) auf einem Schachbrett zu gelangen, wobei die Kontrollpunkte eines stationären Pferdes bei (horse_x, horse_y) vermieden werden.\n\nDer Bauer kann sich nur entweder einen Schritt nach rechts oder einen Schritt nach unten bewegen. Die Kontrollpunkte des Pferdes umfassen seine aktuelle Position und alle Punkte, die es in einem Zug erreichen kann. Der Bauer muss diese Kontrollpunkte vermeiden.\n\nArgumente:\n- n: x-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n- m: y-Koordinate des Zielpunkts, eine ganze Zahl, die 15 nicht überschreitet.\n- horse_x: x-Koordinate der Position des Pferdes, eine ganze Zahl.\n- horse_y: y-Koordinate der Position des Pferdes, eine ganze Zahl.\n\nRückgabewerte:\n- Die Gesamtanzahl der gültigen Pfade von (0, 0) zu (n, m), die die Kontrollpunkte des Pferdes vermeiden.\n\nBeispiele:\n- count_paths(6, 6, 3, 3) gibt 6 zurück\n- count_paths(5, 5, 1, 1) gibt 12 zurück\n- count_paths(7, 7, 2, 2) gibt 28 zurück",
      "ha": "Yana lissafin adadin hanyoyin da pawn zai iya ɗauka don motsawa daga asali (0, 0) zuwa wani wuri (n, m) akan allo na catur, yana guje wa wuraren sarrafawa na doki mai tsayawa wanda yake a (horse_x, horse_y).\n\nPawn ɗin zai iya motsawa ne kawai ko dai mataki ɗaya zuwa dama ko mataki ɗaya ƙasa a lokaci guda. Wuraren sarrafawa na doki sun haɗa da matsayinsa na yanzu da duk wuraren da zai iya kaiwa a cikin motsi ɗaya. Pawn ɗin dole ne ya guje wa waɗannan wuraren sarrafawa.\n\nHujjoji:\n- n: x-kowodin wurin da ake nufi, cikakken lamba da ba zai wuce 15 ba.\n- m: y-kowodin wurin da ake nufi, cikakken lamba da ba zai wuce 15 ba.\n- horse_x: x-kowodin wurin doki, cikakken lamba.\n- horse_y: y-kowodin wurin doki, cikakken lamba.\n\nYana Mayarwa:\n- Jimillar adadin hanyoyin da suka dace daga (0, 0) zuwa (n, m) yana guje wa wuraren sarrafawa na doki.\n\nMisalai:\n- count_paths(6, 6, 3, 3) yana mayar da 6\n- count_paths(5, 5, 1, 1) yana mayar da 12\n- count_paths(7, 7, 2, 2) yana mayar da 28",
      "hi": "प्यादा शतरंज की बिसात पर मूल बिंदु (0, 0) से एक दिए गए बिंदु (n, m) तक जाने के लिए कितने रास्ते ले सकता है, इसकी गणना करता है, जो (horse_x, horse_y) पर स्थित स्थिर घोड़े के नियंत्रण बिंदुओं से बचते हुए।\n\n  प्यादा केवल एक बार में या तो एक कदम दाईं ओर या एक कदम नीचे की ओर ही चल सकता है। घोड़े के नियंत्रण बिंदुओं में उसकी वर्तमान स्थिति और वे सभी बिंदु शामिल हैं जिन्हें वह एक चाल में पहुंच सकता है। प्यादे को इन नियंत्रण बिंदुओं से बचना चाहिए।\n\n  Arguments:\n  - n: गंतव्य बिंदु का x-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n  - m: गंतव्य बिंदु का y-निर्देशांक, एक पूर्णांक जो 15 से अधिक नहीं है।\n  - horse_x: घोड़े की स्थिति का x-निर्देशांक, एक पूर्णांक।\n  - horse_y: घोड़े की स्थिति का y-निर्देशांक, एक पूर्णांक।\n\n  Returns:\n  - (0, 0) से (n, m) तक घोड़े के नियंत्रण बिंदुओं से बचते हुए कुल मान्य रास्तों की संख्या।\n\n  Examples:\n  - count_paths(6, 6, 3, 3) returns 6\n  - count_paths(5, 5, 1, 1) returns 12\n  - count_paths(7, 7, 2, 2) returns 28",
      "hu": "Kiszámítja, hány útvonalon tud egy gyalog eljutni az origóból (0, 0) egy adott pontba (n, m) a sakktáblán, elkerülve egy álló ló kontrollpontjait, amely a (ló_x, ló_y) helyen található.\n\nA gyalog csak egy lépést tehet jobbra vagy egy lépést lefelé egyszerre. A ló kontrollpontjai közé tartozik a jelenlegi pozíciója és minden pont, amelyet egy lépésben elérhet. A gyalognak el kell kerülnie ezeket a kontrollpontokat.\n\nArgumentumok:\n- n: a célpont x-koordinátája, egy legfeljebb 15-ös egész szám.\n- m: a célpont y-koordinátája, egy legfeljebb 15-ös egész szám.\n- ló_x: a ló pozíciójának x-koordinátája, egy egész szám.\n- ló_y: a ló pozíciójának y-koordinátája, egy egész szám.\n\nVisszatérési érték:\n- Az összes érvényes útvonal száma (0, 0)-tól (n, m)-ig, elkerülve a ló kontrollpontjait.\n\nPéldák:\n- count_paths(6, 6, 3, 3) visszaadja 6\n- count_paths(5, 5, 1, 1) visszaadja 12\n- count_paths(7, 7, 2, 2) visszaadja 28"
    },
    "docstring_bertscore": {
      "sq": "0.9615966035003337",
      "hy": "0.9556668907352992",
      "bn": "0.9326100747351503",
      "bg": "0.968675393019655",
      "zh": "0.9507831655567943",
      "fr": "0.9711684029320239",
      "de": "0.9807425859282866",
      "ha": "0.9804611266783602",
      "hi": "0.9919133599273077",
      "hu": "0.9326341090112557"
    }
  },
  {
    "task_id": "Rust/37",
    "prompt": {
      "en": "/*\n  Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "sq": "/*\n  Llogarit diferencën midis numrit të kth më të madh dhe numrit të kth më të vogël në një listë të dhënë të numrave të plotë.\n  Nëse numri i kth më i madh ose më i vogël nuk ekziston, funksioni kthen None.\n\n  Argumentet:\n  - numbers: Një Vec<i32> që përfaqëson sekuencën e numrave të plotë jo-negativë.\n  - k: Një vlerë usize që përfaqëson pozicionin e kth.\n\n  Kthen:\n  - Një vlerë Option<i32> që përfaqëson diferencën nëse të dy numrat i kth më i madh dhe më i vogël ekzistojnë, përndryshe None.\n\n  Shembull:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) kthen Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) kthen None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "hy": "/*\n  Հաշվում է տրված ամբողջ թվերի ցուցակի k-րդ ամենամեծ և k-րդ ամենափոքր թվերի տարբերությունը:\n  Եթե k-րդ ամենամեծ կամ ամենափոքր թիվը գոյություն չունի, ֆունկցիան վերադարձնում է None:\n\n  Արգումենտներ:\n  - numbers: A Vec<i32> ներկայացնող ոչ բացասական ամբողջ թվերի հաջորդականությունը:\n  - k: A usize արժեք ներկայացնող k-րդ դիրքը:\n\n  Վերադարձնում է:\n  - An Option<i32> արժեք, որը ներկայացնում է տարբերությունը, եթե k-րդ ամենամեծ և ամենափոքր թվերը գոյություն ունեն, հակառակ դեպքում՝ None:\n\n  Օրինակ:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) վերադարձնում է Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) վերադարձնում է None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "bn": "/*\n  প্রদত্ত পূর্ণসংখ্যার তালিকায় kth বৃহত্তম এবং kth ক্ষুদ্রতম সংখ্যার মধ্যে পার্থক্য গণনা করে।\n  যদি kth বৃহত্তম বা ক্ষুদ্রতম সংখ্যা বিদ্যমান না থাকে, তাহলে ফাংশনটি None প্রদান করে।\n\n  আর্গুমেন্ট:\n  - numbers: একটি Vec<i32> যা অ-ঋণাত্মক পূর্ণসংখ্যার ক্রম উপস্থাপন করে।\n  - k: একটি usize মান যা kth অবস্থান উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি Option<i32> মান যা পার্থক্য উপস্থাপন করে যদি উভয় kth বৃহত্তম এবং ক্ষুদ্রতম সংখ্যা বিদ্যমান থাকে, অন্যথায় None।\n\n  উদাহরণ:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "bg": "/*\n  Изчислява разликата между k-тото най-голямо и k-тото най-малко число в даден списък от цели числа.\n  Ако k-тото най-голямо или най-малко число не съществува, функцията връща None.\n\n  Аргументи:\n  - numbers: Vec<i32>, представляващ последователност от неотрицателни цели числа.\n  - k: Стойност от тип usize, представляваща k-тата позиция.\n\n  Връща:\n  - Стойност от тип Option<i32>, представляваща разликата, ако съществуват и двете k-то най-голямо и най-малко число, в противен случай None.\n\n  Пример:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) връща Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) връща None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "zh": "/*\n  计算给定整数列表中第k大和第k小数字之间的差值。\n  如果第k大或第k小数字不存在，函数返回None。\n\n  参数:\n  - numbers: 一个Vec<i32>，表示非负整数序列。\n  - k: 一个usize值，表示第k个位置。\n\n  返回:\n  - 一个Option<i32>值，如果第k大和第k小数字都存在则表示差值，否则返回None。\n\n  示例:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) 返回 Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) 返回 None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "fr": "/*\n  Calcule la différence entre le k-ième plus grand et le k-ième plus petit nombre dans une liste donnée d'entiers.\n  Si le k-ième plus grand ou plus petit nombre n'existe pas, la fonction retourne None.\n\n  Arguments:\n  - numbers: Un Vec<i32> représentant la séquence d'entiers non négatifs.\n  - k: Une valeur usize représentant la position k-ième.\n\n  Retourne:\n  - Une valeur Option<i32> représentant la différence si les deux k-ième plus grands et plus petits nombres existent, sinon None.\n\n  Exemple:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) retourne Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) retourne None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "de": "/*\n  Berechnet die Differenz zwischen der k-größten und der k-kleinsten Zahl in einer gegebenen Liste von ganzen Zahlen.\n  Wenn die k-größte oder k-kleinste Zahl nicht existiert, gibt die Funktion None zurück.\n\n  Argumente:\n  - numbers: Ein Vec<i32>, der die Sequenz von nicht-negativen ganzen Zahlen darstellt.\n  - k: Ein usize-Wert, der die k-te Position darstellt.\n\n  Rückgabewert:\n  - Ein Option<i32>-Wert, der die Differenz darstellt, wenn sowohl die k-größte als auch die k-kleinste Zahl existieren, andernfalls None.\n\n  Beispiel:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) gibt Some(4) zurück // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) gibt None zurück\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "ha": "/*\n  Lissafa bambanci tsakanin lamba ta k mafi girma da ta k mafi ƙanƙanta a cikin jerin lambobin cikakku da aka bayar.\n  Idan lamba ta k mafi girma ko mafi ƙanƙanta ba ta wanzu, aikin yana dawowa da None.\n\n  Huɗɗa:\n  - numbers: A Vec<i32> yana wakiltar jeri na lambobin cikakku marasa tabbatacce.\n  - k: Wani ƙima na usize yana wakiltar matsayi na k.\n\n  Dawowa:\n  - Wani ƙima na Option<i32> yana wakiltar bambanci idan duka lambobin ta k mafi girma da mafi ƙanƙanta suna wanzu, in ba haka ba None.\n\n  Misali:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) yana dawowa Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) yana dawowa None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "hi": "/*\n  दिए गए पूर्णांकों की सूची में से kवें सबसे बड़े और kवें सबसे छोटे संख्याओं के बीच का अंतर गणना करता है।\n  यदि kवीं सबसे बड़ी या सबसे छोटी संख्या मौजूद नहीं है, तो फ़ंक्शन None लौटाता है।\n\n  तर्क:\n  - numbers: गैर-ऋणात्मक पूर्णांकों का अनुक्रम दर्शाने वाला Vec<i32>।\n  - k: kवें स्थान को दर्शाने वाला usize मान।\n\n  लौटाता है:\n  - एक Option<i32> मान जो अंतर को दर्शाता है यदि दोनों kवें सबसे बड़े और सबसे छोटे संख्याएँ मौजूद हैं, अन्यथा None।\n\n  उदाहरण:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) लौटाता है // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None लौटाता है\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> ",
      "hu": "/*\n  Kiszámítja a különbséget a k-adik legnagyobb és a k-adik legkisebb szám között egy adott egész számokat tartalmazó listában.\n  Ha a k-adik legnagyobb vagy legkisebb szám nem létezik, a függvény None értéket ad vissza.\n\n  Argumentumok:\n  - numbers: Egy Vec<i32>, amely a nem-negatív egész számok sorozatát képviseli.\n  - k: Egy usize érték, amely a k-adik pozíciót jelöli.\n\n  Visszatérési érték:\n  - Egy Option<i32> érték, amely a különbséget képviseli, ha mindkét k-adik legnagyobb és legkisebb szám létezik, különben None.\n\n  Példa:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) visszatér Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) visszatér None\n*/\nfn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32> "
    },
    "prompt_bertscore": {
      "sq": "0.971698150158244",
      "hy": "0.9563289257952885",
      "bn": "0.9937743279672235",
      "bg": "0.9594492104509655",
      "zh": "0.9508018368126117",
      "fr": "0.9711944235119395",
      "de": "0.9544556426717484",
      "ha": "0.9616524186374045",
      "hi": "0.9673842955429283",
      "hu": "0.9707349914406058"
    },
    "canonical_solution": "{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}",
    "instruction": {
      "en": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\n请用中文为以下 Rust 代码提供简洁的自然语言描述（文档字符串），字数不超过 500 个字符。",
      "fr": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Rust a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>\n{\n    if numbers.len() < k {\n        return None;\n    }\n\n    let mut sorted_numbers = numbers.clone();\n    sorted_numbers.sort_unstable();\n\n    let kth_smallest = sorted_numbers[k - 1];\n    let kth_largest = sorted_numbers[sorted_numbers.len() - k];\n\n    Some(kth_largest - kth_smallest)\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9423368058640478",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8627098587147819",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n     \n        assert_eq!(kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2), Some(4)); // 5 - 1 = 4\n        assert_eq!(kth_largest_minus_kth_smallest(vec![10, 20, 30], 4), None);\n        assert_eq!(kth_largest_minus_kth_smallest(vec![7, 7, 7, 7], 1), Some(0)); // 7 - 7 = 0\n        \n        \n    }\n    \n\n}",
    "entry_point": "kth_largest_minus_kth_smallest",
    "signature": "fn kth_largest_minus_kth_smallest(numbers: Vec<i32>, k: usize) -> Option<i32>",
    "docstring": {
      "en": "Calculates the difference between the kth largest and kth smallest numbers in a given list of integers.\n  If the kth largest or smallest number does not exist, the function returns None.\n\n  Arguments:\n  - numbers: A Vec<i32> representing the sequence of non-negative integers.\n  - k: A usize value representing the kth position.\n\n  Returns:\n  - An Option<i32> value representing the difference if both kth largest and smallest numbers exist, otherwise None.\n\n  Example:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "sq": "Llogarit ndryshimin midis numrit të kth më të madh dhe numrit të kth më të vogël në një listë të dhënë të numrave të plotë.\n  Nëse numri i kth më i madh ose më i vogël nuk ekziston, funksioni kthen None.\n\n  Argumentet:\n  - numbers: Një Vec<i32> që përfaqëson sekuencën e numrave të plotë jo-negativë.\n  - k: Një vlerë usize që përfaqëson pozicionin e kth.\n\n  Kthen:\n  - Një vlerë Option<i32> që përfaqëson ndryshimin nëse ekzistojnë si numri i kth më i madh ashtu edhe më i vogël, përndryshe None.\n\n  Shembull:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) kthen Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) kthen None",
      "hy": "Հաշվում է տրված ամբողջ թվերի ցուցակի k-րդ ամենամեծ և k-րդ ամենափոքր թվերի տարբերությունը։ \nԵթե k-րդ ամենամեծ կամ ամենափոքր թիվը գոյություն չունի, ֆունկցիան վերադարձնում է None։\n\nԱրգումենտներ:\n- numbers: A Vec<i32>, որը ներկայացնում է ոչ բացասական ամբողջ թվերի հաջորդականությունը։\n- k: A usize արժեք, որը ներկայացնում է k-րդ դիրքը։\n\nՎերադարձնում է:\n- An Option<i32> արժեք, որը ներկայացնում է տարբերությունը, եթե k-րդ ամենամեծ և ամենափոքր թվերը գոյություն ունեն, հակառակ դեպքում՝ None։\n\nՕրինակ:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) վերադարձնում է Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) վերադարձնում է None",
      "bn": "দেওয়া পূর্ণসংখ্যার তালিকায় k-তম বৃহত্তম এবং k-তম ক্ষুদ্রতম সংখ্যার মধ্যে পার্থক্য গণনা করে।  \nযদি k-তম বৃহত্তম বা ক্ষুদ্রতম সংখ্যা বিদ্যমান না থাকে, তাহলে ফাংশনটি None প্রদান করে।\n\nআর্গুমেন্টস:\n- numbers: একটি Vec<i32> যা অ-ঋণাত্মক পূর্ণসংখ্যার ক্রম উপস্থাপন করে।\n- k: একটি usize মান যা k-তম অবস্থান উপস্থাপন করে।\n\nরিটার্নস:\n- একটি Option<i32> মান যা পার্থক্য উপস্থাপন করে যদি উভয় k-তম বৃহত্তম এবং ক্ষুদ্রতম সংখ্যা বিদ্যমান থাকে, অন্যথায় None।\n\nউদাহরণ:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "bg": "Изчислява разликата между k-тото по големина и k-тото по малко число в даден списък от цели числа. Ако k-тото по големина или малко число не съществува, функцията връща None.\n\nАргументи:\n- numbers: Vec<i32>, представляващ последователността от неотрицателни цели числа.\n- k: Стойност от тип usize, представляваща k-тата позиция.\n\nВръща:\n- Стойност от тип Option<i32>, представляваща разликата, ако и двете k-ти по големина и малко числа съществуват, в противен случай None.\n\nПример:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) връща Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) връща None",
      "zh": "计算给定整数列表中第k大和第k小数字之间的差值。\n如果第k大或第k小的数字不存在，函数返回None。\n\n参数:\n- numbers: 一个Vec<i32>，表示非负整数的序列。\n- k: 一个usize值，表示第k个位置。\n\n返回:\n- 一个Option<i32>值，如果第k大和第k小的数字都存在，则表示它们的差值，否则返回None。\n\n示例:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) 返回 Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) 返回 None",
      "fr": "Calcule la différence entre le k-ième plus grand et le k-ième plus petit nombre dans une liste donnée d'entiers.\n  Si le k-ième plus grand ou plus petit nombre n'existe pas, la fonction renvoie None.\n\n  Arguments:\n  - numbers: Un Vec<i32> représentant la séquence d'entiers non négatifs.\n  - k: Une valeur usize représentant la position k-ième.\n\n  Renvoie:\n  - Une valeur Option<i32> représentant la différence si les deux k-ièmes plus grands et plus petits nombres existent, sinon None.\n\n  Exemple:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) renvoie Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) renvoie None",
      "de": "Berechnet die Differenz zwischen der k-größten und der k-kleinsten Zahl in einer gegebenen Liste von ganzen Zahlen. Wenn die k-größte oder k-kleinste Zahl nicht existiert, gibt die Funktion None zurück.\n\nArgumente:\n- numbers: Ein Vec<i32>, der die Sequenz von nicht-negativen ganzen Zahlen darstellt.\n- k: Ein usize-Wert, der die k-te Position darstellt.\n\nRückgabewerte:\n- Ein Option<i32>-Wert, der die Differenz darstellt, wenn sowohl die k-größte als auch die k-kleinste Zahl existieren, andernfalls None.\n\nBeispiel:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) gibt Some(4) zurück // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) gibt None zurück",
      "ha": "Lissafa bambanci tsakanin lamba ta k mafi girma da lamba ta k mafi ƙanƙanta a cikin jerin lambobin cikakku da aka bayar.\n  Idan ba a sami lamba mafi girma ko mafi ƙanƙanta ba, aikin yana mayar da None.\n\nArguments: \n- numbers: A Vec<i32> wanda ke wakiltar jerin lambobin da ba su da korau. \n- k: Wani usize darajar da ke wakiltar matsayin k.\n\nReturns: \n- An Option<i32> darajar da ke wakiltar bambanci idan duka lambobin mafi girma da mafi ƙanƙanta na k suna nan, in ba haka ba None.\n\nExample: \n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) returns Some(4) // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) returns None",
      "hi": "kth सबसे बड़े और kth सबसे छोटे संख्याओं के बीच का अंतर गणना करता है एक दिए गए पूर्णांकों की सूची में।  \nयदि kth सबसे बड़ी या सबसे छोटी संख्या मौजूद नहीं है, तो फ़ंक्शन None लौटाता है।\n\nआर्गुमेंट्स:\n- numbers: एक Vec<i32> जो गैर-ऋणात्मक पूर्णांकों के अनुक्रम का प्रतिनिधित्व करता है।\n- k: एक usize मान जो kth स्थिति का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\n- एक Option<i32> मान जो अंतर का प्रतिनिधित्व करता है यदि दोनों kth सबसे बड़ी और सबसे छोटी संख्याएं मौजूद हैं, अन्यथा None।\n\nउदाहरण:\n- kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) Some(4) लौटाता है // (5 - 1)\n- kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) None लौटाता है",
      "hu": "Kiszámítja a különbséget a megadott egész számokat tartalmazó lista k-adik legnagyobb és k-adik legkisebb száma között. Ha a k-adik legnagyobb vagy legkisebb szám nem létezik, a függvény None értéket ad vissza.\n\n  Argumentumok:\n  - numbers: Egy Vec<i32>, amely a nem negatív egész számok sorozatát képviseli.\n  - k: Egy usize érték, amely a k-adik pozíciót jelöli.\n\n  Visszatérési érték:\n  - Egy Option<i32> érték, amely a különbséget jelenti, ha mind a k-adik legnagyobb, mind a legkisebb szám létezik, ellenkező esetben None.\n\n  Példa:\n  - kth_largest_minus_kth_smallest(vec![3, 1, 4, 1, 5, 9, 2], 2) visszaadja Some(4) // (5 - 1)\n  - kth_largest_minus_kth_smallest(vec![10, 20, 30], 4) visszaadja None"
    },
    "docstring_bertscore": {
      "sq": "0.9839812542910604",
      "hy": "0.9659732253160564",
      "bn": "0.9691797155571026",
      "bg": "0.970662491351528",
      "zh": "0.9474292915730202",
      "fr": "0.9687028040122379",
      "de": "0.9521467631225988",
      "ha": "0.9779512331836032",
      "hi": "0.9957224947444137",
      "hu": "0.9637465787446553"
    }
  },
  {
    "task_id": "Rust/38",
    "prompt": {
      "en": "/*\n  Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "sq": "/*\n  Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohor nga një grup bimësh, secila me kërkesën e vet kohore dhe vlerën.\n\n  Argumentet:\n  - total_time: Një u32 që përfaqëson kohën totale të disponueshme për mbledhjen e bimëve.\n  - herbs: Një segment tuplesh, ku çdo tuple përmban dy vlera u32 që përfaqësojnë kohën e kërkuar për të mbledhur një bimë dhe vlerën e saj, respektivisht.\n\n  Kthen:\n  - Një u32 që përfaqëson vlerën maksimale totale të bimëve që mund të mblidhen brenda kohës së dhënë.\n\n  Shembuj:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) kthen 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) kthen 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) kthen 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "hy": "/*\n  Հաշվում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակային սահմանափակման շրջանակներում խոտաբույսերի հավաքածուից, որոնցից յուրաքանչյուրը ունի իր ժամանակային պահանջը և արժեքը:\n\n  Արգումենտներ:\n  - total_time: u32, որը ներկայացնում է խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n  - herbs: զույգերի կտոր, որտեղ յուրաքանչյուր զույգ պարունակում է երկու u32 արժեք, որոնք ներկայացնում են խոտաբույս հավաքելու համար պահանջվող ժամանակը և դրա արժեքը, համապատասխանաբար:\n\n  Վերադարձնում է:\n  - u32, որը ներկայացնում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակի ընթացքում:\n\n  Օրինակներ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) վերադարձնում է 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) վերադարձնում է 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) վերադարձնում է 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32",
      "bn": "/*\n  প্রদত্ত সময়সীমার মধ্যে একটি নির্দিষ্ট সময় প্রয়োজনীয়তা এবং মান সহ প্রতিটি ভেষজ উদ্ভিদের সেট থেকে সর্বাধিক মোট মান গণনা করে যা সংগ্রহ করা যেতে পারে।\n\n  আর্গুমেন্ট:\n  - total_time: ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময় উপস্থাপনকারী একটি u32।\n  - herbs: একটি টুপলের স্লাইস, যেখানে প্রতিটি টুপলে দুটি u32 মান রয়েছে যা যথাক্রমে একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মান উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি u32 যা প্রদত্ত সময়ের মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজগুলির সর্বাধিক মোট মান উপস্থাপন করে।\n\n  উদাহরণ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 রিটার্ন করে\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 রিটার্ন করে\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 রিটার্ন করে\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "bg": "/*\n  Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит от набор от билки, всяка със собствено времево изискване и стойност.\n\n  Аргументи:\n  - total_time: u32, представляващ общото време, налично за събиране на билки.\n  - herbs: Срез от кортежи, където всеки кортеж съдържа две u32 стойности, представляващи времето, необходимо за събиране на билка и нейната стойност, съответно.\n\n  Връща:\n  - u32, представляващ максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\n  Примери:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) връща 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) връща 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) връща 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "zh": "/*\n  计算在给定时间限制内可以收集的草药的最大总价值，每种草药都有其自身的时间需求和价值。\n\n  参数:\n  - total_time: 一个 u32，表示可用于收集草药的总时间。\n  - herbs: 一个元组的切片，其中每个元组包含两个 u32 值，分别表示收集一种草药所需的时间和其价值。\n\n  返回:\n  - 一个 u32，表示在给定时间内可以收集的草药的最大总价值。\n\n  示例:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 返回 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 返回 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 返回 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "fr": "/*\n  Calcule la valeur totale maximale des herbes qui peuvent être collectées dans un délai donné à partir d'un ensemble d'herbes, chacune ayant son propre temps requis et sa valeur.\n\n  Arguments:\n  - total_time: Un u32 représentant le temps total disponible pour collecter des herbes.\n  - herbs: Une tranche de tuples, où chaque tuple contient deux valeurs u32 représentant le temps requis pour collecter une herbe et sa valeur, respectivement.\n\n  Renvoie:\n  - Un u32 représentant la valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n  Exemples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) renvoie 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) renvoie 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) renvoie 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32",
      "de": "/*\n  Berechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines gegebenen Zeitlimits gesammelt werden können, aus einer Menge von Kräutern, von denen jedes seine eigene Zeitanforderung und seinen Wert hat.\n\n  Argumente:\n  - total_time: Ein u32, das die insgesamt verfügbare Zeit zum Sammeln von Kräutern darstellt.\n  - herbs: Ein Slice von Tupeln, wobei jedes Tupel zwei u32-Werte enthält, die die zum Sammeln eines Krauts erforderliche Zeit und dessen Wert darstellen.\n\n  Rückgabewert:\n  - Ein u32, das den maximalen Gesamtwert der Kräuter darstellt, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n  Beispiele:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) gibt 3 zurück\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) gibt 100 zurück\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) gibt 30 zurück\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "ha": "/*\n  Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin iyakar lokaci da aka bayar daga saitin ganyayyaki, kowanne yana da bukatun lokacinsa da ƙimarsa.\n\n  Huɗɗa:\n  - total_time: Wani u32 da ke wakiltar jimillar lokacin da ake da shi don tattara ganyayyaki.\n  - herbs: Wani yanki na tuples, inda kowanne tuple ke ɗauke da ƙimar u32 guda biyu da ke wakiltar lokacin da ake buƙata don tattara wani ganye da ƙimarsa, bi da bi.\n\n  Komawa:\n  - Wani u32 da ke wakiltar mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin lokacin da aka bayar.\n\n  Misalai:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "hi": "/*\n  दिए गए समय सीमा के भीतर जड़ी-बूटियों के एक सेट से अधिकतम कुल मूल्य की गणना करता है, जिसमें प्रत्येक जड़ी-बूटी की अपनी समय आवश्यकता और मूल्य होता है।\n\n  तर्क:\n  - total_time: जड़ी-बूटियों को इकट्ठा करने के लिए उपलब्ध कुल समय का प्रतिनिधित्व करने वाला एक u32।\n  - herbs: ट्यूपल्स की एक स्लाइस, जहां प्रत्येक ट्यूपल में दो u32 मान होते हैं जो क्रमशः जड़ी-बूटी को इकट्ठा करने के लिए आवश्यक समय और उसका मूल्य दर्शाते हैं।\n\n  लौटाता है:\n  - एक u32 जो दिए गए समय के भीतर इकट्ठा की जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 लौटाता है\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 लौटाता है\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 लौटाता है\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32 ",
      "hu": "/*\n  Kiszámítja a maximális összértéket, amit a gyógynövényekből lehet összegyűjteni egy adott időkorláton belül, ahol minden gyógynövénynek megvan a saját időigénye és értéke.\n\n  Argumentumok:\n  - total_time: Egy u32, amely az összes rendelkezésre álló időt jelenti a gyógynövények gyűjtésére.\n  - herbs: Egy tuple szelet, ahol minden tuple két u32 értéket tartalmaz, amelyek egy gyógynövény gyűjtéséhez szükséges időt és annak értékét képviselik.\n\n  Visszatér:\n  - Egy u32, amely a gyógynövényekből gyűjthető maximális összértéket jelenti a megadott időn belül.\n\n  Példák:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) visszaadja 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) visszaadja 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) visszaadja 30\n*/\n\nfn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32"
    },
    "prompt_bertscore": {
      "sq": "0.9978333398036714",
      "hy": "0.9776797054527285",
      "bn": "0.9674236243583731",
      "bg": "0.9923068467121378",
      "zh": "0.971191642686605",
      "fr": "0.9912745646218994",
      "de": "0.9939958008420774",
      "ha": "0.9890902263216588",
      "hi": "0.9721500342750983",
      "hu": "0.972102760244412"
    },
    "canonical_solution": "{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}",
    "instruction": {
      "en": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\n请用中文为以下 Rust 代码提供一个简洁的自然语言描述（文档字符串），字数不超过 500 个字符。",
      "fr": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32\n{\n    let n = herbs.len();\n    let mut dp = vec![vec![0; n + 1]; (total_time + 1) as usize];\n\n    for i in 1..=n {\n        let (time, value) = herbs[i - 1];\n        for j in 0..=total_time {\n            dp[j as usize][i] = dp[j as usize][i - 1];\n            if j >= time {\n                dp[j as usize][i] = dp[j as usize][i].max(dp[(j - time) as usize][i - 1] + value);\n            }\n        }\n    }\n    dp[total_time as usize][n]\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9277247605135973",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8627098587147819",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9665526301375352",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]), 3);\n        assert_eq!(max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]), 110);\n        assert_eq!(max_herbs_value(5, &[(2, 20), (3, 30)]), 50);\n    }\n    \n\n}",
    "entry_point": "max_herbs_value",
    "signature": "fn max_herbs_value(total_time: u32, herbs: &[(u32, u32)]) -> u32",
    "docstring": {
      "en": "Calculates the maximum total value of herbs that can be collected within a given time limit from a set of herbs, each with its own time requirement and value.\n\n  Arguments:\n  - total_time: A u32 representing the total time available for collecting herbs.\n  - herbs: A slice of tuples, where each tuple contains two u32 values representing the time required to collect a herb and its value, respectively.\n\n  Returns:\n  - A u32 representing the maximum total value of herbs that can be collected within the given time.\n\n  Examples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "sq": "Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri kohor të dhënë nga një grup bimësh, secila me kërkesën e vet të kohës dhe vlerën.\n\n  Argumentet:\n  - total_time: Një u32 që përfaqëson kohën totale në dispozicion për mbledhjen e bimëve.\n  - herbs: Një segment tuplesh, ku çdo tuple përmban dy vlera u32 që përfaqësojnë kohën e kërkuar për të mbledhur një bimë dhe vlerën e saj, përkatësisht.\n\n  Kthen:\n  - Një u32 që përfaqëson vlerën maksimale totale të bimëve që mund të mblidhen brenda kohës së dhënë.\n\n  Shembuj:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) kthen 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) kthen 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) kthen 30",
      "hy": "Հաշվում է բույսերի առավելագույն ընդհանուր արժեքը, որոնք հնարավոր է հավաքել տրված ժամանակային սահմանափակման շրջանակներում՝ հաշվի առնելով յուրաքանչյուր բույսի համար անհրաժեշտ ժամանակը և արժեքը:\n\n  Արձանագրություններ:\n  - total_time: u32, որը ներկայացնում է բույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n  - herbs: զույգերի կտոր, որտեղ յուրաքանչյուր զույգ պարունակում է երկու u32 արժեք՝ ներկայացնելով բույս հավաքելու համար անհրաժեշտ ժամանակը և դրա արժեքը, համապատասխանաբար:\n\n  Վերադարձնում է:\n  - u32, որը ներկայացնում է բույսերի առավելագույն ընդհանուր արժեքը, որոնք հնարավոր է հավաքել տրված ժամանակի ընթացքում:\n\n  Օրինակներ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) վերադարձնում է 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) վերադարձնում է 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) վերադարձնում է 30",
      "bn": "গণনা করে একটি নির্দিষ্ট সময়সীমার মধ্যে সর্বাধিক মোট মূল্য কতটুকু ভেষজ সংগ্রহ করা যেতে পারে একটি সেট থেকে, যেখানে প্রতিটি ভেষজের নিজস্ব সময় প্রয়োজন এবং মূল্য রয়েছে।\n\n  আর্গুমেন্টসমূহ:\n  - total_time: একটি u32 যা ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়কে উপস্থাপন করে।\n  - herbs: একটি টুপলের স্লাইস, যেখানে প্রতিটি টুপলে দুটি u32 মান রয়েছে যা একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মূল্যকে যথাক্রমে উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি u32 যা নির্দিষ্ট সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্যকে উপস্থাপন করে।\n\n  উদাহরণসমূহ:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) রিটার্ন করে 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) রিটার্ন করে 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) রিটার্ন করে 30",
      "bg": "Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено времево ограничение от набор от билки, всяка със собствено времево изискване и стойност.\n\nАргументи:\n- total_time: u32, представляващо общото време, достъпно за събиране на билки.\n- herbs: Срез от кортежи, където всеки кортеж съдържа две u32 стойности, представляващи времето, необходимо за събиране на билка и нейната стойност, съответно.\n\nВръща:\n- u32, представляващо максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\nПримери:\n- max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) връща 3\n- max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) връща 100\n- max_herbs_value(5, &[(2, 20), (3, 30)]) връща 30",
      "zh": "计算在给定时间限制内可以收集的草药的最大总价值，每种草药都有其自己的时间需求和价值。\n\n  参数:\n  - total_time: 一个 u32，表示收集草药的总可用时间。\n  - herbs: 一个元组切片，其中每个元组包含两个 u32 值，分别表示收集一种草药所需的时间和其价值。\n\n  返回:\n  - 一个 u32，表示在给定时间内可以收集的草药的最大总价值。\n\n  示例:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 返回 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 返回 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 返回 30",
      "fr": "Calcule la valeur totale maximale des herbes qui peuvent être collectées dans un délai donné à partir d'un ensemble d'herbes, chacune ayant son propre temps requis et sa valeur.\n\n  Arguments:\n  - total_time: Un u32 représentant le temps total disponible pour collecter des herbes.\n  - herbs: Une tranche de tuples, où chaque tuple contient deux valeurs u32 représentant le temps nécessaire pour collecter une herbe et sa valeur, respectivement.\n\n  Renvoie:\n  - Un u32 représentant la valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n  Exemples:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) renvoie 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) renvoie 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) renvoie 30",
      "de": "Berechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines vorgegebenen Zeitlimits aus einer Menge von Kräutern gesammelt werden können, wobei jedes Kraut seine eigene Zeitanforderung und seinen Wert hat.\n\n  Argumente:\n  - total_time: Ein u32, das die insgesamt verfügbare Zeit zum Sammeln von Kräutern darstellt.\n  - herbs: Ein Slice von Tupeln, wobei jedes Tupel zwei u32-Werte enthält, die die zum Sammeln eines Krauts benötigte Zeit und dessen Wert darstellen.\n\n  Rückgabewerte:\n  - Ein u32, das den maximalen Gesamtwert der Kräuter darstellt, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n  Beispiele:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) gibt 3 zurück\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) gibt 100 zurück\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) gibt 30 zurück",
      "ha": "Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin iyakar lokaci da aka bayar daga saitin ganyayyaki, kowanne yana da bukatar lokaci da ƙimarsa.\n\n  Huɗa:\n  - total_time: Wani u32 da ke wakiltar jimillar lokacin da ake da shi don tattara ganyayyaki.\n  - herbs: Wani yanki na tuples, inda kowanne tuple ke dauke da ƙimar u32 guda biyu da ke wakiltar lokacin da ake buƙata don tattara ganye da ƙimar sa, bi da bi.\n\n  Komawa:\n  - Wani u32 da ke wakiltar mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin lokacin da aka bayar.\n\n  Misalai:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) returns 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) returns 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) returns 30",
      "hi": "हर्ब्स के अधिकतम कुल मूल्य की गणना करता है जो एक निर्धारित समय सीमा के भीतर एक सेट से एकत्र किया जा सकता है, जहाँ प्रत्येक हर्ब के लिए उसका अपना समय आवश्यकता और मूल्य होता है।\n\n  तर्क:\n  - total_time: एक u32 जो हर्ब्स एकत्र करने के लिए उपलब्ध कुल समय का प्रतिनिधित्व करता है।\n  - herbs: ट्यूपल्स की एक स्लाइस, जहाँ प्रत्येक ट्यूपल में दो u32 मान होते हैं जो क्रमशः एक हर्ब को एकत्र करने के लिए आवश्यक समय और उसका मूल्य दर्शाते हैं।\n\n  वापसी मान:\n  - एक u32 जो दिए गए समय के भीतर एकत्र किए जा सकने वाले हर्ब्स के अधिकतम कुल मूल्य का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) 3 लौटाता है\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) 100 लौटाता है\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) 30 लौटाता है",
      "hu": "Kiszámítja a maximálisan összegyűjthető gyógynövények összértékét egy adott időkorláton belül egy olyan gyógynövénykészletből, ahol minden gyógynövénynek megvan a saját időigénye és értéke.\n\n  Argumentumok:\n  - total_time: Egy u32, amely az összes rendelkezésre álló időt jelenti a gyógynövények gyűjtésére.\n  - herbs: Egy szelet tuple, ahol minden tuple két u32 értéket tartalmaz, amelyek egy gyógynövény gyűjtéséhez szükséges időt és annak értékét képviselik.\n\n  Visszatérési érték:\n  - Egy u32, amely a maximálisan összegyűjthető gyógynövények összértékét jelenti az adott időn belül.\n\n  Példák:\n  - max_herbs_value(70, &[(71, 100), (69, 1), (1, 2)]) visszaadja 3\n  - max_herbs_value(10, &[(5, 60), (4, 40), (3, 50)]) visszaadja 100\n  - max_herbs_value(5, &[(2, 20), (3, 30)]) visszaadja 30"
    },
    "docstring_bertscore": {
      "sq": "0.9966729411176656",
      "hy": "0.9821182999473342",
      "bn": "0.9779140893023498",
      "bg": "0.9863848805319636",
      "zh": "0.967798241257005",
      "fr": "0.9898535628759758",
      "de": "0.994312616299828",
      "ha": "0.9937298347618717",
      "hi": "0.9903586799349475",
      "hu": "0.9928741350803734"
    }
  },
  {
    "task_id": "Rust/39",
    "prompt": {
      "en": "/*\n  Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "sq": "/*\n  Verifikon saktësinë e një numri të dhënë ISBN.\n\n  Një numër ISBN është një varg i formatuar si \"x-xxx-xxxxx-x\", ku 'x' përfaqëson një shifër, dhe '-' është një ndarës. Shifra e fundit është një shifër kontrolli, e llogaritur si shuma e 9 shifrave të para, secila e shumëzuar me pozicionin e saj (1 deri në 9), modulo 11. Nëse rezultati është 10, shifra kontrolluese është 'X'.\n\n  Argumentet:\n  - isbn: Një varg që përfaqëson një numër ISBN.\n\n  Kthen:\n  - Një përgjigje si varg. Nëse ISBN është i saktë, kthen \"Right\". Përndryshe, kthen numrin e korrigjuar ISBN.\n\n  Shembull:\n  - validate_isbn(\"0-670-82162-4\") kthen \"Right\"\n  - validate_isbn(\"0-670-82162-0\") kthen \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "hy": "/*\n  Ստուգում է տրված ISBN համարի ճշտությունը:\n\n  ISBN համարը տող է, որը ձևավորված է \"x-xxx-xxxxx-x\" ձևաչափով, որտեղ 'x'-ը ներկայացնում է թվանշան, իսկ '-' նշանը բաժանարար է: Վերջին թվանշանը ստուգման թվանշան է, որը հաշվարկվում է առաջին 9 թվանշանների գումարի միջոցով, որոնցից յուրաքանչյուրը բազմապատկվում է իրենց դիրքով (1-ից 9), և այնուհետև վերցվում է 11-ի մնացորդը: Եթե արդյունքը 10 է, ապա ստուգման թվանշանը 'X' է:\n\n  Փաստարկներ:\n  - isbn: Տող, որը ներկայացնում է ISBN համարը:\n\n  Վերադարձնում է:\n  - Տողային պատասխան: Եթե ISBN-ը ճիշտ է, վերադարձնում է \"Right\": Հակառակ դեպքում, վերադարձնում է ուղղված ISBN համարը:\n\n  Օրինակ:\n  - validate_isbn(\"0-670-82162-4\") վերադարձնում է \"Right\"\n  - validate_isbn(\"0-670-82162-0\") վերադարձնում է \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "bn": "/*\n  একটি প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করে।\n\n  একটি ISBN নম্বর একটি স্ট্রিং যা \"x-xxx-xxxxx-x\" হিসাবে বিন্যস্ত, যেখানে 'x' একটি সংখ্যা নির্দেশ করে, এবং '-' একটি বিভাজক। শেষ সংখ্যা একটি চেক সংখ্যা, যা প্রথম 9 সংখ্যার প্রতিটি তাদের অবস্থান (1 থেকে 9) দ্বারা গুণিত এবং 11 দ্বারা মডুলো হিসাবে হিসাব করা হয়। যদি ফলাফল 10 হয়, তাহলে চেক সংখ্যা 'X' হয়।\n\n  আর্গুমেন্ট:\n  - isbn: একটি স্ট্রিং যা একটি ISBN নম্বর নির্দেশ করে।\n\n  রিটার্নস:\n  - একটি স্ট্রিং প্রতিক্রিয়া। যদি ISBN সঠিক হয়, তাহলে \"Right\" রিটার্ন করে। অন্যথায়, সংশোধিত ISBN নম্বর রিটার্ন করে।\n\n  উদাহরণ:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" রিটার্ন করে\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" রিটার্ন করে\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "bg": "/*\n  Проверява коректността на даден ISBN номер.\n\n  ISBN номерът е низ във формат \"x-xxx-xxxxx-x\", където 'x' представлява цифра, а '-' е разделител. Последната цифра е контролна цифра, изчислена като сумата на първите 9 цифри, всяка умножена по позицията си (от 1 до 9), модул 11. Ако резултатът е 10, контролната цифра е 'X'.\n\n  Аргументи:\n  - isbn: Низ, представляващ ISBN номер.\n\n  Връща:\n  - Низов отговор. Ако ISBN е коректен, връща \"Right\". В противен случай връща коригирания ISBN номер.\n\n  Пример:\n  - validate_isbn(\"0-670-82162-4\") връща \"Right\"\n  - validate_isbn(\"0-670-82162-0\") връща \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "zh": "/*\n  验证给定的ISBN号码的正确性。\n\n  ISBN号码是一个格式为\"x-xxx-xxxxx-x\"的字符串，其中'x'代表一个数字，'-'是分隔符。最后一位数字是校验位，计算方法是前9位数字分别乘以它们的位置（1到9），然后对11取模。如果结果是10，校验位为'X'。\n\n  参数:\n  - isbn: 表示ISBN号码的字符串。\n\n  返回:\n  - 字符串响应。如果ISBN正确，返回\"Right\"。否则，返回更正后的ISBN号码。\n\n  示例:\n  - validate_isbn(\"0-670-82162-4\") 返回 \"Right\"\n  - validate_isbn(\"0-670-82162-0\") 返回 \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "fr": "/*\n  Valide la correction d'un numéro ISBN donné.\n\n  Un numéro ISBN est une chaîne formatée comme \"x-xxx-xxxxx-x\", où 'x' représente un chiffre, et '-' est un séparateur. Le dernier chiffre est un chiffre de contrôle, calculé comme la somme des 9 premiers chiffres chacun multiplié par leur position (1 à 9), modulo 11. Si le résultat est 10, le chiffre de contrôle est 'X'.\n\n  Arguments :\n  - isbn : Une chaîne représentant un numéro ISBN.\n\n  Renvoie :\n  - Une réponse sous forme de chaîne. Si l'ISBN est correct, renvoie \"Right\". Sinon, renvoie le numéro ISBN corrigé.\n\n  Exemple :\n  - validate_isbn(\"0-670-82162-4\") renvoie \"Right\"\n  - validate_isbn(\"0-670-82162-0\") renvoie \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "de": "/*\n  Validiert die Korrektheit einer gegebenen ISBN-Nummer.\n\n  Eine ISBN-Nummer ist eine Zeichenkette im Format \"x-xxx-xxxxx-x\", wobei 'x' eine Ziffer darstellt und '-' ein Trennzeichen ist. Die letzte Ziffer ist eine Prüfziffer, berechnet als die Summe der ersten 9 Ziffern, jeweils multipliziert mit ihrer Position (1 bis 9), modulo 11. Wenn das Ergebnis 10 ist, ist die Prüfziffer 'X'.\n\n  Argumente:\n  - isbn: Eine Zeichenkette, die eine ISBN-Nummer darstellt.\n\n  Rückgabewerte:\n  - Eine Zeichenkette als Antwort. Wenn die ISBN korrekt ist, wird \"Right\" zurückgegeben. Andernfalls wird die korrigierte ISBN-Nummer zurückgegeben.\n\n  Beispiel:\n  - validate_isbn(\"0-670-82162-4\") gibt \"Right\" zurück\n  - validate_isbn(\"0-670-82162-0\") gibt \"0-670-82162-4\" zurück\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "ha": "/*\n  Tabbatar da daidaiton lambar ISBN da aka bayar.\n\n  Lambar ISBN tana da tsari kamar haka \"x-xxx-xxxxx-x\", inda 'x' ke wakiltar lamba, kuma '-' shi ne mai raba. Lambar ƙarshe ita ce lambar duba, ana ƙididdige ta azaman jumlar lambobin farko 9 kowanne an ninka da matsayinsa (1 zuwa 9), modulo 11. Idan sakamakon ya zama 10, lambar duba ita ce 'X'.\n\n  Huɗɗa:\n  - isbn: Wani kirtani da ke wakiltar lambar ISBN.\n\n  Mayarwa:\n  - Martani na kirtani. Idan ISBN daidai ne, yana mayar da \"Right\". In ba haka ba, yana mayar da lambar ISBN da aka gyara.\n\n  Misali:\n  - validate_isbn(\"0-670-82162-4\") yana mayar da \"Right\"\n  - validate_isbn(\"0-670-82162-0\") yana mayar da \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "hi": "/*\n  दिए गए ISBN नंबर की शुद्धता की जांच करता है।\n\n  एक ISBN नंबर एक स्ट्रिंग के रूप में होता है \"x-xxx-xxxxx-x\", जहाँ 'x' एक अंक का प्रतिनिधित्व करता है, और '-' एक विभाजक है। अंतिम अंक एक जाँच अंक होता है, जो पहले 9 अंकों के योग के रूप में गणना की जाती है, प्रत्येक को उनकी स्थिति (1 से 9) से गुणा किया जाता है, और फिर 11 से भागफल लिया जाता है। यदि परिणाम 10 होता है, तो जाँच अंक 'X' होता है।\n\n  तर्क:\n  - isbn: एक स्ट्रिंग जो एक ISBN नंबर का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग प्रतिक्रिया। यदि ISBN सही है, तो \"Right\" लौटाता है। अन्यथा, सही किया गया ISBN नंबर लौटाता है।\n\n  उदाहरण:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" लौटाता है\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" लौटाता है\n*/\n\n\nfn validate_isbn(isbn: &str) -> String ",
      "hu": "/*\n  Ellenőrzi egy adott ISBN szám helyességét.\n\n  Egy ISBN szám egy \"x-xxx-xxxxx-x\" formátumú karakterlánc, ahol 'x' egy számjegyet jelöl, és '-' egy elválasztó. Az utolsó számjegy egy ellenőrző számjegy, amelyet az első 9 számjegy összegének kiszámításával kapunk, mindegyiket megszorozva a pozíciójával (1-től 9-ig), majd az eredményt 11-gyel osztva. Ha az eredmény 10, az ellenőrző számjegy 'X'.\n\n  Argumentumok:\n  - isbn: Egy karakterlánc, amely egy ISBN számot jelöl.\n\n  Visszatér:\n  - Egy karakterlánc választ ad vissza. Ha az ISBN helyes, \"Right\"-ot ad vissza. Ellenkező esetben a javított ISBN számot adja vissza.\n\n  Példa:\n  - validate_isbn(\"0-670-82162-4\") visszaadja \"Right\"\n  - validate_isbn(\"0-670-82162-0\") visszaadja \"0-670-82162-4\"\n*/\n\n\nfn validate_isbn(isbn: &str) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9872225048487877",
      "hy": "0.9576742493660377",
      "bn": "0.9783983501713128",
      "bg": "0.9783236651480437",
      "zh": "0.9587095109119916",
      "fr": "0.9817655323906163",
      "de": "0.9761415117819944",
      "ha": "0.9667826441187736",
      "hi": "0.9667365618703735",
      "hu": "0.9583337022310736"
    },
    "canonical_solution": "{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}",
    "instruction": {
      "en": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, като използвате не повече от 500 символа.",
      "zh": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\n请用最多500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn validate_isbn(isbn: &str) -> String\n{\n    let parts: Vec<&str> = isbn.split('-').collect();\n    if parts.len() != 4 {\n        return \"Invalid ISBN format\".to_string();\n    }\n\n    let mut sum = 0;\n    let mut count = 1;\n    let digits = parts.iter().take(3).flat_map(|&part| part.chars()).collect::<Vec<char>>();\n    for digit in digits {\n        sum += digit.to_digit(10).unwrap() * count;\n        count += 1;\n    }\n\n    let check_digit = sum % 11;\n    let expected_check_digit = if check_digit == 10 { 'X' } else { char::from_digit(check_digit, 10).unwrap() };\n    let actual_check_digit = parts[3].chars().next().unwrap();\n\n    if expected_check_digit == actual_check_digit {\n        \"Right\".to_string()\n    } else {\n        format!(\"{}-{}-{}-{}\", parts[0], parts[1], parts[2], expected_check_digit)\n    }\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9423368058640478",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.856169158897684",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9361141132869868",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(validate_isbn(\"0-670-82162-4\"), \"Right\");\n        assert_eq!(validate_isbn(\"0-670-82162-0\"), \"0-670-82162-4\");\n        assert_eq!(validate_isbn(\"0-123-45678-9\"), \"Right\");\n        assert_eq!(validate_isbn(\"1-234-56789-X\"), \"Right\");\n    }\n    \n\n}",
    "entry_point": "validate_isbn",
    "signature": "fn validate_isbn(isbn: &str) -> String",
    "docstring": {
      "en": "Validates the correctness of a given ISBN number.\n\n  An ISBN number is a string formatted as \"x-xxx-xxxxx-x\", where 'x' represents a digit, and '-' is a separator. The last digit is a check digit, calculated as the sum of the first 9 digits each multiplied by their position (1 to 9), modulo 11. If the result is 10, the check digit is 'X'.\n\n  Arguments:\n  - isbn: A string representing an ISBN number.\n\n  Returns:\n  - A string response. If the ISBN is correct, returns \"Right\". Otherwise, returns the corrected ISBN number.\n\n  Example:\n  - validate_isbn(\"0-670-82162-4\") returns \"Right\"\n  - validate_isbn(\"0-670-82162-0\") returns \"0-670-82162-4\"",
      "sq": "Kontrollon saktësinë e një numri të dhënë ISBN.\n\n  Një numër ISBN është një varg i formatuar si \"x-xxx-xxxxx-x\", ku 'x' përfaqëson një shifër, dhe '-' është një ndarës. Shifra e fundit është një shifër kontrolli, e llogaritur si shuma e 9 shifrave të para secila e shumëzuar me pozicionin e tyre (1 deri në 9), modulo 11. Nëse rezultati është 10, shifra kontrolluese është 'X'.\n\n  Argumentet:\n  - isbn: Një varg që përfaqëson një numër ISBN.\n\n  Kthen:\n  - Një përgjigje me varg. Nëse ISBN është i saktë, kthen \"Right\". Përndryshe, kthen numrin e korrigjuar ISBN.\n\n  Shembull:\n  - validate_isbn(\"0-670-82162-4\") kthen \"Right\"\n  - validate_isbn(\"0-670-82162-0\") kthen \"0-670-82162-4\"",
      "hy": "Ստուգում է տրված ISBN համարի ճշտությունը։\n\n  ISBN համարը տող է, որը ձևավորված է որպես \"x-xxx-xxxxx-x\", որտեղ 'x'-ը ներկայացնում է թվանշան, իսկ '-' նշանը բաժանարար է։ Վերջին թվանշանը ստուգիչ թվանշան է, որը հաշվարկվում է առաջին 9 թվանշանների գումարը, որոնցից յուրաքանչյուրը բազմապատկվում է իրենց դիրքով (1-ից 9), և արդյունքում ստացված գումարը բաժանվում է 11-ի։ Եթե արդյունքը 10 է, ապա ստուգիչ թվանշանը 'X' է։\n\n  Արձանագրություններ:\n  - isbn: Տող, որը ներկայացնում է ISBN համարը։\n\n  Վերադարձնում է:\n  - Տողային պատասխան։ Եթե ISBN համարը ճիշտ է, վերադարձնում է \"Right\"։ Հակառակ դեպքում, վերադարձնում է ուղղված ISBN համարը։\n\n  Օրինակ:\n  - validate_isbn(\"0-670-82162-4\") վերադարձնում է \"Right\"\n  - validate_isbn(\"0-670-82162-0\") վերադարձնում է \"0-670-82162-4\"",
      "bn": "একটি প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করে।\n\nএকটি ISBN নম্বর একটি স্ট্রিং যা \"x-xxx-xxxxx-x\" আকারে বিন্যস্ত হয়, যেখানে 'x' একটি সংখ্যা নির্দেশ করে, এবং '-' একটি বিভাজক। শেষ সংখ্যা একটি যাচাইকরণ সংখ্যা, যা প্রথম 9 সংখ্যার প্রতিটি তাদের অবস্থান (1 থেকে 9) দ্বারা গুণ করে, 11 দ্বারা ভাগশেষ হিসাবে গণনা করা হয়। যদি ফলাফল 10 হয়, তাহলে যাচাইকরণ সংখ্যা 'X' হয়।\n\nআর্গুমেন্টস:\n- isbn: একটি স্ট্রিং যা একটি ISBN নম্বর উপস্থাপন করে।\n\nরিটার্নস:\n- একটি স্ট্রিং প্রতিক্রিয়া। যদি ISBN সঠিক হয়, তাহলে \"Right\" রিটার্ন করে। অন্যথায়, সংশোধিত ISBN নম্বর রিটার্ন করে।\n\nউদাহরণ:\n- validate_isbn(\"0-670-82162-4\") \"Right\" রিটার্ন করে\n- validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" রিটার্ন করে",
      "bg": "Проверява коректността на даден ISBN номер.\n\nISBN номерът е низ във формат \"x-xxx-xxxxx-x\", където 'x' представлява цифра, а '-' е разделител. Последната цифра е контролна цифра, изчислена като сумата от първите 9 цифри, всяка умножена по позицията си (от 1 до 9), модул 11. Ако резултатът е 10, контролната цифра е 'X'.\n\nАргументи:\n- isbn: Низ, представляващ ISBN номер.\n\nВръща:\n- Низов отговор. Ако ISBN е коректен, връща \"Right\". В противен случай връща коригирания ISBN номер.\n\nПример:\n- validate_isbn(\"0-670-82162-4\") връща \"Right\"\n- validate_isbn(\"0-670-82162-0\") връща \"0-670-82162-4\"",
      "zh": "验证给定的 ISBN 号码的正确性。\n\nISBN 号码是一个格式为 \"x-xxx-xxxxx-x\" 的字符串，其中 'x' 代表一个数字，'-' 是分隔符。最后一位数字是校验位，计算方法是前 9 位数字分别乘以其位置（1 到 9），然后对 11 取模。如果结果是 10，校验位为 'X'。\n\n参数：\n- isbn: 表示 ISBN 号码的字符串。\n\n返回：\n- 一个字符串响应。如果 ISBN 正确，返回 \"Right\"。否则，返回更正后的 ISBN 号码。\n\n示例：\n- validate_isbn(\"0-670-82162-4\") 返回 \"Right\"\n- validate_isbn(\"0-670-82162-0\") 返回 \"0-670-82162-4\"",
      "fr": "Valide la validité d'un numéro ISBN donné.\n\n  Un numéro ISBN est une chaîne formatée comme \"x-xxx-xxxxx-x\", où 'x' représente un chiffre, et '-' est un séparateur. Le dernier chiffre est un chiffre de contrôle, calculé comme la somme des 9 premiers chiffres chacun multiplié par leur position (1 à 9), modulo 11. Si le résultat est 10, le chiffre de contrôle est 'X'.\n\n  Arguments:\n  - isbn: Une chaîne représentant un numéro ISBN.\n\n  Renvoie:\n  - Une réponse sous forme de chaîne. Si l'ISBN est correct, renvoie \"Right\". Sinon, renvoie le numéro ISBN corrigé.\n\n  Exemple:\n  - validate_isbn(\"0-670-82162-4\") renvoie \"Right\"\n  - validate_isbn(\"0-670-82162-0\") renvoie \"0-670-82162-4\"",
      "de": "Validiert die Korrektheit einer gegebenen ISBN-Nummer.\n\n  Eine ISBN-Nummer ist eine Zeichenkette im Format \"x-xxx-xxxxx-x\", wobei 'x' eine Ziffer darstellt und '-' ein Trennzeichen ist. Die letzte Ziffer ist eine Prüfziffer, die als Summe der ersten 9 Ziffern berechnet wird, wobei jede Ziffer mit ihrer Position (1 bis 9) multipliziert wird, modulo 11. Wenn das Ergebnis 10 ist, ist die Prüfziffer 'X'.\n\n  Argumente:\n  - isbn: Eine Zeichenkette, die eine ISBN-Nummer darstellt.\n\n  Rückgabewerte:\n  - Eine Zeichenkettenantwort. Wenn die ISBN korrekt ist, wird \"Right\" zurückgegeben. Andernfalls wird die korrigierte ISBN-Nummer zurückgegeben.\n\n  Beispiel:\n  - validate_isbn(\"0-670-82162-4\") gibt \"Right\" zurück\n  - validate_isbn(\"0-670-82162-0\") gibt \"0-670-82162-4\" zurück",
      "ha": "Tabbatar da daidaiton lambar ISBN da aka bayar.\n\n  Lambar ISBN wata igiya ce da aka tsara a matsayin \"x-xxx-xxxxx-x\", inda 'x' ke wakiltar wata lamba, kuma '-' yana matsayin mai raba. Lambar karshe ita ce lambar duba, da aka lasafta a matsayin jumlar lambobin farko 9 kowanne an ninka da matsayinsa (1 zuwa 9), modulo 11. Idan sakamakon ya zama 10, lambar duba ita ce 'X'.\n\n  Huɗa:\n  - isbn: Wata igiya da ke wakiltar lambar ISBN.\n\n  Komawa:\n  - Wata amsa ta igiya. Idan ISBN ya yi daidai, yana dawowa \"Right\". In ba haka ba, yana dawowa da lambar ISBN da aka gyara.\n\n  Misali:\n  - validate_isbn(\"0-670-82162-4\") yana dawowa \"Right\"\n  - validate_isbn(\"0-670-82162-0\") yana dawowa \"0-670-82162-4\"",
      "hi": "दिए गए ISBN संख्या की शुद्धता की पुष्टि करता है।\n\n  एक ISBN संख्या \"x-xxx-xxxxx-x\" के रूप में स्वरूपित एक स्ट्रिंग होती है, जहाँ 'x' एक अंक का प्रतिनिधित्व करता है, और '-' एक विभाजक है। अंतिम अंक एक जाँच अंक होता है, जिसे पहले 9 अंकों के योग के रूप में गणना की जाती है, प्रत्येक को उनकी स्थिति (1 से 9) से गुणा किया जाता है, और फिर 11 से माड्यूलो लिया जाता है। यदि परिणाम 10 है, तो जाँच अंक 'X' होता है।\n\n  तर्क:\n  - isbn: एक स्ट्रिंग जो एक ISBN संख्या का प्रतिनिधित्व करती है।\n\n  लौटाता है:\n  - एक स्ट्रिंग प्रतिक्रिया। यदि ISBN सही है, तो \"Right\" लौटाता है। अन्यथा, सही किया गया ISBN संख्या लौटाता है।\n\n  उदाहरण:\n  - validate_isbn(\"0-670-82162-4\") \"Right\" लौटाता है\n  - validate_isbn(\"0-670-82162-0\") \"0-670-82162-4\" लौटाता है",
      "hu": "Egy adott ISBN szám helyességét ellenőrzi.\n\n  Egy ISBN szám egy \"x-xxx-xxxxx-x\" formátumú karakterlánc, ahol az 'x' egy számjegyet jelöl, és a '-' egy elválasztó. Az utolsó számjegy egy ellenőrző számjegy, amelyet az első 9 számjegy és azok pozíciójának (1-től 9-ig) szorzatának összege, modulo 11 alapján számítanak ki. Ha az eredmény 10, az ellenőrző számjegy 'X'.\n\n  Argumentumok:\n  - isbn: Egy karakterlánc, amely egy ISBN számot jelöl.\n\n  Visszatérési érték:\n  - Egy karakterlánc válasz. Ha az ISBN helyes, \"Right\"-ot ad vissza. Ellenkező esetben a javított ISBN számot adja vissza.\n\n  Példa:\n  - validate_isbn(\"0-670-82162-4\") visszaadja \"Right\"\n  - validate_isbn(\"0-670-82162-0\") visszaadja \"0-670-82162-4\""
    },
    "docstring_bertscore": {
      "sq": "0.9935518619404644",
      "hy": "0.9782261376309556",
      "bn": "0.9880023277247307",
      "bg": "0.9763089571932068",
      "zh": "0.9514749951739389",
      "fr": "0.9847567072986206",
      "de": "0.9765520807795935",
      "ha": "0.984343556106068",
      "hi": "0.9714196703640331",
      "hu": "0.9577129822903395"
    }
  },
  {
    "task_id": "Rust/40",
    "prompt": {
      "en": "/*\n  Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve që qëndrojnë në një rreth, në mënyrë që pas 'm' kalimeve, topi të kthehet te studenti origjinal.\n\n  Argumentet:\n  - n: Numri i studentëve në rreth. Është një numër i plotë ku 3 <= n <= 30.\n  - m: Numri i herëve që topi kalon. Është një numër i plotë ku 1 <= m <= 30.\n\n  Kthen:\n  - Numri i sekuencave të dallueshme të kalimit që kthejnë topin te studenti fillestar pas 'm' kalimeve.\n\n  Shembuj:\n  - count_passing_ways(3, 3) kthen 2\n  - count_passing_ways(4, 2) kthen 4\n  - count_passing_ways(5, 5) kthen 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "hy": "/*\n  Հաշվում է գնդակը 'n' ուսանողների միջև շրջանաձև փոխանցելու տարբեր եղանակների քանակը, այնպես, որ 'm' փոխանցումներից հետո գնդակը վերադառնա սկզբնական ուսանողին:\n\n  Արգումենտներ:\n  - n: Ուսանողների քանակը շրջանի մեջ: Այն ամբողջ թիվ է, որտեղ 3 <= n <= 30:\n  - m: Գնդակը փոխանցելու քանակը: Այն ամբողջ թիվ է, որտեղ 1 <= m <= 30:\n\n  Վերադարձնում է:\n  - Տարբեր փոխանցումների հաջորդականությունների քանակը, որոնք 'm' փոխանցումներից հետո գնդակը վերադարձնում են սկզբնական ուսանողին:\n\n  Օրինակներ:\n  - count_passing_ways(3, 3) վերադարձնում է 2\n  - count_passing_ways(4, 2) վերադարձնում է 4\n  - count_passing_ways(5, 5) վերադարձնում է 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "bn": "/*\n  'n' জন ছাত্র একটি বৃত্তে দাঁড়িয়ে আছে, তাদের মধ্যে বল পাস করার বিভিন্ন পদ্ধতির সংখ্যা গণনা করে, যাতে 'm' বার পাস করার পর বলটি মূল ছাত্রের কাছে ফিরে আসে।\n\n  আর্গুমেন্টসমূহ:\n  - n: বৃত্তে ছাত্রদের সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 3 <= n <= 30।\n  - m: বল পাস করার সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 1 <= m <= 30।\n\n  রিটার্নস:\n  - 'm' বার পাস করার পর বলটি শুরু ছাত্রের কাছে ফিরে আসে এমন স্বতন্ত্র পাসিং সিকোয়েন্সের সংখ্যা।\n\n  উদাহরণসমূহ:\n  - count_passing_ways(3, 3) রিটার্ন করে 2\n  - count_passing_ways(4, 2) রিটার্ন করে 4\n  - count_passing_ways(5, 5) রিটার্ন করে 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "bg": "/*\n  Изчислява броя на различните начини за предаване на топка между 'n' ученици, стоящи в кръг, така че след 'm' предавания топката да се върне при оригиналния ученик.\n\n  Аргументи:\n  - n: Броят на учениците в кръга. Това е цяло число, където 3 <= n <= 30.\n  - m: Броят на предаванията на топката. Това е цяло число, където 1 <= m <= 30.\n\n  Връща:\n  - Броят на различните последователности на предаване, които връщат топката при началния ученик след 'm' предавания.\n\n  Примери:\n  - count_passing_ways(3, 3) връща 2\n  - count_passing_ways(4, 2) връща 4\n  - count_passing_ways(5, 5) връща 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "zh": "/*\n  计算在一个圆圈中有 'n' 个学生传球的不同方式的数量，使得经过 'm' 次传球后，球返回到原来的学生。\n\n  参数:\n  - n: 圆圈中的学生数量。它是一个整数，其中 3 <= n <= 30。\n  - m: 球被传递的次数。它是一个整数，其中 1 <= m <= 30。\n\n  返回:\n  - 返回经过 'm' 次传球后，球返回到起始学生的不同传球序列的数量。\n\n  示例:\n  - count_passing_ways(3, 3) 返回 2\n  - count_passing_ways(4, 2) 返回 4\n  - count_passing_ways(5, 5) 返回 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre de façons différentes de faire passer un ballon parmi 'n' étudiants debout en cercle, de telle sorte qu'après 'm' passes, le ballon retourne à l'étudiant d'origine.\n\n  Arguments:\n  - n: Le nombre d'étudiants dans le cercle. C'est un entier où 3 <= n <= 30.\n  - m: Le nombre de fois que le ballon est passé. C'est un entier où 1 <= m <= 30.\n\n  Renvoie:\n  - Le nombre de séquences de passes distinctes qui renvoient le ballon à l'étudiant de départ après 'm' passes.\n\n  Exemples:\n  - count_passing_ways(3, 3) renvoie 2\n  - count_passing_ways(4, 2) renvoie 4\n  - count_passing_ways(5, 5) renvoie 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "de": "/*\n  Berechnet die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis stehen, so zu passen, dass der Ball nach 'm' Pässen zum ursprünglichen Schüler zurückkehrt.\n\n  Argumente:\n  - n: Die Anzahl der Schüler im Kreis. Es ist eine ganze Zahl, wobei 3 <= n <= 30.\n  - m: Die Anzahl der Ballpässe. Es ist eine ganze Zahl, wobei 1 <= m <= 30.\n\n  Rückgabewert:\n  - Die Anzahl der unterschiedlichen Passsequenzen, die den Ball nach 'm' Pässen zum startenden Schüler zurückbringen.\n\n  Beispiele:\n  - count_passing_ways(3, 3) gibt 2 zurück\n  - count_passing_ways(4, 2) gibt 4 zurück\n  - count_passing_ways(5, 5) gibt 6 zurück\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "ha": "/*\n  Lissafa adadin hanyoyin daban-daban na wuce kwallo tsakanin 'n' ɗalibai da ke tsaye a cikin da'ira, ta yadda bayan 'm' wucewa, kwallon ta dawo ga ɗalibin asali.\n\n  Huɗɗa:\n  - n: Yawan ɗalibai a cikin da'ira. Yana da lamba inda 3 <= n <= 30.\n  - m: Yawan lokutan da aka wuce kwallon. Yana da lamba inda 1 <= m <= 30.\n\n  Komawa:\n  - Adadin jerin hanyoyin wucewa daban-daban da ke mayar da kwallon ga ɗalibin farawa bayan 'm' wucewa.\n\n  Misalai:\n  - count_passing_ways(3, 3) yana dawowa 2\n  - count_passing_ways(4, 2) yana dawowa 4\n  - count_passing_ways(5, 5) yana dawowa 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "hi": "/*\n  'n' छात्रों के बीच एक गोला पास करने के विभिन्न तरीकों की संख्या की गणना करता है, जो एक वृत्त में खड़े हैं, ताकि 'm' पास के बाद, गोला मूल छात्र के पास लौट आए।\n\n  तर्क:\n  - n: वृत्त में छात्रों की संख्या। यह एक पूर्णांक है जहाँ 3 <= n <= 30।\n  - m: गोला पास करने की संख्या। यह एक पूर्णांक है जहाँ 1 <= m <= 30।\n\n  लौटाता है:\n  - विशिष्ट पासिंग अनुक्रमों की संख्या जो 'm' पास के बाद गोला को प्रारंभिक छात्र के पास लौटाते हैं।\n\n  उदाहरण:\n  - count_passing_ways(3, 3) 2 लौटाता है\n  - count_passing_ways(4, 2) 4 लौटाता है\n  - count_passing_ways(5, 5) 6 लौटाता है\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja, hogy hány különböző módon lehet átadni egy labdát 'n' diák között, akik körben állnak, úgy, hogy 'm' átadás után a labda visszatér az eredeti diákhoz.\n\n  Argumentumok:\n  - n: A körben álló diákok száma. Ez egy egész szám, ahol 3 <= n <= 30.\n  - m: Az átadások száma. Ez egy egész szám, ahol 1 <= m <= 30.\n\n  Visszatérési érték:\n  - A különböző átadási sorozatok száma, amelyek 'm' átadás után visszajuttatják a labdát a kezdő diákhoz.\n\n  Példák:\n  - count_passing_ways(3, 3) visszaadja 2\n  - count_passing_ways(4, 2) visszaadja 4\n  - count_passing_ways(5, 5) visszaadja 6\n*/\nfn count_passing_ways(n: i32, m: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9979429837740027",
      "hy": "0.9790335701298624",
      "bn": "0.9829704242819739",
      "bg": "0.9781011991212846",
      "zh": "0.9725939731767113",
      "fr": "0.9988912452130633",
      "de": "0.9760336554850925",
      "ha": "0.9863846819015826",
      "hi": "0.9839381514983758",
      "hu": "0.9806865721608348"
    },
    "canonical_solution": "{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}",
    "instruction": {
      "en": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nՏրամադրել համառոտ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nনিচের Rust কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\n请用最多500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn count_passing_ways(n: i32, m: i32) -> i32\n{\n    let mut dp = vec![vec![0; (m + 1) as usize]; n as usize];\n\n    // Base case: 0 passes\n    dp[0][0] = 1;\n\n    for j in 1..=m as usize {\n        for i in 0..n as usize {\n            // Passing to the left or right neighbor\n            dp[i][j] = dp[(i + n as usize - 1) % n as usize][j - 1] \n                     + dp[(i + 1) % n as usize][j - 1];\n        }\n    }\n\n    dp[0][m as usize]\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9277247605135973",
      "bn": "0.8976533126072015",
      "bg": "0.8316696904400789",
      "zh": "0.856169158897684",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9536426485221726",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_passing_ways(3, 3), 2);\n        assert_eq!(count_passing_ways(4, 2), 2);\n        assert_eq!(count_passing_ways(5, 5), 2);    \n        assert_eq!(count_passing_ways(10, 3), 0);    \n        assert_eq!(count_passing_ways(30, 10), 252);    \n    }\n    \n\n}",
    "entry_point": "count_passing_ways",
    "signature": "fn count_passing_ways(n: i32, m: i32) -> i32",
    "docstring": {
      "en": "Calculates the number of different ways to pass a ball among 'n' students standing in a circle, such that after 'm' passes, the ball returns to the original student.\n\n  Arguments:\n  - n: The number of students in the circle. It is an integer where 3 <= n <= 30.\n  - m: The number of times the ball is passed. It is an integer where 1 <= m <= 30.\n\n  Returns:\n  - The number of distinct passing sequences that return the ball to the starting student after 'm' passes.\n\n  Examples:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6",
      "sq": "Llogarit numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve që qëndrojnë në një rreth, në mënyrë që pas 'm' kalimesh, topi të kthehet te studenti origjinal.\n\n  Argumentet:\n  - n: Numri i studentëve në rreth. Është një numër i plotë ku 3 <= n <= 30.\n  - m: Numri i herëve që topi kalohet. Është një numër i plotë ku 1 <= m <= 30.\n\n  Kthen:\n  - Numri i sekuencave të dallueshme të kalimit që kthejnë topin te studenti fillestar pas 'm' kalimesh.\n\n  Shembuj:\n  - count_passing_ways(3, 3) kthen 2\n  - count_passing_ways(4, 2) kthen 4\n  - count_passing_ways(5, 5) kthen 6",
      "hy": "Հաշվում է գնդակը 'n' աշակերտների միջև շրջանաձև փոխանցելու տարբեր եղանակների քանակը, այնպես, որ 'm' փոխանցումից հետո գնդակը վերադառնա սկզբնական աշակերտին:\n\n  Արձանագրումներ:\n  - n: Շրջանում կանգնած աշակերտների քանակը։ Դա ամբողջ թիվ է, որտեղ 3 <= n <= 30։\n  - m: Գնդակի փոխանցումների քանակը։ Դա ամբողջ թիվ է, որտեղ 1 <= m <= 30։\n\n  Վերադարձնում է:\n  - Տարբեր փոխանցման հաջորդականությունների քանակը, որոնք 'm' փոխանցումից հետո գնդակը վերադարձնում են սկզբնական աշակերտին։\n\n  Օրինակներ:\n  - count_passing_ways(3, 3) վերադարձնում է 2\n  - count_passing_ways(4, 2) վերադարձնում է 4\n  - count_passing_ways(5, 5) վերադարձնում է 6",
      "bn": "বলটি একটি বৃত্তে দাঁড়িয়ে থাকা 'n' জন ছাত্রের মধ্যে কতভাবে পাস করা যায় তা গণনা করে, যাতে 'm' বার পাস করার পর বলটি মূল ছাত্রের কাছে ফিরে আসে।\n\n  আর্গুমেন্টসমূহ:\n  - n: বৃত্তে ছাত্রদের সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 3 <= n <= 30।\n  - m: বলটি পাস করার সংখ্যা। এটি একটি পূর্ণসংখ্যা যেখানে 1 <= m <= 30।\n\n  রিটার্নস:\n  - স্বতন্ত্র পাসিং সিকোয়েন্সের সংখ্যা যা 'm' বার পাস করার পর বলটিকে শুরু ছাত্রের কাছে ফিরিয়ে দেয়।\n\n  উদাহরণ:\n  - count_passing_ways(3, 3) রিটার্ন করে 2\n  - count_passing_ways(4, 2) রিটার্ন করে 4\n  - count_passing_ways(5, 5) রিটার্ন করে 6",
      "bg": "Изчислява броя на различните начини за предаване на топка между 'n' ученици, стоящи в кръг, така че след 'm' предавания топката да се върне при първоначалния ученик.\n\n  Аргументи:\n  - n: Броят на учениците в кръга. Това е цяло число, където 3 <= n <= 30.\n  - m: Броят на предаванията на топката. Това е цяло число, където 1 <= m <= 30.\n\n  Връща:\n  - Броят на различните последователности на предаване, които връщат топката на началния ученик след 'm' предавания.\n\n  Примери:\n  - count_passing_ways(3, 3) връща 2\n  - count_passing_ways(4, 2) връща 4\n  - count_passing_ways(5, 5) връща 6",
      "zh": "计算在一个圆圈中有 'n' 个学生传球的不同方式，使得经过 'm' 次传球后，球返回到原来的学生。\n\n  参数:\n  - n: 圆圈中的学生数量。它是一个整数，范围为 3 <= n <= 30。\n  - m: 球被传递的次数。它是一个整数，范围为 1 <= m <= 30。\n\n  返回:\n  - 在 'm' 次传球后，球返回到起始学生的不同传球序列的数量。\n\n  示例:\n  - count_passing_ways(3, 3) 返回 2\n  - count_passing_ways(4, 2) 返回 4\n  - count_passing_ways(5, 5) 返回 6",
      "fr": "Calcule le nombre de façons différentes de faire passer un ballon parmi 'n' étudiants disposés en cercle, de telle sorte qu'après 'm' passes, le ballon revienne à l'étudiant d'origine.\n\n  Arguments:\n  - n: Le nombre d'étudiants dans le cercle. C'est un entier où 3 <= n <= 30.\n  - m: Le nombre de fois que le ballon est passé. C'est un entier où 1 <= m <= 30.\n\n  Retourne:\n  - Le nombre de séquences de passes distinctes qui ramènent le ballon à l'étudiant de départ après 'm' passes.\n\n  Exemples:\n  - count_passing_ways(3, 3) retourne 2\n  - count_passing_ways(4, 2) retourne 4\n  - count_passing_ways(5, 5) retourne 6",
      "de": "Berechnet die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis stehen, so weiterzugeben, dass der Ball nach 'm' Weitergaben zum ursprünglichen Schüler zurückkehrt.\n\n  Argumente:\n  - n: Die Anzahl der Schüler im Kreis. Es ist eine ganze Zahl, wobei 3 <= n <= 30.\n  - m: Die Anzahl der Male, die der Ball weitergegeben wird. Es ist eine ganze Zahl, wobei 1 <= m <= 30.\n\n  Rückgabewert:\n  - Die Anzahl der unterschiedlichen Weitergabesequenzen, die den Ball nach 'm' Weitergaben zum startenden Schüler zurückbringen.\n\n  Beispiele:\n  - count_passing_ways(3, 3) gibt 2 zurück\n  - count_passing_ways(4, 2) gibt 4 zurück\n  - count_passing_ways(5, 5) gibt 6 zurück",
      "ha": "Lissafa adadin hanyoyi daban-daban don wuce kwallo tsakanin 'n' ɗalibai da ke tsaye a cikin da'ira, ta yadda bayan 'm' wucewa, kwallon ta koma ga ɗalibin asali.\n\n  Huɗɗa:\n  - n: Yawan ɗalibai a cikin da'ira. Yana da lamba inda 3 <= n <= 30.\n  - m: Yawan sauyin da ake wuce ƙwallon. Yana da lamba inda 1 <= m <= 30.\n\n  Komawa:\n  - Yawan hanyoyin wucewa daban-daban da ke dawo da ƙwallon ga ɗalibin da ya fara bayan 'm' sauyin.\n\n  Misalai:\n  - count_passing_ways(3, 3) returns 2\n  - count_passing_ways(4, 2) returns 4\n  - count_passing_ways(5, 5) returns 6",
      "hi": "गेंद को 'n' छात्रों के बीच एक वृत्त में पास करने के विभिन्न तरीकों की गणना करता है, ताकि 'm' पास के बाद, गेंद मूल छात्र के पास लौट आए।\n\n  तर्क:\n  - n: वृत्त में छात्रों की संख्या। यह एक पूर्णांक है जहाँ 3 <= n <= 30।\n  - m: गेंद पास करने की बार की संख्या। यह एक पूर्णांक है जहाँ 1 <= m <= 30।\n\n  वापसी:\n  - विशिष्ट पासिंग अनुक्रमों की संख्या जो 'm' पास के बाद गेंद को प्रारंभिक छात्र के पास लौटाते हैं।\n\n  उदाहरण:\n  - count_passing_ways(3, 3) 2 लौटाता है\n  - count_passing_ways(4, 2) 4 लौटाता है\n  - count_passing_ways(5, 5) 6 लौटाता है",
      "hu": "Kiszámítja, hányféleképpen lehet átadni egy labdát 'n' diák között, akik körben állnak, úgy, hogy 'm' passz után a labda visszatér az eredeti diákhoz.\n\n  Argumentumok:\n  - n: A körben álló diákok száma. Ez egy egész szám, ahol 3 <= n <= 30.\n  - m: A labda átadásának száma. Ez egy egész szám, ahol 1 <= m <= 30.\n\n  Visszatér:\n  - Azoknak a különböző átadási sorozatoknak a száma, amelyek 'm' passz után visszajuttatják a labdát a kiinduló diákhoz.\n\n  Példák:\n  - count_passing_ways(3, 3) visszaadja 2\n  - count_passing_ways(4, 2) visszaadja 4\n  - count_passing_ways(5, 5) visszaadja 6"
    },
    "docstring_bertscore": {
      "sq": "0.9976545724607401",
      "hy": "0.9760815254069218",
      "bn": "0.9801037906228783",
      "bg": "0.9710913343441824",
      "zh": "0.9448272335814633",
      "fr": "0.9898847478457983",
      "de": "0.9843387889769232",
      "ha": "0.9795992694550497",
      "hi": "0.9882899445164692",
      "hu": "0.9784362885740905"
    }
  },
  {
    "task_id": "Rust/41",
    "prompt": {
      "en": "/*\n  Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "sq": "/*\n  Llogarit shumën maksimale të mundshme të diferencave absolute midis çifteve të elementeve nga dy vargje.\n  \n  Argumentet:\n  - a: Një varg me numra të plotë.\n  - b: Një varg me numra të plotë, me të njëjtën gjatësi si 'a'.\n  \n  Kthen:\n  - Shuma maksimale e diferencave absolute që mund të merret duke çiftuar secilin element nga 'a' me një nga 'b'.\n\n  Shembuj:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) kthen 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) kthen 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) kthen 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "hy": "/*\n  Հաշվարկում է զույգերի տարրերի միջև բացարձակ տարբերությունների առավելագույն հնարավոր գումարը երկու զանգվածներից:\n  \n  Արգումենտներ:\n  - a: ամբողջ թվերի զանգված:\n  - b: ամբողջ թվերի զանգված, նույն երկարության, ինչ 'a'-ն:\n  \n  Վերադարձնում է:\n  - Բացարձակ տարբերությունների առավելագույն գումարը, որը կարելի է ստանալ 'a'-ի յուրաքանչյուր տարրը 'b'-ի մեկ տարրի հետ զուգակցելով:\n\n  Օրինակներ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) վերադարձնում է 14:\n  - max_pairing_difference(&[1, 2], &[3, 4]) վերադարձնում է 4:\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) վերադարձնում է 60:\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "bn": "/*\n  দুটি অ্যারের উপাদানগুলির জোড়ার মধ্যে সর্বাধিক সম্ভাব্য যোগফল গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - a: পূর্ণসংখ্যার একটি অ্যারে।\n  - b: পূর্ণসংখ্যার একটি অ্যারে, যা 'a' এর সমান দৈর্ঘ্যের।\n\n  রিটার্নস:\n  - সর্বাধিক যোগফল যা 'a' থেকে প্রতিটি উপাদানকে 'b' এর একটি উপাদানের সাথে জোড়া করে প্রাপ্ত করা যেতে পারে।\n\n  উদাহরণসমূহ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 রিটার্ন করে।\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 রিটার্ন করে।\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 রিটার্ন করে।\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "bg": "/*\n  Изчислява максималната възможна сума от абсолютни разлики между двойки елементи от два масива.\n  \n  Аргументи:\n  - a: Масив от цели числа.\n  - b: Масив от цели числа, със същата дължина като 'a'.\n  \n  Връща:\n  - Максималната сума от абсолютни разлики, която може да бъде получена чрез сдвояване на всеки елемент от 'a' с един от 'b'.\n\n  Примери:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) връща 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) връща 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) връща 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "zh": "/*\n  计算两个数组中元素对之间绝对差的最大可能和。\n  \n  参数:\n  - a: 整数数组。\n  - b: 整数数组，与 'a' 的长度相同。\n  \n  返回:\n  - 通过将 'a' 中的每个元素与 'b' 中的一个元素配对可以获得的绝对差的最大和。\n\n  示例:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 返回 14。\n  - max_pairing_difference(&[1, 2], &[3, 4]) 返回 4。\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 返回 60。\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "fr": "/*\n  Calcule la somme maximale possible des différences absolues entre les paires d'éléments de deux tableaux.\n  \n  Arguments:\n  - a: Un tableau d'entiers.\n  - b: Un tableau d'entiers, de la même longueur que 'a'.\n  \n  Renvoie:\n  - La somme maximale des différences absolues qui peut être obtenue en associant chaque élément de 'a' avec un de 'b'.\n\n  Exemples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) renvoie 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) renvoie 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) renvoie 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "de": "/*\n  Berechnet die maximal mögliche Summe der absoluten Unterschiede zwischen Paaren von Elementen aus zwei Arrays.\n  \n  Argumente:\n  - a: Ein Array von Ganzzahlen.\n  - b: Ein Array von Ganzzahlen, mit der gleichen Länge wie 'a'.\n  \n  Rückgabewert:\n  - Die maximale Summe der absoluten Unterschiede, die durch das Paaren jedes Elements von 'a' mit einem von 'b' erzielt werden kann.\n\n  Beispiele:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) gibt 14 zurück.\n  - max_pairing_difference(&[1, 2], &[3, 4]) gibt 4 zurück.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) gibt 60 zurück.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "ha": "/*\n  Lissafi mafi girman yuwuwar jimillar bambance-bambancen darajar da za a iya samu tsakanin ma'aurata daga abubuwan da ke cikin jerin lambobi guda biyu.\n  \n  Huɗoɗi:\n  - a: Jerin lambobi na cikakken adadi.\n  - b: Jerin lambobi na cikakken adadi, mai tsawon iri ɗaya da 'a'.\n  \n  Komawa:\n  - Mafi girman jimillar bambance-bambancen darajar da za a iya samu ta hanyar haɗa kowane abu daga 'a' da ɗaya daga 'b'.\n\n  Misalai:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "hi": "/*\n  दो एरे के तत्वों के जोड़ों के बीच निरपेक्ष अंतर के अधिकतम संभव योग की गणना करता है।\n\n  तर्क:\n  - a: पूर्णांकों का एक एरे।\n  - b: पूर्णांकों का एक एरे, जो 'a' के समान लंबाई का है।\n\n  रिटर्न करता है:\n  - निरपेक्ष अंतरों का अधिकतम योग जो 'a' के प्रत्येक तत्व को 'b' के एक तत्व के साथ जोड़कर प्राप्त किया जा सकता है।\n\n  उदाहरण:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 लौटाता है।\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 लौटाता है।\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 लौटाता है।\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 ",
      "hu": "/*\n  Kiszámítja a maximális lehetséges összegét az elemek közötti abszolút különbségeknek két tömb párjai között.\n  \n  Argumentumok:\n  - a: Egész számok tömbje.\n  - b: Egész számok tömbje, amely ugyanolyan hosszú, mint 'a'.\n  \n  Visszatér:\n  - Az abszolút különbségek maximális összege, amely elérhető úgy, hogy az 'a' minden elemét párosítjuk a 'b' egyik elemével.\n\n  Példák:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) visszatér 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) visszatér 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) visszatér 60.\n*/\n\nfn max_pairing_difference(a: &[i32], b: &[i32]) -> i64 "
    },
    "prompt_bertscore": {
      "sq": "0.997620209404821",
      "hy": "0.9883648281701194",
      "bn": "0.971567252737142",
      "bg": "0.9904097279428735",
      "zh": "0.9676633712282823",
      "fr": "0.9971111197382286",
      "de": "0.9907509749374914",
      "ha": "0.9443119863730588",
      "hi": "0.9843296519793956",
      "hu": "0.9880819785075257"
    },
    "canonical_solution": "{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}",
    "instruction": {
      "en": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nՏվեք կարճ բնութագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nনিচের রাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\n请用最多500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, अधिकतम 500 वर्णों का उपयोग करते हुए।",
      "hu": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64\n{\n    assert_eq!(a.len(), b.len(), \"Arrays must be of equal length\");\n\n    // Clone and sort arrays\n    let mut a_sorted = a.to_vec();\n    a_sorted.sort();\n    let mut b_sorted = b.to_vec();\n    b_sorted.sort_by(|x, y| y.cmp(x)); // Sort in descending order\n\n    // Calculate the sum of absolute differences\n    a_sorted.iter().zip(b_sorted.iter())\n        .map(|(x, y)| (*x as i64 - *y as i64).abs())\n        .sum()\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8870448612168901",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.856169158897684",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9536426485221726",
      "hi": "0.9220725343908686",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]), 14);\n        assert_eq!(max_pairing_difference(&[1, 2], &[3, 4]), 4);\n        assert_eq!(max_pairing_difference(&[10, 20, 30], &[30, 20, 10]), 40);\n    }\n    \n}",
    "entry_point": "max_pairing_difference",
    "signature": "fn max_pairing_difference(a: &[i32], b: &[i32]) -> i64",
    "docstring": {
      "en": "Calculates the maximum possible sum of absolute differences between pairs of elements from two arrays.\n  \n  Arguments:\n  - a: An array of integers.\n  - b: An array of integers, of the same length as 'a'.\n  \n  Returns:\n  - The maximum sum of absolute differences that can be obtained by pairing each element from 'a' with one from 'b'.\n\n  Examples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "sq": "Llogarit shumën maksimale të mundshme të diferencave absolute midis çifteve të elementeve nga dy vargje.\n\nArguments:\n- a: Një varg me numra të plotë.\n- b: Një varg me numra të plotë, me të njëjtën gjatësi si 'a'.\n\nReturns:\n- Shuma maksimale e diferencave absolute që mund të merret duke çiftuar secilin element nga 'a' me një nga 'b'.\n\nExamples:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) kthen 14.\n- max_pairing_difference(&[1, 2], &[3, 4]) kthen 4.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) kthen 60.",
      "hy": "Հաշվում է երկու զանգվածներից տարրերի զույգերի միջև բացարձակ տարբերությունների առավելագույն հնարավոր գումարը։\n\nՓոփոխականներ:\n- a: ամբողջ թվերի զանգված։\n- b: ամբողջ թվերի զանգված, նույն երկարությամբ, ինչ 'a'։\n\nՎերադարձնում է:\n- Բացարձակ տարբերությունների առավելագույն գումարը, որը կարող է ստացվել 'a'-ի յուրաքանչյուր տարրը 'b'-ի մեկ տարրի հետ զուգակցելով։\n\nՕրինակներ:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) վերադարձնում է 14։\n- max_pairing_difference(&[1, 2], &[3, 4]) վերադարձնում է 4։\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) վերադարձնում է 60։",
      "bn": "দুটি অ্যারের উপাদানগুলোর জোড়া থেকে পার্থক্যের সর্বাধিক সম্ভাব্য যোগফল গণনা করে।\n  \n  আর্গুমেন্টসমূহ:\n  - a: পূর্ণসংখ্যার একটি অ্যারে।\n  - b: পূর্ণসংখ্যার একটি অ্যারে, যা 'a' এর সমান দৈর্ঘ্যের।\n\n  রিটার্নস:\n  - সর্বাধিক যোগফল যা প্রতিটি উপাদানকে 'a' থেকে 'b' এর একটি উপাদানের সাথে জোড়া করে প্রাপ্ত হতে পারে।\n\n  উদাহরণসমূহ:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 14 রিটার্ন করে।\n  - max_pairing_difference(&[1, 2], &[3, 4]) 4 রিটার্ন করে।\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 60 রিটার্ন করে।",
      "bg": "Изчислява максималната възможна сума на абсолютните разлики между двойки елементи от два масива.\n\nАргументи:\n- a: Масив от цели числа.\n- b: Масив от цели числа, със същата дължина като 'a'.\n\nВръща:\n- Максималната сума на абсолютните разлики, която може да бъде получена чрез сдвояване на всеки елемент от 'a' с един от 'b'.\n\nПримери:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) връща 14.\n- max_pairing_difference(&[1, 2], &[3, 4]) връща 4.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) връща 60.",
      "zh": "计算两个数组中元素对之间绝对差的最大可能和。\n\n  参数:\n  - a: 一个整数数组。\n  - b: 一个整数数组，与 'a' 的长度相同。\n\n  返回:\n  - 通过将 'a' 中的每个元素与 'b' 中的一个元素配对可以获得的绝对差的最大和。\n\n  示例:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) 返回 14。\n  - max_pairing_difference(&[1, 2], &[3, 4]) 返回 4。\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) 返回 60。",
      "fr": "Calcule la somme maximale possible des différences absolues entre les paires d'éléments de deux tableaux.\n  \n  Arguments:\n  - a: Un tableau d'entiers.\n  - b: Un tableau d'entiers, de la même longueur que 'a'.\n  \n  Retourne:\n  - La somme maximale des différences absolues qui peut être obtenue en associant chaque élément de 'a' avec un de 'b'.\n\n  Exemples:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) retourne 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) retourne 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) retourne 60.",
      "de": "Berechnet die maximal mögliche Summe der absoluten Differenzen zwischen Paaren von Elementen aus zwei Arrays.\n\n  Argumente:\n  - a: Ein Array von ganzen Zahlen.\n  - b: Ein Array von ganzen Zahlen, mit der gleichen Länge wie 'a'.\n  \n  Rückgabewerte:\n  - Die maximale Summe der absoluten Differenzen, die durch das Paaren jedes Elements aus 'a' mit einem aus 'b' erzielt werden kann.\n\n  Beispiele:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) gibt 14 zurück.\n  - max_pairing_difference(&[1, 2], &[3, 4]) gibt 4 zurück.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) gibt 60 zurück.",
      "ha": "Lissafin yuwuwar jimillar bambance-bambancen darajar da za a iya samu tsakanin ma'aurata na abubuwa daga jerin abubuwa biyu.\n\n  Huɗɗa:\n  - a: Jeri na lambobin cikakke.\n  - b: Jeri na lambobin cikakke, wanda yake da tsawon iri ɗaya da 'a'.\n\n  Dawowa:\n  - Mafi girman jimillar bambance-bambancen cikakke da za a iya samu ta hanyar haɗa kowane abu daga 'a' da ɗaya daga 'b'.\n\n  Misalai:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "hi": "दो ऐरे के तत्वों के जोड़ों के बीच अधिकतम संभव पूर्णांकों के अंतर के योग की गणना करता है।\n\nArguments:\n- a: पूर्णांकों की एक array।\n- b: पूर्णांकों की एक array, जो 'a' के समान लंबाई की है।\n\nReturns:\n- अधिकतम योग जो कि प्रत्येक तत्व को 'a' से 'b' के एक तत्व के साथ जोड़कर प्राप्त किया जा सकता है।\n\nExamples:\n- max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) returns 14.\n- max_pairing_difference(&[1, 2], &[3, 4]) returns 4.\n- max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) returns 60.",
      "hu": "Kiszámítja a maximális lehetséges abszolút különbségek összegét két tömb elempárjai között.\n\n  Argumentumok:\n  - a: Egész számokat tartalmazó tömb.\n  - b: Egész számokat tartalmazó tömb, amely ugyanolyan hosszú, mint 'a'.\n\n  Visszatér:\n  - Az abszolút különbségek maximális összege, amelyet úgy lehet elérni, hogy az 'a' minden elemét párosítjuk a 'b' egy elemével.\n\n  Példák:\n  - max_pairing_difference(&[2, 5, 6, 3], &[1, 4, 6, 7]) visszaadja 14.\n  - max_pairing_difference(&[1, 2], &[3, 4]) visszaadja 4.\n  - max_pairing_difference(&[10, 20, 30], &[30, 20, 10]) visszaadja 60."
    },
    "docstring_bertscore": {
      "sq": "0.9963235502774253",
      "hy": "0.99643577644271",
      "bn": "0.964968950109544",
      "bg": "0.9897818573084223",
      "zh": "0.9855847973571551",
      "fr": "0.9958704743782847",
      "de": "0.9817798337780508",
      "ha": "0.9742725985268371",
      "hi": "0.9861826748040701",
      "hu": "0.9775521847481042"
    }
  },
  {
    "task_id": "Rust/42",
    "prompt": {
      "en": "/*\n  Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "sq": "/*\n  Gjen numrin me faktorin më të madh prim në një listë të dhënë numrash.\n\n  Funksioni iteron nëpër secilin numër në listë dhe llogarit faktorin e tij më të madh prim. \n  Më pas krahason këta faktorë për të gjetur numrin me faktorin më të madh prim.\n\n  Argumentet:\n  - numbers: Një segment i numrave të plotë.\n\n  Kthen:\n  - Numrin nga lista që ka faktorin më të madh prim.\n\n  Shembuj:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) kthen 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) kthen 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) kthen 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "hy": "/*\n  Գտնում է այն թիվը, որը ունի ամենամեծ պարզ բաժանարարը տրված թվերի ցանկում:\n\n  Ֆունկցիան անցնում է ցանկի յուրաքանչյուր թվի միջով և հաշվարկում դրա ամենամեծ պարզ բաժանարարը:\n  Այնուհետև համեմատում է այս բաժանարարները՝ գտնելու համար այն թիվը, որը ունի ամենամեծ պարզ բաժանարարը:\n\n  Արգումենտներ:\n  - numbers: ամբողջ թվերի կտոր։\n\n  Վերադարձնում է:\n  - Ցանկից այն թիվը, որը ունի ամենամեծ պարզ բաժանարարը:\n\n  Օրինակներ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) վերադարձնում է 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) վերադարձնում է 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) վերադարձնում է 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "bn": "/*\n  প্রদত্ত সংখ্যার তালিকায় সবচেয়ে বড় মৌলিক গুণকযুক্ত সংখ্যা খুঁজে বের করে।\n\n  ফাংশনটি তালিকার প্রতিটি সংখ্যার মাধ্যমে পুনরাবৃত্তি করে এবং এর সবচেয়ে বড় মৌলিক গুণক গণনা করে। \n  তারপর এই গুণকগুলির সাথে তুলনা করে সবচেয়ে বড় মৌলিক গুণকযুক্ত সংখ্যাটি খুঁজে বের করে।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস।\n\n  রিটার্ন করে:\n  - তালিকা থেকে সেই সংখ্যাটি যার সবচেয়ে বড় মৌলিক গুণক রয়েছে।\n\n  উদাহরণসমূহ:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "bg": "/*\n  Намира числото с най-голям прост делител в даден списък от числа.\n\n  Функцията преминава през всяко число в списъка и изчислява неговия най-голям прост делител.\n  След това сравнява тези делители, за да намери числото с най-голям прост делител.\n\n  Аргументи:\n  - numbers: Срез от цели числа.\n\n  Връща:\n  - Числото от списъка, което има най-голям прост делител.\n\n  Примери:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) връща 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) връща 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) връща 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "zh": "/*\n  查找给定数字列表中具有最大素因数的数字。\n\n  该函数遍历列表中的每个数字并计算其最大的素因数。\n  然后比较这些因数以找到具有最大素因数的数字。\n\n  参数：\n  - numbers: 整数切片。\n\n  返回：\n  - 列表中具有最大素因数的数字。\n\n  示例：\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) 返回 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) 返回 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) 返回 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "fr": "/*\n  Trouve le nombre avec le plus grand facteur premier dans une liste donnée de nombres.\n\n  La fonction parcourt chaque nombre de la liste et calcule son plus grand facteur premier.\n  Elle compare ensuite ces facteurs pour trouver le nombre avec le plus grand facteur premier.\n\n  Arguments:\n  - numbers: Une tranche d'entiers.\n\n  Renvoie:\n  - Le nombre de la liste qui a le plus grand facteur premier.\n\n  Exemples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "de": "/*\n  Findet die Zahl mit dem größten Primfaktor in einer gegebenen Liste von Zahlen.\n\n  Die Funktion iteriert durch jede Zahl in der Liste und berechnet deren größten Primfaktor. \n  Sie vergleicht dann diese Faktoren, um die Zahl mit dem größten Primfaktor zu finden.\n\n  Argumente:\n  - numbers: Ein Slice von ganzen Zahlen.\n\n  Rückgabewerte:\n  - Die Zahl aus der Liste, die den größten Primfaktor hat.\n\n  Beispiele:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) gibt 38 zurück\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) gibt 22 zurück\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) gibt 19 zurück\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "ha": "/*\n  Nemi lambar da ke da mafi girman abin da ke da farko a cikin jerin lambobi da aka bayar.\n\n  Aikin yana zagayawa ta kowace lamba a cikin jerin kuma yana ƙididdige mafi girman abin da ke da farko. \n  Sannan yana kwatanta waɗannan abubuwan don nemo lambar da ke da mafi girman abin da ke da farko.\n\n  Huɗa:\n  - numbers: Wani yanki na lambobin cikakku.\n\n  Komawa:\n  - Lambar daga jerin da ke da mafi girman abin da ke da farko.\n\n  Misalai:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "hi": "/*\n  दिए गए संख्याओं की सूची में सबसे बड़े अभाज्य गुणनखंड वाली संख्या खोजता है।\n\n  फ़ंक्शन सूची में प्रत्येक संख्या के माध्यम से इटरेट करता है और उसके सबसे बड़े अभाज्य गुणनखंड की गणना करता है।\n  फिर यह इन गुणनखंडों की तुलना करके सबसे बड़े अभाज्य गुणनखंड वाली संख्या खोजता है।\n\n  तर्क:\n  - numbers: पूर्णांकों की एक श्रेणी।\n\n  लौटाता है:\n  - सूची से वह संख्या जिसका सबसे बड़ा अभाज्य गुणनखंड है।\n\n  उदाहरण:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32",
      "hu": "/*\n  Megkeresi azt a számot a megadott számok listájában, amelynek a legnagyobb prímtényezője van.\n\n  A függvény végigmegy a lista minden számán, és kiszámítja annak legnagyobb prímtényezőjét.\n  Ezután összehasonlítja ezeket a tényezőket, hogy megtalálja azt a számot, amelynek a legnagyobb prímtényezője van.\n\n  Argumentumok:\n  - numbers: Egész számok szelete.\n\n  Visszatér:\n  - A lista azon száma, amelynek a legnagyobb prímtényezője van.\n\n  Példák:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) visszaadja 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) visszaadja 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) visszaadja 19\n*/\n\nfn max_prime_factor_in_list(numbers: &[i32]) -> i32"
    },
    "prompt_bertscore": {
      "sq": "0.9993695471705952",
      "hy": "0.9876771697909765",
      "bn": "0.9861459281835786",
      "bg": "0.9993695471705952",
      "zh": "0.9802525647782735",
      "fr": "0.9976011408882417",
      "de": "0.9952614736300317",
      "ha": "0.9756216960748261",
      "hi": "0.9831227737842276",
      "hu": "0.9836469593597786"
    },
    "canonical_solution": "{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}",
    "instruction": {
      "en": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nՏվեք կարճ բնութագրություն (docstring) Rust կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसका आकार अधिकतम 500 वर्णों तक हो।",
      "hu": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32\n{\n    let mut max_prime = -1;\n    let mut result = -1;\n\n    for &num in numbers {\n        let prime_factor = largest_prime_factor(num);\n        if prime_factor > max_prime {\n            max_prime = prime_factor;\n            result = num;\n        }\n    }\n\n    result\n}\n\nfn largest_prime_factor(mut n: i32) -> i32 \n{\n    let mut max_prime = -1;\n\n    // Divide n by 2 until it becomes odd\n    while n % 2 == 0 {\n        max_prime = 2;\n        n /= 2;\n    }\n\n    // n must be odd at this point, so a skip of 2 (i += 2) can be used\n    for i in (3..=(n as f64).sqrt() as i32).step_by(2) {\n        while n % i == 0 {\n            max_prime = i;\n            n /= i;\n        }\n    }\n\n    // Handle the case when n is a prime number greater than 2\n    if n > 2 {\n        max_prime = n;\n    }\n\n    max_prime\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.8946337335547091",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.937014504804218",
      "hi": "0.8958767624792254",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_prime_factor_in_list(&[36, 38, 40, 42]), 38);\n        assert_eq!(max_prime_factor_in_list(&[10, 15, 21, 22]), 22);\n        assert_eq!(max_prime_factor_in_list(&[7, 11, 13, 19]), 19);\n        assert_eq!(max_prime_factor_in_list(&[2, 3, 5, 7]), 7);\n    }\n    \n\n}",
    "entry_point": "max_prime_factor_in_list",
    "signature": "fn max_prime_factor_in_list(numbers: &[i32]) -> i32",
    "docstring": {
      "en": "Finds the number with the largest prime factor in a given list of numbers.\n\n  The function iterates through each number in the list and calculates its largest prime factor. \n  It then compares these factors to find the number with the largest prime factor.\n\n  Arguments:\n  - numbers: A slice of integers.\n\n  Returns:\n  - The number from the list that has the largest prime factor.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "sq": "Gjen numrin me faktor kryesor më të madh në një listë të dhënë numrash.\n\n  Funksioni iteron nëpër secilin numër në listë dhe llogarit faktorin e tij më të madh kryesor. \n  Pastaj krahason këta faktorë për të gjetur numrin me faktor kryesor më të madh.\n\n  Argumentet:\n  - numbers: Një prerje e numrave të plotë.\n\n  Kthen:\n  - Numri nga lista që ka faktorin kryesor më të madh.\n\n  Shembuj:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) kthen 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) kthen 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) kthen 19",
      "hy": "Գտնում է ցուցակում ամենամեծ պարզ բաժանարար ունեցող թիվը:\n\n  Ֆունկցիան անցնում է ցուցակի յուրաքանչյուր թվով և հաշվարկում դրա ամենամեծ պարզ բաժանարարը:\n  Այնուհետև համեմատում է այդ բաժանարարները՝ գտնելու ամենամեծ պարզ բաժանարար ունեցող թիվը:\n\n  Արգումենտներ:\n  - numbers: Թվերի շերտ:\n\n  Վերադարձնում է.\n  - Ցուցակից այն թիվը, որը ունի ամենամեծ պարզ բաժանարարը:\n\n  Օրինակներ.\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) վերադարձնում է 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) վերադարձնում է 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) վերադարձնում է 19",
      "bn": "প্রদত্ত সংখ্যার তালিকায় সবচেয়ে বড় মৌলিক গুণনীয়কযুক্ত সংখ্যা খুঁজে বের করে।\n  এটি তালিকার প্রতিটি সংখ্যার উপর দিয়ে পুনরাবৃত্তি করে এবং তার সবচেয়ে বড় মৌলিক গুণনীয়ক গণনা করে।\n  তারপর এই গুণনীয়কগুলির তুলনা করে সবচেয়ে বড় মৌলিক গুণনীয়কযুক্ত সংখ্যাটি খুঁজে বের করে।\n\n  Arguments:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস।\n\n  Returns:\n  - তালিকা থেকে সেই সংখ্যা যা সবচেয়ে বড় মৌলিক গুণনীয়কযুক্ত।\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "bg": "Намира числото с най-голям прост делител в даден списък от числа.\n\n  Функцията преминава през всяко число в списъка и изчислява неговия най-голям прост делител. \n  След това сравнява тези делители, за да намери числото с най-голям прост делител.\n\n  Аргументи:\n  - numbers: Списък от цели числа.\n\n  Връща:\n  - Числото от списъка, което има най-голям прост делител.\n\n  Примери:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) връща 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) връща 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) връща 19",
      "zh": "找到给定数字列表中具有最大素因子的数字。\n\n该函数遍历列表中的每个数字并计算其最大素因子。然后比较这些因子以找到具有最大素因子的数字。\n\n参数:\n- numbers: 整数切片。\n\n返回:\n- 列表中具有最大素因子的数字。\n\n示例:\n- max_prime_factor_in_list(&[36, 38, 40, 42]) 返回 38\n- max_prime_factor_in_list(&[10, 15, 21, 22]) 返回 22\n- max_prime_factor_in_list(&[7, 11, 13, 19]) 返回 19",
      "fr": "Trouve le nombre avec le plus grand facteur premier dans une liste donnée de nombres.\n\n  La fonction parcourt chaque nombre de la liste et calcule son plus grand facteur premier.\n  Elle compare ensuite ces facteurs pour trouver le nombre avec le plus grand facteur premier.\n\n  Arguments:\n  - numbers: Une tranche d'entiers.\n\n  Returns:\n  - Le nombre de la liste qui a le plus grand facteur premier.\n\n  Examples:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "de": "Findet die Zahl mit dem größten Primfaktor in einer gegebenen Liste von Zahlen.\n\n  Die Funktion durchläuft jede Zahl in der Liste und berechnet ihren größten Primfaktor. \n  Anschließend vergleicht sie diese Faktoren, um die Zahl mit dem größten Primfaktor zu finden.\n\n  Argumente:\n  - numbers: Ein Ausschnitt von ganzen Zahlen.\n\n  Rückgabewerte:\n  - Die Zahl aus der Liste, die den größten Primfaktor hat.\n\n  Beispiele:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) gibt 38 zurück\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) gibt 22 zurück\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) gibt 19 zurück",
      "ha": "Yana nemo lambar da take da mafi girman abin da ke rarraba ta a cikin jerin lambobi da aka bayar.\n\n  Aikin yana zagayawa ta kowace lamba a cikin jerin kuma yana ƙididdige mafi girman abin da ke rarraba ta. \n  Sannan yana kwatanta waɗannan abubuwan don nemo lambar da take da mafi girman abin da ke rarraba ta.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobin cikakke.\n\n  Dawowa:\n  - Lambar daga jerin da take da mafi girman abin da ke rarraba ta.\n\n  Misalai:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) yana dawowa 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) yana dawowa 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) yana dawowa 19",
      "hi": "दिए गए संख्याओं की सूची में सबसे बड़े अभाज्य गुणनखंड वाले संख्या को खोजता है।\n\n  फ़ंक्शन सूची में प्रत्येक संख्या के माध्यम से पुनरावृत्ति करता है और उसके सबसे बड़े अभाज्य गुणनखंड की गणना करता है।\n  फिर यह इन गुणनखण्डों की तुलना करता है ताकि सबसे बड़े अभाज्य गुणनखंड वाली संख्या को खोजा जा सके।\n\n  तर्क:\n  - numbers: पूर्णांकों की एक सूची।\n\n  वापसी:\n  - सूची से वह संख्या जो सबसे बड़े अभाज्य गुणनखंड वाली है।\n\n  उदाहरण:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) returns 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) returns 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) returns 19",
      "hu": "Megkeresi azt a számot, amelynek a legnagyobb prímtényezője van egy adott számok listájában.\n\n  A függvény végigiterál a lista minden számán, és kiszámítja annak legnagyobb prímtényezőjét. \n  Ezután összehasonlítja ezeket a tényezőket, hogy megtalálja azt a számot, amelynek a legnagyobb prímtényezője van.\n\n  Argumentumok:\n  - numbers: Egész számok szelete.\n\n  Visszatér:\n  - A lista azon száma, amelynek a legnagyobb prímtényezője van.\n\n  Példák:\n  - max_prime_factor_in_list(&[36, 38, 40, 42]) visszaadja 38\n  - max_prime_factor_in_list(&[10, 15, 21, 22]) visszaadja 22\n  - max_prime_factor_in_list(&[7, 11, 13, 19]) visszaadja 19"
    },
    "docstring_bertscore": {
      "sq": "0.9942208490637899",
      "hy": "0.9769628484075736",
      "bn": "0.9921131820906287",
      "bg": "0.9474185655324444",
      "zh": "0.9772161021433932",
      "fr": "0.9919876476898147",
      "de": "0.9890332194023017",
      "ha": "0.9152005190982045",
      "hi": "0.9929380940630667",
      "hu": "0.9854103998826065"
    }
  },
  {
    "task_id": "Rust/43",
    "prompt": {
      "en": "/*\n  Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "sq": "/*\n  Llogarit gjatësinë e nënvargut më të gjatë jo-zvogëlues në një sekuencë të dhënë numrash.\n  \n  Funksioni merr një vektor të numrave të plotë dhe kthen gjatësinë e nënvargut më të gjatë ku secili element nuk është më i vogël se ai i mëparshmi.\n\n  Argumentet:\n  - sequence: Një vektor i numrave të plotë.\n\n  Kthen:\n  - Gjatesia e nënvargut më të gjatë jo-zvogëlues në sekuencën e dhënë.\n\n  Shembuj:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) kthen 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) kthen 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) kthen 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "hy": "/*\n  Հաշվում է տրված թվերի հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը։\n\n  Ֆունկցիան ընդունում է ամբողջ թվերի վեկտոր և վերադարձնում է ամենաերկար ենթահաջորդականության երկարությունը, որտեղ յուրաքանչյուր տարր չի փոքրանում նախորդից։\n\n  Արգումենտներ:\n  - sequence: Ամբողջ թվերի վեկտոր։\n\n  Վերադարձնում է:\n  - Տրված հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը։\n\n  Օրինակներ:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) վերադարձնում է 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) վերադարձնում է 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) վերադարձնում է 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "bn": "/*\n  প্রদত্ত সংখ্যার একটি সিকোয়েন্সে দীর্ঘতম অ-হ্রাসমান উপসিকোয়েন্সের দৈর্ঘ্য গণনা করে।\n\n  ফাংশনটি পূর্ণসংখ্যার একটি ভেক্টর নেয় এবং দীর্ঘতম উপসিকোয়েন্সের দৈর্ঘ্য ফেরত দেয় যেখানে প্রতিটি উপাদান পূর্ববর্তীটির চেয়ে কম নয়।\n\n  আর্গুমেন্টসমূহ:\n  - sequence: পূর্ণসংখ্যার একটি ভেক্টর।\n\n  রিটার্নস:\n  - প্রদত্ত সিকোয়েন্সে দীর্ঘতম অ-হ্রাসমান উপসিকোয়েন্সের দৈর্ঘ্য।\n\n  উদাহরণসমূহ:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 ফেরত দেয়\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 ফেরত দেয়\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 ফেরত দেয়\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "bg": "/*\n  Изчислява дължината на най-дългата не-намаляваща подредица в дадена последователност от числа.\n  \n  Функцията приема вектор от цели числа и връща дължината на най-дългата подредица, в която всеки елемент не е по-малък от предишния.\n\n  Аргументи:\n  - sequence: Вектор от цели числа.\n\n  Връща:\n  - Дължината на най-дългата не-намаляваща подредица в дадената последователност.\n\n  Примери:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) връща 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) връща 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) връща 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "zh": "/*\n  计算给定数字序列中最长非递减子序列的长度。\n  \n  该函数接受一个整数向量，并返回最长子序列的长度，其中每个元素不小于前一个元素。\n\n  参数:\n  - sequence: 一个整数向量。\n\n  返回:\n  - 给定序列中最长非递减子序列的长度。\n\n  示例:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 返回 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 返回 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 返回 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "fr": "/*\n  Calcule la longueur de la plus longue sous-séquence non décroissante dans une séquence donnée de nombres.\n  \n  La fonction prend un vecteur d'entiers et renvoie la longueur de la plus longue sous-séquence où chaque élément n'est pas inférieur au précédent.\n\n  Arguments :\n  - sequence: Un vecteur d'entiers.\n\n  Renvoie :\n  - La longueur de la plus longue sous-séquence non décroissante dans la séquence donnée.\n\n  Exemples :\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) renvoie 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) renvoie 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) renvoie 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "de": "/*\n  Berechnet die Länge der längsten nicht abnehmenden Teilfolge in einer gegebenen Zahlenfolge.\n  \n  Die Funktion nimmt einen Vektor von ganzen Zahlen und gibt die Länge der längsten Teilfolge zurück, bei der jedes Element nicht kleiner als das vorherige ist.\n\n  Argumente:\n  - sequence: Ein Vektor von ganzen Zahlen.\n\n  Rückgabewert:\n  - Die Länge der längsten nicht abnehmenden Teilfolge in der gegebenen Sequenz.\n\n  Beispiele:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) gibt 3 zurück\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) gibt 3 zurück\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) gibt 4 zurück\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "ha": "/*\n  Lissafin tsawon mafi tsawo wanda ba ya raguwa a cikin jerin lambobi da aka bayar.\n  \n  Aikin yana ɗaukar vector na lambobi kuma yana mayar da tsawon mafi tsawo lissafi inda kowane abu ba ya raguwa daga wanda ya gabace shi.\n\n  Huɗɗa:\n  - sequence: Vector na lambobi.\n\n  Mayarwa:\n  - Tsawon mafi tsawo lissafi wanda ba ya raguwa a cikin jerin da aka bayar.\n\n  Misalai:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) yana mayar da 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) yana mayar da 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) yana mayar da 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "hi": "/*\n  दिए गए संख्याओं के अनुक्रम में सबसे लंबी गैर-घटती उपक्रम की लंबाई की गणना करता है।\n\n  यह फ़ंक्शन पूर्णांकों के एक वेक्टर को लेता है और सबसे लंबी उपक्रम की लंबाई लौटाता है जहाँ प्रत्येक तत्व पिछले तत्व से कम नहीं होता है।\n\n  तर्क:\n  - sequence: पूर्णांकों का एक वेक्टर।\n\n  लौटाता है:\n  - दिए गए अनुक्रम में सबसे लंबी गैर-घटती उपक्रम की लंबाई।\n\n  उदाहरण:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 लौटाता है\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 लौटाता है\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 लौटाता है\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize ",
      "hu": "/*\n  Kiszámítja a leghosszabb nem csökkenő részszekvencia hosszát egy adott számokból álló sorozatban.\n  \n  A függvény egy egész számokat tartalmazó vektort vesz át, és visszaadja a leghosszabb részszekvencia hosszát, ahol minden elem nem kisebb az előzőnél.\n\n  Argumentumok:\n  - sequence: Egy egész számokat tartalmazó vektor.\n\n  Visszatérési érték:\n  - A leghosszabb nem csökkenő részszekvencia hossza az adott sorozatban.\n\n  Példák:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) visszaadja 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) visszaadja 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) visszaadja 4\n*/\n\nfn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9977646136918333",
      "hy": "0.9926401484915143",
      "bn": "0.999999801369619",
      "bg": "0.9925563264707176",
      "zh": "0.9922091205646686",
      "fr": "0.9988471492684735",
      "de": "0.9943058628668728",
      "ha": "0.9466075576866789",
      "hi": "0.9954293163020062",
      "hu": "0.9904615704723236"
    },
    "canonical_solution": "{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}",
    "instruction": {
      "en": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nՏրամադրել կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nДайте кратко описание на кода на Rust на български език, използвайки не повече от 500 символа.",
      "zh": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nरस्ट कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों का उपयोग करते हुए प्रदान करें।",
      "hu": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize\n{\n    let n = sequence.len();\n    if n == 0 {\n        return 0;\n    }\n\n    let mut lengths = vec![1; n];\n    for i in 1..n {\n        for j in 0..i {\n            if sequence[j] <= sequence[i] {\n                lengths[i] = lengths[i].max(lengths[j] + 1);\n            }\n        }\n    }\n\n    *lengths.iter().max().unwrap()\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9538033405004298",
      "hy": "0.9258661760382538",
      "bn": "0.868870975873722",
      "bg": "0.8252430044616951",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9230891246810051",
      "hi": "0.961450411539892",
      "hu": "0.9315990460956828"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![1, 2, 3]), 3);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]), 4);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![]), 0);\n        assert_eq!(longest_non_decreasing_subsequence_length(vec![10]), 1);        \n    }\n    \n\n}",
    "entry_point": "longest_non_decreasing_subsequence_length",
    "signature": "fn longest_non_decreasing_subsequence_length(sequence: Vec<i32>) -> usize",
    "docstring": {
      "en": "Calculates the length of the longest non-decreasing subsequence in a given sequence of numbers.\n  \n  The function takes a vector of integers and returns the length of the longest subsequence where each element is not less than the previous one.\n\n  Arguments:\n  - sequence: A vector of integers.\n\n  Returns:\n  - The length of the longest non-decreasing subsequence in the given sequence.\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "sq": "Llogarit gjatësinë e nënvargut më të gjatë jo-zbritës në një varg të dhënë numrash.\n\n  Funksioni merr një vektor të numrave të plotë dhe kthen gjatësinë e nënvargut më të gjatë ku secili element nuk është më i vogël se ai i mëparshmi.\n\n  Argumentet:\n  - sequence: Një vektor i numrave të plotë.\n\n  Kthen:\n  - Gjatësia e nënvargut më të gjatë jo-zbritës në vargun e dhënë.\n\n  Shembuj:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) kthen 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) kthen 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) kthen 4",
      "hy": "Հաշվում է տրված թվերի հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը։\n\nՖունկցիան ընդունում է ամբողջ թվերի վեկտոր և վերադարձնում է ամենաերկար ենթահաջորդականության երկարությունը, որտեղ յուրաքանչյուր տարր չի փոքրանում նախորդից։\n\nԱրգումենտներ:\n- sequence: Ամբողջ թվերի վեկտոր։\n\nՎերադարձնում է:\n- Տրված հաջորդականության ամենաերկար չնվազող ենթահաջորդականության երկարությունը։\n\nՕրինակներ:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) վերադարձնում է 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) վերադարձնում է 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) վերադարձնում է 4",
      "bn": "প্রদত্ত সংখ্যার সিকোয়েন্সের মধ্যে দীর্ঘতম অ-হ্রাসমান উপসিকোয়েন্সের দৈর্ঘ্য গণনা করে।\n  \n  ফাংশনটি পূর্ণসংখ্যার একটি ভেক্টর গ্রহণ করে এবং দীর্ঘতম উপধারাটির দৈর্ঘ্য প্রদান করে যেখানে প্রতিটি উপাদান পূর্ববর্তীটির চেয়ে কম নয়।\n\n  Arguments:\n  - sequence: পূর্ণসংখ্যার একটি ভেক্টর।\n\n  Returns:\n  - প্রদত্ত ক্রমের দীর্ঘতম অ-হ্রাসকারী উপধারাটির দৈর্ঘ্য।\n\n  Examples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "bg": "Изчислява дължината на най-дългата ненамаляваща подредица в дадена последователност от числа.\n\nФункцията приема вектор от цели числа и връща дължината на най-дългата подредица, в която всеки елемент не е по-малък от предходния.\n\nАргументи:\n- sequence: Вектор от цели числа.\n\nВръща:\n- Дължината на най-дългата ненамаляваща подредица в дадената последователност.\n\nПримери:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) връща 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) връща 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) връща 4",
      "zh": "计算给定数字序列中最长非递减子序列的长度。\n\n该函数接受一个整数向量，并返回最长子序列的长度，其中每个元素都不小于前一个元素。\n\n参数：\n- sequence: 一个整数向量。\n\n返回：\n- 给定序列中最长非递减子序列的长度。\n\n示例：\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 返回 3\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 返回 3\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 返回 4",
      "fr": "Calcule la longueur de la plus longue sous-séquence non décroissante dans une séquence donnée de nombres.\n\n  La fonction prend un vecteur d'entiers et renvoie la longueur de la plus longue sous-séquence où chaque élément n'est pas inférieur au précédent.\n\n  Arguments:\n  - sequence: Un vecteur d'entiers.\n\n  Renvoie:\n  - La longueur de la plus longue sous-séquence non décroissante dans la séquence donnée.\n\n  Exemples:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) renvoie 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) renvoie 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) renvoie 4",
      "de": "Berechnet die Länge der längsten nicht abnehmenden Teilfolge in einer gegebenen Zahlenfolge.\n\nDie Funktion nimmt einen Vektor von ganzen Zahlen und gibt die Länge der längsten Teilfolge zurück, bei der jedes Element nicht kleiner als das vorherige ist.\n\nArgumente:\n- sequence: Ein Vektor von ganzen Zahlen.\n\nRückgabewerte:\n- Die Länge der längsten nicht abnehmenden Teilfolge in der gegebenen Folge.\n\nBeispiele:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) gibt 3 zurück\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) gibt 3 zurück\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) gibt 4 zurück",
      "ha": "Lissafin tsawon mafi tsawo wanda ba ya raguwa a cikin jerin lambobi da aka bayar.\n\n  Aikin yana ɗaukar wata vector na lambobi kuma yana mayar da tsawon mafi tsawo subsequence inda kowane abu ba ya raguwa daga wanda ya gabace shi.\n\n  Huɗɗa:\n  - sequence: Wata vector na lambobi.\n\n  Mayarwa:\n  - Tsawon mafi tsawo subsequence wanda ba ya raguwa a cikin jerin da aka bayar.\n\n  Misalai:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) returns 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) returns 4",
      "hi": "गणना करता है कि संख्याओं के दिए गए अनुक्रम में सबसे लंबा गैर-घटता उप-अनुक्रम कितना लंबा है।\n\nयह फ़ंक्शन पूर्णांकों के एक वेक्टर को लेता है और सबसे लंबे उप-अनुक्रम की लंबाई लौटाता है जहाँ प्रत्येक तत्व पिछले तत्व से कम नहीं होता।\n\nआर्गुमेंट्स:\n- sequence: पूर्णांकों का एक वेक्टर।\n\nरिटर्न्स:\n- दिए गए अनुक्रम में सबसे लंबे गैर-घटता उप-अनुक्रम की लंबाई।\n\nउदाहरण:\n- longest_non_decreasing_subsequence_length(vec![1, 2, 3]) 3 लौटाता है\n- longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) 3 लौटाता है\n- longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) 4 लौटाता है",
      "hu": "Kiszámítja a leghosszabb nem csökkenő részszekvencia hosszát egy adott számokból álló sorozatban.\n\n  A függvény egy egész számokat tartalmazó vektort vesz át, és visszaadja a leghosszabb részszekvencia hosszát, ahol minden elem nem kisebb, mint az előző.\n\n  Argumentumok:\n  - sequence: Egy egész számokat tartalmazó vektor.\n\n  Visszatérési érték:\n  - A leghosszabb nem csökkenő részszekvencia hossza az adott sorozatban.\n\n  Példák:\n  - longest_non_decreasing_subsequence_length(vec![1, 2, 3]) visszaadja 3\n  - longest_non_decreasing_subsequence_length(vec![4, 10, 4, 3, 8, 9]) visszaadja 3\n  - longest_non_decreasing_subsequence_length(vec![6, 1, 5, 2, 3, 4]) visszaadja 4"
    },
    "docstring_bertscore": {
      "sq": "0.9964731189543445",
      "hy": "0.9809777642994318",
      "bn": "0.9969099071622403",
      "bg": "0.99206352449537",
      "zh": "0.9871011416859754",
      "fr": "0.9981535319778997",
      "de": "0.9924427098927656",
      "ha": "0.9741941395263284",
      "hi": "0.9967730508297072",
      "hu": "0.9907831530592192"
    }
  },
  {
    "task_id": "Rust/44",
    "prompt": {
      "en": "/*\n  Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "sq": "/*\n  Numëron numrin e çifteve të studentëve, notat e të cilëve në secilin lëndë (Kinezisht, Matematikë, Anglisht) ndryshojnë me jo më shumë se 5 pikë, dhe ndryshimi i totalit të pikëve është jo më shumë se 10 pikë. Të tilla çifte konsiderohen \"të barabarta\".\n\n  Argumentet:\n  - scores: Një vektor tuplesh, secili që përmban tre numra të plotë që përfaqësojnë notat e një studenti në Kinezisht, Matematikë dhe Anglisht, respektivisht.\n\n  Kthen:\n  - Një numër të plotë që përfaqëson numrin e çifteve të studentëve \"të barabarta\".\n\n  Shembull:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) kthen 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "hy": "/*\n  Հաշվում է ուսանողների այն զույգերի քանակը, որոնց միավորները յուրաքանչյուր առարկայում (չինարեն, մաթեմատիկա, անգլերեն) տարբերվում են ոչ ավելի, քան 5 միավորով, և որոնց ընդհանուր միավորների տարբերությունը ոչ ավելի է, քան 10 միավոր: Նման զույգերը համարվում են \"հավասարապես համընկնող\":\n\n  Արգումենտներ:\n  - scores: Վեկտոր, որը պարունակում է երեք ամբողջ թվերից բաղկացած տուփեր, որոնք ներկայացնում են ուսանողի միավորները չինարենում, մաթեմատիկայում և անգլերենում համապատասխանաբար:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է \"հավասարապես համընկնող\" ուսանողների զույգերի քանակը:\n\n  Օրինակ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) վերադարձնում է 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "bn": "/*\n  ছাত্রদের জোড়ার সংখ্যা গণনা করে যাদের প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ পয়েন্টের বেশি নয়, এবং যাদের মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি নয়। এমন জোড়াগুলিকে \"সমানভাবে মেলানো\" বলে বিবেচনা করা হয়।\n\n  আর্গুমেন্টসমূহ:\n  - scores: একটি টুপলের ভেক্টর, প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা একজন ছাত্রের চীনা, গণিত এবং ইংরেজিতে স্কোর উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা \"সমানভাবে মেলানো\" ছাত্রদের জোড়ার সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 রিটার্ন করে\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "bg": "/*\n  Брои броя на двойките ученици, чиито оценки по всеки предмет (Китайски, Математика, Английски) се различават с не повече от 5 точки, и чиято разлика в общия резултат е не повече от 10 точки. Такива двойки се считат за \"равностойни\".\n\n  Аргументи:\n  - scores: Вектор от кортежи, всеки съдържащ три цели числа, представляващи оценките на ученик по Китайски, Математика и Английски, съответно.\n\n  Връща:\n  - Цяло число, представляващо броя на \"равностойните\" двойки ученици.\n\n  Пример:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) връща 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "zh": "/*\n  计算每对学生在每门学科（语文、数学、英语）上的分数差不超过5分，且总分差不超过10分的学生对数。这样的对被认为是“实力相当”。\n\n  参数:\n  - scores: 一个元组的向量，每个元组包含三个整数，分别代表一个学生在语文、数学和英语中的分数。\n\n  返回:\n  - 一个整数，表示“实力相当”的学生对数。\n\n  示例:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 返回 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "fr": "/*\n  Compte le nombre de paires d'étudiants dont les scores dans chaque matière (Chinois, Mathématiques, Anglais) diffèrent de pas plus de 5 points, et dont la différence de score total est de pas plus de 10 points. De telles paires sont considérées comme \"également assorties\".\n\n  Arguments:\n  - scores: Un vecteur de tuples, chacun contenant trois entiers représentant les scores d'un étudiant en Chinois, Mathématiques et Anglais, respectivement.\n\n  Retourne:\n  - Un entier représentant le nombre de paires d'étudiants \"également assorties\".\n\n  Exemple:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) retourne 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "de": "/*\n  Zählt die Anzahl der Schülerpaare, deren Punktzahlen in jedem Fach (Chinesisch, Mathematik, Englisch) sich um nicht mehr als 5 Punkte unterscheiden und deren Gesamtnotenunterschied nicht mehr als 10 Punkte beträgt. Solche Paare werden als \"gleichwertig\" betrachtet.\n\n  Argumente:\n  - scores: Ein Vektor von Tupeln, die jeweils drei ganze Zahlen enthalten, die die Punktzahlen eines Schülers in Chinesisch, Mathematik und Englisch darstellen.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Anzahl der \"gleichwertigen\" Schülerpaare darstellt.\n\n  Beispiel:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) gibt 2 zurück\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "ha": "/*\n  Yana ƙididdige yawan ma'aurata ɗalibai waɗanda maki nasu a kowace darasi (Sinanci, Lissafi, Turanci) ba su bambanta da fiye da maki 5 ba, kuma bambancin jimlar maki nasu ba ya wuce maki 10. Ana ɗaukar irin waɗannan ma'aurata a matsayin \"daidai gwargwado\".\n\n  Huɗɗa:\n  - scores: Wani vector na tuples, kowanne yana ɗauke da lambobi uku waɗanda ke wakiltar maki na ɗalibi a Sinanci, Lissafi, da Turanci, bi da bi.\n\n  Mayarwa:\n  - Wani lamba wanda ke wakiltar yawan ma'aurata ɗalibai \"daidai gwargwado\".\n\n  Misali:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32",
      "hi": "/*\n  उन छात्र जोड़ों की संख्या गिनता है जिनके प्रत्येक विषय (चीनी, गणित, अंग्रेजी) में अंक 5 अंकों से अधिक नहीं भिन्न होते हैं, और जिनके कुल अंकों का अंतर 10 अंकों से अधिक नहीं होता है। ऐसे जोड़ों को \"समान रूप से मेल खाते\" माना जाता है।\n\n  तर्क:\n  - scores: ट्यूपल का एक वेक्टर, प्रत्येक में तीन पूर्णांक होते हैं जो क्रमशः चीनी, गणित, और अंग्रेजी में एक छात्र के अंक दर्शाते हैं।\n\n  प्रत्यावर्तन:\n  - एक पूर्णांक जो \"समान रूप से मेल खाते\" छात्र जोड़ों की संख्या दर्शाता है।\n\n  उदाहरण:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 लौटाता है\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32 ",
      "hu": "/*\n  Megszámolja azon diákpárok számát, akiknek az egyes tantárgyakban (kínai, matematika, angol) elért pontszámai legfeljebb 5 ponttal különböznek, és akiknek az összpontszám különbsége legfeljebb 10 pont. Az ilyen párokat \"egyenlően illeszkedőnek\" tekintjük.\n\n  Argumentumok:\n  - scores: Egy vektor, amely tuple-öket tartalmaz, mindegyik három egész számot tartalmaz, amelyek egy diák kínai, matematika és angol pontszámait képviselik.\n\n  Visszatér:\n  - Egy egész szám, amely az \"egyenlően illeszkedő\" diákpárok számát jelenti.\n\n  Példa:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) visszatér 2\n*/\n\nfn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32"
    },
    "prompt_bertscore": {
      "sq": "0.9684491530156563",
      "hy": "0.9793497896964699",
      "bn": "0.9692961129603891",
      "bg": "0.9687097560755741",
      "zh": "0.9348575774965602",
      "fr": "0.9968711742379385",
      "de": "0.9663583696248831",
      "ha": "0.9394785146809558",
      "hi": "0.9795651050295118",
      "hu": "0.986273448888203"
    },
    "canonical_solution": "{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}",
    "instruction": {
      "en": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\n请使用不超过500个字符的中文，为以下Rust代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32\n{\n    let mut count = 0;\n    for i in 0..scores.len() {\n        for j in (i + 1)..scores.len() {\n            let (score_i, score_j) = (&scores[i], &scores[j]);\n            let subject_diff_ok = (score_i.0 - score_j.0).abs() <= 5\n                && (score_i.1 - score_j.1).abs() <= 5\n                && (score_i.2 - score_j.2).abs() <= 5;\n            let total_diff_ok = (score_i.0 + score_i.1 + score_i.2 - score_j.0 - score_j.1 - score_j.2).abs() <= 10;\n\n            if subject_diff_ok && total_diff_ok {\n                count += 1;\n            }\n        }\n    }\n    count\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9423368058640478",
      "bn": "0.8772950889637926",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9374544710982102",
      "ha": "0.9412908182775181",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]), 2);\n        assert_eq!(count_comparable_pairs(vec![(100, 100, 100), (95, 95, 95), (90, 90, 90)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 85, 80), (80, 85, 90), (70, 75, 80)]), 0);\n        assert_eq!(count_comparable_pairs(vec![(90, 90, 90)]), 0);\n    }\n    \n\n}",
    "entry_point": "count_comparable_pairs",
    "signature": "fn count_comparable_pairs(scores: Vec<(i32, i32, i32)>) -> i32",
    "docstring": {
      "en": "Counts the number of student pairs whose scores in each subject (Chinese, Mathematics, English) differ by no more than 5 points, and whose total score difference is no more than 10 points. Such pairs are considered \"equally matched\".\n\n  Arguments:\n  - scores: A vector of tuples, each containing three integers representing the scores of a student in Chinese, Mathematics, and English, respectively.\n\n  Returns:\n  - An integer representing the number of \"equally matched\" student pairs.\n\n  Example:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "sq": "Numëron numrin e çifteve të studentëve, notat e të cilëve në secilin lëndë (Kinezisht, Matematikë, Anglisht) ndryshojnë me jo më shumë se 5 pikë, dhe ndryshimi i totalit të pikëve është jo më shumë se 10 pikë. Të tilla çifte konsiderohen \"të barabarta\".\n\nArguments:\n- scores: Një vektor tuplesh, secili që përmban tre numra të plotë që përfaqësojnë notat e një studenti në Kinezisht, Matematikë dhe Anglisht, përkatësisht.\n\nReturns:\n- Një numër i plotë që përfaqëson numrin e çifteve të studentëve \"të barabarta\".\n\nExample:\n- count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "hy": "Հաշվում է այն ուսանողական զույգերի քանակը, որոնցից յուրաքանչյուր առարկայի (չինարեն, մաթեմատիկա, անգլերեն) միավորները տարբերվում են ոչ ավելի, քան 5 միավորով, և որոնց ընդհանուր միավորների տարբերությունը ոչ ավելի է, քան 10 միավոր: Նման զույգերը համարվում են \"հավասարապես համընկնող\":\n\n  Արգումենտներ:\n  - scores: Վեկտոր, որը պարունակում է եռյակներ, որոնցից յուրաքանչյուրը ներկայացնում է ուսանողի միավորները չինարենում, մաթեմատիկայում և անգլերենում, համապատասխանաբար:\n\n  Վերադարձնում է:\n  - Ամբողջ թիվ, որը ներկայացնում է \"հավասարապես համընկնող\" ուսանողական զույգերի քանակը:\n\n  Օրինակ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) վերադարձնում է 2",
      "bn": "প্রত্যেক বিষয়ে (চীনা, গণিত, ইংরেজি) ছাত্রদের স্কোরের মধ্যে পার্থক্য ৫ পয়েন্টের বেশি নয় এবং মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি নয় এমন ছাত্র জোড়ার সংখ্যা গণনা করে। এমন জোড়াগুলিকে \"সমানভাবে মেলানো\" বলে বিবেচনা করা হয়।\n\n  আর্গুমেন্টস:\n  - scores: একটি টুপলের ভেক্টর, প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা যথাক্রমে চীনা, গণিত এবং ইংরেজিতে একজন ছাত্রের স্কোর উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি পূর্ণসংখ্যা যা \"সমানভাবে মেলানো\" ছাত্র জোড়ার সংখ্যা উপস্থাপন করে।\n\n  উদাহরণ:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 রিটার্ন করে।",
      "bg": "Брои броя на двойките ученици, чиито резултати по всеки предмет (Китайски, Математика, Английски) се различават с не повече от 5 точки, и чиято разлика в общия резултат е не повече от 10 точки. Такива двойки се считат за \"равностойни\".\n\n  Аргументи:\n  - scores: Вектор от кортежи, всеки съдържащ три цели числа, представляващи резултатите на ученик по Китайски, Математика и Английски, съответно.\n\n  Връща:\n  - Цяло число, представляващо броя на \"равностойните\" двойки ученици.\n\n  Пример:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) връща 2",
      "zh": "计算每对学生在每个科目（语文、数学、英语）中的分数差不超过5分，并且总分差不超过10分的数量。这样的对被认为是“匹配相等”。\n\n  参数:\n  - scores: 一个元组向量，每个元组包含三个整数，分别代表一个学生在语文、数学和英语中的分数。\n\n  返回:\n  - 一个整数，表示“匹配相等”的学生对的数量。\n\n  示例:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 返回 2",
      "fr": "Compte le nombre de paires d'étudiants dont les scores dans chaque matière (Chinois, Mathématiques, Anglais) diffèrent de pas plus de 5 points, et dont la différence de score total est de pas plus de 10 points. De telles paires sont considérées comme \"également assorties\".\n\n  Arguments:\n  - scores: Un vecteur de tuples, chacun contenant trois entiers représentant les scores d'un étudiant en Chinois, Mathématiques et Anglais, respectivement.\n\n  Retourne:\n  - Un entier représentant le nombre de paires d'étudiants \"également assorties\".\n\n  Exemple:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) retourne 2",
      "de": "Zählt die Anzahl der Schülerpaare, deren Punktzahlen in jedem Fach (Chinesisch, Mathematik, Englisch) um nicht mehr als 5 Punkte differieren und deren Gesamtpunktzahlunterschied nicht mehr als 10 Punkte beträgt. Solche Paare werden als \"gleichwertig\" betrachtet.\n\n  Argumente:\n  - scores: Ein Vektor von Tupeln, die jeweils drei ganze Zahlen enthalten, die die Punktzahlen eines Schülers in Chinesisch, Mathematik und Englisch darstellen.\n\n  Rückgabewert:\n  - Eine ganze Zahl, die die Anzahl der \"gleichwertigen\" Schülerpaare darstellt.\n\n  Beispiel:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) gibt 2 zurück",
      "ha": "Yana ƙirga yawan ma'aurata ɗalibai waɗanda maki nasu a kowace darasi (Sinanci, Lissafi, Turanci) ba su bambanta da fiye da maki 5 ba, kuma bambancin jimillar maki nasu ba ya wuce maki 10. Ana ɗaukar irin waɗannan ma'auratan a matsayin \"daidai gwargwado\".\n\n  Huɗɗa:\n  - scores: Wata vector na tuples, kowanne yana ɗauke da lambobi guda uku da ke wakiltar maki na ɗalibi a cikin Sinanci, Lissafi, da Turanci, bi da bi.\n\n  Komawa:\n  - Wani lamba da ke wakiltar adadin \"daidaitattun\" ma'aurata ɗalibai.\n\n  Misali:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) returns 2",
      "hi": "प्रत्येक विषय (चीनी, गणित, अंग्रेजी) में जिन छात्र जोड़ों के अंकों में अंतर 5 अंकों से अधिक नहीं है, और जिनके कुल अंक का अंतर 10 अंकों से अधिक नहीं है, उनकी संख्या गिनता है। ऐसे जोड़े \"समान रूप से मेल खाते\" माने जाते हैं।\n\n  तर्क:\n  - scores: ट्यूपल का एक वेक्टर, जिसमें प्रत्येक ट्यूपल तीन पूर्णांक शामिल करता है जो क्रमशः चीनी, गणित, और अंग्रेजी में एक छात्र के अंक का प्रतिनिधित्व करते हैं।\n\n  वापसी:\n  - एक पूर्णांक जो \"समान रूप से मेल खाते\" छात्र जोड़ों की संख्या का प्रतिनिधित्व करता है।\n\n  उदाहरण:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) 2 लौटाता है।",
      "hu": "Számolja meg azon diákpárok számát, akiknek az egyes tantárgyakban (kínai, matematika, angol) elért pontszámai legfeljebb 5 ponttal térnek el egymástól, és akiknek az összpontszám-különbsége legfeljebb 10 pont. Az ilyen párok \"egyenlően illeszkedőnek\" tekinthetők.\n\n  Argumentumok:\n  - scores: Egy vektor, amely tuple-öket tartalmaz, mindegyik három egész számot tartalmaz, amelyek egy diák kínai, matematika és angol pontszámait képviselik.\n\n  Visszatér:\n  - Egy egész szám, amely az \"egyenlően illeszkedő\" diákpárok számát jelenti.\n\n  Példa:\n  - count_comparable_pairs(vec![(90, 90, 90), (85, 95, 90), (80, 100, 91)]) visszatér 2"
    },
    "docstring_bertscore": {
      "sq": "0.958916682399411",
      "hy": "0.9800497631592369",
      "bn": "0.9450103707927774",
      "bg": "0.9675982204633028",
      "zh": "0.9167492401791335",
      "fr": "0.9679023235766673",
      "de": "0.958774661676971",
      "ha": "0.9708317244361698",
      "hi": "0.9727040144078046",
      "hu": "0.9804202088198669"
    }
  },
  {
    "task_id": "Rust/45",
    "prompt": {
      "en": "/*\n  Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "sq": "/*\n  Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur parasysh një sasi fillestare dhe një normë konvertimi të bishtave të cigareve në cigare të reja.\n\n  Argumentet:\n  - initial_cigarettes: Numri fillestar i cigareve që Pjetri ka.\n  - butts_for_new: Numri i bishtave të cigareve të kërkuara për të shkëmbyer për një cigare të re.\n\n  Kthen:\n  - Numri total i cigareve që Pjetri mund të pijë duke përfshirë ato të marra duke shkëmbyer bishtat për të reja.\n\n  Shembull:\n  - total_smoked_cigarettes(4, 3) kthen 5\n  - total_smoked_cigarettes(10, 3) kthen 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "hy": "/*\n  Հաշվում է ընդհանուր ծխախոտների քանակը, որ Պետերը կարող է ծխել տրված սկզբնական քանակով և ծխախոտի մնացորդների փոխանակման հարաբերակցությամբ:\n\n  Արգումենտներ:\n  - initial_cigarettes: Սկզբնական ծխախոտների քանակը, որ Պետերը ունի:\n  - butts_for_new: Ծխախոտի մնացորդների քանակը, որը պահանջվում է մեկ նոր ծխախոտի փոխանակման համար:\n\n  Վերադարձնում է:\n  - Ընդհանուր ծխախոտների քանակը, որ Պետերը կարող է ծխել, ներառյալ այն ծխախոտները, որոնք ստացվում են մնացորդների փոխանակմամբ:\n\n  Օրինակ:\n  - total_smoked_cigarettes(4, 3) վերադարձնում է 5\n  - total_smoked_cigarettes(10, 3) վերադարձնում է 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
      "bn": "/*\n  পিটার কতগুলি সিগারেট খেতে পারবে তা গণনা করে, একটি প্রাথমিক পরিমাণ এবং সিগারেটের অবশিষ্টাংশকে নতুন সিগারেটে রূপান্তর করার হার দেওয়া হলে।\n\n  আর্গুমেন্ট:\n  - initial_cigarettes: পিটারের কাছে থাকা প্রাথমিক সিগারেটের সংখ্যা।\n  - butts_for_new: একটি নতুন সিগারেটের জন্য বিনিময় করতে প্রয়োজনীয় সিগারেটের অবশিষ্টাংশের সংখ্যা।\n\n  রিটার্ন করে:\n  - পিটার মোট কতগুলি সিগারেট খেতে পারবে, তার মধ্যে অবশিষ্টাংশ বিনিময় করে পাওয়া নতুন সিগারেটও অন্তর্ভুক্ত।\n\n  উদাহরণ:\n  - total_smoked_cigarettes(4, 3) 5 রিটার্ন করে\n  - total_smoked_cigarettes(10, 3) 14 রিটার্ন করে\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "bg": "/*\n  Изчислява общия брой цигари, които Петър може да изпуши, като се даде начално количество и курс на обмен на фасове за нови цигари.\n\n  Аргументи:\n  - initial_cigarettes: Началният брой цигари, които Петър има.\n  - butts_for_new: Броят на фасовете, необходими за обмен за една нова цигара.\n\n  Връща:\n  - Общият брой цигари, които Петър може да изпуши, включително тези, получени чрез обмен на фасове за нови.\n\n  Пример:\n  - total_smoked_cigarettes(4, 3) връща 5\n  - total_smoked_cigarettes(10, 3) връща 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "zh": "/*\n  计算彼得可以抽的香烟总数，给定初始数量和烟蒂换新香烟的转换率。\n\n  参数:\n  - initial_cigarettes: 彼得拥有的初始香烟数量。\n  - butts_for_new: 需要多少个烟蒂才能兑换一支新香烟。\n\n  返回:\n  - 彼得可以抽的香烟总数，包括通过交换烟蒂获得的新香烟。\n\n  示例:\n  - total_smoked_cigarettes(4, 3) 返回 5\n  - total_smoked_cigarettes(10, 3) 返回 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "fr": "/*\n  Calcule le nombre total de cigarettes que Peter peut fumer étant donné une quantité initiale et un taux de conversion de mégots de cigarettes en nouvelles cigarettes.\n\n  Arguments:\n  - initial_cigarettes: Le nombre initial de cigarettes que Peter a.\n  - butts_for_new: Le nombre de mégots de cigarettes requis pour échanger contre une nouvelle cigarette.\n\n  Retourne:\n  - Le nombre total de cigarettes que Peter peut fumer, y compris celles obtenues en échangeant des mégots contre de nouvelles.\n\n  Exemple:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "de": "/*\n  Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, basierend auf einer anfänglichen Menge und einer Umtauschrate von Zigarettenstummeln zu neuen Zigaretten.\n\n  Argumente:\n  - initial_cigarettes: Die anfängliche Anzahl der Zigaretten, die Peter hat.\n  - butts_for_new: Die Anzahl der Zigarettenstummel, die erforderlich sind, um sie gegen eine neue Zigarette einzutauschen.\n\n  Rückgabewert:\n  - Die Gesamtanzahl der Zigaretten, die Peter rauchen kann, einschließlich derjenigen, die durch den Umtausch von Stummeln gegen neue Zigaretten erhalten werden.\n\n  Beispiel:\n  - total_smoked_cigarettes(4, 3) gibt 5 zurück\n  - total_smoked_cigarettes(10, 3) gibt 14 zurück\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "ha": "/*\n  Lissafin adadin sigari da duka Peter zai iya sha la'akari da adadin farko da kuma yawan bututun sigari da ake bukata don musayar sabbin sigari.\n\n  Huɗɗa:\n  - initial_cigarettes: Adadin sigari na farko da Peter ke da shi.\n  - butts_for_new: Yawan bututun sigari da ake bukata don musayar sabuwar sigari guda ɗaya.\n\n  Komawa:\n  - Jimillar adadin sigari da Peter zai iya sha ciki har da waɗanda aka samu ta hanyar musayar bututun don sabbin sigari.\n\n  Misali:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "hi": "/*\n  यह गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है, दिए गए प्रारंभिक मात्रा और सिगरेट के बट्स को नई सिगरेट में बदलने की दर के आधार पर।\n\n  तर्क:\n  - initial_cigarettes: प्रारंभिक संख्या सिगरेट जो पीटर के पास है।\n  - butts_for_new: एक नई सिगरेट के लिए विनिमय करने के लिए आवश्यक सिगरेट बट्स की संख्या।\n\n  वापसी:\n  - कुल सिगरेट की संख्या जो पीटर पी सकता है, जिसमें वे भी शामिल हैं जो बट्स को नई सिगरेट में बदलकर प्राप्त की जाती हैं।\n\n  उदाहरण:\n  - total_smoked_cigarettes(4, 3) 5 लौटाता है\n  - total_smoked_cigarettes(10, 3) 14 लौटाता है\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja, hogy összesen hány cigarettát tud elszívni Péter, figyelembe véve a kezdeti mennyiséget és a csikkek új cigarettára váltásának arányát.\n\n  Argumentumok:\n  - initial_cigarettes: A kezdeti cigaretták száma, amivel Péter rendelkezik.\n  - butts_for_new: Az új cigarettára cserélhető cigarettacsikkek száma.\n\n  Visszatér:\n  - Az összes cigaretta száma, amit Péter elszívhat, beleértve azokat is, amelyeket csikkek újra váltásával szerzett.\n\n  Példa:\n  - total_smoked_cigarettes(4, 3) visszaadja az 5-öt\n  - total_smoked_cigarettes(10, 3) visszaadja a 14-et\n*/\nfn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9856712015729052",
      "hy": "0.9697762025913503",
      "bn": "0.9780465757665",
      "bg": "0.9860428390158215",
      "zh": "0.9597809231872938",
      "fr": "0.9819363545183062",
      "de": "0.9726583294201666",
      "ha": "0.9666322809203302",
      "hi": "0.9500275755873376",
      "hu": "0.9567772345652842"
    },
    "canonical_solution": "{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}",
    "instruction": {
      "en": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nরাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसकी लंबाई अधिकतम 500 वर्णों की हो।",
      "hu": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32\n{\n    let mut total_smoked = initial_cigarettes;\n    let mut butts = initial_cigarettes;\n\n    while butts >= butts_for_new {\n        let new_cigarettes = butts / butts_for_new;\n        total_smoked += new_cigarettes;\n        butts = butts % butts_for_new + new_cigarettes;\n    }\n\n    total_smoked\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9154557591378343",
      "bn": "0.8851102013056104",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9665526301375352",
      "hi": "0.8958767624792254",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(total_smoked_cigarettes(4, 3), 5);\n        assert_eq!(total_smoked_cigarettes(10, 3), 14);\n        assert_eq!(total_smoked_cigarettes(1, 2), 1); // Edge case: Not enough to exchange\n        assert_eq!(total_smoked_cigarettes(100, 5), 124); // Larger numbers\n    }\n    \n\n}",
    "entry_point": "total_smoked_cigarettes",
    "signature": "fn total_smoked_cigarettes(initial_cigarettes: i32, butts_for_new: i32) -> i32",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial amount and a conversion rate of cigarette butts to new cigarettes.\n\n  Arguments:\n  - initial_cigarettes: The initial number of cigarettes Peter has.\n  - butts_for_new: The number of cigarette butts required to exchange for one new cigarette.\n\n  Returns:\n  - The total number of cigarettes Peter can smoke including those obtained by exchanging butts for new ones.\n\n  Example:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "sq": "Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur parasysh një sasi fillestare dhe një normë konvertimi të bishtave të cigareve në cigare të reja.\n\n  Argumentet:\n  - initial_cigarettes: Numri fillestar i cigareve që Pjetri ka.\n  - butts_for_new: Numri i bishtave të cigareve të nevojshëm për të shkëmbyer për një cigare të re.\n\n  Kthen:\n  - Numri total i cigareve që Pjetri mund të pijë duke përfshirë ato të marra duke shkëmbyer bishtat për të reja.\n\n  Shembull:\n  - total_smoked_cigarettes(4, 3) kthen 5\n  - total_smoked_cigarettes(10, 3) kthen 14",
      "hy": "Հաշվում է ընդհանուր սիգարետների քանակը, որը կարող է ծխել Պետերը՝ հաշվի առնելով սկզբնական քանակը և սիգարետի մնացորդները նոր սիգարետների փոխանակման փոխարժեքը:\n\n  Արգումենտներ:\n  - initial_cigarettes: Սիգարետների սկզբնական քանակը, որը ունի Պետերը:\n  - butts_for_new: Սիգարետի մնացորդների քանակը, որը պահանջվում է փոխանակելու համար մեկ նոր սիգարետի:\n\n  Վերադարձնում է:\n  - Սիգարետների ընդհանուր քանակը, որը կարող է ծխել Պետերը, ներառյալ այն սիգարետները, որոնք ստացվում են մնացորդները նորերով փոխանակելով:\n\n  Օրինակ:\n  - total_smoked_cigarettes(4, 3) վերադարձնում է 5\n  - total_smoked_cigarettes(10, 3) վերադարձնում է 14",
      "bn": "পিটার কতগুলি সিগারেট খেতে পারে তা গণনা করে, একটি প্রাথমিক পরিমাণ এবং সিগারেটের বাট থেকে নতুন সিগারেটের জন্য একটি রূপান্তর হার দেওয়া হলে।\n\n  আর্গুমেন্টসমূহ:\n  - initial_cigarettes: পিটারের কাছে থাকা প্রাথমিক সিগারেটের সংখ্যা।\n  - butts_for_new: একটি নতুন সিগারেটের জন্য বিনিময় করতে প্রয়োজনীয় সিগারেট বাটের সংখ্যা।\n\n  রিটার্নসমূহ:\n  - পিটার মোট কতগুলি সিগারেট খেতে পারে, যার মধ্যে নতুন সিগারেটের জন্য বাট বিনিময় করে প্রাপ্ত সিগারেটও অন্তর্ভুক্ত।\n\n  উদাহরণ:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид началното количество и курсът на обмяна на фасове за нови цигари.\n\n  Аргументи:\n  - initial_cigarettes: Началният брой цигари, които Петър има.\n  - butts_for_new: Броят на фасовете, необходими за обмяна за една нова цигара.\n\n  Връща:\n  - Общият брой цигари, които Петър може да изпуши, включително тези, получени чрез обмяна на фасове за нови.\n\n  Пример:\n  - total_smoked_cigarettes(4, 3) връща 5\n  - total_smoked_cigarettes(10, 3) връща 14",
      "zh": "计算彼得在给定初始数量和烟头兑换新香烟的转换率下可以抽的香烟总数。\n\n  参数：\n  - initial_cigarettes: 彼得拥有的初始香烟数量。\n  - butts_for_new: 兑换一支新香烟所需的烟头数量。\n\n  返回：\n  - 彼得可以抽的香烟总数，包括通过兑换烟头获得的新香烟。\n\n  示例：\n  - total_smoked_cigarettes(4, 3) 返回 5\n  - total_smoked_cigarettes(10, 3) 返回 14",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer étant donné une quantité initiale et un taux de conversion de mégots de cigarettes en nouvelles cigarettes.\n\n  Arguments:\n  - initial_cigarettes: Le nombre initial de cigarettes que Peter a.\n  - butts_for_new: Le nombre de mégots de cigarettes requis pour échanger contre une nouvelle cigarette.\n\n  Renvoie:\n  - Le nombre total de cigarettes que Peter peut fumer, y compris celles obtenues en échangeant des mégots contre de nouvelles.\n\n  Exemple:\n  - total_smoked_cigarettes(4, 3) renvoie 5\n  - total_smoked_cigarettes(10, 3) renvoie 14",
      "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Menge und eine Umwandlungsrate von Zigarettenstummeln zu neuen Zigaretten.\n\n  Argumente:\n  - initial_cigarettes: Die anfängliche Anzahl der Zigaretten, die Peter hat.\n  - butts_for_new: Die Anzahl der Zigarettenstummel, die benötigt werden, um sie gegen eine neue Zigarette einzutauschen.\n\n  Rückgabewert:\n  - Die Gesamtanzahl der Zigaretten, die Peter rauchen kann, einschließlich derjenigen, die durch das Eintauschen von Stummeln gegen neue erhalten werden.\n\n  Beispiel:\n  - total_smoked_cigarettes(4, 3) gibt 5 zurück\n  - total_smoked_cigarettes(10, 3) gibt 14 zurück",
      "ha": "Lissafa adadin sigari da Peter zai iya sha la'akari da adadin farko da kuma yawan bututun sigari da ake bukata don musayar sabbin sigari.\n\n  Huɗa:\n  - initial_cigarettes: Adadin sigari na farko da Peter ke da shi.\n  - butts_for_new: Adadin bututun sigari da ake buƙata don musanya da sabon sigari.\n\n  Komawa:\n  - Jimillar adadin sigari da Peter zai iya sha ciki har da waɗanda aka samu ta hanyar musanya bututun da sababbi.\n\n  Misali:\n  - total_smoked_cigarettes(4, 3) returns 5\n  - total_smoked_cigarettes(10, 3) returns 14",
      "hi": "सिगरेट की कुल संख्या की गणना करता है जो पीटर धूम्रपान कर सकता है, दिए गए प्रारंभिक मात्रा और सिगरेट बट्स को नई सिगरेट में बदलने की दर के आधार पर।\n\n  तर्क:\n  - initial_cigarettes: प्रारंभिक सिगरेट की संख्या जो पीटर के पास है।\n  - butts_for_new: एक नई सिगरेट के लिए विनिमय करने के लिए आवश्यक सिगरेट बट्स की संख्या।\n\n  लौटाता है:\n  - सिगरेट की कुल संख्या जो पीटर धूम्रपान कर सकता है, जिसमें बट्स को नई सिगरेट में बदलकर प्राप्त की गई सिगरेट भी शामिल हैं।\n\n  उदाहरण:\n  - total_smoked_cigarettes(4, 3) 5 लौटाता है\n  - total_smoked_cigarettes(10, 3) 14 लौटाता है",
      "hu": "Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni adott kezdeti mennyiség és a cigarettacsikkek új cigarettára váltásának aránya alapján.\n\n  Argumentumok:\n  - initial_cigarettes: A kezdeti cigaretták száma, amivel Péter rendelkezik.\n  - butts_for_new: Az új cigarettára cserélendő cigarettacsikkek száma.\n\n  Visszatér:\n  - Az összes cigaretta száma, amit Péter el tud szívni, beleértve azokat is, amelyeket csikkek újra cserélésével szerzett.\n\n  Példa:\n  - total_smoked_cigarettes(4, 3) visszaadja 5\n  - total_smoked_cigarettes(10, 3) visszaadja 14"
    },
    "docstring_bertscore": {
      "sq": "0.9820692382432186",
      "hy": "0.965418649292207",
      "bn": "0.9618472750411997",
      "bg": "0.9799504479687194",
      "zh": "0.9553161094823915",
      "fr": "0.9795670913333221",
      "de": "0.9693835103280444",
      "ha": "0.9811366686042597",
      "hi": "0.9548256910716164",
      "hu": "0.9837371375527685"
    }
  },
  {
    "task_id": "Rust/46",
    "prompt": {
      "en": "/*\n  Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "sq": "/*\n  Gjen gjatësinë e sekuencës më të gjatë radhore në vargun e dhënë të numrave.\n  Një sekuencë radhore përcaktohet si një sekuencë e numrave të plotë ku çdo numër ndjek atë të mëparshmin me saktësisht një.\n  Kjo funksion nuk kërkon që vargu hyrës të jetë i renditur.\n\n  Argumentet:\n  - numbers: Një segment i numrave të plotë që përfaqëson sekuencën.\n\n  Kthen:\n  - Gjatësinë e sekuencës më të gjatë radhore të gjetur në varg.\n\n  Shembull:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) kthen 4 (sepse sekuenca më e gjatë radhore është 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) kthen 5 (sepse sekuenca është 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) kthen 4 (sepse sekuenca është 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "hy": "/*\n  Գտնում է ամենաերկար հաջորդական հաջորդականության երկարությունը տրված թվերի զանգվածում:\n  Հաջորդական հաջորդականությունը սահմանվում է որպես ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր թիվ հաջորդում է նախորդին ճիշտ մեկով:\n  Այս ֆունկցիան չի պահանջում, որ մուտքային զանգվածը դասավորված լինի:\n\n  Արգումենտներ:\n  - numbers: Integer-ների հատված, որը ներկայացնում է հաջորդականությունը:\n\n  Վերադարձնում է:\n  - Ամենաերկար հաջորդական հաջորդականության երկարությունը, որը գտնվել է զանգվածում:\n\n  Օրինակ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) վերադարձնում է 4 (քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) վերադարձնում է 5 (քանի որ հաջորդականությունը 1, 2, 3, 4, 5 է)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) վերադարձնում է 4 (քանի որ հաջորդականությունը 1, 2, 3, 4 է)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize",
      "bn": "/*\n  প্রদত্ত সংখ্যার অ্যারেতে সবচেয়ে দীর্ঘ ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n  ধারাবাহিক ক্রমকে এমন একটি পূর্ণসংখ্যার ক্রম হিসাবে সংজ্ঞায়িত করা হয় যেখানে প্রতিটি সংখ্যা পূর্ববর্তী সংখ্যার ঠিক এক দ্বারা অনুসরণ করে।\n  এই ফাংশনটি ইনপুট অ্যারেকে সাজানো প্রয়োজন হয় না।\n\n  আর্গুমেন্টসমূহ:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস যা ক্রমকে উপস্থাপন করে।\n\n  রিটার্নস:\n  - অ্যারেতে পাওয়া সবচেয়ে দীর্ঘ ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\n  উদাহরণ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 রিটার্ন করে (কারণ সবচেয়ে দীর্ঘ ধারাবাহিক ক্রম হল 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 রিটার্ন করে (কারণ ক্রমটি হল 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 রিটার্ন করে (কারণ ক্রমটি হল 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "bg": "/*\n  Намира дължината на най-дългата последователна поредица в дадения масив от числа.\n  Последователна поредица се дефинира като поредица от цели числа, където всяко число следва предходното с точно едно.\n  Тази функция не изисква входният масив да бъде сортиран.\n\n  Аргументи:\n  - numbers: Срез от цели числа, представляващ поредицата.\n\n  Връща:\n  - Дължината на най-дългата последователна поредица, намерена в масива.\n\n  Пример:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) връща 4 (защото най-дългата последователна поредица е 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) връща 5 (защото поредицата е 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) връща 4 (защото поредицата е 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "zh": "/*\n  查找给定数字数组中最长连续序列的长度。\n  连续序列被定义为每个数字紧跟前一个数字增加一的整数序列。\n  此函数不要求输入数组是排序的。\n\n  参数:\n  - numbers: 表示序列的整数切片。\n\n  返回:\n  - 数组中找到的最长连续序列的长度。\n\n  示例:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 返回 4 (因为最长的连续序列是 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 返回 5 (因为序列是 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 返回 4 (因为序列是 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "fr": "/*\n  Trouve la longueur de la plus longue séquence consécutive dans le tableau de nombres donné.\n  Une séquence consécutive est définie comme une séquence d'entiers où chaque nombre suit le précédent par exactement un.\n  Cette fonction ne nécessite pas que le tableau d'entrée soit trié.\n\n  Arguments:\n  - numbers: Une tranche d'entiers représentant la séquence.\n\n  Renvoie:\n  - La longueur de la plus longue séquence consécutive trouvée dans le tableau.\n\n  Exemple:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) renvoie 4 (car la plus longue séquence consécutive est 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) renvoie 5 (car la séquence est 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) renvoie 4 (car la séquence est 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "de": "/*\n  Findet die Länge der längsten aufeinanderfolgenden Sequenz im gegebenen Array von Zahlen.\n  Eine aufeinanderfolgende Sequenz ist definiert als eine Sequenz von ganzen Zahlen, bei der jede Zahl der vorherigen um genau eins folgt.\n  Diese Funktion erfordert nicht, dass das Eingabearray sortiert ist.\n\n  Argumente:\n  - numbers: Ein Slice von ganzen Zahlen, das die Sequenz darstellt.\n\n  Rückgabewerte:\n  - Die Länge der längsten aufeinanderfolgenden Sequenz, die im Array gefunden wurde.\n\n  Beispiel:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) gibt 4 zurück (weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) gibt 5 zurück (weil die Sequenz 1, 2, 3, 4, 5 ist)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) gibt 4 zurück (weil die Sequenz 1, 2, 3, 4 ist)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "ha": "/*\n  Nemi tsawon mafi dogon jere mai jere a cikin jerin lambobin da aka bayar.\n  Jere mai jere ana ayyana shi azaman jere na lambobi inda kowace lamba ke biyo bayan ta gabanta da ɗaya kawai.\n  Wannan aikin ba ya buƙatar jerin shigarwa ya zama a jere.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobi masu nuna jerin.\n\n  Komawa:\n  - Tsawon mafi dogon jere mai jere da aka samu a cikin jerin.\n\n  Misali:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) yana dawowa 4 (saboda mafi dogon jere mai jere shine 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) yana dawowa 5 (saboda jerin shine 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) yana dawowa 4 (saboda jerin shine 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "hi": "/*\n  दिए गए संख्या के array में सबसे लंबी लगातार अनुक्रम की लंबाई खोजता है।\n  एक लगातार अनुक्रम को ऐसे पूर्णांकों के अनुक्रम के रूप में परिभाषित किया जाता है जहाँ प्रत्येक संख्या ठीक एक द्वारा पिछले एक का अनुसरण करती है।\n  इस function के लिए इनपुट array को sorted होने की आवश्यकता नहीं है।\n\n  तर्क:\n  - numbers: अनुक्रम का प्रतिनिधित्व करने वाले पूर्णांकों का एक slice।\n\n  लौटाता है:\n  - array में पाए गए सबसे लंबे लगातार अनुक्रम की लंबाई।\n\n  उदाहरण:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 4 लौटाता है (क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4 है)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 5 लौटाता है (क्योंकि अनुक्रम 1, 2, 3, 4, 5 है)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 4 लौटाता है (क्योंकि अनुक्रम 1, 2, 3, 4 है)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize ",
      "hu": "/*\n  Megkeresi a leghosszabb egymást követő sorozat hosszát a megadott szám tömbben.\n  Egy egymást követő sorozat olyan egész számok sorozataként van definiálva, ahol minden szám pontosan eggyel követi az előzőt.\n  Ennek a függvénynek nem szükséges, hogy a bemeneti tömb rendezett legyen.\n\n  Argumentumok:\n  - numbers: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatérési érték:\n  - A leghosszabb egymást követő sorozat hossza, amelyet a tömbben találtunk.\n\n  Példa:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) visszatér 4 (mert a leghosszabb egymást követő sorozat 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) visszatér 5 (mert a sorozat 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) visszatér 4 (mert a sorozat 1, 2, 3, 4)\n*/\nuse std::collections::HashSet;\n\nfn longest_consecutive_sequence(numbers: &[i32]) -> usize "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.99613445415468",
      "bn": "0.999151848272981",
      "bg": "1",
      "zh": "0.9885066502621782",
      "fr": "0.9968274755541108",
      "de": "0.9956505905464791",
      "ha": "0.9687576259974034",
      "hi": "0.9926421347953246",
      "hu": "0.9943714108926144"
    },
    "canonical_solution": "{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}",
    "instruction": {
      "en": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nনিচের Rust কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简明的自然语言描述（文档字符串）。",
      "fr": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Rust a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize\n{\n    let num_set: HashSet<i32> = numbers.iter().cloned().collect();\n    let mut longest_streak = 0;\n\n    for &num in numbers {\n        if !num_set.contains(&(num - 1)) {\n            let mut current_num = num;\n            let mut current_streak = 1;\n\n            while num_set.contains(&(current_num + 1)) {\n                current_num += 1;\n                current_streak += 1;\n            }\n\n            longest_streak = longest_streak.max(current_streak);\n        }\n    }\n\n    longest_streak\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9104262392596499",
      "bn": "0.868870975873722",
      "bg": "0.8316696904400789",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.939889679569698"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]), 5);\n        assert_eq!(longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]), 4);\n        assert_eq!(longest_consecutive_sequence(&[6, 6, 2, 3, 1, 4, 5, 7]), 7);\n    }\n    \n\n}",
    "entry_point": "longest_consecutive_sequence",
    "signature": "fn longest_consecutive_sequence(numbers: &[i32]) -> usize",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in the given array of numbers.\n  A consecutive sequence is defined as a sequence of integers where each number follows the previous one by exactly one.\n  This function does not require the input array to be sorted.\n\n  Arguments:\n  - numbers: A slice of integers representing the sequence.\n\n  Returns:\n  - The length of the longest consecutive sequence found in the array.\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (because the longest consecutive sequence is 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (because the sequence is 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (because the sequence is 1, 2, 3, 4)",
      "sq": "Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në vargun e dhënë të numrave.\n  Një sekuencë radhazi përkufizohet si një sekuencë e numrave të plotë ku secili numër ndjek atë të mëparshmin me saktësisht një.\n  Kjo funksion nuk kërkon që vargu hyrës të jetë i renditur.\n\n  Argumentet:\n  - numbers: Një pjesë e numrave të plotë që përfaqëson sekuencën.\n\n  Kthen:\n  - Gjatësia e sekuencës më të gjatë radhazi të gjetur në varg.\n\n  Shembull:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) kthen 4 (sepse sekuenca më e gjatë radhazi është 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) kthen 5 (sepse sekuenca është 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) kthen 4 (sepse sekuenca është 1, 2, 3, 4)",
      "hy": "Գտնում է տրված թվերի զանգվածում ամենաերկար հաջորդական հաջորդականության երկարությունը:\n  Հաջորդական հաջորդականությունը սահմանվում է որպես ամբողջ թվերի հաջորդականություն, որտեղ յուրաքանչյուր թիվ նախորդին հաջորդում է հենց մեկով:\n  Այս ֆունկցիան չի պահանջում, որ մուտքային զանգվածը լինի տեսակավորված:\n\n  Արգումենտներ:\n  - numbers: Ամբողջ թվերի հատված, որը ներկայացնում է հաջորդականությունը:\n\n  Վերադարձնում է.\n  - Ամենաերկար հաջորդական հաջորդականության երկարությունը, որը գտնվել է զանգվածում:\n\n  Օրինակ:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) վերադարձնում է 4 (քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) վերադարձնում է 5 (քանի որ հաջորդականությունը 1, 2, 3, 4, 5 է)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) վերադարձնում է 4 (քանի որ հաջորդականությունը 1, 2, 3, 4 է)",
      "bn": "প্রদত্ত সংখ্যার অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n  একটি ক্রমাগত সিকোয়েন্স সংজ্ঞায়িত হয় এমন একটি পূর্ণসংখ্যার সিকোয়েন্স হিসাবে যেখানে প্রতিটি সংখ্যা পূর্ববর্তী সংখ্যার পর ঠিক এক দ্বারা অনুসরণ করে।\n  এই ফাংশনটি ইনপুট অ্যারেকে সাজানো প্রয়োজন হয় না।\n\n  Arguments:\n  - numbers: পূর্ণসংখ্যার একটি স্লাইস যা সিকোয়েন্সকে উপস্থাপন করে।\n\n  Returns:\n  - অ্যারেতে পাওয়া দীর্ঘতম ক্রমাগত সিকোয়েন্সের দৈর্ঘ্য।\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (কারণ দীর্ঘতম ক্রমাগত সিকোয়েন্স হল 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (কারণ সিকোয়েন্স হল 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (কারণ সিকোয়েন্স হল 1, 2, 3, 4)",
      "bg": "Намира дължината на най-дългата последователна поредица в дадения масив от числа.\n  Последователна поредица се определя като поредица от цели числа, където всяко число следва предходното с точно едно.\n  Тази функция не изисква входният масив да бъде сортиран.\n\n  Аргументи:\n  - numbers: Срез от цели числа, представляващ поредицата.\n\n  Връща:\n  - Дължината на най-дългата намерена последователна поредица в масива.\n\n  Пример:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) връща 4 (защото най-дългата последователна поредица е 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) връща 5 (защото поредицата е 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) връща 4 (защото поредицата е 1, 2, 3, 4)",
      "zh": "找到给定数字数组中最长连续序列的长度。\n  连续序列被定义为每个数字紧跟前一个数字增加一的整数序列。\n  此函数不要求输入数组是排序的。\n\n  参数:\n  - numbers: 表示序列的整数切片。\n\n  返回:\n  - 数组中找到的最长连续序列的长度。\n\n  示例:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) 返回 4 (因为最长的连续序列是 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) 返回 5 (因为序列是 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) 返回 4 (因为序列是 1, 2, 3, 4)",
      "fr": "Trouve la longueur de la plus longue séquence consécutive dans le tableau de nombres donné.\n  Une séquence consécutive est définie comme une séquence d'entiers où chaque nombre suit le précédent par exactement un.\n  Cette fonction ne nécessite pas que le tableau d'entrée soit trié.\n\n  Arguments:\n  - numbers: Une tranche d'entiers représentant la séquence.\n\n  Retourne:\n  - La longueur de la plus longue séquence consécutive trouvée dans le tableau.\n\n  Exemple:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) retourne 4 (parce que la plus longue séquence consécutive est 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) retourne 5 (parce que la séquence est 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) retourne 4 (parce que la séquence est 1, 2, 3, 4)",
      "de": "Findet die Länge der längsten aufeinanderfolgenden Sequenz im gegebenen Array von Zahlen.\n  Eine aufeinanderfolgende Sequenz ist definiert als eine Sequenz von ganzen Zahlen, bei der jede Zahl der vorherigen um genau eins folgt.\n  Diese Funktion erfordert nicht, dass das Eingabearray sortiert ist.\n\n  Argumente:\n  - numbers: Ein Slice von ganzen Zahlen, das die Sequenz darstellt.\n\n  Rückgabewerte:\n  - Die Länge der längsten aufeinanderfolgenden Sequenz, die im Array gefunden wurde.\n\n  Beispiel:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) gibt 4 zurück (weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) gibt 5 zurück (weil die Sequenz 1, 2, 3, 4, 5 ist)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) gibt 4 zurück (weil die Sequenz 1, 2, 3, 4 ist)",
      "ha": "Nemi tsawon jerin lambobi masu jere mafi tsawo a cikin jerin lambobi da aka bayar.\n  Ana ayyana jerin lambobi masu jere a matsayin jerin lambobi inda kowanne lamba ke biyo bayan wanda ya gabace shi da lamba daya tak.\n  Wannan aikin baya bukatar a jera lambobin da aka bayar a cikin tsari.\n\n  Huɗɗa:\n  - numbers: Wani yanki na lambobi masu jere da ke wakiltar jerin.\n\n  Komawa:\n  - Tsawon mafi tsawo jerin lambobi masu jere da aka samu a cikin jerin.\n\n  Misali:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (saboda mafi tsawo jerin lambobi masu jere shine 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (saboda jerin shine 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (saboda jerin shine 1, 2, 3, 4)",
      "hi": "दिए गए संख्याओं के array में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\n  एक अनुक्रमिक अनुक्रम को उन पूर्णांकों की अनुक्रम के रूप में परिभाषित किया जाता है जहां प्रत्येक संख्या ठीक एक के अंतर से पिछले संख्या का अनुसरण करती है।\n  इस फ़ंक्शन के लिए इनपुट सरणी को क्रमबद्ध होना आवश्यक नहीं है।\n\n  Arguments:\n  - numbers: अनुक्रम का प्रतिनिधित्व करने वाले पूर्णांकों का एक स्लाइस।\n\n  Returns:\n  - सरणी में पाए गए सबसे लंबे अनुक्रमिक अनुक्रम की लंबाई।\n\n  Example:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) returns 4 (क्योंकि सबसे लंबा अनुक्रमिक अनुक्रम 1, 2, 3, 4 है)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) returns 5 (क्योंकि अनुक्रम 1, 2, 3, 4, 5 है)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) returns 4 (क्योंकि अनुक्रम 1, 2, 3, 4 है)",
      "hu": "Megtalálja a leghosszabb egymást követő sorozat hosszát a megadott szám tömbben.\n  Egy egymást követő sorozat olyan egész számok sorozataként van definiálva, ahol minden szám pontosan eggyel követi az előzőt.\n  Ennek a függvénynek nem szükséges, hogy a bemeneti tömb rendezett legyen.\n\n  Argumentumok:\n  - numbers: Egész számok szelete, amely a sorozatot képviseli.\n\n  Visszatér:\n  - A tömbben talált leghosszabb egymást követő sorozat hossza.\n\n  Példa:\n  - longest_consecutive_sequence(&[1, 9, 3, 10, 4, 20, 2]) visszatér 4 (mert a leghosszabb egymást követő sorozat 1, 2, 3, 4)\n  - longest_consecutive_sequence(&[8, 4, 2, 1, 3, 5]) visszatér 5 (mert a sorozat 1, 2, 3, 4, 5)\n  - longest_consecutive_sequence(&[100, 4, 200, 1, 3, 2]) visszatér 4 (mert a sorozat 1, 2, 3, 4)"
    },
    "docstring_bertscore": {
      "sq": "0.9905867076123757",
      "hy": "0.996902557838142",
      "bn": "1",
      "bg": "0.9978826001381681",
      "zh": "0.9776155478396543",
      "fr": "0.9950008705701139",
      "de": "0.9945035000960025",
      "ha": "0.9708394710210302",
      "hi": "0.9868155111980472",
      "hu": "0.9974895106141001"
    }
  },
  {
    "task_id": "Rust/47",
    "prompt": {
      "en": "/*\n  Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "sq": "/*\n  Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me dimensione 'b' x 'c'.\n  Kthen një varg që tregon nëse katrori ('Alice') apo drejtkëndëshi ('Bob') ka një sipërfaqe më të madhe.\n  \n  Argumentet:\n  - a: Një usize që përfaqëson gjatësinë e brinjës së katrorit.\n  - b: Një usize që përfaqëson gjatësinë e drejtkëndëshit.\n  - c: Një usize që përfaqëson gjerësinë e drejtkëndëshit.\n\n  Kthen:\n  - Një varg që është ose 'Alice' nëse sipërfaqja e katrorit është më e madhe, ose 'Bob' nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\n  Shembull:\n  - compare_area(5, 4, 6) kthen \"Alice\"\n  - compare_area(7, 5, 10) kthen \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "hy": "/*\n  Համեմատում է կողքի երկարությունը 'a' ունեցող քառակուսու մակերեսը 'b' x 'c' չափսերով ուղղանկյան մակերեսի հետ:\n  Վերադարձնում է տող, որը ցույց է տալիս՝ քառակուսին ('Alice') թե ուղղանկյունը ('Bob') ունի ավելի մեծ մակերես:\n  \n  Փաստարկներ:\n  - a: usize, որը ներկայացնում է քառակուսու կողքի երկարությունը:\n  - b: usize, որը ներկայացնում է ուղղանկյան երկարությունը:\n  - c: usize, որը ներկայացնում է ուղղանկյան լայնությունը:\n\n  Վերադարձնում է:\n  - Տող, որը կամ 'Alice' է, եթե քառակուսու մակերեսը մեծ է, կամ 'Bob', եթե ուղղանկյան մակերեսը մեծ է:\n\n  Օրինակ:\n  - compare_area(5, 4, 6) վերադարձնում է \"Alice\"\n  - compare_area(7, 5, 10) վերադարձնում է \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "bn": "/*\n  একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফলকে একটি আয়তক্ষেত্রের 'b' x 'c' মাত্রার ক্ষেত্রফলের সাথে তুলনা করে।\n  একটি স্ট্রিং প্রদান করে যা নির্দেশ করে যে বর্গক্ষেত্র ('Alice') বা আয়তক্ষেত্র ('Bob') এর ক্ষেত্রফল বড়।\n\n  আর্গুমেন্টসমূহ:\n  - a: একটি usize যা বর্গক্ষেত্রের বাহুর দৈর্ঘ্য উপস্থাপন করে।\n  - b: একটি usize যা আয়তক্ষেত্রের দৈর্ঘ্য উপস্থাপন করে।\n  - c: একটি usize যা আয়তক্ষেত্রের প্রস্থ উপস্থাপন করে।\n\n  রিটার্নস:\n  - একটি স্ট্রিং যা হয় 'Alice' যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, অথবা 'Bob' যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\n  উদাহরণ:\n  - compare_area(5, 4, 6) \"Alice\" প্রদান করে\n  - compare_area(7, 5, 10) \"Bob\" প্রদান করে\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "bg": "/*\n  Сравнява площта на квадрат със страна 'a' с площта на правоъгълник с размери 'b' x 'c'.\n  Връща низ, указващ дали квадратът ('Alice') или правоъгълникът ('Bob') има по-голяма площ.\n  \n  Аргументи:\n  - a: usize, представляваща дължината на страната на квадрата.\n  - b: usize, представляваща дължината на правоъгълника.\n  - c: usize, представляваща ширината на правоъгълника.\n\n  Връща:\n  - Низ, който е или 'Alice', ако площта на квадрата е по-голяма, или 'Bob', ако площта на правоъгълника е по-голяма.\n\n  Пример:\n  - compare_area(5, 4, 6) връща \"Alice\"\n  - compare_area(7, 5, 10) връща \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "zh": "/*\n  比较边长为 'a' 的正方形的面积与尺寸为 'b' x 'c' 的矩形的面积。\n  返回一个字符串，指示正方形 ('Alice') 或矩形 ('Bob') 哪个面积更大。\n  \n  参数:\n  - a: 一个 usize，表示正方形的边长。\n  - b: 一个 usize，表示矩形的长度。\n  - c: 一个 usize，表示矩形的宽度。\n\n  返回:\n  - 一个字符串，如果正方形的面积更大，则为 'Alice'，如果矩形的面积更大，则为 'Bob'。\n\n  示例:\n  - compare_area(5, 4, 6) 返回 \"Alice\"\n  - compare_area(7, 5, 10) 返回 \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "fr": "/*\n  Compare la surface d'un carré avec une longueur de côté 'a' à la surface d'un rectangle avec des dimensions 'b' x 'c'.\n  Retourne une chaîne indiquant si le carré ('Alice') ou le rectangle ('Bob') a une surface plus grande.\n  \n  Arguments :\n  - a : Un usize représentant la longueur du côté du carré.\n  - b : Un usize représentant la longueur du rectangle.\n  - c : Un usize représentant la largeur du rectangle.\n\n  Retourne :\n  - Une chaîne qui est soit 'Alice' si la surface du carré est plus grande, soit 'Bob' si la surface du rectangle est plus grande.\n\n  Exemple :\n  - compare_area(5, 4, 6) retourne \"Alice\"\n  - compare_area(7, 5, 10) retourne \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "de": "/*\n  Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Abmessungen 'b' x 'c'.\n  Gibt einen String zurück, der angibt, ob das Quadrat ('Alice') oder das Rechteck ('Bob') eine größere Fläche hat.\n  \n  Argumente:\n  - a: Ein usize, das die Seitenlänge des Quadrats darstellt.\n  - b: Ein usize, das die Länge des Rechtecks darstellt.\n  - c: Ein usize, das die Breite des Rechtecks darstellt.\n\n  Rückgabewert:\n  - Ein String, der entweder 'Alice' ist, wenn die Fläche des Quadrats größer ist, oder 'Bob', wenn die Fläche des Rechtecks größer ist.\n\n  Beispiel:\n  - compare_area(5, 4, 6) gibt \"Alice\" zurück\n  - compare_area(7, 5, 10) gibt \"Bob\" zurück\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "ha": "/*\n  Kwatanta yanki na murabba'i tare da tsawon gefe 'a' da yanki na murabba'in mai girma 'b' x 'c'.\n  Yana dawowa da rubutu da ke nuna ko murabba'i ('Alice') ko murabba'in ('Bob') yana da yanki mafi girma.\n  \n  Huɗɗa:\n  - a: Wani usize da ke wakiltar tsawon gefe na murabba'i.\n  - b: Wani usize da ke wakiltar tsawon murabba'in.\n  - c: Wani usize da ke wakiltar fadin murabba'in.\n\n  Dawowa:\n  - Wani rubutu wanda ko dai 'Alice' idan yankin murabba'i ya fi girma, ko 'Bob' idan yankin murabba'in ya fi girma.\n\n  Misali:\n  - compare_area(5, 4, 6) yana dawowa \"Alice\"\n  - compare_area(7, 5, 10) yana dawowa \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "hi": "/*\n  वर्ग के क्षेत्रफल की तुलना 'a' भुजा लंबाई वाले वर्ग से आयत के क्षेत्रफल से करें जिसकी माप 'b' x 'c' है।\n  एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि वर्ग ('Alice') या आयत ('Bob') का क्षेत्रफल बड़ा है।\n\n  तर्क:\n  - a: वर्ग की भुजा लंबाई को दर्शाने वाला usize।\n  - b: आयत की लंबाई को दर्शाने वाला usize।\n  - c: आयत की चौड़ाई को दर्शाने वाला usize।\n\n  लौटाता है:\n  - एक स्ट्रिंग जो या तो 'Alice' है यदि वर्ग का क्षेत्रफल बड़ा है, या 'Bob' है यदि आयत का क्षेत्रफल बड़ा है।\n\n  उदाहरण:\n  - compare_area(5, 4, 6) \"Alice\" लौटाता है\n  - compare_area(7, 5, 10) \"Bob\" लौटाता है\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String ",
      "hu": "/*\n  Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' x 'c' méretű téglalap területével.\n  Visszaad egy sztringet, amely jelzi, hogy a négyzetnek ('Alice') vagy a téglalapnak ('Bob') van-e nagyobb területe.\n  \n  Argumentumok:\n  - a: Egy usize, amely a négyzet oldalhosszát képviseli.\n  - b: Egy usize, amely a téglalap hosszát képviseli.\n  - c: Egy usize, amely a téglalap szélességét képviseli.\n\n  Visszatér:\n  - Egy sztring, amely 'Alice', ha a négyzet területe nagyobb, vagy 'Bob', ha a téglalap területe nagyobb.\n\n  Példa:\n  - compare_area(5, 4, 6) visszaadja \"Alice\"\n  - compare_area(7, 5, 10) visszaadja \"Bob\"\n*/\nfn compare_area(a: usize, b: usize, c: usize) -> String "
    },
    "prompt_bertscore": {
      "sq": "0.9892546922771557",
      "hy": "0.9806522091049157",
      "bn": "0.9983092581966311",
      "bg": "0.9638905857709056",
      "zh": "0.9539018611694231",
      "fr": "0.985755420854464",
      "de": "0.9836753635042667",
      "ha": "0.9822350946113827",
      "hi": "0.9732647479734661",
      "hu": "0.9893335485384265"
    },
    "canonical_solution": "{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}",
    "instruction": {
      "en": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nՏրամադրել կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nনিচের Rust কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn compare_area(a: usize, b: usize, c: usize) -> String\n{\n    let square_area = a * a;\n    let rectangle_area = b * c;\n    if square_area > rectangle_area {\n        \"Alice\".to_string()\n    } else {\n        \"Bob\".to_string()\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9258661760382538",
      "bn": "0.8706957931842895",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.8859772229188276",
      "hi": "0.9115359871984918",
      "hu": "0.9307939971613484"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(compare_area(5, 4, 6), \"Alice\");\n        assert_eq!(compare_area(7, 5, 10), \"Bob\");\n        assert_eq!(compare_area(6, 3, 8), \"Alice\");\n        assert_eq!(compare_area(9, 4, 5), \"Alice\");\n    }\n    \n\n}",
    "entry_point": "compare_area",
    "signature": "fn compare_area(a: usize, b: usize, c: usize) -> String",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with dimensions 'b' x 'c'.\n  Returns a string indicating whether the square ('Alice') or the rectangle ('Bob') has a larger area.\n  \n  Arguments:\n  - a: An usize representing the side length of the square.\n  - b: An usize representing the length of the rectangle.\n  - c: An usize representing the width of the rectangle.\n\n  Returns:\n  - A string that is either 'Alice' if the square's area is larger, or 'Bob' if the rectangle's area is larger.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "sq": "Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me dimensione 'b' x 'c'.\nKthen një varg që tregon nëse katrori ('Alice') apo drejtkëndëshi ('Bob') ka një sipërfaqe më të madhe.\n\nArgumentet:\n- a: Një usize që përfaqëson gjatësinë e brinjës së katrorit.\n- b: Një usize që përfaqëson gjatësinë e drejtkëndëshit.\n- c: Një usize që përfaqëson gjerësinë e drejtkëndëshit.\n\nKthen:\n- Një varg që është ose 'Alice' nëse sipërfaqja e katrorit është më e madhe, ose 'Bob' nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\nShembull:\n- compare_area(5, 4, 6) kthen \"Alice\"\n- compare_area(7, 5, 10) kthen \"Bob\"",
      "hy": "Համեմատում է կողմի երկարությունը 'a' ունեցող քառակուսու մակերեսը 'b' x 'c' չափերով ուղղանկյան մակերեսի հետ։ Վերադարձնում է տող, որը ցույց է տալիս, թե քառակուսին ('Alice') կամ ուղղանկյունը ('Bob') ավելի մեծ մակերես ունի։\n\nՓոփոխականներ:\n- a: usize, որը ներկայացնում է քառակուսու կողմի երկարությունը։\n- b: usize, որը ներկայացնում է ուղղանկյան երկարությունը։\n- c: usize, որը ներկայացնում է ուղղանկյան լայնությունը։\n\nՎերադարձնում է:\n- Տող, որը կամ 'Alice' է, եթե քառակուսու մակերեսը ավելի մեծ է, կամ 'Bob', եթե ուղղանկյան մակերեսը ավելի մեծ է։\n\nՕրինակ:\n- compare_area(5, 4, 6) վերադարձնում է \"Alice\"\n- compare_area(7, 5, 10) վերադարձնում է \"Bob\"",
      "bn": "বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' সহ বর্গক্ষেত্রের ক্ষেত্রফল এবং 'b' x 'c' মাত্রার আয়তক্ষেত্রের ক্ষেত্রফলের তুলনা করে।  \nএকটি স্ট্রিং ফেরত দেয় যা নির্দেশ করে যে বর্গক্ষেত্র ('Alice') বা আয়তক্ষেত্র ('Bob') এর ক্ষেত্রফল বড়।\n\nআর্গুমেন্টসমূহ:\n- a: একটি usize যা বর্গক্ষেত্রের বাহুর দৈর্ঘ্য উপস্থাপন করে।\n- b: একটি usize যা আয়তক্ষেত্রের দৈর্ঘ্য উপস্থাপন করে।\n- c: একটি usize যা আয়তক্ষেত্রের প্রস্থ উপস্থাপন করে।\n\nফেরত:\n- একটি স্ট্রিং যা হয় 'Alice' যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, অথবা 'Bob' যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\nউদাহরণ:\n- compare_area(5, 4, 6) \"Alice\" ফেরত দেয়\n- compare_area(7, 5, 10) \"Bob\" ফেরত দেয়",
      "bg": "Сравнява площта на квадрат със страна 'a' с площта на правоъгълник с размери 'b' x 'c'.\n  Връща низ, указващ дали квадратът ('Алис') или правоъгълникът ('Боб') има по-голяма площ.\n  \n  Аргументи:\n  - a: usize, представляваща дължината на страната на квадрата.\n  - b: usize, представляваща дължината на правоъгълника.\n  - c: usize, представляваща ширината на правоъгълника.\n\n  Връща:\n  - Низ, който е или 'Алис', ако площта на квадрата е по-голяма, или 'Боб', ако площта на правоъгълника е по-голяма.\n\n  Пример:\n  - compare_area(5, 4, 6) връща \"Alice\"\n  - compare_area(7, 5, 10) връща \"Bob\"",
      "zh": "比较边长为 'a' 的正方形与尺寸为 'b' x 'c' 的矩形的面积。  \n返回一个字符串，指示正方形（'Alice'）或矩形（'Bob'）哪个面积更大。\n\n参数:\n- a: 一个 usize，表示正方形的边长。\n- b: 一个 usize，表示矩形的长度。\n- c: 一个 usize，表示矩形的宽度。\n\n返回:\n- 一个字符串，如果正方形的面积更大则为 'Alice'，如果矩形的面积更大则为 'Bob'。\n\n示例:\n- compare_area(5, 4, 6) 返回 \"Alice\"\n- compare_area(7, 5, 10) 返回 \"Bob\"",
      "fr": "Compare l'aire d'un carré avec une longueur de côté 'a' à l'aire d'un rectangle avec des dimensions 'b' x 'c'.  \nRenvoie une chaîne indiquant si le carré ('Alice') ou le rectangle ('Bob') a une aire plus grande.\n\nArguments:\n- a: Un usize représentant la longueur du côté du carré.\n- b: Un usize représentant la longueur du rectangle.\n- c: Un usize représentant la largeur du rectangle.\n\nReturns:\n- Une chaîne qui est soit 'Alice' si l'aire du carré est plus grande, soit 'Bob' si l'aire du rectangle est plus grande.\n\nExample:\n- compare_area(5, 4, 6) renvoie \"Alice\"\n- compare_area(7, 5, 10) renvoie \"Bob\"",
      "de": "Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Abmessungen 'b' x 'c'.\nGibt einen String zurück, der angibt, ob das Quadrat ('Alice') oder das Rechteck ('Bob') eine größere Fläche hat.\n\nArgumente:\n- a: Eine usize, die die Seitenlänge des Quadrats darstellt.\n- b: Eine usize, die die Länge des Rechtecks darstellt.\n- c: Eine usize, die die Breite des Rechtecks darstellt.\n\nRückgabewert:\n- Ein String, der entweder 'Alice' ist, wenn die Fläche des Quadrats größer ist, oder 'Bob', wenn die Fläche des Rechtecks größer ist.\n\nBeispiel:\n- compare_area(5, 4, 6) gibt \"Alice\" zurück\n- compare_area(7, 5, 10) gibt \"Bob\" zurück",
      "ha": "Kwatanta girman fili na murabba'i mai gefen tsawo 'a' da girman fili na rectangle mai girma 'b' x 'c'.\n  Yana mayar da wata ƙirtani da ke nuna ko murabba'i ('Alice') ko rectangle ('Bob') yana da babbar yanki.\n\n  Arguments:\n  - a: Wani usize da ke wakiltar tsawon gefen murabba'i.\n  - b: Wani usize da ke wakiltar tsawon rectangle.\n  - c: Wani usize da ke wakiltar fadin rectangle.\n\n  Returns:\n  - Wata ƙirtani wadda ko dai 'Alice' idan yankin murabba'i ya fi girma, ko 'Bob' idan yankin rectangle ya fi girma.\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "hi": "वर्ग के भुजा की लंबाई 'a' के क्षेत्रफल की तुलना आयत के आयाम 'b' x 'c' के क्षेत्रफल से करता है।\n  एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि वर्ग ('Alice') या आयत ('Bob') का क्षेत्रफल बड़ा है। \n  \n  Arguments:\n  - a: वर्ग की भुजा की लंबाई को दर्शाने वाला एक usize।\n  - b: आयत की लंबाई को दर्शाने वाला एक usize।\n  - c: यत की चौड़ाई को दर्शाने वाला एक usize।\n\n  Returns:\n  - एक स्ट्रिंग जो या तो 'Alice' है यदि वर्ग का क्षेत्रफल बड़ा है, या 'Bob' है यदि आयत का क्षेत्रफल बड़ा है।\n\n  Example:\n  - compare_area(5, 4, 6) returns \"Alice\"\n  - compare_area(7, 5, 10) returns \"Bob\"",
      "hu": "Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' x 'c' méretű téglalap területével. \n  Visszaad egy sztringet, amely jelzi, hogy a négyzetnek ('Alice') vagy a téglalapnak ('Bob') van-e nagyobb területe.\n  \n  Argumentumok:\n  - a: Egy usize, amely a négyzet oldalhosszúságát jelenti.\n  - b: Egy usize, amely a téglalap hosszát jelenti.\n  - c: Egy usize, amely a téglalap szélességét jelenti.\n\n  Visszatér:\n  - Egy sztring, amely 'Alice', ha a négyzet területe nagyobb, vagy 'Bob', ha a téglalap területe nagyobb.\n\n  Példa:\n  - compare_area(5, 4, 6) visszaadja \"Alice\"\n  - compare_area(7, 5, 10) visszaadja \"Bob\""
    },
    "docstring_bertscore": {
      "sq": "0.9892397949985781",
      "hy": "0.974744544312176",
      "bn": "0.9380531430666494",
      "bg": "0.9546099784778125",
      "zh": "0.9414006608782304",
      "fr": "0.9827600747084579",
      "de": "0.9843475287136887",
      "ha": "0.9683766529265786",
      "hi": "0.874558756834656",
      "hu": "0.9919518942212284"
    }
  },
  {
    "task_id": "Rust/48",
    "prompt": {
      "en": "/*\n  Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "sq": "/*\n  Gjen M numra të plotë pozitivë, shuma e të cilëve është e barabartë me N dhe prodhimi i të cilëve është maksimal, duke kthyer sekuencën më të vogël leksikografike të këtyre numrave.\n\n  Argumentet:\n  - n: Shuma që M numrat duhet të jenë të barabartë me.\n  - m: Numri i numrave për të gjetur.\n\n  Kthen:\n  - Një vektor me M numra të plotë, shuma e të cilëve është N dhe prodhimi i të cilëve është maksimal.\n\n  Shembull:\n  - max_product_partition(6, 3) kthen vec![2, 2, 2]\n  - max_product_partition(8, 3) kthen vec![2, 3, 3]\n  - max_product_partition(10, 2) kthen vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "hy": "/*\n  Գտնում է M դրական ամբողջ թվեր, որոնց գումարը հավասար է N-ի և որոնց արտադրյալը առավելագույն է, վերադարձնելով այդ թվերի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը։\n\n  Արգումենտներ:\n  - n: Գումարը, որին M թվերը պետք է հավասարվեն։\n  - m: Գտնվող թվերի քանակը։\n\n  Վերադարձնում է:\n  - M թվերի վեկտոր, որոնց գումարը N է և որոնց արտադրյալը առավելագույն է։\n\n  Օրինակ:\n  - max_product_partition(6, 3) վերադարձնում է vec![2, 2, 2]\n  - max_product_partition(8, 3) վերադարձնում է vec![2, 3, 3]\n  - max_product_partition(10, 2) վերադարձնում է vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "bn": "/*\n  এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N এবং যাদের গুণফল সর্বাধিক, এবং এই পূর্ণসংখ্যাগুলির লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম ক্রম ফেরত দেয়।\n\n  আর্গুমেন্ট:\n  - n: যে যোগফল M পূর্ণসংখ্যাগুলির সমান হতে হবে।\n  - m: যে সংখ্যক পূর্ণসংখ্যা খুঁজে বের করতে হবে।\n\n  রিটার্নস:\n  - M পূর্ণসংখ্যার একটি ভেক্টর যার যোগফল N এবং যার গুণফল সর্বাধিক।\n\n  উদাহরণ:\n  - max_product_partition(6, 3) vec![2, 2, 2] ফেরত দেয়\n  - max_product_partition(8, 3) vec![2, 3, 3] ফেরত দেয়\n  - max_product_partition(10, 2) vec![5, 5] ফেরত দেয়\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "bg": "/*\n  Намира M положителни цели числа, чиято сума е равна на N и чийто произведение е максимално, връщайки лексикографски най-малката последователност от тези числа.\n\n  Аргументи:\n  - n: Сумата, на която M числата трябва да са равни.\n  - m: Броят на числата, които трябва да се намерят.\n\n  Връща:\n  - Вектор от M числа, чиято сума е N и чието произведение е максимално.\n\n  Пример:\n  - max_product_partition(6, 3) връща vec![2, 2, 2]\n  - max_product_partition(8, 3) връща vec![2, 3, 3]\n  - max_product_partition(10, 2) връща vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "zh": "/*\n  找到 M 个正整数，这些整数的和等于 N，并且它们的乘积最大，返回这些整数的字典序最小的序列。\n\n  参数:\n  - n: M 个整数的和必须等于的值。\n  - m: 要找到的整数的数量。\n\n  返回:\n  - 一个包含 M 个整数的向量，这些整数的和为 N，并且乘积最大。\n\n  示例:\n  - max_product_partition(6, 3) 返回 vec![2, 2, 2]\n  - max_product_partition(8, 3) 返回 vec![2, 3, 3]\n  - max_product_partition(10, 2) 返回 vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "fr": "/*\n  Trouve M entiers positifs dont la somme est égale à N et dont le produit est maximisé, en retournant la séquence lexicographiquement la plus petite de ces entiers.\n\n  Arguments:\n  - n: La somme que les M entiers doivent atteindre.\n  - m: Le nombre d'entiers à trouver.\n\n  Renvoie:\n  - Un vecteur de M entiers dont la somme est N et dont le produit est maximisé.\n\n  Exemple:\n  - max_product_partition(6, 3) renvoie vec![2, 2, 2]\n  - max_product_partition(8, 3) renvoie vec![2, 3, 3]\n  - max_product_partition(10, 2) renvoie vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "de": "/*\n  Findet M positive ganze Zahlen, deren Summe N entspricht und deren Produkt maximiert wird, und gibt die lexikografisch kleinste Sequenz dieser Zahlen zurück.\n\n  Argumente:\n  - n: Die Summe, die die M Zahlen ergeben müssen.\n  - m: Die Anzahl der zu findenden Zahlen.\n\n  Rückgabe:\n  - Ein Vektor von M Zahlen, deren Summe N ist und deren Produkt maximiert wird.\n\n  Beispiel:\n  - max_product_partition(6, 3) gibt vec![2, 2, 2] zurück\n  - max_product_partition(8, 3) gibt vec![2, 3, 3] zurück\n  - max_product_partition(10, 2) gibt vec![5, 5] zurück\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "ha": "/*\n  Nemo lambobi M masu kyau waɗanda jimlarsu ta yi daidai da N kuma waɗanda samfurinsu ya fi girma, suna mayar da jerin lambobi mafi ƙaranci a cikin tsarin haruffa.\n\n  Huɗɗa:\n  - n: Jimlar da lambobi M dole ne su yi daidai da.\n  - m: Yawan lambobin da za a nema.\n\n  Mayarwa:\n  - Wani vector na lambobi M waɗanda jimlarsu ita ce N kuma samfurinsu ya fi girma.\n\n  Misali:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "hi": "/*\n  ऐसे M धनात्मक पूर्णांक खोजता है जिनका योग N के बराबर होता है और जिनका गुणनफल अधिकतम होता है, इन पूर्णांकों का वर्णानुक्रम में सबसे छोटा अनुक्रम लौटाता है।\n\n  तर्क:\n  - n: वह योग जिसे M पूर्णांकों के बराबर होना चाहिए।\n  - m: खोजने के लिए पूर्णांकों की संख्या।\n\n  लौटाता है:\n  - M पूर्णांकों का एक वेक्टर जिनका योग N है और जिनका गुणनफल अधिकतम है।\n\n  उदाहरण:\n  - max_product_partition(6, 3) vec![2, 2, 2] लौटाता है\n  - max_product_partition(8, 3) vec![2, 3, 3] लौटाता है\n  - max_product_partition(10, 2) vec![5, 5] लौटाता है\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> ",
      "hu": "/*\n  Megkeresi azt az M pozitív egész számot, amelyek összege N és szorzatuk maximális, visszaadva ezeknek az egész számoknak a lexikografikusan legkisebb sorozatát.\n\n  Argumentumok:\n  - n: Az összeg, amelynek az M egész számnak meg kell egyeznie.\n  - m: Az egész számok száma, amelyeket meg kell találni.\n\n  Visszatér:\n  - Egy M egész számot tartalmazó vektor, amelynek összege N és szorzatuk maximális.\n\n  Példa:\n  - max_product_partition(6, 3) visszaadja vec![2, 2, 2]\n  - max_product_partition(8, 3) visszaadja vec![2, 3, 3]\n  - max_product_partition(10, 2) visszaadja vec![5, 5]\n*/\nfn max_product_partition(n: i32, m: i32) -> Vec<i32> "
    },
    "prompt_bertscore": {
      "sq": "0.9698624081767195",
      "hy": "0.971709670720344",
      "bn": "0.9894624596557181",
      "bg": "0.9672297611064831",
      "zh": "0.9710400877058754",
      "fr": "0.9862267707486598",
      "de": "0.9846089262951306",
      "ha": "0.911548302282116",
      "hi": "0.9720666095150636",
      "hu": "0.9726766034152218"
    },
    "canonical_solution": "{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}",
    "instruction": {
      "en": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nՏրամադրեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\n请用中文为以下Rust代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Rust a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>\n{\n    let mut result = vec![n / m; m as usize];\n    let remainder = n % m;\n\n    for i in 0..remainder as usize {\n        result[i] += 1;\n    }\n\n    result.sort(); // To ensure it is lexicographically smallest\n    result\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9258661760382538",
      "bn": "0.8690823185991431",
      "bg": "0.8316696904400789",
      "zh": "0.8871262996731144",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(max_product_partition(6, 3), vec![2, 2, 2]);\n        assert_eq!(max_product_partition(8, 3), vec![2, 3, 3]);\n        assert_eq!(max_product_partition(10, 2), vec![5, 5]);\n        assert_eq!(max_product_partition(7, 3), vec![2, 2, 3]);\n    }\n    \n\n}",
    "entry_point": "max_product_partition",
    "signature": "fn max_product_partition(n: i32, m: i32) -> Vec<i32>",
    "docstring": {
      "en": "Finds M positive integers whose sum equals N and whose product is maximized, returning the lexicographically smallest sequence of these integers.\n\n  Arguments:\n  - n: The sum that the M integers must equal to.\n  - m: The number of integers to find.\n\n  Returns:\n  - A vector of M integers whose sum is N and whose product is maximized.\n\n  Example:\n  - max_product_partition(6, 3) returns vec![2, 2, 2]\n  - max_product_partition(8, 3) returns vec![2, 3, 3]\n  - max_product_partition(10, 2) returns vec![5, 5]",
      "sq": "Gjen M numra të plotë pozitivë, shuma e të cilëve është e barabartë me N dhe produkti i të cilëve është maksimal, duke kthyer vargun leksikografikisht më të vogël të këtyre numrave.\n\n  Argumentet:\n  - n: Shuma që M numrat duhet të jenë të barabartë.\n  - m: Numri i numrave për të gjetur.\n\n  Kthen:\n  - Një vektor prej M numrash, shuma e të cilëve është N dhe produkti i të cilëve është maksimal.\n\n  Shembull:\n  - max_product_partition(6, 3) kthen vec![2, 2, 2]\n  - max_product_partition(8, 3) kthen vec![2, 3, 3]\n  - max_product_partition(10, 2) kthen vec![5, 5]",
      "hy": "Գտնում է M դրական ամբողջ թվեր, որոնց գումարը հավասար է N-ի և որոնց արտադրյալը առավելագույն է, վերադարձնելով այս թվերի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը:\n\n  Արգումենտներ:\n  - n: Գումարը, որին պետք է հավասարվեն M ամբողջ թվերը:\n  - m: Գտնվող ամբողջ թվերի քանակը:\n\n  Վերադարձնում է:\n  - M ամբողջ թվերի վեկտոր, որոնց գումարը N է և որոնց արտադրյալը առավելագույն է:\n\n  Օրինակ:\n  - max_product_partition(6, 3) վերադարձնում է vec![2, 2, 2]\n  - max_product_partition(8, 3) վերադարձնում է vec![2, 3, 3]\n  - max_product_partition(10, 2) վերադարձնում է vec![5, 5]",
      "bn": "এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N এবং যাদের গুণফল সর্বাধিক, এবং এই পূর্ণসংখ্যাগুলির লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট ক্রমটি ফেরত দেয়।\n\n  আর্গুমেন্টস:\n  - n: সংখ্যাটি যার সমান M টি পূর্ণসংখ্যার যোগফল হতে হবে।\n  - m: পূর্ণসংখ্যাগুলি খুঁজে বের করার সংখ্যা।\n\n  রিটার্নস:\n  - M পূর্ণসংখ্যার একটি ভেক্টর যার যোগফল N এবং যার গুণফল সর্বাধিক।\n\n  উদাহরণ:\n  - max_product_partition(6, 3) রিটার্ন করে vec![2, 2, 2]\n  - max_product_partition(8, 3) রিটার্ন করে vec![2, 3, 3]\n  - max_product_partition(10, 2) রিটার্ন করে vec![5, 5]",
      "bg": "Намира M положителни цели числа, чиято сума е равна на N и чийто произведение е максимизирано, връщайки лексикографски най-малката последователност от тези числа.\n\nАргументи:\n- n: Сумата, на която M числата трябва да са равни.\n- m: Броят на числата, които трябва да се намерят.\n\nВръща:\n- Вектор от M цели числа, чиято сума е N и чието произведение е максимизирано.\n\nПример:\n- max_product_partition(6, 3) връща vec![2, 2, 2]\n- max_product_partition(8, 3) връща vec![2, 3, 3]\n- max_product_partition(10, 2) връща vec![5, 5]",
      "zh": "找到 M 个正整数，其和等于 N 且乘积最大，返回这些整数的字典序最小序列。\n\n  参数:\n  - n: M 个整数的和必须等于的值。\n  - m: 要找到的整数个数。\n\n  返回:\n  - 一个包含 M 个整数的向量，其和为 N 且乘积最大。\n\n  示例:\n  - max_product_partition(6, 3) 返回 vec![2, 2, 2]\n  - max_product_partition(8, 3) 返回 vec![2, 3, 3]\n  - max_product_partition(10, 2) 返回 vec![5, 5]",
      "fr": "Trouve M entiers positifs dont la somme est égale à N et dont le produit est maximisé, en renvoyant la séquence lexicographiquement la plus petite de ces entiers.\n\n  Arguments:\n  - n: La somme que les M entiers doivent égaler.\n  - m: Le nombre d'entiers à trouver.\n\n  Renvoie:\n  - Un vecteur de M entiers dont la somme est N et dont le produit est maximisé.\n\n  Exemple:\n  - max_product_partition(6, 3) renvoie vec![2, 2, 2]\n  - max_product_partition(8, 3) renvoie vec![2, 3, 3]\n  - max_product_partition(10, 2) renvoie vec![5, 5]",
      "de": "Findet M positive ganze Zahlen, deren Summe N ergibt und deren Produkt maximiert ist, und gibt die lexikografisch kleinste Sequenz dieser Zahlen zurück.\n\n  Argumente:\n  - n: Die Summe, die die M Zahlen ergeben müssen.\n  - m: Die Anzahl der zu findenden Zahlen.\n\n  Rückgabe:\n  - Ein Vektor von M Zahlen, deren Summe N ergibt und deren Produkt maximiert ist.\n\n  Beispiel:\n  - max_product_partition(6, 3) gibt vec![2, 2, 2] zurück\n  - max_product_partition(8, 3) gibt vec![2, 3, 3] zurück\n  - max_product_partition(10, 2) gibt vec![5, 5] zurück",
      "ha": "Nemo lambobi M masu kyau waɗanda jimlarsu ta yi daidai da N kuma samfurin su ya kai matsakaicin daraja, ta dawo da jerin lambobi mafi ƙarancin tsari a cikin waɗannan lambobin.\n\n  Huɗɗa:\n  - n: Jimlar da lambobi M dole ne su yi daidai da ita.\n  - m: Yawan lambobin da za a samu.\n\n  Komawa:\n  - Wani vector na lambobi M waɗanda jimlarsu ta yi daidai da N kuma samfurin su ya kai matsakaicin daraja.\n\n  Misali:\n  - max_product_partition(6, 3) ya dawo da vec![2, 2, 2]\n  - max_product_partition(8, 3) ya dawo da vec![2, 3, 3]\n  - max_product_partition(10, 2) ya dawo da vec![5, 5]",
      "hi": "M धनात्मक पूर्णांकों को खोजता है जिनका योग N के बराबर होता है और जिनका गुणनफल अधिकतम होता है, इन पूर्णांकों के क्रमानुसार सबसे छोटे अनुक्रम को लौटाता है।\n\nArguments:\n- n: वह योग जिसके बराबर M पूर्णांकों को होना चाहिए।\n- m: खोजने के लिए पूर्णांकों की संख्या।\n\nReturns:\n- M पूर्णांकों का एक वेक्टर जिसका योग N है और जिसका गुणनफल अधिकतम है।\n\nExample:\n- max_product_partition(6, 3) vec![2, 2, 2] लौटाता है\n- max_product_partition(8, 3) vec![2, 3, 3] लौटाता है\n- max_product_partition(10, 2) vec![5, 5] लौटाता है",
      "hu": "Megtalálja azt az M pozitív egész számot, amelyek összege N és amelyek szorzata maximalizált, visszaadva ezeknek az egész számoknak a lexikografikusan legkisebb sorozatát.\n\n  Argumentumok:\n  - n: Az összeg, amelyre az M egész számnak egyenlőnek kell lennie.\n  - m: A megtalálandó egész számok száma.\n\n  Visszatér:\n  - Egy M egész számot tartalmazó vektor, amelynek összege N és amelynek szorzata maximalizált.\n\n  Példa:\n  - max_product_partition(6, 3) visszaadja: vec![2, 2, 2]\n  - max_product_partition(8, 3) visszaadja: vec![2, 3, 3]\n  - max_product_partition(10, 2) visszaadja: vec![5, 5]"
    },
    "docstring_bertscore": {
      "sq": "0.965088724229308",
      "hy": "0.9678540563940757",
      "bn": "0.9904925568117651",
      "bg": "0.965589471419897",
      "zh": "0.9659617047539564",
      "fr": "0.9838434048066222",
      "de": "0.9792572279389077",
      "ha": "0.9607468627302664",
      "hi": "0.94187081899014",
      "hu": "0.9796811051720361"
    }
  },
  {
    "task_id": "Rust/49",
    "prompt": {
      "en": "/*\n  Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "sq": "/*\n  Llogarit numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Argumentet:\n  - title: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla anglisht, shifra, hapësira dhe karaktere të rreshtave të rinj.\n\n  Kthen:\n  - Numri i karaktereve në titull, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Shembuj:\n  - count_title_chars(\"234\") kthen 3\n  - count_title_chars(\"Ca 45\") kthen 4\n  - count_title_chars(\"Hello\\nWorld\") kthen 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize",
      "hy": "/*\n  Հաշվում է տրված վերնագրի տողի սիմվոլների քանակը, բացի բացատներից և նոր տողի սիմվոլներից:\n\n  Արգումենտներ:\n  - title: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, թվեր, բացատներ և նոր տողի սիմվոլներ:\n\n  Վերադարձնում է:\n  - Սիմվոլների քանակը վերնագրում, բացի բացատներից և նոր տողի սիմվոլներից:\n\n  Օրինակներ:\n  - count_title_chars(\"234\") վերադարձնում է 3\n  - count_title_chars(\"Ca 45\") վերադարձնում է 4\n  - count_title_chars(\"Hello\\nWorld\") վերադարձնում է 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize",
      "bn": "/*\n  প্রদত্ত শিরোনাম স্ট্রিংয়ে কতগুলি অক্ষর রয়েছে তা গণনা করে, স্পেস এবং নিউলাইন অক্ষর বাদ দিয়ে।\n\n  আর্গুমেন্টসমূহ:\n  - title: একটি স্ট্রিং যা বড় এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা, স্পেস এবং নিউলাইন অক্ষর ধারণ করতে পারে।\n\n  রিটার্নস:\n  - শিরোনামে অক্ষরের সংখ্যা, স্পেস এবং নিউলাইন অক্ষর বাদ দিয়ে।\n\n  উদাহরণসমূহ:\n  - count_title_chars(\"234\") রিটার্ন করে 3\n  - count_title_chars(\"Ca 45\") রিটার্ন করে 4\n  - count_title_chars(\"Hello\\nWorld\") রিটার্ন করে 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "bg": "/*\n  Изчислява броя на символите в даден низ заглавие, изключвайки интервалите и символите за нов ред.\n\n  Аргументи:\n  - title: Низ, който може да съдържа главни и малки английски букви, цифри, интервали и символи за нов ред.\n\n  Връща:\n  - Броят на символите в заглавието, изключвайки интервалите и символите за нов ред.\n\n  Примери:\n  - count_title_chars(\"234\") връща 3\n  - count_title_chars(\"Ca 45\") връща 4\n  - count_title_chars(\"Hello\\nWorld\") връща 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "zh": "/*\n  计算给定标题字符串中的字符数，不包括空格和换行符。\n\n  参数：\n  - title: 一个字符串，可能包含大写和小写的英文字母、数字、空格和换行符。\n\n  返回：\n  - 标题中的字符数，不包括空格和换行符。\n\n  示例：\n  - count_title_chars(\"234\") 返回 3\n  - count_title_chars(\"Ca 45\") 返回 4\n  - count_title_chars(\"Hello\\nWorld\") 返回 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "fr": "/*\n  Calcule le nombre de caractères dans une chaîne de titre donnée, en excluant les espaces et les caractères de nouvelle ligne.\n\n  Arguments:\n  - title: Une chaîne qui peut contenir des lettres anglaises majuscules et minuscules, des chiffres, des espaces et des caractères de nouvelle ligne.\n\n  Retourne:\n  - Le nombre de caractères dans le titre, en excluant les espaces et les caractères de nouvelle ligne.\n\n  Exemples:\n  - count_title_chars(\"234\") retourne 3\n  - count_title_chars(\"Ca 45\") retourne 4\n  - count_title_chars(\"Hello\\nWorld\") retourne 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "de": "/*\n  Berechnet die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche.\n\n  Argumente:\n  - title: Ein String, der Groß- und Kleinbuchstaben, Ziffern, Leerzeichen und Zeilenumbrüche enthalten kann.\n\n  Rückgabewert:\n  - Die Anzahl der Zeichen im Titel, ohne Leerzeichen und Zeilenumbrüche.\n\n  Beispiele:\n  - count_title_chars(\"234\") gibt 3 zurück\n  - count_title_chars(\"Ca 45\") gibt 4 zurück\n  - count_title_chars(\"Hello\\nWorld\") gibt 10 zurück\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "ha": "/*\n  Lissafa adadin haruffa a cikin taken da aka bayar, banda sarari da haruffan sabon layi.\n\n  Huɗaɗɗa:\n  - title: Wani zare wanda zai iya ƙunsar manya da ƙananan haruffan Ingilishi, lambobi, sarari, da haruffan sabon layi.\n\n  Dawowa:\n  - Adadin haruffa a cikin taken, banda sarari da haruffan sabon layi.\n\n  Misalai:\n  - count_title_chars(\"234\") yana dawowa 3\n  - count_title_chars(\"Ca 45\") yana dawowa 4\n  - count_title_chars(\"Hello\\nWorld\") yana dawowa 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "hi": "/*\n  दिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं हैं।\n\n  तर्क:\n  - title: एक स्ट्रिंग जो बड़े और छोटे अंग्रेजी अक्षरों, अंकों, रिक्त स्थान और नई पंक्ति के वर्णों को शामिल कर सकती है।\n\n  लौटाता है:\n  - शीर्षक में वर्णों की गिनती, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं हैं।\n\n  उदाहरण:\n  - count_title_chars(\"234\") 3 लौटाता है\n  - count_title_chars(\"Ca 45\") 4 लौटाता है\n  - count_title_chars(\"Hello\\nWorld\") 10 लौटाता है\n*/\n\n\nfn count_title_chars(title: &str) -> usize ",
      "hu": "/*\n  Kiszámítja a karakterek számát egy adott cím sztringben, a szóközök és az új sor karakterek kivételével.\n\n  Argumentumok:\n  - title: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, számjegyeket, szóközöket és új sor karaktereket.\n\n  Visszatérési érték:\n  - A karakterek száma a címben, a szóközök és az új sor karakterek kivételével.\n\n  Példák:\n  - count_title_chars(\"234\") visszaadja 3\n  - count_title_chars(\"Ca 45\") visszaadja 4\n  - count_title_chars(\"Hello\\nWorld\") visszaadja 10\n*/\n\n\nfn count_title_chars(title: &str) -> usize"
    },
    "prompt_bertscore": {
      "sq": "0.9956468165692394",
      "hy": "0.9852272626712922",
      "bn": "0.9852272626712922",
      "bg": "0.9967255781686398",
      "zh": "0.9816197376909366",
      "fr": "0.9914702155472188",
      "de": "0.9543376562254137",
      "ha": "0.9689928043685487",
      "hi": "0.9896368571302668",
      "hu": "0.9924151002698017"
    },
    "canonical_solution": "{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}",
    "instruction": {
      "en": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nՏրամադրել կարճ բնութագրում (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nনিচের Rust কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nBa da takaitaccen bayani na harshen halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn count_title_chars(title: &str) -> usize\n{\n    title.chars().filter(|&c| c != ' ' && c != '\\n').count()\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8870448612168901",
      "bn": "0.8781885284176876",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9536426485221726",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_title_chars(\"234\"), 3);\n        assert_eq!(count_title_chars(\"Ca 45\"), 4);\n        assert_eq!(count_title_chars(\"Hello\\nWorld\"), 10);\n    }\n    \n\n}",
    "entry_point": "count_title_chars",
    "signature": "fn count_title_chars(title: &str) -> usize",
    "docstring": {
      "en": "Calculates the number of characters in a given title string, excluding spaces and newline characters.\n\n  Arguments:\n  - title: A string that may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n\n  Returns:\n  - The count of characters in the title, excluding spaces and newline characters.\n\n  Examples:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "sq": "Llogarit numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Argumentet:\n  - title: Një varg që mund të përmbajë shkronja të mëdha dhe të vogla të anglishtes, shifra, hapësira dhe karaktere të rreshtave të rinj.\n\n  Kthen:\n  - Numri i karaktereve në titull, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Shembuj:\n  - count_title_chars(\"234\") kthen 3\n  - count_title_chars(\"Ca 45\") kthen 4\n  - count_title_chars(\"Hello\\nWorld\") kthen 10",
      "hy": "Հաշվում է տրված վերնագրի տողում գտնվող սիմվոլների քանակը՝ բացառելով բացատներն ու նոր տողի սիմվոլները։\n\n  Արգումենտներ:\n  - title: Տող, որը կարող է պարունակել մեծատառ և փոքրատառ անգլերեն տառեր, թվեր, բացատներ և նոր տողի սիմվոլներ։\n\n  Վերադարձնում է:\n  - Սիմվոլների քանակը վերնագրում՝ բացառելով բացատներն ու նոր տողի սիմվոլները։\n\n  Օրինակներ:\n  - count_title_chars(\"234\") վերադարձնում է 3\n  - count_title_chars(\"Ca 45\") վերադարձնում է 4\n  - count_title_chars(\"Hello\\nWorld\") վերադարձնում է 10",
      "bn": "প্রদত্ত শিরোনাম স্ট্রিং-এ কতগুলি অক্ষর রয়েছে তা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n\n  আর্গুমেন্টস:\n  - title: একটি স্ট্রিং যা বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা, ফাঁকা স্থান এবং নতুন লাইন অক্ষর ধারণ করতে পারে।\n\n  রিটার্নস:\n  - শিরোনামে ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে অক্ষরের সংখ্যা।\n\n  উদাহরণ:\n  - count_title_chars(\"234\") রিটার্ন করে 3\n  - count_title_chars(\"Ca 45\") রিটার্ন করে 4\n  - count_title_chars(\"Hello\\nWorld\") রিটার্ন করে 10",
      "bg": "Изчислява броя на символите в даден низ за заглавие, изключвайки интервалите и символите за нов ред.\n\nАргументи:\n- title: Низ, който може да съдържа главни и малки английски букви, цифри, интервали и символи за нов ред.\n\nВръща:\n- Броят на символите в заглавието, изключвайки интервалите и символите за нов ред.\n\nПримери:\n- count_title_chars(\"234\") връща 3\n- count_title_chars(\"Ca 45\") връща 4\n- count_title_chars(\"Hello\\nWorld\") връща 10",
      "zh": "计算给定标题字符串中的字符数，不包括空格和换行符。\n\n  参数:\n  - title: 一个字符串，可能包含大写和小写的英文字母、数字、空格和换行符。\n\n  返回:\n  - 标题中字符的数量，不包括空格和换行符。\n\n  示例:\n  - count_title_chars(\"234\") 返回 3\n  - count_title_chars(\"Ca 45\") 返回 4\n  - count_title_chars(\"Hello\\nWorld\") 返回 10",
      "fr": "Calcule le nombre de caractères dans une chaîne de titre donnée, à l'exclusion des espaces et des caractères de nouvelle ligne.\n\n  Arguments:\n  - title: Une chaîne qui peut contenir des lettres anglaises majuscules et minuscules, des chiffres, des espaces et des caractères de nouvelle ligne.\n\n  Renvoie:\n  - Le nombre de caractères dans le titre, à l'exclusion des espaces et des caractères de nouvelle ligne.\n\n  Exemples:\n  - count_title_chars(\"234\") renvoie 3\n  - count_title_chars(\"Ca 45\") renvoie 4\n  - count_title_chars(\"Hello\\nWorld\") renvoie 10",
      "de": "Berechnet die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche.\n\n  Argumente:\n  - title: Ein String, der Groß- und Kleinbuchstaben des englischen Alphabets, Ziffern, Leerzeichen und Zeilenumbrüche enthalten kann.\n\n  Rückgabewerte:\n  - Die Anzahl der Zeichen im Titel, ohne Leerzeichen und Zeilenumbrüche.\n\n  Beispiele:\n  - count_title_chars(\"234\") gibt 3 zurück\n  - count_title_chars(\"Ca 45\") gibt 4 zurück\n  - count_title_chars(\"Hello\\nWorld\") gibt 10 zurück",
      "ha": "Lissafa yawan haruffa a cikin wani take na kirtani, banda sarari da haruffan sabon layi.\n\n  Huɗɗa:\n  - title: Wani kirtani wanda zai iya ƙunsar manyan da ƙananan haruffan Ingilishi, lambobi, sarari, da haruffan sabon layi.\n\n  Komawa:\n  - Adadin haruffa a cikin taken, ban da sarari da haruffan sabon layi.\n\n  Misalai:\n  - count_title_chars(\"234\") returns 3\n  - count_title_chars(\"Ca 45\") returns 4\n  - count_title_chars(\"Hello\\nWorld\") returns 10",
      "hi": "दिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\n  तर्क:\n  - title: एक स्ट्रिंग जिसमें बड़े और छोटे अंग्रेजी अक्षर, अंक, रिक्त स्थान और नई पंक्ति के वर्ण हो सकते हैं।\n\n  वापसी:\n  - शीर्षक में वर्णों की गिनती, रिक्त स्थान और नई पंक्ति के वर्णों को छोड़कर।\n\n  उदाहरण:\n  - count_title_chars(\"234\") 3 लौटाता है\n  - count_title_chars(\"Ca 45\") 4 लौटाता है\n  - count_title_chars(\"Hello\\nWorld\") 10 लौटाता है",
      "hu": "Számolja ki a megadott cím sztringben található karakterek számát, a szóközök és az új sor karakterek kivételével.\n\n  Argumentumok:\n  - title: Egy sztring, amely tartalmazhat nagy- és kisbetűs angol betűket, számjegyeket, szóközöket és új sor karaktereket.\n\n  Visszatérési érték:\n  - A címben található karakterek száma, a szóközök és az új sor karakterek kivételével.\n\n  Példák:\n  - count_title_chars(\"234\") visszaadja 3\n  - count_title_chars(\"Ca 45\") visszaadja 4\n  - count_title_chars(\"Hello\\nWorld\") visszaadja 10"
    },
    "docstring_bertscore": {
      "sq": "0.9929343200858269",
      "hy": "0.9789183645088622",
      "bn": "0.981638607577135",
      "bg": "0.9954487820793476",
      "zh": "0.9734850290660338",
      "fr": "0.9880692661631394",
      "de": "0.948691190383735",
      "ha": "0.9776797054527285",
      "hi": "0.9957683783624327",
      "hu": "0.9900225973302366"
    }
  },
  {
    "task_id": "Rust/50",
    "prompt": {
      "en": "/*\n  Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "sq": "/*\n  Numëron numrin e studentëve që janë regjistruar si në Kursin A ashtu edhe në Kursin B.\n\n  Argumentet:\n  - n: Numri i studentëve të regjistruar në Kursin A.\n  - m: Numri i studentëve të regjistruar në Kursin B.\n  - a: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin A.\n  - b: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin B.\n\n  Kthen:\n  - Numri i studentëve që janë regjistruar në të dyja kurset.\n\n  Shembull:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) kthen 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) kthen 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "hy": "/*\n  Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ Դասընթաց A-ում, և՛ Դասընթաց B-ում:\n\n  Արգումենտներ:\n  - n: Ուսանողների քանակը, ովքեր գրանցվել են Դասընթաց A-ում:\n  - m: Ուսանողների քանակը, ովքեր գրանցվել են Դասընթաց B-ում:\n  - a: Վեկտոր, որը պարունակում է Դասընթաց A-ում գրանցված ուսանողների ID-ները:\n  - b: Վեկտոր, որը պարունակում է Դասընթաց B-ում գրանցված ուսանողների ID-ները:\n\n  Վերադարձնում է:\n  - Ուսանողների քանակը, ովքեր գրանցվել են երկու դասընթացներում:\n\n  Օրինակ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) վերադարձնում է 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) վերադարձնում է 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize",
      "bn": "/*\n  কতজন ছাত্র-ছাত্রী উভয় কোর্স A এবং কোর্স B-তে ভর্তি হয়েছে তা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - n: কোর্স A-তে ভর্তি হওয়া ছাত্র-ছাত্রীদের সংখ্যা।\n  - m: কোর্স B-তে ভর্তি হওয়া ছাত্র-ছাত্রীদের সংখ্যা।\n  - a: কোর্স A-তে ভর্তি হওয়া ছাত্র-ছাত্রীদের আইডিসমূহ ধারণকারী একটি ভেক্টর।\n  - b: কোর্স B-তে ভর্তি হওয়া ছাত্র-ছাত্রীদের আইডিসমূহ ধারণকারী একটি ভেক্টর।\n\n  রিটার্ন করে:\n  - কতজন ছাত্র-ছাত্রী উভয় কোর্সে ভর্তি হয়েছে।\n\n  উদাহরণ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 রিটার্ন করে\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 রিটার্ন করে\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "bg": "/*\n  Брои броя на студентите, които са записани както в Курс A, така и в Курс B.\n\n  Аргументи:\n  - n: Броят на студентите, записани в Курс A.\n  - m: Броят на студентите, записани в Курс B.\n  - a: Вектор, съдържащ ID-тата на студентите, записани в Курс A.\n  - b: Вектор, съдържащ ID-тата на студентите, записани в Курс B.\n\n  Връща:\n  - Броят на студентите, които са записани и в двата курса.\n\n  Пример:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) връща 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) връща 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "zh": "/*\n  计算同时注册了课程A和课程B的学生人数。\n\n  参数：\n  - n: 注册课程A的学生人数。\n  - m: 注册课程B的学生人数。\n  - a: 包含注册课程A的学生ID的向量。\n  - b: 包含注册课程B的学生ID的向量。\n\n  返回：\n  - 同时注册了两个课程的学生人数。\n\n  示例：\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 返回 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 返回 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "fr": "/*\n  Compte le nombre d'étudiants inscrits à la fois au Cours A et au Cours B.\n\n  Arguments:\n  - n: Le nombre d'étudiants inscrits au Cours A.\n  - m: Le nombre d'étudiants inscrits au Cours B.\n  - a: Un vecteur contenant les identifiants des étudiants inscrits au Cours A.\n  - b: Un vecteur contenant les identifiants des étudiants inscrits au Cours B.\n\n  Retourne:\n  - Le nombre d'étudiants inscrits dans les deux cours.\n\n  Exemple:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) retourne 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) retourne 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "de": "/*\n  Zählt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n\n  Argumente:\n  - n: Die Anzahl der Studenten, die in Kurs A eingeschrieben sind.\n  - m: Die Anzahl der Studenten, die in Kurs B eingeschrieben sind.\n  - a: Ein Vektor, der die IDs der in Kurs A eingeschriebenen Studenten enthält.\n  - b: Ein Vektor, der die IDs der in Kurs B eingeschriebenen Studenten enthält.\n\n  Rückgabewert:\n  - Die Anzahl der Studenten, die in beiden Kursen eingeschrieben sind.\n\n  Beispiel:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) gibt 4 zurück\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) gibt 0 zurück\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "ha": "/*\n  Yana ƙididdige yawan ɗaliban da suka yi rijista a duka Course A da Course B.\n\n  Huɗɗa:\n  - n: Yawan ɗaliban da suka yi rijista a Course A.\n  - m: Yawan ɗaliban da suka yi rijista a Course B.\n  - a: Wata vector mai ɗauke da ID na ɗaliban da suka yi rijista a Course A.\n  - b: Wata vector mai ɗauke da ID na ɗaliban da suka yi rijista a Course B.\n\n  Komawa:\n  - Yawan ɗaliban da suka yi rijista a duka kwasa-kwasan.\n\n  Misali:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize ",
      "hi": "/*\n  उन छात्रों की संख्या गिनता है जिन्होंने कोर्स A और कोर्स B दोनों में नामांकन किया है।\n\n  तर्क:\n  - n: कोर्स A में नामांकित छात्रों की संख्या।\n  - m: कोर्स B में नामांकित छात्रों की संख्या।\n  - a: कोर्स A में नामांकित छात्रों के IDs को संग्रहीत करने वाला एक वेक्टर।\n  - b: कोर्स B में नामांकित छात्रों के IDs को संग्रहीत करने वाला एक वेक्टर।\n\n  लौटाता है:\n  - उन छात्रों की संख्या जो दोनों कोर्स में नामांकित हैं।\n\n  उदाहरण:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 4 लौटाता है\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 0 लौटाता है\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize",
      "hu": "/*\n  Megszámolja azon diákok számát, akik beiratkoztak mind az A, mind a B kurzusra.\n\n  Argumentumok:\n  - n: Az A kurzusra beiratkozott diákok száma.\n  - m: A B kurzusra beiratkozott diákok száma.\n  - a: Egy vektor, amely az A kurzusra beiratkozott diákok azonosítóit tartalmazza.\n  - b: Egy vektor, amely a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n\n  Visszatér:\n  - Azon diákok száma, akik mindkét kurzusra beiratkoztak.\n\n  Példa:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) visszatér 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) visszatér 0\n*/\nfn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize "
    },
    "prompt_bertscore": {
      "sq": "0.9892977950698402",
      "hy": "0.9982671485558516",
      "bn": "0.9756123604469175",
      "bg": "0.9982671485558516",
      "zh": "0.9646775593405659",
      "fr": "0.9813700593019757",
      "de": "0.9922035589139996",
      "ha": "0.9672820008966952",
      "hi": "0.970537552841857",
      "hu": "0.9953093435518611"
    },
    "canonical_solution": "{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}",
    "instruction": {
      "en": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nՀամառոտ բնական լեզվով նկարագրեք (docstring) Rust կոդը հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nনিচের Rust কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize\n{\n    let set_a: std::collections::HashSet<usize> = a.into_iter().collect();\n    let set_b: std::collections::HashSet<usize> = b.into_iter().collect();\n    set_a.intersection(&set_b).count()\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.8832303633794961",
      "bn": "0.8781885284176876",
      "bg": "0.8316696904400789",
      "zh": "0.8506108849451848",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9665526301375352",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]), 4);\n        assert_eq!(count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]), 0);\n        assert_eq!(count_students_enrolled_in_both(4, 4, vec![1, 3, 5, 7], vec![2, 4, 1, 3]), 2);\n    \n    }\n\n}",
    "entry_point": "count_students_enrolled_in_both",
    "signature": "fn count_students_enrolled_in_both(n: usize, m: usize, a: Vec<usize>, b: Vec<usize>) -> usize",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both Course A and Course B.\n\n  Arguments:\n  - n: The number of students enrolled in Course A.\n  - m: The number of students enrolled in Course B.\n  - a: A vector containing the IDs of students enrolled in Course A.\n  - b: A vector containing the IDs of students enrolled in Course B.\n\n  Returns:\n  - The number of students who are enrolled in both courses.\n\n  Example:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "sq": "Numëron numrin e studentëve që janë regjistruar në të dy Kursin A dhe Kursin B.\n\n  Argumentet:\n  - n: Numri i studentëve të regjistruar në Kursin A.\n  - m: Numri i studentëve të regjistruar në Kursin B.\n  - a: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin A.\n  - b: Një vektor që përmban ID-të e studentëve të regjistruar në Kursin B.\n\n  Kthen:\n  - Numri i studentëve që janë regjistruar në të dy kurset.\n\n  Shembull:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) kthen 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) kthen 0",
      "hy": "Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են ինչպես Դասընթաց A-ում, այնպես էլ Դասընթաց B-ում:\n\n  Արձանագրություններ:\n  - n: Ուսանողների քանակը, ովքեր գրանցվել են Դասընթաց A-ում:\n  - m: Ուսանողների քանակը, ովքեր գրանցվել են Դասընթաց B-ում:\n  - a: Վեկտոր, որը պարունակում է Դասընթաց A-ում գրանցված ուսանողների ID-ները:\n  - b: Վեկտոր, որը պարունակում է Դասընթաց B-ում գրանցված ուսանողների ID-ները:\n\n  Վերադարձնում է:\n  - Ուսանողների քանակը, ովքեր գրանցված են երկու դասընթացներում:\n\n  Օրինակ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) վերադարձնում է 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) վերադարձնում է 0",
      "bn": "কতজন শিক্ষার্থী কোর্স A এবং কোর্স B উভয়েই ভর্তি হয়েছে তা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - n: কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n  - m: কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n  - a: কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডিসমূহ ধারণকারী একটি ভেক্টর।\n  - b: কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডিসমূহ ধারণকারী একটি ভেক্টর।\n\n  রিটার্নস:\n  - উভয় কোর্সে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n\n  উদাহরণ:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) রিটার্ন করে 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) রিটার্ন করে 0",
      "bg": "Брои броя на студентите, които са записани както в Курс А, така и в Курс Б.\n\n  Аргументи:\n  - n: Броят на студентите, записани в Курс А.\n  - m: Броят на студентите, записани в Курс Б.\n  - a: Вектор, съдържащ идентификаторите на студентите, записани в Курс А.\n  - b: Вектор, съдържащ идентификаторите на студентите, записани в Курс Б.\n\n  Връща:\n  - Броят на студентите, които са записани и в двата курса.\n\n  Пример:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) връща 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) връща 0",
      "zh": "计算同时注册了课程A和课程B的学生人数。\n\n  参数:\n  - n: 注册课程A的学生人数。\n  - m: 注册课程B的学生人数。\n  - a: 包含注册课程A的学生ID的向量。\n  - b: 包含注册课程B的学生ID的向量。\n\n  返回:\n  - 同时注册了两个课程的学生人数。\n\n  示例:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) 返回 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) 返回 0",
      "fr": "Compte le nombre d'étudiants qui se sont inscrits à la fois au Cours A et au Cours B.\n\n  Arguments:\n  - n: Le nombre d'étudiants inscrits au Cours A.\n  - m: Le nombre d'étudiants inscrits au Cours B.\n  - a: Un vecteur contenant les identifiants des étudiants inscrits au Cours A.\n  - b: Un vecteur contenant les identifiants des étudiants inscrits au Cours B.\n\n  Renvoie:\n  - Le nombre d'étudiants qui sont inscrits aux deux cours.\n\n  Exemple:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) renvoie 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) renvoie 0",
      "de": "Zählt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n\n  Argumente:\n  - n: Die Anzahl der Studenten, die in Kurs A eingeschrieben sind.\n  - m: Die Anzahl der Studenten, die in Kurs B eingeschrieben sind.\n  - a: Ein Vektor, der die IDs der in Kurs A eingeschriebenen Studenten enthält.\n  - b: Ein Vektor, der die IDs der in Kurs B eingeschriebenen Studenten enthält.\n\n  Rückgabewert:\n  - Die Anzahl der Studenten, die in beiden Kursen eingeschrieben sind.\n\n  Beispiel:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) gibt 4 zurück\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) gibt 0 zurück",
      "ha": "Yana ƙididdige adadin ɗaliban da suka yi rijista a duka Course A da Course B.\n\n  Huɗɗa:\n  - n: Yawan ɗaliban da suka yi rajista a Course A.\n  - m: Yawan ɗaliban da suka yi rajista a Course B.\n  - a: Wata vector da ke ɗauke da ID na ɗaliban da suka yi rajista a Course A.\n  - b: Wata vector da ke ɗauke da ID na ɗaliban da suka yi rajista a Course B.\n\n  Komawa:\n  - Yawan ɗaliban da suka yi rajista a duka kwasa-kwasan.\n\n  Misali:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "hi": "उन छात्रों की संख्या गिनता है जिन्होंने दोनों कोर्स A और कोर्स B में नामांकन किया है।\n\n  तर्क:\n  - n: कोर्स A में नामांकित छात्रों की संख्या।\n  - m: कोर्स B में नामांकित छात्रों की संख्या।\n  - a: एक वेक्टर जिसमें कोर्स A में नामांकित छात्रों के आईडी शामिल हैं।\n  - b: एक वेक्टर जिसमें कोर्स B में नामांकित छात्रों के आईडी शामिल हैं।\n\n  प्रत्यावर्तन:\n  - उन छात्रों की संख्या जो दोनों पाठ्यक्रमों में नामांकित हैं।\n\n  उदाहरण:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) returns 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) returns 0",
      "hu": "Számolja meg azoknak a diákoknak a számát, akik beiratkoztak mind az A, mind a B kurzusra.\n\n  Argumentumok:\n  - n: Az A kurzusra beiratkozott diákok száma.\n  - m: A B kurzusra beiratkozott diákok száma.\n  - a: Egy vektor, amely az A kurzusra beiratkozott diákok azonosítóit tartalmazza.\n  - b: Egy vektor, amely a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n\n  Visszatérési érték:\n  - Azoknak a diákoknak a száma, akik mindkét kurzusra beiratkoztak.\n\n  Példa:\n  - count_students_enrolled_in_both(5, 5, vec![1, 2, 3, 4, 5], vec![1, 3, 4, 5, 6]) visszaadja 4\n  - count_students_enrolled_in_both(3, 2, vec![7, 8, 9], vec![10, 11]) visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9977238944637212",
      "hy": "0.9977238944637212",
      "bn": "0.9930586627043548",
      "bg": "0.9977238944637212",
      "zh": "0.970292244321279",
      "fr": "1",
      "de": "0.9911849823200527",
      "ha": "0.9627230363911825",
      "hi": "0.9906206734075326",
      "hu": "0.9863366133493721"
    }
  },
  {
    "task_id": "Rust/51",
    "prompt": {
      "en": "/*\n  Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "sq": "/*\n  Llogarit fitimet totale të Deliv-e-droid bazuar në numrin e dorëzimeve të suksesshme dhe dështimeve.\n  Deliv-e-droid fiton 50 njësi parash për çdo dorëzim të suksesshëm dhe humbet 10 njësi për çdo dështim.\n  Për më tepër, nëse numri i dorëzimeve të suksesshme është më i madh se ai i dështimeve, Deliv-e-droid merr një bonus prej 500 njësish.\n\n  Argumentet:\n  - delivered: Numri i pakove të dorëzuara me sukses (0 <= delivered <= 100).\n  - failed: Numri i dorëzimeve të dështuara (0 <= failed <= 100).\n\n  Kthen:\n  - Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n\n  Shembuj:\n  - calculate_droid_earnings(5, 2) kthen 730.\n  - calculate_droid_earnings(0, 10) kthen -100.\n  - calculate_droid_earnings(10, 5) kthen 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "hy": "/*\n  Հաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնված հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա:\n  Deliv-e-droid-ը վաստակում է 50 միավոր գումար յուրաքանչյուր հաջողությամբ առաքման համար և կորցնում է 10 միավոր յուրաքանչյուր ձախողված առաքման համար:\n  Բացի այդ, եթե հաջողությամբ առաքումների քանակը գերազանցում է ձախողվածների քանակը, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս:\n\n  Արգումենտներ:\n  - delivered: Հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100):\n  - failed: Ձախողված առաքումների քանակը (0 <= failed <= 100):\n\n  Վերադարձնում է:\n  - Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները:\n\n  Օրինակներ:\n  - calculate_droid_earnings(5, 2) վերադարձնում է 730:\n  - calculate_droid_earnings(0, 10) վերադարձնում է -100:\n  - calculate_droid_earnings(10, 5) վերադարձնում է 950:\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "bn": "/*\n  Deliv-e-droid এর মোট উপার্জন হিসাব করে সফলভাবে বিতরণ করা এবং ব্যর্থ বিতরণের সংখ্যার উপর ভিত্তি করে।\n  Deliv-e-droid প্রতিটি সফল বিতরণের জন্য 50 ইউনিট অর্থ উপার্জন করে এবং প্রতিটি ব্যর্থ বিতরণের জন্য 10 ইউনিট হারায়।\n  অতিরিক্তভাবে, যদি সফল বিতরণের সংখ্যা ব্যর্থগুলোর চেয়ে বেশি হয়, তাহলে Deliv-e-droid 500 ইউনিট বোনাস পায়।\n\n  আর্গুমেন্টসমূহ:\n  - delivered: সফলভাবে বিতরণ করা প্যাকেজের সংখ্যা (0 <= delivered <= 100)।\n  - failed: ব্যর্থ বিতরণের সংখ্যা (0 <= failed <= 100)।\n\n  রিটার্নস:\n  - Deliv-e-droid এর মোট উপার্জন, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভের চেয়ে বেশি হয়।\n\n  উদাহরণসমূহ:\n  - calculate_droid_earnings(5, 2) 730 রিটার্ন করে।\n  - calculate_droid_earnings(0, 10) -100 রিটার্ন করে।\n  - calculate_droid_earnings(10, 5) 950 রিটার্ন করে।\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "bg": "/*\n  Изчислява общите приходи на Deliv-e-droid въз основа на броя успешно доставени и неуспешни доставки.\n  Deliv-e-droid печели 50 единици пари за всяка успешна доставка и губи 10 единици за всяка неуспешна доставка.\n  Освен това, ако броят на успешните доставки е по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n\n  Аргументи:\n  - delivered: Броят на успешно доставените пакети (0 <= delivered <= 100).\n  - failed: Броят на неуспешните доставки (0 <= failed <= 100).\n\n  Връща:\n  - Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n\n  Примери:\n  - calculate_droid_earnings(5, 2) връща 730.\n  - calculate_droid_earnings(0, 10) връща -100.\n  - calculate_droid_earnings(10, 5) връща 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "zh": "/*\n  计算Deliv-e-droid基于成功交付和失败交付的数量的总收入。\n  Deliv-e-droid每成功交付一次赚取50个单位的金钱，每失败交付一次损失10个单位。\n  另外，如果成功交付的数量大于失败的数量，Deliv-e-droid会获得500个单位的奖金。\n\n  参数:\n  - delivered: 成功交付的包裹数量 (0 <= delivered <= 100)。\n  - failed: 失败交付的数量 (0 <= failed <= 100)。\n\n  返回:\n  - Deliv-e-droid的总收入，如果损失超过收益，可能为负。\n\n  示例:\n  - calculate_droid_earnings(5, 2) 返回 730。\n  - calculate_droid_earnings(0, 10) 返回 -100。\n  - calculate_droid_earnings(10, 5) 返回 950。\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "fr": "/*\n  Calcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies et échouées.\n  Deliv-e-droid gagne 50 unités d'argent pour chaque livraison réussie et perd 10 unités pour chaque livraison échouée.\n  De plus, si le nombre de livraisons réussies est supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n\n  Arguments:\n  - delivered: Le nombre de colis livrés avec succès (0 <= delivered <= 100).\n  - failed: Le nombre de livraisons échouées (0 <= failed <= 100).\n\n  Retourne:\n  - Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n\n  Exemples:\n  - calculate_droid_earnings(5, 2) retourne 730.\n  - calculate_droid_earnings(0, 10) retourne -100.\n  - calculate_droid_earnings(10, 5) retourne 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "de": "/*\n  Berechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten und fehlgeschlagenen Lieferungen.\n  Deliv-e-droid verdient 50 Geldeinheiten für jede erfolgreiche Lieferung und verliert 10 Einheiten für jede fehlgeschlagene Lieferung.\n  Zusätzlich erhält Deliv-e-droid einen Bonus von 500 Einheiten, wenn die Anzahl der erfolgreichen Lieferungen größer ist als die der fehlgeschlagenen.\n\n  Argumente:\n  - delivered: Die Anzahl der erfolgreich zugestellten Pakete (0 <= delivered <= 100).\n  - failed: Die Anzahl der fehlgeschlagenen Lieferungen (0 <= failed <= 100).\n\n  Rückgabewert:\n  - Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne überwiegen.\n\n  Beispiele:\n  - calculate_droid_earnings(5, 2) gibt 730 zurück.\n  - calculate_droid_earnings(0, 10) gibt -100 zurück.\n  - calculate_droid_earnings(10, 5) gibt 950 zurück.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "ha": "/*\n  Lissafa jimillar kudaden shiga na Deliv-e-droid bisa ga yawan isar da aka yi nasara da kuma yawan isar da aka kasa yi.\n  Deliv-e-droid yana samun 50 raka'a na kudi don kowane isar da aka yi nasara kuma yana rasa 10 raka'a don kowane isar da aka kasa yi.\n  Bugu da ƙari, idan yawan isar da aka yi nasara ya fi yawan waɗanda aka kasa yi, Deliv-e-droid yana samun kari na 500 raka'a.\n\n  Huɗɗa:\n  - delivered: Yawan fakitoci da aka isar da nasara (0 <= delivered <= 100).\n  - failed: Yawan isar da aka kasa yi (0 <= failed <= 100).\n\n  Komawa:\n  - Jimillar kudaden shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi ribar.\n\n  Misalai:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "hi": "/*\n  Deliv-e-droid की कुल कमाई की गणना करता है जो सफलतापूर्वक वितरित और असफल डिलीवरी की संख्या पर आधारित है।\n  Deliv-e-droid प्रत्येक सफल डिलीवरी के लिए 50 यूनिट पैसा कमाता है और प्रत्येक असफल डिलीवरी के लिए 10 यूनिट खोता है।\n  इसके अतिरिक्त, यदि सफल डिलीवरी की संख्या असफल डिलीवरी से अधिक है, तो Deliv-e-droid को 500 यूनिट का बोनस मिलता है।\n\n  तर्क:\n  - delivered: सफलतापूर्वक वितरित पैकेजों की संख्या (0 <= delivered <= 100)।\n  - failed: असफल डिलीवरी की संख्या (0 <= failed <= 100)।\n\n  लौटाता है:\n  - Deliv-e-droid की कुल कमाई, जो नकारात्मक हो सकती है यदि नुकसान लाभ से अधिक हो।\n\n  उदाहरण:\n  - calculate_droid_earnings(5, 2) 730 लौटाता है।\n  - calculate_droid_earnings(0, 10) -100 लौटाता है।\n  - calculate_droid_earnings(10, 5) 950 लौटाता है।\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 ",
      "hu": "/*\n  Kiszámítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és a sikertelen kézbesítések száma alapján.\n  A Deliv-e-droid 50 egységnyi pénzt keres minden sikeres kézbesítésért, és 10 egységet veszít minden sikertelen kézbesítésért.\n  Továbbá, ha a sikeres kézbesítések száma nagyobb, mint a sikerteleneké, a Deliv-e-droid 500 egységnyi bónuszt kap.\n\n  Argumentumok:\n  - delivered: A sikeresen kézbesített csomagok száma (0 <= delivered <= 100).\n  - failed: A sikertelen kézbesítések száma (0 <= failed <= 100).\n\n  Visszatér:\n  - A Deliv-e-droid összes bevétele, amely negatív is lehet, ha a veszteségek meghaladják a nyereségeket.\n\n  Példák:\n  - calculate_droid_earnings(5, 2) visszatér 730.\n  - calculate_droid_earnings(0, 10) visszatér -100.\n  - calculate_droid_earnings(10, 5) visszatér 950.\n*/\n\nfn calculate_droid_earnings(delivered: i32, failed: i32) -> i32 "
    },
    "prompt_bertscore": {
      "sq": "0.9710533959414047",
      "hy": "0.982236882284812",
      "bn": "0.9885241297357094",
      "bg": "0.9894751720001044",
      "zh": "0.9722364384908485",
      "fr": "0.9938468280563012",
      "de": "0.9807543051207677",
      "ha": "0.976315909256543",
      "hi": "0.9790989195252229",
      "hu": "0.9980836140837754"
    },
    "canonical_solution": "{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}",
    "instruction": {
      "en": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nরাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nПредоставете кратко описание на Rust кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\n请用中文为以下 Rust 代码提供一个简洁的自然语言描述（文档字符串），字数不超过 500 个字符。",
      "fr": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Rust cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32\n{\n    let earnings_per_delivery = 50;\n    let loss_per_failure = 10;\n    let bonus = if delivered > failed { 500 } else { 0 };\n\n    (delivered * earnings_per_delivery) - (failed * loss_per_failure) + bonus\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.950068890706593",
      "bn": "0.9071935298083071",
      "bg": "0.8316696904400789",
      "zh": "0.8627098587147819",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9361141132869868",
      "hi": "0.9115359871984918",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(calculate_droid_earnings(5, 2), 730);\n        assert_eq!(calculate_droid_earnings(0, 10), -100);\n        assert_eq!(calculate_droid_earnings(10, 5), 950);\n        assert_eq!(calculate_droid_earnings(3, 3), 120);\n    }\n    \n\n}",
    "entry_point": "calculate_droid_earnings",
    "signature": "fn calculate_droid_earnings(delivered: i32, failed: i32) -> i32",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n  Arguments:\n  - delivered: The number of successfully delivered packages (0 <= delivered <= 100).\n  - failed: The number of failed deliveries (0 <= failed <= 100).\n\n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730.\n  - calculate_droid_earnings(0, 10) returns -100.\n  - calculate_droid_earnings(10, 5) returns 950.",
      "sq": "Llogarit fitimet totale të Deliv-e-droid bazuar në numrin e dorëzimeve të suksesshme dhe të dështuara.\n  Deliv-e-droid fiton 50 njësi parash për çdo dorëzim të suksesshëm dhe humb 10 njësi për çdo dorëzim të dështuar.\n  Për më tepër, nëse numri i dorëzimeve të suksesshme është më i madh se ai i dështimeve, Deliv-e-droid merr një bonus prej 500 njësish.\n\n  Argumentet:\n  - delivered: Numri i pakove të dorëzuara me sukses (0 <= delivered <= 100).\n  - failed: Numri i dorëzimeve të dështuara (0 <= failed <= 100).\n\n  Kthen:\n  - Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n\n  Shembuj:\n  - calculate_droid_earnings(5, 2) kthen 730.\n  - calculate_droid_earnings(0, 10) kthen -100.\n  - calculate_droid_earnings(10, 5) kthen 950.",
      "hy": "Հաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնվելով հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա։  \nDeliv-e-droid-ը վաստակում է 50 միավոր գումար յուրաքանչյուր հաջողված առաքման համար և կորցնում է 10 միավոր յուրաքանչյուր ձախողված առաքման համար։  \nԲացի այդ, եթե հաջողությամբ առաքումների քանակը գերազանցում է ձախողվածներին, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս։\n\nԱրձանագրություններ:\n- delivered: Հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100)։\n- failed: Ձախողված առաքումների քանակը (0 <= failed <= 100)։\n\nՎերադարձնում է:\n- Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները։\n\nՕրինակներ:\n- calculate_droid_earnings(5, 2) վերադարձնում է 730։\n- calculate_droid_earnings(0, 10) վերադարձնում է -100։\n- calculate_droid_earnings(10, 5) վերադարձնում է 950։",
      "bn": "Deliv-e-droid-এর মোট উপার্জন গণনা করে সফলভাবে বিতরণকৃত এবং ব্যর্থ বিতরণের সংখ্যার উপর ভিত্তি করে।\n  Deliv-e-droid প্রতিটি সফল বিতরণের জন্য ৫০ ইউনিট অর্থ উপার্জন করে এবং প্রতিটি ব্যর্থ বিতরণের জন্য ১০ ইউনিট হারায়।\n  অতিরিক্তভাবে, যদি সফল বিতরণের সংখ্যা ব্যর্থগুলোর চেয়ে বেশি হয়, তাহলে Deliv-e-droid ৫০০ ইউনিট বোনাস পায়।\n\n  Arguments:\n  - delivered: সফলভাবে বিতরণকৃত প্যাকেজের সংখ্যা (0 <= delivered <= 100)।\n  - failed: ব্যর্থ বিতরণের সংখ্যা (0 <= failed <= 100)।\n\n  Returns:\n  - Deliv-e-droid-এর মোট উপার্জন, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভের চেয়ে বেশি হয়।\n\n  Examples:\n  - calculate_droid_earnings(5, 2) returns 730।\n  - calculate_droid_earnings(0, 10) returns -100।\n  - calculate_droid_earnings(10, 5) returns 950।",
      "bg": "Изчислява общите приходи на Deliv-e-droid въз основа на броя успешно доставени и неуспешни доставки.\n  Deliv-e-droid печели 50 единици пари за всяка успешна доставка и губи 10 единици за всяка неуспешна доставка.\n  Освен това, ако броят на успешните доставки е по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n\n  Аргументи:\n  - delivered: Броят на успешно доставените пакети (0 <= delivered <= 100).\n  - failed: Броят на неуспешните доставки (0 <= failed <= 100).\n\n  Връща:\n  - Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n\n  Примери:\n  - calculate_droid_earnings(5, 2) връща 730.\n  - calculate_droid_earnings(0, 10) връща -100.\n  - calculate_droid_earnings(10, 5) връща 950.",
      "zh": "计算 Deliv-e-droid 的总收入，基于成功交付和失败交付的数量。\nDeliv-e-droid 每成功交付一个包裹赚取 50 单位的钱，每失败交付一个包裹损失 10 单位的钱。\n另外，如果成功交付的数量大于失败交付的数量，Deliv-e-droid 将获得 500 单位的奖金。\n\n参数:\n- delivered: 成功交付的包裹数量 (0 <= delivered <= 100)。\n- failed: 失败交付的数量 (0 <= failed <= 100)。\n\n返回:\n- Deliv-e-droid 的总收入，如果损失超过收益，则可能为负数。\n\n示例:\n- calculate_droid_earnings(5, 2) 返回 730。\n- calculate_droid_earnings(0, 10) 返回 -100。\n- calculate_droid_earnings(10, 5) 返回 950。",
      "fr": "Calcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies et échouées.\n  Deliv-e-droid gagne 50 unités d'argent pour chaque livraison réussie et perd 10 unités pour chaque livraison échouée.\n  De plus, si le nombre de livraisons réussies est supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n\n  Arguments:\n  - delivered: Le nombre de colis livrés avec succès (0 <= delivered <= 100).\n  - failed: Le nombre de livraisons échouées (0 <= failed <= 100).\n\n  Retourne:\n  - Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n\n  Exemples:\n  - calculate_droid_earnings(5, 2) retourne 730.\n  - calculate_droid_earnings(0, 10) retourne -100.\n  - calculate_droid_earnings(10, 5) retourne 950.",
      "de": "Berechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten und fehlgeschlagenen Lieferungen.\n  Deliv-e-droid verdient 50 Geldeinheiten für jede erfolgreiche Lieferung und verliert 10 Einheiten für jede fehlgeschlagene Lieferung.\n  Zusätzlich erhält Deliv-e-droid einen Bonus von 500 Einheiten, wenn die Anzahl der erfolgreichen Lieferungen größer ist als die der fehlgeschlagenen.\n\n  Argumente:\n  - delivered: Die Anzahl der erfolgreich zugestellten Pakete (0 <= delivered <= 100).\n  - failed: Die Anzahl der fehlgeschlagenen Lieferungen (0 <= failed <= 100).\n\n  Rückgabewerte:\n  - Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne übersteigen.\n\n  Beispiele:\n  - calculate_droid_earnings(5, 2) gibt 730 zurück.\n  - calculate_droid_earnings(0, 10) gibt -100 zurück.\n  - calculate_droid_earnings(10, 5) gibt 950 zurück.",
      "ha": "Lissafa jimillar kudaden shiga na Deliv-e-droid bisa ga adadin nasarorin da aka kai da kuma wadanda suka kasa.\n  Deliv-e-droid yana samun 50 raka'a na kudi don kowane nasarar da aka kai kuma yana rasa 10 raka'a don kowane rashin nasara.\n  Bugu da ƙari, idan adadin nasarorin da aka kai ya fi yawan wadanda suka kasa, Deliv-e-droid yana samun kari na 500 raka'a.\n\n  Huɗɗa:\n  - delivered: Adadin fakitin da aka kai nasara (0 <= delivered <= 100).\n  - failed: Adadin rashin nasarorin da aka yi (0 <= failed <= 100).\n\n  Dawowa:\n  - Jimillar kudaden shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi riba.\n\n  Misalai:\n  - calculate_droid_earnings(5, 2) yana dawowa 730.\n  - calculate_droid_earnings(0, 10) yana dawowa -100.\n  - calculate_droid_earnings(10, 5) yana dawowa 950.",
      "hi": "Deliv-e-droid की कुल कमाई की गणना करता है जो सफलतापूर्वक वितरित और असफल डिलीवरी की संख्या पर आधारित है। \nDeliv-e-droid प्रत्येक सफल डिलीवरी के लिए 50 इकाइयों की कमाई करता है और प्रत्येक असफल डिलीवरी के लिए 10 इकाइयाँ खोता है। \nअतिरिक्त रूप से, यदि सफल डिलीवरी की संख्या असफल डिलीवरी की संख्या से अधिक है, तो Deliv-e-droid को 500 इकाइयों का बोनस मिलता है।\n\nतर्क:\n- delivered: सफलतापूर्वक वितरित पैकेजों की संख्या (0 <= delivered <= 100)।\n- failed: असफल डिलीवरी की संख्या (0 <= failed <= 100)।\n\nवापसी:\n- Deliv-e-droid की कुल कमाई, जो नकारात्मक हो सकती है यदि नुकसान लाभ से अधिक हो।\n\nउदाहरण:\n- calculate_droid_earnings(5, 2) 730 लौटाता है।\n- calculate_droid_earnings(0, 10) -100 लौटाता है।\n- calculate_droid_earnings(10, 5) 950 लौटाता है।",
      "hu": "Számítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és a sikertelen kézbesítések száma alapján. \nA Deliv-e-droid 50 pénzegységet keres minden sikeres kézbesítésért, és 10 pénzegységet veszít minden sikertelen kézbesítésért. \nTovábbá, ha a sikeres kézbesítések száma meghaladja a sikertelenek számát, a Deliv-e-droid 500 egység bónuszt kap.\n\nÉrvek:\n- delivered: A sikeresen kézbesített csomagok száma (0 <= delivered <= 100).\n- failed: A sikertelen kézbesítések száma (0 <= failed <= 100).\n\nVisszatér:\n- A Deliv-e-droid összes bevétele, amely negatív is lehet, ha a veszteségek meghaladják a nyereségeket.\n\nPéldák:\n- calculate_droid_earnings(5, 2) visszatér 730.\n- calculate_droid_earnings(0, 10) visszatér -100.\n- calculate_droid_earnings(10, 5) visszatér 950."
    },
    "docstring_bertscore": {
      "sq": "0.9754006204607343",
      "hy": "0.976725286471856",
      "bn": "0.9815553814474813",
      "bg": "0.9891523976309227",
      "zh": "0.9662074105352966",
      "fr": "0.9927680664569007",
      "de": "0.985339687466958",
      "ha": "0.9925575182530038",
      "hi": "0.9877544370091992",
      "hu": "0.9788160698626291"
    }
  },
  {
    "task_id": "Rust/52",
    "prompt": {
      "en": "/*\n  Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "sq": "/*\n  Gjen ID-të që mungojnë dhe ID-të e dyfishta nga një seri sekuencash ID-sh.\n  Çdo sekuencë e ID-ve përfaqësohet si një vektor brenda një vektori më të madh, duke simuluar formatin e hyrjes të përshkruar.\n  ID-të supozohet të jenë pjesë e një diapazoni të vazhdueshëm, por me një ID që mungon dhe një ID të dyfishtë.\n  Funksioni identifikon dhe kthen si ID-në që mungon (që është anashkaluar) ashtu edhe ID-në e dyfishtë (që shfaqet më shumë se një herë).\n\n  Argumentet:\n  - data: Një vektor vektorësh, ku çdo vektor i brendshëm përmban një sekuencë numrash ID.\n\n  Kthen:\n  - Një dyshe që përmban dy vlera usize: e para është ID-ja që mungon, dhe e dyta është ID-ja e dyfishtë.\n\n  Shembull:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) kthen (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "hy": "/*\n  Գտնում է բացակայող և կրկնվող ID համարները ID հաջորդականությունների շարքից:\n  ID-ների յուրաքանչյուր հաջորդականություն ներկայացված է որպես վեկտոր ավելի մեծ վեկտորի մեջ, որը մոդելավորում է նկարագրված մուտքի ձևաչափը:\n  ID-ները ենթադրվում են, որ մաս են կազմում անընդհատ տիրույթի, բայց մեկ բացակայող ID-ով և մեկ կրկնվող ID-ով:\n  Ֆունկցիան հայտնաբերում և վերադարձնում է և՛ բացակայող ID-ն (որը բաց է թողնվել), և՛ կրկնվող ID-ն (որը հայտնվում է մեկից ավելի անգամ):\n\n  Արգումենտներ:\n  - data: Վեկտոր վեկտորների, որտեղ յուրաքանչյուր ներքին վեկտոր պարունակում է ID համարների հաջորդականություն:\n\n  Վերադարձնում է.\n  - Զույգ, որը պարունակում է երկու usize արժեքներ: առաջինը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնվող ID-ն:\n\n  Օրինակ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) վերադարձնում է (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "bn": "/*\n  ID নম্বরগুলির একটি সিরিজ থেকে অনুপস্থিত এবং সদৃশ ID নম্বরগুলি খুঁজে বের করে।\n  প্রতিটি ID এর ক্রম একটি বৃহত্তর ভেক্টরের মধ্যে একটি ভেক্টর হিসাবে উপস্থাপিত হয়, বর্ণিত ইনপুট ফরম্যাট অনুকরণ করে।\n  ID গুলি একটি ধারাবাহিক পরিসরের অংশ হিসাবে অনুমান করা হয় তবে একটি অনুপস্থিত ID এবং একটি সদৃশ ID সহ।\n  ফাংশনটি উভয় অনুপস্থিত ID (যা বাদ দেওয়া হয়েছে) এবং সদৃশ ID (যা একাধিকবার প্রদর্শিত হয়েছে) সনাক্ত করে এবং ফেরত দেয়।\n\n  আর্গুমেন্টসমূহ:\n  - data: একটি ভেক্টরের ভেক্টর, যেখানে প্রতিটি অভ্যন্তরীণ ভেক্টরে ID নম্বরের একটি ক্রম থাকে।\n\n  রিটার্নস:\n  - একটি টিউপল যা দুটি usize মান ধারণ করে: প্রথমটি অনুপস্থিত ID, এবং দ্বিতীয়টি সদৃশ ID।\n\n  উদাহরণ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) ফেরত দেয়\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "bg": "/*\n  Намира липсващите и дублиращите се ID номера от серия ID последователности.\n  Всяка последователност от ID е представена като вектор в по-голям вектор, симулирайки описания формат на входните данни.\n  Предполага се, че ID-тата са част от непрекъснат диапазон, но с едно липсващо ID и едно дублирано ID.\n  Функцията идентифицира и връща както липсващото ID (което е пропуснато), така и дублираното ID (което се появява повече от веднъж).\n\n  Аргументи:\n  - data: Вектор от вектори, където всеки вътрешен вектор съдържа последователност от ID номера.\n\n  Връща:\n  - Кортеж, съдържащ две стойности от тип usize: първата е липсващото ID, а втората е дублираното ID.\n\n  Пример:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) връща (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "zh": "/*\n  查找ID序列中缺失和重复的ID号。\n  每个ID序列表示为一个较大向量中的一个向量，模拟描述的输入格式。\n  假设ID是连续范围的一部分，但有一个缺失ID和一个重复ID。\n  该函数识别并返回缺失的ID（被跳过的）和重复的ID（出现多次的）。\n\n  参数:\n  - data: 一个向量的向量，其中每个内部向量包含一系列ID号。\n\n  返回:\n  - 一个包含两个usize值的元组：第一个是缺失的ID，第二个是重复的ID。\n\n  示例:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) 返回 (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "fr": "/*\n  Trouve les numéros d'identification manquants et en double à partir d'une série de séquences d'identification.\n  Chaque séquence d'identifiants est représentée comme un vecteur au sein d'un vecteur plus grand, simulant le format d'entrée décrit.\n  Les identifiants sont supposés faire partie d'une plage continue mais avec un identifiant manquant et un identifiant en double.\n  La fonction identifie et retourne à la fois l'identifiant manquant (qui a été sauté) et l'identifiant en double (qui apparaît plus d'une fois).\n\n  Arguments:\n  - data: Un vecteur de vecteurs, où chaque vecteur interne contient une séquence de numéros d'identification.\n\n  Renvoie:\n  - Un tuple contenant deux valeurs usize: la première est l'identifiant manquant, et la seconde est l'identifiant en double.\n\n  Exemple:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "de": "/*\n  Findet die fehlenden und doppelten ID-Nummern aus einer Reihe von ID-Sequenzen.\n  Jede Sequenz von IDs wird als Vektor innerhalb eines größeren Vektors dargestellt, was das beschriebene Eingabeformat simuliert.\n  Es wird angenommen, dass die IDs Teil eines kontinuierlichen Bereichs sind, jedoch mit einer fehlenden ID und einer doppelten ID.\n  Die Funktion identifiziert und gibt sowohl die fehlende ID (die übersprungen wurde) als auch die doppelte ID (die mehr als einmal erscheint) zurück.\n\n  Argumente:\n  - data: Ein Vektor von Vektoren, wobei jeder innere Vektor eine Sequenz von ID-Nummern enthält.\n\n  Rückgabe:\n  - Ein Tupel, das zwei usize-Werte enthält: der erste ist die fehlende ID, und der zweite ist die doppelte ID.\n\n  Beispiel:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) gibt (7, 9) zurück\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "ha": "/*\n  Nemi lambobin ID da suka ɓace da waɗanda aka maimaita daga jerin lambobin ID.\n  Kowace jeri na lambobin ID ana wakilta ta a matsayin vector cikin babban vector, yana kwaikwayon tsarin shigarwa da aka bayyana.\n  Ana ɗauka cewa lambobin ID suna cikin kewayon ci gaba amma tare da ɗaya ID da ya ɓace da ɗaya ID da aka maimaita.\n  Aikin yana gano kuma yana dawo da duka ID da ya ɓace (wanda aka tsallake) da ID da aka maimaita (wanda ya bayyana fiye da sau ɗaya).\n\n  Huɗɗa:\n  - data: Vector na vectors, inda kowace vector ta ciki ke ɗauke da jerin lambobin ID.\n\n  Komawa:\n  - Tuple mai ɗauke da ƙimomi biyu na usize: na farko shine ID da ya ɓace, na biyu kuma shine ID da aka maimaita.\n\n  Misali:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "hi": "/*\n  ID संख्याओं की श्रृंखला से गायब और डुप्लिकेट ID नंबर खोजता है।\n  ID की प्रत्येक श्रृंखला को एक बड़े वेक्टर के भीतर एक वेक्टर के रूप में दर्शाया गया है, जैसा कि वर्णित इनपुट प्रारूप का अनुकरण करता है।\n  यह माना जाता है कि ID एक सतत श्रेणी का हिस्सा हैं लेकिन एक गायब ID और एक डुप्लिकेट ID के साथ।\n  यह फ़ंक्शन दोनों को पहचानता है और लौटाता है: गायब ID (जो छोड़ी गई है) और डुप्लिकेट ID (जो एक से अधिक बार दिखाई देती है)।\n\n  तर्क:\n  - data: वेक्टर का एक वेक्टर, जहाँ प्रत्येक आंतरिक वेक्टर में ID संख्याओं की एक श्रृंखला होती है।\n\n  लौटाता है:\n  - एक टपल जिसमें दो usize मान होते हैं: पहला गायब ID है, और दूसरा डुप्लिकेट ID है।\n\n  उदाहरण:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) (7, 9) लौटाता है\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) ",
      "hu": "/*\n  Megkeresi a hiányzó és duplikált azonosító számokat az azonosító sorozatokból.\n  Minden azonosító sorozat egy vektorként van ábrázolva egy nagyobb vektoron belül, szimulálva a leírt bemeneti formátumot.\n  Feltételezzük, hogy az azonosítók egy folyamatos tartomány részét képezik, de egy hiányzó azonosítóval és egy duplikált azonosítóval.\n  A függvény azonosítja és visszaadja mind a hiányzó azonosítót (amelyet kihagytak), mind a duplikált azonosítót (amely többször jelenik meg).\n\n  Argumentumok:\n  - data: Vektorok vektora, ahol minden belső vektor egy azonosító számokból álló sorozatot tartalmaz.\n\n  Visszatér:\n  - Egy tuple, amely két usize értéket tartalmaz: az első a hiányzó azonosító, a második a duplikált azonosító.\n\n  Példa:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) visszatér (7, 9)\n*/\nfn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize) "
    },
    "prompt_bertscore": {
      "sq": "0.9881431566648844",
      "hy": "0.9777482329341857",
      "bn": "0.9832012327847364",
      "bg": "0.9761073473564564",
      "zh": "0.9599537316187942",
      "fr": "0.9741782490958456",
      "de": "0.9797287764634844",
      "ha": "0.9451156448947259",
      "hi": "0.9824051222175486",
      "hu": "0.9559586787650394"
    },
    "canonical_solution": "{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}",
    "instruction": {
      "en": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nনিচের রাস্ট কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nПредоставете кратко описание на Rust кода на български език, използвайки най-много 500 знака.",
      "zh": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\n请用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Rust a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nहिंदी में अधिकतम 500 वर्णों का उपयोग करके Rust कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) प्रदान करें।",
      "hu": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)\n{\n    let mut all_ids = data.into_iter().flatten().collect::<Vec<_>>();\n    all_ids.sort_unstable();\n    let mut missing = 0;\n    let mut duplicate = 0;\n    \n    for i in 1..all_ids.len() {\n        if all_ids[i] == all_ids[i-1] {\n            duplicate = all_ids[i];\n        } else if all_ids[i] - all_ids[i-1] > 1 {\n            missing = all_ids[i-1] + 1;\n        }\n    }\n    \n    (missing, duplicate)\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9397160766166736",
      "hy": "0.9423368058640478",
      "bn": "0.8772950889637926",
      "bg": "0.8449290628956817",
      "zh": "0.8780246583533338",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9665526301375352",
      "hi": "0.9586012573543276",
      "hu": "0.9407390230790031"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]), (7, 9));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 2, 4, 7], vec![5, 3, 3]]), (6, 3));\n        assert_eq!(find_missing_and_duplicate_ids(vec![vec![1, 1, 3, 4, 5]]), (2, 1)); // Edge case with minimal input\n    \n    }\n    \n\n}",
    "entry_point": "find_missing_and_duplicate_ids",
    "signature": "fn find_missing_and_duplicate_ids(data: Vec<Vec<usize>>) -> (usize, usize)",
    "docstring": {
      "en": "Finds the missing and duplicate ID numbers from a series of ID sequences.\n  Each sequence of IDs is represented as a vector within a larger vector, simulating the input format described.\n  The IDs are assumed to be part of a continuous range but with one missing ID and one duplicate ID.\n  The function identifies and returns both the missing ID (that has been skipped) and the duplicate ID (that appears more than once).\n\n  Arguments:\n  - data: A vector of vectors, where each inner vector contains a sequence of ID numbers.\n\n  Returns:\n  - A tuple containing two usize values: the first is the missing ID, and the second is the duplicate ID.\n\n  Example:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "sq": "Gjen numrat e ID-ve që mungojnë dhe janë të dyfishuar nga një seri sekuencash ID-sh.\n  Çdo sekuencë ID-sh përfaqësohet si një vektor brenda një vektori më të madh, duke simuluar formatin e hyrjes të përshkruar.\n  ID-të supozohet të jenë pjesë e një diapazoni të vazhdueshëm, por me një ID që mungon dhe një ID të dyfishuar.\n  Funksioni identifikon dhe kthen si ID-në që mungon (që është anashkaluar) ashtu edhe ID-në e dyfishuar (që shfaqet më shumë se një herë).\n\n  Argumentet:\n  - data: Një vektor vektorësh, ku çdo vektor i brendshëm përmban një sekuencë numrash ID.\n\n  Kthen:\n  - Një dyshe që përmban dy vlera usize: e para është ID-ja që mungon, dhe e dyta është ID-ja e dyfishuar.\n\n  Shembull:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) kthen (7, 9)",
      "hy": "Գտնում է բացակայող և կրկնվող ID համարները ID հաջորդականությունների շարքից:\n  ID-ների յուրաքանչյուր հաջորդականություն ներկայացված է որպես վեկտոր ավելի մեծ վեկտորի ներսում, մուտքի ձևաչափը նկարագրված է:\n  Ենթադրվում է, որ ID-ները շարունակական տիրույթի մաս են կազմում, բայց մեկ բացակայող ID-ով և մեկ կրկնվող ID-ով:\n  Ֆունկցիան հայտնաբերում և վերադարձնում է ինչպես բացակայող ID-ն (որը բաց է թողնվել), այնպես էլ կրկնվող ID-ն (որը հայտնվում է մեկից ավելի անգամ):\n\n  Արգումենտներ:\n  - data: Վեկտոր վեկտորների, որտեղ յուրաքանչյուր ներքին վեկտոր պարունակում է ID համարների հաջորդականություն:\n\n  Վերադարձնում է.\n  - Զույգ, որը պարունակում է երկու usize արժեքներ. առաջինը բացակայող ID-ն է, իսկ երկրորդը կրկնվող ID-ն է:\n\n  Օրինակ:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) վերադարձնում է (7, 9)",
      "bn": "অনুপস্থিত এবং সদৃশ আইডি নম্বরগুলি একটি আইডি সিকোয়েন্সের সিরিজ থেকে খুঁজে বের করে। \nপ্রতিটি আইডি সিকোয়েন্স একটি বড় ভেক্টরের মধ্যে একটি ভেক্টর হিসাবে উপস্থাপিত হয়, বর্ণিত ইনপুট ফর্ম্যাটকে অনুকরণ করে। \nআইডিগুলি একটি ধারাবাহিক পরিসরের অংশ হিসেবে বিবেচিত হয় তবে একটি অনুপস্থিত আইডি এবং একটি সদৃশ আইডি সহ। \nফাংশনটি উভয় অনুপস্থিত আইডি (যা বাদ দেওয়া হয়েছে) এবং সদৃশ আইডি (যা একাধিকবার উপস্থিত হয়) সনাক্ত করে এবং ফেরত দেয়।\n\nআর্গুমেন্টস:\n- data: একটি ভেক্টরের ভেক্টর, যেখানে প্রতিটি অভ্যন্তরীণ ভেক্টর একটি আইডি নম্বরের সিকোয়েন্স ধারণ করে।\n\nরিটার্নস:\n- একটি টিউপল যা দুটি usize মান ধারণ করে: প্রথমটি অনুপস্থিত আইডি এবং দ্বিতীয়টি সদৃশ আইডি।\n\nউদাহরণ:\n- find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "bg": "Намира липсващите и дублиращите се ID номера от поредица ID последователности.\n  Всяка последователност от ID-та е представена като вектор в по-голям вектор, симулирайки описания формат на входа.\n  Предполага се, че ID-тата са част от непрекъснат диапазон, но с едно липсващо ID и едно дублирано ID.\n  Функцията идентифицира и връща както липсващото ID (което е пропуснато), така и дублираното ID (което се появява повече от веднъж).\n\n  Аргументи:\n  - data: Вектор от вектори, където всеки вътрешен вектор съдържа последователност от ID номера.\n\n  Връща:\n  - Кортеж, съдържащ две стойности от тип usize: първата е липсващото ID, а втората е дублираното ID.\n\n  Пример:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) връща (7, 9)",
      "zh": "查找一系列ID序列中缺失和重复的ID号。\n每个ID序列表示为一个较大向量中的向量，模拟所描述的输入格式。\n假设这些ID是一个连续范围的一部分，但其中有一个缺失的ID和一个重复的ID。\n该函数识别并返回缺失的ID（被跳过的）和重复的ID（出现多次的）。\n\n参数:\n- data: 一个向量的向量，其中每个内部向量包含一系列ID号。\n\n返回:\n- 一个包含两个usize值的元组：第一个是缺失的ID，第二个是重复的ID。\n\n示例:\n- find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) 返回 (7, 9)",
      "fr": "Trouve les numéros d'identification manquants et en double à partir d'une série de séquences d'ID.\n  Chaque séquence d'ID est représentée comme un vecteur à l'intérieur d'un vecteur plus grand, simulant le format d'entrée décrit.\n  Les ID sont supposés faire partie d'une plage continue mais avec un ID manquant et un ID en double.\n  La fonction identifie et renvoie à la fois l'ID manquant (qui a été sauté) et l'ID en double (qui apparaît plus d'une fois).\n\n  Arguments:\n  - data: Un vecteur de vecteurs, où chaque vecteur interne contient une séquence de numéros d'identification.\n\n  Renvoie:\n  - Un tuple contenant deux valeurs usize : la première est l'ID manquant, et la seconde est l'ID en double.\n\n  Exemple:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "de": "Findet die fehlenden und doppelten ID-Nummern aus einer Reihe von ID-Sequenzen.\n  Jede Sequenz von IDs wird als Vektor innerhalb eines größeren Vektors dargestellt, was das beschriebene Eingabeformat simuliert.\n  Es wird angenommen, dass die IDs Teil eines kontinuierlichen Bereichs sind, jedoch mit einer fehlenden ID und einer doppelten ID.\n  Die Funktion identifiziert und gibt sowohl die fehlende ID (die übersprungen wurde) als auch die doppelte ID (die mehr als einmal erscheint) zurück.\n\n  Argumente:\n  - data: Ein Vektor von Vektoren, wobei jeder innere Vektor eine Sequenz von ID-Nummern enthält.\n\n  Rückgabewerte:\n  - Ein Tupel, das zwei usize-Werte enthält: der erste ist die fehlende ID, und der zweite ist die doppelte ID.\n\n  Beispiel:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) gibt (7, 9) zurück.",
      "ha": "Yana gano lambobin ID da suka ɓace da kuma lambobin ID masu maimaitawa daga jerin lambobin ID.\n  Kowace jerin lambobin ID ana wakilta ta hanyar vector a cikin babban vector, yana kwaikwayon tsarin shigarwa da aka bayyana.\n  Ana ɗaukar lambobin ID a matsayin wani ɓangare na kewayon ci gaba amma tare da ID ɗaya da ya ɓace da kuma ID ɗaya da aka maimaita.\n  Ayyukan yana gano kuma yana dawowa duka ID ɗin da ya ɓace (wanda aka tsallake) da ID ɗin da aka maimaita (wanda ya bayyana fiye da sau ɗaya).\n\n  Huɗa:\n  - data: Wani vector na vectors, inda kowanne vector na ciki ya ƙunshi jerin lambobin ID.\n\n  Dawowa:\n  - Wani tuple mai ɗauke da ƙimomin usize guda biyu: na farko shine ID ɗin da ya ɓace, na biyu kuma shine ID ɗin da aka maimaita.\n\n  Misali:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "hi": "लापता और डुप्लिकेट आईडी नंबरों को आईडी अनुक्रमों की एक श्रृंखला से खोजता है।\n  आईडी का प्रत्येक अनुक्रम एक बड़े वेक्टर के भीतर एक वेक्टर के रूप में दर्शाया गया है, जो वर्णित इनपुट प्रारूप का अनुकरण करता है।\n  आईडी को एक सतत श्रेणी का हिस्सा माना जाता है लेकिन एक लापता आईडी और एक डुप्लिकेट आईडी के साथ।\n  फ़ंक्शन दोनों लापता आईडी (जो छोड़ दी गई है) और डुप्लिकेट आईडी (जो एक से अधिक बार प्रकट होती है) की पहचान करता है और लौटाता है।\n\n  तर्क:\n  - data: वेक्टर का एक वेक्टर, जहाँ प्रत्येक आंतरिक वेक्टर में आईडी नंबरों का एक अनुक्रम होता है।\n\n  रिटर्न:\n  - एक युग्म जिसमें दो usize मान होते हैं: पहला लापता आईडी है, और दूसरा डुप्लिकेट आईडी है।\n\n  उदाहरण:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) returns (7, 9)",
      "hu": "Megkeresi a hiányzó és duplikált azonosító számokat egy azonosítósorozatokból álló sorozatból.\n  Minden azonosítósorozat egy nagyobb vektoron belüli vektorként van ábrázolva, szimulálva a leírt bemeneti formátumot.\n  Feltételezzük, hogy az azonosítók egy folyamatos tartomány részét képezik, de egy hiányzó és egy duplikált azonosítóval.\n  A függvény azonosítja és visszaadja mind a hiányzó azonosítót (amelyet kihagytak), mind a duplikált azonosítót (amely többször is megjelenik).\n\n  Argumentumok:\n  - data: Vektorok vektora, ahol minden belső vektor egy azonosítószámokból álló sorozatot tartalmaz.\n\n  Visszatérési érték:\n  - Egy tuple, amely két usize értéket tartalmaz: az első a hiányzó azonosító, a második a duplikált azonosító.\n\n  Példa:\n  - find_missing_and_duplicate_ids(vec![vec![5, 6, 8, 11, 9], vec![10, 12, 9]]) visszaadja (7, 9)"
    },
    "docstring_bertscore": {
      "sq": "0.9729777270728707",
      "hy": "0.9781723087976951",
      "bn": "0.9555238768609541",
      "bg": "0.9805471336333482",
      "zh": "0.9554809726986505",
      "fr": "0.9693944349990014",
      "de": "0.9696780791831191",
      "ha": "0.9590225523925026",
      "hi": "0.9645365317700311",
      "hu": "0.9572662625633921"
    }
  },
  {
    "task_id": "Rust/53",
    "prompt": {
      "en": "/*\n  Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "sq": "/*\n  Numëron numrin e karaktereve shifrore, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n\n  Argumentet:\n  - s: Një varg me saktësisht 8 karaktere që mund të përfshijë shifra, shkronja të vogla dhe shkronja të mëdha.\n\n  Kthen:\n  - Një tuple që përmban tre vlera usize: numri i karaktereve shifrore, numri i shkronjave të vogla dhe numri i shkronjave të mëdha në varg.\n\n  Shembuj:\n  - count_chars_types(\"yLOI2022\") kthen (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") kthen (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") kthen (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "hy": "/*\n  Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 նիշ երկարությամբ տողում։\n  \n  Արգումենտներ:\n  - s: Ճիշտ 8 նիշից բաղկացած տող, որը կարող է ներառել թվանշաններ, փոքրատառեր և մեծատառեր։\n\n  Վերադարձնում է:\n  - Թյուփլ, որը պարունակում է երեք usize արժեքներ՝ թվանշանների քանակը, փոքրատառերի քանակը և մեծատառերի քանակը տողում։\n\n  Օրինակներ:\n  - count_chars_types(\"yLOI2022\") վերադարձնում է (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") վերադարձնում է (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") վերադարձնում է (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "bn": "/*\n  একটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যা অক্ষর, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n\n  আর্গুমেন্টসমূহ:\n  - s: একটি স্ট্রিং যা ঠিক ৮ অক্ষরের এবং এতে সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর থাকতে পারে।\n\n  রিটার্নস:\n  - একটি টিউপল যা তিনটি usize মান ধারণ করে: স্ট্রিং-এ সংখ্যা অক্ষরের সংখ্যা, ছোট হাতের অক্ষরের সংখ্যা, এবং বড় হাতের অক্ষরের সংখ্যা।\n\n  উদাহরণসমূহ:\n  - count_chars_types(\"yLOI2022\") রিটার্ন করে (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") রিটার্ন করে (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") রিটার্ন করে (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "bg": "/*\n  Брои броя на цифрите, малките букви и главните букви в даден низ с дължина 8.\n  \n  Аргументи:\n  - s: Низ от точно 8 символа, който може да включва цифри, малки букви и главни букви.\n\n  Връща:\n  - Кортеж, съдържащ три стойности от тип usize: броя на цифрите, броя на малките букви и броя на главните букви в низа.\n\n  Примери:\n  - count_chars_types(\"yLOI2022\") връща (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") връща (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") връща (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "zh": "/*\n  统计给定长度为8的字符串中的数字字符、小写字母和大写字母的数量。\n  \n  参数:\n  - s: 一个长度正好为8的字符串，可能包含数字字符、小写字母和大写字母。\n\n  返回:\n  - 一个包含三个usize值的元组：字符串中数字字符的数量、小写字母的数量和大写字母的数量。\n\n  示例:\n  - count_chars_types(\"yLOI2022\") 返回 (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") 返回 (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") 返回 (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "fr": "/*\n  Compte le nombre de caractères numériques, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n  \n  Arguments :\n  - s : Une chaîne de exactement 8 caractères qui peut inclure des chiffres, des lettres minuscules et des lettres majuscules.\n\n  Renvoie :\n  - Un tuple contenant trois valeurs usize : le compte des caractères numériques, le compte des lettres minuscules et le compte des lettres majuscules dans la chaîne.\n\n  Exemples :\n  - count_chars_types(\"yLOI2022\") renvoie (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") renvoie (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") renvoie (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "de": "/*\n  Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n  \n  Argumente:\n  - s: Ein String mit genau 8 Zeichen, der Ziffern, Kleinbuchstaben und Großbuchstaben enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält: die Anzahl der Ziffern, die Anzahl der Kleinbuchstaben und die Anzahl der Großbuchstaben im String.\n\n  Beispiele:\n  - count_chars_types(\"yLOI2022\") gibt (4, 1, 3) zurück\n  - count_chars_types(\"IAKIOIOI\") gibt (0, 0, 8) zurück\n  - count_chars_types(\"1n2s0e1s\") gibt (4, 4, 0) zurück\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "ha": "/*\n  Yana ƙirga adadin haruffan lambobi, haruffan ƙaramin rubutu, da haruffan babban rubutu a cikin wani baƙaƙe guda 8.\n\n  Huɗɗa:\n  - s: Wani baƙaƙe na ainihin haruffa 8 wanda zai iya ƙunsar lambobi, haruffan ƙaramin rubutu, da haruffan babban rubutu.\n\n  Komawa:\n  - Wani haɗin uku na ƙimar usize: adadin haruffan lambobi, adadin haruffan ƙaramin rubutu, da adadin haruffan babban rubutu a cikin baƙaƙen.\n\n  Misalai:\n  - count_chars_types(\"yLOI2022\") yana dawowa (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") yana dawowa (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") yana dawowa (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "hi": "/*\n  एक दिए गए 8 वर्णों की लंबाई वाले स्ट्रिंग में अंक वर्णों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है।\n\n  तर्क:\n  - s: एक स्ट्रिंग जो ठीक 8 वर्णों की होती है और इसमें अंक, छोटे अक्षर, और बड़े अक्षर शामिल हो सकते हैं।\n\n  लौटाता है:\n  - एक ट्यूपल जिसमें तीन usize मान होते हैं: स्ट्रिंग में अंक वर्णों की संख्या, छोटे अक्षरों की संख्या, और बड़े अक्षरों की संख्या।\n\n  उदाहरण:\n  - count_chars_types(\"yLOI2022\") (4, 1, 3) लौटाता है\n  - count_chars_types(\"IAKIOIOI\") (0, 0, 8) लौटाता है\n  - count_chars_types(\"1n2s0e1s\") (4, 4, 0) लौटाता है\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) ",
      "hu": "/*\n  Megszámolja a számjegy karakterek, kisbetűk és nagybetűk számát egy adott, 8 hosszúságú sztringben.\n  \n  Argumentumok:\n  - s: Egy pontosan 8 karakter hosszú sztring, amely tartalmazhat számjegyeket, kisbetűket és nagybetűket.\n\n  Visszatér:\n  - Egy hármas, amely három usize értéket tartalmaz: a számjegy karakterek száma, a kisbetűk száma és a nagybetűk száma a sztringben.\n\n  Példák:\n  - count_chars_types(\"yLOI2022\") visszaadja (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") visszaadja (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") visszaadja (4, 4, 0)\n*/\nfn count_chars_types(s: &str) -> (usize, usize, usize) "
    },
    "prompt_bertscore": {
      "sq": "0.9901358166474264",
      "hy": "0.97586044979283",
      "bn": "0.9749582706021696",
      "bg": "0.9843999671342819",
      "zh": "0.9711616494990687",
      "fr": "0.9939411774872928",
      "de": "0.9802116469197802",
      "ha": "0.9712403071299586",
      "hi": "0.9797283792027224",
      "hu": "0.9841262544692159"
    },
    "canonical_solution": "{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}",
    "instruction": {
      "en": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nProvide a concise natural language description (docstring) of the Rust code in English using at most 500 characters.",
      "sq": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Rust në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) Rust կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nনিচের রাস্ট কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nПредоставете кратко описание на кода на Rust на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\n请使用不超过500个字符的中文，为以下Rust代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nFournissez une description concise en langage naturel (docstring) du code Rust en français en utilisant au maximum 500 caractères.",
      "de": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Rust-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Rust a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nरस्ट कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "fn count_chars_types(s: &str) -> (usize, usize, usize)\n{\n    let mut digits = 0;\n    let mut lowercase = 0;\n    let mut uppercase = 0;\n\n    for c in s.chars() {\n        if c.is_digit(10) {\n            digits += 1;\n        } else if c.is_lowercase() {\n            lowercase += 1;\n        } else if c.is_uppercase() {\n            uppercase += 1;\n        }\n    }\n\n    (digits, lowercase, uppercase)\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Rust kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9536591348437985",
      "hy": "0.9319271834851525",
      "bn": "0.8781885284176876",
      "bg": "0.8316696904400789",
      "zh": "0.856169158897684",
      "fr": "0.9678347892471154",
      "de": "0.9240604272442657",
      "ha": "0.9175576658299455",
      "hi": "0.9115359871984918",
      "hu": "0.9519225094224105"
    },
    "level": "",
    "test": "#[cfg(test)]\nmod tests {\n    use super::*;\n \n    #[test]\n    fn main() {\n        assert_eq!(count_chars_types(\"yLOI2022\"), (4, 1, 3));\n        assert_eq!(count_chars_types(\"IAKIOIOI\"), (0, 0, 8));\n        assert_eq!(count_chars_types(\"1n2s0e1s\"), (4, 4, 0));\n    }\n    \n\n}",
    "entry_point": "count_chars_types",
    "signature": "fn count_chars_types(s: &str) -> (usize, usize, usize)",
    "docstring": {
      "en": "Counts the number of digit characters, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  Arguments:\n  - s: A string of exactly 8 characters that may include digits, lowercase letters, and uppercase letters.\n\n  Returns:\n  - A tuple containing three usize values: the count of digit characters, the count of lowercase letters, and the count of uppercase letters in the string.\n\n  Examples:\n  - count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "sq": "Numëron numrin e karaktereve shifrore, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n\nArguments:\n- s: Një varg me saktësisht 8 karaktere që mund të përfshijë shifra, shkronja të vogla dhe shkronja të mëdha.\n\nReturns:\n- Një tuple që përmban tre vlera usize: numri i karaktereve shifrore, numri i shkronjave të vogla dhe numri i shkronjave të mëdha në varg.\n\nExamples:\n- count_chars_types(\"yLOI2022\") kthen (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") kthen (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") kthen (4, 4, 0)",
      "hy": "Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 նիշ երկարությամբ տողում:\n\n  Արգումենտներ:\n  - s: Ճիշտ 8 նիշ երկարությամբ տող, որը կարող է ներառել թվանշաններ, փոքրատառեր և մեծատառեր:\n\n  Վերադարձնում է:\n  - Եռյակ, որը պարունակում է երեք usize արժեքներ՝ թվանշանների քանակը, փոքրատառերի քանակը և մեծատառերի քանակը տողում:\n\n  Օրինակներ:\n  - count_chars_types(\"yLOI2022\") վերադարձնում է (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") վերադարձնում է (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") վերադարձնում է (4, 4, 0)",
      "bn": "একটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যা অক্ষর, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n\n  যুক্তি:\n  - s: একটি স্ট্রিং যা ঠিক 8 অক্ষরের এবং এতে সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর থাকতে পারে।\n\n  রিটার্নস:\n  - একটি টিউপল যা তিনটি usize মান ধারণ করে: সংখ্যার অক্ষরের সংখ্যা, ছোট হাতের অক্ষরের সংখ্যা, এবং বড় হাতের অক্ষরের সংখ্যা স্ট্রিংয়ে।\n\n  উদাহরণ:\n  - count_chars_types(\"yLOI2022\") রিটার্ন করে (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") রিটার্ন করে (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") রিটার্ন করে (4, 4, 0)",
      "bg": "Брои броя на цифровите символи, малките букви и главните букви в даден низ с дължина 8.\n\n  Аргументи:\n  - s: Низ с точно 8 символа, който може да включва цифри, малки букви и главни букви.\n\n  Връща:\n  - Кортеж, съдържащ три стойности от тип usize: броя на цифровите символи, броя на малките букви и броя на главните букви в низа.\n\n  Примери:\n  - count_chars_types(\"yLOI2022\") връща (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") връща (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") връща (4, 4, 0)",
      "zh": "计算给定长度为8的字符串中数字字符、小写字母和大写字母的数量。\n\n  参数:\n  - s: 一个正好包含8个字符的字符串，可能包括数字、小写字母和大写字母。\n\n  返回:\n  - 一个包含三个usize值的元组：字符串中数字字符的数量、小写字母的数量和大写字母的数量。\n\n  示例:\n  - count_chars_types(\"yLOI2022\") 返回 (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") 返回 (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") 返回 (4, 4, 0)",
      "fr": "Compte le nombre de caractères numériques, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n\n  Arguments:\n  - s: Une chaîne de exactement 8 caractères qui peut inclure des chiffres, des lettres minuscules et des lettres majuscules.\n\n  Retourne:\n  - Un tuple contenant trois valeurs usize : le nombre de caractères numériques, le nombre de lettres minuscules et le nombre de lettres majuscules dans la chaîne.\n\n  Exemples:\n  - count_chars_types(\"yLOI2022\") retourne (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") retourne (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") retourne (4, 4, 0)",
      "de": "Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n\n  Argumente:\n  - s: Ein String mit genau 8 Zeichen, der Ziffern, Kleinbuchstaben und Großbuchstaben enthalten kann.\n\n  Rückgabewerte:\n  - Ein Tupel, das drei usize-Werte enthält: die Anzahl der Ziffern, die Anzahl der Kleinbuchstaben und die Anzahl der Großbuchstaben im String.\n\n  Beispiele:\n  - count_chars_types(\"yLOI2022\") gibt (4, 1, 3) zurück\n  - count_chars_types(\"IAKIOIOI\") gibt (0, 0, 8) zurück\n  - count_chars_types(\"1n2s0e1s\") gibt (4, 4, 0) zurück",
      "ha": "Yana ƙididdige adadin haruffan lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu mai tsawon haruffa 8.\n\nArguments:\n- s: Wani igiyar rubutu na haruffa 8 daidai wanda zai iya ƙunsar lambobi, ƙananan haruffa, da manyan haruffa.\n\nReturns:\n- Wani tuple da ke ƙunshe da ƙimar usize guda uku: adadin haruffan lambobi, adadin ƙananan haruffa, da adadin manyan haruffa a cikin igiyar rubutu.\n\nExamples:\n- count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "hi": "8 वर्णों की लंबाई वाले दिए गए स्ट्रिंग में अंक वर्णों, छोटे अक्षरों और बड़े अक्षरों की संख्या गिनता है।\n\nArguments:\n- s: एक स्ट्रिंग जो ठीक 8 वर्णों की होती है और इसमें अंक, छोटे अक्षर और बड़े अक्षर शामिल हो सकते हैं।\n\nReturns:\n- एक टपल जिसमें तीन usize मान होते हैं: स्ट्रिंग में अंक वर्णों की गिनती, छोटे अक्षरों की गिनती, और बड़े अक्षरों की गिनती।\n\nExamples:\n- count_chars_types(\"yLOI2022\") returns (4, 1, 3)\n- count_chars_types(\"IAKIOIOI\") returns (0, 0, 8)\n- count_chars_types(\"1n2s0e1s\") returns (4, 4, 0)",
      "hu": "Számolja meg a számjegy karakterek, kisbetűk és nagybetűk számát egy adott, 8 hosszúságú karakterláncban.\n\n  Argumentumok:\n  - s: Egy pontosan 8 karakter hosszú karakterlánc, amely tartalmazhat számjegyeket, kisbetűket és nagybetűket.\n\n  Visszatér:\n  - Egy hármas, amely három usize értéket tartalmaz: a számjegy karakterek száma, a kisbetűk száma és a nagybetűk száma a karakterláncban.\n\n  Példák:\n  - count_chars_types(\"yLOI2022\") visszaadja (4, 1, 3)\n  - count_chars_types(\"IAKIOIOI\") visszaadja (0, 0, 8)\n  - count_chars_types(\"1n2s0e1s\") visszaadja (4, 4, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9886198695793682",
      "hy": "0.9673701927858748",
      "bn": "0.9553733150321296",
      "bg": "0.9818861010319044",
      "zh": "0.964758401905647",
      "fr": "0.9913373318223064",
      "de": "0.9663077188777192",
      "ha": "0.980278188097427",
      "hi": "0.9892860758773592",
      "hu": "0.9725756991816561"
    }
  }
]