[
  {
    "task_id": "C#/1",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "sq": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n   pragu i dhënë.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "hy": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Ստուգել, արդյոք տրված թվերի ցանկում որևէ երկու թիվ իրար մոտ են, քան տրված շեմը։\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "bn": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "bg": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Проверете дали в даден списък от числа, някои две числа са по-близо едно до друго\n   от дадения праг.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "zh": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "fr": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Vérifiez si, dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que\n   le seuil donné.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "de": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n   der gegebene Schwellenwert.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "ha": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Duba idan a cikin jerin lambobi da aka bayar, akwai kowanne lambobi biyu da suke kusa da juna fiye da\n   ƙayyadadden tazara.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "hi": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* जाँचें कि दिए गए संख्याओं की सूची में, कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं या नहीं।\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "hu": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Ellenőrzi, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz\n   a megadott küszöbértéknél.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)"
    },
    "prompt_bertscore": {
      "sq": "0.9934283138434608",
      "hy": "0.9810105383123027",
      "bn": "0.9810105383123027",
      "bg": "0.9927913062114818",
      "zh": "0.9533727098343462",
      "fr": "0.9859524621924506",
      "de": "0.9827994035239028",
      "ha": "0.9661774173477603",
      "hi": "0.9732129054440161",
      "hu": "0.9751912640391235"
    },
    "canonical_solution": "    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }",
    "instruction": {
      "en": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nՏվեք C# կոդի հակիրճ նկարագրությունը (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nনিচের C# কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, সর্বাধিক ৫০০ অক্ষর ব্যবহার করে।",
      "bg": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9380769787123736",
      "hy": "0.9287852481179426",
      "bn": "0.9051182395872546",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9428713202194127",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "static void Main()\n    {\n\n        // Test cases\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.3) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.05) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.95) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.8) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 }, 0.1) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 1.0) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 0.5) == false);\n    }\n}",
    "entry_point": "HasCloseElements",
    "signature": "static bool HasCloseElements(List<double> numbers, double threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "hy": "Ստուգել, արդյոք տրված թվերի ցանկում որևէ երկու թիվ ավելի մոտ են միմյանց, քան տրված շեմը։  \n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা দেওয়া থ্রেশহোল্ডের চেয়ে একে অপরের কাছাকাছি কিনা তা পরীক্ষা করুন।\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "bg": "Проверете дали в даден списък от числа, някои две числа са по-близо едно до друго от дадения праг.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "zh": "检查给定数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "fr": "Vérifiez si, dans la liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "ha": "Duba idan a cikin jerin lambobi da aka bayar, ko akwai lambobi biyu da ke kusa da juna fiye da\n   ƙayyadadden ƙimar da aka bayar.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "hi": "जाँचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।  \n>>> hasCloseElements([1.0, 2.0, 3.0], 0.5)  \nfalse  \n>>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \ntrue",
      "hu": "Ellenőrizze, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true"
    },
    "docstring_bertscore": {
      "sq": "0.9912743659915184",
      "hy": "0.9674289873786611",
      "bn": "0.9624344264475388",
      "bg": "0.9889523768372206",
      "zh": "0.944774596530489",
      "fr": "0.9805588528258293",
      "de": "0.9550501434021859",
      "ha": "0.9537594431862212",
      "hi": "0.9680852621576004",
      "hu": "0.9732135013351592"
    }
  },
  {
    "task_id": "C#/2",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Converts a given Fahrenheit temperature to Celsius and returns the result as a string formatted to two decimal places.\n    The formula used is: Celsius = 5/9 * (Fahrenheit - 32).\n    Example usage:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Konverton një temperaturë të dhënë në Fahrenheit në Celsius dhe kthen rezultatin si një varg i formatuar me dy vende dhjetore.\n    Formula e përdorur është: Celsius = 5/9 * (Fahrenheit - 32).\n    Shembull përdorimi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Տրված Ֆարենհայթի ջերմաստիճանը փոխակերպում է Ցելսիուսի և վերադարձնում արդյունքը որպես տող՝ ձևաչափված մինչև երկու տասնորդական տեղ:\n    Օգտագործվող բանաձևն է՝ Ցելսիուս = 5/9 * (Ֆարենհայթ - 32):\n    Օրինակ օգտագործում:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* একটি প্রদত্ত ফারেনহাইট তাপমাত্রাকে সেলসিয়াসে রূপান্তর করে এবং ফলাফলকে দুটি দশমিক স্থান পর্যন্ত ফরম্যাট করা একটি স্ট্রিং হিসেবে ফেরত দেয়।\n    ব্যবহৃত সূত্র হল: সেলসিয়াস = 5/9 * (ফারেনহাইট - 32)।\n    উদাহরণ ব্যবহার:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Преобразува дадена температура по Фаренхайт в Целзий и връща резултата като низ, форматиран до два десетични знака.\n    Използваната формула е: Целзий = 5/9 * (Фаренхайт - 32).\n    Пример за използване:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* 将给定的华氏温度转换为摄氏温度，并返回格式化为两位小数的字符串。\n    使用的公式是：摄氏温度 = 5/9 * (华氏温度 - 32)。\n    示例用法:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Convertit une température donnée en Fahrenheit en Celsius et renvoie le résultat sous forme de chaîne formatée à deux décimales.\n    La formule utilisée est : Celsius = 5/9 * (Fahrenheit - 32).\n    Exemple d'utilisation :\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Konvertiert eine gegebene Fahrenheit-Temperatur in Celsius und gibt das Ergebnis als String formatiert auf zwei Dezimalstellen zurück.\n    Die verwendete Formel ist: Celsius = 5/9 * (Fahrenheit - 32).\n    Beispielverwendung:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Yana canza zafin Fahrenheit da aka bayar zuwa Celsius kuma yana mayar da sakamakon a matsayin kirtani da aka tsara zuwa wurare biyu na goma.\n    Ana amfani da tsarin: Celsius = 5/9 * (Fahrenheit - 32).\n    Misalin amfani:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* एक दिए गए फ़ारेनहाइट तापमान को सेल्सियस में परिवर्तित करता है और परिणाम को दो दशमलव स्थानों तक स्वरूपित एक स्ट्रिंग के रूप में लौटाता है।\n    उपयोग किया गया सूत्र है: Celsius = 5/9 * (Fahrenheit - 32).\n    उदाहरण उपयोग:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Átalakítja a megadott Fahrenheit hőmérsékletet Celsiusra, és az eredményt két tizedesjegyre formázott sztringként adja vissza.\n    Az alkalmazott képlet: Celsius = 5/9 * (Fahrenheit - 32).\n    Példa használat:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)"
    },
    "prompt_bertscore": {
      "sq": "0.9932267040067103",
      "hy": "0.9942907669579142",
      "bn": "1",
      "bg": "0.9952886859922335",
      "zh": "0.9799814343081609",
      "fr": "0.9899892274262226",
      "de": "0.9935560331784662",
      "ha": "0.995007226742307",
      "hi": "1",
      "hu": "0.9954241519120993"
    },
    "canonical_solution": "{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}",
    "instruction": {
      "en": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nՏրամադրել կարճ բնութագիր (docstring) այս C# կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简明的自然语言描述（文档字符串）。",
      "fr": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.8891364391291875",
      "bn": "0.8778230485165833",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9543420260937965",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(ConvertFahrenheitToCelsius(32) == \"c=0.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(212) == \"c=100.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(-40) == \"c=-40.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(98.6) == \"c=37.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(0) == \"c=-17.78\");\n\n    }\n}",
    "entry_point": "ConvertFahrenheitToCelsius",
    "signature": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
    "docstring": {
      "en": "Converts a given Fahrenheit temperature to Celsius and returns the result as a string formatted to two decimal places.\n    The formula used is: Celsius = 5/9 * (Fahrenheit - 32).\n    Example usage:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "sq": "Konverton një temperaturë të dhënë në Fahrenheit në Celsius dhe kthen rezultatin si një varg i formatuar me dy vende dhjetore.\n    Formula e përdorur është: Celsius = 5/9 * (Fahrenheit - 32).\n    Shembull përdorimi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "hy": "Փոխակերպում է տրված Ֆարենհայթի ջերմաստիճանը Ցելսիուսի և վերադարձնում արդյունքը որպես տող, ձևաչափված մինչև երկու տասնորդական թվանշան:\n    Օգտագործվող բանաձևն է՝ Ցելսիուս = 5/9 * (Ֆարենհայթ - 32):\n    Օրինակ օգտագործում:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "bn": "একটি প্রদত্ত ফারেনহাইট তাপমাত্রাকে সেলসিয়াসে রূপান্তর করে এবং ফলাফলটি দুটি দশমিক স্থান পর্যন্ত ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\n    ব্যবহৃত সূত্র হল: সেলসিয়াস = 5/9 * (ফারেনহাইট - 32)।\n    উদাহরণ ব্যবহার:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "bg": "Преобразува дадена температура по Фаренхайт в Целзий и връща резултата като низ, форматиран до два знака след десетичната точка.\n    Използваната формула е: Целзий = 5/9 * (Фаренхайт - 32).\n    Пример за използване:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "zh": "将给定的华氏温度转换为摄氏温度，并返回格式化为两位小数的字符串。\n    使用的公式是：Celsius = 5/9 * (Fahrenheit - 32)。\n    示例用法：\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "fr": "Convertit une température donnée en Fahrenheit en Celsius et renvoie le résultat sous forme de chaîne formatée à deux décimales.\n    La formule utilisée est : Celsius = 5/9 * (Fahrenheit - 32).\n    Exemple d'utilisation :\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "de": "Konvertiert eine gegebene Fahrenheit-Temperatur in Celsius und gibt das Ergebnis als Zeichenkette formatiert auf zwei Dezimalstellen zurück.\n    Die verwendete Formel ist: Celsius = 5/9 * (Fahrenheit - 32).\n    Beispielverwendung:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "ha": "Yana canza zafin Fahrenheit da aka bayar zuwa Celsius kuma yana mayar da sakamakon azaman kirtani da aka tsara zuwa wurare biyu na goma.\n    Ana amfani da wannan ƙa'idar: Celsius = 5/9 * (Fahrenheit - 32).\n    Misalin amfani:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "hi": "दिए गए फ़ारेनहाइट तापमान को सेल्सियस में परिवर्तित करता है और परिणाम को दो दशमलव स्थानों तक स्वरूपित स्ट्रिंग के रूप में लौटाता है।  \n    उपयोग किया गया सूत्र है: सेल्सियस = 5/9 * (फ़ारेनहाइट - 32)।  \n    उदाहरण उपयोग:  \n    >>> ConvertFahrenheitToCelsius(32)  \n    \"c=0.00\"  \n    >>> ConvertFahrenheitToCelsius(212)  \n    \"c=100.00\"  ",
      "hu": "Átalakít egy adott Fahrenheit hőmérsékletet Celsiusra, és az eredményt két tizedesjegyre formázott sztringként adja vissza.\n    Az alkalmazott képlet: Celsius = 5/9 * (Fahrenheit - 32).\n    Példa használat:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\""
    },
    "docstring_bertscore": {
      "sq": "0.9899232821397191",
      "hy": "0.9899653917804985",
      "bn": "1",
      "bg": "0.9934736015703367",
      "zh": "0.9734397413391579",
      "fr": "0.9859083662478609",
      "de": "1",
      "ha": "0.9839929734835414",
      "hi": "0.9867130179214332",
      "hu": "0.9960305704653988"
    }
  },
  {
    "task_id": "C#/3",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Encodes the given string by shifting each letter by a specified number of places in the alphabet.\n    If the shift takes the letter beyond 'z', it wraps around to the beginning of the alphabet.\n    \n    Examples:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Kodon vargun e dhënë duke zhvendosur secilën shkronjë me një numër të caktuar vendesh në alfabet.\n    Nëse zhvendosja e çon shkronjën përtej 'z', ajo kthehet në fillim të alfabetit.\n    \n    Shembuj:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Կոդավորում է տրված տողը՝ այբուբենում յուրաքանչյուր տառը որոշակի քանակով տեղաշարժելով:\n    Եթե տեղաշարժը տառը տանում է 'z'-ից այն կողմ, այն շրջվում է այբուբենի սկզբին:\n    \n    Օրինակներ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    প্রদত্ত স্ট্রিং এনকোড করে প্রতিটি অক্ষরকে বর্ণমালায় নির্দিষ্ট সংখ্যক স্থান সরিয়ে।\n    যদি সরানো অক্ষরকে 'z' এর বাইরে নিয়ে যায়, এটি বর্ণমালার শুরুতে ঘুরে আসে।\n    \n    উদাহরণ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Кодира дадения низ, като измества всяка буква с определен брой места в азбуката.\n    Ако изместването премине отвъд 'z', то се връща в началото на азбуката.\n    \n    Примери:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    通过在字母表中将每个字母移动指定数量的位置来编码给定的字符串。\n    如果移动使字母超出'z'，则会回绕到字母表的开头。\n    \n    例子:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Encode la chaîne donnée en décalant chaque lettre d'un nombre spécifié de places dans l'alphabet.\n    Si le décalage dépasse 'z', il revient au début de l'alphabet.\n    \n    Exemples :\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Kodiert den gegebenen String, indem jeder Buchstabe um eine angegebene Anzahl von Stellen im Alphabet verschoben wird.\n    Wenn die Verschiebung den Buchstaben über 'z' hinausführt, wird zum Anfang des Alphabets zurückgekehrt.\n    \n    Beispiele:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Yana ƙunsar kirtani da aka bayar ta hanyar matsar da kowane harafi da adadin wurare da aka fayyace a cikin haruffa.\n    Idan matsawar ta kai harafin bayan 'z', yana komawa zuwa farkon haruffa.\n    \n    Misalai:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    दिए गए स्ट्रिंग को वर्णमाला में निर्दिष्ट संख्या स्थानों द्वारा प्रत्येक अक्षर को शिफ्ट करके एन्कोड करता है।\n    यदि शिफ्ट अक्षर को 'z' से आगे ले जाता है, तो यह वर्णमाला की शुरुआत में वापस आ जाता है।\n    \n    उदाहरण:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    A megadott karakterláncot úgy kódolja, hogy az ábécében minden betűt egy meghatározott számú hellyel eltol.\n    Ha az eltolás a betűt túlviszi a 'z'-n, akkor az ábécé elejére ugrik vissza.\n    \n    Példák:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9802591195808477",
      "bn": "0.9648167992376713",
      "bg": "0.9828284035595339",
      "zh": "0.9798324615223847",
      "fr": "0.9837937472113635",
      "de": "0.9929551762758356",
      "ha": "0.9834745481890405",
      "hi": "0.9921556889921702",
      "hu": "0.9918722434384334"
    },
    "canonical_solution": "{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}",
    "instruction": {
      "en": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nՏրամադրել C# կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\n请用最多500个字符的中文对该C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (dokumentációs komment) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9120407069967015",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.9336369938051008",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.8940620753180907"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(EncodeString(\"China\", 4) == \"Glmre\");\n        Debug.Assert(EncodeString(\"apple\", 2) == \"crrng\");\n        Debug.Assert(EncodeString(\"hello\", 5) == \"mjqqt\");\n        Debug.Assert(EncodeString(\"xyz\", 3) == \"abc\");\n        Debug.Assert(EncodeString(\"AbCdE\", 1) == \"BcDeF\");\n        Debug.Assert(EncodeString(\"Java\", 10) == \"Tkfk\");\n        Debug.Assert(EncodeString(\"OpenAI\", 4) == \"StirEM\");\n        Debug.Assert(EncodeString(\"\", 5) == \"\");\n\n    }\n}\n",
    "entry_point": "EncodeString",
    "signature": "static string EncodeString(string input, int shift)",
    "docstring": {
      "en": "Encodes the given string by shifting each letter by a specified number of places in the alphabet.\n    If the shift takes the letter beyond 'z', it wraps around to the beginning of the alphabet.\n    \n    Examples:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "sq": "Kodi i jepur kodon vargun duke zhvendosur secilën shkronjë me një numër të caktuar vendesh në alfabet. Nëse zhvendosja e çon shkronjën përtej 'z', ajo kthehet në fillim të alfabetit.\n\nShembuj:\n>>> EncodeString(\"apple\", 2)\n\"crrng\"\n\n>>> EncodeString(\"hello\", 5)\n\"mjqqt\"",
      "hy": "Տրված տողը կոդավորում է՝ այբուբենի յուրաքանչյուր տառը որոշակի քանակով տեղաշարժելով:\n    Եթե տեղաշարժը տառը տանում է 'z'-ից այն կողմ, այն շրջվում է այբուբենի սկզբին:\n    \n    Օրինակներ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "bn": "প্রদত্ত স্ট্রিংটি এনকোড করে প্রতিটি অক্ষরকে বর্ণমালায় নির্দিষ্ট সংখ্যক স্থানে সরিয়ে দেয়। \n    যদি সরানোটি অক্ষরকে 'z'-এর বাইরে নিয়ে যায়, তবে এটি বর্ণমালার শুরুতে ফিরে আসে।\n    \n    উদাহরণ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "bg": "Кодира дадения низ, като измества всяка буква с определен брой позиции в азбуката. Ако изместването отведе буквата отвъд 'z', тя се връща в началото на азбуката.\n\nПримери:\n>>> EncodeString(\"apple\", 2)\n\"crrng\"\n\n>>> EncodeString(\"hello\", 5)\n\"mjqqt\"",
      "zh": "对给定字符串进行编码，通过在字母表中将每个字母移动指定数量的位置来实现。\n如果移动使字母超过'z'，则它会绕回字母表的开头。\n\n示例：\n>>> EncodeString(\"apple\", 2)\n\"crrng\"\n\n>>> EncodeString(\"hello\", 5)\n\"mjqqt\"",
      "fr": "Encode la chaîne donnée en décalant chaque lettre d'un nombre spécifié de places dans l'alphabet. Si le décalage emmène la lettre au-delà de 'z', il revient au début de l'alphabet.\n\n    Exemples :\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "de": "Kodiert die angegebene Zeichenkette, indem jeder Buchstabe um eine bestimmte Anzahl von Stellen im Alphabet verschoben wird. Wenn die Verschiebung den Buchstaben über 'z' hinausführt, wird sie zum Anfang des Alphabets zurückgesetzt.\n\nBeispiele:\n>>> EncodeString(\"apple\", 2)\n\"crrng\"\n\n>>> EncodeString(\"hello\", 5)\n\"mjqqt\"",
      "ha": "Encodes da aka bayar tana ta hanyar matsar da kowace harafi da adadin wurare da aka kayyade a cikin haruffa. Idan matsawar ta kai harafin bayan 'z', yana komawa farkon haruffa.\n\nMisalai:\n>>> EncodeString(\"apple\", 2)\n\"crrng\"\n\n>>> EncodeString(\"hello\", 5)\n\"mjqqt\"",
      "hi": "दिए गए स्ट्रिंग को एन्कोड करता है प्रत्येक अक्षर को वर्णमाला में निर्दिष्ट संख्या स्थानों द्वारा स्थानांतरित करके। \n    यदि शिफ्ट अक्षर को 'z' से आगे ले जाता है, तो यह वर्णमाला की शुरुआत में लपेटता है।\n    \n    उदाहरण:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "hu": "A megadott karakterláncot úgy kódolja, hogy az ábécében minden betűt egy meghatározott számú hellyel eltol.\n    Ha az eltolás a betűt a 'z' utánra viszi, akkor visszaugrik az ábécé elejére.\n    \n    Példák:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\""
    },
    "docstring_bertscore": {
      "sq": "0.966824753759553",
      "hy": "0.9524165031800442",
      "bn": "0.9481886555197166",
      "bg": "0.9714156977564123",
      "zh": "0.9580254278797075",
      "fr": "0.9746013318074499",
      "de": "0.99496174038505",
      "ha": "0.9516670707523996",
      "hi": "0.9680781114638831",
      "hu": "0.972005828618467"
    }
  },
  {
    "task_id": "C#/4",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Computes a value based on the input x according to specified linear functions.\n   The function applies different formulas based on the value of x:\n   - For x less than 1, returns x.\n   - For x between 1 and 10, returns 2x - 1.\n   - For x greater than or equal to 10, returns 3x - 11.\n   Example cases:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Llogarit një vlerë bazuar në hyrjen x sipas funksioneve lineare të specifikuara.\n   Funksioni aplikon formula të ndryshme bazuar në vlerën e x:\n   - Për x më pak se 1, kthen x.\n   - Për x midis 1 dhe 10, kthen 2x - 1.\n   - Për x më të madh ose të barabartë me 10, kthen 3x - 11.\n   Shembuj rastesh:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Հաշվում է արժեքը մուտքային x-ի հիման վրա՝ ըստ նշված գծային ֆունկցիաների:\n   Ֆունկցիան կիրառվում է տարբեր բանաձևեր՝ հիմնված x-ի արժեքի վրա.\n   - Եթե x-ը փոքր է 1-ից, վերադարձնում է x:\n   - Եթե x-ը 1-ից մինչև 10 է, վերադարձնում է 2x - 1:\n   - Եթե x-ը մեծ կամ հավասար է 10-ի, վերադարձնում է 3x - 11:\n   Օրինակային դեպքեր:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* ইনপুট x এর উপর ভিত্তি করে নির্দিষ্ট লিনিয়ার ফাংশন অনুযায়ী একটি মান গণনা করে।\n   ফাংশনটি x এর মানের উপর ভিত্তি করে বিভিন্ন সূত্র প্রয়োগ করে:\n   - x যদি 1 এর চেয়ে কম হয়, তাহলে x ফেরত দেয়।\n   - x যদি 1 এবং 10 এর মধ্যে হয়, তাহলে 2x - 1 ফেরত দেয়।\n   - x যদি 10 এর সমান বা তার চেয়ে বড় হয়, তাহলে 3x - 11 ফেরত দেয়।\n   উদাহরণ কেস:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Изчислява стойност на базата на входа x според определени линейни функции.\n   Функцията прилага различни формули в зависимост от стойността на x:\n   - За x по-малко от 1, връща x.\n   - За x между 1 и 10, връща 2x - 1.\n   - За x по-голямо или равно на 10, връща 3x - 11.\n   Примерни случаи:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 根据指定的线性函数计算输入 x 的值。\n   该函数根据 x 的值应用不同的公式：\n   - 对于小于 1 的 x，返回 x。\n   - 对于 1 到 10 之间的 x，返回 2x - 1。\n   - 对于大于或等于 10 的 x，返回 3x - 11。\n   示例案例：\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcule une valeur basée sur l'entrée x selon des fonctions linéaires spécifiées.\n   La fonction applique différentes formules en fonction de la valeur de x :\n   - Pour x inférieur à 1, retourne x.\n   - Pour x entre 1 et 10, retourne 2x - 1.\n   - Pour x supérieur ou égal à 10, retourne 3x - 11.\n   Cas d'exemple :\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Berechnet einen Wert basierend auf der Eingabe x gemäß den angegebenen linearen Funktionen.\n   Die Funktion wendet unterschiedliche Formeln basierend auf dem Wert von x an:\n   - Für x kleiner als 1, gibt x zurück.\n   - Für x zwischen 1 und 10, gibt 2x - 1 zurück.\n   - Für x größer oder gleich 10, gibt 3x - 11 zurück.\n   Beispielhafte Fälle:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Lissafi darajar bisa ga shigar x bisa ga ayyukan layi da aka fayyace.\n   Aikin yana amfani da daban-daban dabaru bisa ga darajar x:\n   - Don x ƙasa da 1, yana dawowa x.\n   - Don x tsakanin 1 da 10, yana dawowa 2x - 1.\n   - Don x mafi girma ko daidai da 10, yana dawowa 3x - 11.\n   Misalan yanayi:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* इनपुट x के आधार पर निर्दिष्ट रैखिक कार्यों के अनुसार एक मान की गणना करता है।\n   फ़ंक्शन x के मान के आधार पर विभिन्न सूत्र लागू करता है:\n   - x के लिए 1 से कम, x लौटाता है।\n   - x के लिए 1 और 10 के बीच, 2x - 1 लौटाता है।\n   - x के लिए 10 के बराबर या उससे अधिक, 3x - 11 लौटाता है।\n   उदाहरण मामले:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Értéket számít az x bemenet alapján a megadott lineáris függvények szerint.\n   A függvény különböző képleteket alkalmaz az x értékétől függően:\n   - Ha x kisebb, mint 1, akkor x-et ad vissza.\n   - Ha x 1 és 10 között van, akkor 2x - 1-et ad vissza.\n   - Ha x nagyobb vagy egyenlő 10-nél, akkor 3x - 11-et ad vissza.\n   Példa esetek:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)"
    },
    "prompt_bertscore": {
      "sq": "0.9905058650472944",
      "hy": "0.9766865535475542",
      "bn": "0.957123645949809",
      "bg": "0.9901628303792471",
      "zh": "0.9801391468307026",
      "fr": "0.9919185243172145",
      "de": "0.9931265942946688",
      "ha": "0.9572170022288954",
      "hi": "0.9835837948986096",
      "hu": "0.9693995993889082"
    },
    "canonical_solution": "{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}",
    "instruction": {
      "en": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nՏվեք C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\n请用不超过500个字符的中文为以下C#代码提供简明的自然语言描述（文档字符串）。",
      "fr": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9226191651994765",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9243830029830663",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(ComputeValue(0.5) == 0.5);\n        Debug.Assert(ComputeValue(2) == 3);\n        Debug.Assert(ComputeValue(5) == 9);\n        Debug.Assert(ComputeValue(10) == 19);\n        Debug.Assert(ComputeValue(15) == 34);\n        Debug.Assert(ComputeValue(0) == 0);\n        Debug.Assert(ComputeValue(1) == 1);\n\n    }\n}",
    "entry_point": "ComputeValue",
    "signature": "static double ComputeValue(double x)",
    "docstring": {
      "en": "Computes a value based on the input x according to specified linear functions.\n   The function applies different formulas based on the value of x:\n   - For x less than 1, returns x.\n   - For x between 1 and 10, returns 2x - 1.\n   - For x greater than or equal to 10, returns 3x - 11.\n   Example cases:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "sq": "Llogarit një vlerë bazuar në hyrjen x sipas funksioneve lineare të specifikuara.\n   Funksioni aplikon formula të ndryshme bazuar në vlerën e x:\n   - Për x më pak se 1, kthen x.\n   - Për x midis 1 dhe 10, kthen 2x - 1.\n   - Për x më të madh ose të barabartë me 10, kthen 3x - 11.\n   Shembuj rastesh:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "hy": "Հաշվում է արժեքը `x` մուտքագրվածի հիման վրա ըստ նշված գծային ֆունկցիաների: \n   Ֆունկցիան կիրառվում է տարբեր բանաձևեր `x`-ի արժեքի հիման վրա:\n   - Եթե `x`-ը փոքր է 1-ից, վերադարձնում է `x`:\n   - Եթե `x`-ը 1-ից և 10-ից միջև է, վերադարձնում է `2x - 1`:\n   - Եթե `x`-ը մեծ կամ հավասար է 10-ի, վերադարձնում է `3x - 11`:\n   Օրինակային դեպքեր:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "bn": "একটি নির্দিষ্ট লিনিয়ার ফাংশন অনুযায়ী ইনপুট x এর উপর ভিত্তি করে একটি মান গণনা করে।\n   ফাংশনটি x এর মানের উপর ভিত্তি করে বিভিন্ন সূত্র প্রয়োগ করে:\n   - x যদি 1 এর চেয়ে কম হয়, তাহলে x ফেরত দেয়।\n   - x যদি 1 এবং 10 এর মধ্যে হয়, তাহলে 2x - 1 ফেরত দেয়।\n   - x যদি 10 এর সমান বা তার চেয়ে বড় হয়, তাহলে 3x - 11 ফেরত দেয়।\n   উদাহরণ কেস:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "bg": "Изчислява стойност на базата на входа x според специфични линейни функции.\n   Функцията прилага различни формули в зависимост от стойността на x:\n   - За x по-малко от 1, връща x.\n   - За x между 1 и 10, връща 2x - 1.\n   - За x по-голямо или равно на 10, връща 3x - 11.\n   Примерни случаи:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "zh": "根据指定的线性函数根据输入 x 计算值。\n   该函数根据 x 的值应用不同的公式：\n   - 对于 x 小于 1，返回 x。\n   - 对于 x 在 1 和 10 之间，返回 2x - 1。\n   - 对于 x 大于或等于 10，返回 3x - 11。\n   示例案例：\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "fr": "Calcule une valeur basée sur l'entrée x selon des fonctions linéaires spécifiées.\n   La fonction applique différentes formules en fonction de la valeur de x :\n   - Pour x inférieur à 1, retourne x.\n   - Pour x entre 1 et 10, retourne 2x - 1.\n   - Pour x supérieur ou égal à 10, retourne 3x - 11.\n   Cas d'exemple :\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "de": "Berechnet einen Wert basierend auf der Eingabe x gemäß den angegebenen linearen Funktionen.\n   Die Funktion wendet unterschiedliche Formeln basierend auf dem Wert von x an:\n   - Für x kleiner als 1, gibt x zurück.\n   - Für x zwischen 1 und 10, gibt 2x - 1 zurück.\n   - Für x größer oder gleich 10, gibt 3x - 11 zurück.\n   Beispielhafte Fälle:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "ha": "Yana lissafin wata kima bisa ga shigar x bisa ga takamaiman ayyukan layi.\n   Aikin yana amfani da daban-daban dabaru dangane da ƙimar x:\n   - Ga x ƙasa da 1, yana dawo da x.\n   - Ga x tsakanin 1 da 10, yana dawo da 2x - 1.\n   - Ga x mafi girma ko daidai da 10, yana dawo da 3x - 11.\n   Misalan lokuta:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "hi": "इनपुट x के आधार पर निर्दिष्ट रैखिक कार्यों के अनुसार एक मान की गणना करता है। \n   यह फ़ंक्शन x के मान के आधार पर विभिन्न सूत्र लागू करता है:\n   - x के लिए जो 1 से कम है, x लौटाता है।\n   - x के लिए जो 1 और 10 के बीच है, 2x - 1 लौटाता है।\n   - x के लिए जो 10 के बराबर या उससे अधिक है, 3x - 11 लौटाता है।\n   उदाहरण मामले:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "hu": "Számít egy értéket az x bemenet alapján a megadott lineáris függvények szerint.\n   A függvény különböző képleteket alkalmaz az x értékétől függően:\n   - Ha x kisebb, mint 1, visszaadja x-et.\n   - Ha x 1 és 10 között van, visszaadja 2x - 1-et.\n   - Ha x nagyobb vagy egyenlő, mint 10, visszaadja 3x - 11-et.\n   Példa esetek:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19"
    },
    "docstring_bertscore": {
      "sq": "0.9868778811376921",
      "hy": "0.8875303138681394",
      "bn": "0.9481614431575148",
      "bg": "0.9845632413074926",
      "zh": "0.9704201622866655",
      "fr": "0.982669300624325",
      "de": "0.9871752308181014",
      "ha": "0.9764648820423192",
      "hi": "0.9777019520554044",
      "hu": "0.9509410767097171"
    }
  },
  {
    "task_id": "C#/5",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   For example, 153 is a narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n   \n   Examples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kjo funksion gjen të gjitha numrat narcisistë brenda një intervali të dhënë.\n   Një numër narcisist është një numër që është shuma e shifrave të tij, secila e ngritur në fuqinë e numrit të shifrave.\n   Për shembull, 153 është një numër narcisist sepse 153 = 1^3 + 5^3 + 3^3.\n   \n   Shembuj:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Այս ֆունկցիան գտնում է բոլոր նարցիսիստական թվերը տրված միջակայքում:\n   Նարցիսիստական թիվը այն թիվն է, որը հավասար է իր թվանշանների գումարին, երբ յուրաքանչյուր թվանշան բարձրացված է թվանշանների քանակի աստիճանի:\n   Օրինակ, 153-ը նարցիսիստական թիվ է, որովհետև 153 = 1^3 + 5^3 + 3^3:\n   \n   Օրինակներ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* এই ফাংশনটি একটি নির্দিষ্ট সীমার মধ্যে সমস্ত নার্সিসিস্টিক সংখ্যা খুঁজে বের করে।\n   একটি নার্সিসিস্টিক সংখ্যা হল এমন একটি সংখ্যা যা তার নিজের অঙ্কগুলোর সমষ্টি, প্রতিটি অঙ্কের সংখ্যা দ্বারা ঘাতিত।\n   উদাহরণস্বরূপ, 153 একটি নার্সিসিস্টিক সংখ্যা কারণ 153 = 1^3 + 5^3 + 3^3।\n\n   উদাহরণ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Тази функция намира всички нарцистични числа в даден диапазон.\n   Нарцистично число е число, което е сумата от собствените си цифри, всяка повдигната на степента на броя на цифрите.\n   Например, 153 е нарцистично число, защото 153 = 1^3 + 5^3 + 3^3.\n   \n   Примери:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 此函数查找给定范围内的所有水仙花数。\n   水仙花数是指每个位数的数字的幂次和等于该数本身的数。\n   例如，153 是一个水仙花数，因为 153 = 1^3 + 5^3 + 3^3。\n   \n   示例:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Cette fonction trouve tous les nombres narcissiques dans une plage donnée.\n   Un nombre narcissique est un nombre qui est la somme de ses propres chiffres chacun élevé à la puissance du nombre de chiffres.\n   Par exemple, 153 est un nombre narcissique parce que 153 = 1^3 + 5^3 + 3^3.\n   \n   Exemples :\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Diese Funktion findet alle narzisstischen Zahlen innerhalb eines gegebenen Bereichs.\n   Eine narzisstische Zahl ist eine Zahl, die die Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Anzahl der Ziffern erhoben wird.\n   Zum Beispiel ist 153 eine narzisstische Zahl, weil 153 = 1^3 + 5^3 + 3^3.\n   \n   Beispiele:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Wannan aikin yana nemo duk lambobin narcissistic a cikin wani kewayon.\n   Lamba narcissistic ita ce lamba da take daidai da jumlar lambobinta da aka ɗaga kowanne zuwa ƙarfin adadin lambobin.\n   Misali, 153 lamba narcissistic ce saboda 153 = 1^3 + 5^3 + 3^3.\n   \n   Misalai:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह फ़ंक्शन दिए गए सीमा के भीतर सभी नार्सिसिस्टिक संख्याएँ खोजता है।\n   एक नार्सिसिस्टिक संख्या वह संख्या होती है जो अपने स्वयं के अंकों का योग होती है, प्रत्येक अंक को अंकों की संख्या की घात तक उठाया जाता है।\n   उदाहरण के लिए, 153 एक नार्सिसिस्टिक संख्या है क्योंकि 153 = 1^3 + 5^3 + 3^3।\n   \n   उदाहरण:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ez a függvény megtalálja az összes nárcisztikus számot egy adott tartományon belül.\n   Egy nárcisztikus szám olyan szám, amely a saját számjegyeinek összege, mindegyik a számjegyek számának hatványára emelve.\n   Például, a 153 egy nárcisztikus szám, mert 153 = 1^3 + 5^3 + 3^3.\n   \n   Példák:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)"
    },
    "prompt_bertscore": {
      "sq": "0.9921858808100875",
      "hy": "0.9792085634955541",
      "bn": "0.9906321939696326",
      "bg": "0.9986304435227644",
      "zh": "0.9991254304323034",
      "fr": "0.9986304435227644",
      "de": "0.9876187724589524",
      "ha": "0.98480457722045",
      "hi": "0.99305965585626",
      "hu": "1"
    },
    "canonical_solution": "{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}",
    "instruction": {
      "en": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nՏվեք C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简明的自然语言描述（文档字符串）。",
      "fr": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C# a Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.948868567313999",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9543420260937965",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n \n        Debug.Assert(FindNarcissisticNumbers(100, 170).SequenceEqual(new List<int> { 153 }));\n        Debug.Assert(FindNarcissisticNumbers(100, 500).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(1, 100).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(370, 380).SequenceEqual(new List<int> { 370, 371 }));\n        Debug.Assert(FindNarcissisticNumbers(0, 999).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(900, 1000).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(10, 15).SequenceEqual(new List<int> { }));\n\n    }\n}",
    "entry_point": "FindNarcissisticNumbers",
    "signature": "static List<int> FindNarcissisticNumbers(int start, int end)",
    "docstring": {
      "en": "This function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   For example, 153 is a narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n   \n   Examples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "sq": "Kjo funksion gjen të gjitha numrat narcisistë brenda një diapazoni të dhënë. Një numër narcisist është një numër që është shuma e vetë shifrave të tij, secila e ngritur në fuqinë e numrit të shifrave. Për shembull, 153 është një numër narcisist sepse 153 = 1^3 + 5^3 + 3^3.\n\nShembuj:\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]",
      "hy": "This function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   Օրինակ, 153-ը նարցիսիստական թիվ է, որովհետև 153 = 1^3 + 5^3 + 3^3։\n\n   Օրինակներ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "bn": "This function finds all narcissistic numbers within a given range.\n   একটি নার্সিসিস্টিক সংখ্যা হল একটি সংখ্যা যা তার নিজের অঙ্কগুলির সমষ্টি, প্রতিটি অঙ্কের সংখ্যা অনুযায়ী ঘাতের সাথে উত্তোলিত।\n   উদাহরণস্বরূপ, 153 একটি নার্সিসিস্টিক সংখ্যা কারণ 153 = 1^3 + 5^3 + 3^3।\n\n   উদাহরণ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "bg": "Тази функция намира всички нарцистични числа в даден диапазон. Нарцистично число е число, което е сумата от собствените си цифри, всяка повдигната на степента на броя на цифрите. Например, 153 е нарцистично число, защото 153 = 1^3 + 5^3 + 3^3.\n\nПримери:\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]",
      "zh": "This function finds all narcissistic numbers within a given range.\n   一个水仙花数是一个数字，其自身数字的每个数字的幂次和等于该数字。\n   例如，153 是一个水仙花数，因为 153 = 1^3 + 5^3 + 3^3。\n   \n   示例:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "fr": "Cette fonction trouve tous les nombres narcissiques dans une plage donnée.  \n   Un nombre narcissique est un nombre qui est la somme de ses propres chiffres, chacun élevé à la puissance du nombre de chiffres.  \n   Par exemple, 153 est un nombre narcissique car 153 = 1^3 + 5^3 + 3^3.\n   \n   Exemples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "de": "This function findet alle narzisstischen Zahlen innerhalb eines gegebenen Bereichs.\n   Eine narzisstische Zahl ist eine Zahl, die die Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Anzahl der Ziffern erhoben wird.\n   Zum Beispiel ist 153 eine narzisstische Zahl, weil 153 = 1^3 + 5^3 + 3^3.\n   \n   Beispiele:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "ha": "Wannan aikin yana nemo duk lambobin narcissistic a cikin kewayon da aka bayar.\n   Lambar narcissistic ita ce lamba da ke daidai da jumlar lambobinta na kansu kowanne ɗaga su an ɗaga shi zuwa ikon adadin lambobin.\n   Alal misali, 153 lamba ce ta narcissistic saboda 153 = 1^3 + 5^3 + 3^3.\n   \n   Misalai:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "hi": "This function finds all narcissistic numbers within a given range.  \n   एक narcissistic संख्या वह संख्या होती है जो अपने स्वयं के अंकों का योग होती है, प्रत्येक अंक को अंकों की संख्या की शक्ति तक उठाया जाता है।  \n   उदाहरण के लिए, 153 एक narcissistic संख्या है क्योंकि 153 = 1^3 + 5^3 + 3^3।  \n   \n   उदाहरण:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "hu": "This function finds all narcissistic numbers within a given range.\n   Egy nárcisztikus szám olyan szám, amely saját számjegyeinek összegével egyenlő, mindegyik számjegy a számjegyek számának hatványára emelve.\n   Például, a 153 egy nárcisztikus szám, mert 153 = 1^3 + 5^3 + 3^3.\n   \n   Példák:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]"
    },
    "docstring_bertscore": {
      "sq": "0.9951587817230366",
      "hy": "0.999999801369619",
      "bn": "0.9937147388529131",
      "bg": "0.9933339644124691",
      "zh": "0.9861731405457804",
      "fr": "0.9951587817230366",
      "de": "0.9837754732163083",
      "ha": "0.9807112023280831",
      "hi": "0.9937147388529131",
      "hu": "0.9878597111111477"
    }
  },
  {
    "task_id": "C#/6",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sorts three given integers in ascending order and returns the sorted list.\n    Example usage:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Radhit tre numra të dhënë të plotë në rend rritës dhe kthen listën e renditur.\n    Shembull përdorimi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Տրված երեք ամբողջ թվերը դասավորում է աճման կարգով և վերադարձնում դասավորված ցուցակը:\n    Օրինակ օգտագործում:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* তিনটি প্রদত্ত পূর্ণসংখ্যা ক্রমবর্ধমান ক্রমে সাজায় এবং সাজানো তালিকা ফেরত দেয়।\n    উদাহরণ ব্যবহার:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Сортира три дадени цели числа във възходящ ред и връща сортирания списък.\n    Пример за използване:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 将三个给定的整数按升序排序并返回排序后的列表。\n    使用示例:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Trie trois entiers donnés par ordre croissant et renvoie la liste triée.\n    Exemple d'utilisation :\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sortiert drei gegebene ganze Zahlen in aufsteigender Reihenfolge und gibt die sortierte Liste zurück.\n    Beispielverwendung:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Yana tsara lambobi guda uku da aka bayar a cikin tsari mai hawa kuma yana mayar da jerin da aka tsara.\n    Misalin amfani:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* तीन दिए गए पूर्णांकों को आरोही क्रम में सॉर्ट करता है और सॉर्ट की गई सूची लौटाता है।\n    उदाहरण उपयोग:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Három adott egész számot növekvő sorrendbe rendez és visszaadja a rendezett listát.\n    Példa használat:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)"
    },
    "prompt_bertscore": {
      "sq": "0.9924554222371519",
      "hy": "0.9922987028665153",
      "bn": "1",
      "bg": "1",
      "zh": "0.9920905382271907",
      "fr": "0.9945380617823026",
      "de": "1",
      "ha": "0.9857637633304674",
      "hi": "1",
      "hu": "1"
    },
    "canonical_solution": "{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}",
    "instruction": {
      "en": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nՏվեք C# կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 символа.",
      "zh": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\n请用不超过500个字符的中文为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9639110447001522",
      "bn": "0.8778230485165833",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9062111039437085",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(SortIntegersAscending(3, 1, 2).SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(SortIntegersAscending(5, 7, 2).SequenceEqual(new List<int> { 2, 5, 7 }));\n        Debug.Assert(SortIntegersAscending(-1, 0, -3).SequenceEqual(new List<int> { -3, -1, 0 }));\n        Debug.Assert(SortIntegersAscending(10, 10, 10).SequenceEqual(new List<int> { 10, 10, 10 }));\n        Debug.Assert(SortIntegersAscending(0, -1, 1).SequenceEqual(new List<int> { -1, 0, 1 }));\n        Debug.Assert(SortIntegersAscending(100, 50, 75).SequenceEqual(new List<int> { 50, 75, 100 }));\n        Debug.Assert(SortIntegersAscending(-5, -10, -7).SequenceEqual(new List<int> { -10, -7, -5 }));\n\n\n    }\n}",
    "entry_point": "SortIntegersAscending",
    "signature": "static List<int> SortIntegersAscending(int num1, int num2, int num3)",
    "docstring": {
      "en": "Sorts three given integers in ascending order and returns the sorted list.\n    Example usage:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "sq": "Rendit tre numra të plotë të dhënë në rend rritës dhe kthen listën e renditur.\n    Shembull përdorimi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hy": "Դասավորում է երեք տրված ամբողջ թվերը աճման կարգով և վերադարձնում դասավորված ցուցակը։\n    Օրինակ օգտագործում՝\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "bn": "তিনটি প্রদত্ত পূর্ণসংখ্যাকে ঊর্ধ্বক্রমে সাজায় এবং সাজানো তালিকা ফেরত দেয়।\n    উদাহরণ ব্যবহার:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "bg": "Сортира три дадени цели числа във възходящ ред и връща сортирания списък.\n    Пример за използване:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "zh": "对给定的三个整数进行升序排序并返回排序后的列表。\n    示例用法：\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "fr": "Trie trois entiers donnés par ordre croissant et renvoie la liste triée.\n    Exemple d'utilisation :\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "de": "Sortiert drei gegebene ganze Zahlen in aufsteigender Reihenfolge und gibt die sortierte Liste zurück.\n    Beispielverwendung:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "ha": "Yana jera lambobi guda uku da aka bayar a cikin tsari mai tashi kuma yana mayar da jerin da aka jera.\n    Misalin amfani:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hi": "तीन दिए गए पूर्णांकों को आरोही क्रम में क्रमबद्ध करता है और क्रमबद्ध सूची लौटाता है।\n    उदाहरण उपयोग:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hu": "Három megadott egész számot növekvő sorrendbe rendez, és visszaadja a rendezett listát.\n    Használati példa:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]"
    },
    "docstring_bertscore": {
      "sq": "0.9908635983635382",
      "hy": "0.992638559448466",
      "bn": "1",
      "bg": "1",
      "zh": "0.9880227866539772",
      "fr": "0.9908097695302778",
      "de": "1",
      "ha": "0.9759166621906629",
      "hi": "0.992638559448466",
      "hu": "0.9974189968288326"
    }
  },
  {
    "task_id": "C#/7",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Copies a substring from the specified start index in the input string to the end of the string.\n   If the start index is greater than the string's length, returns an empty string.\n   Examples:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kopjon një nënvarg nga indeksi i specifikuar i fillimit në vargun hyrës deri në fund të vargut.\n   Nëse indeksi i fillimit është më i madh se gjatësia e vargut, kthen një varg bosh.\n   Shembuj:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Պատճենում է ենթատողը նշված մեկնարկային ինդեքսից մուտքագրված տողի վերջ:\n   Եթե մեկնարկային ինդեքսը մեծ է տողի երկարությունից, վերադարձնում է դատարկ տող:\n   Օրինակներ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* নির্দিষ্ট শুরুর সূচক থেকে ইনপুট স্ট্রিংয়ের শেষ পর্যন্ত একটি সাবস্ট্রিং কপি করে।\n   যদি শুরুর সূচক স্ট্রিংয়ের দৈর্ঘ্যের চেয়ে বড় হয়, তাহলে একটি খালি স্ট্রিং ফেরত দেয়।\n   উদাহরণ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Копира подниз от зададения начален индекс в входния низ до края на низа.\n   Ако началният индекс е по-голям от дължината на низа, връща празен низ.\n   Примери:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 从输入字符串中指定的起始索引复制子字符串到字符串的末尾。\n   如果起始索引大于字符串的长度，则返回一个空字符串。\n   示例:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Copie une sous-chaîne à partir de l'index de début spécifié dans la chaîne d'entrée jusqu'à la fin de la chaîne.\n   Si l'index de début est supérieur à la longueur de la chaîne, retourne une chaîne vide.\n   Exemples :\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kopiert einen Teilstring vom angegebenen Startindex im Eingabestring bis zum Ende des Strings.\n   Wenn der Startindex größer als die Länge des Strings ist, wird ein leerer String zurückgegeben.\n   Beispiele:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kwafi wani ɓangare na rubutu daga takamaiman farawa a cikin rubutun shigarwa zuwa ƙarshen rubutun.\n   Idan farawa ya fi tsayin rubutun, zai dawo da rubutu mara komai.\n   Misalai:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* इनपुट स्ट्रिंग में निर्दिष्ट प्रारंभिक इंडेक्स से स्ट्रिंग के अंत तक एक उपस्ट्रिंग की प्रतिलिपि बनाता है।\n   यदि प्रारंभिक इंडेक्स स्ट्रिंग की लंबाई से अधिक है, तो एक खाली स्ट्रिंग लौटाता है।\n   उदाहरण:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Egy részsztringet másol a megadott kezdőindextől a bemeneti sztring végéig.\n   Ha a kezdőindex nagyobb, mint a sztring hossza, üres sztringet ad vissza.\n   Példák:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)"
    },
    "prompt_bertscore": {
      "sq": "0.9917375720400917",
      "hy": "0.9829499653527273",
      "bn": "0.9757285592198228",
      "bg": "0.9877603959206301",
      "zh": "0.9826969102472888",
      "fr": "0.9917375720400917",
      "de": "0.9849938719735762",
      "ha": "0.9351940573620332",
      "hi": "0.9853613381784908",
      "hu": "0.9764575327182209"
    },
    "canonical_solution": "{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}",
    "instruction": {
      "en": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nՏվեք C# կոդի հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nনিচের C# কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简明的自然语言描述（文档字符串）。",
      "fr": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568463579378843",
      "hy": "0.9169325760208287",
      "bn": "0.8797765783140615",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.8819054987379934",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(CopySubstringFromIndex(\"Hello World\", 6) == \"World\");\n        Debug.Assert(CopySubstringFromIndex(\"Example\", 3) == \"mple\");\n        Debug.Assert(CopySubstringFromIndex(\"Short\", 10) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"AnotherExample\", 0) == \"AnotherExample\");\n        Debug.Assert(CopySubstringFromIndex(\"Test\", 4) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"\", 0) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"LastOne\", 7) == \"\");\n\n    }\n}",
    "entry_point": "CopySubstringFromIndex",
    "signature": "static string CopySubstringFromIndex(string input, int startIndex)",
    "docstring": {
      "en": "Copies a substring from the specified start index in the input string to the end of the string.\n   If the start index is greater than the string's length, returns an empty string.\n   Examples:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "sq": "Kopjon një nënvarg nga indeksi i specifikuar i fillimit në vargun e hyrjes deri në fund të vargut.\n   Nëse indeksi i fillimit është më i madh se gjatësia e vargut, kthen një varg bosh.\n   Shembuj:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "hy": "Պատճենում է ենթատողը մուտքային տողի նշված սկզբնական ինդեքսից մինչև տողի վերջը:\n   Եթե սկզբնական ինդեքսը մեծ է տողի երկարությունից, վերադարձնում է դատարկ տող:\n   Օրինակներ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "bn": "নির্দিষ্ট শুরুর সূচক থেকে ইনপুট স্ট্রিংয়ের শেষ পর্যন্ত একটি সাবস্ট্রিং কপি করে।  \nযদি শুরুর সূচক স্ট্রিংয়ের দৈর্ঘ্যের চেয়ে বড় হয়, তাহলে একটি খালি স্ট্রিং ফেরত দেয়।  \nউদাহরণসমূহ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "bg": "Копира подниз от зададения начален индекс в входния низ до края на низа.\nАко началният индекс е по-голям от дължината на низа, връща празен низ.\nПримери:\n>>> CopySubstringFromIndex(\"Hello World\", 6)\n\"World\"\n>>> CopySubstringFromIndex(\"Example\", 3)\n\"mple\"\n>>> CopySubstringFromIndex(\"Short\", 10)\n\"\"",
      "zh": "从输入字符串的指定起始索引复制子字符串到字符串的末尾。\n如果起始索引大于字符串的长度，则返回一个空字符串。\n示例：\n>>> CopySubstringFromIndex(\"Hello World\", 6)\n\"World\"\n>>> CopySubstringFromIndex(\"Example\", 3)\n\"mple\"\n>>> CopySubstringFromIndex(\"Short\", 10)\n\"\"",
      "fr": "Copie une sous-chaîne à partir de l'index de départ spécifié dans la chaîne d'entrée jusqu'à la fin de la chaîne.\n   Si l'index de départ est supérieur à la longueur de la chaîne, retourne une chaîne vide.\n   Exemples :\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "de": "Kopiert einen Teilstring vom angegebenen Startindex im Eingabestring bis zum Ende des Strings.\n   Wenn der Startindex größer als die Länge des Strings ist, wird ein leerer String zurückgegeben.\n   Beispiele:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "ha": "Kwafi wani yanki na rubutu daga takamaiman farawa a cikin rubutun shigarwa zuwa ƙarshen rubutun.\n   Idan farawar ya fi tsawon rubutun, zai dawo da rubutu mara komai.\n   Misalai:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "hi": "निर्दिष्ट प्रारंभ इंडेक्स से इनपुट स्ट्रिंग के अंत तक एक उपस्ट्रिंग की प्रतिलिपि बनाता है। \n   यदि प्रारंभ इंडेक्स स्ट्रिंग की लंबाई से अधिक है, तो एक खाली स्ट्रिंग लौटाता है।\n   उदाहरण:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "hu": "Lemásol egy részsztringet a megadott kezdőindexből a bemeneti sztring végéig.\n   Ha a kezdőindex nagyobb, mint a sztring hossza, üres sztringet ad vissza.\n   Példák:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\""
    },
    "docstring_bertscore": {
      "sq": "0.9931657244797326",
      "hy": "0.958455661285029",
      "bn": "0.9715807596030523",
      "bg": "0.9881391840572638",
      "zh": "0.977727178113796",
      "fr": "0.9865280930366898",
      "de": "0.9870600251971011",
      "ha": "0.9067557484485063",
      "hi": "0.9370119226092646",
      "hu": "0.9775595340722024"
    }
  },
  {
    "task_id": "C#/8",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Converts a given number of seconds into a formatted time string without leading zeros.\n    The format of the output is \"<Hours>:<Minutes>:<Seconds>\". Each component is an integer without leading zeros.\n    Examples:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Konverton një numër të dhënë sekondash në një varg të formatuar kohe pa zero në fillim.\n    Formati i daljes është \"<Orë>:<Minuta>:<Sekonda>\". Secili komponent është një numër i plotë pa zero në fillim.\n    Shembuj:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Փոխակերպում է տրված վայրկյանների քանակը ձևաչափված ժամանակի տողի՝ առանց առաջատար զրոների:\n    Ելքի ձևաչափը \"<Hours>:<Minutes>:<Seconds>\" է: Յուրաքանչյուր բաղադրիչ ամբողջ թիվ է՝ առանց առաջատար զրոների:\n    Օրինակներ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* প্রদত্ত সেকেন্ড সংখ্যাকে একটি বিন্যাসিত সময় স্ট্রিংয়ে রূপান্তর করে যা শূন্য দিয়ে শুরু হয় না।\n    আউটপুটের বিন্যাস \"<ঘন্টা>:<মিনিট>:<সেকেন্ড>\"। প্রতিটি উপাদান একটি পূর্ণসংখ্যা যা শূন্য দিয়ে শুরু হয় না।\n    উদাহরণ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Преобразува даден брой секунди във форматиран низ за време без водещи нули.\n    Форматът на изхода е \"<Часове>:<Минути>:<Секунди>\". Всеки компонент е цяло число без водещи нули.\n    Примери:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 将给定的秒数转换为无前导零的格式化时间字符串。\n    输出格式为\"<小时>:<分钟>:<秒>\"。每个部分都是没有前导零的整数。\n    示例:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Convertit un nombre donné de secondes en une chaîne de temps formatée sans zéros initiaux.\n    Le format de la sortie est \"<Heures>:<Minutes>:<Secondes>\". Chaque composant est un entier sans zéros initiaux.\n    Exemples :\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Konvertiert eine gegebene Anzahl von Sekunden in einen formatierten Zeitstring ohne führende Nullen.\n    Das Format der Ausgabe ist \"<Stunden>:<Minuten>:<Sekunden>\". Jede Komponente ist eine ganze Zahl ohne führende Nullen.\n    Beispiele:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Yana canza adadin da aka bayar na daƙiƙa zuwa kirtani lokaci da aka tsara ba tare da sifili na gaba ba.\n    Tsarin fitarwa shine \"<Hours>:<Minutes>:<Seconds>\". Kowanne bangare yana da adadi ba tare da sifili na gaba ba.\n    Misalai:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* दिए गए सेकंड की संख्या को बिना अग्रणी शून्य के स्वरूपित समय स्ट्रिंग में परिवर्तित करता है।\n    आउटपुट का स्वरूप \"<Hours>:<Minutes>:<Seconds>\" है। प्रत्येक घटक अग्रणी शून्य के बिना एक पूर्णांक है।\n    उदाहरण:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Átalakítja a megadott másodpercek számát egy formázott idő karakterlánccá vezető nullák nélkül.\n    A kimenet formátuma \"<Órák>:<Percek>:<Másodpercek>\". Minden összetevő egy egész szám vezető nullák nélkül.\n    Példák:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)"
    },
    "prompt_bertscore": {
      "sq": "0.9919175311653093",
      "hy": "0.9903257072916958",
      "bn": "0.9581946609643491",
      "bg": "0.9919175311653093",
      "zh": "0.9726247608857717",
      "fr": "0.9919175311653093",
      "de": "0.9951887749105729",
      "ha": "0.974175071009749",
      "hi": "0.9974559420797051",
      "hu": "0.9903257072916958"
    },
    "canonical_solution": "{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}",
    "instruction": {
      "en": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nՏվեք C# կոդի հակիրճ բնութագրությունը (docstring) հայերեն՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nনিচের C# কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में 500 वर्णों तक प्रदान करें।",
      "hu": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9287852481179426",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9252758465458182",
      "hi": "0.9056009114131693",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FormatTime(0) == \"0:0:0\");\n        Debug.Assert(FormatTime(3661) == \"1:1:1\");\n        Debug.Assert(FormatTime(5436) == \"1:30:36\");\n        Debug.Assert(FormatTime(3600) == \"1:0:0\");\n        Debug.Assert(FormatTime(7200) == \"2:0:0\");\n        Debug.Assert(FormatTime(86399) == \"23:59:59\");\n        Debug.Assert(FormatTime(12345) == \"3:25:45\");\n\n    }\n}",
    "entry_point": "FormatTime",
    "signature": "static string FormatTime(int seconds)",
    "docstring": {
      "en": "Converts a given number of seconds into a formatted time string without leading zeros.\n    The format of the output is \"<Hours>:<Minutes>:<Seconds>\". Each component is an integer without leading zeros.\n    Examples:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "sq": "Konverton një numër të dhënë sekondash në një varg kohe të formatuar pa zero të parashtruara.\n    Formati i daljes është \"<Orë>:<Minuta>:<Sekonda>\". Çdo komponent është një numër i plotë pa zero të parashtruara.\n    Shembuj:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "hy": "Վերածում է տրված վայրկյանների քանակը ձևաչափված ժամանակի տողի առանց զրոների: \n    Արդյունքի ձևաչափը \"<Ժամեր>:<Րոպեներ>:<Վայրկյաններ>\" է: Յուրաքանչյուր բաղադրիչ ամբողջ թիվ է առանց զրոների: \n    Օրինակներ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "bn": "প্রদত্ত সেকেন্ডের সংখ্যা একটি বিন্যাসিত সময় স্ট্রিংয়ে রূপান্তর করে যা শূন্য দিয়ে শুরু হয় না। \n    আউটপুটের বিন্যাস \"<Hours>:<Minutes>:<Seconds>\"। প্রতিটি উপাদান একটি পূর্ণসংখ্যা যা শূন্য দিয়ে শুরু হয় না।\n    উদাহরণ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "bg": "Преобразува даден брой секунди в форматиран низ за време без водещи нули.\nФорматът на изхода е \"<Часове>:<Минути>:<Секунди>\". Всеки компонент е цяло число без водещи нули.\nПримери:\n>>> FormatTime(0)\n\"0:0:0\"\n>>> FormatTime(3661)\n\"1:1:1\"\n>>> FormatTime(5436)\n\"1:30:36\"",
      "zh": "将给定的秒数转换为没有前导零的格式化时间字符串。\n输出格式为 \"<小时>:<分钟>:<秒>\"。每个部分都是没有前导零的整数。\n示例：\n>>> FormatTime(0)\n\"0:0:0\"\n>>> FormatTime(3661)\n\"1:1:1\"\n>>> FormatTime(5436)\n\"1:30:36\"",
      "fr": "Convertit un nombre donné de secondes en une chaîne de temps formatée sans zéros initiaux.\n    Le format de la sortie est \"<Heures>:<Minutes>:<Secondes>\". Chaque composant est un entier sans zéros initiaux.\n    Exemples :\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "de": "Konvertiert eine gegebene Anzahl von Sekunden in einen formatierten Zeitstring ohne führende Nullen.\n    Das Format der Ausgabe ist \"<Stunden>:<Minuten>:<Sekunden>\". Jede Komponente ist eine ganze Zahl ohne führende Nullen.\n    Beispiele:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "ha": "Canza adadin da aka bayar na daƙiƙoƙi zuwa tsari na lokaci ba tare da sifili na farko ba.  \n    Tsarin fitarwa shine \"<Hours>:<Minutes>:<Seconds>\". Kowanne bangare yana da adadi ba tare da sifili a gaba ba.  \n    Misalai:  \n    >>> FormatTime(0)  \n    \"0:0:0\"  \n    >>> FormatTime(3661)  \n    \"1:1:1\"  \n    >>> FormatTime(5436)  \n    \"1:30:36\"  ",
      "hi": "दिए गए सेकंड की संख्या को बिना अग्रणी शून्य के एक स्वरूपित समय स्ट्रिंग में परिवर्तित करता है। \n    आउटपुट का प्रारूप \"<घंटे>:<मिनट>:<सेकंड>\" है। प्रत्येक घटक अग्रणी शून्य के बिना एक पूर्णांक है।\n    उदाहरण:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "hu": "Átalakít egy adott számú másodpercet egy formázott idő karakterlánccá vezető nullák nélkül.\n    A kimenet formátuma \"<Órák>:<Percek>:<Másodpercek>\". Minden összetevő egy egész szám vezető nullák nélkül.\n    Példák:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\""
    },
    "docstring_bertscore": {
      "sq": "0.9910993726258267",
      "hy": "0.9913923524378532",
      "bn": "0.9354199001052699",
      "bg": "0.9810160999629716",
      "zh": "0.9575304409701685",
      "fr": "0.9910993726258267",
      "de": "0.9940190405966585",
      "ha": "0.9769191497237459",
      "hi": "0.9906486802912585",
      "hu": "0.9910993726258267"
    }
  },
  {
    "task_id": "C#/9",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Calculates the area of intersection between two rectangles.\n   Each rectangle is defined by the coordinates of its top-left (x1, y1) and bottom-right (x2, y2) corners.\n   \n   Examples:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (No Intersection)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Llogarit sipërfaqen e ndërprerjes midis dy drejtkëndëshave.\n   Secili drejtkëndësh përcaktohet nga koordinatat e këndeve të tij të sipërme-majtas (x1, y1) dhe të poshtme-djathtas (x2, y2).\n   \n   Shembuj:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pa Ndërprerje)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Հաշվում է երկու ուղղանկյունների հատման մակերեսը։\n   Յուրաքանչյուր ուղղանկյուն սահմանվում է իր վերևի ձախ (x1, y1) և ներքևի աջ (x2, y2) անկյունների կոորդինատներով։\n   \n   Օրինակներ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Հատում չկա)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* দুটি আয়তক্ষেত্রের মধ্যে ছেদ এলাকার হিসাব করে।\n   প্রতিটি আয়তক্ষেত্র তার উপরের-বাম (x1, y1) এবং নিচের-ডান (x2, y2) কোণগুলির স্থানাঙ্ক দ্বারা সংজ্ঞায়িত হয়।\n   \n   উদাহরণ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (কোনো ছেদ নেই)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Изчислява площта на пресичане между два правоъгълника.\n   Всеки правоъгълник е определен от координатите на горния ляв (x1, y1) и долния десен (x2, y2) ъгъл.\n   \n   Примери:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Няма пресичане)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* 计算两个矩形之间的交集面积。\n   每个矩形由其左上角 (x1, y1) 和右下角 (x2, y2) 的坐标定义。\n   \n   示例:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (无交集)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Calcule la surface d'intersection entre deux rectangles.\n   Chaque rectangle est défini par les coordonnées de son coin supérieur gauche (x1, y1) et de son coin inférieur droit (x2, y2).\n   \n   Exemples :\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pas d'intersection)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Berechnet die Schnittfläche zwischen zwei Rechtecken.\n   Jedes Rechteck wird durch die Koordinaten seiner oberen linken (x1, y1) und unteren rechten (x2, y2) Ecken definiert.\n   \n   Beispiele:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Keine Schnittmenge)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Lissafi yankin da ke haɗuwa tsakanin murabba'ai biyu.\n   Ana ayyana kowane murabba'i ta hanyar daidaitattun kusurwoyi na saman hagu (x1, y1) da ƙasan dama (x2, y2).\n   \n   Misalai:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Babu Haɗuwa)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* दो आयतों के बीच प्रतिच्छेदन का क्षेत्रफल गणना करता है।\n   प्रत्येक आयत को उसके शीर्ष-बाएँ (x1, y1) और नीचे-दाएँ (x2, y2) कोनों के निर्देशांक द्वारा परिभाषित किया जाता है।\n   \n   उदाहरण:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (कोई प्रतिच्छेदन नहीं)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Két téglalap metszetének területét számítja ki.\n   Minden téglalap a bal felső (x1, y1) és a jobb alsó (x2, y2) sarkok koordinátáival van meghatározva.\n   \n   Példák:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Nincs metszet)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)"
    },
    "prompt_bertscore": {
      "sq": "0.9986012448567523",
      "hy": "0.9900474261278659",
      "bn": "0.9905007006573875",
      "bg": "0.9819254298473493",
      "zh": "0.9705596008141519",
      "fr": "0.9842190148571591",
      "de": "0.9766208068914316",
      "ha": "0.9795432556875979",
      "hi": "0.9964355778123289",
      "hu": "0.991243379652077"
    },
    "canonical_solution": "{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}",
    "instruction": {
      "en": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nՏվեք C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9226191651994765",
      "bn": "0.8942418358129273",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9543420260937965",
      "hi": "0.9150793545657733",
      "hu": "0.9339510284375169"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5) - 2.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3) - 0.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 4, 4, 3, 3, 6, 6) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 3, 3, 1, 1, 2, 2) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(2, 2, 5, 5, 3, 3, 6, 6) - 4.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 3, 3, 5, 5) - 0.00) < 0.01);\n\n    }\n}",
    "entry_point": "CalculateIntersectionArea",
    "signature": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
    "docstring": {
      "en": "Calculates the area of intersection between two rectangles.\n   Each rectangle is defined by the coordinates of its top-left (x1, y1) and bottom-right (x2, y2) corners.\n   \n   Examples:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (No Intersection)",
      "sq": "Llogarit sipërfaqen e ndërprerjes midis dy drejtkëndëshave.\n   Secili drejtkëndësh përcaktohet nga koordinatat e këndit të sipërm të majtë (x1, y1) dhe këndit të poshtëm të djathtë (x2, y2).\n   \n   Shembuj:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pa Ndërprerje)",
      "hy": "Հաշվում է երկու ուղղանկյունների միջև հատման մակերեսը։\n   Յուրաքանչյուր ուղղանկյուն սահմանվում է իր վերին ձախ (x1, y1) և ներքևի աջ (x2, y2) անկյունների կոորդինատներով։\n\n   Օրինակներ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Ոչ մի հատում)",
      "bn": "দুটি আয়তক্ষেত্রের মধ্যে ছেদ ক্ষেত্রফল গণনা করে।  \nপ্রতিটি আয়তক্ষেত্র তার উপরের-বাম (x1, y1) এবং নিচের-ডান (x2, y2) কোণের স্থানাঙ্ক দ্বারা সংজ্ঞায়িত হয়।\n\nউদাহরণসমূহ:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (কোনো ছেদ নেই)",
      "bg": "Изчислява площта на пресичане между два правоъгълника.\n   Всеки правоъгълник е дефиниран чрез координатите на горния ляв (x1, y1) и долния десен (x2, y2) ъгъл.\n   \n   Примери:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Няма пресичане)",
      "zh": "计算两个矩形之间的交集面积。\n   每个矩形由其左上角 (x1, y1) 和右下角 (x2, y2) 的坐标定义。\n   \n   示例：\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00（无交集）",
      "fr": "Calcule la surface d'intersection entre deux rectangles.\n   Chaque rectangle est défini par les coordonnées de son coin supérieur gauche (x1, y1) et de son coin inférieur droit (x2, y2).\n   \n   Exemples :\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pas d'intersection)",
      "de": "Berechnet die Fläche des Schnittbereichs zwischen zwei Rechtecken.\n   Jedes Rechteck wird durch die Koordinaten seiner oberen linken (x1, y1) und unteren rechten (x2, y2) Ecken definiert.\n   \n   Beispiele:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Keine Schnittmenge)",
      "ha": "Lissafi yankin da ya ratsa tsakanin murabba'i biyu.\n   Kowane rectangle an ayyana shi ta hanyar daidaitattun wurare na saman hagu (x1, y1) da ƙasan dama (x2, y2).\n\n   Misalai:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Babu Haɗuwa)",
      "hi": "दो आयतों के बीच प्रतिच्छेदन का क्षेत्रफल गणना करता है।\n   प्रत्येक आयत इसके शीर्ष-बाएँ (x1, y1) और निचले-दाएँ (x2, y2) कोनों के निर्देशांक द्वारा परिभाषित होता है।\n\nउदाहरण:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (कोई प्रतिच्छेदन नहीं)",
      "hu": "Kiszámítja a két téglalap metszetének területét.\n   Minden téglalapot a bal felső (x1, y1) és a jobb alsó (x2, y2) sarkok koordinátái határoznak meg.\n   \n   Példák:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Nincs metszet)"
    },
    "docstring_bertscore": {
      "sq": "0.9713866977207812",
      "hy": "0.9909573519033867",
      "bn": "0.9890787057595587",
      "bg": "0.9798995985911745",
      "zh": "0.9752925655334513",
      "fr": "0.9714808485213918",
      "de": "0.9838102335329894",
      "ha": "0.9749062294423384",
      "hi": "0.993982293976167",
      "hu": "0.9832481095546607"
    }
  },
  {
    "task_id": "C#/10",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Solves a linear equation of the form ax + b = 0.\n    The function returns the solution as a double with two decimal places precision.\n    Assumes that 'a' is not zero.\n\n    Examples:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Zgjidh një ekuacion linear të formës ax + b = 0.\n    Funksioni kthen zgjidhjen si një numër me presje dhjetore me saktësi prej dy vendesh dhjetore.\n    Supozohet që 'a' nuk është zero.\n\n    Shembuj:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Լուծում է ax + b = 0 տեսքի գծային հավասարումը։\n    Ֆունկցիան վերադարձնում է լուծումը որպես double երկու տասնորդական թվանշան ճշգրտությամբ։\n    Ենթադրվում է, որ 'a'-ն զրո չէ։\n\n    Օրինակներ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    একটি সরল সমীকরণ ax + b = 0 আকারে সমাধান করে।\n    ফাংশনটি সমাধানটি দশমিকের দুটি স্থান পর্যন্ত নির্ভুলতা সহ প্রদান করে।\n    ধরে নেওয়া হয় যে 'a' শূন্য নয়।\n\n    উদাহরণ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Решава линейно уравнение от вида ax + b = 0.\n    Функцията връща решението като число с плаваща запетая с точност до два знака след десетичната запетая.\n    Предполага се, че 'a' не е нула.\n\n    Примери:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    解一元一次方程 ax + b = 0。\n    该函数返回一个双精度数，保留两位小数。\n    假设 'a' 不为零。\n\n    例子:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Résout une équation linéaire de la forme ax + b = 0.\n    La fonction renvoie la solution sous forme de double avec une précision de deux décimales.\n    Suppose que 'a' n'est pas zéro.\n\n    Exemples :\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Löst eine lineare Gleichung der Form ax + b = 0.\n    Die Funktion gibt die Lösung als Double mit zwei Dezimalstellen zurück.\n    Geht davon aus, dass 'a' nicht null ist.\n\n    Beispiele:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Yana warware wata daidaituwar layi mai siffar ax + b = 0.\n    Aikin yana dawowa da mafita a matsayin lamba mai tsawon wurare biyu na adadi mai lamba.\n    Yana dauka cewa 'a' ba sifili ba ne.\n\n    Misalai:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    ax + b = 0 के रूप में एक रैखिक समीकरण हल करता है।\n    फ़ंक्शन समाधान को दो दशमलव स्थानों की सटीकता के साथ एक डबल के रूप में लौटाता है।\n    मान लिया जाता है कि 'a' शून्य नहीं है।\n\n    उदाहरण:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Megold egy ax + b = 0 alakú lineáris egyenletet.\n    A függvény visszaadja a megoldást double típusban, két tizedesjegy pontossággal.\n    Feltételezi, hogy 'a' nem nulla.\n\n    Példák:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)"
    },
    "prompt_bertscore": {
      "sq": "0.9677336863831686",
      "hy": "0.9879320125698443",
      "bn": "0.9552487737832207",
      "bg": "0.9611022124819378",
      "zh": "0.9545849510498021",
      "fr": "0.9908014270542743",
      "de": "0.989051890658119",
      "ha": "0.980028112447704",
      "hi": "0.975842970319299",
      "hu": "0.993122621687048"
    },
    "canonical_solution": "{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}",
    "instruction": {
      "en": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nC# կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9055949525017384",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.8429757317285846",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(SolveLinearEquation(1, -3) == 3.00);\n        Debug.Assert(SolveLinearEquation(4, 8) == -2.00);\n        Debug.Assert(SolveLinearEquation(-2, 6) == 3.00);\n        Debug.Assert(SolveLinearEquation(3, -9) == 3.00);\n        Debug.Assert(SolveLinearEquation(0.5, -1.5) == 3.00);\n        Debug.Assert(SolveLinearEquation(-5, 10) == 2.00);\n        Debug.Assert(SolveLinearEquation(10, -20) == 2.00);\n\n    }\n}",
    "entry_point": "SolveLinearEquation",
    "signature": "static double SolveLinearEquation(double a, double b)",
    "docstring": {
      "en": "Solves a linear equation of the form ax + b = 0.\n    The function returns the solution as a double with two decimal places precision.\n    Assumes that 'a' is not zero.\n\n    Examples:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "sq": "Zgjidh një ekuacion linear të formës ax + b = 0.\n    Funksioni kthen zgjidhjen si një numër me presje dhjetore me saktësi deri në dy vende dhjetore.\n    Supozohet që 'a' nuk është zero.\n\n    Shembuj:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hy": "Գտնում է գծային հավասարումը ax + b = 0 ձևով:\n    Ֆունկցիան վերադարձնում է լուծումը որպես double երկու տասնորդական թվանշան ճշգրտությամբ:\n    Ենթադրում է, որ 'a'-ն զրո չէ:\n\n    Օրինակներ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "bn": "একটি সরল সমীকরণ ax + b = 0 সমাধান করে। \n    ফাংশনটি সমাধানটি একটি ডাবল হিসাবে দুই দশমিক স্থান নির্ভুলতার সাথে প্রদান করে। \n    ধরে নেয় যে 'a' শূন্য নয়।\n\n    উদাহরণ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "bg": "Решава линейно уравнение от вида ax + b = 0. \n    Функцията връща решението като число с плаваща запетая с точност до два знака след десетичната запетая.\n    Предполага се, че 'a' не е нула.\n\n    Примери:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "zh": "求解形如 ax + b = 0 的线性方程。\n    该函数返回一个具有两位小数精度的双精度数作为解。\n    假设 'a' 不为零。\n\n    示例：\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "fr": "Résout une équation linéaire de la forme ax + b = 0.\n    La fonction renvoie la solution sous forme de double avec une précision de deux décimales.\n    Suppose que 'a' n'est pas zéro.\n\n    Exemples :\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "de": "Löst eine lineare Gleichung der Form ax + b = 0.\n    Die Funktion gibt die Lösung als Double mit einer Genauigkeit von zwei Dezimalstellen zurück.\n    Es wird angenommen, dass 'a' nicht null ist.\n\n    Beispiele:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "ha": "Yana warware wata daidaituwar layi mai siffa ax + b = 0.\n    Aikin yana dawowa da mafita a matsayin lamba mai lissafi tare da madaidaicin wurare guda biyu na decimal. \n    Yana ɗauka cewa 'a' ba sifili ba ne.\n\n    Misalai:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hi": "एक रैखिक समीकरण ax + b = 0 के रूप में हल करता है।\n    फ़ंक्शन समाधान को दो दशमलव स्थानों की सटीकता के साथ एक डबल के रूप में लौटाता है।\n    यह मानता है कि 'a' शून्य नहीं है।\n\n    उदाहरण:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hu": "Megold egy ax + b = 0 alakú lineáris egyenletet.\n    A függvény a megoldást két tizedesjegy pontosságú lebegőpontos számként adja vissza.\n    Feltételezi, hogy 'a' nem nulla.\n\n    Példák:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00"
    },
    "docstring_bertscore": {
      "sq": "0.9535044017769724",
      "hy": "0.9538831899136059",
      "bn": "0.9489952934970993",
      "bg": "0.9503497540653763",
      "zh": "0.9488542659265645",
      "fr": "0.9905793582882774",
      "de": "0.9802346880439804",
      "ha": "0.959127429233689",
      "hi": "0.9535238675543137",
      "hu": "0.9639142227862487"
    }
  },
  {
    "task_id": "C#/11",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Calculates the total number of cows after a given number of years, following the rule that each cow gives birth to another cow every year from its fourth year.\n    Example cases:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Llogarit numrin total të lopëve pas një numri të caktuar vitesh, duke ndjekur rregullin që çdo lopë lind një tjetër lopë çdo vit nga viti i saj i katërt.\n    Shembuj rastesh:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Հաշվում է կովերի ընդհանուր քանակը որոշակի տարիների անց, հետևելով այն կանոնին, որ յուրաքանչյուր կով իր չորրորդ տարուց սկսած ամեն տարի ծնում է մեկ այլ կով:\n    Օրինակներ:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* একটি নির্দিষ্ট সংখ্যক বছরের পর মোট গরুর সংখ্যা গণনা করে, এই নিয়ম অনুসরণ করে যে প্রতিটি গরু তার চতুর্থ বছর থেকে প্রতি বছর আরেকটি গরুর জন্ম দেয়।\n    উদাহরণ কেস:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Изчислява общия брой крави след даден брой години, следвайки правилото, че всяка крава ражда друга крава всяка година от четвъртата си година.\n    Примерни случаи:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* 计算给定年数后的牛的总数，遵循的规则是每头牛从第四年开始每年生一头小牛。\n    示例案例:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Calcule le nombre total de vaches après un certain nombre d'années, suivant la règle que chaque vache donne naissance à une autre vache chaque année à partir de sa quatrième année.\n    Cas d'exemple :\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Berechnet die Gesamtanzahl der Kühe nach einer bestimmten Anzahl von Jahren, gemäß der Regel, dass jede Kuh jedes Jahr ab ihrem vierten Jahr ein weiteres Kalb zur Welt bringt.\n    Beispielhafte Fälle:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Lissafa jimillar adadin shanu bayan wani adadin shekaru, bisa ga ƙa'idar cewa kowace saniya tana haifar da wata saniya kowace shekara daga shekara ta huɗu.\n    Misalan lokuta:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* एक दिए गए वर्षों की संख्या के बाद कुल गायों की संख्या की गणना करता है, इस नियम का पालन करते हुए कि प्रत्येक गाय अपने चौथे वर्ष से हर साल एक और गाय को जन्म देती है।\n    उदाहरण मामले:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Kiszámítja a tehenek teljes számát egy adott év után, azzal a szabállyal, hogy minden tehén minden évben szül egy másik tehenet a negyedik évétől kezdve.\n    Példa esetek:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)"
    },
    "prompt_bertscore": {
      "sq": "0.9934195741066952",
      "hy": "0.9854515163714807",
      "bn": "0.9945527604304992",
      "bg": "1",
      "zh": "0.9794834679429064",
      "fr": "0.987092799209972",
      "de": "0.9847328716528965",
      "ha": "0.978963056344595",
      "hi": "1",
      "hu": "0.9804994623418999"
    },
    "canonical_solution": "{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}",
    "instruction": {
      "en": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nC# կոդի համար տրամադրեք կարճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nFournir une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568463579378843",
      "hy": "0.8903445091066416",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.8438073971339778",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(TotalCows(1) == 1);\n        Debug.Assert(TotalCows(2) == 1);\n        Debug.Assert(TotalCows(3) == 1);\n        Debug.Assert(TotalCows(4) == 2);\n        Debug.Assert(TotalCows(5) == 3);\n        Debug.Assert(TotalCows(6) == 4);\n        Debug.Assert(TotalCows(7) == 6);\n        Debug.Assert(TotalCows(8) == 9);\n        Debug.Assert(TotalCows(10) == 19);\n    }\n}\n",
    "entry_point": "TotalCows",
    "signature": "static int TotalCows(int years)",
    "docstring": {
      "en": "Calculates the total number of cows after a given number of years, following the rule that each cow gives birth to another cow every year from its fourth year.\n    Example cases:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "sq": "Llogarit numrin total të lopëve pas një numri të caktuar vitesh, duke ndjekur rregullin që çdo lopë lind një lopë tjetër çdo vit nga viti i saj i katërt.\n    Shembuj rastesh:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "hy": "Հաշվարկում է կովերի ընդհանուր թիվը տրված տարիների քանակից հետո՝ հետևելով այն կանոնին, որ յուրաքանչյուր կով իր չորրորդ տարուց սկսած ամեն տարի ծնում է մեկ այլ կով:\n    Օրինակ դեպքեր:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "bn": "গণনা করে একটি নির্দিষ্ট সংখ্যক বছরের পরে মোট গরুর সংখ্যা, এই নিয়ম অনুসরণ করে যে প্রতিটি গরু তার চতুর্থ বছর থেকে প্রতি বছর আরেকটি গরুর জন্ম দেয়।\n    উদাহরণ কেস:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "bg": "Изчислява общия брой крави след даден брой години, следвайки правилото, че всяка крава ражда още една крава всяка година от четвъртата си година.\n    Примерни случаи:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "zh": "计算给定年数后的牛总数，遵循的规则是每头牛从第四年开始每年生下一头小牛。\n    示例案例：\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "fr": "Calcule le nombre total de vaches après un certain nombre d'années, en suivant la règle selon laquelle chaque vache donne naissance à une autre vache chaque année à partir de sa quatrième année.\n    Cas d'exemple :\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "de": "Berechnet die Gesamtanzahl der Kühe nach einer bestimmten Anzahl von Jahren, gemäß der Regel, dass jede Kuh jedes Jahr ab ihrem vierten Jahr ein weiteres Kalb zur Welt bringt.\n    Beispielhafte Fälle:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "ha": "Yana ƙididdige jimillar adadin shanu bayan wani adadin shekaru, bisa ƙa'idar cewa kowace saniya tana haifar da wata saniya a kowace shekara daga shekara ta huɗu.\n    Misalan lamura:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "hi": "गणना करता है कि दिए गए वर्षों की संख्या के बाद कुल गायों की संख्या कितनी होगी, इस नियम का पालन करते हुए कि प्रत्येक गाय अपने चौथे वर्ष से हर साल एक और गाय को जन्म देती है।\n    उदाहरण मामले:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "hu": "Kiszámítja a tehenek teljes számát egy adott évek száma után, azzal a szabállyal, hogy minden tehén minden évben szül egy másik tehenet a negyedik évétől kezdve.\n    Példa esetek:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4"
    },
    "docstring_bertscore": {
      "sq": "0.9837488567452496",
      "hy": "0.9912358316975977",
      "bn": "0.9807751613107762",
      "bg": "0.9999996027392379",
      "zh": "0.9651508955385719",
      "fr": "0.976936231936515",
      "de": "0.9585257778095343",
      "ha": "0.9486085601452244",
      "hi": "0.9893790348956835",
      "hu": "0.9838068568165118"
    }
  },
  {
    "task_id": "C#/12",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function counts how many apples are reachable.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Example:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kjo funksion numëron sa mollë janë të arritshme.\n   Ai merr një listë të numrave të plotë që përfaqësojnë lartësitë e mollëve nga toka dhe një numër të plotë që përfaqëson lartësinë maksimale që mund të arrihet (me ose pa një stol).\n   Një mollë konsiderohet e arritshme nëse lartësia e saj është më e vogël ose e barabartë me lartësinë maksimale të arritshme.\n   Shembull:\n   >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n   3\n   >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n   2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Այս ֆունկցիան հաշվում է, թե քանի խնձոր է հասանելի:\n    Այն ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է խնձորների բարձրությունները գետնից և ամբողջ թիվ, որը ներկայացնում է առավելագույն բարձրությունը, որը կարող է հասնել (սանդուղքով կամ առանց դրա):\n    Խնձորը համարվում է հասանելի, եթե նրա բարձրությունը փոքր է կամ հավասար առավելագույն հասանելի բարձրությանը:\n    Օրինակ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* এই ফাংশনটি কতগুলি আপেল পৌঁছানো যায় তা গণনা করে।\n    এটি মাটির থেকে আপেলের উচ্চতা প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা এবং একটি পূর্ণসংখ্যা নেয় যা পৌঁছানোর সর্বাধিক উচ্চতা প্রতিনিধিত্ব করে (স্টুল সহ বা ছাড়া)।\n    একটি আপেল পৌঁছানো যায় বলে বিবেচিত হয় যদি এর উচ্চতা পৌঁছানোর সর্বাধিক উচ্চতার চেয়ে কম বা সমান হয়।\n    উদাহরণ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Тази функция брои колко ябълки са достижими.\n    Тя приема списък от цели числа, представляващи височините на ябълките от земята, и цяло число, представляващо максималната височина, която може да бъде достигната (със или без стол).\n    Ябълката се счита за достижима, ако нейната височина е по-малка или равна на максималната достижима височина.\n    Пример:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 此函数计算有多少苹果是可以够到的。\n    它接受一个整数列表，表示苹果离地面的高度，以及一个整数，表示可以达到的最大高度（无论是否使用凳子）。\n    如果苹果的高度小于或等于最大可达高度，则认为该苹果是可以够到的。\n    示例：\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Cette fonction compte combien de pommes sont accessibles.\n    Elle prend une liste d'entiers représentant les hauteurs des pommes à partir du sol et un entier représentant la hauteur maximale qui peut être atteinte (avec ou sans tabouret).\n    Une pomme est considérée comme accessible si sa hauteur est inférieure ou égale à la hauteur maximale atteignable.\n    Exemple :\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Diese Funktion zählt, wie viele Äpfel erreichbar sind.\n    Sie nimmt eine Liste von ganzen Zahlen, die die Höhen der Äpfel vom Boden darstellen, und eine ganze Zahl, die die maximale Höhe darstellt, die erreicht werden kann (mit oder ohne Hocker).\n    Ein Apfel wird als erreichbar angesehen, wenn seine Höhe kleiner oder gleich der maximal erreichbaren Höhe ist.\n    Beispiel:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Wannan aikin yana ƙirga yawan tuffa da za a iya kaiwa.\n    Yana ɗaukar jerin lambobi masu wakiltar tsayin tuffa daga ƙasa da kuma lamba mai wakiltar mafi girman tsayin da za a iya kaiwa (tare da ko ba tare da kujera ba).\n    Ana ɗaukar tuffa a matsayin wanda za a iya kaiwa idan tsayinsa ya yi ƙasa ko daidai da mafi girman tsayin da za a iya kaiwa.\n    Misali:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह फ़ंक्शन गिनता है कि कितने सेब पहुँच योग्य हैं।\n    यह जमीन से सेबों की ऊँचाईयों का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची और एक पूर्णांक लेता है जो अधिकतम ऊँचाई का प्रतिनिधित्व करता है जिसे (स्टूल के साथ या बिना) पहुँचा जा सकता है।\n    एक सेब को पहुँच योग्य माना जाता है यदि उसकी ऊँचाई अधिकतम पहुँच योग्य ऊँचाई से कम या बराबर है।\n    उदाहरण:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ez a függvény megszámolja, hány alma érhető el.\n    Egy egész számok listáját veszi át, amely az almák magasságát jelenti a földtől, és egy egész számot, amely a maximálisan elérhető magasságot jelenti (sámli használatával vagy anélkül).\n    Egy almát elérhetőnek tekintünk, ha a magassága kisebb vagy egyenlő a maximálisan elérhető magassággal.\n    Példa:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)"
    },
    "prompt_bertscore": {
      "sq": "0.9971125101508959",
      "hy": "0.9898879259318949",
      "bn": "0.9840962612816796",
      "bg": "0.9889086781533929",
      "zh": "0.9627752761813947",
      "fr": "0.9924526414118173",
      "de": "0.9971125101508959",
      "ha": "0.9738518993798052",
      "hi": "1",
      "hu": "0.9919314352919818"
    },
    "canonical_solution": "{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}",
    "instruction": {
      "en": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nՏրամադրել համառոտ բնական լեզվով նկարագրություն (docstring) C# կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C# a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9294844270591853",
      "bn": "0.8797765783140615",
      "bg": "0.8379186022274364",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9014117966771436",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountReachableApples(new List<int> {150, 190, 300, 210, 220}, 200) == 2);\n        Debug.Assert(CountReachableApples(new List<int> {120, 180, 260, 310, 150}, 250) == 3);\n        Debug.Assert(CountReachableApples(new List<int> {100, 200, 300, 400, 500}, 350) == 3);\n\n    }\n}",
    "entry_point": "CountReachableApples",
    "signature": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
    "docstring": {
      "en": "This function counts how many apples are reachable.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Example:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "sq": "Kjo funksion numëron sa mollë janë të arritshme. \n    Merr një listë të numrave të plotë që përfaqësojnë lartësitë e mollëve nga toka dhe një numër të plotë që përfaqëson lartësinë maksimale që mund të arrihet (me ose pa një stol). \n    Një mollë konsiderohet e arritshme nëse lartësia e saj është më e vogël ose e barabartë me lartësinë maksimale të arritshme.\n    Shembull:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "hy": "Այս ֆունկցիան հաշվում է, թե քանի խնձոր է հասանելի:\n    Այն ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է խնձորների բարձրությունները գետնից և ամբողջ թիվ, որը ներկայացնում է առավելագույն բարձրությունը, որին կարելի է հասնել (աթոռով կամ առանց դրա):\n    Խնձորը համարվում է հասանելի, եթե նրա բարձրությունը փոքր կամ հավասար է առավելագույն հասանելի բարձրությանը:\n    Օրինակ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "bn": "এই ফাংশনটি কতগুলি আপেল পৌঁছানো যায় তা গণনা করে।\n    এটি মাটির থেকে আপেলের উচ্চতা নির্দেশকারী পূর্ণসংখ্যার একটি তালিকা এবং একটি পূর্ণসংখ্যা নেয় যা পৌঁছানোর সর্বাধিক উচ্চতা নির্দেশ করে (স্টুল সহ বা ছাড়া)।\n    একটি আপেল পৌঁছানো যায় বলে বিবেচিত হয় যদি তার উচ্চতা পৌঁছানোর সর্বাধিক উচ্চতার থেকে কম বা সমান হয়।\n    উদাহরণ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "bg": "Тази функция брои колко ябълки са достижими.\n    Тя приема списък от цели числа, представляващи височините на ябълките от земята, и цяло число, представляващо максималната височина, която може да бъде достигната (със или без столче).  \n    Ябълката се счита за достижима, ако нейната височина е по-малка или равна на максималната достижима височина.  \n    Пример:  \n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)  \n    3  \n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)  \n    2  ",
      "zh": "该函数计算可以够到的苹果数量。\n    它接受一个整数列表，表示苹果距离地面的高度，以及一个整数，表示可以达到的最大高度（有无凳子均可）。\n    如果苹果的高度小于或等于最大可达高度，则认为该苹果是可以够到的。\n    示例：\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "fr": "Cette fonction compte combien de pommes sont accessibles.\n    Elle prend une liste d'entiers représentant les hauteurs des pommes à partir du sol et un entier représentant la hauteur maximale qui peut être atteinte (avec ou sans tabouret).\n    Une pomme est considérée comme accessible si sa hauteur est inférieure ou égale à la hauteur maximale atteignable.\n    Exemple :\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "de": "Diese Funktion zählt, wie viele Äpfel erreichbar sind.\n    Sie nimmt eine Liste von ganzen Zahlen, die die Höhen der Äpfel vom Boden darstellen, und eine ganze Zahl, die die maximale erreichbare Höhe (mit oder ohne Hocker) darstellt.\n    Ein Apfel gilt als erreichbar, wenn seine Höhe kleiner oder gleich der maximal erreichbaren Höhe ist.\n    Beispiel:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "ha": "Wannan aikin yana ƙididdige yawan tuffa da za a iya kaiwa.\n    Yana ɗaukar jerin lambobi waɗanda ke wakiltar tsayin tuffa daga ƙasa da kuma lamba ɗaya wanda ke wakiltar mafi girman tsayin da za a iya kaiwa (tare ko ba tare da tabarma ba).\n    Ana ɗaukar tuffa a matsayin wanda za a iya kaiwa idan tsayinsa bai wuce mafi girman tsayin da za a iya kaiwa ba.\n    Misali:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "hi": "यह फ़ंक्शन गिनता है कि कितने सेब पहुँच योग्य हैं।\n    यह जमीन से सेबों की ऊँचाईयों को दर्शाने वाली पूर्णांकों की एक सूची और एक पूर्णांक लेता है जो अधिकतम ऊँचाई को दर्शाता है जिसे (स्टूल के साथ या बिना) पहुँचा जा सकता है।  \nएक सेब को पहुँच योग्य माना जाता है यदि उसकी ऊँचाई अधिकतम पहुँच योग्य ऊँचाई से कम या बराबर है।  \nउदाहरण:  \n>>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)  \n3  \n>>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)  \n2  ",
      "hu": "Ez a függvény megszámolja, hány alma érhető el.\n    Egy egész számokból álló listát vesz át, amely az almák földtől mért magasságát jelöli, és egy egész számot, amely a maximálisan elérhető magasságot jelöli (székkel vagy anélkül).\n    Az alma elérhetőnek számít, ha a magassága kisebb vagy egyenlő a maximálisan elérhető magassággal.\n    Példa:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9957437481951844",
      "hy": "0.9917743186605832",
      "bn": "0.9838950487056912",
      "bg": "0.9922450726636359",
      "zh": "0.8895160217873451",
      "fr": "0.9903255086613147",
      "de": "0.9897073709155342",
      "ha": "0.941409996506139",
      "hi": "1",
      "hu": "0.8891421994102375"
    }
  },
  {
    "task_id": "C#/13",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Calculates the maximum total value of herbs that can be collected within a given time.\n    The function takes the total time available for collecting herbs, the number of different herbs,\n    an array of time costs for each herb, and an array of values for each herb.\n\n    Parameters:\n    totalMinutes - the total time available for collecting herbs.\n    herbCount - the number of different herbs available.\n    timeCosts - an array where timeCosts[i] represents the time required to collect the i-th herb.\n    values - an array where values[i] represents the value of the i-th herb.\n\n    Returns:\n    The maximum total value of the herbs that can be collected within the given time.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kohe të caktuar.\n    Funksioni merr kohën totale në dispozicion për mbledhjen e bimëve, numrin e bimëve të ndryshme,\n    një varg të kostove të kohës për secilën bimë, dhe një varg të vlerave për secilën bimë.\n\n    Parametrat:\n    totalMinutes - koha totale në dispozicion për mbledhjen e bimëve.\n    herbCount - numri i bimëve të ndryshme në dispozicion.\n    timeCosts - një varg ku timeCosts[i] përfaqëson kohën e kërkuar për të mbledhur bimën e i-të.\n    values - një varg ku values[i] përfaqëson vlerën e bimës së i-të.\n\n    Kthen:\n    Vlera maksimale totale e bimëve që mund të mblidhen brenda kohës së dhënë.\n\n    Shembuj:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Հաշվում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակում:\n    Ֆունկցիան ընդունում է խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը, տարբեր խոտաբույսերի քանակը,\n    յուրաքանչյուր խոտաբույսի համար ժամանակի ծախսերի զանգվածը և յուրաքանչյուր խոտաբույսի արժեքների զանգվածը:\n\n    Պարամետրեր:\n    totalMinutes - խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n    herbCount - հասանելի տարբեր խոտաբույսերի քանակը:\n    timeCosts - զանգված, որտեղ timeCosts[i]-ն ներկայացնում է i-րդ խոտաբույսը հավաքելու համար պահանջվող ժամանակը:\n    values - զանգված, որտեղ values[i]-ն ներկայացնում է i-րդ խոտաբույսի արժեքը:\n\n    Վերադարձնում է:\n    Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակում:\n\n    Օրինակներ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    প্রদত্ত সময়ের মধ্যে সংগ্রহ করা যেতে পারে এমন গুল্মের সর্বাধিক মোট মান গণনা করে।\n    ফাংশনটি গুল্ম সংগ্রহের জন্য উপলব্ধ মোট সময়, বিভিন্ন গুল্মের সংখ্যা,\n    প্রতিটি গুল্মের জন্য সময় খরচের একটি অ্যারে এবং প্রতিটি গুল্মের জন্য মানের একটি অ্যারে নেয়।\n\n    প্যারামিটার:\n    totalMinutes - গুল্ম সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    herbCount - উপলব্ধ বিভিন্ন গুল্মের সংখ্যা।\n    timeCosts - একটি অ্যারে যেখানে timeCosts[i] i-তম গুল্ম সংগ্রহের জন্য প্রয়োজনীয় সময় উপস্থাপন করে।\n    values - একটি অ্যারে যেখানে values[i] i-তম গুল্মের মান উপস্থাপন করে।\n\n    রিটার্নস:\n    প্রদত্ত সময়ের মধ্যে সংগ্রহ করা যেতে পারে এমন গুল্মের সর্বাধিক মোট মান।\n\n    উদাহরণ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено време.\n    Функцията приема общото време, налично за събиране на билки, броя на различните билки,\n    масив с времевите разходи за всяка билка и масив със стойностите за всяка билка.\n\n    Параметри:\n    totalMinutes - общото време, налично за събиране на билки.\n    herbCount - броят на различните налични билки.\n    timeCosts - масив, където timeCosts[i] представлява времето, необходимо за събиране на i-тата билка.\n    values - масив, където values[i] представлява стойността на i-тата билка.\n\n    Връща:\n    Максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\n    Примери:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    计算在给定时间内可以收集的草药的最大总价值。\n    该函数接受用于收集草药的总时间、不同草药的数量、\n    每种草药的时间成本数组和每种草药的价值数组。\n\n    参数:\n    totalMinutes - 收集草药的总可用时间。\n    herbCount - 可用的不同草药的数量。\n    timeCosts - 一个数组，其中 timeCosts[i] 表示收集第 i 种草药所需的时间。\n    values - 一个数组，其中 values[i] 表示第 i 种草药的价值。\n\n    返回:\n    在给定时间内可以收集的草药的最大总价值。\n\n    示例:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Calcule la valeur totale maximale des herbes qui peuvent être collectées dans un temps donné.\n    La fonction prend le temps total disponible pour collecter les herbes, le nombre d'herbes différentes,\n    un tableau des coûts en temps pour chaque herbe, et un tableau des valeurs pour chaque herbe.\n\n    Paramètres:\n    totalMinutes - le temps total disponible pour collecter les herbes.\n    herbCount - le nombre d'herbes différentes disponibles.\n    timeCosts - un tableau où timeCosts[i] représente le temps requis pour collecter la i-ème herbe.\n    values - un tableau où values[i] représente la valeur de la i-ème herbe.\n\n    Renvoie:\n    La valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n    Exemples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Berechnet den maximalen Gesamtwert der Kräuter, die innerhalb einer bestimmten Zeit gesammelt werden können.\n    Die Funktion nimmt die insgesamt verfügbare Zeit zum Sammeln von Kräutern, die Anzahl der verschiedenen Kräuter,\n    ein Array von Zeitkosten für jedes Kraut und ein Array von Werten für jedes Kraut.\n\n    Parameter:\n    totalMinutes - die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n    herbCount - die Anzahl der verfügbaren verschiedenen Kräuter.\n    timeCosts - ein Array, in dem timeCosts[i] die Zeit darstellt, die benötigt wird, um das i-te Kraut zu sammeln.\n    values - ein Array, in dem values[i] den Wert des i-ten Krauts darstellt.\n\n    Rückgabewert:\n    Der maximale Gesamtwert der Kräuter, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n    Beispiele:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Lissafin darajar ganyayyaki mafi girma da za a iya tattarawa a cikin wani lokaci da aka bayar.\n    Aikin yana ɗaukar jimillar lokacin da ake da shi don tattara ganyayyaki, adadin nau'ikan ganyayyaki daban-daban,\n    wani tsararren lokaci na farashi don kowane ganye, da wani tsararren darajoji don kowane ganye.\n\n    Sigogi:\n    totalMinutes - jimillar lokacin da ake da shi don tattara ganyayyaki.\n    herbCount - adadin nau'ikan ganyayyaki daban-daban da ake da su.\n    timeCosts - wani tsararren inda timeCosts[i] ke wakiltar lokacin da ake bukata don tattara ganye na i-th.\n    values - wani tsararren inda values[i] ke wakiltar darajar ganye na i-th.\n\n    Komawa:\n    Mafi girman jimillar darajar ganyayyakin da za a iya tattarawa a cikin lokacin da aka bayar.\n\n    Misalai:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    एक दिए गए समय के भीतर एकत्रित की जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है।\n    यह फ़ंक्शन जड़ी-बूटियों को एकत्रित करने के लिए उपलब्ध कुल समय, विभिन्न जड़ी-बूटियों की संख्या,\n    प्रत्येक जड़ी-बूटी के लिए समय लागतों की एक array, और प्रत्येक जड़ी-बूटी के लिए मूल्यों की एक array लेता है।\n\n    पैरामीटर्स:\n    totalMinutes - जड़ी-बूटियों को एकत्रित करने के लिए उपलब्ध कुल समय।\n    herbCount - उपलब्ध विभिन्न जड़ी-बूटियों की संख्या।\n    timeCosts - एक array जहां timeCosts[i] i-थ जड़ी-बूटी को एकत्रित करने के लिए आवश्यक समय का प्रतिनिधित्व करता है।\n    values - एक array जहां values[i] i-थ जड़ी-बूटी के मूल्य का प्रतिनिधित्व करता है।\n\n    रिटर्न करता है:\n    दिए गए समय के भीतर एकत्रित की जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Kiszámítja a maximális összértéket, amelyet a gyógynövényekből lehet begyűjteni adott időn belül.\n    A függvény megkapja a gyógynövények gyűjtésére rendelkezésre álló teljes időt, a különböző gyógynövények számát,\n    egy tömböt az egyes gyógynövények időráfordításával, és egy tömböt az egyes gyógynövények értékével.\n\n    Paraméterek:\n    totalMinutes - a gyógynövények gyűjtésére rendelkezésre álló teljes idő.\n    herbCount - a rendelkezésre álló különböző gyógynövények száma.\n    timeCosts - egy tömb, ahol a timeCosts[i] az i-edik gyógynövény gyűjtéséhez szükséges időt jelenti.\n    values - egy tömb, ahol a values[i] az i-edik gyógynövény értékét jelenti.\n\n    Visszatérési érték:\n    A maximális összérték, amelyet a gyógynövényekből lehet begyűjteni a megadott időn belül.\n\n    Példák:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)"
    },
    "prompt_bertscore": {
      "sq": "0.9970143867426646",
      "hy": "0.9943447944215557",
      "bn": "0.9849096526920175",
      "bg": "0.9855134890503635",
      "zh": "0.9916168047684225",
      "fr": "0.9935447112467471",
      "de": "0.9946608153577822",
      "ha": "0.9834052261860592",
      "hi": "0.9905241390423496",
      "hu": "0.9735956661882702"
    },
    "canonical_solution": "{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}",
    "instruction": {
      "en": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nՏրամադրել կարճ բնական լեզվով նկարագրություն (docstring) C# կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nनिम्नलिखित C# कोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9255449907121205",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9543420260937965",
      "hi": "0.8915736339044856",
      "hu": "0.9437490678732059"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350}) == 650);\n        Debug.Assert(MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300}) == 450);\n        Debug.Assert(MaxHerbValue(7, 3, new int[] {2, 3, 5}, new int[] {100, 200, 300}) == 400);\n        Debug.Assert(MaxHerbValue(12, 4, new int[] {2, 4, 6, 3}, new int[] {100, 200, 300, 150}) == 600);\n        Debug.Assert(MaxHerbValue(8, 3, new int[] {1, 3, 4}, new int[] {150, 250, 350}) == 750);\n        Debug.Assert(MaxHerbValue(15, 5, new int[] {3, 5, 7, 4, 2}, new int[] {120, 280, 350, 220, 180}) == 810);\n\n\n    }\n}",
    "entry_point": "MaxHerbValue",
    "signature": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
    "docstring": {
      "en": "Calculates the maximum total value of herbs that can be collected within a given time.\n    The function takes the total time available for collecting herbs, the number of different herbs,\n    an array of time costs for each herb, and an array of values for each herb.\n\n    Parameters:\n    totalMinutes - the total time available for collecting herbs.\n    herbCount - the number of different herbs available.\n    timeCosts - an array where timeCosts[i] represents the time required to collect the i-th herb.\n    values - an array where values[i] represents the value of the i-th herb.\n\n    Returns:\n    The maximum total value of the herbs that can be collected within the given time.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "sq": "Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kohe të dhënë.\n    Funksioni merr kohën totale në dispozicion për mbledhjen e bimëve, numrin e bimëve të ndryshme,\n    një varg me kostot e kohës për secilën bimë, dhe një varg me vlerat për secilën bimë.\n\n    Parametrat:\n    totalMinutes - koha totale në dispozicion për mbledhjen e bimëve.\n    herbCount - numri i bimëve të ndryshme në dispozicion.\n    timeCosts - një varg ku timeCosts[i] përfaqëson kohën e kërkuar për të mbledhur bimën e i-të.\n    values - një varg ku values[i] përfaqëson vlerën e bimës së i-të.\n\n    Kthen:\n    Vlera maksimale totale e bimëve që mund të mblidhen brenda kohës së dhënë.\n\n    Shembuj:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hy": "Հաշվում է բույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակի ընթացքում։ Ֆունկցիան ընդունում է բույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը, տարբեր բույսերի քանակը, յուրաքանչյուր բույսի համար ժամանակի արժեքների զանգվածը և յուրաքանչյուր բույսի արժեքների զանգվածը։\n\nՓոփոխականներ:\ntotalMinutes - բույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը։\nherbCount - հասանելի տարբեր բույսերի քանակը։\ntimeCosts - զանգված, որտեղ timeCosts[i]-ն ներկայացնում է i-րդ բույսը հավաքելու համար անհրաժեշտ ժամանակը։\nvalues - զանգված, որտեղ values[i]-ն ներկայացնում է i-րդ բույսի արժեքը։\n\nՎերադարձնում է:\nԲույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակի ընթացքում։\n\nՕրինակներ:\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450",
      "bn": "হিসাব করে নির্ধারিত সময়ের মধ্যে সর্বাধিক মোট মূল্যমানের ভেষজ সংগ্রহ করা যেতে পারে।\n    ফাংশনটি ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়, বিভিন্ন ভেষজের সংখ্যা,\n    প্রতিটি ভেষজের জন্য সময় খরচের একটি অ্যারে, এবং প্রতিটি ভেষজের জন্য মূল্যমানের একটি অ্যারে গ্রহণ করে।\n\n    Parameters:\n    totalMinutes - ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    herbCount - উপলব্ধ বিভিন্ন ভেষজের সংখ্যা।\n    timeCosts - একটি অ্যারে যেখানে timeCosts[i] i-তম ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় নির্দেশ করে।\n    values - একটি অ্যারে যেখানে values[i] i-তম ভেষজের মূল্যমান নির্দেশ করে।\n\n    Returns:\n    নির্ধারিত সময়ের মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্যমান।\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "bg": "Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено време.\n    Функцията приема общото време, налично за събиране на билки, броя на различните билки,\n    масив от времеви разходи за всяка билка и масив от стойности за всяка билка.\n\n    Параметри:\n    totalMinutes - общото време, налично за събиране на билки.\n    herbCount - броят на различните налични билки.\n    timeCosts - масив, в който timeCosts[i] представлява времето, необходимо за събиране на i-тата билка.\n    values - масив, в който values[i] представлява стойността на i-тата билка.\n\n    Връща:\n    Максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\n    Примери:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "zh": "计算在给定时间内可以收集的草药的最大总价值。\n    该函数接受用于收集草药的总时间、不同草药的数量、每种草药的时间成本数组和每种草药的价值数组。\n\n    参数：\n    totalMinutes - 收集草药的总可用时间。\n    herbCount - 可用的不同草药的数量。\n    timeCosts - 一个数组，其中 timeCosts[i] 表示收集第 i 种草药所需的时间。\n    values - 一个数组，其中 values[i] 表示第 i 种草药的价值。\n\n    返回：\n    在给定时间内可以收集的草药的最大总价值。\n\n    示例：\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "fr": "Calcule la valeur totale maximale des herbes qui peuvent être collectées dans un temps donné.\n    La fonction prend le temps total disponible pour collecter des herbes, le nombre de différentes herbes,\n    un tableau des coûts en temps pour chaque herbe, et un tableau des valeurs pour chaque herbe.\n\n    Paramètres:\n    totalMinutes - le temps total disponible pour collecter des herbes.\n    herbCount - le nombre de différentes herbes disponibles.\n    timeCosts - un tableau où timeCosts[i] représente le temps nécessaire pour collecter la i-ème herbe.\n    values - un tableau où values[i] représente la valeur de la i-ème herbe.\n\n    Renvoie:\n    La valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n    Exemples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "de": "Berechnet den maximalen Gesamtwert der Kräuter, die innerhalb einer bestimmten Zeit gesammelt werden können.\n    Die Funktion nimmt die insgesamt verfügbare Zeit zum Sammeln von Kräutern, die Anzahl der verschiedenen Kräuter,\n    ein Array von Zeitkosten für jedes Kraut und ein Array von Werten für jedes Kraut.\n\n    Parameter:\n    totalMinutes - die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n    herbCount - die Anzahl der verschiedenen verfügbaren Kräuter.\n    timeCosts - ein Array, wobei timeCosts[i] die Zeit darstellt, die benötigt wird, um das i-te Kraut zu sammeln.\n    values - ein Array, wobei values[i] den Wert des i-ten Krauts darstellt.\n\n    Rückgabewert:\n    Der maximale Gesamtwert der Kräuter, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n    Beispiele:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "ha": "Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin wani lokaci da aka bayar.\n    Aikin yana ɗaukar jimillar lokacin da ake da shi don tattara ganyayyaki, yawan nau'ikan ganyayyaki daban-daban,\n    jerin farashin lokaci don kowane ganye, da jerin ƙimomi don kowane ganye.\n\n    Sigogi:\n    totalMinutes - jimillar lokacin da ake da shi don tattara ganyayyaki.\n    herbCount - yawan nau'ikan ganyayyaki daban-daban da ake da su.\n    timeCosts - jerin inda timeCosts[i] ke wakiltar lokacin da ake buƙata don tattara ganye na i-th.\n    values - jerin inda values[i] ke wakiltar ƙimar ganye na i-th.\n\n    Returns:\n    Mafi girman jimillar ƙimar ganyayyakin da za a iya tattarawa a cikin lokacin da aka bayar.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hi": "एक दिए गए समय के भीतर एकत्रित की जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य गणना करता है। \n    यह फ़ंक्शन जड़ी-बूटियों को एकत्रित करने के लिए उपलब्ध कुल समय, विभिन्न जड़ी-बूटियों की संख्या,\n    प्रत्येक जड़ी-बूटी के लिए समय लागत का एक सरणी, और प्रत्येक जड़ी-बूटी के लिए मूल्यों का एक सरणी लेता है।\n\n    पैरामीटर्स:\n    totalMinutes - जड़ी-बूटियों को एकत्रित करने के लिए उपलब्ध कुल समय।\n    herbCount - उपलब्ध विभिन्न जड़ी-बूटियों की संख्या।\n    timeCosts - एक सरणी जहां timeCosts[i] i-वीं जड़ी-बूटी को एकत्रित करने के लिए आवश्यक समय को दर्शाता है।\n    values - एक सरणी जहां values[i] i-वीं जड़ी-बूटी के मूल्य को दर्शाता है।\n\n    Returns:\n    दिए गए समय के भीतर एकत्रित की जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hu": "Kiszámítja a maximálisan gyűjthető gyógynövények összértékét a rendelkezésre álló időn belül.\n    A függvény a gyógynövények gyűjtésére rendelkezésre álló teljes időt, a különböző gyógynövények számát,\n    a gyógynövények gyűjtéséhez szükséges idő költségeit tartalmazó tömböt, valamint a gyógynövények értékeit tartalmazó tömböt veszi figyelembe.\n\n    Paraméterek:\n    totalMinutes - a gyógynövények gyűjtésére rendelkezésre álló teljes idő.\n    herbCount - a rendelkezésre álló különböző gyógynövények száma.\n    timeCosts - egy tömb, ahol a timeCosts[i] az i-edik gyógynövény gyűjtéséhez szükséges időt jelenti.\n    values - egy tömb, ahol a values[i] az i-edik gyógynövény értékét jelenti.\n\n    Visszatérési érték:\n    A gyógynövények maximális összértéke, amely a rendelkezésre álló időn belül gyűjthető.\n\n    Példák:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450"
    },
    "docstring_bertscore": {
      "sq": "0.9867328809595367",
      "hy": "0.9857087427149208",
      "bn": "0.9725647745106992",
      "bg": "0.9976617231544573",
      "zh": "0.9913675236402237",
      "fr": "0.9929929160482323",
      "de": "0.9923279015325275",
      "ha": "0.966284081862376",
      "hi": "0.999999801369619",
      "hu": "0.9576462424823118"
    }
  },
  {
    "task_id": "C#/14",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    This function takes a list of integers and performs two operations. Firstly, it removes any duplicate numbers, ensuring each number is unique. Secondly, it sorts the remaining numbers in ascending order.\n    Example usage:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Kjo funksion merr një listë me numra të plotë dhe kryen dy operacione. Së pari, heq çdo numër të përsëritur, duke siguruar që çdo numër të jetë unik. Së dyti, rendit numrat e mbetur në rend rritës.\n    Shembull përdorimi:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Այս ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ և կատարում է երկու գործողություն։ Նախ, այն հեռացնում է կրկնվող թվերը, ապահովելով, որ յուրաքանչյուր թիվ լինի եզակի։ Երկրորդ, այն դասավորում է մնացած թվերը աճման կարգով։\n    Օրինակ օգտագործում:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    এই ফাংশনটি একটি পূর্ণসংখ্যার তালিকা নেয় এবং দুটি অপারেশন সম্পন্ন করে। প্রথমত, এটি কোনো সদৃশ সংখ্যা সরিয়ে দেয়, প্রতিটি সংখ্যাকে অনন্য করে তোলে। দ্বিতীয়ত, এটি অবশিষ্ট সংখ্যাগুলিকে ঊর্ধ্বক্রমে সাজায়।\n    উদাহরণ ব্যবহার:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Тази функция приема списък от цели числа и извършва две операции. Първо, премахва всички дублиращи се числа, като гарантира, че всяко число е уникално. Второ, сортира останалите числа във възходящ ред.\n    Пример за използване:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    此函数接受一个整数列表并执行两个操作。首先，它删除任何重复的数字，确保每个数字都是唯一的。其次，它按升序排列剩余的数字。\n    示例用法:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Cette fonction prend une liste d'entiers et effectue deux opérations. Premièrement, elle supprime tous les nombres en double, garantissant que chaque nombre est unique. Deuxièmement, elle trie les nombres restants par ordre croissant.\n    Exemple d'utilisation :\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Diese Funktion nimmt eine Liste von ganzen Zahlen und führt zwei Operationen aus. Erstens entfernt sie alle doppelten Zahlen, sodass jede Zahl einzigartig ist. Zweitens sortiert sie die verbleibenden Zahlen in aufsteigender Reihenfolge.\n    Beispielverwendung:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Wannan aikin yana ɗaukar jerin lambobi kuma yana aiwatar da ayyuka biyu. Da farko, yana cire duk wata maimaituwar lamba, yana tabbatar da cewa kowace lamba ta zama ta musamman. Na biyu, yana tsara sauran lambobin cikin tsari mai hawa.\n    Misalin amfani:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    यह फ़ंक्शन पूर्णांकों की एक सूची लेता है और दो कार्य करता है। सबसे पहले, यह किसी भी डुप्लिकेट संख्या को हटा देता है, जिससे प्रत्येक संख्या अद्वितीय हो जाती है। दूसरे, यह शेष संख्याओं को आरोही क्रम में व्यवस्थित करता है।\n    उदाहरण उपयोग:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Ez a függvény egy egész számokból álló listát vesz át, és két műveletet hajt végre. Először eltávolítja az ismétlődő számokat, biztosítva, hogy minden szám egyedi legyen. Másodszor, a megmaradt számokat növekvő sorrendbe rendezi.\n    Példa használat:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)"
    },
    "prompt_bertscore": {
      "sq": "0.9953993231144699",
      "hy": "0.9907382625931053",
      "bn": "0.9900029329225141",
      "bg": "0.9864075243954016",
      "zh": "0.9930439640561582",
      "fr": "0.9858533456323142",
      "de": "0.9906919817143242",
      "ha": "0.9869595182242975",
      "hi": "0.9837822266492634",
      "hu": "0.992569833336628"
    },
    "canonical_solution": "{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}",
    "instruction": {
      "en": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C# në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nՏվեք C# կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\n请用最多500个字符的中文为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nFournir une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9639110447001522",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8818071766993811",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(UniqueAndSorted(new List<int> { 3, 1, 2, 1 }) .SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 5, 4, 5, 4, 5 }) .SequenceEqual(new List<int> { 4, 5 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 8, 7, 9, 6, 10 }) .SequenceEqual(new List<int> { 6, 7, 8, 9, 10 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 11, 11, 11 }) .SequenceEqual(new List<int> { 11 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 15, 14, 13, 12, 11, 15, 14 }) .SequenceEqual(new List<int> { 11, 12, 13, 14, 15 }));\n\n    }\n}",
    "entry_point": "UniqueAndSorted",
    "signature": "static List<int> UniqueAndSorted(List<int> numbers)",
    "docstring": {
      "en": "This function takes a list of integers and performs two operations. Firstly, it removes any duplicate numbers, ensuring each number is unique. Secondly, it sorts the remaining numbers in ascending order.\n    Example usage:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "sq": "Kjo funksion merr një listë të numrave të plotë dhe kryen dy operacione. Së pari, heq çdo numër të dyfishtë, duke siguruar që çdo numër të jetë unik. Së dyti, rendit numrat e mbetur në rend rritës.\n    Shembull përdorimi:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hy": "Այս ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ և կատարում է երկու գործողություն։ Նախ, այն հեռացնում է կրկնվող թվերը, ապահովելով, որ յուրաքանչյուր թիվ լինի եզակի։ Երկրորդ, այն դասավորում է մնացած թվերը աճման կարգով։\n    Օրինակ օգտագործում:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "bn": "এই ফাংশনটি পূর্ণসংখ্যার একটি তালিকা গ্রহণ করে এবং দুটি অপারেশন সম্পাদন করে। প্রথমত, এটি যেকোনও সদৃশ সংখ্যা সরিয়ে দেয়, প্রতিটি সংখ্যাকে অনন্য করে তোলে। দ্বিতীয়ত, এটি অবশিষ্ট সংখ্যাগুলিকে ঊর্ধ্বক্রমে সাজায়।\n    উদাহরণ ব্যবহার:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "bg": "Тази функция приема списък от цели числа и извършва две операции. Първо, премахва всички дублиращи се числа, като гарантира, че всяко число е уникално. Второ, сортира останалите числа във възходящ ред.\n    Пример за използване:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "zh": "此函数接受一个整数列表并执行两个操作。首先，它移除任何重复的数字，确保每个数字都是唯一的。其次，它将剩余的数字按升序排序。\n    示例用法:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "fr": "Cette fonction prend une liste d'entiers et effectue deux opérations. Premièrement, elle supprime tous les nombres en double, garantissant que chaque nombre est unique. Deuxièmement, elle trie les nombres restants par ordre croissant.\n    Exemple d'utilisation :\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "de": "Diese Funktion nimmt eine Liste von ganzen Zahlen und führt zwei Operationen durch. Erstens entfernt sie alle doppelten Zahlen, sodass jede Zahl einzigartig ist. Zweitens sortiert sie die verbleibenden Zahlen in aufsteigender Reihenfolge.\n    Beispielverwendung:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "ha": "Wannan aikin yana ɗaukar jerin lambobi kuma yana aiwatar da ayyuka guda biyu. Da fari, yana cire duk wani lambobi masu maimaita, yana tabbatar da cewa kowanne lamba na musamman ne. Na biyu, yana tsara lambobin da suka rage a cikin tsari mai ƙaruwa.\n    Misalin amfani:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hi": "यह फ़ंक्शन पूर्णांकों की एक सूची लेता है और दो ऑपरेशनों को निष्पादित करता है। सबसे पहले, यह किसी भी डुप्लिकेट नंबर को हटा देता है, जिससे प्रत्येक नंबर अद्वितीय हो जाता है। दूसरे, यह शेष संख्याओं को आरोही क्रम में क्रमबद्ध करता है।\n    Example usage:\n    उदाहरण उपयोग:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hu": "Ez a függvény egy egész számokat tartalmazó listát vesz át, és két műveletet hajt végre. Először eltávolítja az ismétlődő számokat, biztosítva, hogy minden szám egyedi legyen. Másodszor, a megmaradt számokat növekvő sorrendbe rendezi.\n    Példa használat:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]"
    },
    "docstring_bertscore": {
      "sq": "0.9966626123378518",
      "hy": "0.9888971575912928",
      "bn": "0.9877784712853044",
      "bg": "0.9895099323167855",
      "zh": "0.9944008081890076",
      "fr": "0.9815563745993865",
      "de": "0.9905249335638737",
      "ha": "0.9849626870037538",
      "hi": "1",
      "hu": "0.9924196687685656"
    }
  },
  {
    "task_id": "C#/15",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function awards the top 5 students based on their total scores. Students are sorted first by their total score (Chinese, Mathematics, English),\n   then by their Chinese score, and finally by their student ID if there is a tie. The function returns a list of the top 5 students with their IDs and total scores.\n   Example:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kjo funksion shpërblen 5 studentët më të mirë bazuar në totalin e pikëve të tyre. Studentët renditen fillimisht sipas totalit të pikëve (Kinezisht, Matematikë, Anglisht),\n   pastaj sipas pikëve në Kinezisht, dhe në fund sipas ID-së së studentit nëse ka barazim. Funksioni kthen një listë të 5 studentëve më të mirë me ID-të dhe totalin e pikëve të tyre.\n   Shembull:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Այս ֆունկցիան պարգևատրում է լավագույն 5 ուսանողներին՝ հիմնվելով նրանց ընդհանուր միավորների վրա։ Ուսանողները դասակարգվում են նախ իրենց ընդհանուր միավորներով (չինարեն, մաթեմատիկա, անգլերեն),\n   ապա՝ իրենց չինարենի միավորով, և վերջապես՝ իրենց ուսանողի ID-ով, եթե կա հավասարություն։ Ֆունկցիան վերադարձնում է լավագույն 5 ուսանողների ցուցակը՝ իրենց ID-ներով և ընդհանուր միավորներով։\n   Օրինակ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* এই ফাংশনটি মোট স্কোরের ভিত্তিতে শীর্ষ ৫ জন শিক্ষার্থীকে পুরস্কৃত করে। শিক্ষার্থীদের প্রথমে তাদের মোট স্কোর (চীনা, গণিত, ইংরেজি) দ্বারা সাজানো হয়, \n   তারপর তাদের চীনা স্কোর দ্বারা, এবং যদি সমতা থাকে তবে তাদের ছাত্র আইডি দ্বারা। ফাংশনটি শীর্ষ ৫ জন শিক্ষার্থীর আইডি এবং মোট স্কোরের একটি তালিকা ফেরত দেয়।\n   উদাহরণ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Тази функция награждава топ 5 студенти на базата на техните общи резултати. Студентите се сортират първо по общия им резултат (Китайски, Математика, Английски),\n   след това по резултата им по Китайски, и накрая по техния студентски ID, ако има равенство. Функцията връща списък с топ 5 студенти с техните ID и общи резултати.\n   Пример:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 此函数根据学生的总成绩奖励前5名学生。学生首先按总成绩（语文、数学、英语）排序，然后按语文成绩排序，如果有并列则按学生ID排序。该函数返回前5名学生的ID和总成绩的列表。\n   示例:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Cette fonction récompense les 5 meilleurs étudiants en fonction de leurs scores totaux. Les étudiants sont triés d'abord par leur score total (Chinois, Mathématiques, Anglais),\n   puis par leur score en Chinois, et enfin par leur ID étudiant en cas d'égalité. La fonction renvoie une liste des 5 meilleurs étudiants avec leurs IDs et leurs scores totaux.\n   Exemple:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Diese Funktion zeichnet die besten 5 Studenten basierend auf ihren Gesamtergebnissen aus. Die Studenten werden zuerst nach ihrem Gesamtergebnis (Chinesisch, Mathematik, Englisch) sortiert,\n   dann nach ihrem Chinesisch-Ergebnis und schließlich nach ihrer Studenten-ID, falls es einen Gleichstand gibt. Die Funktion gibt eine Liste der besten 5 Studenten mit ihren IDs und Gesamtergebnissen zurück.\n   Beispiel:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Wannan aikin yana ba da lambar yabo ga ɗalibai biyar na farko bisa ga jimillar maki nasu. Ana jera ɗalibai da farko bisa ga jimillar maki nasu (Sinanci, Lissafi, Turanci),\n   sannan bisa ga maki nasu na Sinanci, kuma a ƙarshe bisa ga lambar ɗalibi idan akwai daidaito. Aikin yana dawo da jerin ɗalibai biyar na farko tare da lambobin su da jimillar maki nasu.\n   Misali:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह फ़ंक्शन उनके कुल स्कोर के आधार पर शीर्ष 5 छात्रों को पुरस्कृत करता है। छात्रों को पहले उनके कुल स्कोर (चीनी, गणित, अंग्रेजी) के आधार पर क्रमबद्ध किया जाता है,\n   फिर उनके चीनी स्कोर के आधार पर, और अंत में यदि टाई होती है तो उनके छात्र आईडी के आधार पर। फ़ंक्शन शीर्ष 5 छात्रों की सूची उनके आईडी और कुल स्कोर के साथ लौटाता है।\n   उदाहरण:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ez a függvény a legjobb 5 diákot jutalmazza az összesített pontszámaik alapján. A diákok először az összesített pontszámuk (kínai, matematika, angol) szerint vannak sorba rendezve,\n   majd a kínai pontszámuk szerint, és végül a diákazonosítójuk alapján, ha döntetlen van. A függvény visszaadja a legjobb 5 diák listáját azonosítóikkal és összesített pontszámaikkal.\n   Példa:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)"
    },
    "prompt_bertscore": {
      "sq": "0.971698348788625",
      "hy": "0.9878916906024943",
      "bn": "0.9820197792783408",
      "bg": "0.9927511828745128",
      "zh": "0.9726070827818596",
      "fr": "0.9911849823200527",
      "de": "0.9926868266310575",
      "ha": "0.9686644683486981",
      "hi": "0.9902849880635837",
      "hu": "0.9880297387173135"
    },
    "canonical_solution": "{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}",
    "instruction": {
      "en": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nՏվեք C# կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nনিচের C# কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nПредоставете кратко описание на C# кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\n请为以下C#代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9287852481179426",
      "bn": "0.872474726876838",
      "bg": "0.9000956717724065",
      "zh": "0.8969811473977793",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9195461545744857",
      "hi": "0.9150793545657733",
      "hu": "0.9437490678732059"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        // Test Case 1\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80) }).SequenceEqual(new List<(int, int)> { (3, 255), (2, 255), (1, 255) }));\n\n        // Test Case 2\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (4, 88, 75, 95), (5, 95, 88, 75) }).SequenceEqual(new List<(int, int)> { (5, 258), (4, 258) }));\n\n        // Test Case 3\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (6, 75, 85, 90), (7, 90, 75, 85) }).SequenceEqual(new List<(int, int)> { (7, 250), (6, 250) }));\n\n        // Test Case 4\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (8, 80, 90, 80), (9, 90, 80, 80) }).SequenceEqual(new List<(int, int)> { (9, 250), (8, 250) }));\n\n        // Test Case 5\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (10, 85, 85, 85), (11, 86, 85, 84), (12, 84, 86, 85) }).SequenceEqual(new List<(int, int)> { (11, 255), (10, 255), (12, 255) }));\n        }\n}\n",
    "entry_point": "AwardTopStudents",
    "signature": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
    "docstring": {
      "en": "This function awards the top 5 students based on their total scores. Students are sorted first by their total score (Chinese, Mathematics, English),\n   then by their Chinese score, and finally by their student ID if there is a tie. The function returns a list of the top 5 students with their IDs and total scores.\n   Example:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "sq": "Kjo funksion shpërblen 5 studentët më të mirë bazuar në totalin e pikëve të tyre. Studentët renditen fillimisht sipas totalit të pikëve të tyre (Kinezisht, Matematikë, Anglisht), pastaj sipas pikëve të tyre në Kinezisht, dhe së fundi sipas ID-së së studentit nëse ka barazim. Funksioni kthen një listë të 5 studentëve më të mirë me ID-të dhe totalin e pikëve të tyre.\nShembull:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hy": "Այս ֆունկցիան պարգևատրում է լավագույն 5 ուսանողներին՝ հիմնված նրանց ընդհանուր միավորների վրա: Ուսանողները դասավորվում են նախ իրենց ընդհանուր միավորներով (չինարեն, մաթեմատիկա, անգլերեն), ապա՝ չինարենի միավորով, և վերջապես՝ ուսանողի ID-ով, եթե կա հավասարություն: Ֆունկցիան վերադարձնում է լավագույն 5 ուսանողների ցուցակը՝ նրանց ID-ներով և ընդհանուր միավորներով:\nՕրինակ:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "bn": "এই ফাংশনটি তাদের মোট স্কোরের ভিত্তিতে শীর্ষ ৫ জন ছাত্রকে পুরস্কৃত করে। ছাত্রদের প্রথমে তাদের মোট স্কোর (চীনা, গণিত, ইংরেজি) অনুযায়ী সাজানো হয়, তারপর তাদের চীনা স্কোর অনুযায়ী, এবং অবশেষে যদি স্কোর সমান হয় তবে তাদের ছাত্র আইডি অনুযায়ী। ফাংশনটি শীর্ষ ৫ জন ছাত্রের আইডি এবং মোট স্কোর সহ একটি তালিকা প্রদান করে।\n   উদাহরণ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "bg": "Тази функция награждава първите 5 студенти въз основа на техните общи резултати. Студентите се сортират първо по общия им резултат (Китайски, Математика, Английски), след това по резултата им по Китайски, и накрая по студентския им ID в случай на равенство. Функцията връща списък с първите 5 студенти с техните ID и общи резултати.\nПример:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "zh": "此函数根据学生的总成绩奖励前5名学生。学生首先按总成绩（语文、数学、英语）排序，然后按语文成绩排序，最后在成绩相同的情况下按学生ID排序。函数返回前5名学生的ID和总成绩的列表。\n示例：\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "fr": "Cette fonction récompense les 5 meilleurs étudiants en fonction de leurs scores totaux. Les étudiants sont triés d'abord par leur score total (Chinois, Mathématiques, Anglais), puis par leur score en Chinois, et enfin par leur ID étudiant en cas d'égalité. La fonction renvoie une liste des 5 meilleurs étudiants avec leurs IDs et leurs scores totaux.\nExemple :\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "de": "Diese Funktion zeichnet die Top-5-Studenten basierend auf ihren Gesamtergebnissen aus. Die Studenten werden zuerst nach ihrem Gesamtergebnis (Chinesisch, Mathematik, Englisch) sortiert, dann nach ihrem Chinesisch-Ergebnis und schließlich nach ihrer Studenten-ID, falls es einen Gleichstand gibt. Die Funktion gibt eine Liste der Top-5-Studenten mit ihren IDs und Gesamtergebnissen zurück.\nBeispiel:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "ha": "Wannan aikin yana ba da lambar yabo ga ɗalibai 5 mafi kyau bisa jimillar maki nasu. Ana tsara ɗalibai da farko bisa jimillar maki nasu (Sinanci, Lissafi, Turanci), sannan bisa maki na Sinanci, kuma a ƙarshe bisa ID ɗin ɗalibai idan akwai daidaituwa. Aikin yana mayar da jerin ɗalibai 5 mafi kyau tare da ID ɗin su da jimillar maki nasu.\n\nMisali:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hi": "यह फ़ंक्शन उनके कुल अंकों के आधार पर शीर्ष 5 छात्रों को पुरस्कृत करता है। छात्रों को पहले उनके कुल स्कोर (चीनी, गणित, अंग्रेजी) के आधार पर क्रमबद्ध किया जाता है, फिर उनके चीनी स्कोर के आधार पर, और अंत में यदि टाई होती है तो उनके छात्र आईडी के आधार पर। फ़ंक्शन शीर्ष 5 छात्रों की सूची उनके आईडी और कुल अंकों के साथ लौटाता है।\n\nउदाहरण:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hu": "Ez a függvény a legjobb 5 diákot díjazza az összpontszámuk alapján. A diákokat először az összpontszámuk (kínai, matematika, angol), majd a kínai pontszámuk, végül pedig a diákazonosítójuk alapján rendezi, ha döntetlen van. A függvény visszaadja a legjobb 5 diák listáját azonosítóikkal és összpontszámaikkal.\nPélda:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]"
    },
    "docstring_bertscore": {
      "sq": "0.9765991561798988",
      "hy": "0.9922873809347963",
      "bn": "0.9741885778756594",
      "bg": "0.9924935592703106",
      "zh": "0.9652768272001481",
      "fr": "0.9934167932813607",
      "de": "0.9912978043764805",
      "ha": "0.9792097552778404",
      "hi": "1",
      "hu": "0.9911939206871992"
    }
  },
  {
    "task_id": "C#/16",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Determine the minimum number of groups needed to distribute souvenirs where each group can have at most two souvenirs and the total price of souvenirs in a group cannot exceed a specified limit.\n    Example:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Përcaktoni numrin minimal të grupeve të nevojshme për të shpërndarë suveniret ku secili grup mund të ketë maksimumi dy suvenire dhe çmimi total i suvenireve në një grup nuk mund të kalojë një kufi të specifikuar.\n    Shembull:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Որոշել անհրաժեշտ խմբերի նվազագույն քանակը հուշանվերներ բաժանելու համար, որտեղ յուրաքանչյուր խումբ կարող է ունենալ առավելագույնը երկու հուշանվեր, և խմբի հուշանվերների ընդհանուր գինը չպետք է գերազանցի նշված սահմանը:\n    Օրինակ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    স্মৃতিচিহ্ন বিতরণের জন্য প্রয়োজনীয় ন্যূনতম সংখ্যক গ্রুপ নির্ধারণ করুন যেখানে প্রতিটি গ্রুপে সর্বাধিক দুটি স্মৃতিচিহ্ন থাকতে পারে এবং একটি গ্রুপে স্মৃতিচিহ্নের মোট মূল্য একটি নির্দিষ্ট সীমা অতিক্রম করতে পারবে না।\n    উদাহরণ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Определете минималния брой групи, необходими за разпределяне на сувенири, където всяка група може да има най-много два сувенира и общата цена на сувенирите в групата не може да надвишава определен лимит.\n    Пример:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    确定分配纪念品所需的最小组数，其中每组最多可以有两个纪念品，并且组内纪念品的总价格不能超过指定的限制。\n    示例：\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Déterminer le nombre minimum de groupes nécessaires pour distribuer des souvenirs où chaque groupe peut avoir au maximum deux souvenirs et le prix total des souvenirs dans un groupe ne peut pas dépasser une limite spécifiée.\n    Exemple :\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Bestimmen Sie die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs zu verteilen, wobei jede Gruppe höchstens zwei Souvenirs haben kann und der Gesamtpreis der Souvenirs in einer Gruppe ein angegebenes Limit nicht überschreiten darf.\n    Beispiel:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Tantance mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta inda kowace ƙungiya za ta iya samun kayan kyauta biyu kawai kuma jimillar farashin kayan kyauta a cikin ƙungiya ba zai wuce iyaka da aka kayyade ba.\n    Misali:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    यह निर्धारित करें कि स्मृति चिन्हों को वितरित करने के लिए न्यूनतम कितने समूहों की आवश्यकता है, जहाँ प्रत्येक समूह में अधिकतम दो स्मृति चिन्ह हो सकते हैं और एक समूह में स्मृति चिन्हों की कुल कीमत निर्दिष्ट सीमा से अधिक नहीं हो सकती।\n    उदाहरण:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Határozza meg a szükséges csoportok minimális számát az ajándéktárgyak elosztásához, ahol minden csoportban legfeljebb két ajándéktárgy lehet, és a csoportban lévő ajándéktárgyak összára nem haladhat meg egy megadott határt.\n    Példa:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)"
    },
    "prompt_bertscore": {
      "sq": "0.9934227521927917",
      "hy": "0.9697605107912486",
      "bn": "0.9864877710693397",
      "bg": "0.9871654979294306",
      "zh": "0.9852717558766441",
      "fr": "0.9890383837922087",
      "de": "0.9834642194092266",
      "ha": "0.9899755219299312",
      "hi": "0.9836928429777978",
      "hu": "0.9736125497706583"
    },
    "canonical_solution": "{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}",
    "instruction": {
      "en": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nՏվեք C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\n请用不超过500个字符的中文为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.948868567313999",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9243830029830663",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30) == 2);\n        Debug.Assert(MinimumGroups(new List<int> { 10, 20, 30, 40, 50 }, 60) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 25, 30, 35, 5, 15, 20 }, 40) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 32, 42, 52, 12, 22 }, 70) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 30, 35, 40, 10, 15, 20, 25}, 45) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 10, 15, 20, 25 }, 30) == 3);\n\n    }\n}\n",
    "entry_point": "MinimumGroups",
    "signature": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
    "docstring": {
      "en": "Determine the minimum number of groups needed to distribute souvenirs where each group can have at most two souvenirs and the total price of souvenirs in a group cannot exceed a specified limit.\n    Example:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "sq": "Përcaktoni numrin minimal të grupeve të nevojshme për të shpërndarë suveniret ku secili grup mund të ketë maksimumi dy suvenire dhe çmimi total i suvenireve në një grup nuk mund të tejkalojë një kufi të specifikuar.\n    Shembull:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "hy": "Նվազագույն խմբերի քանակը որոշելու համար, որոնք անհրաժեշտ են հուշանվերները բաշխելու համար, որտեղ յուրաքանչյուր խումբ կարող է ունենալ առավելագույնը երկու հուշանվեր, և խմբի հուշանվերների ընդհանուր գինը չի կարող գերազանցել նշված սահմանը:\n    Օրինակ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "bn": "স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করুন যেখানে প্রতিটি গ্রুপে সর্বাধিক দুটি স্মারক থাকতে পারে এবং একটি গ্রুপে স্মারকের মোট মূল্য নির্দিষ্ট সীমা অতিক্রম করতে পারবে না।\n    উদাহরণ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "bg": "Определете минималния брой групи, необходими за разпределяне на сувенири, където всяка група може да има най-много два сувенира и общата цена на сувенирите в група не може да надвишава определен лимит.\n    Пример:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "zh": "确定分配纪念品所需的最小组数，其中每组最多可以有两个纪念品，并且每组中纪念品的总价格不能超过指定的限制。\n    示例：\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "fr": "Déterminer le nombre minimum de groupes nécessaires pour distribuer des souvenirs où chaque groupe peut avoir au maximum deux souvenirs et le prix total des souvenirs dans un groupe ne peut pas dépasser une limite spécifiée.\n    Exemple :\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "de": "Bestimmen Sie die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs zu verteilen, wobei jede Gruppe höchstens zwei Souvenirs haben kann und der Gesamtpreis der Souvenirs in einer Gruppe ein bestimmtes Limit nicht überschreiten darf.\n    Beispiel:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "ha": "Kayyade mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan tunawa inda kowace ƙungiya za ta iya samun a kalla kayan tunawa biyu kuma jimlar farashin kayan tunawa a cikin ƙungiya ba zai wuce iyaka da aka ƙayyade ba.\n    Misali:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "hi": "स्मृति चिन्हों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करें जहाँ प्रत्येक समूह में अधिकतम दो स्मृति चिन्ह हो सकते हैं और समूह में स्मृति चिन्हों की कुल कीमत निर्दिष्ट सीमा से अधिक नहीं हो सकती।\n\n    उदाहरण:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "hu": "Határozza meg a szükséges minimális csoportok számát az ajándéktárgyak elosztásához, ahol minden csoportban legfeljebb két ajándéktárgy lehet, és a csoportban lévő ajándéktárgyak összára nem haladhat meg egy megadott határt.\n    Példa:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.989637651651791",
      "hy": "0.9555101713646627",
      "bn": "0.9385737532953419",
      "bg": "0.9906750981319361",
      "zh": "0.9779861921306654",
      "fr": "0.9846216386395169",
      "de": "0.9775501984442938",
      "ha": "0.9786033367245408",
      "hi": "0.9697255518441865",
      "hu": "0.9484508476226827"
    }
  },
  {
    "task_id": "C#/17",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calculate the initial number of peaches a monkey had, given that each day it eats half of the peaches plus one more, and on the Nth day only one peach is left.\n    Examples:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Llogarit numrin fillestar të pjeshkëve që kishte një majmun, duke pasur parasysh që çdo ditë ai ha gjysmën e pjeshkëve plus edhe një tjetër, dhe në ditën e N-të mbetet vetëm një pjeshkë.\n    Shembuj:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Հաշվել կապիկի սկզբնական դեղձերի քանակը, հաշվի առնելով, որ ամեն օր այն ուտում է դեղձերի կեսը և ևս մեկ դեղձ, և N-րդ օրը միայն մեկ դեղձ է մնում:\n    Օրինակներ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* একটি বাঁদর কতগুলি পীচ ছিল তা গণনা করুন, দেওয়া যে প্রতিদিন এটি অর্ধেক পীচ এবং আরও একটি খায়, এবং N তম দিনে শুধুমাত্র একটি পীচ অবশিষ্ট থাকে।\n    উদাহরণ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Изчислете първоначалния брой праскови, които една маймуна е имала, като се има предвид, че всеки ден изяжда половината от прасковите плюс още една, и на N-тия ден остава само една праскова.\n    Примери:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 计算猴子最初有多少个桃子，已知每天它吃掉一半的桃子加上一个，到了第N天只剩下一个桃子。\n    例子:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calculer le nombre initial de pêches qu'un singe avait, étant donné que chaque jour il mange la moitié des pêches plus une de plus, et que le Nème jour, il ne reste qu'une pêche.\n    Exemples :\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Berechne die anfängliche Anzahl an Pfirsichen, die ein Affe hatte, gegeben, dass er jeden Tag die Hälfte der Pfirsiche plus einen weiteren isst, und am N-ten Tag nur noch ein Pfirsich übrig ist.\n    Beispiele:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Lissafa adadin farko na ayaba da biri ya mallaka, la'akari da cewa kowace rana yana cin rabin ayabar da karin daya, kuma a rana ta N daya tilo ce ta rage.\n    Misalai:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह गणना करें कि एक बंदर के पास शुरू में कितने आड़ू थे, यह मानते हुए कि हर दिन वह आधे आड़ू खा जाता है और एक और खा जाता है, और Nवें दिन केवल एक आड़ू बचा है।\n    उदाहरण:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Számítsuk ki, hogy hány barackja volt kezdetben egy majomnak, ha minden nap megeszi a barackok felét plusz még egyet, és az N-edik napon csak egy barack marad.\n    Példák:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)"
    },
    "prompt_bertscore": {
      "sq": "0.9885181708242783",
      "hy": "0.9750087227189524",
      "bn": "0.9799991124120729",
      "bg": "0.9885181708242783",
      "zh": "0.9767395878592905",
      "fr": "0.9957681797320517",
      "de": "0.9845235152312857",
      "ha": "0.9812276413187737",
      "hi": "0.9766585466638282",
      "hu": "0.9640705448961232"
    },
    "canonical_solution": "{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}",
    "instruction": {
      "en": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nՏվեք C# կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nBa da takaitaccen bayani na yanayi (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9287852481179426",
      "bn": "0.8797765783140615",
      "bg": "0.8379186022274364",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.8951781794291257",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(InitialPeachesCount(1) == 1);\n        Debug.Assert(InitialPeachesCount(2) == 4);\n        Debug.Assert(InitialPeachesCount(3) == 10);\n        Debug.Assert(InitialPeachesCount(4) == 22);\n\n\n    }\n}",
    "entry_point": "InitialPeachesCount",
    "signature": "static int InitialPeachesCount(int days)",
    "docstring": {
      "en": "Calculate the initial number of peaches a monkey had, given that each day it eats half of the peaches plus one more, and on the Nth day only one peach is left.\n    Examples:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "sq": "Llogaritni numrin fillestar të pjeshkëve që kishte një majmun, duke pasur parasysh se çdo ditë ai ha gjysmën e pjeshkëve plus edhe një tjetër, dhe në ditën e N-të mbetet vetëm një pjeshkë.\n    Shembuj:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "hy": "Հաշվարկել, թե քանի դեղձ ուներ կապիկը սկզբում, եթե ամեն օր այն ուտում է դեղձերի կեսը և ևս մեկ դեղձ, և N-րդ օրը մնում է միայն մեկ դեղձ։\n    Օրինակներ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "bn": "প্রাথমিকভাবে একটি বানরের কাছে কতগুলি পীচ ছিল তা গণনা করুন, দেওয়া হয়েছে যে প্রতিদিন এটি অর্ধেক পীচ এবং আরও একটি পীচ খায়, এবং N-তম দিনে শুধুমাত্র একটি পীচ অবশিষ্ট থাকে।\n    উদাহরণ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "bg": "Изчислете първоначалния брой праскови, които една маймуна е имала, като се има предвид, че всеки ден тя изяжда половината от прасковите плюс още една, и на N-тия ден остава само една праскова.\n    Примери:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "zh": "计算猴子最初有多少桃子，已知它每天吃掉一半的桃子加上一个，并且在第N天只剩下一个桃子。\n    示例：\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "fr": "Calculez le nombre initial de pêches qu'un singe avait, étant donné que chaque jour il mange la moitié des pêches plus une de plus, et que le Nème jour il ne reste qu'une pêche.\n    Exemples :\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "de": "Berechne die anfängliche Anzahl von Pfirsichen, die ein Affe hatte, gegeben, dass er jeden Tag die Hälfte der Pfirsiche plus einen weiteren isst, und am N-ten Tag nur noch ein Pfirsich übrig ist.\n    Beispiele:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "ha": "Ƙididdige adadin ayaba da biri ya fara da shi, la'akari da cewa kowace rana yana cin rabin ayabar da ƙari ɗaya, kuma a rana ta N sai dai ayaba ɗaya ce ta rage. \n    Misalai:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "hi": "शुरुआती संख्या की गणना करें कि एक बंदर के पास कितनी आड़ू थीं, यह देखते हुए कि हर दिन वह आधी आड़ू खाता है और एक और खाता है, और Nवें दिन केवल एक आड़ू बचा होता है।\n    उदाहरण:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "hu": "Számítsuk ki, hogy hány barackja volt kezdetben egy majomnak, tekintve, hogy minden nap megeszi a barackok felét plusz még egyet, és az N-edik napon csak egy barack marad.\n    Példák:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10"
    },
    "docstring_bertscore": {
      "sq": "0.9876958410467939",
      "hy": "0.9518166394293189",
      "bn": "0.951401501932956",
      "bg": "0.9876958410467939",
      "zh": "0.95744244771137",
      "fr": "0.9944226575309214",
      "de": "0.9818992106370527",
      "ha": "0.9340517340407016",
      "hi": "0.9906023994124774",
      "hu": "0.9671872542049417"
    }
  },
  {
    "task_id": "C#/18",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Finds all amicable number pairs within a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n\n    Example usage:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Gjen të gjitha çiftet e numrave miqësorë brenda një kufiri të specifikuar.\n    Numrat miqësorë janë dy numra të ndryshëm të tillë që shuma e ndarësve të duhur të secilit është e barabartë me numrin tjetër.\n\n    Shembull përdorimi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Գտնում է բոլոր բարեկամական թվերի զույգերը նշված սահմանաչափի ներսում:\n    Բարեկամական թվերը երկու տարբեր թվեր են, որոնք այնպես են կապված, որ յուրաքանչյուրի ճիշտ բաժանարարների գումարը հավասար է մյուս թվին:\n\n    Օրինակ օգտագործում:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - নির্দিষ্ট সীমার মধ্যে সমস্ত বন্ধুত্বপূর্ণ সংখ্যা জোড়া খুঁজে বের করে।\n    বন্ধুত্বপূর্ণ সংখ্যা হল দুটি ভিন্ন সংখ্যা যেগুলি এমনভাবে সম্পর্কিত যে প্রতিটির যথাযথ বিভাজকদের যোগফল অন্য সংখ্যার সমান হয়।\n\n    উদাহরণ ব্যবহার:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Намира всички двойки приятелски числа в рамките на определен лимит.\n    Приятелските числа са две различни числа, така свързани, че сумата от собствените делители на всяко от тях е равна на другото число.\n\n    Пример за използване:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - 查找指定范围内的所有亲和数对。\n    亲和数是两个不同的数，它们的真因子之和等于对方。\n\n    示例用法:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Trouve toutes les paires de nombres amicaux dans une limite spécifiée.\n    Les nombres amicaux sont deux nombres différents tels que la somme des diviseurs propres de chacun est égale à l'autre nombre.\n\n    Exemple d'utilisation :\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Findet alle befreundeten Zahlenpaare innerhalb eines angegebenen Limits.\n    Befreundete Zahlen sind zwei verschiedene Zahlen, die so miteinander verwandt sind, dass die Summe der echten Teiler jeder Zahl gleich der anderen Zahl ist.\n\n    Beispielverwendung:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Nemi dukkan lambobin da ke da alaƙa a cikin iyaka da aka kayyade.\n    Lambobin da ke da alaƙa su ne lambobi biyu daban-daban da suka danganta da cewa jumlar masu rarraba da suka dace na kowanne suna daidai da ɗayan lambar.\n\n    Misalin amfani:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - निर्दिष्ट सीमा के भीतर सभी मित्रवत संख्या युग्मों को खोजता है।\n    मित्रवत संख्याएँ दो भिन्न संख्याएँ होती हैं जो इस प्रकार संबंधित होती हैं कि प्रत्येक के उचित भाजकों का योग दूसरी संख्या के बराबर होता है।\n\n    उदाहरण उपयोग:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Megkeresi az összes barátságos szám párt egy megadott határon belül.\n    A barátságos számok két különböző szám, amelyek úgy kapcsolódnak egymáshoz, hogy mindegyik szám megfelelő osztóinak összege egyenlő a másik számmal.\n\n    Példa használat:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)"
    },
    "prompt_bertscore": {
      "sq": "0.9844392959497269",
      "hy": "0.9825320470310298",
      "bn": "0.9797154682279552",
      "bg": "0.9849170020161158",
      "zh": "0.9525050923299858",
      "fr": "0.9793489951749458",
      "de": "0.9776785136704423",
      "ha": "0.9756449358294071",
      "hi": "0.9823898276782089",
      "hu": "0.970502593894795"
    },
    "canonical_solution": "{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nՏվեք C# կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9169325760208287",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9252758465458182",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindAmicableNumbers(300).SequenceEqual(new List<(int, int)> { (220, 284) }));\n        Debug.Assert(FindAmicableNumbers(2000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) }));\n        Debug.Assert(FindAmicableNumbers(500).Count == 1);\n        Debug.Assert(FindAmicableNumbers(100).Count == 0);\n        Debug.Assert(FindAmicableNumbers(3000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) ,(2620,2924)}));\n\n    }\n}\n\n\n\n",
    "entry_point": "FindAmicableNumbers",
    "signature": "static List<(int, int)> FindAmicableNumbers(int limit)",
    "docstring": {
      "en": "FindAmicableNumbers - Finds all amicable number pairs within a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n\n    Example usage:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "sq": "FindAmicableNumbers - Gjen të gjitha çiftet e numrave miqësorë brenda një kufiri të specifikuar.\n    Numrat miqësorë janë dy numra të ndryshëm të tillë që shuma e ndarësve të duhur të secilit është e barabartë me numrin tjetër.\n\n    Shembull përdorimi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hy": "FindAmicableNumbers - Գտնում է բոլոր ընկերական թվերի զույգերը նշված սահմաններում:\n    Ընկերական թվերը երկու տարբեր թվեր են, որոնք այնպես են կապված, որ յուրաքանչյուրի ճիշտ բաժանարարների գումարը հավասար է մյուս թվին:\n\n    Օգտագործման օրինակ:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "bn": "FindAmicableNumbers - নির্দিষ্ট সীমার মধ্যে সমস্ত বন্ধুত্বপূর্ণ সংখ্যার জোড়া খুঁজে বের করে। \n    বন্ধুত্বপূর্ণ সংখ্যা হল দুটি ভিন্ন সংখ্যা যা এমনভাবে সম্পর্কিত যে প্রতিটি সংখ্যার সঠিক বিভাজকদের যোগফল অন্য সংখ্যার সমান হয়।\n\n    উদাহরণ ব্যবহার:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "bg": "FindAmicableNumbers - Намира всички двойки приятелски числа в рамките на зададен лимит.\n    Приятелските числа са две различни числа, които са свързани така, че сумата от собствените делители на всяко от тях е равна на другото число.\n\n    Пример за използване:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "zh": "FindAmicableNumbers - 在指定的限制内查找所有友好数对。\n    友好数是两个不同的数字，它们的特性是每个数字的适当除数之和等于另一个数字。\n\n    示例用法:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "fr": "FindAmicableNumbers - Trouve toutes les paires de nombres amicaux dans une limite spécifiée.\n    Les nombres amicaux sont deux nombres différents tels que la somme des diviseurs propres de chacun est égale à l'autre nombre.\n\n    Exemple d'utilisation :\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "de": "FindAmicableNumbers - Findet alle befreundeten Zahlenpaare innerhalb eines angegebenen Limits.\n    Befreundete Zahlen sind zwei verschiedene Zahlen, die so miteinander in Beziehung stehen, dass die Summe der echten Teiler jeder Zahl gleich der anderen Zahl ist.\n\n    Beispielverwendung:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "ha": "FindAmicableNumbers - Nemo dukkan ma'aurata lambobi a cikin iyaka da aka kayyade.\n    Lambobin ma'aurata su ne lambobi biyu daban-daban da suka danganta da cewa jumlar masu raba su daidai na kowanne ya yi daidai da dayan lambar.\n\n    Misalin amfani:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hi": "FindAmicableNumbers - निर्दिष्ट सीमा के भीतर सभी मित्रवत संख्या युग्मों को खोजता है।  \n    मित्रवत संख्याएँ दो भिन्न संख्याएँ होती हैं जो इस प्रकार संबंधित होती हैं कि प्रत्येक के उचित भाजकों का योग दूसरी संख्या के बराबर होता है।\n\n    उदाहरण उपयोग:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hu": "FindAmicableNumbers - Megtalálja az összes barátságos szám párt egy megadott határértéken belül.\n    A barátságos számok két különböző szám, amelyek úgy kapcsolódnak egymáshoz, hogy mindegyik szám megfelelő osztóinak összege egyenlő a másik számmal.\n\n    Példa használat:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)"
    },
    "docstring_bertscore": {
      "sq": "0.9754359766685585",
      "hy": "0.9537461349506918",
      "bn": "0.9658713279305855",
      "bg": "0.9667890002909667",
      "zh": "0.9562999257596574",
      "fr": "0.9692635375778993",
      "de": "0.9694464761588325",
      "ha": "0.9645701003044259",
      "hi": "0.9718916161493719",
      "hu": "0.9614994732440076"
    }
  },
  {
    "task_id": "C#/19",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function takes a string, reverses it, and then concatenates it with the original string.\n    Example usage:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kjo funksion merr një varg, e kthen atë mbrapsht dhe pastaj e bashkon me vargun origjinal.\n    Shembull përdorimi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Այս ֆունկցիան ստանում է տող, շրջում այն, և ապա միացնում այն սկզբնական տողի հետ։\n    Օրինակ օգտագործում՝\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* এই ফাংশনটি একটি স্ট্রিং নেয়, সেটিকে উল্টায় এবং তারপর মূল স্ট্রিংটির সাথে সংযুক্ত করে।\n    উদাহরণ ব্যবহার:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Тази функция приема низ, обръща го и след това го конкатенира с оригиналния низ.\n    Пример за използване:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 这个函数接受一个字符串，将其反转，然后与原始字符串连接。\n    示例用法：\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Cette fonction prend une chaîne, la renverse, puis la concatène avec la chaîne originale.\n    Exemple d'utilisation :\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Diese Funktion nimmt einen String, kehrt ihn um und verkettet ihn dann mit dem Originalstring.\n    Beispielverwendung:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Wannan aiki yana ɗaukar wani kirtani, yana jujjuya shi, sannan kuma yana haɗa shi da kirtanin asali.\n    Misalin amfani:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह फ़ंक्शन एक स्ट्रिंग लेता है, उसे उलटता है, और फिर उसे मूल स्ट्रिंग के साथ जोड़ता है।\n    उदाहरण उपयोग:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ez a függvény egy karakterláncot vesz, megfordítja, majd összefűzi az eredeti karakterlánccal.\n    Példa használat:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.999999801369619",
      "zh": "0.999999801369619",
      "fr": "0.9929396831061149",
      "de": "0.999999801369619",
      "ha": "0.9908230777658071",
      "hi": "0.999999801369619",
      "hu": "0.999999801369619"
    },
    "canonical_solution": "{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}",
    "instruction": {
      "en": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit C# në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nՏվեք C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nОсигурете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nBa da taƙaitaccen bayanin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.948868567313999",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9428713202194127",
      "hi": "0.9242652151671127",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(ReverseAndConcatenate(\"abc\") == \"abccba\");\n        Debug.Assert(ReverseAndConcatenate(\"test\") == \"testtset\");\n        Debug.Assert(ReverseAndConcatenate(\"\") == \"\");\n        Debug.Assert(ReverseAndConcatenate(\"12345\") == \"1234554321\");\n\n    }\n}",
    "entry_point": "ReverseAndConcatenate",
    "signature": "static string ReverseAndConcatenate(string input)",
    "docstring": {
      "en": "This function takes a string, reverses it, and then concatenates it with the original string.\n    Example usage:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "sq": "Kjo funksion merr një varg, e kthen atë mbrapsht dhe pastaj e bashkon me vargun origjinal.\n    Shembull përdorimi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hy": "Այս ֆունկցիան ստանում է տող, շրջում այն, և ապա միացնում այն սկզբնական տողի հետ:\n    Օրինակ օգտագործում:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "bn": "এই ফাংশনটি একটি স্ট্রিং গ্রহণ করে, সেটিকে উল্টে দেয়, এবং তারপর মূল স্ট্রিংটির সাথে সংযুক্ত করে। \n    উদাহরণ ব্যবহার:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "bg": "Тази функция приема низ, обръща го и след това го конкатенира с оригиналния низ.\n    Пример за използване:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "zh": "这个函数接受一个字符串，将其反转，然后与原始字符串连接。\n    示例用法：  \n>>> ReverseAndConcatenate(\"hello\")  \n\"helloolleh\"  \n>>> ReverseAndConcatenate(\"123\")  \n\"123321\"",
      "fr": "Cette fonction prend une chaîne, la renverse, puis la concatène avec la chaîne originale.\n    Exemple d'utilisation :\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "de": "Diese Funktion nimmt einen String, kehrt ihn um und verkettet ihn dann mit dem ursprünglichen String.\n    Beispielverwendung:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "ha": "Wannan aikin yana ɗaukar kirtani, yana juyawa, sannan yana haɗawa da shi tare da ainihin kirtani.\n    Misalin amfani:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hi": "यह फ़ंक्शन एक स्ट्रिंग लेता है, उसे उलटता है, और फिर उसे मूल स्ट्रिंग के साथ जोड़ता है।\n    उदाहरण उपयोग:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hu": "Ez a függvény egy karakterláncot vesz, megfordítja, majd összefűzi az eredeti karakterlánccal.\n    Példa használat:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\""
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "1",
      "zh": "1",
      "fr": "0.9896142132668287",
      "de": "1",
      "ha": "0.9872824912238602",
      "hi": "1",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/20",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calculates the number of unique postage values that can be created using a given number of 3-cent and 5-cent stamps.\n        Parameters:\n        threeCentStamps - the number of 3-cent stamps available\n        fiveCentStamps - the number of 5-cent stamps available\n\n        Returns:\n        The number of unique postage values that can be created.\n\n        Example:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Llogarit numrin e vlerave unike të pullave që mund të krijohen duke përdorur një numër të caktuar pullash prej 3 cent dhe 5 cent.\n        Parametrat:\n        threeCentStamps - numri i pullave prej 3 cent që janë në dispozicion\n        fiveCentStamps - numri i pullave prej 5 cent që janë në dispozicion\n\n        Kthen:\n        Numrin e vlerave unike të pullave që mund të krijohen.\n\n        Shembull:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Հաշվում է եզակի նամականիշային արժեքների քանակը, որոնք կարող են ստեղծվել 3 ցենտանոց և 5 ցենտանոց նամականիշների տրված քանակով:\n        Պարամետրեր:\n        threeCentStamps - առկա 3 ցենտանոց նամականիշների քանակը\n        fiveCentStamps - առկա 5 ցենտանոց նամականիշների քանակը\n\n        Վերադարձնում է:\n        Եզակի նամականիշային արժեքների քանակը, որոնք կարող են ստեղծվել:\n\n        Օրինակ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* প্রদত্ত সংখ্যক 3-সেন্ট এবং 5-সেন্ট স্ট্যাম্প ব্যবহার করে কতগুলি অনন্য ডাকমাশুল মান তৈরি করা যেতে পারে তা গণনা করে।\n        প্যারামিটার:\n        threeCentStamps - উপলব্ধ 3-সেন্ট স্ট্যাম্পের সংখ্যা\n        fiveCentStamps - উপলব্ধ 5-সেন্ট স্ট্যাম্পের সংখ্যা\n\n        রিটার্নস:\n        কতগুলি অনন্য ডাকমাশুল মান তৈরি করা যেতে পারে।\n\n        উদাহরণ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Изчислява броя на уникалните стойности на пощенски марки, които могат да бъдат създадени с даден брой 3-центови и 5-центови марки.\n        Параметри:\n        threeCentStamps - броят на наличните 3-центови марки\n        fiveCentStamps - броят на наличните 5-центови марки\n\n        Връща:\n        Броят на уникалните стойности на пощенски марки, които могат да бъдат създадени.\n\n        Пример:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 计算可以使用给定数量的3美分和5美分邮票创建的唯一邮资值的数量。\n        参数:\n        threeCentStamps - 可用的3美分邮票数量\n        fiveCentStamps - 可用的5美分邮票数量\n\n        返回:\n        可以创建的唯一邮资值的数量。\n\n        示例:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcule le nombre de valeurs d'affranchissement uniques qui peuvent être créées en utilisant un nombre donné de timbres de 3 cents et de 5 cents.\n        Paramètres:\n        threeCentStamps - le nombre de timbres de 3 cents disponibles\n        fiveCentStamps - le nombre de timbres de 5 cents disponibles\n\n        Renvoie:\n        Le nombre de valeurs d'affranchissement uniques qui peuvent être créées.\n\n        Exemple:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Berechnet die Anzahl der einzigartigen Portowerte, die mit einer gegebenen Anzahl von 3-Cent- und 5-Cent-Briefmarken erstellt werden können.\n        Parameter:\n        threeCentStamps - die Anzahl der verfügbaren 3-Cent-Briefmarken\n        fiveCentStamps - die Anzahl der verfügbaren 5-Cent-Briefmarken\n\n        Rückgabe:\n        Die Anzahl der einzigartigen Portowerte, die erstellt werden können.\n\n        Beispiel:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Lissafa adadin ƙimar hatimi na musamman da za a iya ƙirƙira ta amfani da adadin hatimin senti 3 da senti 5 da aka bayar.\n        Sigogi:\n        threeCentStamps - adadin hatimin senti 3 da ake da su\n        fiveCentStamps - adadin hatimin senti 5 da ake da su\n\n        Komawa:\n        Adadin ƙimar hatimi na musamman da za a iya ƙirƙira.\n\n        Misali:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह गणना करता है कि 3-सेंट और 5-सेंट टिकटों की एक दी गई संख्या का उपयोग करके कितने अद्वितीय डाक मूल्य बनाए जा सकते हैं।\n        पैरामीटर्स:\n        threeCentStamps - उपलब्ध 3-सेंट टिकटों की संख्या\n        fiveCentStamps - उपलब्ध 5-सेंट टिकटों की संख्या\n\n        रिटर्न्स:\n        अद्वितीय डाक मूल्यों की संख्या जो बनाई जा सकती है।\n\n        उदाहरण:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kiszámítja az egyedi postai értékek számát, amelyek létrehozhatók adott számú 3 centes és 5 centes bélyeggel.\n        Paraméterek:\n        threeCentStamps - a rendelkezésre álló 3 centes bélyegek száma\n        fiveCentStamps - a rendelkezésre álló 5 centes bélyegek száma\n\n        Visszatérési érték:\n        Az egyedi postai értékek száma, amelyek létrehozhatók.\n\n        Példa:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)"
    },
    "prompt_bertscore": {
      "sq": "0.9883030541216175",
      "hy": "0.9865431889456484",
      "bn": "0.9715255403571247",
      "bg": "0.9945841440307027",
      "zh": "0.9873164570190173",
      "fr": "1",
      "de": "0.9945841440307027",
      "ha": "0.9898235696884395",
      "hi": "0.9712206427222361",
      "hu": "0.9854109957737496"
    },
    "canonical_solution": "   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }",
    "instruction": {
      "en": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nՏվեք C# կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C# a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9364434424587427",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9014117966771436",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountUniquePostageCombinations(4, 3) == 19); \n        Debug.Assert(CountUniquePostageCombinations(2, 2) == 8); \n        Debug.Assert(CountUniquePostageCombinations(3, 1) == 7);\n        Debug.Assert(CountUniquePostageCombinations(1, 3) == 7); \n\n    }\n}\n",
    "entry_point": "CountUniquePostageCombinations",
    "signature": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
    "docstring": {
      "en": "Calculates the number of unique postage values that can be created using a given number of 3-cent and 5-cent stamps.\n        Parameters:\n        threeCentStamps - the number of 3-cent stamps available\n        fiveCentStamps - the number of 5-cent stamps available\n\n        Returns:\n        The number of unique postage values that can be created.\n\n        Example:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "sq": "Llogarit numrin e vlerave unike të pullave postare që mund të krijohen duke përdorur një numër të caktuar pullash prej 3-cent dhe 5-cent.\n        Parametrat:\n        threeCentStamps - numri i pullave prej 3-cent në dispozicion\n        fiveCentStamps - numri i pullave prej 5-cent në dispozicion\n\n        Kthen:\n        Numri i vlerave unike të pullave postare që mund të krijohen.\n\n        Shembull:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hy": "Հաշվում է եզակի փոստային արժեքների քանակը, որոնք կարող են ստեղծվել օգտագործելով 3-ցենտանոց և 5-ցենտանոց դրոշմանիշների տրված քանակը:\n        \n        Պարամետրեր:\n        threeCentStamps - առկա 3-ցենտանոց դրոշմանիշների քանակը\n        fiveCentStamps - առկա 5-ցենտանոց դրոշմանիշների քանակը\n\n        Վերադարձնում է:\n        Եզակի փոստային արժեքների քանակը, որոնք կարող են ստեղծվել:\n\n        Օրինակ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "bn": "অনন্য ডাকমাশুল মানগুলির সংখ্যা গণনা করে যা একটি প্রদত্ত সংখ্যক ৩-সেন্ট এবং ৫-সেন্ট স্ট্যাম্প ব্যবহার করে তৈরি করা যেতে পারে।\n        \n        প্যারামিটারসমূহ:\n        threeCentStamps - উপলব্ধ ৩-সেন্ট স্ট্যাম্পের সংখ্যা\n        fiveCentStamps - উপলব্ধ ৫-সেন্ট স্ট্যাম্পের সংখ্যা\n\n        রিটার্নস:\n        অনন্য ডাকমাশুল মানগুলির সংখ্যা যা তৈরি করা যেতে পারে।\n\n        উদাহরণ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "bg": "Изчислява броя на уникалните стойности на пощенски марки, които могат да бъдат създадени с даден брой 3-центови и 5-центови марки.\n        \n        Параметри:\n        threeCentStamps - броят на наличните 3-центови марки\n        fiveCentStamps - броят на наличните 5-центови марки\n\n        Връща:\n        Броят на уникалните стойности на пощенски марки, които могат да бъдат създадени.\n\n        Пример:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "zh": "计算可以使用给定数量的3美分和5美分邮票创建的唯一邮资值的数量。\n        参数:\n        threeCentStamps - 可用的3美分邮票数量\n        fiveCentStamps - 可用的5美分邮票数量\n\n        返回:\n        可以创建的唯一邮资值的数量。\n\n        示例:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "fr": "Calcule le nombre de valeurs d'affranchissement uniques qui peuvent être créées en utilisant un nombre donné de timbres de 3 cents et de 5 cents.\n        \n        Paramètres:\n        threeCentStamps - le nombre de timbres de 3 cents disponibles\n        fiveCentStamps - le nombre de timbres de 5 cents disponibles\n\n        Renvoie:\n        Le nombre de valeurs d'affranchissement uniques qui peuvent être créées.\n\n        Exemple:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "de": "Berechnet die Anzahl der eindeutigen Portowerte, die mit einer gegebenen Anzahl von 3-Cent- und 5-Cent-Briefmarken erstellt werden können.\n        \nArgs:\n        threeCentStamps - die Anzahl der verfügbaren 3-Cent-Briefmarken\n        fiveCentStamps - die Anzahl der verfügbaren 5-Cent-Briefmarken\n\nReturns:\n        Die Anzahl der eindeutigen Portowerte, die erstellt werden können.\n\nExample:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "ha": "Ƙididdige adadin ƙimar wasiƙa na musamman da za a iya ƙirƙira ta amfani da adadin tambarin kuɗi na 3-cent da 5-cent da aka bayar.\n        \n        Sigogi:\n        threeCentStamps - adadin tambarin kuɗi na 3-cent da ake da su\n        fiveCentStamps - adadin tambarin kuɗi na 5-cent da ake da su\n\n        Komawa:\n        Adadin ƙimar wasiƙa na musamman da za a iya ƙirƙira.\n\n        Misali:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hi": "यह गणना करता है कि 3-सेंट और 5-सेंट डाक टिकटों की एक निश्चित संख्या का उपयोग करके कितने अद्वितीय डाक मूल्य बनाए जा सकते हैं।\n        पैरामीटर्स:\n        threeCentStamps - उपलब्ध 3-सेंट टिकटों की संख्या\n        fiveCentStamps - उपलब्ध 5-सेंट टिकटों की संख्या\n\n        रिटर्न्स:\n        उन अद्वितीय डाक मूल्य की संख्या जो बनाई जा सकती हैं।\n\n        उदाहरण:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hu": "Kiszámítja az egyedi postai értékek számát, amelyeket meg lehet alkotni adott számú 3-centes és 5-centes bélyeggel.\n        Paraméterek:\n        threeCentStamps - a rendelkezésre álló 3-centes bélyegek száma\n        fiveCentStamps - a rendelkezésre álló 5-centes bélyegek száma\n\n        Visszatér:\n        Az egyedi postai értékek száma, amelyeket meg lehet alkotni.\n\n        Példa:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8"
    },
    "docstring_bertscore": {
      "sq": "0.9823038207232208",
      "hy": "0.9926810663500075",
      "bn": "0.9710232041234874",
      "bg": "0.9830480887609585",
      "zh": "0.9831646847946259",
      "fr": "0.9972247363161806",
      "de": "0.9782936719605074",
      "ha": "0.984895748565345",
      "hi": "0.9840944736082503",
      "hu": "0.9923000932791826"
    }
  },
  {
    "task_id": "C#/21",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Determines if a sequence has \"Jolly Jumps\" where the absolute differences between adjacent elements, \n   when sorted, form a continuous sequence from 1 to (length of sequence - 1).\n   A sequence with a single element is always considered jolly.\n   \n        Examples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Përcakton nëse një sekuencë ka \"Jolly Jumps\" ku diferencat absolute midis elementeve ngjitur, \n   kur renditen, formojnë një sekuencë të vazhdueshme nga 1 deri te (gjatësia e sekuencës - 1).\n   Një sekuencë me një element të vetëm gjithmonë konsiderohet jolly.\n   \n        Shembuj:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Սահմանում է՝ արդյոք հաջորդականությունն ունի \"Jolly Jumps\", որտեղ հարևան տարրերի միջև բացարձակ տարբերությունները,\n   երբ դասավորված են, ձևավորում են շարունակական հաջորդականություն 1-ից մինչև (հաջորդականության երկարություն - 1):\n   Միայն մեկ տարր ունեցող հաջորդականությունը միշտ համարվում է jolly:\n   \n        Օրինակներ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* নির্ধারণ করে যে একটি ক্রমে \"Jolly Jumps\" আছে কিনা যেখানে সন্নিহিত উপাদানগুলির মধ্যে পার্থক্যের মান, \n   যখন সাজানো হয়, তখন একটি ধারাবাহিক ক্রম গঠন করে 1 থেকে (ক্রমের দৈর্ঘ্য - 1) পর্যন্ত।\n   একটি একক উপাদানযুক্ত ক্রম সর্বদা জলি হিসাবে বিবেচিত হয়।\n   \n        উদাহরণ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Определя дали една последователност има \"Jolly Jumps\", където абсолютните разлики между съседни елементи, \n   когато са сортирани, образуват непрекъсната последователност от 1 до (дължината на последователността - 1).\n   Последователност с един елемент винаги се счита за jolly.\n   \n        Примери:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 确定一个序列是否具有“Jolly Jumps”，即相邻元素之间的绝对差值在排序后形成一个从1到（序列长度-1）的连续序列。\n   只有一个元素的序列始终被认为是jolly。\n   \n        示例:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Détermine si une séquence a des \"Jolly Jumps\" où les différences absolues entre les éléments adjacents, \n   une fois triées, forment une séquence continue de 1 à (longueur de la séquence - 1).\n   Une séquence avec un seul élément est toujours considérée comme joyeuse.\n   \n        Exemples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bestimmt, ob eine Sequenz \"Jolly Jumps\" hat, bei denen die absoluten Differenzen zwischen benachbarten Elementen,\n   wenn sie sortiert sind, eine kontinuierliche Sequenz von 1 bis (Länge der Sequenz - 1) bilden.\n   Eine Sequenz mit einem einzigen Element wird immer als jolly angesehen.\n   \n        Beispiele:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Yana tantance idan jerin yana da \"Jolly Jumps\" inda bambance-bambancen darajoji tsakanin abubuwa masu makwabtaka, \n   idan an jera su, suna samar da jerin ci gaba daga 1 zuwa (tsawon jerin - 1).\n   Ana daukar jerin da ke da abu guda daya a koyaushe a matsayin jolly.\n   \n        Misalai:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह निर्धारित करता है कि क्या एक अनुक्रम में \"Jolly Jumps\" हैं जहाँ आसन्न तत्वों के बीच के पूर्ण अंतर, \n   जब क्रमबद्ध होते हैं, तो 1 से (अनुक्रम की लंबाई - 1) तक एक सतत अनुक्रम बनाते हैं।\n   एकल तत्व वाला अनुक्रम हमेशा जॉली माना जाता है।\n   \n        उदाहरण:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Meghatározza, hogy egy sorozat \"Jolly Jumps\"-t tartalmaz-e, ahol a szomszédos elemek közötti abszolút különbségek, \n   ha sorba rendezzük, egy folytonos sorozatot alkotnak 1-től (a sorozat hossza - 1)-ig.\n   Egyetlen elemet tartalmazó sorozat mindig jolly-nak tekintendő.\n   \n        Példák:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)"
    },
    "prompt_bertscore": {
      "sq": "0.9971462773156717",
      "hy": "0.9859407429999696",
      "bn": "0.9863099968783134",
      "bg": "0.9912219275709252",
      "zh": "0.9672776310283125",
      "fr": "0.994898575923881",
      "de": "0.9947581442444893",
      "ha": "0.9843131656577697",
      "hi": "0.9962055638310905",
      "hu": "0.9851325159795387"
    },
    "canonical_solution": "{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }",
    "instruction": {
      "en": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nՏրամադրել C# կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.948868567313999",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9062111039437085",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(IsSequenceJolly(new int[] {1, 4, 2, 3}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {1, 3}) == \"Not Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {5}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {10, 7, 8, 9}) == \"Not Jolly\");\n\n    }\n}",
    "entry_point": "IsSequenceJolly",
    "signature": "static string IsSequenceJolly(int[] sequence)",
    "docstring": {
      "en": "Determines if a sequence has \"Jolly Jumps\" where the absolute differences between adjacent elements, \n   when sorted, form a continuous sequence from 1 to (length of sequence - 1).\n   A sequence with a single element is always considered jolly.\n   \n        Examples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "sq": "Përcakton nëse një sekuencë ka \"Jolly Jumps\" ku diferencat absolute midis elementeve ngjitur, kur renditen, formojnë një sekuencë të vazhdueshme nga 1 deri te (gjatësia e sekuencës - 1). Një sekuencë me një element të vetëm gjithmonë konsiderohet jolly.\n\n        Shembuj:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hy": "Վճռում է՝ արդյոք հաջորդականությունը ունի \"Jolly Jumps\", որտեղ հարևան տարրերի միջև բացարձակ տարբերությունները, \n   երբ դասավորված են, կազմում են շարունակական հաջորդականություն 1-ից մինչև (հաջորդականության երկարություն - 1):\n   Միայն մեկ տարր ունեցող հաջորդականությունը միշտ համարվում է jolly:\n   \n        Օրինակներ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "bn": "একটি সিকোয়েন্সে \"Jolly Jumps\" আছে কিনা তা নির্ধারণ করে যেখানে সংলগ্ন উপাদানগুলির মধ্যে পার্থক্যের মানগুলি, \n   সাজানো হলে, 1 থেকে (সিকোয়েন্সের দৈর্ঘ্য - 1) পর্যন্ত একটি ধারাবাহিক সিকোয়েন্স গঠন করে।\n   একটি একক উপাদানযুক্ত সিকোয়েন্স সর্বদা জলি হিসাবে বিবেচিত হয়।\n   \n        উদাহরণসমূহ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "bg": "Определя дали една последователност има \"Jolly Jumps\", където абсолютните разлики между съседни елементи, когато са сортирани, образуват непрекъсната последователност от 1 до (дължина на последователността - 1). Последователност с един елемент винаги се счита за jolly.\n\n        Примери:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "zh": "确定一个序列是否具有“Jolly Jumps”，即相邻元素之间的绝对差值在排序后形成从1到（序列长度-1）的连续序列。\n   只有一个元素的序列总是被认为是jolly。\n\n        示例：\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "fr": "Détermine si une séquence a des \"Jolly Jumps\" où les différences absolues entre les éléments adjacents, \nlorsqu'elles sont triées, forment une séquence continue de 1 à (longueur de la séquence - 1).\nUne séquence avec un seul élément est toujours considérée comme jolly.\n\n        Exemples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "de": "Bestimmt, ob eine Sequenz \"Jolly Jumps\" hat, bei denen die absoluten Unterschiede zwischen benachbarten Elementen, \n   wenn sortiert, eine kontinuierliche Sequenz von 1 bis (Länge der Sequenz - 1) bilden.\n   Eine Sequenz mit einem einzigen Element wird immer als jolly betrachtet.\n   \n        Beispiele:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "ha": "Yana tantance idan jerin yana da \"Jolly Jumps\" inda bambance-bambancen ƙima tsakanin abubuwan da ke kusa, \n   idan aka jera su, suna samar da jerin ci gaba daga 1 zuwa (tsawon jerin - 1).\n   Jerin da ke da abu guda ɗaya koyaushe ana ɗauka jolly ne.\n   \n        Misalai:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hi": "निर्धारित करता है कि क्या एक अनुक्रम में \"Jolly Jumps\" हैं, जहाँ आसन्न तत्वों के बीच के परिमाणात्मक अंतर, जब क्रमबद्ध होते हैं, तो 1 से (अनुक्रम की लंबाई - 1) तक एक निरंतर अनुक्रम बनाते हैं। \n   एकल तत्व वाला अनुक्रम हमेशा जॉली माना जाता है।\n\n        उदाहरण:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hu": "Megállapítja, hogy egy sorozat \"Jolly Jumps\"-t tartalmaz-e, ahol a szomszédos elemek közötti abszolút különbségek, \n   ha rendezve vannak, egy folytonos sorozatot alkotnak 1-től (a sorozat hossza - 1)-ig.\n   Egyetlen elemből álló sorozat mindig jolly-nak tekintendő.\n   \n        Példák:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\""
    },
    "docstring_bertscore": {
      "sq": "0.9887438149371339",
      "hy": "0.9877683411358715",
      "bn": "0.9848095429799759",
      "bg": "0.9901115837409402",
      "zh": "0.9689695646139677",
      "fr": "0.9905418171462618",
      "de": "0.9935083618870177",
      "ha": "0.9770266087598859",
      "hi": "0.9893732746146335",
      "hu": "0.9762449982105136"
    }
  },
  {
    "task_id": "C#/22",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Determines the winner in a game of Rock-Paper-Scissors played for a number of rounds.\n    Players A and B have their own repeating patterns of moves.\n    Rock (represented by 0) beats Scissors (2), Scissors beat Paper (5), and Paper beats Rock.\n    If both players choose the same move, the round is a draw.\n\n    Examples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Përcakton fituesin në një lojë të Guri-Letra-Gërshërë e luajtur për një numër raundesh.\n    Lojtarët A dhe B kanë modelet e tyre të përsëritura të lëvizjeve.\n    Guri (përfaqësuar nga 0) mund Gërshërët (2), Gërshërët mundin Letrën (5), dhe Letra mund Gur.\n    Nëse të dy lojtarët zgjedhin të njëjtën lëvizje, raundi është barazim.\n\n    Shembuj:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Որոշում է հաղթողին Քար-Մկրատ-Թուղթ խաղում, որը խաղացվում է մի քանի ռաունդների համար:\n    Խաղացողներ A-ն և B-ն ունեն իրենց կրկնվող քայլերի նախշերը:\n    Քարը (ներկայացված է 0-ով) հաղթում է Մկրատին (2), Մկրատը հաղթում է Թղթին (5), իսկ Թուղթը հաղթում է Քարին:\n    Եթե երկու խաղացողներն էլ ընտրում են նույն քայլը, ռաունդը ոչ-ոքի է ավարտվում:\n\n    Օրինակներ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* একটি নির্দিষ্ট সংখ্যক রাউন্ডের জন্য খেলা হওয়া রক-পেপার-সিজর্স গেমে বিজয়ী নির্ধারণ করে।\n    খেলোয়াড় A এবং B তাদের নিজস্ব পুনরাবৃত্তি করা চালের প্যাটার্ন আছে।\n    রক (0 দ্বারা প্রতিনিধিত্ব করা) সিজর্স (2) কে হারায়, সিজর্স পেপার (5) কে হারায়, এবং পেপার রক কে হারায়।\n    যদি উভয় খেলোয়াড় একই চাল নির্বাচন করে, তাহলে রাউন্ডটি ড্র হয়।\n\n    উদাহরণ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Определя победителя в игра на Камък-Ножица-Хартия, играна за определен брой рундове.\n    Играчите A и B имат свои собствени повтарящи се модели на ходове.\n    Камък (представен от 0) побеждава Ножица (2), Ножица побеждава Хартия (5), а Хартия побеждава Камък.\n    Ако и двамата играчи изберат един и същ ход, рундът е равен.\n\n    Примери:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* 确定在进行若干轮的石头剪刀布游戏中的赢家。\n    玩家 A 和 B 有各自重复的出招模式。\n    石头（用 0 表示）胜剪刀（2），剪刀胜布（5），布胜石头。\n    如果两位玩家选择相同的出招，则该轮为平局。\n\n    示例:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Détermine le gagnant dans un jeu de Pierre-Papier-Ciseaux joué sur un certain nombre de manches.\n    Les joueurs A et B ont leurs propres motifs répétitifs de mouvements.\n    Pierre (représentée par 0) bat Ciseaux (2), Ciseaux battent Papier (5), et Papier bat Pierre.\n    Si les deux joueurs choisissent le même mouvement, la manche est un match nul.\n\n    Exemples :\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Bestimmt den Gewinner in einem Spiel von Schere-Stein-Papier, das über eine Anzahl von Runden gespielt wird.\n    Spieler A und B haben ihre eigenen sich wiederholenden Muster von Zügen.\n    Stein (dargestellt durch 0) schlägt Schere (2), Schere schlägt Papier (5), und Papier schlägt Stein.\n    Wenn beide Spieler denselben Zug wählen, ist die Runde ein Unentschieden.\n\n    Beispiele:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Yana tantance wanda ya yi nasara a wasan Rock-Paper-Scissors da aka buga na tsawon zagaye da dama.\n    'Yan wasa A da B suna da nasu maimaita tsarin motsi.\n    Rock (wakilta ta 0) yana doke Scissors (2), Scissors suna doke Paper (5), kuma Paper yana doke Rock.\n    Idan duka 'yan wasan sun zaɓi motsi iri ɗaya, zagayen ya zama kunnen doki.\n\n    Misalai:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* चट्टान-कागज-कैंची के खेल में विजेता का निर्धारण करता है, जो कई राउंड के लिए खेला जाता है।\n    खिलाड़ियों A और B के पास अपनी खुद की चालों के दोहराने वाले पैटर्न होते हैं।\n    चट्टान (0 द्वारा दर्शाया गया) कैंची (2) को हराता है, कैंची कागज (5) को हराती है, और कागज चट्टान को हराता है।\n    यदि दोनों खिलाड़ी एक ही चाल चुनते हैं, तो राउंड ड्रॉ होता है।\n\n    उदाहरण:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Meghatározza a győztest egy Kő-Papír-Olló játékban, amelyet több fordulón keresztül játszanak.\n    A és B játékosoknak saját ismétlődő mozdulatsorozataik vannak.\n    A kő (0-val jelölve) üti az ollót (2), az olló üti a papírt (5), és a papír üti a követ.\n    Ha mindkét játékos ugyanazt a mozdulatot választja, a forduló döntetlen.\n\n    Példák:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"döntetlen\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9742964341725613",
      "bn": "0.975911100539994",
      "bg": "0.9957473235420431",
      "zh": "0.9706044912802658",
      "fr": "0.9943136094517332",
      "de": "0.9978013603123248",
      "ha": "0.9790472756261538",
      "hi": "0.9920216134849716",
      "hu": "0.9832349999495124"
    },
    "canonical_solution": "    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }",
    "instruction": {
      "en": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nՏվեք C# կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\n请用最多500个字符的中文，为以下C#代码提供简明的自然语言描述（文档字符串）。",
      "fr": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar C# a Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568463579378843",
      "hy": "0.9287852481179426",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8818071766993811",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(5, new List<int> {0, 0, 0}, new List<int> {2, 2, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2}) == \"draw\");\n    }\n}",
    "entry_point": "DetermineWinner",
    "signature": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
    "docstring": {
      "en": "Determines the winner in a game of Rock-Paper-Scissors played for a number of rounds.\n    Players A and B have their own repeating patterns of moves.\n    Rock (represented by 0) beats Scissors (2), Scissors beat Paper (5), and Paper beats Rock.\n    If both players choose the same move, the round is a draw.\n\n    Examples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "sq": "Përcakton fituesin në një lojë të Guri-Letër-Gërshërë luajtur për një numër raundesh.\n    Lojtarët A dhe B kanë modelet e tyre të përsëritura të lëvizjeve.\n    Guri (përfaqësuar nga 0) mund Gërshërët (2), Gërshërët mundin Letër (5), dhe Letra mund Gur.\n    Nëse të dy lojtarët zgjedhin të njëjtën lëvizje, raundi është barazim.\n\n    Shembuj:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"barazim\"",
      "hy": "Վճռում է հաղթողին Քար-Թուղթ-Մկրատ խաղում, որը խաղացվում է մի քանի ռաունդ:\n    Խաղացողներ A-ն և B-ն ունեն իրենց կրկնվող քայլերի օրինակները:\n    Քարը (ներկայացված է 0-ով) հաղթում է Մկրատին (2), Մկրատը հաղթում է Թղթին (5), և Թուղթը հաղթում է Քարին:\n    Եթե երկու խաղացողներն էլ ընտրում են նույն քայլը, ռաունդը ոչ-ոքի է:\n\n    Օրինակներ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "bn": "খেলাটি কতগুলো রাউন্ডে খেলা হবে তা নির্ধারণ করে রক-পেপার-সিজর্সের বিজয়ী নির্ধারণ করে।\n    খেলোয়াড় A এবং B তাদের নিজস্ব পুনরাবৃত্ত প্যাটার্নে চাল চালায়।\n    রক (০ দ্বারা প্রতিনিধিত্ব করা) সিজর্স (২) কে হারায়, সিজর্স পেপার (৫) কে হারায়, এবং পেপার রককে হারায়।\n    যদি উভয় খেলোয়াড় একই চাল নির্বাচন করে, তাহলে রাউন্ডটি ড্র হয়।\n\n    উদাহরণ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "bg": "Определя победителя в игра на Камък-Ножица-Хартия, играна за определен брой рундове.\nИграчите A и B имат свои собствени повтарящи се модели на ходове.\nКамък (представен с 0) побеждава Ножица (2), Ножица побеждава Хартия (5), а Хартия побеждава Камък.\nАко и двамата играчи изберат един и същи ход, рундът е равен.\n\nПримери:\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\"",
      "zh": "确定石头剪刀布游戏中多轮比赛的获胜者。\n玩家A和B有各自重复的出招模式。\n石头（用0表示）胜剪刀（2），剪刀胜布（5），布胜石头。\n如果两位玩家选择相同的出招，该轮比赛为平局。\n\n示例：\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\"",
      "fr": "Détermine le gagnant dans un jeu de Pierre-Papier-Ciseaux joué sur un certain nombre de manches.\n    Les joueurs A et B ont leurs propres motifs répétitifs de mouvements.\n    Pierre (représentée par 0) bat Ciseaux (2), Ciseaux battent Papier (5), et Papier bat Pierre.\n    Si les deux joueurs choisissent le même mouvement, la manche est un match nul.\n\n    Exemples :\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "de": "Bestimmt den Gewinner in einem Spiel von Schere-Stein-Papier, das über eine Anzahl von Runden gespielt wird.\n    Spieler A und B haben ihre eigenen sich wiederholenden Muster von Zügen.\n    Stein (dargestellt durch 0) schlägt Schere (2), Schere schlägt Papier (5), und Papier schlägt Stein.\n    Wenn beide Spieler denselben Zug wählen, ist die Runde ein Unentschieden.\n\n    Beispiele:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "ha": "Yana tantance wanda ya yi nasara a wasan Rock-Paper-Scissors da aka buga na tsawon wasu zagaye.\n    'Yan wasa A da B suna da nasu tsarin motsi da suke maimaitawa.\n    Rock (wanda aka wakilta da 0) yana doke Scissors (2), Scissors suna doke Paper (5), kuma Paper yana doke Rock.\n    Idan duka 'yan wasan suka zaɓi motsi ɗaya, zagayen ya zama kunnen doki.\n\n    Misalai:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "hi": "कई राउंड के लिए खेले गए रॉक-पेपर-सीज़र के खेल में विजेता का निर्धारण करता है।\n    खिलाड़ी A और B के पास अपनी खुद की दोहराने वाली चालों के पैटर्न होते हैं।\n    रॉक (0 द्वारा दर्शाया गया) कैंची (2) को हराता है, कैंची कागज (5) को हराती है, और कागज रॉक को हराता है।\n    यदि दोनों खिलाड़ी एक ही चाल चुनते हैं, तो राउंड ड्रॉ होता है।\n\n    उदाहरण:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "hu": "Meghatározza a győztest egy Kő-Papír-Olló játékban, amelyet több fordulón keresztül játszanak.\n    A és B játékosoknak saját ismétlődő mozgásmintáik vannak.\n    A Kő (0-val jelölve) veri az Ollót (2), az Olló veri a Papírt (5), és a Papír veri a Követ.\n    Ha mindkét játékos ugyanazt a lépést választja, a forduló döntetlen.\n\n    Példák:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"döntetlen\""
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9734421249037303",
      "bn": "0.8814327584311304",
      "bg": "0.9946892195022702",
      "zh": "0.962663248646491",
      "fr": "0.9840428297091812",
      "de": "0.9975266544953536",
      "ha": "0.9736618101051548",
      "hi": "0.957755091931119",
      "hu": "0.9767191289300439"
    }
  },
  {
    "task_id": "C#/23",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Calculate the dot product of two n-dimensional integer vectors.\n    The dot product is the sum of the products of the corresponding elements of the two vectors.\n\n    Example 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Example 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Llogarit prodhimin skalar të dy vektorëve të plotë n-dimensionalë.\n    Prodhimi skalar është shuma e produkteve të elementeve përkatëse të dy vektorëve.\n\n    Shembull 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Shembull 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Հաշվարկել երկու n-չափանի ամբողջ թվերի վեկտորների կետային արտադրյալը:\n    Կետային արտադրյալը երկու վեկտորների համապատասխան տարրերի արտադրյալների գումարն է:\n\n    Օրինակ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Օրինակ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    দুটি n-মাত্রিক পূর্ণসংখ্যার ভেক্টরের ডট গুণফল গণনা করুন।\n    ডট গুণফল হল দুটি ভেক্টরের সংশ্লিষ্ট উপাদানগুলির গুণফলের যোগফল।\n\n    উদাহরণ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    উদাহরণ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Изчислете скаларното произведение на два n-мерни векторa от цели числа.\n    Скаларното произведение е сумата от произведенията на съответстващите елементи на двата вектора.\n\n    Пример 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Пример 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    计算两个n维整数向量的点积。\n    点积是两个向量对应元素乘积的和。\n\n    示例 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    示例 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Calculer le produit scalaire de deux vecteurs entiers n-dimensionnels.\n    Le produit scalaire est la somme des produits des éléments correspondants des deux vecteurs.\n\n    Exemple 1 :\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Exemple 2 :\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Berechne das Skalarprodukt von zwei n-dimensionalen Ganzzahlvektoren.\n    Das Skalarprodukt ist die Summe der Produkte der entsprechenden Elemente der beiden Vektoren.\n\n    Beispiel 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Beispiel 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Lissafin samfurin dot na n-dimensional vectors na integers guda biyu.\n    Samfurin dot shine jumlar samfuran abubuwan da suka dace na vectors guda biyu.\n\n    Misali 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Misali 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    दो n-आयामी पूर्णांक वेक्टरों का डॉट उत्पाद गणना करें।\n    डॉट उत्पाद दो वेक्टरों के संगत तत्वों के उत्पादों का योग है।\n\n    उदाहरण 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    उदाहरण 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Két n-dimenziós egész szám vektor skaláris szorzatának kiszámítása.\n    A skaláris szorzat a két vektor megfelelő elemeinek szorzatainak összege.\n\n    1. példa:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    2. példa:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "0.9953995217448509",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9876042724411368",
      "hi": "1",
      "hu": "0.9808264079490833"
    },
    "canonical_solution": "{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}",
    "instruction": {
      "en": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nՏրամադրել C# կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 символа.",
      "zh": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nBa da taƙaitaccen bayanin yare na halitta (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9081658255234729",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9543420260937965",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1}) == 3);\n        Debug.Assert(CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8}) == 92);\n        Debug.Assert(CalculateDotProduct(new List<int> {0, 0, 0}, new List<int> {0, 0, 0}) == 0);\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 2}, new List<int> {3, 4}) == 11);\n\n    }\n}",
    "entry_point": "CalculateDotProduct",
    "signature": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
    "docstring": {
      "en": "Calculate the dot product of two n-dimensional integer vectors.\n    The dot product is the sum of the products of the corresponding elements of the two vectors.\n\n    Example 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Example 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "sq": "Llogarit produktin skalar të dy vektorëve të plotë n-dimensionalë.\n    Produkti skalar është shuma e produkteve të elementeve përkatëse të dy vektorëve.\n\n    Shembull 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Shembull 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hy": "Հաշվարկել երկու n-չափանի ամբողջ թվերի վեկտորների կետային արտադրյալը։  \nԿետային արտադրյալը երկու վեկտորների համապատասխան տարրերի արտադրյալների գումարն է։\n\nՕրինակ 1:\n>>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n3\n\nՕրինակ 2:\n>>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n100",
      "bn": "দুইটি n-মাত্রিক পূর্ণসংখ্যা ভেক্টরের ডট গুণফল গণনা করুন। ডট গুণফল হল দুই ভেক্টরের সংশ্লিষ্ট উপাদানগুলির গুণফলের যোগফল।\n\n    উদাহরণ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    উদাহরণ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "bg": "Изчислете скаларното произведение на два n-мерни вектора от цели числа.  \n    Скаларното произведение е сумата от произведенията на съответстващите елементи на двата вектора.\n\n    Пример 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Пример 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "zh": "计算两个n维整数向量的点积。\n    点积是两个向量对应元素的乘积之和。\n\n    示例 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    示例 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "fr": "Calculer le produit scalaire de deux vecteurs entiers n-dimensionnels.  \n    Le produit scalaire est la somme des produits des éléments correspondants des deux vecteurs.\n\n    Exemple 1 :\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Exemple 2 :\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "de": "Berechne das Skalarprodukt von zwei n-dimensionalen Ganzzahlvektoren.\n    Das Skalarprodukt ist die Summe der Produkte der entsprechenden Elemente der beiden Vektoren.\n\n    Beispiel 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Beispiel 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "ha": "Ƙididdige samfurin dot na n-dimensional vectors na integer guda biyu.  \n    Samfurin dot shine jumlar samfuran abubuwan da suka dace na vectors guda biyu.\n\n    Misali 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Misali 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hi": "दो n-आयामी पूर्णांक वेक्टरों का डॉट गुणनफल गणना करें। \n    डॉट गुणनफल दो वेक्टरों के संगत तत्वों के गुणनफल के योग के बराबर होता है।\n\n    उदाहरण 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    उदाहरण 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hu": "Számítsa ki két n-dimenziós egész szám vektor skaláris szorzatát.  \n    A skaláris szorzat a két vektor megfelelő elemeinek szorzatainak összege.\n\n    Példa 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Példa 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9663458559108778",
      "bg": "0.9679207962021035",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.9892799183355471",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/24",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Calculate the value of 2 raised to the power of a given non-negative integer 'n'.\n    This function uses high-precision arithmetic to handle large exponents.\n    Examples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Llogarit vlerën e 2 të ngritur në fuqinë e një numri të plotë jo-negativ 'n'.\n    Kjo funksion përdor aritmetikë me precizion të lartë për të trajtuar eksponentët e mëdhenj.\n    Shembuj:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Հաշվարկել 2-ի արժեքը, բարձրացված տրված ոչ բացասական ամբողջ թիվ 'n'-ի աստիճանի:\n    Այս ֆունկցիան օգտագործում է բարձր ճշգրտության թվաբանություն մեծ աստիճանները մշակելու համար:\n    Օրինակներ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* একটি প্রদত্ত অ-ঋণাত্মক পূর্ণসংখ্যা 'n' এর জন্য 2 এর ঘাতমূলের মান গণনা করুন।\n    এই ফাংশনটি বড় ঘাতগুলির জন্য উচ্চ-নির্ভুলতার গাণিতিক ব্যবহার করে।\n    উদাহরণ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Изчислете стойността на 2, повдигната на степен дадено неотрицателно цяло число 'n'.\n    Тази функция използва аритметика с висока точност за обработка на големи експоненти.\n    Примери:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* 计算2的给定非负整数'n'次幂的值。\n    此函数使用高精度算术来处理大指数。\n    示例:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Calculer la valeur de 2 élevé à la puissance d'un entier non négatif 'n' donné.\n    Cette fonction utilise l'arithmétique de haute précision pour gérer les grands exposants.\n    Exemples :\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Berechne den Wert von 2 hoch einer gegebenen nicht-negativen Ganzzahl 'n'.\n    Diese Funktion verwendet Hochpräzisionsarithmetik, um große Exponenten zu verarbeiten.\n    Beispiele:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Lissafa darajar 2 da aka ɗaga zuwa ƙarfin wani cikakken lamba mara kyau 'n'.\n    Wannan aikin yana amfani da lissafi mai daidaito mai girma don sarrafa manyan masu nuni.\n    Misalai:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* दिए गए गैर-ऋणात्मक पूर्णांक 'n' के घात में 2 की शक्ति की गणना करें।\n    यह फ़ंक्शन बड़े घातांकों को संभालने के लिए उच्च-सटीक अंकगणित का उपयोग करता है।\n    उदाहरण:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Számítsa ki a 2 értékét egy adott nem negatív egész szám 'n' hatványára emelve.\n    Ez a függvény nagy pontosságú aritmetikát használ a nagy kitevők kezelésére.\n    Példák:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.993435464537178",
      "hy": "0.9974311132820758",
      "bn": "0.9641335107269112",
      "bg": "1",
      "zh": "0.9961030705544766",
      "fr": "1",
      "de": "0.9891504113271123",
      "ha": "1",
      "hi": "0.9774904106996023",
      "hu": "1"
    },
    "canonical_solution": "    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }",
    "instruction": {
      "en": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nՏվեք C# կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nনিচে দেওয়া C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 символа.",
      "zh": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9287852481179426",
      "bn": "0.8695183122855147",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9388230344235406",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {           \n        Debug.Assert(CalculatePowerOfTwo(3).Equals(new BigInteger(8)));\n        Debug.Assert(CalculatePowerOfTwo(10).Equals(new BigInteger(1024)));\n        Debug.Assert(CalculatePowerOfTwo(15).Equals(new BigInteger(32768)));\n        Debug.Assert(CalculatePowerOfTwo(0).Equals(new BigInteger(1)));\n\n    }\n}\n",
    "entry_point": "CalculatePowerOfTwo",
    "signature": "static BigInteger CalculatePowerOfTwo(int n)",
    "docstring": {
      "en": "Calculate the value of 2 raised to the power of a given non-negative integer 'n'.\n    This function uses high-precision arithmetic to handle large exponents.\n    Examples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "sq": "Llogarit vlerën e 2 të ngritur në fuqinë e një numri të dhënë të plotë jo-negativ 'n'.\n    Kjo funksion përdor aritmetikë me precizion të lartë për të trajtuar eksponentë të mëdhenj.\n    Shembuj:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "hy": "Հաշվարկել 2-ի արժեքը բարձրացված տրված ոչ բացասական ամբողջ թիվ 'n'-ի աստիճանի:\n    Այս ֆունկցիան օգտագործում է բարձր ճշգրտության թվաբանություն մեծ աստիճաններ մշակելու համար:\n    Օրինակներ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "bn": "একটি প্রদত্ত অ-ঋণাত্মক পূর্ণসংখ্যা 'n' এর জন্য 2 এর ঘাতমূলের মান গণনা করুন।\n    এই ফাংশনটি বড় সূচকগুলি পরিচালনা করার জন্য উচ্চ-নির্ভুলতা গাণিতিক ব্যবহার করে।\n    উদাহরণসমূহ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "bg": "Изчислява стойността на 2, повдигнато на степен дадено неотрицателно цяло число 'n'.\n    Тази функция използва аритметика с висока точност, за да обработва големи експоненти.\n    Примери:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "zh": "计算 2 的值，幂为给定的非负整数 'n'。\n    此函数使用高精度算术来处理大指数。\n    示例：\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "fr": "Calculer la valeur de 2 élevé à la puissance d'un entier non négatif 'n'.\n    Cette fonction utilise l'arithmétique de haute précision pour gérer les grands exposants.\n    Exemples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "de": "Berechnen Sie den Wert von 2 hoch einer gegebenen nicht-negativen ganzen Zahl 'n'.\n    Diese Funktion verwendet Hochpräzisionsarithmetik, um große Exponenten zu verarbeiten.\n    Beispiele:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "ha": "Ƙididdige ƙimar 2 da aka ɗaga zuwa ikon wani baƙi mai kyau 'n' da aka bayar.\n    Wannan aikin yana amfani da lissafin daidai don sarrafa manyan masu ƙarfi.\n    Misalai:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "hi": "एक दिए गए गैर-ऋणात्मक पूर्णांक 'n' की शक्ति के लिए 2 का मान गणना करें।\n    यह फ़ंक्शन बड़े घातांक को संभालने के लिए उच्च-सटीक अंकगणित का उपयोग करता है।  \n    उदाहरण:  \n    >>> CalculatePowerOfTwo(3)  \n    8  \n    >>> CalculatePowerOfTwo(10)  \n    1024  \n    >>> CalculatePowerOfTwo(0)  \n    1",
      "hu": "Számítsa ki a 2 értékét egy adott nem negatív egész 'n' hatványára emelve.\n    Ez a függvény nagy pontosságú aritmetikát használ a nagy kitevők kezelésére.\n    Példák:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9923292919451947",
      "hy": "1",
      "bn": "1",
      "bg": "0.9969891606842731",
      "zh": "0.9976281546200624",
      "fr": "0.9912008727505355",
      "de": "0.9857687290899934",
      "ha": "0.9595449502946243",
      "hi": "0.9976281546200624",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/25",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds the first character in a string that appears only once.\n   If all characters appear more than once or the string is empty, it returns 'no' as a character.\n   Examples:\n   - FirstUniqueChar(\"aabbcdde\") should return 'c'.\n   - FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".\n   - FirstUniqueChar(\"xxyyzz\") should return 'n'.\n   - FirstUniqueChar(\"\") should return 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Gjen karakterin e parë në një varg që shfaqet vetëm një herë.\n   Nëse të gjithë karakteret shfaqen më shumë se një herë ose vargu është bosh, kthen 'n' si karakter.\n   Shembuj:\n   - FirstUniqueChar(\"aabbcdde\") duhet të kthejë 'c'.\n   - FirstUniqueChar(\"aabbcc\") duhet të kthejë 'n', që përfaqëson \"jo\".\n   - FirstUniqueChar(\"xxyyzz\") duhet të kthejë 'n'.\n   - FirstUniqueChar(\"\") duhet të kthejë 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Գտնում է տողում առաջին սիմվոլը, որը հանդիպում է միայն մեկ անգամ։\n   Եթե բոլոր սիմվոլները հանդիպում են մեկից ավելի անգամ կամ տողը դատարկ է, վերադարձնում է 'no' որպես սիմվոլ։\n   Օրինակներ:\n   - FirstUniqueChar(\"aabbcdde\") պետք է վերադարձնի 'c'։\n   - FirstUniqueChar(\"aabbcc\") պետք է վերադարձնի 'n', որը ներկայացնում է \"ոչ\"։\n   - FirstUniqueChar(\"xxyyzz\") պետք է վերադարձնի 'n'։\n   - FirstUniqueChar(\"\") պետք է վերադարձնի 'n'։\n*/\n    static char FirstUniqueChar(string str)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি স্ট্রিং-এ প্রথম যে অক্ষরটি কেবল একবারই উপস্থিত হয় তা খুঁজে বের করে।\n   যদি সব অক্ষর একাধিকবার উপস্থিত হয় বা স্ট্রিংটি খালি হয়, তাহলে এটি একটি অক্ষর হিসেবে 'no' ফেরত দেয়।\n   উদাহরণ:\n   - FirstUniqueChar(\"aabbcdde\") 'c' ফেরত দেবে।\n   - FirstUniqueChar(\"aabbcc\") 'n' ফেরত দেবে, যা \"no\" নির্দেশ করে।\n   - FirstUniqueChar(\"xxyyzz\") 'n' ফেরত দেবে।\n   - FirstUniqueChar(\"\") 'n' ফেরত দেবে।\n*/\n    static char FirstUniqueChar(string str)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Намира първия символ в низ, който се появява само веднъж.\n   Ако всички символи се появяват повече от веднъж или низът е празен, връща 'n' като символ.\n   Примери:\n   - FirstUniqueChar(\"aabbcdde\") трябва да върне 'c'.\n   - FirstUniqueChar(\"aabbcc\") трябва да върне 'n', представляващо \"не\".\n   - FirstUniqueChar(\"xxyyzz\") трябва да върне 'n'.\n   - FirstUniqueChar(\"\") трябва да върне 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 查找字符串中仅出现一次的第一个字符。\n   如果所有字符出现多次或字符串为空，则返回字符 'n'，表示“无”。\n   示例：\n   - FirstUniqueChar(\"aabbcdde\") 应返回 'c'。\n   - FirstUniqueChar(\"aabbcc\") 应返回 'n'，表示“无”。\n   - FirstUniqueChar(\"xxyyzz\") 应返回 'n'。\n   - FirstUniqueChar(\"\") 应返回 'n'。\n*/\n    static char FirstUniqueChar(string str)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Trouve le premier caractère dans une chaîne qui apparaît une seule fois.\n   Si tous les caractères apparaissent plus d'une fois ou si la chaîne est vide, il retourne 'n' comme caractère.\n   Exemples :\n   - FirstUniqueChar(\"aabbcdde\") devrait retourner 'c'.\n   - FirstUniqueChar(\"aabbcc\") devrait retourner 'n', représentant \"non\".\n   - FirstUniqueChar(\"xxyyzz\") devrait retourner 'n'.\n   - FirstUniqueChar(\"\") devrait retourner 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Findet das erste Zeichen in einem String, das nur einmal vorkommt.\n   Wenn alle Zeichen mehr als einmal vorkommen oder der String leer ist, gibt es 'n' als Zeichen zurück.\n   Beispiele:\n   - FirstUniqueChar(\"aabbcdde\") sollte 'c' zurückgeben.\n   - FirstUniqueChar(\"aabbcc\") sollte 'n' zurückgeben, was \"nein\" repräsentiert.\n   - FirstUniqueChar(\"xxyyzz\") sollte 'n' zurückgeben.\n   - FirstUniqueChar(\"\") sollte 'n' zurückgeben.\n*/\n    static char FirstUniqueChar(string str)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Nemi harafin farko a cikin kirtani wanda ya bayyana sau ɗaya kawai.\n   Idan duk haruffa sun bayyana fiye da sau ɗaya ko kuma kirtanin babu komai, zai dawo da 'no' a matsayin harafi.\n   Misalai:\n   - FirstUniqueChar(\"aabbcdde\") yakamata ya dawo da 'c'.\n   - FirstUniqueChar(\"aabbcc\") yakamata ya dawo da 'n', yana wakiltar \"no\".\n   - FirstUniqueChar(\"xxyyzz\") yakamata ya dawo da 'n'.\n   - FirstUniqueChar(\"\") yakamata ya dawo da 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* एक स्ट्रिंग में पहला ऐसा वर्ण खोजता है जो केवल एक बार आता है।\n   यदि सभी वर्ण एक से अधिक बार आते हैं या स्ट्रिंग खाली है, तो यह 'no' के रूप में एक वर्ण लौटाता है।\n   उदाहरण:\n   - FirstUniqueChar(\"aabbcdde\") को 'c' लौटाना चाहिए।\n   - FirstUniqueChar(\"aabbcc\") को 'n' लौटाना चाहिए, जो \"no\" का प्रतिनिधित्व करता है।\n   - FirstUniqueChar(\"xxyyzz\") को 'n' लौटाना चाहिए।\n   - FirstUniqueChar(\"\") को 'n' लौटाना चाहिए।\n*/\n    static char FirstUniqueChar(string str)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megkeresi az első karaktert egy szövegben, amely csak egyszer fordul elő.\n   Ha minden karakter többször fordul elő, vagy a szöveg üres, akkor 'n'-t ad vissza karakterként.\n   Példák:\n   - FirstUniqueChar(\"aabbcdde\") 'c'-t kell visszaadjon.\n   - FirstUniqueChar(\"aabbcc\") 'n'-t kell visszaadjon, ami \"no\"-t jelent.\n   - FirstUniqueChar(\"xxyyzz\") 'n'-t kell visszaadjon.\n   - FirstUniqueChar(\"\") 'n'-t kell visszaadjon.\n*/\n    static char FirstUniqueChar(string str)"
    },
    "prompt_bertscore": {
      "sq": "0.9882426704857828",
      "hy": "0.9797269887900552",
      "bn": "0.9744398453076685",
      "bg": "0.9910677903952421",
      "zh": "0.9560639528669879",
      "fr": "0.9916390513710984",
      "de": "0.9898503847898793",
      "ha": "0.9952084393182954",
      "hi": "0.9851412557163042",
      "hu": "0.9717444310370251"
    },
    "canonical_solution": "    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }",
    "instruction": {
      "en": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nՏրամադրել C# կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9169325760208287",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9428713202194127",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FirstUniqueChar(\"aabbcdde\") == 'c');\n        Debug.Assert(FirstUniqueChar(\"aabbcc\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"xxyyazz\") == 'a');\n        Debug.Assert(FirstUniqueChar(\"\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"aabbcceeddf\") == 'f');\n\n    }\n}",
    "entry_point": "FirstUniqueChar",
    "signature": "static char FirstUniqueChar(string str)",
    "docstring": {
      "en": "Finds the first character in a string that appears only once.\n   If all characters appear more than once or the string is empty, it returns 'no' as a character.\n   Examples:\n   - FirstUniqueChar(\"aabbcdde\") should return 'c'.\n   - FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".\n   - FirstUniqueChar(\"xxyyzz\") should return 'n'.\n   - FirstUniqueChar(\"\") should return 'n'.",
      "sq": "Gjen karakterin e parë në një varg që shfaqet vetëm një herë.\n   Nëse të gjithë karakteret shfaqen më shumë se një herë ose vargu është bosh, kthen 'n' si një karakter.\n   Shembuj:\n   - FirstUniqueChar(\"aabbcdde\") duhet të kthejë 'c'.\n   - FirstUniqueChar(\"aabbcc\") duhet të kthejë 'n', që përfaqëson \"jo\".\n   - FirstUniqueChar(\"xxyyzz\") duhet të kthejë 'n'.\n   - FirstUniqueChar(\"\") duhet të kthejë 'n'.",
      "hy": "Գտնում է տողում առաջին նիշը, որը հանդիպում է միայն մեկ անգամ:\n   Եթե բոլոր նիշերը հանդիպում են մեկից ավելի անգամ կամ տողը դատարկ է, վերադարձնում է 'n' որպես նիշ:\n   Օրինակներ:\n   - FirstUniqueChar(\"aabbcdde\") պետք է վերադարձնի 'c':\n   - FirstUniqueChar(\"aabbcc\") պետք է վերադարձնի 'n', որը ներկայացնում է \"ոչ\":\n   - FirstUniqueChar(\"xxyyzz\") պետք է վերադարձնի 'n':\n   - FirstUniqueChar(\"\") պետք է վերադարձնի 'n':",
      "bn": "প্রথম যে অক্ষরটি শুধুমাত্র একবার প্রদর্শিত হয় তা একটি স্ট্রিংয়ে খুঁজে বের করে।\n   যদি সমস্ত অক্ষর একাধিকবার উপস্থিত থাকে বা স্ট্রিংটি খালি হয়, এটি 'no' হিসাবে একটি অক্ষর ফেরত দেয়।\n   উদাহরণস্বরূপ:\n   - FirstUniqueChar(\"aabbcdde\") 'c' ফেরত দেবে।\n   - FirstUniqueChar(\"aabbcc\") 'n' ফেরত দেবে, যা \"no\" নির্দেশ করে।\n   - FirstUniqueChar(\"xxyyzz\") 'n' ফেরত দেবে।\n   - FirstUniqueChar(\"\") 'n' ফেরত দেবে।",
      "bg": "Намира първия символ в низ, който се появява само веднъж.\n   Ако всички символи се появяват повече от веднъж или низът е празен, връща 'n' като символ.\n   Примери:\n   - FirstUniqueChar(\"aabbcdde\") трябва да върне 'c'.\n   - FirstUniqueChar(\"aabbcc\") трябва да върне 'n', представляващо \"не\".\n   - FirstUniqueChar(\"xxyyzz\") трябва да върне 'n'.\n   - FirstUniqueChar(\"\") трябва да върне 'n'.",
      "zh": "找到字符串中仅出现一次的第一个字符。\n   如果所有字符出现多次或字符串为空，则返回 'n' 作为字符。\n   示例：\n   - FirstUniqueChar(\"aabbcdde\") 应返回 'c'。\n   - FirstUniqueChar(\"aabbcc\") 应返回 'n'，表示“没有”。\n   - FirstUniqueChar(\"xxyyzz\") 应返回 'n'。\n   - FirstUniqueChar(\"\") 应返回 'n'。",
      "fr": "Trouve le premier caractère dans une chaîne qui apparaît une seule fois.\n   Si tous les caractères apparaissent plus d'une fois ou si la chaîne est vide, il renvoie 'n' comme caractère.\n   Exemples :\n   - FirstUniqueChar(\"aabbcdde\") devrait renvoyer 'c'.\n   - FirstUniqueChar(\"aabbcc\") devrait renvoyer 'n', représentant \"non\".\n   - FirstUniqueChar(\"xxyyzz\") devrait renvoyer 'n'.\n   - FirstUniqueChar(\"\") devrait renvoyer 'n'.",
      "de": "Findet das erste Zeichen in einem String, das nur einmal vorkommt.\n   Wenn alle Zeichen mehr als einmal vorkommen oder der String leer ist, gibt es 'n' als Zeichen zurück.\n   Beispiele:\n   - FirstUniqueChar(\"aabbcdde\") sollte 'c' zurückgeben.\n   - FirstUniqueChar(\"aabbcc\") sollte 'n' zurückgeben, was \"nein\" repräsentiert.\n   - FirstUniqueChar(\"xxyyzz\") sollte 'n' zurückgeben.\n   - FirstUniqueChar(\"\") sollte 'n' zurückgeben.",
      "ha": "Yana nemo harafin farko a cikin wani igiyar rubutu wanda ya bayyana sau ɗaya kawai.\n   Idan duk haruffa sun bayyana fiye da sau ɗaya ko kuma igiyar rubutu babu komai, zai dawo da 'a'a' a matsayin harafi.\n   Misalai:\n   - FirstUniqueChar(\"aabbcdde\") ya kamata ya dawo da 'c'.\n   - FirstUniqueChar(\"aabbcc\") ya kamata ya dawo da 'n', wanda ke wakiltar \"a'a\".\n   - FirstUniqueChar(\"xxyyzz\") ya kamata ya dawo da 'n'.\n   - FirstUniqueChar(\"\") ya kamata ya dawo da 'n'.",
      "hi": "पहली बार एक स्ट्रिंग में वह अक्षर खोजता है जो केवल एक बार दिखाई देता है।  \n   यदि सभी अक्षर एक से अधिक बार दिखाई देते हैं या स्ट्रिंग खाली है, तो यह 'no' को एक अक्षर के रूप में लौटाता है।  \n   उदाहरण:  \n   - FirstUniqueChar(\"aabbcdde\") को 'c' लौटाना चाहिए।  \n   - FirstUniqueChar(\"aabbcc\") को 'n' लौटाना चाहिए, जो \"no\" का प्रतिनिधित्व करता है।  \n   - FirstUniqueChar(\"xxyyzz\") को 'n' लौटाना चाहिए।  \n   - FirstUniqueChar(\"\") को 'n' लौटाना चाहिए।  ",
      "hu": "Megkeresi az első karaktert egy szövegben, amely csak egyszer fordul elő.\n   Ha minden karakter többször fordul elő, vagy a szöveg üres, akkor 'n'-t ad vissza karakterként.\n   Példák:\n   - FirstUniqueChar(\"aabbcdde\") 'c'-t kell visszaadjon.\n   - FirstUniqueChar(\"aabbcc\") 'n'-t kell visszaadjon, ami \"no\"-t jelent.\n   - FirstUniqueChar(\"xxyyzz\") 'n'-t kell visszaadjon.\n   - FirstUniqueChar(\"\") 'n'-t kell visszaadjon."
    },
    "docstring_bertscore": {
      "sq": "0.9713582935762932",
      "hy": "0.9474849080797101",
      "bn": "0.956696789260965",
      "bg": "0.986091304828794",
      "zh": "0.9490517045253133",
      "fr": "0.97870682315306",
      "de": "0.9775335134922869",
      "ha": "0.9790794537478814",
      "hi": "0.9548292664184751",
      "hu": "0.9532001000332269"
    }
  },
  {
    "task_id": "C#/26",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines if two DNA sequences are related based on the similarity threshold.\n   The function compares two DNA sequences of the same length, base pair by base pair.\n   If the proportion of identical base pairs is greater than or equal to the given threshold,\n   the sequences are considered related.\n   \n   Example:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton nëse dy sekuenca të ADN-së janë të lidhura bazuar në pragun e ngjashmërisë.\n   Funksioni krahason dy sekuenca të ADN-së me të njëjtën gjatësi, bazë për bazë.\n   Nëse përqindja e çifteve bazë identike është më e madhe ose e barabartë me pragun e dhënë,\n   sekuencat konsiderohen të lidhura.\n   \n   Shembull:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Սահմանում է՝ արդյոք երկու ԴՆԹ հաջորդականություններն առնչվա՞ծ են՝ հիմնվելով նմանության շեմի վրա։\n   Ֆունկցիան համեմատում է նույն երկարության երկու ԴՆԹ հաջորդականություններ՝ զույգ առ զույգ։\n   Եթե նույնական զույգերի բաժինը մեծ կամ հավասար է տրված շեմին,\n   հաջորդականությունները համարվում են առնչված։\n   \n   Օրինակ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* দুটি ডিএনএ সিকোয়েন্স সম্পর্কিত কিনা তা নির্ধারণ করে সাদৃশ্যের সীমার উপর ভিত্তি করে।\n   ফাংশনটি একই দৈর্ঘ্যের দুটি ডিএনএ সিকোয়েন্সকে তুলনা করে, প্রতিটি বেস পেয়ার ধরে ধরে।\n   যদি অভিন্ন বেস পেয়ারের অনুপাত প্রদত্ত সীমার চেয়ে বেশি বা সমান হয়,\n   তাহলে সিকোয়েন্সগুলোকে সম্পর্কিত বলে বিবেচনা করা হয়।\n   \n   উদাহরণ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя дали две ДНК последователности са свързани въз основа на прага на сходство.\n   Функцията сравнява две ДНК последователности с еднаква дължина, база по база.\n   Ако делът на идентичните базови двойки е по-голям или равен на дадения праг,\n   последователностите се считат за свързани.\n   \n   Пример:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 判断两个 DNA 序列是否基于相似性阈值相关。\n   该函数逐个碱基对地比较两个相同长度的 DNA 序列。\n   如果相同碱基对的比例大于或等于给定的阈值，\n   则认为这些序列是相关的。\n   \n   示例:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine si deux séquences d'ADN sont liées en fonction du seuil de similarité.\n   La fonction compare deux séquences d'ADN de même longueur, paire de bases par paire de bases.\n   Si la proportion de paires de bases identiques est supérieure ou égale au seuil donné,\n   les séquences sont considérées comme liées.\n   \n   Exemple :\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt, ob zwei DNA-Sequenzen basierend auf dem Ähnlichkeitsschwellenwert verwandt sind.\n   Die Funktion vergleicht zwei DNA-Sequenzen gleicher Länge, Basenpaar für Basenpaar.\n   Wenn der Anteil identischer Basenpaare größer oder gleich dem gegebenen Schwellenwert ist,\n   werden die Sequenzen als verwandt betrachtet.\n   \n   Beispiel:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantancewa idan kwayoyin halitta guda biyu suna da alaka bisa ga matakin kamanceceniya.\n   Aikin yana kwatanta kwayoyin halitta guda biyu masu tsawon iri ɗaya, kwayar halitta ta kwayar halitta.\n   Idan kaso na kwayoyin halitta masu kama da juna ya fi ko yayi daidai da matakin da aka bayar,\n   ana ɗaukar kwayoyin halittar suna da alaka.\n   \n   Misali:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह निर्धारित करता है कि क्या दो डीएनए अनुक्रम समानता सीमा के आधार पर संबंधित हैं।\n   यह फ़ंक्शन समान लंबाई के दो डीएनए अनुक्रमों की तुलना करता है, प्रत्येक बेस जोड़ी द्वारा।\n   यदि समान बेस जोड़ों का अनुपात दिए गए सीमा से अधिक या उसके बराबर है,\n   तो अनुक्रमों को संबंधित माना जाता है।\n   \n   उदाहरण:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza, hogy két DNS-szekvencia kapcsolódik-e a hasonlósági küszöb alapján.\n   A függvény összehasonlít két azonos hosszúságú DNS-szekvenciát, bázispáronként.\n   Ha az azonos bázispárok aránya nagyobb vagy egyenlő a megadott küszöbnél,\n   a szekvenciák kapcsolódónak tekintendők.\n   \n   Példa:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)"
    },
    "prompt_bertscore": {
      "sq": "0.9877868137613078",
      "hy": "0.971920218924241",
      "bn": "0.9907837489503623",
      "bg": "0.9902675085900525",
      "zh": "0.9734313988631544",
      "fr": "1",
      "de": "0.9993214786183848",
      "ha": "0.9593006349259514",
      "hi": "0.9877882041739751",
      "hu": "0.9933576014278123"
    },
    "canonical_solution": "    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }",
    "instruction": {
      "en": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nC# կոդի համար տրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nFournir une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9364434424587427",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8909247084496446",
      "fr": "0.9489770195020442",
      "de": "0.9270041294912027",
      "ha": "0.9428713202194127",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(AreDNAsRelated(\"ATCGCCGTAAGTAACGGTTTTAAATAGGCC\", \"ATCGCCGGAAGTAACGGTCTTAAATAGGCC\", 0.85) == true);\n        Debug.Assert(AreDNAsRelated(\"GGCATGAC\", \"TGACATGC\", 0.50) == false);\n        Debug.Assert(AreDNAsRelated(\"AAAA\", \"AAAA\", 1.00) == true);\n        Debug.Assert(AreDNAsRelated(\"CCCC\", \"GGTT\", 0.25) == false);\n\n    }\n}",
    "entry_point": "AreDNAsRelated",
    "signature": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
    "docstring": {
      "en": "Determines if two DNA sequences are related based on the similarity threshold.\n   The function compares two DNA sequences of the same length, base pair by base pair.\n   If the proportion of identical base pairs is greater than or equal to the given threshold,\n   the sequences are considered related.\n   \n   Example:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "sq": "Përcakton nëse dy sekuenca të ADN-së janë të lidhura bazuar në pragun e ngjashmërisë.\n   Funksioni krahason dy sekuenca të ADN-së me të njëjtën gjatësi, çift bazë për çift bazë.\n   Nëse përqindja e çifteve bazë identike është më e madhe ose e barabartë me pragun e dhënë,\n   sekuencat konsiderohen të lidhura.\n   \n   Shembull:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hy": "Որոշում է՝ արդյոք երկու ԴՆԹ հաջորդականություններն առնչվա՞ծ են՝ հիմնվելով նմանության շեմի վրա:\n   Ֆունկցիան համեմատում է նույն երկարության երկու ԴՆԹ հաջորդականություններ՝ հիմք առ հիմք:\n   Եթե նույնական հիմքերի բաժինը մեծ է կամ հավասար է տրված շեմին,\n   հաջորդականությունները համարվում են առնչված:\n   \n   Օրինակ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "bn": "দুটি ডিএনএ সিকোয়েন্স সম্পর্কিত কিনা তা নির্ধারণ করে সাদৃশ্যের থ্রেশহোল্ডের উপর ভিত্তি করে। \n   ফাংশনটি একই দৈর্ঘ্যের দুটি ডিএনএ সিকোয়েন্সকে তুলনা করে, বেস জোড়া দ্বারা বেস জোড়া। \n   যদি অভিন্ন বেস জোড়ার অনুপাত প্রদত্ত থ্রেশহোল্ডের সমান বা তার বেশি হয়, \n   তবে সিকোয়েন্সগুলোকে সম্পর্কিত বলে বিবেচনা করা হয়।\n\n   উদাহরণ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "bg": "Определя дали две ДНК последователности са свързани въз основа на прага на сходство.\n   Функцията сравнява две ДНК последователности с еднаква дължина, база по база.\n   Ако делът на идентичните бази е по-голям или равен на дадения праг,\n   последователностите се считат за свързани.\n   \n   Пример:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "zh": "确定两个DNA序列是否基于相似性阈值相关。\n   该函数逐个碱基对比较两个长度相同的DNA序列。\n   如果相同碱基对的比例大于或等于给定的阈值，则认为序列是相关的。\n   \n   示例:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "fr": "Détermine si deux séquences d'ADN sont liées en fonction du seuil de similarité.\n   La fonction compare deux séquences d'ADN de même longueur, paire de bases par paire de bases.\n   Si la proportion de paires de bases identiques est supérieure ou égale au seuil donné,\n   les séquences sont considérées comme liées.\n   \n   Exemple :\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "de": "Bestimmt, ob zwei DNA-Sequenzen basierend auf dem Ähnlichkeitsschwellenwert verwandt sind.\n   Die Funktion vergleicht zwei DNA-Sequenzen gleicher Länge, Basenpaar für Basenpaar.\n   Wenn der Anteil identischer Basenpaare größer oder gleich dem angegebenen Schwellenwert ist,\n   werden die Sequenzen als verwandt betrachtet.\n   \n   Beispiel:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "ha": "Yana tantance ko kwayoyin halittar DNA guda biyu suna da alaka bisa ga matakin kamanceceniya.\n   Aikin yana kwatanta kwayoyin halittar DNA guda biyu masu tsawon iri ɗaya, kwayar tushe da kwayar tushe.\n   Idan yawan kwayoyin tushe masu kama da juna ya fi ko ya kai matakin da aka bayar,\n   ana ɗaukar kwayoyin halittar suna da alaka.\n\n   Misali:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hi": "दो डीएनए अनुक्रमों के संबंध का निर्धारण करता है जो समानता सीमा के आधार पर होता है।\n   यह फ़ंक्शन समान लंबाई के दो डीएनए अनुक्रमों की तुलना करता है, प्रत्येक आधार युग्म द्वारा।\n   यदि समान आधार युग्मों का अनुपात दिए गए सीमा से अधिक या उसके बराबर है,\n   तो अनुक्रमों को संबंधित माना जाता है।\n   \n   उदाहरण:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hu": "Meghatározza, hogy két DNS-szekvencia rokon-e a hasonlósági küszöb alapján.\n   A függvény összehasonlít két azonos hosszúságú DNS-szekvenciát, bázispáronként.\n   Ha az azonos bázispárok aránya nagyobb vagy egyenlő a megadott küszöbértéknél,\n   a szekvenciákat rokonoknak tekintjük.\n   \n   Példa:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true"
    },
    "docstring_bertscore": {
      "sq": "0.995200494103054",
      "hy": "0.9705562240976744",
      "bn": "0.986552524573557",
      "bg": "0.9705562240976744",
      "zh": "0.9575491122259858",
      "fr": "0.9865417985329812",
      "de": "0.991095995909349",
      "ha": "0.9390993292835602",
      "hi": "0.9432159439305082",
      "hu": "0.9910652082002886"
    }
  },
  {
    "task_id": "C#/27",
    "prompt": {
      "en": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* This function takes a string as input and returns a 'Close Friend' string based on specific ASCII value manipulations.\n   The Close Friend string is generated by summing the ASCII values of each pair of adjacent characters in the input string,\n   creating a new character from the sum. For the last character of the Close Friend string, sum the ASCII value of the \n   last and first characters of the input string. The input string length should be between 2 and 100 characters, and \n   each character's ASCII value should not exceed 63.\n\n   Example:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "sq": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Kjo funksion merr një varg si hyrje dhe kthen një varg 'Mik i Afërt' bazuar në manipulime specifike të vlerave ASCII.\n   Vargu Mik i Afërt gjenerohet duke mbledhur vlerat ASCII të çdo çifti karakteresh ngjitur në vargun hyrës,\n   duke krijuar një karakter të ri nga shuma. Për karakterin e fundit të vargut Mik i Afërt, mblidhni vlerën ASCII të\n   karakterit të fundit dhe të parë të vargut hyrës. Gjatësia e vargut hyrës duhet të jetë midis 2 dhe 100 karaktere, dhe\n   vlera ASCII e çdo karakteri nuk duhet të kalojë 63.\n\n   Shembull:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "hy": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Այս ֆունկցիան ընդունում է տող որպես մուտք և վերադարձնում է 'Close Friend' տող՝ հիմնված հատուկ ASCII արժեքների մանիպուլյացիաների վրա:\n   Close Friend տողը գեներացվում է մուտքային տողի հարակից յուրաքանչյուր զույգ նիշերի ASCII արժեքների գումարով,\n   ստեղծելով նոր նիշ գումարից: Close Friend տողի վերջին նիշի համար գումարեք մուտքային տողի վերջին և առաջին նիշերի \n   ASCII արժեքները: Մուտքային տողի երկարությունը պետք է լինի 2-ից 100 նիշ, և \n   յուրաքանչյուր նիշի ASCII արժեքը չպետք է գերազանցի 63-ը:\n\n   Օրինակ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "bn": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* এই ফাংশনটি একটি স্ট্রিং ইনপুট হিসেবে গ্রহণ করে এবং নির্দিষ্ট ASCII মানের পরিবর্তনের উপর ভিত্তি করে একটি 'Close Friend' স্ট্রিং ফেরত দেয়।\n   Close Friend স্ট্রিংটি ইনপুট স্ট্রিংয়ের প্রতিটি সংলগ্ন অক্ষরের ASCII মান যোগ করে তৈরি করা হয়,\n   যোগফল থেকে একটি নতুন অক্ষর তৈরি করে। Close Friend স্ট্রিংয়ের শেষ অক্ষরের জন্য, ইনপুট স্ট্রিংয়ের\n   শেষ এবং প্রথম অক্ষরের ASCII মান যোগ করুন। ইনপুট স্ট্রিংয়ের দৈর্ঘ্য 2 থেকে 100 অক্ষরের মধ্যে হওয়া উচিত এবং\n   প্রতিটি অক্ষরের ASCII মান 63 এর বেশি হওয়া উচিত নয়।\n\n   উদাহরণ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "bg": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Тази функция приема низ като вход и връща низ 'Close Friend' въз основа на специфични манипулации на ASCII стойности.\n   Низът 'Close Friend' се генерира чрез сумиране на ASCII стойностите на всяка двойка съседни символи в входния низ,\n   създавайки нов символ от сумата. За последния символ на низа 'Close Friend', сумирайте ASCII стойността на \n   последния и първия символ на входния низ. Дължината на входния низ трябва да бъде между 2 и 100 символа, и \n   ASCII стойността на всеки символ не трябва да надвишава 63.\n\n   Пример:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "zh": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 这个函数接受一个字符串作为输入，并基于特定的ASCII值操作返回一个“Close Friend”字符串。\n   “Close Friend”字符串是通过对输入字符串中每对相邻字符的ASCII值求和生成新字符而生成的。\n   对于“Close Friend”字符串的最后一个字符，求输入字符串的最后一个字符和第一个字符的ASCII值之和。\n   输入字符串的长度应在2到100个字符之间，并且每个字符的ASCII值不应超过63。\n\n   示例：\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "fr": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Cette fonction prend une chaîne en entrée et renvoie une chaîne 'Ami Proche' basée sur des manipulations spécifiques des valeurs ASCII.\n   La chaîne Ami Proche est générée en additionnant les valeurs ASCII de chaque paire de caractères adjacents dans la chaîne d'entrée,\n   créant un nouveau caractère à partir de la somme. Pour le dernier caractère de la chaîne Ami Proche, additionnez la valeur ASCII du \n   dernier et du premier caractère de la chaîne d'entrée. La longueur de la chaîne d'entrée doit être comprise entre 2 et 100 caractères, et \n   la valeur ASCII de chaque caractère ne doit pas dépasser 63.\n\n   Exemple :\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "de": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Diese Funktion nimmt einen String als Eingabe und gibt einen 'Close Friend'-String basierend auf spezifischen ASCII-Wert-Manipulationen zurück.\n   Der 'Close Friend'-String wird erzeugt, indem die ASCII-Werte jedes Paares benachbarter Zeichen im Eingabestring summiert werden,\n   und ein neues Zeichen aus der Summe erstellt wird. Für das letzte Zeichen des 'Close Friend'-Strings wird die Summe der ASCII-Werte \n   des letzten und ersten Zeichens des Eingabestrings gebildet. Die Länge des Eingabestrings sollte zwischen 2 und 100 Zeichen liegen, und \n   der ASCII-Wert jedes Zeichens sollte 63 nicht überschreiten.\n\n   Beispiel:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "ha": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Wannan aikin yana karɓar kirtani a matsayin shigarwa kuma yana mayar da kirtani 'Aboki Na Kusa' bisa ga wasu takamaiman sarrafa ƙimar ASCII.\n   Ana samar da kirtanin Aboki Na Kusa ta hanyar tara ƙimar ASCII na kowanne ma'aurata na haruffa masu makwabtaka a cikin kirtanin shigarwa,\n   ƙirƙirar sabon harafi daga tarin. Don harafin ƙarshe na kirtanin Aboki Na Kusa, tara ƙimar ASCII na harafin ƙarshe da na farko na kirtanin shigarwa.\n   Tsawon kirtanin shigarwa ya kamata ya kasance tsakanin haruffa 2 zuwa 100, kuma ƙimar ASCII na kowanne harafi bai kamata ya wuce 63 ba.\n\n   Misali:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "hi": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* यह फ़ंक्शन एक स्ट्रिंग को इनपुट के रूप में लेता है और विशिष्ट ASCII मान हेरफेर के आधार पर 'क्लोज़ फ्रेंड' स्ट्रिंग लौटाता है।\n   क्लोज़ फ्रेंड स्ट्रिंग इनपुट स्ट्रिंग में प्रत्येक जोड़ी के आसन्न वर्णों के ASCII मानों को जोड़कर उत्पन्न होती है,\n   योग से एक नया वर्ण बनाना। क्लोज़ फ्रेंड स्ट्रिंग के अंतिम वर्ण के लिए, इनपुट स्ट्रिंग के अंतिम और पहले वर्णों के \n   ASCII मान का योग करें। इनपुट स्ट्रिंग की लंबाई 2 और 100 वर्णों के बीच होनी चाहिए, और \n   प्रत्येक वर्ण का ASCII मान 63 से अधिक नहीं होना चाहिए।\n\n   उदाहरण:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "hu": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Ez a függvény egy karakterláncot vesz bemenetként, és egy 'Közeli Barát' karakterláncot ad vissza meghatározott ASCII érték manipulációk alapján.\n   A Közeli Barát karakterlánc úgy jön létre, hogy az input karakterlánc minden szomszédos karakterpárjának ASCII értékeit összeadjuk,\n   és az összegből egy új karaktert hozunk létre. A Közeli Barát karakterlánc utolsó karakteréhez az input karakterlánc utolsó és első \n   karakterének ASCII értékét adjuk össze. Az input karakterlánc hossza 2 és 100 karakter között kell legyen, és \n   minden karakter ASCII értéke nem haladhatja meg a 63-at.\n\n   Példa:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)"
    },
    "prompt_bertscore": {
      "sq": "0.9718608284403115",
      "hy": "0.9839899940278259",
      "bn": "0.9596543956345746",
      "bg": "0.9755376754236483",
      "zh": "0.9595421694692898",
      "fr": "0.9679714469492674",
      "de": "0.969871147913485",
      "ha": "0.980711003697702",
      "hi": "0.9745629961439102",
      "hu": "0.9597723820809093"
    },
    "canonical_solution": "    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }",
    "instruction": {
      "en": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nՏրամադրել կարճ բնական լեզվով նկարագրություն (docstring) C# կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nBa da takaitaccen bayanin yaren dabi'a (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nC# कोड के लिए संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में 500 वर्णों तक प्रदान करें।",
      "hu": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9255449907121205",
      "bn": "0.8913843391513593",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.966551835616011",
      "hi": "0.9196599697828187",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(GenerateCloseFriendString(\"1234\") == \"cege\");\n        Debug.Assert(GenerateCloseFriendString(\"4312\") == \"gdcf\");\n\n    }\n}",
    "entry_point": "GenerateCloseFriendString",
    "signature": "static string GenerateCloseFriendString(string inputString)",
    "docstring": {
      "en": "This function takes a string as input and returns a 'Close Friend' string based on specific ASCII value manipulations.\n   The Close Friend string is generated by summing the ASCII values of each pair of adjacent characters in the input string,\n   creating a new character from the sum. For the last character of the Close Friend string, sum the ASCII value of the \n   last and first characters of the input string. The input string length should be between 2 and 100 characters, and \n   each character's ASCII value should not exceed 63.\n\n   Example:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "sq": "Kjo funksion merr një varg si hyrje dhe kthen një varg 'Mik i Afërt' bazuar në manipulime specifike të vlerave ASCII.\n   Vargu Mik i Afërt gjenerohet duke mbledhur vlerat ASCII të secilit çift të karaktereve ngjitur në vargun hyrës,\n   duke krijuar një karakter të ri nga shuma. Për karakterin e fundit të vargut Mik i Afërt, mblidhni vlerën ASCII të\n   karakterit të fundit dhe të parë të vargut hyrës. Gjatësia e vargut hyrës duhet të jetë midis 2 dhe 100 karaktereve, dhe\n   vlera ASCII e secilit karakter nuk duhet të kalojë 63.\n\n   Shembull:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hy": "Այս ֆունկցիան ընդունում է տող որպես մուտք և վերադարձնում է 'Close Friend' տող՝ հիմնված հատուկ ASCII արժեքների մանիպուլյացիաների վրա:\n   'Close Friend' տողը գեներացվում է մուտքային տողի հարակից յուրաքանչյուր զույգ նիշերի ASCII արժեքների գումարով,\n   ստեղծելով նոր նիշ գումարից: 'Close Friend' տողի վերջին նիշի համար գումարեք մուտքային տողի վերջին և առաջին նիշերի \n   ASCII արժեքները: Մուտքային տողի երկարությունը պետք է լինի 2-ից 100 նիշ, և յուրաքանչյուր նիշի ASCII արժեքը չպետք է գերազանցի 63:\n\n   Օրինակ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "bn": "এই ফাংশনটি একটি স্ট্রিং ইনপুট হিসেবে গ্রহণ করে এবং নির্দিষ্ট ASCII মানের পরিবর্তনের উপর ভিত্তি করে একটি 'Close Friend' স্ট্রিং ফেরত দেয়।\n   Close Friend স্ট্রিংটি ইনপুট স্ট্রিংয়ের প্রতিটি সংলগ্ন অক্ষরের ASCII মান যোগ করে তৈরি করা হয়,\n   যোগফল থেকে একটি নতুন অক্ষর তৈরি করা হয়। Close Friend স্ট্রিংয়ের শেষ অক্ষরের জন্য, ইনপুট স্ট্রিংয়ের শেষ এবং প্রথম অক্ষরের ASCII মান যোগ করুন। ইনপুট স্ট্রিংয়ের দৈর্ঘ্য 2 থেকে 100 অক্ষরের মধ্যে হওয়া উচিত এবং \n   প্রতিটি অক্ষরের ASCII মান 63 অতিক্রম করা উচিত নয়।\n\n   উদাহরণ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "bg": "Тази функция приема низ като вход и връща низ 'Close Friend' въз основа на специфични манипулации на ASCII стойности. \n   Низът Close Friend се генерира чрез събиране на ASCII стойностите на всяка двойка съседни символи в входния низ, \n   създавайки нов символ от сумата. За последния символ на низа Close Friend, съберете ASCII стойността на \n   последния и първия символ на входния низ. Дължината на входния низ трябва да бъде между 2 и 100 символа, и \n   ASCII стойността на всеки символ не трябва да надвишава 63.\n\n   Пример:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "zh": "此函数接受一个字符串作为输入，并基于特定的ASCII值操作返回一个“Close Friend”字符串。\n“Close Friend”字符串是通过对输入字符串中每对相邻字符的ASCII值求和生成的，从和中创建一个新字符。对于“Close Friend”字符串的最后一个字符，将输入字符串的最后一个字符和第一个字符的ASCII值相加。输入字符串的长度应在2到100个字符之间，并且每个字符的ASCII值不应超过63。\n\n示例：\n>>> GenerateCloseFriendString(\"1234\")\n\"cege\"",
      "fr": "Cette fonction prend une chaîne de caractères en entrée et renvoie une chaîne 'Ami Proche' basée sur des manipulations spécifiques des valeurs ASCII.\n   La chaîne Ami Proche est générée en additionnant les valeurs ASCII de chaque paire de caractères adjacents dans la chaîne d'entrée,\n   créant un nouveau caractère à partir de la somme. Pour le dernier caractère de la chaîne Ami Proche, additionnez la valeur ASCII des \n   derniers et premiers caractères de la chaîne d'entrée. La longueur de la chaîne d'entrée doit être comprise entre 2 et 100 caractères, et \n   la valeur ASCII de chaque caractère ne doit pas dépasser 63.\n\n   Exemple :\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "de": "Diese Funktion nimmt einen String als Eingabe und gibt einen 'Close Friend'-String basierend auf spezifischen ASCII-Wert-Manipulationen zurück. Der 'Close Friend'-String wird erzeugt, indem die ASCII-Werte jedes Paares benachbarter Zeichen im Eingabestring summiert werden, um ein neues Zeichen aus der Summe zu erstellen. Für das letzte Zeichen des 'Close Friend'-Strings wird die Summe des ASCII-Werts des letzten und des ersten Zeichens des Eingabestrings gebildet. Die Länge des Eingabestrings sollte zwischen 2 und 100 Zeichen liegen, und der ASCII-Wert jedes Zeichens sollte 63 nicht überschreiten.\n\n   Beispiel:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "ha": "Wannan aikin yana karɓar kirtani a matsayin shigarwa kuma yana mayar da kirtani 'Aboki Mai Kusa' bisa ga wasu takamaiman gyare-gyaren ƙimar ASCII. \n   Ana samar da kirtanin Aboki Mai Kusa ta hanyar tara ƙimar ASCII na kowanne ma'aurata na haruffa masu makwabtaka a cikin kirtanin shigarwa, \n   ta hanyar ƙirƙirar sabon harafi daga tarin. Don harafin ƙarshe na kirtanin Aboki Mai Kusa, tara ƙimar ASCII na harafin ƙarshe da na farko na kirtanin shigarwa. \n   Tsawon kirtanin shigarwa ya kamata ya kasance tsakanin haruffa 2 zuwa 100, kuma ƙimar ASCII na kowane harafi bai kamata ya wuce 63 ba.\n\n   Misali:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hi": "यह फ़ंक्शन एक स्ट्रिंग को इनपुट के रूप में लेता है और विशिष्ट ASCII मान हेरफेर के आधार पर एक 'Close Friend' स्ट्रिंग लौटाता है। \n   Close Friend स्ट्रिंग इनपुट स्ट्रिंग में प्रत्येक जोड़ी के आसन्न वर्णों के ASCII मानों को जोड़कर उत्पन्न की जाती है,\n   और जोड़ से एक नया वर्ण बनता है। Close Friend स्ट्रिंग के अंतिम वर्ण के लिए, इनपुट स्ट्रिंग के अंतिम और पहले वर्णों के \n   ASCII मान को जोड़ें। इनपुट स्ट्रिंग की लंबाई 2 और 100 वर्णों के बीच होनी चाहिए, और प्रत्येक वर्ण का ASCII मान 63 से अधिक नहीं होना चाहिए।\n\n   उदाहरण:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hu": "Ez a függvény egy karakterláncot vesz bemenetként, és egy 'Közeli Barát' karakterláncot ad vissza specifikus ASCII érték manipulációk alapján.\n   A Közeli Barát karakterlánc azáltal jön létre, hogy az input karakterlánc minden szomszédos karakterpárjának ASCII értékeit összegezzük,\n   és az összegből egy új karaktert hozunk létre. A Közeli Barát karakterlánc utolsó karakteréhez az input karakterlánc utolsó és első karakterének \n   ASCII értékét összegezzük. Az input karakterlánc hossza 2 és 100 karakter között kell legyen, és minden karakter ASCII értéke nem haladhatja meg a 63-at.\n\n   Példa:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\""
    },
    "docstring_bertscore": {
      "sq": "0.9635036537886497",
      "hy": "0.9744664617787272",
      "bn": "0.9458779882971378",
      "bg": "0.9635036537886497",
      "zh": "0.9474026751019616",
      "fr": "0.9667901920732529",
      "de": "0.9560389254389775",
      "ha": "0.973918837818214",
      "hi": "0.9636168731058395",
      "hu": "0.961695322799708"
    }
  },
  {
    "task_id": "C#/28",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Decrypts a cipher text that was encrypted using a Caesar cipher with a 5-letter shift.\n    The function only shifts uppercase alphabetic characters and leaves other characters unchanged.\n    Example:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Dekripton një tekst të koduar që është koduar duke përdorur një kod Caesar me një zhvendosje prej 5 shkronjash.\n    Funksioni zhvendos vetëm shkronjat alfabetike të mëdha dhe lë karakteret e tjera të pandryshuara.\n    Shembull:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Ապակոդավորում է ծածկագիրը, որը կոդավորվել էր Կեսարի ծածկագրով՝ 5 տառանոց տեղաշարժով:\n    Ֆունկցիան տեղաշարժում է միայն մեծատառ այբենական նիշերը և թողնում է այլ նիշերը անփոփոխ:\n    Օրինակ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    একটি সিজার সাইফার দিয়ে এনক্রিপ্ট করা সাইফার টেক্সট ডিক্রিপ্ট করে যা ৫-অক্ষরের শিফট ব্যবহার করে এনক্রিপ্ট করা হয়েছিল।\n    ফাংশনটি শুধুমাত্র বড় হাতের বর্ণমালার অক্ষরগুলিকে শিফট করে এবং অন্যান্য অক্ষর অপরিবর্তিত রাখে।\n    উদাহরণ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Декриптира шифрован текст, който е бил криптиран с помощта на шифър на Цезар с 5-буквено изместване.\n    Функцията изместа само главни азбучни символи и оставя другите символи непроменени.\n    Пример:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    解密使用凯撒密码加密的密文，偏移量为5个字母。\n    该函数仅对大写字母字符进行偏移，其他字符保持不变。\n    示例：\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Décrypte un texte chiffré qui a été crypté en utilisant un chiffre de César avec un décalage de 5 lettres.\n    La fonction ne décale que les caractères alphabétiques majuscules et laisse les autres caractères inchangés.\n    Exemple :\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Entschlüsselt einen Chiffretext, der mit einem Caesar-Chiffre mit einer Verschiebung um 5 Buchstaben verschlüsselt wurde.\n    Die Funktion verschiebt nur Großbuchstaben und lässt andere Zeichen unverändert.\n    Beispiel:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Yana warware rubutun sirri wanda aka rufe ta amfani da sirrin Caesar tare da juyawa haruffa 5.\n    Aiki yana juyawa ne kawai manyan haruffan alphabet kuma yana barin sauran haruffa ba tare da canji ba.\n    Misali:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    एक सिफर पाठ को डिक्रिप्ट करता है जिसे एक सीज़र सिफर का उपयोग करके 5-अक्षर शिफ्ट के साथ एन्क्रिप्ट किया गया था।\n    यह फ़ंक्शन केवल बड़े अक्षरों वाले वर्णमाला के अक्षरों को शिफ्ट करता है और अन्य वर्णों को अपरिवर्तित छोड़ देता है।\n    उदाहरण:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Dekódol egy titkos szöveget, amelyet egy Caesar-rejtjel segítségével titkosítottak 5 betűs eltolással.\n    A függvény csak a nagybetűs ábécé karaktereit tolja el, és más karaktereket változatlanul hagy.\n    Példa:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)"
    },
    "prompt_bertscore": {
      "sq": "0.9721935343285449",
      "hy": "0.9736189059428513",
      "bn": "0.9862309419866615",
      "bg": "0.9922248123647703",
      "zh": "0.9546685744402178",
      "fr": "0.982157032871636",
      "de": "0.9734381522961095",
      "ha": "0.9718024311082872",
      "hi": "0.9807493393612418",
      "hu": "0.9764775943867054"
    },
    "canonical_solution": "    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }",
    "instruction": {
      "en": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nՏվեք C# կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nসি# কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\n请用最多500个字符的中文对以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nFournir une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568463579378843",
      "hy": "0.9340356449798378",
      "bn": "0.9129434820785051",
      "bg": "0.8379186022274364",
      "zh": "0.8818071766993811",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9138947229732811",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n        Debug.Assert(DecryptCaesarCipher(\"F XYWNFYNTS YT XJHWJY\") == \"A STRIATION TO SECRET\");\n        Debug.Assert(DecryptCaesarCipher(\"YMJ VZNHP TS X HNUMJW\") == \"THE QUICK ON S CIPHER\");\n        Debug.Assert(DecryptCaesarCipher(\"JXU UQFSI QDT TZW YMZXW\") == \"ESP PLAND LYO OUR THUSR\");\n    }\n}",
    "entry_point": "DecryptCaesarCipher",
    "signature": "static string DecryptCaesarCipher(string cipherText)",
    "docstring": {
      "en": "Decrypts a cipher text that was encrypted using a Caesar cipher with a 5-letter shift.\n    The function only shifts uppercase alphabetic characters and leaves other characters unchanged.\n    Example:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sq": "Dekripton një tekst të koduar që ishte koduar duke përdorur një kod Caesar me një zhvendosje prej 5 shkronjash.\n    Funksioni zhvendos vetëm karakteret alfabetike me shkronja të mëdha dhe lë karakteret e tjera të pandryshuara.\n    Shembull:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Վերծանում է գաղտնագիրը, որը կոդավորվել է Կեսարի գաղտնագրով՝ 5 տառի տեղաշարժով:\n    Ֆունկցիան տեղաշարժում է միայն մեծատառ այբբենական նիշերը և թողնում է մյուս նիշերը անփոփոխ:\n    Օրինակ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "একটি সিজার সাইফার দিয়ে ৫-অক্ষরের শিফট ব্যবহার করে এনক্রিপ্ট করা সাইফার টেক্সট ডিক্রিপ্ট করে।\n    ফাংশনটি শুধুমাত্র বড় হাতের বর্ণমালার অক্ষরগুলিকে স্থানান্তরিত করে এবং অন্যান্য অক্ষর অপরিবর্তিত রাখে।\n    উদাহরণ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Декриптира шифрован текст, който е бил криптиран с помощта на шифър на Цезар с 5-буквено изместване.\n    Функцията изместа само главни азбучни символи и оставя другите символи непроменени.\n    Пример:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "解密使用凯撒密码加密的密文，该密码使用了5个字母的移位。\n    该函数仅移动大写字母字符，其他字符保持不变。\n    示例：\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Déchiffre un texte chiffré qui a été crypté en utilisant un chiffre de César avec un décalage de 5 lettres.  \n    La fonction ne décale que les caractères alphabétiques majuscules et laisse les autres caractères inchangés.  \n    Exemple :  \n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Entschlüsselt einen Chiffretext, der mit einem Caesar-Chiffre mit einer Verschiebung von 5 Buchstaben verschlüsselt wurde.\n    Die Funktion verschiebt nur Großbuchstaben und lässt andere Zeichen unverändert.\n    Beispiel:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Yana warware rubutun sirri da aka ɓoye ta amfani da sirrin Caesar tare da juyawa haruffa 5.\n    Aikin yana canza haruffan manyan baƙaƙe kawai kuma yana barin sauran haruffa ba tare da canji ba.\n    Misali:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"  ",
      "hi": "किसी गुप्त पाठ को डिक्रिप्ट करता है जिसे एक सीज़र सिफर के साथ 5-अक्षर शिफ्ट का उपयोग करके एन्क्रिप्ट किया गया था।\n    यह फ़ंक्शन केवल बड़े अक्षरों वाले वर्णमाला वर्णों को शिफ्ट करता है और अन्य वर्णों को अपरिवर्तित छोड़ देता है।\n    उदाहरण:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Visszafejt egy titkosított szöveget, amelyet egy Caesar-rejtjel segítségével titkosítottak 5 betűs eltolással.\n    A függvény csak a nagybetűs ábécé karaktereket tolja el, és más karaktereket változatlanul hagy.\n    Példa:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "sq": "0.9724624798644662",
      "hy": "0.9683889680102027",
      "bn": "0.974629934582319",
      "bg": "0.9893605622702473",
      "zh": "0.9477596138966813",
      "fr": "0.9906727145673637",
      "de": "0.9535038058858293",
      "ha": "0.9652945053040602",
      "hi": "0.9858879073186143",
      "hu": "0.9744126329454668"
    }
  },
  {
    "task_id": "C#/29",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Determines which of the two provided strings is a substring of the other. \n    If neither string is a substring of the other, it returns \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Përcakton se cili nga dy vargjet e dhëna është një nënvarg i tjetrit.\n    Nëse asnjëri varg nuk është nënvarg i tjetrit, kthen \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Որոշում է, թե երկու տրված տողերից որը մյուսի ենթատողն է:\n    Եթե ոչ մի տող մյուսի ենթատողը չէ, վերադարձնում է \"No substring\":\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* প্রদত্ত দুটি স্ট্রিং এর মধ্যে কোনটি অন্যটির সাবস্ট্রিং তা নির্ধারণ করে।\n    যদি কোনটিই অন্যটির সাবস্ট্রিং না হয়, তাহলে এটি \"No substring\" রিটার্ন করে।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Определя коя от двете предоставени низове е подниз на другата.\n    Ако нито един от низовете не е подниз на другия, връща \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* 确定提供的两个字符串中哪个是另一个的子字符串。\n    如果两个字符串都不是另一个的子字符串，则返回 \"No substring\"。\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Détermine laquelle des deux chaînes fournies est une sous-chaîne de l'autre. \n    Si aucune des chaînes n'est une sous-chaîne de l'autre, elle renvoie \"Pas de sous-chaîne\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Bestimmt, welche der beiden bereitgestellten Zeichenfolgen eine Teilzeichenfolge der anderen ist.\n    Wenn keine der Zeichenfolgen eine Teilzeichenfolge der anderen ist, wird \"Keine Teilzeichenfolge\" zurückgegeben.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Yana tantance wanne daga cikin kirtani biyu da aka bayar yana cikin wani.\n    Idan babu ɗayansu da ke cikin wani, zai dawo da \"Babu substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Babu substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code yana cikin decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book yana cikin notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* यह निर्धारित करता है कि दिए गए दो स्ट्रिंग्स में से कौन सा दूसरे का सबस्ट्रिंग है।\n    यदि कोई भी स्ट्रिंग दूसरे का सबस्ट्रिंग नहीं है, तो यह \"No substring\" लौटाता है।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Meghatározza, hogy a két megadott string közül melyik a másik részstringje.\n    Ha egyik string sem részstringje a másiknak, akkor \"Nincs részstring\" értéket ad vissza.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)"
    },
    "prompt_bertscore": {
      "sq": "0.9934102384787865",
      "hy": "0.9883833007955556",
      "bn": "0.9931448682897239",
      "bg": "0.992536066171852",
      "zh": "0.9891158496408122",
      "fr": "0.999999801369619",
      "de": "0.9919771202796198",
      "ha": "0.9433520057415171",
      "hi": "0.9960111046880574",
      "hu": "0.9965420436965636"
    },
    "canonical_solution": "    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }",
    "instruction": {
      "en": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nՏվեք C# կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9364434424587427",
      "bn": "0.8711681362303905",
      "bg": "0.8379186022274364",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.8922885046458301",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CheckSubstring(\"apple\", \"pineapple\") == \"\\\"apple\\\" is substring of \\\"pineapple\\\"\");\n        Debug.Assert(CheckSubstring(\"star\", \"astrophysics\") == \"No substring\");\n        Debug.Assert(CheckSubstring(\"sun\", \"sunset\") == \"\\\"sun\\\" is substring of \\\"sunset\\\"\");\n        Debug.Assert(CheckSubstring(\"moon\", \"moonlight\") == \"\\\"moon\\\" is substring of \\\"moonlight\\\"\");\n\n\n    }\n}",
    "entry_point": "CheckSubstring",
    "signature": "static string CheckSubstring(string str1, string str2)",
    "docstring": {
      "en": "Determines which of the two provided strings is a substring of the other. \n    If neither string is a substring of the other, it returns \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "sq": "Përcakton se cila nga dy vargjet e dhëna është një nënvarg i tjetrit. \n    Nëse asnjë varg nuk është nënvarg i tjetrit, kthen \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code është nënvarg i decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book është nënvarg i notebook\"",
      "hy": "Սահմանում է, թե երկու տրված տողերից որը մյուսի ենթատողն է։ \n    Եթե ոչ մի տող մյուսի ենթատողը չէ, վերադարձնում է \"Ոչ մի ենթատող\"։\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Ոչ մի ենթատող\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code-ը decode-ի ենթատողն է\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book-ը notebook-ի ենթատողն է\"",
      "bn": "নির্ধারণ করে যে প্রদত্ত দুটি স্ট্রিংয়ের মধ্যে কোনটি অন্যটির সাবস্ট্রিং। \n    যদি কোন স্ট্রিংই অন্যটির সাবস্ট্রিং না হয়, তাহলে এটি \"No substring\" ফেরত দেয়।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "bg": "Определя коя от двете предоставени низове е подниз на другата. \nАко нито един от низовете не е подниз на другия, връща \"Няма подниз\".\n>>> CheckSubstring(\"hello\", \"world\")\n\"No substring\"\n>>> CheckSubstring(\"code\", \"decode\")\n\"code is substring of decode\"\n>>> CheckSubstring(\"book\", \"notebook\")\n\"book is substring of notebook\"",
      "zh": "确定提供的两个字符串中哪个是另一个的子字符串。\n    如果两个字符串都不是彼此的子字符串，则返回 \"No substring\"。\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "fr": "Détermine laquelle des deux chaînes fournies est une sous-chaîne de l'autre. \n    Si aucune des chaînes n'est une sous-chaîne de l'autre, elle renvoie \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "de": "Bestimmt, welche der beiden bereitgestellten Zeichenfolgen eine Teilzeichenfolge der anderen ist. \n    Wenn keine der beiden Zeichenfolgen eine Teilzeichenfolge der anderen ist, wird \"Keine Teilzeichenfolge\" zurückgegeben.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Keine Teilzeichenfolge\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code ist Teilzeichenfolge von decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book ist Teilzeichenfolge von notebook\"",
      "ha": "Yana tantance wanne daga cikin kirtani biyu da aka bayar shi ne kirtani na wani. \n    Idan babu wani kirtani da yake cikin wani, yana mayar da \"Babu kirtani\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Babu kirtani\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code yana cikin decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book yana cikin notebook\"",
      "hi": "निर्धारित करता है कि दिए गए दो स्ट्रिंग्स में से कौन सा दूसरे का उपस्ट्रिंग है। \n    यदि कोई भी स्ट्रिंग दूसरे का उपस्ट्रिंग नहीं है, तो यह \"No substring\" लौटाता है।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "hu": "Meghatározza, hogy a megadott két string közül melyik a másik részstringje. \n    Ha egyik string sem részstringje a másiknak, akkor \"Nincs részstring\" értéket ad vissza.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Nincs részstring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\""
    },
    "docstring_bertscore": {
      "sq": "0.9853937149305995",
      "hy": "0.9802676606872321",
      "bn": "0.994591691985182",
      "bg": "0.9955296246444288",
      "zh": "0.9831027121157431",
      "fr": "0.9895057610787837",
      "de": "0.9820726149596962",
      "ha": "0.9632343109919663",
      "hi": "0.994591691985182",
      "hu": "0.994591691985182"
    }
  },
  {
    "task_id": "C#/30",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Removes a specific suffix ('er', 'ly', or 'ing') from the given word if it ends with one of these suffixes. \n    The function ensures the remaining word is not empty.\n    Examples:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Heq një prapashtesë specifike ('er', 'ly', ose 'ing') nga fjala e dhënë nëse përfundon me njërën nga këto prapashtesa.\n    Funksioni siguron që fjala e mbetur të mos jetë bosh.\n    Shembuj:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Հեռացնում է հատուկ վերջածանց ('er', 'ly' կամ 'ing') տրված բառից, եթե այն ավարտվում է այդ վերջածանցներից մեկով։ \n    Ֆունկցիան ապահովում է, որ մնացած բառը դատարկ չլինի։\n    Օրինակներ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* প্রদত্ত শব্দের শেষ থেকে একটি নির্দিষ্ট উপসর্গ ('er', 'ly', বা 'ing') সরিয়ে দেয় যদি এটি এই উপসর্গগুলির একটির সাথে শেষ হয়।\n    ফাংশনটি নিশ্চিত করে যে অবশিষ্ট শব্দটি খালি নয়।\n    উদাহরণ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Премахва специфичен суфикс ('er', 'ly' или 'ing') от дадената дума, ако тя завършва с някой от тези суфикси.\n    Функцията осигурява, че останалата дума не е празна.\n    Примери:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 从给定的单词中移除特定的后缀（'er'，'ly'，或'ing'），如果它以这些后缀之一结尾。\n    该函数确保剩余的单词不为空。\n    示例：\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Supprime un suffixe spécifique ('er', 'ly', ou 'ing') du mot donné s'il se termine par l'un de ces suffixes. \n    La fonction s'assure que le mot restant n'est pas vide.\n    Exemples :\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Entfernt ein bestimmtes Suffix ('er', 'ly' oder 'ing') von dem gegebenen Wort, wenn es mit einem dieser Suffixe endet. \n    Die Funktion stellt sicher, dass das verbleibende Wort nicht leer ist.\n    Beispiele:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana cire wata takamaiman ƙari ('er', 'ly', ko 'ing') daga kalmar da aka bayar idan ta ƙare da ɗaya daga cikin waɗannan ƙarin. \n    Aikin yana tabbatar da cewa kalmar da ta rage ba ta zama babu komai ba.\n    Misalai:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दिए गए शब्द से एक विशिष्ट प्रत्यय ('er', 'ly', या 'ing') को हटाता है यदि यह इन प्रत्ययों में से किसी एक के साथ समाप्त होता है। \n    यह फ़ंक्शन सुनिश्चित करता है कि शेष शब्द खाली न हो।\n    उदाहरण:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Eltávolít egy adott utótagot ('er', 'ly' vagy 'ing') a megadott szóból, ha az egyik ilyen utótaggal végződik. \n    A függvény biztosítja, hogy a megmaradt szó ne legyen üres.\n    Példák:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)"
    },
    "prompt_bertscore": {
      "sq": "0.9973947639223464",
      "hy": "0.9934988276287281",
      "bn": "0.9859105511820523",
      "bg": "0.9973947639223464",
      "zh": "0.9888971575912928",
      "fr": "0.9973947639223464",
      "de": "0.9973947639223464",
      "ha": "0.9841345969452193",
      "hi": "0.9917173117412262",
      "hu": "0.990111186480178"
    },
    "canonical_solution": "{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}",
    "instruction": {
      "en": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nՏվեք C# կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\n提供一段中文的简洁自然语言描述（文档字符串），对该C#代码进行说明，字数不超过500个字符。",
      "fr": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a C# kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568463579378843",
      "hy": "0.9287852481179426",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8977005866378878",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9543420260937965",
      "hi": "0.9150793545657733",
      "hu": "0.9437490678732059"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(RemoveSuffix(\"happily\") == \"happi\");\n        Debug.Assert(RemoveSuffix(\"dancing\") == \"danc\");\n        Debug.Assert(RemoveSuffix(\"flower\") == \"flow\");\n        Debug.Assert(RemoveSuffix(\"computer\") == \"comput\");\n        Debug.Assert(RemoveSuffix(\"flying\") == \"fly\");\n        Debug.Assert(RemoveSuffix(\"ing\") == \"ing\");\n        Debug.Assert(RemoveSuffix(\"er\") == \"er\");\n    }\n}",
    "entry_point": "RemoveSuffix",
    "signature": "static string RemoveSuffix(string word)",
    "docstring": {
      "en": "Removes a specific suffix ('er', 'ly', or 'ing') from the given word if it ends with one of these suffixes. \n    The function ensures the remaining word is not empty.\n    Examples:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "sq": "Heq një prapashtesë specifike ('er', 'ly', ose 'ing') nga fjala e dhënë nëse përfundon me njërën nga këto prapashtesa. \n    Funksioni siguron që fjala e mbetur të mos jetë bosh.\n    Shembuj:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hy": "Հեռացնում է տրված բառի հատուկ վերջածանցը ('er', 'ly' կամ 'ing'), եթե այն ավարտվում է այդ վերջածանցներից մեկով:\n    Ֆունկցիան ապահովում է, որ մնացած բառը դատարկ չլինի:\n    Օրինակներ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "bn": "নির্দিষ্ট একটি প্রত্যয় ('er', 'ly', বা 'ing') সরিয়ে দেয় প্রদত্ত শব্দ থেকে যদি এটি এই প্রত্যয়গুলির একটির সাথে শেষ হয়। \n    ফাংশনটি নিশ্চিত করে যে অবশিষ্ট শব্দটি খালি নয়।\n    উদাহরণ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "bg": "Премахва конкретно окончание ('er', 'ly' или 'ing') от дадена дума, ако тя завършва с някое от тези окончания.\n    Функцията гарантира, че останалата дума не е празна.\n    Примери:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "zh": "移除给定单词中特定的后缀（'er'、'ly' 或 'ing'），如果它以这些后缀之一结尾。\n    该函数确保剩余的单词不为空。\n    示例：\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "fr": "Supprime un suffixe spécifique ('er', 'ly', ou 'ing') du mot donné s'il se termine par l'un de ces suffixes. \n    La fonction garantit que le mot restant n'est pas vide.\n    Exemples :\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "de": "Entfernt ein spezifisches Suffix ('er', 'ly' oder 'ing') aus dem gegebenen Wort, wenn es mit einem dieser Suffixe endet. \n    Die Funktion stellt sicher, dass das verbleibende Wort nicht leer ist.\n    Beispiele:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "ha": "Yana cire wani takamaiman ƙari ('er', 'ly', ko 'ing') daga kalmar da aka bayar idan ta ƙare da ɗaya daga cikin waɗannan ƙarin. \n    Aikin yana tabbatar da cewa kalmar da ta rage ba ta zama babu komai ba.\n    Misalai:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hi": "एक दिए गए शब्द से एक विशिष्ट प्रत्यय ('er', 'ly', या 'ing') को हटाता है यदि यह इन प्रत्ययों में से किसी एक के साथ समाप्त होता है। \n    यह फ़ंक्शन सुनिश्चित करता है कि शेष शब्द खाली न हो।\n    उदाहरण:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hu": "Eltávolít egy adott utótagot ('er', 'ly' vagy 'ing') a megadott szóból, ha az egyik ilyen utótaggal végződik. \n    A függvény biztosítja, hogy a megmaradt szó ne legyen üres.\n    Példák:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\""
    },
    "docstring_bertscore": {
      "sq": "0.9905722075945601",
      "hy": "0.9947498017684858",
      "bn": "0.9911021534511611",
      "bg": "0.9926534567270436",
      "zh": "0.9885380338623818",
      "fr": "0.9905722075945601",
      "de": "0.9973039898382134",
      "ha": "0.9838354595913807",
      "hi": "0.9883145746837175",
      "hu": "0.9846764606246825"
    }
  },
  {
    "task_id": "C#/31",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Finds the first longest and the first shortest word in a given sentence. \n    A word is defined as a continuous sequence of letters (A-Z, a-z), \n    and words are separated by spaces and commas. Quotation marks and other \n    punctuation are not part of the words.\n\n    Examples:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Gjen fjalën e parë më të gjatë dhe fjalën e parë më të shkurtër në një fjali të dhënë. \n    Një fjalë përcaktohet si një sekuencë e vazhdueshme shkronjash (A-Z, a-z), \n    dhe fjalët ndahen nga hapësirat dhe presjet. Thonjëzat dhe shenjat e tjera \n    të pikësimit nuk janë pjesë e fjalëve.\n\n    Shembuj:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Գտնում է տրված նախադասության առաջին ամենաերկար և առաջին ամենակարճ բառերը։ \n    Բառը սահմանվում է որպես անընդմեջ տառերի հաջորդականություն (A-Z, a-z), \n    և բառերը բաժանվում են բացատներով և ստորակետերով։ Մեջբերումները և այլ \n    կետադրական նշանները բառերի մաս չեն կազմում։\n\n    Օրինակներ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    প্রদত্ত বাক্যে প্রথম দীর্ঘতম এবং প্রথম সংক্ষিপ্ততম শব্দ খুঁজে বের করে। \n    একটি শব্দকে ধারাবাহিক অক্ষরের (A-Z, a-z) ক্রম হিসেবে সংজ্ঞায়িত করা হয়, \n    এবং শব্দগুলি স্পেস এবং কমা দ্বারা পৃথক করা হয়। উদ্ধৃতি চিহ্ন এবং অন্যান্য \n    বিরামচিহ্ন শব্দের অংশ নয়।\n\n    উদাহরণ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Намира първата най-дълга и първата най-къса дума в дадено изречение. \n    Думата се дефинира като непрекъсната последователност от букви (A-Z, a-z), \n    а думите са разделени с интервали и запетаи. Кавичките и другите \n    пунктуационни знаци не са част от думите.\n\n    Примери:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    找到给定句子中第一个最长和第一个最短的单词。\n    单词被定义为连续的字母序列 (A-Z, a-z)，\n    单词之间由空格和逗号分隔。引号和其他\n    标点符号不属于单词的一部分。\n\n    示例:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Trouve le premier mot le plus long et le premier mot le plus court dans une phrase donnée. \n    Un mot est défini comme une séquence continue de lettres (A-Z, a-z), \n    et les mots sont séparés par des espaces et des virgules. Les guillemets et autres \n    signes de ponctuation ne font pas partie des mots.\n\n    Exemples :\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Findet das erste längste und das erste kürzeste Wort in einem gegebenen Satz.\n    Ein Wort wird als eine kontinuierliche Folge von Buchstaben (A-Z, a-z) definiert,\n    und Wörter werden durch Leerzeichen und Kommas getrennt. Anführungszeichen und andere\n    Satzzeichen sind nicht Teil der Wörter.\n\n    Beispiele:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Nemi kalmar da tafi tsawo da kuma kalmar da tafi guntuwa a cikin wata jimla da aka bayar.\n    Ana ayyana kalma a matsayin jerin haruffa masu ci gaba (A-Z, a-z),\n    kuma ana raba kalmomi ta wurin sarari da kuma alamar rubutu. Alamomin magana da sauran\n    alamomin rubutu ba su cikin kalmomi.\n\n    Misalai:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    दिए गए वाक्य में पहला सबसे लंबा और पहला सबसे छोटा शब्द खोजता है।\n    एक शब्द को अक्षरों (A-Z, a-z) के निरंतर अनुक्रम के रूप में परिभाषित किया गया है,\n    और शब्दों को रिक्त स्थान और अल्पविराम द्वारा अलग किया जाता है। उद्धरण चिह्न और अन्य\n    विराम चिह्न शब्दों का हिस्सा नहीं हैं।\n\n    उदाहरण:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Megkeresi az első leghosszabb és az első legrövidebb szót egy adott mondatban. \n    Egy szó folyamatos betűsorozatként van meghatározva (A-Z, a-z), \n    és a szavakat szóközök és vesszők választják el egymástól. Az idézőjelek és más \n    írásjelek nem részei a szavaknak.\n\n    Példák:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)"
    },
    "prompt_bertscore": {
      "sq": "0.991875620154911",
      "hy": "0.9867221549189609",
      "bn": "0.9862466337867634",
      "bg": "0.9974275379352172",
      "zh": "0.969921798660649",
      "fr": "0.9922508329446859",
      "de": "0.9974275379352172",
      "ha": "0.9647824361817523",
      "hi": "0.9937922047015166",
      "hu": "0.9974275379352172"
    },
    "canonical_solution": "    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }",
    "instruction": {
      "en": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nՏվեք C# կոդի հակիրճ նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 символа.",
      "zh": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na C# cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9380769787123736",
      "hy": "0.9340356449798378",
      "bn": "0.8913843391513593",
      "bg": "0.831676443873034",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.8412067295550879",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindLongestAndShortestWord(\"Fast cars, smooth drives\") == (\"smooth\", \"Fast\"));\n        Debug.Assert(FindLongestAndShortestWord(\"Sunshine brings happiness\") == (\"happiness\", \"brings\"));\n        Debug.Assert(FindLongestAndShortestWord(\"A\") == (\"A\", \"A\")); // Edge case: Only one word\n        Debug.Assert(FindLongestAndShortestWord(\"Every cloud has a silver lining\") == (\"silver\", \"a\"));\n\n\n    }\n}",
    "entry_point": "FindLongestAndShortestWord",
    "signature": "static (string, string) FindLongestAndShortestWord(string sentence)",
    "docstring": {
      "en": "Finds the first longest and the first shortest word in a given sentence. \n    A word is defined as a continuous sequence of letters (A-Z, a-z), \n    and words are separated by spaces and commas. Quotation marks and other \n    punctuation are not part of the words.\n\n    Examples:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "sq": "Gjen fjalën e parë më të gjatë dhe fjalën e parë më të shkurtër në një fjali të dhënë. \n    Një fjalë përcaktohet si një sekuencë e vazhdueshme e shkronjave (A-Z, a-z), \n    dhe fjalët ndahen nga hapësirat dhe presjet. Thonjëzat dhe shenjat e tjera \n    të pikësimit nuk janë pjesë e fjalëve.\n\n    Shembuj:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hy": "Գտնում է տրված նախադասության առաջին ամենաերկար և առաջին ամենակարճ բառերը։ \n    Բառը սահմանվում է որպես տառերի (A-Z, a-z) շարունակական հաջորդականություն, \n    իսկ բառերը բաժանվում են բացատներով և ստորակետերով։ Մեջբերումները և այլ \n    կետադրական նշանները չեն համարվում բառերի մաս։\n\n    Օրինակներ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "bn": "প্রদত্ত বাক্যে প্রথম দীর্ঘতম এবং প্রথম সংক্ষিপ্ততম শব্দ খুঁজে বের করে। \n    একটি শব্দকে সংজ্ঞায়িত করা হয় একটি অবিচ্ছিন্ন অক্ষরের ক্রম (A-Z, a-z) হিসাবে, \n    এবং শব্দগুলি স্পেস এবং কমা দ্বারা পৃথক করা হয়। উদ্ধৃতি চিহ্ন এবং অন্যান্য \n    বিরামচিহ্ন শব্দের অংশ নয়।\n\n    উদাহরণ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "bg": "Намира първата най-дълга и първата най-къса дума в дадено изречение. \n    Думата се определя като непрекъсната последователност от букви (A-Z, a-z), \n    а думите се разделят с интервали и запетаи. Кавичките и другите \n    пунктуационни знаци не са част от думите.\n\n    Примери:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "zh": "找到给定句子中第一个最长和第一个最短的单词。\n    单词被定义为连续的字母序列（A-Z, a-z），\n    单词由空格和逗号分隔。引号和其他标点符号不属于单词的一部分。\n\n    示例：\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "fr": "Trouve le premier mot le plus long et le premier mot le plus court dans une phrase donnée. \n    Un mot est défini comme une séquence continue de lettres (A-Z, a-z), \n    et les mots sont séparés par des espaces et des virgules. Les guillemets et autres \n    signes de ponctuation ne font pas partie des mots.\n\n    Exemples :\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "de": "Findet das erste längste und das erste kürzeste Wort in einem gegebenen Satz. \n    Ein Wort wird als eine kontinuierliche Sequenz von Buchstaben (A-Z, a-z) definiert, \n    und Wörter werden durch Leerzeichen und Kommas getrennt. Anführungszeichen und andere \n    Satzzeichen sind nicht Teil der Wörter.\n\n    Beispiele:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "ha": "Yana nemo kalma mafi tsawo da kuma kalma mafi gajarta a cikin wata jimla da aka bayar. \n    Ana ayyana kalma a matsayin jerin haruffa masu ci gaba (A-Z, a-z), \n    kuma kalmomi suna rabuwa da sarari da kuma alamar rubutu. Alamomin magana da sauran \n    alamomin rubutu ba sa cikin kalmomin.\n\n    Misalai:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hi": "पहले सबसे लंबा और पहले सबसे छोटा शब्द किसी दिए गए वाक्य में खोजता है। \n    एक शब्द को अक्षरों (A-Z, a-z) के निरंतर अनुक्रम के रूप में परिभाषित किया गया है, \n    और शब्दों को स्पेस और कॉमा द्वारा अलग किया जाता है। उद्धरण चिह्न और अन्य \n    विराम चिह्न शब्दों का हिस्सा नहीं होते हैं।\n\n    उदाहरण:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hu": "Megtalálja az első leghosszabb és az első legrövidebb szót egy adott mondatban. \n    Egy szó folyamatos betűsorozatként van definiálva (A-Z, a-z), \n    és a szavakat szóközök és vesszők választják el egymástól. Az idézőjelek és más \n    írásjelek nem részei a szavaknak.\n\n    Példák:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")"
    },
    "docstring_bertscore": {
      "sq": "0.98448021380822",
      "hy": "0.9774131434813798",
      "bn": "0.9795515981636014",
      "bg": "0.9974793804646672",
      "zh": "0.9774753147906436",
      "fr": "0.9892880621811695",
      "de": "0.9974793804646672",
      "ha": "0.9726903089115132",
      "hi": "0.9938003485471391",
      "hu": "0.993304567116076"
    }
  },
  {
    "task_id": "C#/32",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calculate the speed of a vehicle and the next palindromic number on the odometer.\n     Given the current palindromic odometer reading and the time elapsed in hours, \n     find the constant speed of the vehicle and the next palindromic odometer reading.\n     The speed is calculated per hour.\n     Example:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Llogarit shpejtësinë e një automjeti dhe numrin e ardhshëm palindromik në odometër.\n     Duke pasur parasysh leximin aktual palindromik të odometrit dhe kohën e kaluar në orë,\n     gjeni shpejtësinë konstante të automjetit dhe leximin e ardhshëm palindromik të odometrit.\n     Shpejtësia llogaritet për orë.\n     Shembull:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Հաշվարկել մեքենայի արագությունը և հաջորդ պալինդրոմիկ թիվը հաշվիչի վրա։\n     Տրված է ընթացիկ պալինդրոմիկ հաշվիչի ընթերցումը և անցած ժամանակը ժամերով,\n     գտնել մեքենայի հաստատուն արագությունը և հաջորդ պալինդրոմիկ հաշվիչի ընթերցումը։\n     Արագությունը հաշվարկվում է ժամում։\n     Օրինակ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* একটি যানবাহনের গতি এবং ওডোমিটারে পরবর্তী পালিনড্রোমিক সংখ্যা গণনা করুন।\n     বর্তমান পালিনড্রোমিক ওডোমিটার রিডিং এবং ঘন্টায় অতিক্রান্ত সময় দেওয়া আছে,\n     যানবাহনের ধ্রুবক গতি এবং পরবর্তী পালিনড্রোমিক ওডোমিটার রিডিং খুঁজে বের করুন।\n     গতি প্রতি ঘন্টায় গণনা করা হয়।\n     উদাহরণ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Изчислете скоростта на превозно средство и следващото палиндромно число на километража.\n     Като се даде текущото палиндромно показание на километража и изминалото време в часове,\n     намерете постоянната скорост на превозното средство и следващото палиндромно показание на километража.\n     Скоростта се изчислява на час.\n     Пример:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 计算车辆的速度和里程表上的下一个回文数。\n     给定当前回文的里程表读数和经过的时间（小时），\n     找出车辆的恒定速度和下一个回文的里程表读数。\n     速度按每小时计算。\n     示例:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calculer la vitesse d'un véhicule et le prochain nombre palindromique sur l'odomètre.\n     Étant donné la lecture actuelle de l'odomètre palindromique et le temps écoulé en heures,\n     trouver la vitesse constante du véhicule et la prochaine lecture palindromique de l'odomètre.\n     La vitesse est calculée par heure.\n     Exemple :\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Berechne die Geschwindigkeit eines Fahrzeugs und die nächste palindromische Zahl auf dem Kilometerzähler.\n     Gegeben ist der aktuelle palindromische Kilometerzählerstand und die verstrichene Zeit in Stunden,\n     finde die konstante Geschwindigkeit des Fahrzeugs und den nächsten palindromischen Kilometerzählerstand.\n     Die Geschwindigkeit wird pro Stunde berechnet.\n     Beispiel:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Lissafi gudun abin hawa da kuma lambar palindrome mai zuwa a kan odometer.\n     An ba da karatun odometer palindrome na yanzu da kuma lokacin da ya wuce a cikin sa'o'i,\n     nemo gudun daidaitaccen na abin hawa da kuma karatun odometer palindrome mai zuwa.\n     Ana lissafin gudun a kowane awa.\n     Misali:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* एक वाहन की गति और ओडोमीटर पर अगली पलिंड्रोमिक संख्या की गणना करें।\n     दिए गए वर्तमान पलिंड्रोमिक ओडोमीटर रीडिंग और बीते हुए समय (घंटों में),\n     वाहन की स्थिर गति और अगली पलिंड्रोमिक ओडोमीटर रीडिंग का पता लगाएं।\n     गति प्रति घंटे की गणना की जाती है।\n     उदाहरण:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Számítsa ki egy jármű sebességét és a következő palindromikus számot a kilométerórán.\n     Adott a jelenlegi palindromikus kilométeróra állás és az eltelt idő órákban,\n     találja meg a jármű állandó sebességét és a következő palindromikus kilométeróra állást.\n     A sebesség óránként kerül kiszámításra.\n     Példa:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)"
    },
    "prompt_bertscore": {
      "sq": "0.9824071085213589",
      "hy": "0.9911951124694854",
      "bn": "0.9955407479457667",
      "bg": "0.9802116469197802",
      "zh": "0.9673592681149179",
      "fr": "0.9985372858740591",
      "de": "0.9985372858740591",
      "ha": "0.9735098578636632",
      "hi": "0.9910681876560041",
      "hu": "0.9923737851505465"
    },
    "canonical_solution": "{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "instruction": {
      "en": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nՏրամադրել կարճ բնական լեզվով նկարագրություն (docstring) այս C# կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568463579378843",
      "hy": "0.9235940431095958",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CalculateSpeedAndNextPalindrome(12321, 2) == (50, 12421));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(11111, 1) == (100, 11211));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(23332, 2) == (50, 23432));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(45654, 4) == (25, 45754));\n\n    }\n}",
    "entry_point": "CalculateSpeedAndNextPalindrome",
    "signature": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
    "docstring": {
      "en": "Calculate the speed of a vehicle and the next palindromic number on the odometer.\n     Given the current palindromic odometer reading and the time elapsed in hours, \n     find the constant speed of the vehicle and the next palindromic odometer reading.\n     The speed is calculated per hour.\n     Example:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "sq": "Llogaritni shpejtësinë e një automjeti dhe numrin e ardhshëm palindromik në odometër.\n     Duke pasur parasysh leximin aktual palindromik të odometrit dhe kohën e kaluar në orë,\n     gjeni shpejtësinë konstante të automjetit dhe leximin e ardhshëm palindromik të odometrit.\n     Shpejtësia llogaritet për orë.\n     Shembull:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "hy": "Հաշվարկել տրանսպորտային միջոցի արագությունը և հաջորդ պալինդրոմային թիվը օդոմետրին:\n     Տրված է ընթացիկ պալինդրոմային օդոմետրային ցուցիչը և անցած ժամանակը ժամերով, \n     գտնել տրանսպորտային միջոցի հաստատուն արագությունը և հաջորդ պալինդրոմային օդոմետրային ցուցիչը:\n     Արագությունը հաշվարկվում է ժամում:\n     Օրինակ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "bn": "যানবাহনের গতি এবং ওডোমিটারে পরবর্তী প্যালিনড্রোমিক সংখ্যা গণনা করুন। \n     বর্তমান প্যালিনড্রোমিক ওডোমিটার রিডিং এবং অতিবাহিত সময় ঘণ্টায় দেওয়া হলে, \n     যানবাহনের ধ্রুবক গতি এবং পরবর্তী প্যালিনড্রোমিক ওডোমিটার রিডিং খুঁজে বের করুন। \n     গতি প্রতি ঘণ্টায় গণনা করা হয়।\n     উদাহরণ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "bg": "Изчислете скоростта на превозно средство и следващото палиндромно число на километража.\n     Като се даде текущото палиндромно показание на километража и изминалото време в часове,\n     намерете постоянната скорост на превозното средство и следващото палиндромно показание на километража.\n     Скоростта се изчислява на час.\n     Пример:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "zh": "计算车辆的速度和里程表上的下一个回文数。\n     给定当前回文里程表读数和经过的时间（小时），\n     找到车辆的恒定速度和下一个回文里程表读数。\n     速度以每小时计算。\n     示例：\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "fr": "Calculer la vitesse d'un véhicule et le prochain nombre palindrome sur l'odomètre.\n     Étant donné la lecture actuelle de l'odomètre palindromique et le temps écoulé en heures,\n     trouver la vitesse constante du véhicule et la prochaine lecture palindromique de l'odomètre.\n     La vitesse est calculée par heure.\n     Exemple:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "de": "Berechne die Geschwindigkeit eines Fahrzeugs und die nächste palindromische Zahl auf dem Kilometerzähler.\n     Gegeben ist der aktuelle palindromische Kilometerzählerstand und die vergangene Zeit in Stunden,\n     finde die konstante Geschwindigkeit des Fahrzeugs und den nächsten palindromischen Kilometerzählerstand.\n     Die Geschwindigkeit wird pro Stunde berechnet.\n     Beispiel:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "ha": "Ƙididdige saurin abin hawa da lambar palindrome ta gaba akan odometer.  \n     An ba da karatun palindrome na yanzu na odometer da kuma lokacin da ya shige a cikin sa'o'i,  \n     nemo saurin dindindin na abin hawa da karatun palindrome na gaba akan odometer.  \n     Ana ƙididdige saurin a kowane awa.  \n     Misali:  \n     >>> CalculateSpeedAndNextPalindrome(12321, 2)  \n     (50, 12421)  \n     >>> CalculateSpeedAndNextPalindrome(23332, 4)  \n     (25, 23432)  ",
      "hi": "वाहन की गति और ओडोमीटर पर अगली पालिंड्रोमिक संख्या की गणना करें।\n     दिए गए वर्तमान पालिंड्रोमिक ओडोमीटर रीडिंग और बीते हुए समय (घंटों में) के आधार पर,\n     वाहन की स्थिर गति और अगली पालिंड्रोमिक ओडोमीटर रीडिंग खोजें।\n     गति प्रति घंटे की गणना की जाती है।\n     उदाहरण:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "hu": "Számítsa ki egy jármű sebességét és a következő palindromikus számot az odométeren.\n     Adott a jelenlegi palindromikus odométer állás és az eltelt idő órákban, \n     találja meg a jármű állandó sebességét és a következő palindromikus odométer állást.\n     A sebesség óránként van kiszámítva.\n     Példa:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)"
    },
    "docstring_bertscore": {
      "sq": "0.9794342076084097",
      "hy": "0.9959596594193694",
      "bn": "0.9959596594193694",
      "bg": "0.9794342076084097",
      "zh": "0.9658957594674528",
      "fr": "0.9917437295819038",
      "de": "0.9983962583035243",
      "ha": "0.9702358332930651",
      "hi": "0.9783127404770867",
      "hu": "0.9983962583035243"
    }
  },
  {
    "task_id": "C#/33",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds all automorphic numbers within a specified limit.\n    An automorphic number is a number whose square ends in the number itself.\n    Examples:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Gjen të gjitha numrat automorfikë brenda një kufiri të specifikuar.\n    Një numër automorfik është një numër katrori i të cilit përfundon me vetë numrin.\n    Shembuj:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Գտնում է բոլոր ավտոմորֆ թվերը նշված սահմանաչափի սահմաններում։\n    Ավտոմորֆ թիվը այն թիվն է, որի քառակուսին ավարտվում է հենց այդ թվով։\n    Օրինակներ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* নির্দিষ্ট সীমার মধ্যে সমস্ত অটোমরফিক সংখ্যা খুঁজে বের করে।\n    একটি অটোমরফিক সংখ্যা হল এমন একটি সংখ্যা যার বর্গ শেষ হয় সংখ্যাটির মধ্যেই।\n    উদাহরণ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Намира всички автоморфни числа до определен лимит.\n    Автоморфно число е число, чийто квадрат завършва със самото число.\n    Примери:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 查找指定范围内的所有自守数。\n    自守数是其平方的末尾部分与该数本身相同的数。\n    例子：\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Trouve tous les nombres automorphes dans une limite spécifiée.\n    Un nombre automorphe est un nombre dont le carré se termine par le nombre lui-même.\n    Exemples :\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Findet alle automorphen Zahlen innerhalb eines angegebenen Limits.\n    Eine automorphe Zahl ist eine Zahl, deren Quadrat in der Zahl selbst endet.\n    Beispiele:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Nemi duk lambobin automorphic cikin iyaka da aka kayyade.\n    Lamba mai automorphic ita ce lamba da murdaddiyar ta ke ƙarewa da kanta.\n    Misalai:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* एक निर्दिष्ट सीमा के भीतर सभी स्वयंसिद्ध संख्याएँ खोजता है।\n    एक स्वयंसिद्ध संख्या वह संख्या होती है जिसका वर्ग संख्या के अंत में होता है।\n    उदाहरण:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megtalálja az összes automorf számot egy megadott határon belül.\n    Egy automorf szám olyan szám, amelynek a négyzete a számmal végződik.\n    Példák:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)"
    },
    "prompt_bertscore": {
      "sq": "0.9982792650090948",
      "hy": "0.9952817339288973",
      "bn": "0.9899953849680347",
      "bg": "0.9849207759933555",
      "zh": "0.9837464731806772",
      "fr": "0.9982792650090948",
      "de": "0.9946761098971219",
      "ha": "0.9929732516405098",
      "hi": "0.9973053802508807",
      "hu": "0.9929464365390701"
    },
    "canonical_solution": "{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}",
    "instruction": {
      "en": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nՏվեք C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 символа.",
      "zh": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nFournir une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.948868567313999",
      "bn": "0.8778230485165833",
      "bg": "0.831676443873034",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9243830029830663",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n     Debug.Assert(FindAutomorphicNumbers(100).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76 }));\n    Debug.Assert(FindAutomorphicNumbers(500).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376 }));\n    Debug.Assert(FindAutomorphicNumbers(1000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625 }));\n    Debug.Assert(FindAutomorphicNumbers(200000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625,9376, 90625, 109376 }));\n\n    }\n}",
    "entry_point": "FindAutomorphicNumbers",
    "signature": "static List<int> FindAutomorphicNumbers(int limit)",
    "docstring": {
      "en": "Finds all automorphic numbers within a specified limit.\n    An automorphic number is a number whose square ends in the number itself.\n    Examples:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "sq": "Gjen të gjitha numrat automorfikë brenda një kufiri të specifikuar.\n    Një numër automorfik është një numër katrori i të cilit përfundon me vetë numrin.\n    Shembuj:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "hy": "Գտնում է բոլոր ավտոմորֆ թվերը նշված սահմանաչափի մեջ:  \n    Ավտոմորֆ թիվը թիվ է, որի քառակուսին ավարտվում է հենց այդ թվով:  \n    Օրինակներ:  \n    >>> FindAutomorphicNumbers(100)  \n    [0, 1, 5, 6, 25, 76]  \n    >>> FindAutomorphicNumbers(500)  \n    [0, 1, 5, 6, 25, 76, 376]",
      "bn": "নির্দিষ্ট সীমার মধ্যে সমস্ত অটোমরফিক সংখ্যা খুঁজে বের করে।\n    একটি অটোমরফিক সংখ্যা হল এমন একটি সংখ্যা যার বর্গ শেষ হয় সংখ্যাটির সাথে।\n    উদাহরণস্বরূপ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "bg": "Намира всички автоморфни числа в рамките на определен лимит.  \nАвтоморфно число е число, чийто квадрат завършва със самото число.  \nПримери:  \n>>> FindAutomorphicNumbers(100)  \n[0, 1, 5, 6, 25, 76]  \n>>> FindAutomorphicNumbers(500)  \n[0, 1, 5, 6, 25, 76, 376]",
      "zh": "查找指定范围内的所有自守数。\n    自守数是其平方以该数字本身结尾的数字。\n    示例：\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "fr": "Trouve tous les nombres automorphes dans une limite spécifiée.\n    Un nombre automorphe est un nombre dont le carré se termine par le nombre lui-même.\n    Exemples :\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "de": "Findet alle automorphen Zahlen innerhalb eines angegebenen Limits.\n    Eine automorphe Zahl ist eine Zahl, deren Quadrat mit der Zahl selbst endet.\n    Beispiele:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "ha": "Yana nemo duk lambobin automorphic a cikin iyaka da aka ayyana.\n    Lambar automorphic ita ce lamba wadda ƙarshen murabba'inta ya ƙare da lambar kanta.\n    Misalai:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "hi": "निर्दिष्ट सीमा के भीतर सभी स्वयंसिद्ध संख्याएँ खोजता है।\n    एक स्वयंसिद्ध संख्या वह संख्या होती है जिसका वर्ग उसी संख्या पर समाप्त होता है।\n    उदाहरण:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "hu": "Megtalálja az összes automorf számot egy megadott határon belül.\n    Egy automorf szám olyan szám, amelynek négyzete a számmal végződik.\n    Példák:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]"
    },
    "docstring_bertscore": {
      "sq": "0.98785633439467",
      "hy": "0.9878543480908597",
      "bn": "0.9702199428625823",
      "bg": "0.9822001356643205",
      "zh": "0.9782293157170521",
      "fr": "0.98785633439467",
      "de": "0.9926435252079919",
      "ha": "0.9849656664594693",
      "hi": "0.9695789626229827",
      "hu": "0.9822001356643205"
    }
  },
  {
    "task_id": "C#/34",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determine the last remaining person's number in a circular counting game.\n   In this game, people are numbered from 1 to totalPeople and sit in a circle. \n   Starting with the first person, they count from 1 to countNumber. \n   The person who is at countNumber is removed from the circle, \n   and the count resumes from the next person. \n   This process continues until only one person remains.\n\n   Example:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcaktoni numrin e personit të fundit të mbetur në një lojë numërimi rrethore.\n   Në këtë lojë, njerëzit janë të numëruar nga 1 deri në totalPeople dhe ulen në një rreth. \n   Duke filluar me personin e parë, ata numërojnë nga 1 deri në countNumber. \n   Personi që është në countNumber hiqet nga rrethi, \n   dhe numërimi vazhdon nga personi tjetër. \n   Ky proces vazhdon derisa të mbetet vetëm një person.\n\n   Shembull:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշել վերջին մնացած անձի համարը շրջանաձև հաշվարկի խաղում:\n   Այս խաղում մարդիկ համարակալված են 1-ից մինչև totalPeople և նստած են շրջանաձև: \n   Սկսելով առաջին մարդուց, նրանք հաշվում են 1-ից մինչև countNumber: \n   countNumber-ի վրա գտնվող անձը հեռացվում է շրջանից, \n   և հաշվարկը վերսկսվում է հաջորդ մարդուց: \n   Այս գործընթացը շարունակվում է, մինչև միայն մեկ մարդ մնա:\n\n   Օրինակ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি বৃত্তাকার গণনা গেমে শেষ অবশিষ্ট ব্যক্তির সংখ্যা নির্ধারণ করুন।\n   এই গেমে, মানুষদের 1 থেকে totalPeople পর্যন্ত নম্বর দেওয়া হয় এবং তারা একটি বৃত্তে বসে। \n   প্রথম ব্যক্তির সাথে শুরু করে, তারা 1 থেকে countNumber পর্যন্ত গণনা করে। \n   যে ব্যক্তি countNumber এ থাকে তাকে বৃত্ত থেকে সরিয়ে দেওয়া হয়, \n   এবং গণনা পরবর্তী ব্যক্তি থেকে পুনরায় শুরু হয়। \n   এই প্রক্রিয়া চলতে থাকে যতক্ষণ না শুধুমাত্র একজন ব্যক্তি অবশিষ্ট থাকে।\n\n   উদাহরণ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определете номера на последния останал човек в игра на броене по кръг.\n   В тази игра хората са номерирани от 1 до totalPeople и седят в кръг. \n   Започвайки с първия човек, те броят от 1 до countNumber. \n   Човекът, който е на countNumber, се премахва от кръга, \n   и броенето продължава от следващия човек. \n   Този процес продължава, докато остане само един човек.\n\n   Пример:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定在一个循环计数游戏中最后剩下的人的编号。\n   在这个游戏中，人们从1到totalPeople编号并坐成一个圈。\n   从第一个人开始，他们从1数到countNumber。\n   在countNumber的人将被从圈中移除，\n   计数从下一个人继续。\n   这个过程持续到只剩下一个人为止。\n\n   示例:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Déterminer le numéro de la dernière personne restante dans un jeu de comptage circulaire.\n   Dans ce jeu, les personnes sont numérotées de 1 à totalPeople et s'assoient en cercle.\n   En commençant par la première personne, elles comptent de 1 à countNumber.\n   La personne qui est à countNumber est retirée du cercle,\n   et le comptage reprend à partir de la personne suivante.\n   Ce processus continue jusqu'à ce qu'il ne reste qu'une seule personne.\n\n   Exemple:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimme die Nummer der letzten verbleibenden Person in einem kreisförmigen Zählspiel.\n   In diesem Spiel sind die Personen von 1 bis totalPeople nummeriert und sitzen im Kreis.\n   Beginnend mit der ersten Person zählen sie von 1 bis countNumber.\n   Die Person, die bei countNumber ist, wird aus dem Kreis entfernt,\n   und das Zählen wird von der nächsten Person fortgesetzt.\n   Dieser Prozess wird fortgesetzt, bis nur noch eine Person übrig bleibt.\n\n   Beispiel:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tantance lambar mutum na ƙarshe da ya rage a cikin wasan ƙidaya mai zagaye.\n   A cikin wannan wasan, an ba mutane lambobi daga 1 zuwa totalPeople kuma suna zaune a cikin da'ira. \n   Fara da mutum na farko, suna ƙidaya daga 1 zuwa countNumber. \n   Mutumin da yake a countNumber za a cire shi daga cikin da'ira, \n   kuma ƙidayar tana ci gaba daga mutumin na gaba. \n   Wannan tsari yana ci gaba har sai mutum guda ɗaya ya rage.\n\n   Misali:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* एक वृत्ताकार गिनती खेल में अंतिम बचे व्यक्ति की संख्या निर्धारित करें।\n   इस खेल में, लोगों को 1 से totalPeople तक संख्या दी जाती है और वे एक वृत्त में बैठते हैं। \n   पहले व्यक्ति से शुरू होकर, वे 1 से countNumber तक गिनते हैं। \n   जो व्यक्ति countNumber पर होता है उसे वृत्त से हटा दिया जाता है, \n   और गिनती अगले व्यक्ति से फिर से शुरू होती है। \n   यह प्रक्रिया तब तक जारी रहती है जब तक केवल एक व्यक्ति नहीं बचता।\n\n   उदाहरण:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Határozza meg az utolsó megmaradt személy számát egy körkörös számolós játékban.\n   Ebben a játékban az emberek 1-től totalPeople-ig vannak számozva és körben ülnek.\n   Az első személlyel kezdve 1-től countNumber-ig számolnak.\n   Az a személy, aki a countNumber-nél van, kikerül a körből,\n   és a számolás a következő személynél folytatódik.\n   Ez a folyamat addig folytatódik, amíg csak egy személy marad.\n\n   Példa:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)"
    },
    "prompt_bertscore": {
      "sq": "0.9878853344303011",
      "hy": "0.9868411345172007",
      "bn": "0.9907672626287364",
      "bg": "0.9878295192932304",
      "zh": "0.9767801084570216",
      "fr": "0.9926987444539196",
      "de": "0.982737828105782",
      "ha": "0.9864299696284585",
      "hi": "0.9855764548811516",
      "hu": "0.986785716640892"
    },
    "canonical_solution": "{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}",
    "instruction": {
      "en": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nՏրամադրել կարճ բնական լեզվով նկարագրություն (docstring) տվյալ C# կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.8875539508834825",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9252758465458182",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(LastRemainingPerson(5, 2) == 3);\n        Debug.Assert(LastRemainingPerson(6, 4) == 5);\n        Debug.Assert(LastRemainingPerson(10, 3) == 4);\n        Debug.Assert(LastRemainingPerson(7, 2) == 7);\n\n    }\n}",
    "entry_point": "LastRemainingPerson",
    "signature": "static int LastRemainingPerson(int totalPeople, int countNumber)",
    "docstring": {
      "en": "Determine the last remaining person's number in a circular counting game.\n   In this game, people are numbered from 1 to totalPeople and sit in a circle. \n   Starting with the first person, they count from 1 to countNumber. \n   The person who is at countNumber is removed from the circle, \n   and the count resumes from the next person. \n   This process continues until only one person remains.\n\n   Example:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "sq": "Përcaktoni numrin e personit të fundit të mbetur në një lojë numërimi rrethore. \n   Në këtë lojë, njerëzit janë të numëruar nga 1 deri në totalPeople dhe ulen në një rreth. \n   Duke filluar me personin e parë, ata numërojnë nga 1 deri në countNumber. \n   Personi që është në countNumber hiqet nga rrethi, \n   dhe numërimi vazhdon nga personi i ardhshëm. \n   Ky proces vazhdon derisa të mbetet vetëm një person.\n\n   Shembull:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hy": "Վերջին մնացած անձի համարը որոշեք շրջանաձև հաշվարկի խաղում։  \n   Այս խաղում մարդիկ համարակալված են 1-ից մինչև totalPeople և նստած են շրջանաձև։  \n   Սկսելով առաջին մարդուց, նրանք հաշվում են 1-ից մինչև countNumber։  \n   countNumber-ի վրա գտնվող անձը հեռացվում է շրջանից,  \n   և հաշվարկը վերսկսվում է հաջորդ մարդուց։  \n   Այս գործընթացը շարունակվում է մինչև միայն մեկ մարդ մնա։\n\n   Օրինակ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "bn": "একটি বৃত্তাকার গণনা খেলায় শেষ অবশিষ্ট ব্যক্তির সংখ্যা নির্ধারণ করুন।\n   এই খেলায়, মানুষদের 1 থেকে totalPeople পর্যন্ত সংখ্যা দেওয়া হয় এবং তারা একটি বৃত্তে বসে। \n   প্রথম ব্যক্তি থেকে শুরু করে, তারা 1 থেকে countNumber পর্যন্ত গণনা করে। \n   যে ব্যক্তি countNumber এ থাকে তাকে বৃত্ত থেকে সরিয়ে দেওয়া হয়, \n   এবং গণনা পরবর্তী ব্যক্তি থেকে পুনরায় শুরু হয়। \n   এই প্রক্রিয়া চলতে থাকে যতক্ষণ না শুধুমাত্র একজন ব্যক্তি অবশিষ্ট থাকে।\n\n   উদাহরণ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "bg": "Определете номера на последния останал човек в игра на броене в кръг.\n   В тази игра хората са номерирани от 1 до totalPeople и седят в кръг.\n   Започвайки с първия човек, те броят от 1 до countNumber.\n   Човекът, който е на countNumber, се премахва от кръга,\n   и броенето продължава от следващия човек.\n   Този процес продължава, докато остане само един човек.\n\n   Пример:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "zh": "确定在一个循环计数游戏中最后剩下的人的编号。\n在这个游戏中，人们从1到totalPeople编号并围坐成一个圆圈。\n从第一个人开始，他们从1数到countNumber。\n在countNumber的那个人将被从圆圈中移除，\n计数从下一个人继续。\n这个过程持续进行，直到只剩下一个人。\n\n示例：\n>>> LastRemainingPerson(5, 2)\n3\n>>> LastRemainingPerson(6, 4)\n5",
      "fr": "Déterminer le numéro de la dernière personne restante dans un jeu de comptage circulaire.  \n   Dans ce jeu, les personnes sont numérotées de 1 à totalPeople et sont assises en cercle.  \n   En commençant par la première personne, elles comptent de 1 à countNumber.  \n   La personne qui est à countNumber est retirée du cercle,  \n   et le comptage reprend à partir de la personne suivante.  \n   Ce processus continue jusqu'à ce qu'il ne reste qu'une seule personne.\n\n   Exemple :\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "de": "Bestimme die Nummer der letzten verbleibenden Person in einem kreisförmigen Zählspiel.\n   In diesem Spiel sind die Personen von 1 bis totalPeople nummeriert und sitzen im Kreis.\n   Beginnend mit der ersten Person zählen sie von 1 bis countNumber.\n   Die Person, die bei countNumber ist, wird aus dem Kreis entfernt,\n   und das Zählen wird von der nächsten Person fortgesetzt.\n   Dieser Prozess wird fortgesetzt, bis nur noch eine Person übrig bleibt.\n\n   Beispiel:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "ha": "Ƙayyade lambar mutumin da ya rage na ƙarshe a cikin wasan ƙidaya na madauwari. \n   A cikin wannan wasa, ana lissafa mutane daga 1 zuwa totalPeople kuma suna zaune a cikin madauwari. \n   Fara da mutum na farko, suna ƙidaya daga 1 zuwa countNumber. \n   Mutumin da yake a countNumber ana cire shi daga madauwari, \n   kuma ƙidaya yana ci gaba daga mutumin na gaba. \n   Wannan tsari yana ci gaba har sai mutum ɗaya kawai ya rage.\n\n   Misali:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hi": "अंतिम बचे हुए व्यक्ति की संख्या का निर्धारण करें एक वृत्ताकार गिनती खेल में। \n   इस खेल में, लोग 1 से totalPeople तक क्रमांकित होते हैं और एक वृत्त में बैठते हैं। \n   पहले व्यक्ति से शुरू करके, वे 1 से countNumber तक गिनते हैं। \n   जो व्यक्ति countNumber पर होता है उसे वृत्त से हटा दिया जाता है, \n   और गिनती अगले व्यक्ति से फिर से शुरू होती है। \n   यह प्रक्रिया तब तक चलती रहती है जब तक केवल एक व्यक्ति नहीं बचता।\n\n   उदाहरण:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hu": "Határozza meg az utolsó megmaradt személy számát egy körkörös számolós játékban.\n   Ebben a játékban az embereket 1-től totalPeople-ig számozzák, és körben ülnek.\n   Az első személlyel kezdve 1-től countNumber-ig számolnak.\n   Az a személy, aki a countNumber-nél van, kikerül a körből,\n   és a számolás a következő személynél folytatódik.\n   Ez a folyamat addig folytatódik, amíg csak egy személy marad.\n\n   Példa:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5"
    },
    "docstring_bertscore": {
      "sq": "0.9850220774876832",
      "hy": "0.9783759049382559",
      "bn": "0.9852391804941544",
      "bg": "0.973895995324395",
      "zh": "0.9662620338900811",
      "fr": "0.9799427013838591",
      "de": "0.9775833697179267",
      "ha": "0.963089708074573",
      "hi": "0.9758197305647179",
      "hu": "0.9812365796859204"
    }
  },
  {
    "task_id": "C#/35",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Determines the minimum number of steps required to convert a number into a palindrome in a given base (from 2 to 16). \n   The function takes an integer representing the base and a string representing the number in that base. \n   A palindrome is a number that reads the same forwards and backwards in the same base.\n   It calculates the number of steps required to reach a palindrome by repeatedly adding the number to its reverse in the given base.\n   If a palindrome is not obtained within 30 steps, it returns \"Impossible!\".\n\n   Example cases:\n   >>> StepsToPalindrome(10, \"56\")  // In base 10, \"56\" becomes palindrome \"121\" in 1 step\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In base 9, \"87\" becomes palindrome \"4884\" in 6 steps\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Përcakton numrin minimal të hapave të nevojshëm për të kthyer një numër në një palindrom në një bazë të dhënë (nga 2 në 16). \n   Funksioni merr një numër të plotë që përfaqëson bazën dhe një varg që përfaqëson numrin në atë bazë. \n   Një palindrom është një numër që lexohet njësoj përpara dhe prapa në të njëjtën bazë.\n   Ai llogarit numrin e hapave të nevojshëm për të arritur një palindrom duke shtuar në mënyrë të përsëritur numrin me të kundërtën e tij në bazën e dhënë.\n   Nëse një palindrom nuk arrihet brenda 30 hapave, kthen \"E pamundur!\".\n\n   Shembuj rastesh:\n   >>> StepsToPalindrome(10, \"56\")  // Në bazën 10, \"56\" bëhet palindrom \"121\" në 1 hap\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Në bazën 9, \"87\" bëhet palindrom \"4884\" në 6 hapa\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Որոշում է նվազագույն քայլերի քանակը, որը պահանջվում է թիվը պալինդրոմի վերածելու համար տրված հիմքում (2-ից 16): \n   Ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է հիմքը և տող, որը ներկայացնում է թիվը այդ հիմքում: \n   Պալինդրոմը թիվ է, որը նույն կերպ է կարդացվում առաջ և հետ նույն հիմքում:\n   Այն հաշվարկում է քայլերի քանակը, որը պահանջվում է պալինդրոմի հասնելու համար՝ բազմիցս ավելացնելով թիվը իր հակադարձին տրված հիմքում:\n   Եթե պալինդրոմը չի ստացվում 30 քայլի ընթացքում, վերադարձնում է \"Impossible!\"։\n\n   Օրինակ դեպքեր:\n   >>> StepsToPalindrome(10, \"56\")  // 10 հիմքում, \"56\" դառնում է պալինդրոմ \"121\" 1 քայլում\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 9 հիմքում, \"87\" դառնում է պալինդրոմ \"4884\" 6 քայլում\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* একটি সংখ্যাকে একটি প্রদত্ত ভিত্তিতে (২ থেকে ১৬ পর্যন্ত) প্যালিনড্রোমে রূপান্তর করতে প্রয়োজনীয় ন্যূনতম ধাপ নির্ধারণ করে।\n   ফাংশনটি একটি পূর্ণসংখ্যা নেয় যা ভিত্তিকে উপস্থাপন করে এবং একটি স্ট্রিং নেয় যা সেই ভিত্তিতে সংখ্যাটিকে উপস্থাপন করে।\n   একটি প্যালিনড্রোম হল একটি সংখ্যা যা একই ভিত্তিতে সামনে এবং পিছনে একইভাবে পড়ে।\n   এটি প্রদত্ত ভিত্তিতে সংখ্যাটিকে তার বিপরীতের সাথে বারবার যোগ করে একটি প্যালিনড্রোমে পৌঁছানোর জন্য প্রয়োজনীয় ধাপের সংখ্যা গণনা করে।\n   যদি ৩০ ধাপের মধ্যে একটি প্যালিনড্রোম প্রাপ্ত না হয়, এটি \"Impossible!\" ফেরত দেয়।\n\n   উদাহরণ কেস:\n   >>> StepsToPalindrome(10, \"56\")  // ভিত্তি ১০ এ, \"56\" এক ধাপে প্যালিনড্রোম \"121\" হয়ে যায়\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // ভিত্তি ৯ এ, \"87\" ছয় ধাপে প্যালিনড্রোম \"4884\" হয়ে যায়\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Определя минималния брой стъпки, необходими за преобразуване на число в палиндром в дадена база (от 2 до 16). \n   Функцията приема цяло число, представляващо базата, и низ, представляващ числото в тази база. \n   Палиндром е число, което се чете еднакво напред и назад в същата база.\n   Изчислява броя на стъпките, необходими за достигане на палиндром, като многократно добавя числото към неговото обръщане в дадената база.\n   Ако палиндром не се получи в рамките на 30 стъпки, връща \"Невъзможно!\".\n\n   Примерни случаи:\n   >>> StepsToPalindrome(10, \"56\")  // В база 10, \"56\" става палиндром \"121\" в 1 стъпка\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // В база 9, \"87\" става палиндром \"4884\" в 6 стъпки\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* 确定将一个数字转换为给定进制（从2到16）下的回文所需的最小步骤数。\n   该函数接受一个表示进制的整数和一个表示该进制下数字的字符串。\n   回文是指在相同进制下正反读都相同的数字。\n   它通过在给定进制下反复将数字与其反转相加来计算达到回文所需的步骤数。\n   如果在30步内没有得到回文，则返回\"Impossible!\"。\n\n   示例案例：\n   >>> StepsToPalindrome(10, \"56\")  // 在10进制中，\"56\"在1步内变为回文\"121\"\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 在9进制中，\"87\"在6步内变为回文\"4884\"\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Détermine le nombre minimum d'étapes nécessaires pour convertir un nombre en palindrome dans une base donnée (de 2 à 16).\n   La fonction prend un entier représentant la base et une chaîne représentant le nombre dans cette base.\n   Un palindrome est un nombre qui se lit de la même façon à l'endroit et à l'envers dans la même base.\n   Elle calcule le nombre d'étapes nécessaires pour atteindre un palindrome en ajoutant de manière répétée le nombre à son inverse dans la base donnée.\n   Si un palindrome n'est pas obtenu en 30 étapes, elle retourne \"Impossible!\".\n\n   Cas d'exemple :\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" devient le palindrome \"121\" en 1 étape\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" devient le palindrome \"4884\" en 6 étapes\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Bestimmt die minimale Anzahl von Schritten, die erforderlich sind, um eine Zahl in eine Palindrom-Zahl in einer gegebenen Basis (von 2 bis 16) umzuwandeln.\n   Die Funktion nimmt eine ganze Zahl, die die Basis darstellt, und einen String, der die Zahl in dieser Basis darstellt.\n   Ein Palindrom ist eine Zahl, die vorwärts und rückwärts in derselben Basis gleich gelesen wird.\n   Sie berechnet die Anzahl der Schritte, die erforderlich sind, um ein Palindrom zu erreichen, indem die Zahl wiederholt zu ihrem Umkehrwert in der gegebenen Basis addiert wird.\n   Wenn innerhalb von 30 Schritten kein Palindrom erreicht wird, gibt sie \"Unmöglich!\" zurück.\n\n   Beispiel-Fälle:\n   >>> StepsToPalindrome(10, \"56\")  // In Basis 10 wird \"56\" in 1 Schritt zum Palindrom \"121\"\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In Basis 9 wird \"87\" in 6 Schritten zum Palindrom \"4884\"\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Yana tantance mafi ƙarancin adadin matakai da ake buƙata don canza lamba zuwa palindrome a cikin wata tushe da aka bayar (daga 2 zuwa 16).\n   Aiki yana ɗaukar cikakken lamba da ke wakiltar tushe da kuma igiya da ke wakiltar lambar a cikin wannan tushe.\n   Palindrome lamba ce da ke karanta iri ɗaya gaba da baya a cikin wannan tushe.\n   Yana ƙididdige adadin matakan da ake buƙata don kaiwa ga palindrome ta hanyar ƙara lambar zuwa juyawarta a cikin wannan tushe akai-akai.\n   Idan ba a sami palindrome ba cikin matakai 30, yana dawowa da \"Impossible!\".\n\n   Misalan shari'o'i:\n   >>> StepsToPalindrome(10, \"56\")  // A cikin tushe 10, \"56\" ya zama palindrome \"121\" a cikin mataki 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // A cikin tushe 9, \"87\" ya zama palindrome \"4884\" a cikin matakai 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* यह निर्धारित करता है कि किसी संख्या को एक दिए गए आधार (2 से 16 तक) में पलिंड्रोम में बदलने के लिए न्यूनतम कितने चरणों की आवश्यकता होती है।\n   फ़ंक्शन एक पूर्णांक लेता है जो आधार का प्रतिनिधित्व करता है और एक स्ट्रिंग लेता है जो उस आधार में संख्या का प्रतिनिधित्व करती है।\n   एक पलिंड्रोम वह संख्या है जो एक ही आधार में आगे और पीछे से पढ़ने पर समान होती है।\n   यह दिए गए आधार में संख्या को उसके उलट के साथ जोड़कर पलिंड्रोम तक पहुंचने के लिए आवश्यक चरणों की संख्या की गणना करता है।\n   यदि 30 चरणों के भीतर पलिंड्रोम प्राप्त नहीं होता है, तो यह \"Impossible!\" लौटाता है।\n\n   उदाहरण मामले:\n   >>> StepsToPalindrome(10, \"56\")  // आधार 10 में, \"56\" 1 चरण में पलिंड्रोम \"121\" बन जाता है\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // आधार 9 में, \"87\" 6 चरणों में पलिंड्रोम \"4884\" बन जाता है\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Meghatározza a minimális lépések számát, amely szükséges ahhoz, hogy egy számot palindrómmá alakítsunk egy adott számrendszerben (2-től 16-ig). \n   A függvény egy egész számot vesz át, amely a számrendszert jelöli, és egy karakterláncot, amely a számot jelöli ebben a számrendszerben. \n   Egy palindróm olyan szám, amely előre és hátra olvasva is ugyanaz a számrendszerben.\n   Kiszámítja a lépések számát, amely szükséges ahhoz, hogy palindrómot érjünk el úgy, hogy ismételten hozzáadjuk a számot a fordítottjához az adott számrendszerben.\n   Ha 30 lépésen belül nem kapunk palindrómot, akkor \"Lehetetlen!\"-t ad vissza.\n\n   Példa esetek:\n   >>> StepsToPalindrome(10, \"56\")  // 10-es számrendszerben a \"56\" palindrómmá, \"121\"-é válik 1 lépésben\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 9-es számrendszerben a \"87\" palindrómmá, \"4884\"-é válik 6 lépésben\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)"
    },
    "prompt_bertscore": {
      "sq": "0.9915127224487602",
      "hy": "0.9917772981162988",
      "bn": "0.9932344505915707",
      "bg": "0.9905442007108342",
      "zh": "0.9903739744742872",
      "fr": "0.9935014098236815",
      "de": "0.9892006648135142",
      "ha": "0.9865501410089846",
      "hi": "0.984104405127302",
      "hu": "0.9386436711894661"
    },
    "canonical_solution": "    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }",
    "instruction": {
      "en": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nՏրամադրել C# կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\n请用最多500个字符的中文对该C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na C# cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9287852481179426",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.9336369938051008",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.8390555625284801",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(StepsToPalindrome(10, \"56\") == \"STEP=1\");\n        Debug.Assert(StepsToPalindrome(9, \"87\") == \"STEP=6\");\n        Debug.Assert(StepsToPalindrome(10, \"87\") == \"STEP=4\");\n        Debug.Assert(StepsToPalindrome(2, \"1001\") == \"STEP=0\"); // Already a palindrome\n        Debug.Assert(StepsToPalindrome(16, \"1A3\") == \"STEP=2\");\n\n\n    }\n}",
    "entry_point": "StepsToPalindrome",
    "signature": "public static string StepsToPalindrome(int baseNum, string num)",
    "docstring": {
      "en": "Determines the minimum number of steps required to convert a number into a palindrome in a given base (from 2 to 16). \n   The function takes an integer representing the base and a string representing the number in that base. \n   A palindrome is a number that reads the same forwards and backwards in the same base.\n   It calculates the number of steps required to reach a palindrome by repeatedly adding the number to its reverse in the given base.\n   If a palindrome is not obtained within 30 steps, it returns \"Impossible!\".\n\n   Example cases:\n   >>> StepsToPalindrome(10, \"56\")  // In base 10, \"56\" becomes palindrome \"121\" in 1 step\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In base 9, \"87\" becomes palindrome \"4884\" in 6 steps\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "sq": "Përcakton numrin minimal të hapave të nevojshëm për të kthyer një numër në një palindrom në një bazë të dhënë (nga 2 deri në 16). \n   Funksioni merr një numër të plotë që përfaqëson bazën dhe një varg që përfaqëson numrin në atë bazë. \n   Një palindrom është një numër që lexohet njësoj nga përpara dhe nga prapa në të njëjtën bazë.\n   Ai llogarit numrin e hapave të nevojshëm për të arritur një palindrom duke shtuar vazhdimisht numrin me të kundërtën e tij në bazën e dhënë.\n   Nëse një palindrom nuk arrihet brenda 30 hapave, kthen \"E pamundur!\".\n\n   Shembuj rastesh:\n   >>> StepsToPalindrome(10, \"56\")  // Në bazën 10, \"56\" bëhet palindrom \"121\" në 1 hap\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Në bazën 9, \"87\" bëhet palindrom \"4884\" në 6 hapa\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hy": "Որոշում է նվազագույն քայլերի քանակը, որոնք անհրաժեշտ են թիվը պալինդրոմ դարձնելու համար տրված հիմքում (2-ից 16): \n   Ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է հիմքը և տող, որը ներկայացնում է այդ հիմքում թիվը: \n   Պալինդրոմը թիվ է, որը նույն կերպ է կարդացվում առաջ և հետ նույն հիմքում:\n   Այն հաշվարկում է պալինդրոմի հասնելու համար անհրաժեշտ քայլերի քանակը՝ բազմիցս ավելացնելով թիվը իր հակառակին տրված հիմքում:\n   Եթե 30 քայլի ընթացքում պալինդրոմ չի ստացվում, վերադարձնում է \"Impossible!\"։\n\n   Օրինակներ:\n   >>> StepsToPalindrome(10, \"56\")  // 10 հիմքում, \"56\"-ը դառնում է պալինդրոմ \"121\" 1 քայլում\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 9 հիմքում, \"87\"-ը դառնում է պալինդրոմ \"4884\" 6 քայլում\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "bn": "একটি প্রদত্ত ভিত্তিতে (২ থেকে ১৬ পর্যন্ত) একটি সংখ্যাকে প্যালিনড্রোমে রূপান্তর করার জন্য প্রয়োজনীয় ন্যূনতম ধাপ নির্ধারণ করে। \n   ফাংশনটি একটি পূর্ণসংখ্যা গ্রহণ করে যা ভিত্তিকে উপস্থাপন করে এবং একটি স্ট্রিং গ্রহণ করে যা সেই ভিত্তিতে সংখ্যাকে উপস্থাপন করে। \n   একটি প্যালিনড্রোম হল একটি সংখ্যা যা একই ভিত্তিতে সামনে এবং পিছনে একইভাবে পড়ে।\n   এটি প্রদত্ত ভিত্তিতে সংখ্যাটিকে তার বিপরীতের সাথে বারবার যোগ করে একটি প্যালিনড্রোমে পৌঁছানোর জন্য প্রয়োজনীয় ধাপের সংখ্যা গণনা করে।\n   যদি ৩০ ধাপের মধ্যে একটি প্যালিনড্রোম পাওয়া না যায়, তবে এটি \"Impossible!\" ফেরত দেয়।\n\n   উদাহরণ কেস:\n   >>> StepsToPalindrome(10, \"56\")  // ভিত্তি ১০ এ, \"56\" এক ধাপে প্যালিনড্রোম \"121\" হয়ে যায়\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // ভিত্তি ৯ এ, \"87\" ছয় ধাপে প্যালিনড্রোম \"4884\" হয়ে যায়\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "bg": "Определя минималния брой стъпки, необходими за превръщането на число в палиндром в дадена база (от 2 до 16). \n   Функцията приема цяло число, представляващо базата, и низ, представляващ числото в тази база. \n   Палиндром е число, което се чете еднакво напред и назад в същата база.\n   Изчислява броя на стъпките, необходими за достигане на палиндром, като многократно добавя числото към неговия обратен в дадената база.\n   Ако палиндром не бъде получен в рамките на 30 стъпки, връща \"Impossible!\".\n\n   Примерни случаи:\n   >>> StepsToPalindrome(10, \"56\")  // В база 10, \"56\" става палиндром \"121\" в 1 стъпка\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // В база 9, \"87\" става палиндром \"4884\" в 6 стъпки\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "zh": "确定将一个数字转换为给定进制（从2到16）下的回文所需的最小步骤数。\n该函数接受一个表示进制的整数和一个表示该进制下数字的字符串。\n回文是指在同一进制下正反读都相同的数字。\n它通过在给定进制下不断将数字与其反转相加来计算达到回文所需的步骤数。\n如果在30步内未获得回文，则返回“Impossible!”。\n\n示例案例：\n>>> StepsToPalindrome(10, \"56\")  // 在10进制下，“56”在1步内变为回文“121”\n\"STEP=1\"\n>>> StepsToPalindrome(9, \"87\")   // 在9进制下，“87”在6步内变为回文“4884”\n\"STEP=6\"\n>>> StepsToPalindrome(2, \"1001\") \n\"STEP=0\"",
      "fr": "Détermine le nombre minimum d'étapes nécessaires pour convertir un nombre en palindrome dans une base donnée (de 2 à 16). \n   La fonction prend un entier représentant la base et une chaîne représentant le nombre dans cette base. \n   Un palindrome est un nombre qui se lit de la même manière à l'endroit et à l'envers dans la même base.\n   Elle calcule le nombre d'étapes nécessaires pour atteindre un palindrome en ajoutant de manière répétée le nombre à son inverse dans la base donnée.\n   Si un palindrome n'est pas obtenu en 30 étapes, elle retourne \"Impossible!\".\n\n   Exemples de cas :\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" devient le palindrome \"121\" en 1 étape\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" devient le palindrome \"4884\" en 6 étapes\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "de": "Bestimmt die minimale Anzahl von Schritten, die erforderlich sind, um eine Zahl in eine Palindrom-Zahl in einer gegebenen Basis (von 2 bis 16) umzuwandeln. \n   Die Funktion nimmt eine ganze Zahl, die die Basis darstellt, und einen String, der die Zahl in dieser Basis repräsentiert. \n   Ein Palindrom ist eine Zahl, die vorwärts und rückwärts in derselben Basis gleich gelesen wird.\n   Sie berechnet die Anzahl der Schritte, die erforderlich sind, um ein Palindrom zu erreichen, indem die Zahl wiederholt zu ihrem Umkehrwert in der gegebenen Basis addiert wird.\n   Wenn innerhalb von 30 Schritten kein Palindrom erreicht wird, gibt sie \"Unmöglich!\" zurück.\n\n   Beispielhafte Fälle:\n   >>> StepsToPalindrome(10, \"56\")  // In Basis 10 wird \"56\" in 1 Schritt zum Palindrom \"121\"\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In Basis 9 wird \"87\" in 6 Schritten zum Palindrom \"4884\"\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "ha": "Yana tantance mafi ƙarancin adadin matakai da ake buƙata don canza lamba zuwa palindrome a cikin wata tushe (daga 2 zuwa 16). \n   Aikin yana ɗaukar lamba mai nuna tushe da kuma kirtani mai nuna lambar a cikin wannan tushe. \n   Palindrome lamba ce da take karatu iri ɗaya a gaba da baya a cikin wannan tushe.\n   Yana ƙididdige adadin matakan da ake buƙata don kaiwa ga palindrome ta hanyar ƙara lambar da juyawarta a cikin tushe da aka bayar.\n   Idan ba a sami palindrome ba cikin matakai 30, yana dawowa da \"Impossible!\".\n\n   Misalan lamura:\n   >>> StepsToPalindrome(10, \"56\")  // A cikin tushe 10, \"56\" ya zama palindrome \"121\" a cikin mataki 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // A cikin tushe 9, \"87\" ya zama palindrome \"4884\" a cikin matakai 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hi": "दिया गया आधार (2 से 16 तक) में एक संख्या को पलिंड्रोम में बदलने के लिए आवश्यक न्यूनतम चरणों की गणना करता है। \n   फ़ंक्शन एक पूर्णांक लेता है जो आधार का प्रतिनिधित्व करता है और एक स्ट्रिंग लेता है जो उस आधार में संख्या का प्रतिनिधित्व करती है। \n   एक पलिंड्रोम वह संख्या है जो आगे और पीछे से पढ़ने पर उसी आधार में समान होती है।\n   यह दिए गए आधार में संख्या को उसके रिवर्स के साथ बार-बार जोड़कर पलिंड्रोम तक पहुंचने के लिए आवश्यक चरणों की गणना करता है।\n   यदि 30 चरणों के भीतर पलिंड्रोम प्राप्त नहीं होता है, तो यह \"Impossible!\" लौटाता है।\n\n   उदाहरण मामले:\n   >>> StepsToPalindrome(10, \"56\")  // आधार 10 में, \"56\" 1 चरण में पलिंड्रोम \"121\" बन जाता है\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // आधार 9 में, \"87\" 6 चरणों में पलिंड्रोम \"4884\" बन जाता है\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hu": "Meghatározza a minimális lépések számát, amely szükséges egy szám palindrómmá alakításához egy adott számrendszerben (2-től 16-ig). \n   A függvény egy egész számot vesz át, amely a számrendszert jelöli, és egy karakterláncot, amely a számot jelöli ebben a számrendszerben. \n   Egy palindróm olyan szám, amely előre és hátrafelé olvasva is ugyanazt adja ugyanabban a számrendszerben.\n   Kiszámítja a palindróm eléréséhez szükséges lépések számát azáltal, hogy ismételten hozzáadja a számot a fordítottjához az adott számrendszerben.\n   Ha 30 lépésen belül nem kapunk palindrómot, akkor \"Lehetetlen!\"-t ad vissza.\n\n   Példa esetek:\n   >>> StepsToPalindrome(10, \"56\")  // A 10-es számrendszerben a \"56\" 1 lépésben \"121\" palindrómmá válik\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // A 9-es számrendszerben a \"87\" 6 lépésben \"4884\" palindrómmá válik\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\""
    },
    "docstring_bertscore": {
      "sq": "0.9957250769393672",
      "hy": "0.980535017180105",
      "bn": "0.9797351326356776",
      "bg": "0.9948370005057602",
      "zh": "0.9869881209991666",
      "fr": "0.9880595332744687",
      "de": "0.9877359643837629",
      "ha": "0.9617427954607753",
      "hi": "0.9691906402280596",
      "hu": "0.9287637960367908"
    }
  },
  {
    "task_id": "C#/36",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines if a given password is secure based on specific criteria.\n   A secure password must:\n   1. Be at least 8 characters long and no more than 16 characters.\n   2. Include characters from at least three of the following categories:\n      - Uppercase letters (A-Z)\n      - Lowercase letters (a-z)\n      - Numbers (0-9)\n      - Special symbols (~, !, @, #, $, %, ^)\n\n   Examples:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton nëse një fjalëkalim i dhënë është i sigurt bazuar në kritere specifike.\n   Një fjalëkalim i sigurt duhet:\n   1. Të jetë të paktën 8 karaktere i gjatë dhe jo më shumë se 16 karaktere.\n   2. Të përfshijë karaktere nga të paktën tre nga kategoritë e mëposhtme:\n      - Shkronja të mëdha (A-Z)\n      - Shkronja të vogla (a-z)\n      - Numra (0-9)\n      - Simbole speciale (~, !, @, #, $, %, ^)\n\n   Shembuj:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Սահմանում է, արդյոք տրված գաղտնաբառը անվտանգ է որոշակի չափանիշների հիման վրա:\n   Անվտանգ գաղտնաբառը պետք է՝\n   1. Լինի առնվազն 8 նիշ երկարությամբ և ոչ ավելի, քան 16 նիշ:\n   2. Ներառի նիշեր առնվազն հետևյալ երեք կատեգորիաներից՝\n      - Մեծատառեր (A-Z)\n      - Փոքրատառեր (a-z)\n      - Թվեր (0-9)\n      - Հատուկ նշաններ (~, !, @, #, $, %, ^)\n\n   Օրինակներ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি প্রদত্ত পাসওয়ার্ড নির্দিষ্ট মানদণ্ডের উপর ভিত্তি করে নিরাপদ কিনা তা নির্ধারণ করে।\n   একটি নিরাপদ পাসওয়ার্ড অবশ্যই:\n   1. কমপক্ষে 8 অক্ষর দীর্ঘ এবং সর্বাধিক 16 অক্ষর হতে হবে।\n   2. নিম্নলিখিত বিভাগগুলির মধ্যে অন্তত তিনটি থেকে অক্ষর অন্তর্ভুক্ত করতে হবে:\n      - বড় হাতের অক্ষর (A-Z)\n      - ছোট হাতের অক্ষর (a-z)\n      - সংখ্যা (0-9)\n      - বিশেষ প্রতীক (~, !, @, #, $, %, ^)\n\n   উদাহরণ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя дали дадена парола е сигурна въз основа на специфични критерии.\n   Сигурната парола трябва:\n   1. Да бъде поне 8 символа дълга и не повече от 16 символа.\n   2. Да включва символи от поне три от следните категории:\n      - Главни букви (A-Z)\n      - Малки букви (a-z)\n      - Цифри (0-9)\n      - Специални символи (~, !, @, #, $, %, ^)\n\n   Примери:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 判断给定的密码是否根据特定标准是安全的。\n   一个安全的密码必须：\n   1. 至少8个字符长，且不超过16个字符。\n   2. 包含以下类别中的至少三种字符：\n      - 大写字母 (A-Z)\n      - 小写字母 (a-z)\n      - 数字 (0-9)\n      - 特殊符号 (~, !, @, #, $, %, ^)\n\n   示例:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine si un mot de passe donné est sécurisé selon des critères spécifiques.\n   Un mot de passe sécurisé doit :\n   1. Être d'au moins 8 caractères et d'au plus 16 caractères.\n   2. Inclure des caractères d'au moins trois des catégories suivantes :\n      - Lettres majuscules (A-Z)\n      - Lettres minuscules (a-z)\n      - Nombres (0-9)\n      - Symboles spéciaux (~, !, @, #, $, %, ^)\n\n   Exemples :\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt, ob ein gegebenes Passwort basierend auf bestimmten Kriterien sicher ist.\n   Ein sicheres Passwort muss:\n   1. Mindestens 8 Zeichen lang sein und nicht mehr als 16 Zeichen.\n   2. Zeichen aus mindestens drei der folgenden Kategorien enthalten:\n      - Großbuchstaben (A-Z)\n      - Kleinbuchstaben (a-z)\n      - Zahlen (0-9)\n      - Spezielle Symbole (~, !, @, #, $, %, ^)\n\n   Beispiele:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tabbatar da ko kalmar sirri da aka bayar tana da tsaro bisa wasu ka'idoji na musamman.\n   Kalmar sirri mai tsaro dole ne ta:\n   1. Kasance a kalla tana da tsawon haruffa 8 kuma ba fiye da haruffa 16 ba.\n   2. Hada haruffa daga a kalla rukuni uku daga cikin wadannan rukuni:\n      - Manyan haruffa (A-Z)\n      - Kananan haruffa (a-z)\n      - Lambobi (0-9)\n      - Alamu na musamman (~, !, @, #, $, %, ^)\n\n   Misalai:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह निर्धारित करता है कि दिया गया पासवर्ड विशिष्ट मानदंडों के आधार पर सुरक्षित है या नहीं।\n   एक सुरक्षित पासवर्ड होना चाहिए:\n   1. कम से कम 8 अक्षर लंबा और अधिकतम 16 अक्षर।\n   2. निम्नलिखित श्रेणियों में से कम से कम तीन श्रेणियों के अक्षर शामिल हों:\n      - अपरकेस अक्षर (A-Z)\n      - लोअरकेस अक्षर (a-z)\n      - संख्या (0-9)\n      - विशेष प्रतीक (~, !, @, #, $, %, ^)\n\n   उदाहरण:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza, hogy egy adott jelszó biztonságos-e a megadott kritériumok alapján.\n   Egy biztonságos jelszónak meg kell felelnie az alábbiaknak:\n   1. Legalább 8 karakter hosszúnak kell lennie, és legfeljebb 16 karakter.\n   2. Tartalmaznia kell karaktereket legalább három az alábbi kategóriák közül:\n      - Nagybetűk (A-Z)\n      - Kisbetűk (a-z)\n      - Számok (0-9)\n      - Speciális szimbólumok (~, !, @, #, $, %, ^)\n\n   Példák:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9931446696593429",
      "bn": "0.9898708437191259",
      "bg": "0.9919048188209232",
      "zh": "0.9798755643150693",
      "fr": "0.9816245048200815",
      "de": "0.9931917450596481",
      "ha": "0.9842070970342971",
      "hi": "0.9861600309406321",
      "hu": "0.9667059727916941"
    },
    "canonical_solution": "{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}",
    "instruction": {
      "en": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nՏրամադրել կարճ բնութագրություն (docstring) C# կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\n请用不超过500个字符的中文为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nBa da taƙaitaccen bayanin yaren halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9022706744447384",
      "bn": "0.8852756604130124",
      "bg": "0.8379186022274364",
      "zh": "0.8316742589388426",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9252758465458182",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(IsPasswordSecure(\"Password123!\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"short\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"Good@Pass1\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"1234567890\") == \"NO\");\n\n    }\n}",
    "entry_point": "IsPasswordSecure",
    "signature": "static string IsPasswordSecure(string password)",
    "docstring": {
      "en": "Determines if a given password is secure based on specific criteria.\n   A secure password must:\n   1. Be at least 8 characters long and no more than 16 characters.\n   2. Include characters from at least three of the following categories:\n      - Uppercase letters (A-Z)\n      - Lowercase letters (a-z)\n      - Numbers (0-9)\n      - Special symbols (~, !, @, #, $, %, ^)\n\n   Examples:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "sq": "Përcakton nëse një fjalëkalim i dhënë është i sigurt bazuar në kritere specifike.\n   Një fjalëkalim i sigurt duhet:\n   1. Të jetë të paktën 8 karaktere i gjatë dhe jo më shumë se 16 karaktere.\n   2. Të përfshijë karaktere nga të paktën tre nga kategoritë e mëposhtme:\n      - Shkronja të mëdha (A-Z)\n      - Shkronja të vogla (a-z)\n      - Numra (0-9)\n      - Simbole speciale (~, !, @, #, $, %, ^)\n\n   Shembuj:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"PO\"\n   >>> IsPasswordSecure(\"short\")\n   \"JO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"JO\"",
      "hy": "Սահմանում է, արդյոք տրված գաղտնաբառը անվտանգ է որոշակի չափանիշների հիման վրա:\n   Անվտանգ գաղտնաբառը պետք է՝\n   1. Լինի առնվազն 8 նիշ երկարությամբ և ոչ ավելի, քան 16 նիշ:\n   2. Ներառի նիշեր առնվազն հետևյալ երեք կատեգորիաներից՝\n      - Մեծատառեր (A-Z)\n      - Փոքրատառեր (a-z)\n      - Թվեր (0-9)\n      - Հատուկ սիմվոլներ (~, !, @, #, $, %, ^)\n\n   Օրինակներ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "bn": "নির্দিষ্ট মানদণ্ডের উপর ভিত্তি করে একটি প্রদত্ত পাসওয়ার্ড নিরাপদ কিনা তা নির্ধারণ করে।\n   একটি নিরাপদ পাসওয়ার্ড অবশ্যই:\n   1. কমপক্ষে 8 অক্ষর দীর্ঘ এবং সর্বাধিক 16 অক্ষর হতে হবে।\n   2. নিম্নলিখিত বিভাগগুলির মধ্যে অন্তত তিনটি থেকে অক্ষর অন্তর্ভুক্ত করতে হবে:\n      - বড় হাতের অক্ষর (A-Z)\n      - ছোট হাতের অক্ষর (a-z)\n      - সংখ্যা (0-9)\n      - বিশেষ প্রতীক (~, !, @, #, $, %, ^)\n\n   উদাহরণ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "bg": "Определя дали дадена парола е сигурна въз основа на специфични критерии.\n   Сигурната парола трябва:\n   1. Да бъде поне 8 символа дълга и не повече от 16 символа.\n   2. Да включва символи от поне три от следните категории:\n      - Главни букви (A-Z)\n      - Малки букви (a-z)\n      - Числа (0-9)\n      - Специални символи (~, !, @, #, $, %, ^)\n\n   Примери:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "zh": "确定给定的密码是否基于特定标准是安全的。\n   一个安全的密码必须：\n   1. 至少8个字符长，且不超过16个字符。\n   2. 包含至少以下三类中的字符：\n      - 大写字母 (A-Z)\n      - 小写字母 (a-z)\n      - 数字 (0-9)\n      - 特殊符号 (~, !, @, #, $, %, ^)\n\n   示例：\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "fr": "Détermine si un mot de passe donné est sécurisé en fonction de critères spécifiques.  \n   Un mot de passe sécurisé doit :\n   1. Être d'au moins 8 caractères et d'au plus 16 caractères.\n   2. Inclure des caractères d'au moins trois des catégories suivantes :\n      - Lettres majuscules (A-Z)\n      - Lettres minuscules (a-z)\n      - Nombres (0-9)\n      - Symboles spéciaux (~, !, @, #, $, %, ^)\n\n   Exemples :\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "de": "Bestimmt, ob ein gegebenes Passwort basierend auf bestimmten Kriterien sicher ist.\n   Ein sicheres Passwort muss:\n   1. Mindestens 8 Zeichen lang und nicht mehr als 16 Zeichen sein.\n   2. Zeichen aus mindestens drei der folgenden Kategorien enthalten:\n      - Großbuchstaben (A-Z)\n      - Kleinbuchstaben (a-z)\n      - Zahlen (0-9)\n      - Spezielle Symbole (~, !, @, #, $, %, ^)\n\n   Beispiele:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "ha": "Yana tantancewa idan kalmar sirri da aka bayar tana da tsaro bisa wasu ka'idoji na musamman.\n   Kalmar sirri mai tsaro dole ne ta:\n   1. Kasance a kalla tana da tsawon haruffa 8 kuma ba fiye da haruffa 16 ba.\n   2. Hada haruffa daga a kalla rukuni uku daga cikin wadannan:\n      - Manyan haruffa (A-Z)\n      - Haruffa kanana (a-z)\n      - Lambobi (0-9)\n      - Alamomin musamman (~, !, @, #, $, %, ^)\n\n   Misalai:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "hi": "निर्धारित करता है कि दिया गया पासवर्ड विशिष्ट मानदंडों के आधार पर सुरक्षित है या नहीं।  \n   एक सुरक्षित पासवर्ड होना चाहिए:\n   1. कम से कम 8 वर्ण लंबा और अधिकतम 16 वर्ण।\n   2. निम्नलिखित श्रेणियों में से कम से कम तीन श्रेणियों के वर्ण शामिल हों:\n      - अपरकेस अक्षर (A-Z)\n      - लोअरकेस अक्षर (a-z)\n      - संख्याएँ (0-9)\n      - विशेष प्रतीक (~, !, @, #, $, %, ^)\n\n   उदाहरण:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "hu": "Meghatározza, hogy egy adott jelszó biztonságos-e a megadott kritériumok alapján.\n   Egy biztonságos jelszónak meg kell felelnie a következőknek:\n   1. Legalább 8 karakter hosszúnak kell lennie, és legfeljebb 16 karakter.\n   2. Tartalmaznia kell karaktereket legalább három az alábbi kategóriák közül:\n      - Nagybetűk (A-Z)\n      - Kisbetűk (a-z)\n      - Számok (0-9)\n      - Speciális szimbólumok (~, !, @, #, $, %, ^)\n\n   Példák:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\""
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9854685985842496",
      "bn": "0.9875482586736849",
      "bg": "1",
      "zh": "0.9887998287045857",
      "fr": "0.9727278500535288",
      "de": "0.9914302908406308",
      "ha": "0.9880813826163826",
      "hi": "0.9805205171622895",
      "hu": "0.9636285922983205"
    }
  },
  {
    "task_id": "C#/37",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Counts the number of ways a group of kids can queue up to buy tickets, ensuring the ticket seller can always give change.\n   - totalKids: Total number of kids.\n   - oneDollarKids: Number of kids with exactly 1 dollar.\n   - twoDollarKids: Number of kids with exactly 2 dollars.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Example:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Numëron numrin e mënyrave se si një grup fëmijësh mund të rreshtohen për të blerë bileta, duke siguruar që shitësi i biletave gjithmonë mund të japë kusur.\n   - totalKids: Numri total i fëmijëve.\n   - oneDollarKids: Numri i fëmijëve me saktësisht 1 dollar.\n   - twoDollarKids: Numri i fëmijëve me saktësisht 2 dollarë.\n   Shitësi i biletave nuk ka kusur fillimisht, dhe bileta kushton 1 dollar.\n   Permutime të ndryshme të fëmijëve me të njëjtën shumë konsiderohen si rregullime të veçanta.\n   Shembull:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Հաշվում է, թե քանի եղանակով կարող են երեխաները հերթ կանգնել տոմս գնելու համար՝ ապահովելով, որ տոմսավաճառը միշտ կարողանա մանրել:\n   - totalKids: Երեխաների ընդհանուր քանակը:\n   - oneDollarKids: Երեխաների քանակը, որոնք ունեն հենց 1 դոլար:\n   - twoDollarKids: Երեխաների քանակը, որոնք ունեն հենց 2 դոլար:\n   Սկզբում տոմսավաճառը մանր չունի, և տոմսի արժեքը 1 դոլար է:\n   Նույն գումարով երեխաների տարբեր հերթականությունները համարվում են տարբեր դասավորություններ:\n   Օրինակ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* কতভাবে একটি দল বাচ্চারা টিকিট কিনতে লাইনে দাঁড়াতে পারে তার সংখ্যা গণনা করে, নিশ্চিত করে যে টিকিট বিক্রেতা সর্বদা চেঞ্জ দিতে পারে।\n   - totalKids: মোট বাচ্চার সংখ্যা।\n   - oneDollarKids: বাচ্চাদের সংখ্যা যাদের কাছে ঠিক 1 ডলার আছে।\n   - twoDollarKids: বাচ্চাদের সংখ্যা যাদের কাছে ঠিক 2 ডলার আছে।\n   টিকিট বিক্রেতার কাছে শুরুতে কোনো চেঞ্জ নেই, এবং টিকিটের মূল্য 1 ডলার।\n   একই পরিমাণ অর্থ সহ বাচ্চাদের বিভিন্ন বিন্যাস আলাদা বিন্যাস হিসেবে বিবেচিত হয়।\n   উদাহরণ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Брои броя на начините, по които група деца могат да се наредят на опашка, за да купят билети, като се гарантира, че продавачът на билети винаги може да върне ресто.\n   - totalKids: Общо брой деца.\n   - oneDollarKids: Брой деца с точно 1 долар.\n   - twoDollarKids: Брой деца с точно 2 долара.\n   Продавачът на билети няма ресто в началото, а билетът струва 1 долар.\n   Различни пермутации на деца със същата сума се считат за различни подредби.\n   Пример:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 计算一组孩子排队买票的方式数量，确保售票员总是可以找零。\n   - totalKids: 孩子的总数。\n   - oneDollarKids: 拥有正好1美元的孩子数量。\n   - twoDollarKids: 拥有正好2美元的孩子数量。\n   售票员最初没有零钱，票价为1美元。\n   拥有相同金额的孩子的不同排列被视为不同的安排。\n   示例:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Compte le nombre de façons dont un groupe d'enfants peut faire la queue pour acheter des billets, en s'assurant que le vendeur de billets peut toujours rendre la monnaie.\n   - totalKids: Nombre total d'enfants.\n   - oneDollarKids: Nombre d'enfants avec exactement 1 dollar.\n   - twoDollarKids: Nombre d'enfants avec exactement 2 dollars.\n   Le vendeur de billets n'a pas de monnaie au départ, et le billet coûte 1 dollar.\n   Différentes permutations d'enfants avec le même montant sont considérées comme des arrangements distincts.\n   Exemple:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Zählt die Anzahl der Möglichkeiten, wie sich eine Gruppe von Kindern anstellen kann, um Tickets zu kaufen, wobei sichergestellt wird, dass der Ticketverkäufer immer Wechselgeld geben kann.\n   - totalKids: Gesamtanzahl der Kinder.\n   - oneDollarKids: Anzahl der Kinder mit genau 1 Dollar.\n   - twoDollarKids: Anzahl der Kinder mit genau 2 Dollar.\n   Der Ticketverkäufer hat anfangs kein Wechselgeld, und das Ticket kostet 1 Dollar.\n   Verschiedene Permutationen von Kindern mit dem gleichen Betrag werden als unterschiedliche Anordnungen betrachtet.\n   Beispiel:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Yana ƙididdige yawan hanyoyin da za a iya tsara ƙungiyar yara su tsaya a layi don siyan tikiti, yana tabbatar da cewa mai sayar da tikiti zai iya ba da canji koyaushe.\n   - totalKids: Jimlar yawan yara.\n   - oneDollarKids: Yawan yara da suke da dala 1 kawai.\n   - twoDollarKids: Yawan yara da suke da dala 2 kawai.\n   Mai sayar da tikiti ba shi da canji a farko, kuma tikitin yana da tsadar dala 1.\n   Daban-daban tsararraki na yara da suke da adadin kudi iri ɗaya ana ɗauka a matsayin tsararraki masu bambanci.\n   Misali:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* यह गणना करता है कि टिकट खरीदने के लिए बच्चों का एक समूह कितने तरीकों से कतार में खड़ा हो सकता है, यह सुनिश्चित करते हुए कि टिकट विक्रेता हमेशा बदलाव दे सकता है।\n   - totalKids: बच्चों की कुल संख्या।\n   - oneDollarKids: बच्चों की संख्या जिनके पास ठीक 1 डॉलर है।\n   - twoDollarKids: बच्चों की संख्या जिनके पास ठीक 2 डॉलर है।\n   टिकट विक्रेता के पास शुरू में कोई बदलाव नहीं है, और टिकट की कीमत 1 डॉलर है।\n   समान राशि वाले बच्चों के विभिन्न क्रमों को अलग-अलग व्यवस्थाओं के रूप में माना जाता है।\n   उदाहरण:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Megszámolja, hányféleképpen tud egy csoport gyerek sorba állni jegyvásárlásra úgy, hogy a jegyárus mindig tudjon visszaadni.\n   - totalKids: A gyerekek teljes száma.\n   - oneDollarKids: Azoknak a gyerekeknek a száma, akiknél pontosan 1 dollár van.\n   - twoDollarKids: Azoknak a gyerekeknek a száma, akiknél pontosan 2 dollár van.\n   A jegyárusnak kezdetben nincs visszajárója, és a jegy 1 dollárba kerül.\n   Az ugyanannyi pénzzel rendelkező gyerekek különböző permutációi különböző elrendezésnek számítanak.\n   Példa:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)"
    },
    "prompt_bertscore": {
      "sq": "0.986854244122349",
      "hy": "0.941837051825364",
      "bn": "0.9598881835930526",
      "bg": "0.980272229185996",
      "zh": "0.96893162621119",
      "fr": "0.98122883310106",
      "de": "0.9875043613594762",
      "ha": "0.9447185827630372",
      "hi": "0.9594643063599242",
      "hu": "0.9653586629171345"
    },
    "canonical_solution": "    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n",
    "instruction": {
      "en": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nՏվեք C# կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nПредоставете кратко описание на C# кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9287852481179426",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9252758465458182",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountQueueArrangements(4, 2, 2) == 8);\n        Debug.Assert(CountQueueArrangements(5, 3, 2) == 60); // Expected output: True\n        Debug.Assert(CountQueueArrangements(6, 4, 2) == 432); // Expected output: True\n\n    }\n}\n",
    "entry_point": "CountQueueArrangements",
    "signature": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
    "docstring": {
      "en": "Counts the number of ways a group of kids can queue up to buy tickets, ensuring the ticket seller can always give change.\n   - totalKids: Total number of kids.\n   - oneDollarKids: Number of kids with exactly 1 dollar.\n   - twoDollarKids: Number of kids with exactly 2 dollars.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Example:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "sq": "Llogarit numrin e mënyrave se si një grup fëmijësh mund të rreshtohen për të blerë bileta, duke siguruar që shitësi i biletave të mund të japë gjithmonë kusur.\n   - totalKids: Numri total i fëmijëve.\n   - oneDollarKids: Numri i fëmijëve me saktësisht 1 dollar.\n   - twoDollarKids: Numri i fëmijëve me saktësisht 2 dollarë.\n   Shitësi i biletave nuk ka kusur fillimisht, dhe bileta kushton 1 dollar.\n   Permutime të ndryshme të fëmijëve me të njëjtën shumë konsiderohen si rregullime të dallueshme.\n   Shembull:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hy": "Հաշվում է, թե քանի եղանակով կարող է երեխաների խումբը հերթ կանգնել տոմս գնելու համար՝ ապահովելով, որ տոմսավաճառը միշտ կարող է վերադարձ տալ:\n   - totalKids: Երեխաների ընդհանուր քանակը:\n   - oneDollarKids: Երեխաների քանակը, ովքեր ունեն ճիշտ 1 դոլար:\n   - twoDollarKids: Երեխաների քանակը, ովքեր ունեն ճիշտ 2 դոլար:\n   Տոմսավաճառը սկզբում վերադարձ չունի, և տոմսի արժեքը 1 դոլար է:\n   Նույն գումարով երեխաների տարբեր դասավորությունները համարվում են տարբեր դասավորություններ:\n   Օրինակ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "bn": "বাচ্চাদের একটি দল কতভাবে টিকিট কিনতে লাইনে দাঁড়াতে পারে তা গণনা করে, নিশ্চিত করে যে টিকিট বিক্রেতা সবসময় খুচরা দিতে পারে।\n   - totalKids: মোট বাচ্চার সংখ্যা।\n   - oneDollarKids: একদম 1 ডলার থাকা বাচ্চার সংখ্যা।\n   - twoDollarKids: একদম 2 ডলার থাকা বাচ্চার সংখ্যা।\n   টিকিট বিক্রেতার শুরুতে কোনো খুচরা নেই, এবং টিকিটের দাম 1 ডলার।\n   একই পরিমাণের বাচ্চাদের বিভিন্ন বিন্যাসকে পৃথক বিন্যাস হিসেবে গণ্য করা হয়।\n   উদাহরণ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "bg": "Брои броя начини, по които група деца могат да се наредят на опашка, за да купят билети, като се гарантира, че продавачът на билети винаги може да върне ресто.\n   - totalKids: Общо брой деца.\n   - oneDollarKids: Брой деца с точно 1 долар.\n   - twoDollarKids: Брой деца с точно 2 долара.\n   Продавачът на билети няма ресто в началото, а билетът струва 1 долар.\n   Различните пермутации на деца със същата сума се считат за различни подреждания.\n   Пример:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "zh": "计算一组孩子排队买票的方法数量，确保售票员总是可以找零。\n   - totalKids: 孩子的总数。\n   - oneDollarKids: 拥有正好1美元的孩子数量。\n   - twoDollarKids: 拥有正好2美元的孩子数量。\n   售票员最初没有零钱，并且票价为1美元。\n   拥有相同金额的孩子的不同排列被视为不同的安排。\n   示例：\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "fr": "Compte le nombre de façons dont un groupe d'enfants peut faire la queue pour acheter des billets, en s'assurant que le vendeur de billets peut toujours rendre la monnaie.\n   - totalKids: Nombre total d'enfants.\n   - oneDollarKids: Nombre d'enfants avec exactement 1 dollar.\n   - twoDollarKids: Nombre d'enfants avec exactement 2 dollars.\n   Le vendeur de billets n'a pas de monnaie au départ, et le billet coûte 1 dollar.\n   Différentes permutations d'enfants avec le même montant sont considérées comme des arrangements distincts.\n   Exemple:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "de": "Zählt die Anzahl der Möglichkeiten, wie eine Gruppe von Kindern sich anstellen kann, um Tickets zu kaufen, wobei sichergestellt wird, dass der Ticketverkäufer immer Wechselgeld geben kann.\n   - totalKids: Gesamtanzahl der Kinder.\n   - oneDollarKids: Anzahl der Kinder mit genau 1 Dollar.\n   - twoDollarKids: Anzahl der Kinder mit genau 2 Dollar.\n   Der Ticketverkäufer hat anfangs kein Wechselgeld, und das Ticket kostet 1 Dollar.\n   Verschiedene Permutationen von Kindern mit dem gleichen Betrag werden als unterschiedliche Anordnungen betrachtet.\n   Beispiel:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "ha": "Yana ƙidaya adadin hanyoyin da za a iya jera ƙungiyar yara don siyan tikiti, yana tabbatar da cewa mai sayar da tikiti zai iya ba da canji koyaushe.\n   - totalKids: Jimlar adadin yara.\n   - oneDollarKids: Adadin yara da ke da dala 1 kawai.\n   - twoDollarKids: Adadin yara da ke da dala 2 kawai.\n   Mai sayar da tikiti ba shi da canji a farko, kuma tikitin yana da tsada dala 1.\n   Daban-daban jeri na yara da ke da adadin iri ɗaya ana ɗauka a matsayin tsararru daban-daban.\n   Misali:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hi": "बच्चों के एक समूह के टिकट खरीदने के लिए कतार में लगने के तरीकों की संख्या गिनता है, यह सुनिश्चित करते हुए कि टिकट विक्रेता हमेशा बदलाव दे सकता है।\n   - totalKids: बच्चों की कुल संख्या।\n   - oneDollarKids: उन बच्चों की संख्या जिनके पास ठीक 1 डॉलर है।\n   - twoDollarKids: उन बच्चों की संख्या जिनके पास ठीक 2 डॉलर हैं।\n   टिकट विक्रेता के पास शुरू में कोई बदलाव नहीं है, और टिकट की कीमत 1 डॉलर है।\n   समान राशि वाले बच्चों के विभिन्न क्रमभेदों को अलग व्यवस्थाएँ माना जाता है।\n   उदाहरण:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hu": "Számolja meg, hányféleképpen tud egy csoport gyerek sorba állni jegyvásárlásra úgy, hogy a jegyárus mindig tudjon visszaadni.\n   - totalKids: A gyerekek teljes száma.\n   - oneDollarKids: Azoknak a gyerekeknek a száma, akiknek pontosan 1 dollárjuk van.\n   - twoDollarKids: Azoknak a gyerekeknek a száma, akiknek pontosan 2 dollárjuk van.\n   A jegyárusnak kezdetben nincs visszajárója, és a jegy 1 dollárba kerül.\n   Az azonos összegű gyerekek különböző permutációi különböző elrendezéseknek számítanak.\n   Példa:\n   >>> CountQueueArrangements(4, 2, 2)\n   8"
    },
    "docstring_bertscore": {
      "sq": "0.9633413727673441",
      "hy": "0.9478589290871987",
      "bn": "0.9491079169231461",
      "bg": "0.974693297673869",
      "zh": "0.9440255613636065",
      "fr": "0.9754913945448672",
      "de": "0.9831724313794863",
      "ha": "0.9482694980847979",
      "hi": "0.9690434551157127",
      "hu": "0.9503910691846315"
    }
  },
  {
    "task_id": "C#/38",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the minimum absolute difference between elements of two sorted arrays.\n   Each array is assumed to be sorted in ascending order.\n   Examples:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton diferencën minimale absolute midis elementeve të dy vargjeve të renditura.\n   Çdo varg supozohet të jetë i renditur në rend rritës.\n   Shembuj:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշում է երկու դասավորված զանգվածների տարրերի միջև նվազագույն բացարձակ տարբերությունը:\n   Յուրաքանչյուր զանգված ենթադրվում է, որ դասավորված է աճման կարգով:\n   Օրինակներ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* দুটি সাজানো অ্যারের উপাদানগুলোর মধ্যে সর্বনিম্ন পার্থক্য নির্ধারণ করে।\n   প্রতিটি অ্যারে ক্রমবর্ধমান ক্রমে সাজানো বলে ধরা হয়।\n   উদাহরণ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя минималната абсолютна разлика между елементи на два сортирани масива.\n   Всеки масив се приема, че е сортиран във възходящ ред.\n   Примери:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定两个已排序数组元素之间的最小绝对差。\n   假设每个数组都是按升序排序的。\n   示例：\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine la différence absolue minimale entre les éléments de deux tableaux triés.\n   Chaque tableau est supposé être trié par ordre croissant.\n   Exemples :\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt den minimalen absoluten Unterschied zwischen Elementen von zwei sortierten Arrays.\n   Jedes Array wird angenommen, in aufsteigender Reihenfolge sortiert zu sein.\n   Beispiele:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana ƙayyade mafi ƙarancin bambanci tsakanin abubuwan abubuwa biyu da aka tsara.\n   Ana tsammanin kowace hanya an tsara ta cikin tsari mai tashi.\n   Misalai:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दो क्रमबद्ध ऐरे के तत्वों के बीच न्यूनतम निरपेक्ष अंतर निर्धारित करता है।\n   प्रत्येक ऐरे को आरोही क्रम में क्रमबद्ध माना जाता है।\n   उदाहरण:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza a minimális abszolút különbséget két rendezett tömb elemei között.\n   Feltételezzük, hogy minden tömb növekvő sorrendben van rendezve.\n   Példák:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.993663293584225",
      "bg": "1",
      "zh": "0.9817859913198628",
      "fr": "1",
      "de": "0.9980720935216754",
      "ha": "0.9894378294884698",
      "hi": "0.9966532767099432",
      "hu": "0.9888590205581341"
    },
    "canonical_solution": "{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}",
    "instruction": {
      "en": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nՏվեք C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\n请用中文为以下C#代码提供一个简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.948868567313999",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8642216345448384",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9428713202194127",
      "hi": "0.9150793545657733",
      "hu": "0.9437490678732059"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6}) == 1);\n        Debug.Assert(MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35}) == 5);\n\n    }\n}",
    "entry_point": "MinArrayDistance",
    "signature": "static int MinArrayDistance(int[] array1, int[] array2)",
    "docstring": {
      "en": "Determines the minimum absolute difference between elements of two sorted arrays.\n   Each array is assumed to be sorted in ascending order.\n   Examples:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "sq": "Përcakton diferencën minimale absolute midis elementeve të dy vargjeve të renditura.\n   Çdo varg supozohet të jetë i renditur në rritje.\n   Shembuj:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "hy": "Սահմանում է երկու դասավորված զանգվածների տարրերի միջև նվազագույն բացարձակ տարբերությունը:\n   Յուրաքանչյուր զանգված ենթադրվում է, որ դասավորված է աճման կարգով:\n   Օրինակներ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "bn": "দুটি সর্ট করা অ্যারের উপাদানগুলির মধ্যে সর্বনিম্ন পরম পার্থক্য নির্ধারণ করে।  \nপ্রতিটি অ্যারে ক্রমবর্ধমান ক্রমে সর্ট করা হয়েছে বলে মনে করা হয়।  \nউদাহরণস্বরূপ:  \n>>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})  \n1  \n>>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})  \n5",
      "bg": "Определя минималната абсолютна разлика между елементите на два сортирани масива.  \n   Предполага се, че всеки масив е сортиран във възходящ ред.\n   Примери:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "zh": "确定两个已排序数组元素之间的最小绝对差值。\n每个数组假定按升序排序。\n示例：\n>>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n1\n>>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n5",
      "fr": "Détermine la différence absolue minimale entre les éléments de deux tableaux triés.\n   Chaque tableau est supposé être trié par ordre croissant.\n   Exemples :\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "de": "Bestimmt den minimalen absoluten Unterschied zwischen Elementen von zwei sortierten Arrays.\n   Es wird angenommen, dass jedes Array in aufsteigender Reihenfolge sortiert ist.\n   Beispiele:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "ha": "Yana ƙayyade mafi ƙarancin bambanci na ainihi tsakanin abubuwan abubuwa biyu da aka jera.\n   Ana ɗauka kowanne jeri an jera shi cikin tsari mai ƙaruwa.\n   Misalai:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "hi": "न्यूनतम निरपेक्ष अंतर निर्धारित करता है जो दो क्रमबद्ध सरणियों के तत्वों के बीच होता है।  \nप्रत्येक सरणी को आरोही क्रम में क्रमबद्ध माना जाता है।  \nउदाहरण:  \n>>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})  \n1  \n>>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})  \n5  ",
      "hu": "Meghatározza a két rendezett tömb elemei közötti minimális abszolút különbséget.\n   Feltételezzük, hogy minden tömb növekvő sorrendben van rendezve.\n   Példák:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5"
    },
    "docstring_bertscore": {
      "sq": "0.9921825040936099",
      "hy": "0.9903352415499854",
      "bn": "0.9845749604999737",
      "bg": "0.9881060127836309",
      "zh": "0.9875468682610177",
      "fr": "0.9865417985329812",
      "de": "0.9921797232682754",
      "ha": "0.973115973818071",
      "hi": "0.9957443440863275",
      "hu": "0.9881060127836309"
    }
  },
  {
    "task_id": "C#/39",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Sort a list of integers in descending order based on their absolute values.\n    Examples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Rendit një listë të numrave të plotë në rend zbritës bazuar në vlerat e tyre absolute.\n    Shembuj:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Դասավորել ամբողջ թվերի ցուցակը նվազման կարգով՝ հիմնվելով նրանց բացարձակ արժեքների վրա:\n    Օրինակներ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* পূর্ণসংখ্যার একটি তালিকাকে তাদের মানের ভিত্তিতে অবতরণী ক্রমে সাজান।\n    উদাহরণ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Сортиране на списък от цели числа в низходящ ред въз основа на техните абсолютни стойности.\n    Примери:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 根据整数的绝对值以降序排序列表。\n    例子:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Trier une liste d'entiers par ordre décroissant en fonction de leurs valeurs absolues.\n    Exemples :\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Sortiere eine Liste von ganzen Zahlen in absteigender Reihenfolge basierend auf ihren absoluten Werten.\n    Beispiele:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Jera jerin lambobi na integers a cikin tsarin saukowa bisa ga ƙimarsu ta cikakke.\n    Misalai:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* पूर्णांक की एक सूची को उनके परिमाण के आधार पर अवरोही क्रम में छांटें।\n    उदाहरण:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Egy egész számokat tartalmazó lista rendezése csökkenő sorrendbe az abszolút értékük alapján.\n    Példák:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9967357083180727",
      "bn": "0.9869174085835182",
      "bg": "0.9955117479101356",
      "zh": "0.987121401984841",
      "fr": "1",
      "de": "1",
      "ha": "0.9990054576821583",
      "hi": "0.9863995791801602",
      "hu": "0.9955117479101356"
    },
    "canonical_solution": "{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}",
    "instruction": {
      "en": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nՏրամադրել C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nПредоставете кратко описание на C# кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C# a Hausa ta amfani da haruffa 500 kawai.",
      "hi": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में 500 वर्णों तक प्रदान करें।",
      "hu": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9226191651994765",
      "bn": "0.872474726876838",
      "bg": "0.9000956717724065",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9237483789156599",
      "hi": "0.9056009114131693",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 3, -4, 2 }).SequenceEqual(new List<int> { -4, 3, 2 }));\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 }).SequenceEqual(new List<int> { -3, 2, 1, 0 }));\n\n\n    }\n}",
    "entry_point": "SortByAbsoluteDescending",
    "signature": "static List<int> SortByAbsoluteDescending(List<int> numbers)",
    "docstring": {
      "en": "Sort a list of integers in descending order based on their absolute values.\n    Examples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "sq": "Rendit një listë të numrave të plotë në rend zbritës bazuar në vlerat e tyre absolute.\n    Shembuj:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hy": "Դասավորել ամբողջ թվերի ցուցակը նվազման կարգով՝ հիմնված նրանց բացարձակ արժեքների վրա։  \n    Օրինակներ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "bn": "একটি পূর্ণসংখ্যার তালিকাকে তাদের মানের পরম মানের উপর ভিত্তি করে অবরোহ ক্রমে সাজান।\n    উদাহরণ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "bg": "Сортирайте списък от цели числа в низходящ ред въз основа на техните абсолютни стойности.\n    Примери:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "zh": "根据整数的绝对值以降序排序列表。\n    示例：\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "fr": "Trier une liste d'entiers par ordre décroissant en fonction de leurs valeurs absolues.\n    Exemples :\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "de": "Sortiere eine Liste von ganzen Zahlen in absteigender Reihenfolge basierend auf ihren Absolutwerten.\n    Beispiele:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "ha": "Sort jerin lambobin gaba daya a cikin tsari mai saukowa bisa ga ƙimarsu ta ainihi.\n    Misalai:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hi": "पूर्णांक की एक सूची को उनके परिमाण के आधार पर अवरोही क्रम में क्रमबद्ध करें।  \n    उदाहरण:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hu": "Rendezzen egy egész számokból álló listát csökkenő sorrendbe az abszolút értékük alapján.\n    Példák:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9968382015946866",
      "bn": "0.9810816479887131",
      "bg": "1",
      "zh": "0.9798368313907675",
      "fr": "1",
      "de": "1",
      "ha": "0.97782391110936",
      "hi": "0.980050557680761",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/40",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calculates the maximum total value of purchases within a budget, considering main items and their accessories.\n    - `totalMoney` is the total budget.\n    - `items` is a list of tuples, where each tuple represents an item with its price, importance, and category (0 for main items, item number of the main item if an accessory).\n    For example:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Llogarit vlerën maksimale totale të blerjeve brenda një buxheti, duke marrë parasysh artikujt kryesorë dhe aksesorët e tyre.\n    - `totalMoney` është buxheti total.\n    - `items` është një listë tuples, ku çdo tuple përfaqëson një artikull me çmimin, rëndësinë dhe kategorinë e tij (0 për artikujt kryesorë, numri i artikullit kryesor nëse është aksesor).\n    Për shembull:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Հաշվարկում է գնումների առավելագույն ընդհանուր արժեքը բյուջեի սահմաններում՝ հաշվի առնելով հիմնական իրերն ու դրանց աքսեսուարները:\n    - `totalMoney`-ը ընդհանուր բյուջեն է:\n    - `items`-ը tuples-ի ցուցակ է, որտեղ յուրաքանչյուր tuple ներկայացնում է իր՝ իր գինը, կարևորությունը և կատեգորիան (0՝ հիմնական իրերի համար, հիմնական իրի համարի դեպքում՝ աքսեսուար):\n    Օրինակ:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* বাজেটের মধ্যে প্রধান আইটেম এবং তাদের আনুষাঙ্গিক বিবেচনা করে ক্রয়ের সর্বাধিক মোট মান গণনা করে।\n    - `totalMoney` হল মোট বাজেট।\n    - `items` হল একটি টুপলের তালিকা, যেখানে প্রতিটি টুপল একটি আইটেমকে তার মূল্য, গুরুত্ব এবং শ্রেণীবিভাগ (0 প্রধান আইটেমের জন্য, আনুষাঙ্গিক হলে প্রধান আইটেমের আইটেম নম্বর) সহ উপস্থাপন করে।\n    উদাহরণস্বরূপ:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Изчислява максималната обща стойност на покупките в рамките на бюджет, като се вземат предвид основни артикули и техните аксесоари.\n    - `totalMoney` е общият бюджет.\n    - `items` е списък от кортежи, където всеки кортеж представлява артикул с неговата цена, важност и категория (0 за основни артикули, номер на основния артикул, ако е аксесоар).\n    Например:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 计算在预算内购买的最大总价值，考虑主要物品及其附件。\n    - `totalMoney` 是总预算。\n    - `items` 是一个元组列表，其中每个元组表示一个物品及其价格、重要性和类别（0表示主要物品，如果是附件则为主要物品的编号）。\n    例如：\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calcule la valeur totale maximale des achats dans un budget, en tenant compte des articles principaux et de leurs accessoires.\n    - `totalMoney` est le budget total.\n    - `items` est une liste de tuples, où chaque tuple représente un article avec son prix, son importance et sa catégorie (0 pour les articles principaux, numéro de l'article principal si c'est un accessoire).\n    Par exemple :\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Berechnet den maximalen Gesamtwert der Einkäufe innerhalb eines Budgets, unter Berücksichtigung von Hauptartikeln und deren Zubehör.\n    - `totalMoney` ist das Gesamtbudget.\n    - `items` ist eine Liste von Tupeln, wobei jedes Tupel einen Artikel mit seinem Preis, seiner Wichtigkeit und seiner Kategorie darstellt (0 für Hauptartikel, Artikelnummer des Hauptartikels, wenn es sich um Zubehör handelt).\n    Zum Beispiel:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Lissafa darajar jimlar mafi girma na sayayya cikin kasafin kudi, la'akari da manyan kayayyaki da na'urorin haɗi.\n    - `totalMoney` shine jimlar kasafin kudi.\n    - `items` jerin tuples ne, inda kowanne tuple ke wakiltar kaya tare da farashinsa, mahimmanci, da rukuni (0 don manyan kayayyaki, lambar kaya na babban kaya idan na'ura ce).\n    Alal misali:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* बजट के भीतर खरीदारी के अधिकतम कुल मूल्य की गणना करता है, मुख्य वस्तुओं और उनके सहायक उपकरणों को ध्यान में रखते हुए।\n    - `totalMoney` कुल बजट है।\n    - `items` ट्यूपल की एक सूची है, जहां प्रत्येक ट्यूपल एक वस्तु का प्रतिनिधित्व करता है जिसमें उसकी कीमत, महत्व और श्रेणी होती है (मुख्य वस्तुओं के लिए 0, यदि सहायक उपकरण हो तो मुख्य वस्तु का आइटम नंबर)।\n    उदाहरण के लिए:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Kiszámítja a vásárlások maximális összértékét egy költségvetésen belül, figyelembe véve a fő tételeket és azok kiegészítőit.\n    - `totalMoney` a teljes költségvetés.\n    - `items` egy tuple-ök listája, ahol minden tuple egy tételt képvisel az árával, fontosságával és kategóriájával (0 a fő tételek esetén, a fő tétel sorszáma, ha kiegészítő).\n    Például:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)"
    },
    "prompt_bertscore": {
      "sq": "0.9919632161529474",
      "hy": "0.981501949874983",
      "bn": "0.9838749870372068",
      "bg": "0.9887855273171513",
      "zh": "0.968977509829209",
      "fr": "0.9886331778148975",
      "de": "0.9818978202243854",
      "ha": "0.9874727791288916",
      "hi": "0.9958013510056846",
      "hu": "0.9876869026796473"
    },
    "canonical_solution": "{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}",
    "instruction": {
      "en": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nՏվեք C# կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nনিচের C# কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar C# cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों का उपयोग करके प्रदान करें।",
      "hu": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9639110447001522",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9543420260937965",
      "hi": "0.9434010674456328",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) }) == 2200);\n        Debug.Assert(MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) }) == 1700);\n\n    }\n}\n",
    "entry_point": "MaxValueOfPurchases",
    "signature": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
    "docstring": {
      "en": "Calculates the maximum total value of purchases within a budget, considering main items and their accessories.\n    - `totalMoney` is the total budget.\n    - `items` is a list of tuples, where each tuple represents an item with its price, importance, and category (0 for main items, item number of the main item if an accessory).\n    For example:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700",
      "sq": "Llogarit vlerën maksimale totale të blerjeve brenda një buxheti, duke marrë parasysh artikujt kryesorë dhe aksesorët e tyre.\n- `totalMoney` është buxheti total.\n- `items` është një listë tuples, ku çdo tuple përfaqëson një artikull me çmimin e tij, rëndësinë dhe kategorinë (0 për artikujt kryesorë, numri i artikullit kryesor nëse është një aksesor).\nPër shembull:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "hy": "Հաշվում է գնումների առավելագույն ընդհանուր արժեքը բյուջեի սահմաններում՝ հաշվի առնելով հիմնական ապրանքները և դրանց աքսեսուարները։\n- `totalMoney`-ը ընդհանուր բյուջեն է։\n- `items`-ը տուփերի ցուցակ է, որտեղ յուրաքանչյուր տուփ ներկայացնում է ապրանքը իր գնով, կարևորությամբ և կատեգորիայով (0՝ հիմնական ապրանքների համար, հիմնական ապրանքի աքսեսուարի համար՝ հիմնական ապրանքի համարը)։\nՕրինակ՝\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "bn": "ক্রয়ের সর্বাধিক মোট মান গণনা করে একটি বাজেটের মধ্যে, প্রধান আইটেম এবং তাদের আনুষঙ্গিক বিবেচনা করে।\n- `totalMoney` হল মোট বাজেট।\n- `items` হল টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল একটি আইটেমকে তার মূল্য, গুরুত্ব এবং শ্রেণীবিভাগ সহ উপস্থাপন করে (0 প্রধান আইটেমের জন্য, একটি আনুষঙ্গিক হলে প্রধান আইটেমের আইটেম নম্বর)।\nউদাহরণস্বরূপ:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "bg": "Изчислява максималната обща стойност на покупките в рамките на бюджет, като се вземат предвид основните артикули и техните аксесоари.\n- `totalMoney` е общият бюджет.\n- `items` е списък от кортежи, където всеки кортеж представлява артикул с неговата цена, важност и категория (0 за основни артикули, номер на основния артикул, ако е аксесоар).\nНапример:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "zh": "计算在预算内购买的最大总价值，考虑主商品及其附件。\n- `totalMoney` 是总预算。\n- `items` 是一个元组列表，其中每个元组表示一个商品及其价格、重要性和类别（0表示主商品，如果是附件则为主商品的编号）。\n\n例如：\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "fr": "Calcule la valeur totale maximale des achats dans un budget, en considérant les articles principaux et leurs accessoires.\n- `totalMoney` est le budget total.\n- `items` est une liste de tuples, où chaque tuple représente un article avec son prix, son importance et sa catégorie (0 pour les articles principaux, numéro de l'article principal si c'est un accessoire).\n\nPar exemple :\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "de": "Berechnet den maximalen Gesamtwert der Einkäufe innerhalb eines Budgets, unter Berücksichtigung von Hauptartikeln und deren Zubehör.\n- `totalMoney` ist das Gesamtbudget.\n- `items` ist eine Liste von Tupeln, wobei jedes Tupel einen Artikel mit seinem Preis, seiner Wichtigkeit und seiner Kategorie darstellt (0 für Hauptartikel, Artikelnummer des Hauptartikels, wenn es sich um Zubehör handelt).\nZum Beispiel:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "ha": "Lissafi na mafi girman jimillar darajar sayayya cikin kasafin kudi, la'akari da manyan abubuwa da kayan haɗi.\n    - `totalMoney` shine jimlar kasafin kudi.\n    - `items` jerin tuples ne, inda kowanne tuple ke wakiltar abu tare da farashinsa, muhimmanci, da rukuni (0 don manyan abubuwa, lambar abu na babban abu idan kayan haɗi ne).\n    Alal misali:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700",
      "hi": "खरीदारी के अधिकतम कुल मूल्य की गणना करता है जो बजट के भीतर है, मुख्य वस्तुओं और उनके सहायक उपकरणों को ध्यान में रखते हुए।\n- `totalMoney` कुल बजट है।\n- `items` ट्यूपल की एक सूची है, जहाँ प्रत्येक ट्यूपल एक वस्तु को उसके मूल्य, महत्व, और श्रेणी (मुख्य वस्तुओं के लिए 0, यदि सहायक है तो मुख्य वस्तु का आइटम नंबर) के साथ दर्शाता है।\n\nउदाहरण के लिए:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "hu": "Kiszámítja a vásárlások maximális összértékét egy költségvetésen belül, figyelembe véve a fő tételeket és azok tartozékait.\n- `totalMoney` a teljes költségvetés.\n- `items` egy tuple-ök listája, ahol minden tuple egy tételt képvisel az árával, fontosságával és kategóriájával (0 a fő tételek esetén, a fő tétel sorszáma, ha tartozék).\nPéldául:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700"
    },
    "docstring_bertscore": {
      "sq": "0.9900166384188055",
      "hy": "0.9696518599728225",
      "bn": "0.9834934180752387",
      "bg": "0.9834419728065507",
      "zh": "0.9544618002135605",
      "fr": "0.988323314420483",
      "de": "0.9793366800913216",
      "ha": "0.9886798559544406",
      "hi": "0.9758127785013817",
      "hu": "0.9814044223578948"
    }
  },
  {
    "task_id": "C#/41",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calculates the total number of cigarettes Peter can smoke given an initial number of cigarettes and a conversion rate of butts to new cigarettes.\n    It is assumed that Peter can continue smoking and converting butts into new cigarettes as long as he has enough butts to do so.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur një numër fillestar të cigareve dhe një normë konvertimi të bishtave në cigare të reja.\n    Supozohet se Pjetri mund të vazhdojë të pijë dhe të konvertojë bishtat në cigare të reja për aq kohë sa ai ka mjaft bishta për ta bërë këtë.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Հաշվում է ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել՝ հաշվի առնելով սկզբնական ծխախոտների քանակը և ծխախոտի մնացորդների փոխակերպման գործակիցը:\n    Ենթադրվում է, որ Պետերը կարող է շարունակել ծխել և փոխակերպել մնացորդները նոր ծխախոտների, քանի դեռ նա ունի բավարար մնացորդներ դա անելու համար.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* পিটার কতগুলি সিগারেট খেতে পারবে তা গণনা করে যদি তাকে প্রাথমিকভাবে কিছু সিগারেট এবং বাট থেকে নতুন সিগারেট তৈরি করার একটি রূপান্তর হার দেওয়া হয়।\n    অনুমান করা হয় যে পিটার ধূমপান এবং বাট থেকে নতুন সিগারেট তৈরি করতে থাকবে যতক্ষণ তার কাছে যথেষ্ট বাট থাকবে তা করার জন্য।\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Изчислява общия брой цигари, които Петър може да изпуши, при даден начален брой цигари и курс на преобразуване на фасове в нови цигари.\n    Предполага се, че Петър може да продължи да пуши и да преобразува фасове в нови цигари, докато има достатъчно фасове, за да го направи.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 计算彼得可以抽的香烟总数，给定初始香烟数量和烟头转换为新香烟的转换率。\n    假设只要彼得有足够的烟头，他就可以继续抽烟并将烟头转换为新香烟。\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calcule le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un taux de conversion de mégots en nouvelles cigarettes.\n    Il est supposé que Peter peut continuer à fumer et à convertir les mégots en nouvelles cigarettes tant qu'il a suffisamment de mégots pour le faire.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und eine Umwandlungsrate von Kippen zu neuen Zigaretten.\n    Es wird angenommen, dass Peter weiter rauchen und Kippen in neue Zigaretten umwandeln kann, solange er genug Kippen dafür hat.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Lissafa jimillar adadin sigari da Peter zai iya sha idan aka ba shi adadin farko na sigari da kuma ƙimar canjin butts zuwa sabbin sigari.\n    Ana ɗauka cewa Peter na iya ci gaba da shan sigari da canza butts zuwa sabbin sigari muddin yana da isassun butts don yin hakan.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है, दिए गए प्रारंभिक सिगरेट की संख्या और बट्स को नई सिगरेट में बदलने की दर के आधार पर।\n    यह माना जाता है कि पीटर धूम्रपान जारी रख सकता है और बट्स को नई सिगरेट में बदल सकता है जब तक कि उसके पास ऐसा करने के लिए पर्याप्त बट्स हैं।\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni, ha adott számú cigarettával indul, és van egy konverziós arány a csikkek új cigarettává alakítására.\n    Feltételezzük, hogy Péter folytathatja a dohányzást és a csikkek új cigarettává alakítását, amíg elegendő csikke van ehhez.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)"
    },
    "prompt_bertscore": {
      "sq": "0.9855849959875361",
      "hy": "0.9834753427105646",
      "bn": "0.9559600691777067",
      "bg": "0.9815033402876502",
      "zh": "0.9669486991173187",
      "fr": "0.9869732237205889",
      "de": "0.9837748773251651",
      "ha": "0.9766100808508557",
      "hi": "0.9731634464791383",
      "hu": "0.9552640683225604"
    },
    "canonical_solution": "{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}",
    "instruction": {
      "en": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nՏվեք C# կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简明的自然语言描述（文档字符串）。",
      "fr": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568463579378843",
      "hy": "0.9287852481179426",
      "bn": "0.8913843391513593",
      "bg": "0.8379186022274364",
      "zh": "0.8542940881007146",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(TotalSmokedCigarettes(4, 3) == 5);\n        Debug.Assert(TotalSmokedCigarettes(10, 3) == 14);\n        Debug.Assert(TotalSmokedCigarettes(1, 2) == 1); // No conversion possible, should return initial cigarettes\n        Debug.Assert(TotalSmokedCigarettes(20, 4) ==26); // Additional case to test\n\n    }\n}",
    "entry_point": "TotalSmokedCigarettes",
    "signature": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial number of cigarettes and a conversion rate of butts to new cigarettes.\n    It is assumed that Peter can continue smoking and converting butts into new cigarettes as long as he has enough butts to do so.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "sq": "Llogarit numrin total të cigareve që Peter mund të pijë duke pasur parasysh një numër fillestar të cigareve dhe një normë konvertimi të bishtave në cigare të reja. \n    Supozohet se Peter mund të vazhdojë të pijë dhe të konvertojë bishtat në cigare të reja për aq kohë sa ai ka mjaftueshëm bishta për ta bërë këtë.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "hy": "Հաշվում է ընդհանուր ծխախոտների քանակը, որոնք Պետրոսը կարող է ծխել՝ հաշվի առնելով սկզբնական ծխախոտների քանակը և ծխախոտի մնացորդների փոխակերպման գործակիցը նոր ծխախոտների:\n    Ենթադրվում է, որ Պետրոսը կարող է շարունակել ծխել և փոխակերպել մնացորդները նոր ծխախոտների, քանի դեռ նա ունի բավարար մնացորդներ դա անելու համար.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "bn": "প্রাথমিক সিগারেটের সংখ্যা এবং বাট থেকে নতুন সিগারেটের রূপান্তর হার দেওয়া হলে পিটার মোট কত সিগারেট খেতে পারে তা গণনা করে। \n    ধরে নেওয়া হয় যে পিটারের কাছে যথেষ্ট বাট থাকলে সে ধূমপান এবং বাটকে নতুন সিগারেটে রূপান্তর করতে পারে।\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши, като се даде началният брой цигари и курсът на конвертиране на фасове в нови цигари. \n    Предполага се, че Петър може да продължи да пуши и да конвертира фасове в нови цигари, докато има достатъчно фасове, за да го направи.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "zh": "计算彼得可以抽的香烟总数，给定初始香烟数量和烟蒂转换为新香烟的比率。\n假设只要彼得有足够的烟蒂，他就可以继续抽烟并将烟蒂转换为新香烟。\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un taux de conversion de mégots en nouvelles cigarettes.  \n    On suppose que Peter peut continuer à fumer et à convertir les mégots en nouvelles cigarettes tant qu'il a suffisamment de mégots pour le faire.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und eine Umwandlungsrate von Kippen zu neuen Zigaretten.  \n    Es wird angenommen, dass Peter weiter rauchen und Kippen in neue Zigaretten umwandeln kann, solange er genug Kippen dafür hat.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "ha": "Yana ƙididdige yawan sigari da Peter zai iya sha la'akari da adadin sigari na farko da kuma ƙimar juyawa daga butts zuwa sabbin sigari.  \nAna ɗauka cewa Peter zai iya ci gaba da shan sigari da juyar da butts zuwa sabbin sigari muddin yana da isassun butts don yin hakan.\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "hi": "कुल सिगरेट की संख्या की गणना करता है जो पीटर धूम्रपान कर सकता है, दिए गए प्रारंभिक सिगरेट की संख्या और बट्स को नई सिगरेट में बदलने की दर के आधार पर।  \nयह माना जाता है कि पीटर धूम्रपान और बट्स को नई सिगरेट में बदलना जारी रख सकता है जब तक कि उसके पास ऐसा करने के लिए पर्याप्त बट्स हों।\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "hu": "Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni egy kezdeti cigarettaszám és egy konverziós arány alapján, amely a csikkek új cigarettákra való átváltását jelenti. \nFeltételezzük, hogy Péter folytathatja a dohányzást és a csikkek új cigarettákra való átváltását, amíg elegendő csikke van ehhez.\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14"
    },
    "docstring_bertscore": {
      "sq": "0.9786750422920945",
      "hy": "0.9520432766940797",
      "bn": "0.8839968780199098",
      "bg": "0.9695267228327705",
      "zh": "0.9269298417286956",
      "fr": "0.9786750422920945",
      "de": "0.9843737479239854",
      "ha": "0.9713807388093502",
      "hi": "0.959002490724018",
      "hu": "0.9466168933145875"
    }
  },
  {
    "task_id": "C#/42",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the number of pairs of students who are considered \"equal opponents\". Two students are equal opponents if the difference in each of their subjects' scores (Chinese, Mathematics, English) does not exceed 5, and the total difference in their scores does not exceed 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\". Dy studentë janë kundërshtarë të barabartë nëse diferenca në secilën nga notat e tyre në lëndë (Kinezisht, Matematikë, Anglisht) nuk e kalon 5, dhe diferenca totale në notat e tyre nuk e kalon 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշում է ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասար մրցակիցներ\": Երկու ուսանողներ համարվում են հավասար մրցակիցներ, եթե նրանց առարկաների (չինարեն, մաթեմատիկա, անգլերեն) գնահատականների տարբերությունը չի գերազանցում 5-ը, և նրանց ընդհանուր գնահատականների տարբերությունը չի գերազանցում 10-ը:\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \"সমান প্রতিদ্বন্দ্বী\" হিসেবে বিবেচিত ছাত্রদের জোড়ার সংখ্যা নির্ধারণ করে। দুই ছাত্র সমান প্রতিদ্বন্দ্বী যদি তাদের প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ এর বেশি না হয়, এবং তাদের স্কোরের মোট পার্থক্য ১০ এর বেশি না হয়।\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя броя на двойките ученици, които се считат за \"равни противници\". Двама ученици са равни противници, ако разликата в оценките им по всеки от предметите (Китайски, Математика, Английски) не надвишава 5, и общата разлика в оценките им не надвишава 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定被认为是“平等对手”的学生对的数量。如果两个学生在每个科目的分数差（语文、数学、英语）不超过5，并且他们的总分差不超过10，则这两个学生被认为是平等对手。\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine le nombre de paires d'élèves qui sont considérés comme des \"adversaires égaux\". Deux élèves sont des adversaires égaux si la différence dans chacune de leurs notes de matières (Chinois, Mathématiques, Anglais) ne dépasse pas 5, et la différence totale de leurs notes ne dépasse pas 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" gelten. Zwei Schüler sind gleichwertige Gegner, wenn der Unterschied in jedem ihrer Fächer (Chinesisch, Mathematik, Englisch) 5 nicht überschreitet und der Gesamtdifferenz ihrer Punktzahlen 10 nicht überschreitet.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana ƙayyade adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"abokan hamayya masu daidaito\". Ana ɗaukar ɗalibai biyu a matsayin abokan hamayya masu daidaito idan bambanci a kowanne daga cikin maki na batutuwansu (Sinanci, Lissafi, Turanci) bai wuce 5 ba, kuma jimillar bambanci a maki nasu bai wuce 10 ba.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* उन छात्रों की जोड़ी की संख्या निर्धारित करता है जिन्हें \"समान प्रतिद्वंद्वी\" माना जाता है। दो छात्र समान प्रतिद्वंद्वी होते हैं यदि उनके प्रत्येक विषय के अंकों (चीनी, गणित, अंग्रेजी) में अंतर 5 से अधिक नहीं होता है, और उनके अंकों के कुल अंतर 10 से अधिक नहीं होता है।\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza azoknak a diákpároknak a számát, akiket \"egyenlő ellenfeleknek\" tekintünk. Két diák akkor tekinthető egyenlő ellenfélnek, ha az egyes tantárgyaik (kínai, matematika, angol) pontszáma közötti különbség nem haladja meg az 5-öt, és az összpontszámuk közötti különbség nem haladja meg a 10-et.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)"
    },
    "prompt_bertscore": {
      "sq": "0.9760747719739666",
      "hy": "0.9824605400938573",
      "bn": "0.985897838837666",
      "bg": "0.988749575218184",
      "zh": "0.9586828944409329",
      "fr": "0.9938241841928632",
      "de": "0.9851086803338144",
      "ha": "0.9872193267626912",
      "hi": "0.9832210958228399",
      "hu": "0.9745179070474153"
    },
    "canonical_solution": "{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}",
    "instruction": {
      "en": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nOfroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nՏրամադրել C# կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9226191651994765",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9243830029830663",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) }) == 2);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(92, 95, 98), Tuple.Create(85, 90, 95) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 95, 90), Tuple.Create(95, 90, 85), Tuple.Create(90, 85, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(80, 80, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(100, 100, 99), Tuple.Create(101, 100, 99) }) == 3);\n\n    }\n}\n",
    "entry_point": "FindEqualOpponents",
    "signature": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
    "docstring": {
      "en": "Determines the number of pairs of students who are considered \"equal opponents\". Two students are equal opponents if the difference in each of their subjects' scores (Chinese, Mathematics, English) does not exceed 5, and the total difference in their scores does not exceed 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "sq": "Përcakton numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\". Dy studentë janë kundërshtarë të barabartë nëse diferenca në secilën nga notat e tyre në lëndët (Kinezisht, Matematikë, Anglisht) nuk tejkalon 5, dhe diferenca totale në notat e tyre nuk tejkalon 10.  \n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "hy": "Սահմանում է ուսանողների զույգերի քանակը, ովքեր համարվում են \"հավասար մրցակիցներ\": Երկու ուսանողներ համարվում են հավասար մրցակիցներ, եթե նրանց առարկաների (չինարեն, մաթեմատիկա, անգլերեն) գնահատականների տարբերությունը չի գերազանցում 5-ը, և նրանց ընդհանուր գնահատականների տարբերությունը չի գերազանցում 10-ը.  \n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "bn": "সমান প্রতিদ্বন্দ্বী হিসেবে বিবেচিত শিক্ষার্থীদের জোড়ার সংখ্যা নির্ধারণ করে। দুই শিক্ষার্থী সমান প্রতিদ্বন্দ্বী যদি তাদের প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ এর বেশি না হয়, এবং তাদের মোট স্কোরের পার্থক্য ১০ এর বেশি না হয়।\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "bg": "Определя броя на двойките ученици, които се считат за \"равни противници\". Двама ученици са равни противници, ако разликата в оценките им по всеки от предметите (Китайски, Математика, Английски) не надвишава 5, и общата разлика в техните оценки не надвишава 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "zh": "确定被认为是“势均力敌”的学生对数。如果两个学生在每个科目（语文、数学、英语）的分数差不超过5，并且他们的总分差不超过10，则这两个学生被认为是势均力敌的对手。\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "fr": "Détermine le nombre de paires d'élèves qui sont considérés comme des \"adversaires égaux\". Deux élèves sont des adversaires égaux si la différence dans chacune de leurs notes de matières (Chinois, Mathématiques, Anglais) ne dépasse pas 5, et si la différence totale de leurs scores ne dépasse pas 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "de": "Bestimmt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" betrachtet werden. Zwei Schüler sind gleichwertige Gegner, wenn der Unterschied in jedem ihrer Fachnoten (Chinesisch, Mathematik, Englisch) nicht mehr als 5 beträgt und der Gesamtdifferenz ihrer Noten nicht mehr als 10 beträgt.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "ha": "Yana ƙayyade yawan ma'aurata na ɗalibai waɗanda ake ɗauka \"abokan hamayya masu daidaito\". Ana ɗaukar ɗalibai biyu a matsayin abokan hamayya masu daidaito idan bambancin kowanne daga cikin maki na batutuwarsu (Sinanci, Lissafi, Turanci) bai wuce 5 ba, kuma jimillar bambancin a cikin maki nasu bai wuce 10 ba.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "hi": "उन छात्रों की जोड़ी की संख्या निर्धारित करता है जिन्हें \"समान प्रतिद्वंद्वी\" माना जाता है। दो छात्र समान प्रतिद्वंद्वी होते हैं यदि उनके प्रत्येक विषय के अंकों (चीनी, गणित, अंग्रेजी) में अंतर 5 से अधिक नहीं होता है, और उनके अंकों में कुल अंतर 10 से अधिक नहीं होता है।\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "hu": "Meghatározza az \"egyenlő ellenfeleknek\" tekintett diákpárok számát. Két diák akkor tekinthető egyenlő ellenfélnek, ha az egyes tantárgyaik (kínai, matematika, angol) pontszáma közötti különbség nem haladja meg az 5-öt, és az összpontszámuk közötti különbség nem haladja meg a 10-et.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9770198553269307",
      "hy": "0.9695455927189689",
      "bn": "0.9618043708788961",
      "bg": "0.9818662379938009",
      "zh": "0.9312478675820132",
      "fr": "0.9840912955221537",
      "de": "0.973554351069015",
      "ha": "0.9765610191467401",
      "hi": "0.9821957657959378",
      "hu": "0.9737124608523188"
    }
  },
  {
    "task_id": "C#/43",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds the length of the longest consecutive elements sequence in a given list of integers.\n    The sequence does not need to be in order but must consist of consecutive natural numbers.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Gjen gjatësinë e sekuencës më të gjatë të elementeve radhazi në një listë të dhënë të numrave të plotë.\n    Sekuenca nuk ka nevojë të jetë në rend, por duhet të përbëhet nga numra natyrorë radhazi.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Գտնում է տրված ամբողջ թվերի ցանկում ամենաերկար հաջորդական տարրերի հաջորդականության երկարությունը:\n    Հաջորդականությունը կարիք չունի լինել կարգավորված, բայց պետք է բաղկացած լինի հաջորդական բնական թվերից:\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* প্রদত্ত পূর্ণসংখ্যার তালিকায় সবচেয়ে দীর্ঘ ক্রমিক উপাদানগুলির ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n    ক্রমটি ক্রম অনুসারে হওয়ার প্রয়োজন নেই তবে অবশ্যই ক্রমিক প্রাকৃতিক সংখ্যাগুলি নিয়ে গঠিত হতে হবে।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Намира дължината на най-дългата последователност от последователни елементи в даден списък от цели числа.\n    Последователността не е необходимо да бъде в ред, но трябва да се състои от последователни естествени числа.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 查找给定整数列表中最长连续元素序列的长度。\n    序列不需要按顺序排列，但必须由连续的自然数组成。\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Trouve la longueur de la plus longue séquence d'éléments consécutifs dans une liste donnée d'entiers.\n    La séquence n'a pas besoin d'être ordonnée mais doit être constituée de nombres naturels consécutifs.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Findet die Länge der längsten Sequenz aufeinanderfolgender Elemente in einer gegebenen Liste von ganzen Zahlen.\n    Die Sequenz muss nicht in Reihenfolge sein, muss aber aus aufeinanderfolgenden natürlichen Zahlen bestehen.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Nemi tsawon jerin abubuwa masu jere mafi tsawo a cikin jerin lambobin kirga da aka bayar.\n    Jerin ba lallai ne ya kasance a tsari ba amma dole ne ya ƙunshi lambobin halitta masu jere.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दिए गए पूर्णांकों की सूची में सबसे लंबे लगातार तत्वों के अनुक्रम की लंबाई पाता है।\n    अनुक्रम क्रम में नहीं होना चाहिए लेकिन इसमें लगातार प्राकृतिक संख्याएँ होनी चाहिए।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megkeresi a leghosszabb egymást követő elemek sorozatának hosszát egy adott egész számok listájában.\n    A sorozatnak nem kell sorrendben lennie, de egymást követő természetes számokból kell állnia.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)"
    },
    "prompt_bertscore": {
      "sq": "0.9819441011031665",
      "hy": "0.9812925934533722",
      "bn": "0.9916271335482364",
      "bg": "0.9885193626065645",
      "zh": "0.989143062003014",
      "fr": "0.9923159837096653",
      "de": "0.9876128135475213",
      "ha": "0.9760122034039407",
      "hi": "0.9972537363518116",
      "hu": "0.9937643964481717"
    },
    "canonical_solution": "{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}",
    "instruction": {
      "en": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nՏրամադրել կարճ բնութագիր (docstring) տվյալ C# կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nFournir une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.8869954022520125",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8316742589388426",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9}) == 6);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {100, 4, 200, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 1}) == 1);\n\n    }\n}\n\n",
    "entry_point": "LongestConsecutiveSequence",
    "signature": "static int LongestConsecutiveSequence(List<int> sequence)",
    "docstring": {
      "en": "Finds the length of the longest consecutive elements sequence in a given list of integers.\n    The sequence does not need to be in order but must consist of consecutive natural numbers.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "sq": "Gjen gjatësinë e sekuencës më të gjatë të elementeve të njëpasnjëshme në një listë të dhënë të numrave të plotë.\n    Sekuenca nuk ka nevojë të jetë në rend, por duhet të përbëhet nga numra natyralë të njëpasnjëshëm.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hy": "Գտնում է տրված ամբողջ թվերի ցուցակի ամենաերկար հաջորդական տարրերի հաջորդականության երկարությունը:\n    Հաջորդականությունը պետք չէ լինել կարգավորված, բայց պետք է բաղկացած լինի հաջորդական բնական թվերից:\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "bn": "দেওয়া পূর্ণসংখ্যার তালিকায় সবচেয়ে দীর্ঘ ধারাবাহিক উপাদানগুলির ক্রমের দৈর্ঘ্য খুঁজে বের করে। \n    ক্রমটি ক্রমানুসারে হতে হবে না তবে ধারাবাহিক প্রাকৃতিক সংখ্যাগুলি নিয়ে গঠিত হতে হবে।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "bg": "Намира дължината на най-дългата последователност от последователни елементи в даден списък от цели числа.\n    Последователността не е необходимо да бъде подредена, но трябва да се състои от последователни естествени числа.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "zh": "找到给定整数列表中最长连续元素序列的长度。  \n    序列不需要按顺序排列，但必须由连续的自然数组成。\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "fr": "Trouve la longueur de la plus longue séquence d'éléments consécutifs dans une liste donnée d'entiers.\n    La séquence n'a pas besoin d'être ordonnée mais doit être constituée de nombres naturels consécutifs.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "de": "Findet die Länge der längsten Sequenz aufeinanderfolgender Elemente in einer gegebenen Liste von ganzen Zahlen.\n    Die Sequenz muss nicht in Ordnung sein, muss aber aus aufeinanderfolgenden natürlichen Zahlen bestehen.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "ha": "Yana nemo tsawon jerin abubuwan da suka fi tsayi a jere a cikin jerin lambobin cikakku da aka bayar.\n    Jerin ba dole ne ya kasance a tsari ba amma dole ne ya ƙunshi lambobin halitta masu jere.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hi": "दिए गए पूर्णांकों की सूची में सबसे लंबे लगातार तत्वों के अनुक्रम की लंबाई खोजता है। अनुक्रम को क्रम में होने की आवश्यकता नहीं है लेकिन इसमें लगातार प्राकृतिक संख्याएँ होनी चाहिए।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hu": "Megtalálja a leghosszabb egymást követő elemek sorozatának hosszát egy adott egész számokat tartalmazó listában.\n    A sorozatnak nem kell sorrendben lennie, de egymást követő természetes számokból kell állnia.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4"
    },
    "docstring_bertscore": {
      "sq": "0.9799905713056885",
      "hy": "0.9801202769445042",
      "bn": "0.9969905510969405",
      "bg": "0.9718302393616322",
      "zh": "0.9883068280988572",
      "fr": "0.9837750759555461",
      "de": "0.9919310380312197",
      "ha": "0.9593266555058669",
      "hi": "0.9914412155115877",
      "hu": "0.9971719006348253"
    }
  },
  {
    "task_id": "C#/44",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines whose geometric shape has a larger area: Alice's square with side length a, or Bob's rectangle with sides b and c.\n    - If Alice's square has a larger area, return \"Alice\".\n    - If Bob's rectangle has a larger area, return \"Bob\".\n    \n    Examples:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton se cila formë gjeometrike ka një sipërfaqe më të madhe: katrori i Alice me gjatësi brinje a, apo drejtkëndëshi i Bob me brinjët b dhe c.\n    - Nëse katrori i Alice ka një sipërfaqe më të madhe, kthe \"Alice\".\n    - Nëse drejtkëndëshi i Bob ka një sipërfaqe më të madhe, kthe \"Bob\".\n    \n    Shembuj:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշում է, թե ում երկրաչափական ձևն ունի ավելի մեծ մակերես՝ Ալիսի քառակուսին կողքի երկարությամբ a, թե՞ Բոբի ուղղանկյունը կողմերով b և c։\n    - Եթե Ալիսի քառակուսին ունի ավելի մեծ մակերես, վերադարձնում է \"Alice\"։\n    - Եթե Բոբի ուղղանկյունը ունի ավելի մեծ մակերես, վերադարձնում է \"Bob\"։\n    \n    Օրինակներ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* নির্ধারণ করে কার জ্যামিতিক আকারের ক্ষেত্রফল বড়: অ্যালিসের বর্গক্ষেত্র যার বাহুর দৈর্ঘ্য a, অথবা ববের আয়তক্ষেত্র যার বাহুগুলি b এবং c।\n    - যদি অ্যালিসের বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Alice\" ফেরত দিন।\n    - যদি ববের আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Bob\" ফেরত দিন।\n    \n    উদাহরণ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя чия геометрична форма има по-голяма площ: квадратът на Алис със страна a, или правоъгълникът на Боб със страни b и c.\n    - Ако квадратът на Алис има по-голяма площ, връща \"Alice\".\n    - Ако правоъгълникът на Боб има по-голяма площ, връща \"Bob\".\n    \n    Примери:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定谁的几何形状面积更大：Alice 的边长为 a 的正方形，还是 Bob 的边长为 b 和 c 的矩形。\n    - 如果 Alice 的正方形面积更大，返回 \"Alice\"。\n    - 如果 Bob 的矩形面积更大，返回 \"Bob\"。\n    \n    示例：\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine quelle forme géométrique a une plus grande surface : le carré d'Alice avec une longueur de côté a, ou le rectangle de Bob avec des côtés b et c.\n    - Si le carré d'Alice a une plus grande surface, retourne \"Alice\".\n    - Si le rectangle de Bob a une plus grande surface, retourne \"Bob\".\n    \n    Exemples :\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt, wessen geometrische Form eine größere Fläche hat: Alices Quadrat mit Seitenlänge a oder Bobs Rechteck mit den Seiten b und c.\n    - Wenn Alices Quadrat eine größere Fläche hat, gib \"Alice\" zurück.\n    - Wenn Bobs Rechteck eine größere Fläche hat, gib \"Bob\" zurück.\n    \n    Beispiele:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantance wane daga cikin siffofin lissafi ne ke da babbar fadin: murabba'in Alice da gefen tsawo a, ko kuma murabba'in Bob da gefen tsawo b da c.\n    - Idan murabba'in Alice yana da babbar fadi, dawo da \"Alice\".\n    - Idan murabba'in Bob yana da babbar fadi, dawo da \"Bob\".\n    \n    Misalai:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह निर्धारित करता है कि किसका ज्यामितीय आकार बड़ा है: ऐलिस का वर्ग जिसकी भुजा की लंबाई a है, या बॉब का आयत जिसकी भुजाएँ b और c हैं।\n    - यदि ऐलिस के वर्ग का क्षेत्रफल बड़ा है, तो \"Alice\" लौटाएँ।\n    - यदि बॉब के आयत का क्षेत्रफल बड़ा है, तो \"Bob\" लौटाएँ।\n    \n    उदाहरण:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza, hogy kinek a geometriai alakzata rendelkezik nagyobb területtel: Alice négyzete, amelynek oldalhossza a, vagy Bob téglalapja, amelynek oldalai b és c.\n    - Ha Alice négyzete nagyobb területtel rendelkezik, adja vissza az \"Alice\" értéket.\n    - Ha Bob téglalapja nagyobb területtel rendelkezik, adja vissza a \"Bob\" értéket.\n    \n    Példák:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "sq": "0.9958684880744744",
      "hy": "0.9980975182104478",
      "bn": "0.9919630175225663",
      "bg": "0.9916690445586347",
      "zh": "0.9919630175225663",
      "fr": "0.9929281625440148",
      "de": "0.9975808805893761",
      "ha": "0.9687447150226361",
      "hi": "0.9808633531999558",
      "hu": "0.9858626812602229"
    },
    "canonical_solution": "{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}",
    "instruction": {
      "en": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nՏրամադրել C# կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nFournir une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nBa da takaitaccen bayani na yanayin harshen halitta (docstring) na lambar C# a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9120407069967015",
      "bn": "0.8778230485165833",
      "bg": "0.831676443873034",
      "zh": "0.8804217297916628",
      "fr": "0.9703846074484602",
      "de": "0.9388230344235406",
      "ha": "0.9018956602853446",
      "hi": "0.9150793545657733",
      "hu": "0.9437490678732059"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CompareArea(5, 4, 6) == \"Alice\");\n        Debug.Assert(CompareArea(7, 5, 10) == \"Bob\");\n        Debug.Assert(CompareArea(2, 2, 8) == \"Bob\"); // Testing with a square of side 2 and a rectangle 2x8\n        Debug.Assert(CompareArea(10, 5, 5) == \"Alice\"); // Testing with a square of side 10 and a rectangle 5x5\n\n\n    }\n}\n\n",
    "entry_point": "CompareArea",
    "signature": "static string CompareArea(int a, int b, int c)",
    "docstring": {
      "en": "Determines whose geometric shape has a larger area: Alice's square with side length a, or Bob's rectangle with sides b and c.\n    - If Alice's square has a larger area, return \"Alice\".\n    - If Bob's rectangle has a larger area, return \"Bob\".\n    \n    Examples:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "sq": "Përcakton se cila formë gjeometrike ka një sipërfaqe më të madhe: katrori i Alice me gjatësi të brinjës a, apo drejtkëndëshi i Bob me brinjët b dhe c.\n    - Nëse katrori i Alice ka një sipërfaqe më të madhe, kthe \"Alice\".\n    - Nëse drejtkëndëshi i Bob ka një sipërfaqe më të madhe, kthe \"Bob\".\n    \n    Shembuj:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "hy": "Սահմանում է, թե ում երկրաչափական ձևն ունի ավելի մեծ մակերես՝ Ալիսի քառակուսին կողմի երկարությամբ a, թե՞ Բոբի ուղղանկյունը կողմերով b և c:\n- Եթե Ալիսի քառակուսին ունի ավելի մեծ մակերես, վերադարձնում է \"Alice\":\n- Եթե Բոբի ուղղանկյունը ունի ավելի մեծ մակերես, վերադարձնում է \"Bob\":\n\nՕրինակներ:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "bn": "নির্ধারণ করে কার জ্যামিতিক আকারের ক্ষেত্রফল বড়: অ্যালিসের বর্গক্ষেত্র যার বাহুর দৈর্ঘ্য a, অথবা ববের আয়তক্ষেত্র যার বাহুর দৈর্ঘ্য b এবং c।\n    - যদি অ্যালিসের বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Alice\" ফেরত দিন।\n    - যদি ববের আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Bob\" ফেরত দিন।\n    \n    উদাহরণসমূহ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "bg": "Определя чия геометрична форма има по-голяма площ: квадратът на Алис със страна a, или правоъгълникът на Боб със страни b и c.\n    - Ако квадратът на Алис има по-голяма площ, връща \"Alice\".\n    - Ако правоъгълникът на Боб има по-голяма площ, връща \"Bob\".\n    \n    Примери:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "zh": "确定谁的几何形状面积更大：Alice的边长为a的正方形，还是Bob的边长为b和c的矩形。\n    - 如果Alice的正方形面积更大，返回\"Alice\"。\n    - 如果Bob的矩形面积更大，返回\"Bob\"。\n    \n    示例：\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "fr": "Détermine quelle forme géométrique a une plus grande surface : le carré d'Alice avec un côté de longueur a, ou le rectangle de Bob avec des côtés b et c.\n    - Si le carré d'Alice a une plus grande surface, retourne \"Alice\".\n    - Si le rectangle de Bob a une plus grande surface, retourne \"Bob\".\n    \n    Exemples :\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "de": "Bestimmt, wessen geometrische Form eine größere Fläche hat: Alices Quadrat mit Seitenlänge a oder Bobs Rechteck mit den Seiten b und c.\n- Wenn Alices Quadrat eine größere Fläche hat, gib \"Alice\" zurück.\n- Wenn Bobs Rechteck eine größere Fläche hat, gib \"Bob\" zurück.\n\nBeispiele:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "ha": "Yana ƙayyade wane siffar lissafi ke da babbar yanki: murabba'in Alice da tsawon gefe a, ko kuma murabba'in Bob da gefuna b da c.\n   - Idan murabba'in Alice yana da babbar yanki, dawo da \"Alice\".\n   - Idan murabba'in Bob yana da babbar yanki, dawo da \"Bob\".\n    \n   Misalai:\n   >>> CompareArea(5, 4, 6)\n   \"Alice\"\n    \n   >>> CompareArea(7, 5, 10)\n   \"Bob\"",
      "hi": "निर्धारित करता है कि किसका ज्यामितीय आकार बड़ा क्षेत्रफल रखता है: ऐलिस का वर्ग जिसकी भुजा की लंबाई a है, या बॉब का आयत जिसकी भुजाएँ b और c हैं।\n- यदि ऐलिस के वर्ग का क्षेत्रफल बड़ा है, तो \"Alice\" लौटाएं।\n- यदि बॉब के आयत का क्षेत्रफल बड़ा है, तो \"Bob\" लौटाएं।\n\nउदाहरण:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "hu": "Meghatározza, hogy kinek a geometriai alakzata rendelkezik nagyobb területtel: Alice négyzete, amelynek oldalhossza a, vagy Bob téglalapja, amelynek oldalai b és c.\n    - Ha Alice négyzete nagyobb területtel rendelkezik, térjen vissza az \"Alice\" értékkel.\n    - Ha Bob téglalapja nagyobb területtel rendelkezik, térjen vissza a \"Bob\" értékkel.\n    \n    Példák:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\""
    },
    "docstring_bertscore": {
      "sq": "0.9941600681671933",
      "hy": "0.9804821814987498",
      "bn": "0.9843636177745526",
      "bg": "0.9879306221571771",
      "zh": "0.9825699854338076",
      "fr": "0.9775374860999076",
      "de": "0.9931772450418326",
      "ha": "0.9479266620471316",
      "hi": "0.9764499847637416",
      "hu": "0.9894870898229665"
    }
  },
  {
    "task_id": "C#/45",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds M positive integers that sum up to N and have the maximum possible product. If multiple solutions exist, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Gjen M numra të plotë pozitivë që kanë shumën N dhe kanë produktin maksimal të mundshëm. Nëse ekzistojnë zgjidhje të shumta,\n   kthen atë me sekuencën më të vogël leksikografike.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Գտնում է M դրական ամբողջ թվեր, որոնք գումարվում են N-ի և ունեն հնարավոր առավելագույն արտադրյալը։ Եթե գոյություն ունեն մի քանի լուծումներ,\n   վերադարձնում է այն մեկը, որը ունի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը։\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যা N এর সমান যোগফল দেয় এবং সর্বাধিক সম্ভাব্য গুণফল থাকে। যদি একাধিক সমাধান থাকে,\n   তাহলে লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট ক্রমটি ফেরত দেয়।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Намира M положителни цели числа, които се сумират до N и имат максимално възможен произведение. Ако съществуват множество решения,\n   връща това с лексикографски най-малката последователност.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 查找 M 个正整数，这些整数的和为 N，并且乘积最大。如果存在多个解决方案，\n   返回按字典序排列的最小序列。\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Trouve M entiers positifs dont la somme est égale à N et ayant le produit maximal possible. Si plusieurs solutions existent,\n   retourne celle avec la séquence lexicographiquement la plus petite.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Findet M positive ganze Zahlen, die sich zu N summieren und das maximal mögliche Produkt haben. Wenn mehrere Lösungen existieren,\n   wird diejenige mit der lexikografisch kleinsten Sequenz zurückgegeben.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Nemi lambobi masu kyau M waɗanda suka haɗu zuwa N kuma suna da mafi girman samfurin da zai yiwu. Idan akwai hanyoyi da yawa, \n   dawo da wanda ke da jerin mafi ƙarancin lexicographically.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* M धनात्मक पूर्णांक खोजता है जिनका योग N होता है और जिनका गुणनफल अधिकतम संभव होता है। यदि कई समाधान मौजूद हैं,\n   तो वह अनुक्रम लौटाता है जो शब्दकोश क्रम में सबसे छोटा होता है।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megkeresi azt az M pozitív egész számot, amelyek összege N és a lehető legnagyobb szorzatot adják. Ha több megoldás létezik,\n   akkor a lexikografikusan legkisebb sorozatot adja vissza.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)"
    },
    "prompt_bertscore": {
      "sq": "0.9844120835875251",
      "hy": "0.9922065383697152",
      "bn": "0.981274319458317",
      "bg": "0.9935631838721835",
      "zh": "0.9482724775405134",
      "fr": "0.982327854999326",
      "de": "0.993856759575353",
      "ha": "0.9555645960890662",
      "hi": "0.9648855253495093",
      "hu": "0.9431764164846823"
    },
    "canonical_solution": "    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }",
    "instruction": {
      "en": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nՏվեք C# կոդի համառոտ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nC# कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में अधिकतम 500 वर्णों का उपयोग करके प्रदान करें।",
      "hu": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9169325760208287",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8481460805469228",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9543420260937965",
      "hi": "0.9701569770317943",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxProductPartition(6, 3).SequenceEqual(new List<int> { 2, 2, 2 }));\n        Debug.Assert(MaxProductPartition(8, 3).SequenceEqual(new List<int> { 2, 3, 3 }));\n        Debug.Assert(MaxProductPartition(10, 2).SequenceEqual(new List<int> { 5, 5 }));\n        Debug.Assert(MaxProductPartition(7, 3).SequenceEqual(new List<int> { 2, 2, 3 }));\n\n    }\n}\n",
    "entry_point": "MaxProductPartition",
    "signature": "public static List<int> MaxProductPartition(int N, int M)",
    "docstring": {
      "en": "Finds M positive integers that sum up to N and have the maximum possible product. If multiple solutions exist, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "sq": "Gjen M numra të plotë pozitivë që shuma e tyre është N dhe kanë produktin maksimal të mundshëm. Nëse ekzistojnë zgjidhje të shumta, kthen atë me sekuencën leksikografikisht më të vogël.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "hy": "Գտնում է M դրական ամբողջ թվեր, որոնք գումարվում են N-ի և ունեն հնարավոր առավելագույն արտադրյալը։ Եթե գոյություն ունեն բազմաթիվ լուծումներ, վերադարձնում է այն, որն ունի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը։\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "bn": "এমটি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যা এন-এর সমান এবং সর্বাধিক সম্ভাব্য গুণফল থাকে। যদি একাধিক সমাধান থাকে, তাহলে লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট ক্রমটি ফেরত দেয়।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "bg": "Намира M положителни цели числа, които се сумират до N и имат максимално възможния произведение. Ако съществуват множество решения, \n   връща това с лексикографски най-малката последователност.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "zh": "找到 M 个正整数，这些整数的和为 N，并且它们的乘积最大。如果存在多个解决方案，则返回字典序最小的序列。\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "fr": "Trouve M entiers positifs dont la somme est égale à N et qui ont le produit maximum possible. Si plusieurs solutions existent, retourne celle avec la séquence lexicographiquement la plus petite.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "de": "Findet M positive ganze Zahlen, die sich zu N summieren und das maximal mögliche Produkt haben. Wenn mehrere Lösungen existieren, wird diejenige mit der lexikografisch kleinsten Sequenz zurückgegeben.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "ha": "Nemi lambobin M masu kyau waɗanda ke ƙara zuwa N kuma suna da mafi girman samfurin da zai yiwu. Idan akwai hanyoyi da dama, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "hi": "M सकारात्मक पूर्णांक खोजता है जिनका योग N होता है और जिनका गुणनफल अधिकतम संभव होता है। यदि कई समाधान मौजूद हैं, तो \n   वर्णक्रमानुसार सबसे छोटे अनुक्रम वाला समाधान लौटाता है।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "hu": "Megtalálja azt az M pozitív egész számot, amelyek összege N és a lehető legnagyobb szorzatot adják. Ha több megoldás létezik, \n   akkor a lexikografikusan legkisebb sorozatot adja vissza.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]"
    },
    "docstring_bertscore": {
      "sq": "0.9531522301113975",
      "hy": "0.9860364828436284",
      "bn": "0.9120714947057619",
      "bg": "1",
      "zh": "0.8968091334878032",
      "fr": "0.958558353192024",
      "de": "0.9715352732457954",
      "ha": "0.9717563488598872",
      "hi": "0.8970119351068397",
      "hu": "0.8956604539942784"
    }
  },
  {
    "task_id": "C#/46",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Counts the number of characters in a given title string, excluding spaces and newline characters.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Numëron numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e reja të rreshtave.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Հաշվում է տրված վերնագրի տողում գտնվող սիմվոլների քանակը, բացի բացատներից և նոր տողի սիմվոլներից։\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* প্রদত্ত শিরোনাম স্ট্রিং-এ কতগুলি অক্ষর রয়েছে তা গণনা করে, স্পেস এবং নিউলাইন অক্ষর বাদ দিয়ে।\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Брои броя на символите в даден низ за заглавие, изключвайки интервали и знаци за нов ред.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 计算给定标题字符串中的字符数，不包括空格和换行符。\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Compte le nombre de caractères dans une chaîne de titre donnée, à l'exclusion des espaces et des caractères de nouvelle ligne.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Zählt die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana ƙididdige yawan haruffa a cikin wata takamaiman taken zare, ba tare da haɗa sarari da haruffan sabon layi ba.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या गिनता है, जिसमें स्पेस और न्यूलाइन वर्ण शामिल नहीं होते।\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megszámolja a karakterek számát egy adott cím stringben, kivéve a szóközöket és az új sor karaktereket.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9969228181370076",
      "bn": "0.9969228181370076",
      "bg": "0.999999801369619",
      "zh": "0.9858448045259297",
      "fr": "0.999999801369619",
      "de": "0.9858954552730936",
      "ha": "0.9814846690318328",
      "hi": "0.9969228181370076",
      "hu": "0.999999801369619"
    },
    "canonical_solution": "{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}",
    "instruction": {
      "en": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nՏվեք C# կոդի համառոտ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简明的自然语言描述（文档字符串）。",
      "fr": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nBa da takaitaccen bayani na yanayin aikin lambar C# a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9169325760208287",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9388230344235406",
      "ha": "0.8348447970809215",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountTitleCharacters(\"234\") == 3);\n        Debug.Assert(CountTitleCharacters(\"Ca 45\") == 4);\n        Debug.Assert(CountTitleCharacters(\"Hello World\\n\") == 10);\n        Debug.Assert(CountTitleCharacters(\" 123 \") == 3);\n        Debug.Assert(CountTitleCharacters(\"\\nNew\\tLine\") == 7);\n\n    }\n}",
    "entry_point": "CountTitleCharacters",
    "signature": "static int CountTitleCharacters(string title)",
    "docstring": {
      "en": "Counts the number of characters in a given title string, excluding spaces and newline characters.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "sq": "Numëron numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "hy": "Հաշվում է տրված վերնագրի տողի մեջ գտնվող սիմվոլների քանակը՝ բացառելով բացատները և նոր տողի սիմվոլները։  \n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "bn": "প্রদত্ত শিরোনাম স্ট্রিং-এ স্পেস এবং নতুন লাইন অক্ষর বাদ দিয়ে অক্ষরের সংখ্যা গণনা করে।  \n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "bg": "Брои броя на символите в даден низ за заглавие, без да включва интервали и знаци за нов ред.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "zh": "计算给定标题字符串中的字符数，排除空格和换行符。  \n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "fr": "Compte le nombre de caractères dans une chaîne de titre donnée, en excluant les espaces et les caractères de nouvelle ligne.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "de": "Zählt die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche zu berücksichtigen.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "ha": "Yana ƙididdige yawan haruffa a cikin wata takamaiman jeri na take, ba tare da haɗa sarari da haruffan sabon layi ba.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "hi": "दिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या गिनता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "hu": "Számolja meg a karakterek számát egy adott cím stringben, kivéve a szóközöket és az új sor karaktereket.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9950938295884383",
      "bn": "0.9803782978094686",
      "bg": "1",
      "zh": "0.9864798258540982",
      "fr": "0.9919220996640732",
      "de": "0.9796930229948982",
      "ha": "0.9551713079346171",
      "hi": "0.9950938295884383",
      "hu": "0.9919220996640732"
    }
  },
  {
    "task_id": "C#/47",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the number of students who have enrolled in both Course A and Course B.\n    Given two lists of student IDs for each course, this function counts how many IDs appear in both lists.\n    - courseAStudents: List<int> representing student IDs enrolled in Course A.\n    - courseBStudents: List<int> representing student IDs enrolled in Course B.\n    \n    Example usage:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton numrin e studentëve që janë regjistruar si në Kursin A ashtu edhe në Kursin B.\n    Duke pasur dy lista të ID-ve të studentëve për secilin kurs, kjo funksion numëron sa ID shfaqen në të dyja listat.\n    - courseAStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin A.\n    - courseBStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin B.\n    \n    Shembull përdorimi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշում է այն ուսանողների քանակը, ովքեր գրանցված են ինչպես Դասընթաց A-ում, այնպես էլ Դասընթաց B-ում:\n    Տրված են յուրաքանչյուր դասընթացի ուսանողների ID-ների ցուցակներ, այս ֆունկցիան հաշվում է, թե քանի ID է հայտնվում երկու ցուցակներում:\n    - courseAStudents: List<int> ներկայացնում է Դասընթաց A-ում գրանցված ուսանողների ID-ները:\n    - courseBStudents: List<int> ներկայացնում է Դասընթաց B-ում գրանցված ուսանողների ID-ները:\n    \n    Օրինակ օգտագործում:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* কতজন শিক্ষার্থী কোর্স A এবং কোর্স B উভয়েই ভর্তি হয়েছে তা নির্ধারণ করে।\n    প্রতিটি কোর্সের জন্য শিক্ষার্থীদের আইডির দুটি তালিকা দেওয়া হলে, এই ফাংশনটি গণনা করে কতগুলি আইডি উভয় তালিকায় উপস্থিত রয়েছে।\n    - courseAStudents: List<int> যা কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি উপস্থাপন করে।\n    - courseBStudents: List<int> যা কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি উপস্থাপন করে।\n    \n    উদাহরণ ব্যবহার:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя броя на студентите, записани както в Курс А, така и в Курс Б.\n    Дадени са два списъка с идентификационни номера на студенти за всеки курс, тази функция брои колко идентификационни номера се появяват и в двата списъка.\n    - courseAStudents: List<int> представляващ идентификационни номера на студенти, записани в Курс А.\n    - courseBStudents: List<int> представляващ идентификационни номера на студенти, записани в Курс Б.\n    \n    Пример за използване:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定同时注册了课程A和课程B的学生人数。\n    给定每门课程的学生ID列表，此函数计算有多少ID同时出现在两个列表中。\n    - courseAStudents: List<int> 表示注册课程A的学生ID。\n    - courseBStudents: List<int> 表示注册课程B的学生ID。\n    \n    示例用法:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine le nombre d'étudiants qui se sont inscrits à la fois au Cours A et au Cours B.\n    Étant donné deux listes d'identifiants d'étudiants pour chaque cours, cette fonction compte combien d'identifiants apparaissent dans les deux listes.\n    - courseAStudents: List<int> représentant les identifiants d'étudiants inscrits au Cours A.\n    - courseBStudents: List<int> représentant les identifiants d'étudiants inscrits au Cours B.\n    \n    Exemple d'utilisation :\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt die Anzahl der Studenten, die sich sowohl für Kurs A als auch Kurs B eingeschrieben haben.\n    Gegeben zwei Listen von Studenten-IDs für jeden Kurs, zählt diese Funktion, wie viele IDs in beiden Listen erscheinen.\n    - courseAStudents: List<int> repräsentiert Studenten-IDs, die in Kurs A eingeschrieben sind.\n    - courseBStudents: List<int> repräsentiert Studenten-IDs, die in Kurs B eingeschrieben sind.\n    \n    Beispielverwendung:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantance yawan ɗaliban da suka yi rijista a duka Course A da Course B.\n    An ba da jerin sunayen ɗalibai na kowanne kwas, wannan aikin yana ƙididdige yawan IDs da suka bayyana a duka jerin.\n    - courseAStudents: List<int> wakiltar IDs ɗalibai da suka yi rijista a Course A.\n    - courseBStudents: List<int> wakiltar IDs ɗalibai da suka yi rijista a Course B.\n    \n    Misalin amfani:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह निर्धारित करता है कि कितने छात्रों ने कोर्स A और कोर्स B दोनों में नामांकन किया है।\n    प्रत्येक कोर्स के लिए छात्रों के आईडी की दो सूचियों को दिया गया है, यह फ़ंक्शन गिनता है कि कितनी आईडी दोनों सूचियों में दिखाई देती हैं।\n    - courseAStudents: List<int> जो कोर्स A में नामांकित छात्रों की आईडी को दर्शाता है।\n    - courseBStudents: List<int> जो कोर्स B में नामांकित छात्रों की आईडी को दर्शाता है।\n    \n    उदाहरण उपयोग:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza azon diákok számát, akik beiratkoztak mind az A, mind a B kurzusra.\n    Két lista adott, amelyek a diákazonosítókat tartalmazzák az egyes kurzusokhoz, ez a függvény megszámolja, hány azonosító szerepel mindkét listában.\n    - courseAStudents: List<int> az A kurzusra beiratkozott diákok azonosítóit reprezentálja.\n    - courseBStudents: List<int> a B kurzusra beiratkozott diákok azonosítóit reprezentálja.\n    \n    Példa használat:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)"
    },
    "prompt_bertscore": {
      "sq": "0.9825632320008524",
      "hy": "0.9799780575916832",
      "bn": "0.9777212192023649",
      "bg": "0.9925571209922417",
      "zh": "0.9667468906501873",
      "fr": "0.9880557592972291",
      "de": "0.9892930279406954",
      "ha": "0.9783913981079766",
      "hi": "0.9856326672789845",
      "hu": "0.9678878235588517"
    },
    "canonical_solution": "{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}",
    "instruction": {
      "en": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nՏրամադրել կարճ բնական լեզվով նկարագրություն (docstring) C# կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9255449907121205",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 2, 3, 4, 5 }, new List<int> { 1, 3, 4, 5, 6 }) == 4);\n        Debug.Assert(CountCommonStudents(new List<int> { 7, 8, 9 }, new List<int> { 10, 11, 12 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 3, 5, 7, 9 }, new List<int> { 2, 4, 6, 8, 10 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 2, 4, 6, 8 }, new List<int> { 1, 3, 5, 7, 8 }) == 1);\n\n\n    }\n}",
    "entry_point": "CountCommonStudents",
    "signature": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
    "docstring": {
      "en": "Determines the number of students who have enrolled in both Course A and Course B.\n    Given two lists of student IDs for each course, this function counts how many IDs appear in both lists.\n    - courseAStudents: List<int> representing student IDs enrolled in Course A.\n    - courseBStudents: List<int> representing student IDs enrolled in Course B.\n    \n    Example usage:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "sq": "Përcakton numrin e studentëve që janë regjistruar në të dy Kursin A dhe Kursin B. \n    Duke pasur dy lista të ID-ve të studentëve për secilin kurs, kjo funksion numëron sa ID shfaqen në të dy listat.\n    - courseAStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin A.\n    - courseBStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin B.\n    \n    Shembull përdorimi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "hy": "Սահմանում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ Դասընթաց A-ում, և՛ Դասընթաց B-ում:\n    Տրված երկու ցուցակ ուսանողների ID-ներով յուրաքանչյուր դասընթացի համար, այս ֆունկցիան հաշվում է, թե քանի ID է հայտնվում երկու ցուցակներում:\n    - courseAStudents: List<int> ներկայացնում է ուսանողների ID-ները, ովքեր գրանցվել են Դասընթաց A-ում:\n    - courseBStudents: List<int> ներկայացնում է ուսանողների ID-ները, ովքեր գրանցվել են Դասընթաց B-ում:\n    \n    Օրինակ օգտագործում:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "bn": "কতজন ছাত্র উভয় কোর্স A এবং কোর্স B-তে ভর্তি হয়েছে তা নির্ধারণ করে।\n    দুটি কোর্সের জন্য ছাত্রদের আইডির তালিকা দেওয়া হলে, এই ফাংশনটি গণনা করে কতগুলি আইডি উভয় তালিকায় উপস্থিত রয়েছে।  \n    - courseAStudents: List<int> যা কোর্স A-তে ভর্তি হওয়া ছাত্রদের আইডি উপস্থাপন করে।  \n    - courseBStudents: List<int> যা কোর্স B-তে ভর্তি হওয়া ছাত্রদের আইডি উপস্থাপন করে।  \n    \n    উদাহরণ ব্যবহার:  \n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})  \n    4  \n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})  \n    0  ",
      "bg": "Определя броя на студентите, които са записани както в Курс А, така и в Курс Б.\n    Като се дадат два списъка с идентификатори на студенти за всеки курс, тази функция брои колко идентификатора се появяват и в двата списъка.\n    - courseAStudents: List<int> представляващ идентификатори на студенти, записани в Курс А.\n    - courseBStudents: List<int> представляващ идентификатори на студенти, записани в Курс Б.\n    \n    Пример за използване:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "zh": "确定同时注册了课程A和课程B的学生人数。\n    给定每门课程的学生ID列表，此函数计算有多少ID同时出现在两个列表中。\n    - courseAStudents: List<int> 表示注册课程A的学生ID。\n    - courseBStudents: List<int> 表示注册课程B的学生ID。\n    \n    示例用法：\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "fr": "Détermine le nombre d'étudiants inscrits à la fois au Cours A et au Cours B.\n    Étant donné deux listes d'IDs d'étudiants pour chaque cours, cette fonction compte combien d'IDs apparaissent dans les deux listes.\n    - courseAStudents : List<int> représentant les IDs d'étudiants inscrits au Cours A.\n    - courseBStudents : List<int> représentant les IDs d'étudiants inscrits au Cours B.\n    \n    Exemple d'utilisation :\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "de": "Bestimmt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n    Gegeben zwei Listen von Studenten-IDs für jeden Kurs, zählt diese Funktion, wie viele IDs in beiden Listen erscheinen.\n    - courseAStudents: List<int>, die die Studenten-IDs darstellt, die in Kurs A eingeschrieben sind.\n    - courseBStudents: List<int>, die die Studenten-IDs darstellt, die in Kurs B eingeschrieben sind.\n    \n    Beispielverwendung:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "ha": "Yana ƙayyade yawan ɗaliban da suka yi rajista a duka Course A da Course B.  \n    An ba da jerin sunayen IDs ɗalibai guda biyu don kowane hanya, wannan aikin yana ƙididdige yawan IDs da suka bayyana a duka jerin.\n    - courseAStudents: List<int> wakiltar IDs ɗalibai da suka yi rajista a Course A.\n    - courseBStudents: List<int> wakiltar IDs ɗalibai da suka yi rajista a Course B.\n    \n    Misalin amfani:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "hi": "दोनों कोर्स A और कोर्स B में नामांकित छात्रों की संख्या निर्धारित करता है। \n    प्रत्येक कोर्स के लिए छात्र आईडी की दो सूचियों को दिया गया है, यह फ़ंक्शन गिनता है कि कितनी आईडी दोनों सूचियों में प्रकट होती हैं।\n    - courseAStudents: List<int> जो कोर्स A में नामांकित छात्र आईडी का प्रतिनिधित्व करता है।\n    - courseBStudents: List<int> जो कोर्स B में नामांकित छात्र आईडी का प्रतिनिधित्व करता है।\n    \n    उदाहरण उपयोग:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "hu": "Meghatározza azon diákok számát, akik beiratkoztak mind a A, mind a B kurzusra.\n    Két lista megadása esetén, amelyek a kurzusokhoz tartozó diákazonosítókat tartalmazzák, ez a függvény megszámolja, hogy hány azonosító szerepel mindkét listában.\n    - courseAStudents: List<int> reprezentálja az A kurzusra beiratkozott diákok azonosítóit.\n    - courseBStudents: List<int> reprezentálja a B kurzusra beiratkozott diákok azonosítóit.\n    \n    Példa használat:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9800205644932247",
      "hy": "0.96486645683293",
      "bn": "0.971778396832182",
      "bg": "0.9888113492666858",
      "zh": "0.9630624957123711",
      "fr": "0.9753459971059497",
      "de": "0.9865785451534727",
      "ha": "0.9792407416172818",
      "hi": "0.9900869535736918",
      "hu": "0.9689097768692762"
    }
  },
  {
    "task_id": "C#/48",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calculates the number of whole apples remaining after eating apples for a given amount of time.\n   Each apple takes a specific amount of time to eat, and the function returns how many whole apples are left uneaten.\n   - totalApples: the total number of apples available\n   - timePerApple: the time it takes to eat one apple (timePerApple>=0)\n   - timeElapsed: the total time elapsed\n\n   Examples:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Llogarit numrin e mollëve të plota që mbeten pasi të keni ngrënë mollë për një periudhë të caktuar kohe.\n   Çdo mollë kërkon një kohë specifike për t'u ngrënë, dhe funksioni kthen sa mollë të plota mbeten të pangrëna.\n   - totalApples: numri total i mollëve të disponueshme\n   - timePerApple: koha që duhet për të ngrënë një mollë (timePerApple>=0)\n   - timeElapsed: koha totale e kaluar\n\n   Shembuj:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Հաշվում է ամբողջ խնձորների քանակը, որոնք մնում են ուտելուց հետո որոշակի ժամանակահատվածում:\n   Յուրաքանչյուր խնձոր ուտելու համար պահանջվում է որոշակի ժամանակ, և ֆունկցիան վերադարձնում է, թե քանի ամբողջ խնձոր է մնացել չուտված:\n   - totalApples: առկա խնձորների ընդհանուր քանակը\n   - timePerApple: ժամանակը, որը պահանջվում է մեկ խնձոր ուտելու համար (timePerApple>=0)\n   - timeElapsed: անցած ընդհանուր ժամանակը\n\n   Օրինակներ:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি নির্দিষ্ট সময়ের জন্য আপেল খাওয়ার পরে অবশিষ্ট সম্পূর্ণ আপেলের সংখ্যা গণনা করে।\n   প্রতিটি আপেল খেতে একটি নির্দিষ্ট সময় লাগে, এবং ফাংশনটি কতগুলি সম্পূর্ণ আপেল অবশিষ্ট রয়েছে তা ফেরত দেয়।\n   - totalApples: উপলব্ধ আপেলের মোট সংখ্যা\n   - timePerApple: একটি আপেল খেতে যে সময় লাগে (timePerApple>=0)\n   - timeElapsed: মোট কেটে যাওয়া সময়\n\n   উদাহরণ:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Изчислява броя на целите ябълки, останали след ядене на ябълки за дадено количество време.\n   Всяка ябълка отнема определено време за ядене и функцията връща колко цели ябълки остават неядени.\n   - totalApples: общият брой на наличните ябълки\n   - timePerApple: времето, необходимо за изяждане на една ябълка (timePerApple>=0)\n   - timeElapsed: общото изминало време\n\n   Примери:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 计算在给定时间内吃苹果后剩余的完整苹果数量。\n   每个苹果需要特定的时间来吃，函数返回剩余未吃的完整苹果数量。\n   - totalApples: 可用苹果的总数\n   - timePerApple: 吃一个苹果所需的时间 (timePerApple>=0)\n   - timeElapsed: 已经过的总时间\n\n   例子:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calcule le nombre de pommes entières restantes après avoir mangé des pommes pendant un certain temps.\n   Chaque pomme prend un certain temps à manger, et la fonction retourne combien de pommes entières restent non mangées.\n   - totalApples: le nombre total de pommes disponibles\n   - timePerApple: le temps qu'il faut pour manger une pomme (timePerApple>=0)\n   - timeElapsed: le temps total écoulé\n\n   Exemples:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Berechnet die Anzahl der ganzen Äpfel, die nach dem Essen von Äpfeln für eine bestimmte Zeit übrig bleiben.\n   Jeder Apfel benötigt eine bestimmte Zeit zum Essen, und die Funktion gibt zurück, wie viele ganze Äpfel uneaten übrig sind.\n   - totalApples: die Gesamtanzahl der verfügbaren Äpfel\n   - timePerApple: die Zeit, die benötigt wird, um einen Apfel zu essen (timePerApple>=0)\n   - timeElapsed: die insgesamt vergangene Zeit\n\n   Beispiele:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana ƙididdige yawan cikakkun tuffa da suka rage bayan cin tuffa na wani lokaci.\n   Kowace tuffa tana ɗaukar wani lokaci don ci, kuma aikin yana dawo da yawan cikakkun tuffa da suka rage ba a ci ba.\n   - totalApples: jimlar yawan tuffa da ake da su\n   - timePerApple: lokacin da ake ɗauka don cin tuffa ɗaya (timePerApple>=0)\n   - timeElapsed: jimlar lokacin da ya shige\n\n   Misalai:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दिए गए समय के लिए सेब खाने के बाद बचे हुए साबुत सेबों की संख्या की गणना करता है।\n   प्रत्येक सेब खाने में एक विशेष समय लगता है, और यह फ़ंक्शन बताता है कि कितने साबुत सेब बिना खाए बचे हैं।\n   - totalApples: उपलब्ध सेबों की कुल संख्या\n   - timePerApple: एक सेब खाने में लगने वाला समय (timePerApple>=0)\n   - timeElapsed: कुल बीता हुआ समय\n\n   उदाहरण:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Kiszámítja, hogy hány egész alma marad meg, miután egy adott ideig almát ettünk.\n   Minden alma elfogyasztása egy meghatározott időt vesz igénybe, és a függvény visszaadja, hogy hány egész alma marad érintetlenül.\n   - totalApples: a rendelkezésre álló almák teljes száma\n   - timePerApple: az idő, ami egy alma elfogyasztásához szükséges (timePerApple>=0)\n   - timeElapsed: az eltelt idő összesen\n\n   Példák:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)"
    },
    "prompt_bertscore": {
      "sq": "0.9786094942663529",
      "hy": "0.9642296478313321",
      "bn": "0.9709783136573735",
      "bg": "0.98192940245497",
      "zh": "0.9567385016409824",
      "fr": "0.9774578353171126",
      "de": "0.9836765552865528",
      "ha": "0.9743675438489718",
      "hi": "0.9626431869780065",
      "hu": "0.9647516484726918"
    },
    "canonical_solution": "{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}",
    "instruction": {
      "en": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nՏվեք C# կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nПредоставете кратко описание на C# кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\n请用中文为以下C#代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nKa bayar da bayanin takaitaccen harshe na dabi'a (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9340356449798378",
      "bn": "0.872474726876838",
      "bg": "0.8379186022274364",
      "zh": "0.8909247084496446",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9428713202194127",
      "hi": "0.9150793545657733",
      "hu": "0.9548157595525647"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(RemainingApples(50, 10, 200) == 30);\n        Debug.Assert(RemainingApples(10, 2, 5) == 7);\n        Debug.Assert(RemainingApples(5, 15, 10) == 4);\n        Debug.Assert(RemainingApples(20, 0, 100) == 0); // Case to test division by zero handling\n        Debug.Assert(RemainingApples(3, 10, 130) == 0); // Case where all apples are eaten\n\n    }\n}",
    "entry_point": "RemainingApples",
    "signature": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
    "docstring": {
      "en": "Calculates the number of whole apples remaining after eating apples for a given amount of time.\n   Each apple takes a specific amount of time to eat, and the function returns how many whole apples are left uneaten.\n   - totalApples: the total number of apples available\n   - timePerApple: the time it takes to eat one apple (timePerApple>=0)\n   - timeElapsed: the total time elapsed\n\n   Examples:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "sq": "Llogarit numrin e mollëve të plota që mbeten pasi të keni ngrënë mollë për një periudhë të caktuar kohe. \n   Çdo mollë kërkon një sasi specifike kohe për t'u ngrënë, dhe funksioni kthen sa mollë të plota mbeten të pangrëna.\n   - totalApples: numri total i mollëve në dispozicion\n   - timePerApple: koha që duhet për të ngrënë një mollë (timePerApple>=0)\n   - timeElapsed: koha totale e kaluar\n\n   Shembuj:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "hy": "Հաշվում է ամբողջ խնձորների քանակը, որոնք մնում են ուտելուց հետո որոշակի ժամանակահատվածի ընթացքում:\n   Յուրաքանչյուր խնձոր ուտելու համար պահանջվում է որոշակի ժամանակ, և ֆունկցիան վերադարձնում է, թե քանի ամբողջ խնձոր է մնում չուտված:\n   - totalApples: հասանելի խնձորների ընդհանուր քանակը\n   - timePerApple: ժամանակը, որը պահանջվում է մեկ խնձոր ուտելու համար (timePerApple>=0)\n   - timeElapsed: անցած ընդհանուր ժամանակը\n\n   Օրինակներ:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "bn": "সম্পূর্ণ আপেল খাওয়ার পর একটি নির্দিষ্ট সময়ের মধ্যে কতগুলি আপেল অবশিষ্ট থাকবে তা গণনা করে।  \nপ্রতিটি আপেল খাওয়ার জন্য নির্দিষ্ট পরিমাণ সময় লাগে, এবং ফাংশনটি কতগুলি সম্পূর্ণ আপেল অবশিষ্ট থাকবে তা ফেরত দেয়।  \n- totalApples: মোট আপেলের সংখ্যা উপলব্ধ  \n- timePerApple: একটি আপেল খেতে যত সময় লাগে (timePerApple>=0)  \n- timeElapsed: মোট সময় অতিবাহিত  \n\nউদাহরণ:  \n>>> RemainingApples(50, 10, 200)  \n30",
      "bg": "Изчислява броя на целите ябълки, останали след ядене на ябълки за дадено количество време.\n   Всяка ябълка отнема определено време за ядене и функцията връща колко цели ябълки остават неядени.\n   - totalApples: общият брой налични ябълки\n   - timePerApple: времето, необходимо за изяждане на една ябълка (timePerApple>=0)\n   - timeElapsed: общото изминало време\n\n   Примери:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "zh": "计算在给定时间内吃掉苹果后剩余的完整苹果数量。\n每个苹果需要特定的时间来吃，函数返回剩下多少完整的苹果未被吃掉。\n- totalApples: 可用的苹果总数\n- timePerApple: 吃一个苹果所需的时间 (timePerApple>=0)\n- timeElapsed: 总共经过的时间\n\n示例：\n>>> RemainingApples(50, 10, 200)\n30",
      "fr": "Calcule le nombre de pommes entières restantes après avoir mangé des pommes pendant un certain temps donné.\n   Chaque pomme prend un certain temps à manger, et la fonction retourne combien de pommes entières restent non mangées.\n   - totalApples: le nombre total de pommes disponibles\n   - timePerApple: le temps qu'il faut pour manger une pomme (timePerApple>=0)\n   - timeElapsed: le temps total écoulé\n\n   Exemples:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "de": "Berechnet die Anzahl der ganzen Äpfel, die nach dem Essen von Äpfeln für eine bestimmte Zeit übrig bleiben.\n   Jeder Apfel benötigt eine bestimmte Zeit zum Essen, und die Funktion gibt an, wie viele ganze Äpfel übrig bleiben.\n   - totalApples: die Gesamtanzahl der verfügbaren Äpfel\n   - timePerApple: die Zeit, die benötigt wird, um einen Apfel zu essen (timePerApple>=0)\n   - timeElapsed: die insgesamt vergangene Zeit\n\n   Beispiele:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "ha": "Yana ƙididdige yawan cikakkun tuffa da suka rage bayan cin tuffa na wani adadin lokaci.\nKowane tuffa yana ɗaukar wani adadin lokaci don ci, kuma aikin yana dawowa da yawan cikakkun tuffa da suka rage ba a ci ba.\n- totalApples: jimlar adadin tuffa da ake da su\n- timePerApple: lokacin da ake ɗauka don cin tuffa guda ɗaya (timePerApple>=0)\n- timeElapsed: jimlar lokacin da ya shige\n\nMisalai:\n>>> RemainingApples(50, 10, 200)\n30",
      "hi": "पूरे सेबों की संख्या की गणना करता है जो एक निश्चित समय तक सेब खाने के बाद बचते हैं। \n   प्रत्येक सेब को खाने में एक विशेष समय लगता है, और यह फ़ंक्शन यह बताता है कि कितने पूरे सेब बिना खाए बचते हैं।\n   - totalApples: उपलब्ध सेबों की कुल संख्या\n   - timePerApple: एक सेब खाने में लगने वाला समय (timePerApple>=0)\n   - timeElapsed: कुल बीता हुआ समय\n\n   उदाहरण:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "hu": "Kiszámítja, hogy hány egész alma marad meg, miután egy adott ideig almát ettünk.\n   Minden alma elfogyasztása egy meghatározott időt vesz igénybe, és a függvény visszaadja, hogy hány egész alma marad meg.\n   - totalApples: a rendelkezésre álló almák teljes száma\n   - timePerApple: az idő, amely alatt egy almát el lehet fogyasztani (timePerApple>=0)\n   - timeElapsed: az eltelt összidő\n\n   Példák:\n   >>> RemainingApples(50, 10, 200)\n   30"
    },
    "docstring_bertscore": {
      "sq": "0.973332878194161",
      "hy": "0.9433436632655137",
      "bn": "0.9333998291301451",
      "bg": "0.983728596446384",
      "zh": "0.9517634064872016",
      "fr": "0.983005581859417",
      "de": "0.9497284382334991",
      "ha": "0.9617372338101063",
      "hi": "0.9409710233640519",
      "hu": "0.9520986945703884"
    }
  },
  {
    "task_id": "C#/49",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Finds the missing (broken) and duplicated ID from a series of ID sequences.\n    IDs are supposed to be continuous but due to an error, one ID is missing and one is duplicated.\n    The function returns a tuple with the first element being the missing ID and the second the duplicated ID.\n\n    Args:\n    ids: A list of lists, each sublist contains a series of ticket IDs.\n\n    Returns:\n    A tuple of two integers: the first is the missing ID (m) and the second is the duplicated ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Gjen ID-në që mungon (të prishur) dhe ID-në e kopjuar nga një seri sekuencash ID.\n    ID-të supozohet të jenë të pandërprera, por për shkak të një gabimi, një ID mungon dhe një është kopjuar.\n    Funksioni kthen një dyshe me elementin e parë që është ID-ja që mungon dhe e dyta ID-ja e kopjuar.\n\n    Argumentet:\n    ids: Një listë listash, çdo nënlistë përmban një seri ID biletash.\n\n    Kthen:\n    Një dyshe e dy numrave të plotë: e para është ID-ja që mungon (m) dhe e dyta është ID-ja e kopjuar (n).\n\n    Shembuj:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Գտնում է բացակայող (կոտրված) և կրկնօրինակված ID-ն ID հաջորդականությունների շարքից:\n    ID-ները պետք է լինեն շարունակական, բայց սխալի պատճառով մեկ ID բացակայում է, իսկ մեկը կրկնօրինակված է:\n    Ֆունկցիան վերադարձնում է տուպլ, որի առաջին տարրը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնօրինակված ID-ն:\n\n    Արգումենտներ:\n    ids: Ցուցակների ցուցակ, յուրաքանչյուր ենթացուցակ պարունակում է տոմսերի ID-ների շարք:\n\n    Վերադարձնում է:\n    Երկու ամբողջ թվերի տուպլ. առաջինը բացակայող ID-ն է (m), իսկ երկրորդը՝ կրկնօրինակված ID-ն (n):\n\n    Օրինակներ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    একটি ধারাবাহিক আইডি সিকোয়েন্স থেকে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\n    আইডিগুলি ধারাবাহিক হওয়া উচিত কিন্তু একটি ত্রুটির কারণে, একটি আইডি অনুপস্থিত এবং একটি সদৃশ হয়েছে।\n    ফাংশনটি একটি টুপল ফেরত দেয় যেখানে প্রথম উপাদানটি অনুপস্থিত আইডি এবং দ্বিতীয়টি সদৃশ আইডি।\n\n    আর্গুমেন্টসমূহ:\n    ids: একটি তালিকার তালিকা, প্রতিটি উপতালিকায় টিকিট আইডির একটি ধারাবাহিক রয়েছে।\n\n    রিটার্নস:\n    দুটি পূর্ণসংখ্যার একটি টুপল: প্রথমটি অনুপস্থিত আইডি (m) এবং দ্বিতীয়টি সদৃশ আইডি (n)।\n\n    উদাহরণ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Намира липсващото (счупено) и дублираното ID от серия от последователности на ID.\n    ID-тата трябва да са непрекъснати, но поради грешка едно ID липсва и едно е дублирано.\n    Функцията връща кортеж, като първият елемент е липсващото ID, а вторият е дублираното ID.\n\n    Аргументи:\n    ids: Списък от списъци, всеки подсписък съдържа серия от ID на билети.\n\n    Връща:\n    Кортеж от две цели числа: първото е липсващото ID (m), а второто е дублираното ID (n).\n\n    Примери:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    查找一系列ID序列中缺失（损坏）和重复的ID。\n    ID应该是连续的，但由于错误，一个ID缺失，一个ID重复。\n    该函数返回一个元组，第一个元素是缺失的ID，第二个是重复的ID。\n\n    参数:\n    ids: 一个列表的列表，每个子列表包含一系列票据ID。\n\n    返回:\n    一个包含两个整数的元组：第一个是缺失的ID (m)，第二个是重复的ID (n)。\n\n    示例:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Trouve l'ID manquant (cassé) et l'ID dupliqué à partir d'une série de séquences d'ID.\n    Les IDs sont supposés être continus mais en raison d'une erreur, un ID est manquant et un est dupliqué.\n    La fonction renvoie un tuple dont le premier élément est l'ID manquant et le second l'ID dupliqué.\n\n    Args:\n    ids: Une liste de listes, chaque sous-liste contient une série d'IDs de tickets.\n\n    Returns:\n    Un tuple de deux entiers : le premier est l'ID manquant (m) et le second est l'ID dupliqué (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Findet die fehlende (defekte) und die doppelte ID aus einer Reihe von ID-Sequenzen.\n    IDs sollen kontinuierlich sein, aber aufgrund eines Fehlers fehlt eine ID und eine ist doppelt vorhanden.\n    Die Funktion gibt ein Tupel zurück, wobei das erste Element die fehlende ID und das zweite die doppelte ID ist.\n\n    Argumente:\n    ids: Eine Liste von Listen, jede Unterliste enthält eine Reihe von Ticket-IDs.\n\n    Rückgabewerte:\n    Ein Tupel aus zwei ganzen Zahlen: die erste ist die fehlende ID (m) und die zweite ist die doppelte ID (n).\n\n    Beispiele:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Nemi ID da ya ɓace (ya karye) da kuma wanda aka maimaita daga jerin ID.\n    IDs ya kamata su kasance masu ci gaba amma saboda kuskure, an rasa ɗaya kuma an maimaita ɗaya.\n    Aikin yana dawo da tuple tare da abu na farko shine ID da ya ɓace kuma na biyu shine ID da aka maimaita.\n\n    Args:\n    ids: Jerin jerin, kowace ƙaramin jerin tana ɗauke da jerin ID na tikiti.\n\n    Returns:\n    Tuple na lambobi guda biyu: na farko shine ID da ya ɓace (m) kuma na biyu shine ID da aka maimaita (n).\n\n    Misalai:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    ID अनुक्रमों की एक श्रृंखला से गायब (टूटा हुआ) और डुप्लिकेट ID खोजता है।\n    IDs को निरंतर होना चाहिए लेकिन एक त्रुटि के कारण, एक ID गायब है और एक डुप्लिकेट है।\n    फ़ंक्शन एक युग्म लौटाता है जिसमें पहला तत्व गायब ID है और दूसरा डुप्लिकेट ID है।\n\n    तर्क:\n    ids: सूचियों की एक सूची, प्रत्येक उपसूची में टिकट IDs की एक श्रृंखला होती है।\n\n    रिटर्न्स:\n    दो पूर्णांकों का एक युग्म: पहला गायब ID (m) है और दूसरा डुप्लिकेट ID (n) है।\n\n    उदाहरण:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Megkeresi a hiányzó (hibás) és a duplikált azonosítót egy azonosítósorozatból.\n    Az azonosítóknak folyamatosnak kellene lenniük, de egy hiba miatt egy azonosító hiányzik, és egy duplikált.\n    A függvény egy olyan tuple-t ad vissza, amelynek első eleme a hiányzó azonosító, a második pedig a duplikált azonosító.\n\n    Argumentumok:\n    ids: Listák listája, minden al-lista tartalmaz egy sorozat jegyazonosítót.\n\n    Visszatérési érték:\n    Egy két egész számot tartalmazó tuple: az első a hiányzó azonosító (m), a második a duplikált azonosító (n).\n\n    Példák:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)"
    },
    "prompt_bertscore": {
      "sq": "0.9736494950215308",
      "hy": "0.981194867305903",
      "bn": "0.9669359867729325",
      "bg": "0.9821051903421859",
      "zh": "0.9677336863831686",
      "fr": "0.9812999427774705",
      "de": "0.9762497653396585",
      "ha": "0.9649937789071734",
      "hi": "0.9723687263246178",
      "hu": "0.9450052064028706"
    },
    "canonical_solution": "    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }",
    "instruction": {
      "en": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nՏվեք C# կոդի կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\n请用不超过500个字符的中文，为以下C#代码提供简明的自然语言描述（文档字符串）。",
      "fr": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nFournir une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9021552701933572",
      "bn": "0.8778230485165833",
      "bg": "0.831676443873034",
      "zh": "0.8542940881007146",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9195461545744857",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "static void Main()\n    {\n\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} }) == (7, 9));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4, 6}, new List<int> {3, 3} }) == (5, 3));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> { 110, 112, 108 }, new List<int> { 107, 109, 108 } }) == (111, 108));\n\n    }\n}",
    "entry_point": "FindErrorIds",
    "signature": "static (int, int) FindErrorIds(List<List<int>> ids)",
    "docstring": {
      "en": "Finds the missing (broken) and duplicated ID from a series of ID sequences.\n    IDs are supposed to be continuous but due to an error, one ID is missing and one is duplicated.\n    The function returns a tuple with the first element being the missing ID and the second the duplicated ID.\n\n    Args:\n    ids: A list of lists, each sublist contains a series of ticket IDs.\n\n    Returns:\n    A tuple of two integers: the first is the missing ID (m) and the second is the duplicated ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "sq": "Gjen ID-të që mungojnë (të prishura) dhe të dyfishuara nga një seri sekuencash ID-sh.\n    ID-të supozohet të jenë të vazhdueshme, por për shkak të një gabimi, një ID mungon dhe një është e dyfishuar.\n    Funksioni kthen një dyshe me elementin e parë që është ID që mungon dhe e dyta ID e dyfishuar.\n\n    Argumentet:\n    ids: Një listë listash, çdo nënlistë përmban një seri ID biletash.\n\n    Kthen:\n    Një dyshe e dy numrave të plotë: e para është ID që mungon (m) dhe e dyta është ID e dyfishuar (n).\n\n    Shembuj:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hy": "Գտնում է բացակայող (կոտրված) և կրկնօրինակված ID-ն ID հաջորդականությունների շարքից:\n    ID-ները պետք է լինեն շարունակական, սակայն սխալի պատճառով մեկ ID բացակայում է և մեկը կրկնօրինակված է:\n    Ֆունկցիան վերադարձնում է կորտեժ, որի առաջին տարրը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնօրինակված ID-ն:\n\n    Արգումենտներ:\n    ids: Ցուցակների ցուցակ, յուրաքանչյուր ենթացուցակ պարունակում է տոմսերի ID-ների շարք:\n\n    Վերադարձնում է.\n    Երկու ամբողջ թվերի կորտեժ. առաջինը բացակայող ID-ն է (m), իսկ երկրորդը՝ կրկնօրինակված ID-ն (n):\n\n    Օրինակներ.\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "bn": "অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি একটি আইডি সিকোয়েন্স থেকে খুঁজে বের করে।\n    আইডিগুলি ধারাবাহিক হওয়া উচিত কিন্তু একটি ত্রুটির কারণে, একটি আইডি অনুপস্থিত এবং একটি সদৃশ হয়েছে।\n    ফাংশনটি একটি টিউপল ফেরত দেয় যার প্রথম উপাদানটি অনুপস্থিত আইডি এবং দ্বিতীয়টি সদৃশ আইডি।\n\n    Args:\n    ids: তালিকার একটি তালিকা, প্রতিটি উপতালিকায় টিকিট আইডির একটি সিরিজ থাকে।\n\n    Returns:\n    দুটি পূর্ণসংখ্যার একটি টিউপল: প্রথমটি অনুপস্থিত আইডি (m) এবং দ্বিতীয়টি সদৃশ আইডি (n)।\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "bg": "Намира липсващото (счупено) и дублираното ID от серия от последователности на ID.\n    ID-тата трябва да бъдат непрекъснати, но поради грешка едно ID липсва и едно е дублирано.\n    Функцията връща кортеж, като първият елемент е липсващото ID, а вторият е дублираното ID.\n\n    Аргументи:\n    ids: Списък от списъци, всеки подсписък съдържа серия от ID на билети.\n\n    Връща:\n    Кортеж от две цели числа: първото е липсващото ID (m), а второто е дублираното ID (n).\n\n    Примери:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "zh": "查找缺失（损坏）和重复的ID从一系列ID序列中。\n    ID应该是连续的，但由于错误，一个ID缺失，一个ID重复。\n    该函数返回一个元组，第一个元素是缺失的ID，第二个是重复的ID。\n\n    参数：\n    ids: 一个列表的列表，每个子列表包含一系列票据ID。\n\n    返回：\n    一个包含两个整数的元组：第一个是缺失的ID (m)，第二个是重复的ID (n)。\n\n    示例：\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "fr": "Trouve l'ID manquant (cassé) et dupliqué à partir d'une série de séquences d'ID.\n    Les IDs sont supposés être continus mais en raison d'une erreur, un ID est manquant et un est dupliqué.\n    La fonction renvoie un tuple dont le premier élément est l'ID manquant et le second l'ID dupliqué.\n\n    Args:\n    ids: Une liste de listes, chaque sous-liste contient une série d'IDs de tickets.\n\n    Returns:\n    Un tuple de deux entiers : le premier est l'ID manquant (m) et le second est l'ID dupliqué (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "de": "Findet die fehlende (defekte) und doppelte ID aus einer Reihe von ID-Sequenzen.\n    IDs sollen kontinuierlich sein, aber aufgrund eines Fehlers fehlt eine ID und eine ist doppelt vorhanden.\n    Die Funktion gibt ein Tupel zurück, wobei das erste Element die fehlende ID und das zweite die doppelte ID ist.\n\n    Argumente:\n    ids: Eine Liste von Listen, jede Unterliste enthält eine Reihe von Ticket-IDs.\n\n    Rückgaben:\n    Ein Tupel von zwei ganzen Zahlen: die erste ist die fehlende ID (m) und die zweite ist die doppelte ID (n).\n\n    Beispiele:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "ha": "Finds the missing (broken) and duplicated ID daga jerin jerin ID.\n    IDs ya kamata su kasance masu ci gaba amma saboda kuskure, ana rasa ID ɗaya kuma ana maimaita ɗaya.\n    Aikin yana dawowa da tuple tare da abu na farko shine ID ɗin da ake nema kuma na biyu shine ID ɗin da aka maimaita.\n\n    Args:\n    ids: Jerin jerin, kowace ƙaramin jerin tana ɗauke da jerin ID ɗin tikiti.\n\n    Returns:\n    Tuple na lambobi guda biyu: na farko shine ID ɗin da ake nema (m) kuma na biyu shine ID ɗin da aka maimaita (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hi": "खोजता है लापता (टूटा हुआ) और डुप्लिकेट आईडी को आईडी अनुक्रमों की एक श्रृंखला से।\n    आईडी लगातार होनी चाहिए लेकिन एक त्रुटि के कारण, एक आईडी गायब है और एक डुप्लिकेट है।\n    फ़ंक्शन एक ट्यूपल लौटाता है जिसमें पहला तत्व लापता आईडी है और दूसरा डुप्लिकेट आईडी है।\n\n    Args:\n    ids: सूचियों की एक सूची, प्रत्येक उप-सूची में टिकट आईडी की एक श्रृंखला होती है।\n\n    Returns:\n    दो पूर्णांकों का एक ट्यूपल: पहला लापता आईडी (m) है और दूसरा डुप्लिकेट आईडी (n) है।\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hu": "Megkeresi a hiányzó (hibás) és duplikált azonosítót egy azonosítósorozatból.\n    Az azonosítóknak folyamatosnak kellene lenniük, de egy hiba miatt egy azonosító hiányzik és egy duplikált.\n    A függvény egy tuple-t ad vissza, amelynek első eleme a hiányzó azonosító, a második pedig a duplikált azonosító.\n\n    Argumentumok:\n    ids: Listák listája, minden allista tartalmaz egy sorozat jegyazonosítót.\n\n    Visszatérési érték:\n    Egy tuple két egész számmal: az első a hiányzó azonosító (m), a második a duplikált azonosító (n).\n\n    Példák:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)"
    },
    "docstring_bertscore": {
      "sq": "0.9875953340739902",
      "hy": "0.9759404978363871",
      "bn": "0.9610050822256118",
      "bg": "0.9789008850353311",
      "zh": "0.9580538320241954",
      "fr": "0.9911102972967836",
      "de": "0.9703178676404325",
      "ha": "0.9750812228080302",
      "hi": "0.9641523806131096",
      "hu": "0.9469277498609072"
    }
  },
  {
    "task_id": "C#/50",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Counts the number of digit, lowercase, and uppercase characters in a given string of length 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Numëron numrin e karaktereve shifrore, të vogla dhe të mëdha në një varg të dhënë me gjatësi 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում։\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* একটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যা, ছোট হাতের এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Брои броя на цифрите, малките и главните букви в даден низ с дължина 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* 计算给定长度为8的字符串中数字、小写字母和大写字母的数量。\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Compte le nombre de caractères chiffres, minuscules et majuscules dans une chaîne donnée de longueur 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Yana ƙididdige adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu mai tsawon haruffa 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* एक दिए गए 8 लंबाई के स्ट्रिंग में अंक, लोअरकेस, और अपरकेस अक्षरों की संख्या गिनता है।\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Megszámolja a számjegy, kisbetűs és nagybetűs karakterek számát egy adott, 8 hosszúságú sztringben.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9836118017823355",
      "bn": "0.9819550257741235",
      "bg": "0.986529483449357",
      "zh": "0.9734137207592423",
      "fr": "0.9943243354923091",
      "de": "0.9836118017823355",
      "ha": "0.9726329047313942",
      "hi": "0.991500010104374",
      "hu": "1"
    },
    "canonical_solution": "    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }",
    "instruction": {
      "en": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nProvide a concise natural language description (docstring) of the C# code in English using at most 500 characters.",
      "sq": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit C# në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nՏվեք C# կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nনিচের C# কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nПредоставете кратко описание на C# кода на български език, използвайки не повече от 500 знака.",
      "zh": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\n请用不超过500个字符的中文，为以下C#代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nFournissez une description concise en langage naturel (docstring) du code C# en français en utilisant au maximum 500 caractères.",
      "de": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des C#-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar C# a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nC# कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 अक्षर हों।",
      "hu": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a C# kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568767483861826",
      "hy": "0.9364434424587427",
      "bn": "0.872474726876838",
      "bg": "0.831676443873034",
      "zh": "0.8763023343193803",
      "fr": "0.9703846074484602",
      "de": "0.9270041294912027",
      "ha": "0.9372774914287082",
      "hi": "0.9150793545657733",
      "hu": "0.9436143964748642"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountCharacters(\"yLAX2022\") == (4, 1, 3));\n        Debug.Assert(CountCharacters(\"MBKKOKOK\") == (0, 0, 8));\n        Debug.Assert(CountCharacters(\"1n2s0e1s\") == (4, 4, 0));\n        Debug.Assert(CountCharacters(\"1234ABCD\") == (4, 0, 4));\n\n\n    }\n}",
    "entry_point": "CountCharacters",
    "signature": "static (int, int, int) CountCharacters(string s)",
    "docstring": {
      "en": "Counts the number of digit, lowercase, and uppercase characters in a given string of length 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "sq": "Numëron numrin e karaktereve shifrore, të vogla dhe të mëdha në një varg të dhënë me gjatësi 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "hy": "Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում:\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "bn": "সংখ্যা করে একটি প্রদত্ত ৮ অক্ষরের স্ট্রিংয়ে সংখ্যা, ছোট হাতের এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "bg": "Брои броя на цифрите, малките и главните букви в даден низ с дължина 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "zh": "计算给定长度为8的字符串中数字、小写和大写字符的数量。\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "fr": "Compte le nombre de caractères numériques, minuscules et majuscules dans une chaîne donnée de longueur 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "de": "Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "ha": "Yana ƙididdige adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani baƙaƙe na tsawon haruffa 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "hi": "आठ वर्णों की लंबाई वाले दिए गए स्ट्रिंग में अंक, छोटे अक्षर, और बड़े अक्षर वर्णों की संख्या गिनता है।\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "hu": "Számolja meg a számjegy, kisbetűs és nagybetűs karakterek számát egy adott, 8 hosszúságú sztringben.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9893891650451163",
      "hy": "0.9737511937766206",
      "bn": "0.9491037456851444",
      "bg": "0.9778576782741358",
      "zh": "0.9715980404462023",
      "fr": "0.9754838465903879",
      "de": "0.9704076485726603",
      "ha": "0.9418892916155762",
      "hi": "0.9678639879131276",
      "hu": "0.9900220014390935"
    }
  }
]