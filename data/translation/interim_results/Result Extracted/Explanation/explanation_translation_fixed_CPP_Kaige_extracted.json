[
  {
    "task_id": "CPP/1",
    "prompt": {
      "en": "#include <bits/stdc++.h>\nusing namespace std;\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "sq": "#include <bits/stdc++.h>\nusing namespace std;\n// Kthen \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "hy": "#include <bits/stdc++.h>\nusing namespace std;\n// Վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "bn": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" ফেরত দিন\nstring hello_mmcodeeval()",
      "bg": "#include <bits/stdc++.h>\nusing namespace std;\n// Връща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "zh": "#include <bits/stdc++.h>\nusing namespace std;\n// 返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "fr": "#include <bits/stdc++.h>\nusing namespace std;\n// Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "de": "#include <bits/stdc++.h>\nusing namespace std;\n// Gibt \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" zurück\nstring hello_mmcodeeval()",
      "ha": "#include <bits/stdc++.h>\nusing namespace std;\n// Mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "hi": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं\nstring hello_mmcodeeval()",
      "hu": "#include <bits/stdc++.h>\nusing namespace std;\n// Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget\nstring hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "sq": "0.9343600083920678",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.9980399153999477",
      "zh": "0.936928895109992",
      "fr": "0.9343600083920678",
      "de": "0.9980399153999477",
      "ha": "0.936928895109992",
      "hi": "0.936928895109992",
      "hu": "0.9231534809244604"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8867794910278275",
      "bg": "0.9788407625177538",
      "zh": "0.904821312162758",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main()\n{\n    assert(hello_mmcodeeval() ==  \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n    return 0;\n}",
    "entry_point": "hello_mmcodeeval",
    "signature": "string hello_mmcodeeval()",
    "docstring": {
      "en": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sq": "Kthe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hy": "Վերադարձնում է \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bn": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "bg": "Върни \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "zh": "返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "fr": "Retourne \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "de": "Zurückgeben \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "ha": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "hi": "\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएँ",
      "hu": "Adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" szöveget."
    },
    "docstring_bertscore": {
      "sq": "0.8983048202569959",
      "hy": "0.9560623638239396",
      "bn": "0.9229602135637135",
      "bg": "0.9420164150594386",
      "zh": "0.956679111157053",
      "fr": "0.9560623638239396",
      "de": "0.956679111157053",
      "ha": "0.8791373857478912",
      "hi": "0.9449897132331498",
      "hu": "0.886144271069278"
    }
  },
  {
    "task_id": "CPP/2",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the area of a triangle given its three sides.\n *\n * @param a (double): Length of side 'a'.\n * @param b (double): Length of side 'b'.\n * @param c (double): Length of side 'c'.\n *\n * @return (double): If the provided sides form a triangle, return the\n *                   calculated area rounded to 2 decimal places.\n *                   Otherwise, return -1 as an indicator.\n *\n * Example usage:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n *\n * @param a (double): Gjatësia e anës 'a'.\n * @param b (double): Gjatësia e anës 'b'.\n * @param c (double): Gjatësia e anës 'c'.\n *\n * @return (double): Nëse anët e dhëna formojnë një trekëndësh, kthen\n *                   sipërfaqen e llogaritur të rrumbullakosur në 2 vende dhjetore.\n *                   Përndryshe, kthen -1 si një tregues.\n *\n * Shembull përdorimi:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվարկել եռանկյան մակերեսը՝ տրված նրա երեք կողմերը:\n *\n * @param a (double): Կողմ 'a'-ի երկարությունը:\n * @param b (double): Կողմ 'b'-ի երկարությունը:\n * @param c (double): Կողմ 'c'-ի երկարությունը:\n *\n * @return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել\n *                   հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական:\n *                   Հակառակ դեպքում վերադարձնել -1 որպես ցուցիչ:\n *\n * Օգտագործման օրինակ:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտ լինի 6-ի\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n *\n * @param a (double): বাহু 'a' এর দৈর্ঘ্য।\n * @param b (double): বাহু 'b' এর দৈর্ঘ্য।\n * @param c (double): বাহু 'c' এর দৈর্ঘ্য।\n *\n * @return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে\n *                   গণনা করা ক্ষেত্রফল 2 দশমিক স্থান পর্যন্ত\n *                   রাউন্ড করে ফেরত দিন। অন্যথায়, সূচক হিসাবে -1 ফেরত দিন।\n *\n * উদাহরণ ব্যবহার:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল প্রায় 6 হওয়া উচিত\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчисляване на лицето на триъгълник, дадени неговите три страни.\n *\n * @param a (double): Дължина на страна 'a'.\n * @param b (double): Дължина на страна 'b'.\n * @param c (double): Дължина на страна 'c'.\n *\n * @return (double): Ако предоставените страни образуват триъгълник, връща\n *                   изчисленото лице, закръглено до 2 знака след десетичната запетая.\n *                   В противен случай връща -1 като индикатор.\n *\n * Пример за използване:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Лицето трябва да бъде приблизително 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算给定三边的三角形面积。\n *\n * @param a (double): 边 'a' 的长度。\n * @param b (double): 边 'b' 的长度。\n * @param c (double): 边 'c' 的长度。\n *\n * @return (double): 如果提供的边能构成三角形，返回计算出的面积，保留两位小数。\n *                   否则，返回 -1 作为指示。\n *\n * 示例用法:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // 面积应约为 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculer l'aire d'un triangle donné ses trois côtés.\n *\n * @param a (double): Longueur du côté 'a'.\n * @param b (double): Longueur du côté 'b'.\n * @param c (double): Longueur du côté 'c'.\n *\n * @return (double): Si les côtés fournis forment un triangle, retourne l'aire\n *                   calculée arrondie à 2 décimales.\n *                   Sinon, retourne -1 comme indicateur.\n *\n * Exemple d'utilisation :\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechne die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n *\n * @param a (double): Länge der Seite 'a'.\n * @param b (double): Länge der Seite 'b'.\n * @param c (double): Länge der Seite 'c'.\n *\n * @return (double): Wenn die angegebenen Seiten ein Dreieck bilden, gib die\n *                   berechnete Fläche gerundet auf 2 Dezimalstellen zurück.\n *                   Andernfalls gib -1 als Indikator zurück.\n *\n * Beispielverwendung:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Fläche sollte ungefähr 6 sein\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafi yanki na alwatika idan aka ba da gefensa uku.\n *\n * @param a (double): Tsawon gefen 'a'.\n * @param b (double): Tsawon gefen 'b'.\n * @param c (double): Tsawon gefen 'c'.\n *\n * @return (double): Idan gefen da aka bayar sun kafa alwatika, dawo da\n *                   yankin da aka lissafa wanda aka zagaye zuwa wurare 2 na goma.\n *                   In ba haka ba, dawo da -1 a matsayin alama.\n *\n * Misalin amfani:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Yankin yakamata ya zama kusan 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * दिए गए तीन भुजाओं के आधार पर त्रिभुज का क्षेत्रफल गणना करें।\n *\n * @param a (double): भुजा 'a' की लंबाई।\n * @param b (double): भुजा 'b' की लंबाई।\n * @param c (double): भुजा 'c' की लंबाई।\n *\n * @return (double): यदि दी गई भुजाएं एक त्रिभुज बनाती हैं, तो\n *                   गणना किया गया क्षेत्रफल 2 दशमलव स्थानों तक\n *                   गोलाई करके लौटाएं। अन्यथा, संकेतक के रूप में -1 लौटाएं।\n *\n * उदाहरण उपयोग:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számítsa ki egy háromszög területét a három oldalának ismeretében.\n *\n * @param a (double): Az 'a' oldal hossza.\n * @param b (double): A 'b' oldal hossza.\n * @param c (double): A 'c' oldal hossza.\n *\n * @return (double): Ha a megadott oldalak háromszöget alkotnak, térjen vissza a\n *                   kiszámított területtel, amely 2 tizedesjegyre van kerekítve.\n *                   Ellenkező esetben térjen vissza -1 értékkel, mint jelző.\n *\n * Példa használat:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie\n */\ndouble calculate_triangle_area(double a, double b, double c)"
    },
    "prompt_bertscore": {
      "sq": "0.9909045162220315",
      "hy": "0.9861371884468131",
      "bn": "0.9960379197894971",
      "bg": "0.9913830168099445",
      "zh": "0.9878742111289632",
      "fr": "0.9920432641965045",
      "de": "0.9900609329937763",
      "ha": "0.9960379197894971",
      "hi": "0.9869603127458216",
      "hu": "0.9768299646826614"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}",
    "instruction": {
      "en": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nՏվեք CPP կոդի համառոտ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nПредоставете кратко описание на CPP кода на български език, като използвате не повече от 500 знака.",
      "zh": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9095451148893792",
      "bn": "0.8736615434035214",
      "bg": "0.8365011292951701",
      "zh": "0.980880895161363",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9536396690664571",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    // Test cases for the calculate_triangle_area function\n    assert(fabs(calculate_triangle_area(3, 5, 4) - 6.00) < 1e-6); // Expected area is 6\n    assert(calculate_triangle_area(1, 1, 4) == -1);  // Not a triangle, should return -1\n    assert(fabs(calculate_triangle_area(7, 24, 25) - 84.00) < 1e-6); // Expected area is 84\n    assert(fabs(calculate_triangle_area(10.5, 6.2, 7.3) - 22.15) < 1e-2); // Expected area is approx 22.15\n\n    // All tests passed\n    \n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "double calculate_triangle_area(double a, double b, double c)",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n\n@param a (double): Length of side 'a'.\n@param b (double): Length of side 'b'.\n@param c (double): Length of side 'c'.\n\n@return (double): If the provided sides form a triangle, return the calculated area rounded to 2 decimal places. Otherwise, return -1 as an indicator.\n\nExample usage:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\n@param a (double): Gjatësia e anës 'a'.\n@param b (double): Gjatësia e anës 'b'.\n@param c (double): Gjatësia e anës 'c'.\n\n@return (double): Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur të rrumbullakosur në 2 shifra dhjetore. Përndryshe, kthen -1 si një tregues.\n\nShembull përdorimi:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Sipërfaqja duhet të jetë afërsisht 6",
      "hy": "Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\n@param a (double): Կողմ 'a'-ի երկարությունը։\n@param b (double): Կողմ 'b'-ի երկարությունը։\n@param c (double): Կողմ 'c'-ի երկարությունը։\n\n@return (double): Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ կլորացված մինչև 2 տասնորդական։ Հակառակ դեպքում, վերադարձնել -1 որպես ցուցիչ։\n\nՕրինակ օգտագործում:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Մակերեսը պետք է մոտավորապես լինի 6",
      "bn": "একটি ত্রিভুজের তিনটি বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n\n@param a (double): বাহু 'a' এর দৈর্ঘ্য।\n@param b (double): বাহু 'b' এর দৈর্ঘ্য।\n@param c (double): বাহু 'c' এর দৈর্ঘ্য।\n\n@return (double): যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থান পর্যন্ত গোলাকার গণনা করা ক্ষেত্রফল প্রদান করুন। অন্যথায়, সূচক হিসাবে -1 প্রদান করুন।\n\nব্যবহারের উদাহরণ:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // ক্ষেত্রফল আনুমানিক 6 হওয়া উচিত",
      "bg": "Изчислява площта на триъгълник, дадени неговите три страни.\n\n@param a (double): Дължина на страна 'a'.\n@param b (double): Дължина на страна 'b'.\n@param c (double): Дължина на страна 'c'.\n\n@return (double): Ако предоставените страни образуват триъгълник, връща изчислената площ, закръглена до 2 знака след десетичната запетая. В противен случай връща -1 като индикатор.\n\nПример за използване:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Площта трябва да бъде приблизително 6",
      "zh": "计算给定三边的三角形面积。\n\n@param a (double): 边 'a' 的长度。\n@param b (double): 边 'b' 的长度。\n@param c (double): 边 'c' 的长度。\n\n@return (double): 如果提供的边长可以构成一个三角形，返回计算出的面积并四舍五入到小数点后两位。否则，返回 -1 作为指示。\n\n示例用法:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // 面积应大约为 6",
      "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n\n@param a (double): Longueur du côté 'a'.\n@param b (double): Longueur du côté 'b'.\n@param c (double): Longueur du côté 'c'.\n\n@return (double): Si les côtés fournis forment un triangle, retourner l'aire calculée arrondie à 2 décimales. Sinon, retourner -1 comme indicateur.\n\nExemple d'utilisation :\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // L'aire devrait être approximativement 6",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n\n@param a (double): Länge der Seite 'a'.\n@param b (double): Länge der Seite 'b'.\n@param c (double): Länge der Seite 'c'.\n\n@return (double): Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche auf 2 Dezimalstellen gerundet zurück. Andernfalls geben Sie -1 als Indikator zurück.\n\nBeispielverwendung:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Die Fläche sollte ungefähr 6 betragen",
      "ha": "Lissafin yankin wani kusurwar kusurwa idan aka ba shi bangarorinsa guda uku.\n\n@param a (double): Tsawon gefen 'a'.\n@param b (double): Tsawon gefen 'b'.\n@param c (double): Tsawon gefen 'c'.\n\n@return (double): Idan gefen da aka bayar sun ƙirƙiri alwatika, dawo da yankin da aka lissafa wanda aka zagaye zuwa wurare 2 na adadi. In ba haka ba, dawo da -1 a matsayin alamar.\n\nExample usage:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Ya kamata yankin ya kasance kusan 6",
      "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\n@param a (double): भुजा 'a' की लंबाई।\n@param b (double): भुजा 'b' की लंबाई।\n@param c (double): भुजा 'c' की लंबाई।\n\n@return (double): यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया क्षेत्रफल 2 दशमलव स्थानों तक गोल कर लौटाएं। अन्यथा, संकेतक के रूप में -1 लौटाएं।\n\nउदाहरण उपयोग:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // क्षेत्रफल लगभग 6 होना चाहिए",
      "hu": "Számítsa ki egy háromszög területét a három oldalának ismeretében.\n\n@param a (double): Az 'a' oldal hossza.\n@param b (double): A 'b' oldal hossza.\n@param c (double): A 'c' oldal hossza.\n\n@return (double): Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegyre kerekítve. Ellenkező esetben adja vissza a -1 értéket jelzésként.\n\nPélda használat:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // A területnek körülbelül 6-nak kell lennie"
    },
    "docstring_bertscore": {
      "sq": "0.9920657094295614",
      "hy": "0.9941429859544243",
      "bn": "0.9920823943815683",
      "bg": "0.9887376573953218",
      "zh": "0.9878597111111477",
      "fr": "0.9911073178410681",
      "de": "0.9875164778127193",
      "ha": "0.9941429859544243",
      "hi": "0.9874999914910935",
      "hu": "0.968140282773147"
    }
  },
  {
    "task_id": "CPP/3",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculate the value of the function for a given input.\n * Parameters:\n * - x (int): Input value for the function.\n * Returns:\n * - std::string: If x is not in the defined domain, returns \"Not define\".\n *   Otherwise, returns the calculated function value rounded to 5 decimal places.\n *\n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * Example:\n *   calculate_function_value(40) returns \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Llogarit vlerën e funksionit për një hyrje të dhënë.\n * Parametrat:\n * - x (int): Vlera e hyrjes për funksionin.\n * Kthen:\n * - std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n *   Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n *\n * Përkufizimet e funksionit:\n * - Për 0 <= x < 10: y = cos(x + 3.0)\n * - Për 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Për 20 <= x < 30: y = (cos(x + 4.0))^4\n * Shembull:\n *   calculate_function_value(40) kthen \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրման համար:\n * Պարամետրեր:\n * - x (int): Ֆունկցիայի մուտքագրման արժեքը:\n * Վերադարձնում է:\n * - std::string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\":\n *   Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական թվանշան:\n *\n * Ֆունկցիայի սահմանումներ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * Օրինակ:\n *   calculate_function_value(40) վերադարձնում է \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n * প্যারামিটার:\n * - x (int): ফাংশনের জন্য ইনপুট মান।\n * রিটার্নস:\n * - std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, \"Not define\" রিটার্ন করে।\n *   অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n *\n * ফাংশন সংজ্ঞা:\n * - 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n * - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n * উদাহরণ:\n *   calculate_function_value(40) \"Not define\" রিটার্ন করে\n */\nstd::string calculate_function_value(int x)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Изчислява стойността на функцията за даден вход.\n * Параметри:\n * - x (int): Входна стойност за функцията.\n * Връща:\n * - std::string: Ако x не е в определения домейн, връща \"Not define\".\n *   В противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n *\n * Дефиниции на функцията:\n * - За 0 <= x < 10: y = cos(x + 3.0)\n * - За 10 <= x < 20: y = (cos(x + 7.5))^2\n * - За 20 <= x < 30: y = (cos(x + 4.0))^4\n * Пример:\n *   calculate_function_value(40) връща \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * 计算给定输入的函数值。\n * 参数：\n * - x (int): 函数的输入值。\n * 返回：\n * - std::string: 如果 x 不在定义域内，返回 \"Not define\"。\n *   否则，返回计算后的函数值，四舍五入到小数点后5位。\n *\n * 函数定义：\n * - 对于 0 <= x < 10: y = cos(x + 3.0)\n * - 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n * 示例：\n *   calculate_function_value(40) 返回 \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculer la valeur de la fonction pour une entrée donnée.\n * Paramètres :\n * - x (int) : Valeur d'entrée pour la fonction.\n * Renvoie :\n * - std::string : Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n *   Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n *\n * Définitions de la fonction :\n * - Pour 0 <= x < 10 : y = cos(x + 3.0)\n * - Pour 10 <= x < 20 : y = (cos(x + 7.5))^2\n * - Pour 20 <= x < 30 : y = (cos(x + 4.0))^4\n * Exemple :\n *   calculate_function_value(40) returns \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Berechnet den Wert der Funktion für eine gegebene Eingabe.\n * Parameter:\n * - x (int): Eingabewert für die Funktion.\n * Rückgabe:\n * - std::string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n *   Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n *\n * Funktionsdefinitionen:\n * - Für 0 <= x < 10: y = cos(x + 3.0)\n * - Für 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Für 20 <= x < 30: y = (cos(x + 4.0))^4\n * Beispiel:\n *   calculate_function_value(40) gibt \"Not define\" zurück\n */\nstd::string calculate_function_value(int x)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n * Sigogi:\n * - x (int): Ƙimar shigarwa don aikin.\n * Komawa:\n * - std::string: Idan x ba ya cikin yankin da aka ayyana, yana mayar da \"Not define\".\n *   In ba haka ba, yana mayar da ƙimar aikin da aka lissafa an zagaye zuwa wurare 5 na ɗigo.\n *\n * Ma'anar Aiki:\n * - Don 0 <= x < 10: y = cos(x + 3.0)\n * - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n * Misali:\n *   calculate_function_value(40) yana mayar da \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n * पैरामीटर्स:\n * - x (int): फ़ंक्शन के लिए इनपुट मान।\n * रिटर्न:\n * - std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n *   अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n *\n * फ़ंक्शन परिभाषाएँ:\n * - 0 <= x < 10 के लिए: y = cos(x + 3.0)\n * - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n * उदाहरण:\n *   calculate_function_value(40) \"Not define\" लौटाता है\n */\nstd::string calculate_function_value(int x)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Számítsa ki a függvény értékét egy adott bemenetre.\n * Paraméterek:\n * - x (int): A függvény bemeneti értéke.\n * Visszatérési érték:\n * - std::string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\n *   Egyébként a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve.\n *\n * Függvény definíciók:\n * - Ha 0 <= x < 10: y = cos(x + 3.0)\n * - Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n * Példa:\n *   calculate_function_value(40) visszaadja \"Not define\"\n */\nstd::string calculate_function_value(int x)"
    },
    "prompt_bertscore": {
      "sq": "0.9881949991943345",
      "hy": "0.9632196123437697",
      "bn": "0.9887744040158133",
      "bg": "0.9887968492488702",
      "zh": "0.9849879130621452",
      "fr": "0.9827940405036149",
      "de": "0.9802134345932096",
      "ha": "0.9842942957715713",
      "hi": "0.9887144176407408",
      "hu": "0.977516629909899"
    },
    "canonical_solution": "{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}",
    "instruction": {
      "en": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nसीपीपी कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों में प्रदान करें।",
      "hu": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.9483094227913859",
      "bn": "0.882825753293328",
      "bg": "0.8365011292951701",
      "zh": "0.9860444905467461",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9536396690664571",
      "hi": "0.9546874443264162",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(calculate_function_value(40) == \"Not define\");\n\n    // Additional test cases based on provided function definitions\n    assert(calculate_function_value(5) == \"-0.14550\");\n    assert(calculate_function_value(15) == \"0.76266\");\n    assert(calculate_function_value(25) == \"0.31314\");\n    assert(calculate_function_value(-1) == \"Not define\");\n\n    // std::cout << \"All tests passed successfully.\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "calculate_function_value",
    "signature": "std::string calculate_function_value(int x)",
    "docstring": {
      "en": "Calculate the value of the function for a given input. Parameters: - x (int): Input value for the function. Returns: - std::string: If x is not in the defined domain, returns \"Not define\". Otherwise, returns the calculated function value rounded to 5 decimal places. Function Definitions: - For 0 <= x < 10: y = cos(x + 3.0) - For 10 <= x < 20: y = (cos(x + 7.5))^2 - For 20 <= x < 30: y = (cos(x + 4.0))^4 Example: calculate_function_value(40) returns \"Not define\"",
      "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n\nParametrat: - x (int): Vlera e hyrjes për funksionin.\n\nKthen:\n- std::string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\". Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërcaktimet e Funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembull:\ncalculate_function_value(40) kthen \"Not define\"",
      "hy": "Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։ Պարամետրեր՝ - x (int): Մուտքագրված արժեք ֆունկցիայի համար։ Վերադարձնում է՝ - std::string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։ Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական։ Ֆունկցիայի սահմանումներ՝ - 0 <= x < 10: y = cos(x + 3.0) - 10 <= x < 20: y = (cos(x + 7.5))^2 - 20 <= x < 30: y = (cos(x + 4.0))^4 Օրինակ՝ calculate_function_value(40) վերադարձնում է \"Not define\"",
      "bn": "প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nParameters: - x (int): ফাংশনের জন্য ইনপুট মান।\n\nReturns:\n- std::string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে। অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\ncalculate_function_value(40) returns \"Not define\"",
      "bg": "Изчислява стойността на функцията за даден вход. \n\nПараметри: - x (int): Входна стойност за функцията.\n\nВръща:\n- std::string: Ако x не е в определения домейн, връща \"Not define\". В противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nОпределения на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПример:\ncalculate_function_value(40) връща \"Not define\"",
      "zh": "计算给定输入的函数值。\n\n参数: - x (int): 函数的输入值。\n\n返回:\n- std::string: 如果 x 不在定义域内，返回 \"Not define\"。否则，返回计算后的函数值，保留小数点后 5 位。\n\n函数定义:\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例:\ncalculate_function_value(40) 返回 \"Not define\"",
      "fr": "Calculer la valeur de la fonction pour une entrée donnée. \n\nParamètres: - x (int): Valeur d'entrée pour la fonction. \n\nRenvoie: \n- std::string: Si x n'est pas dans le domaine défini, renvoie \"Not define\". Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales. \n\nDéfinitions de fonction: \n- Pour 0 <= x < 10: y = cos(x + 3.0) \n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2 \n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4 \n\nExemple: calculate_function_value(40) renvoie \"Not define\"",
      "de": "Berechne den Wert der Funktion für eine gegebene Eingabe.\n\nParameter: - x (int): Eingabewert für die Funktion.\n\nRückgabewerte:\n- std::string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben. Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispiel:\ncalculate_function_value(40) gibt \"Not define\" zurück.",
      "ha": "Lissafa ƙimar aikin don wani shigarwa da aka bayar.\n\nSigogi: - x (int): Ƙimar shigarwa don aikin.\n\nReturns:\n    - std::string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa \"Not define\". In ba haka ba, yana dawowa da ƙimar aikin da aka lissafa tare da zagaye zuwa wurare 5 na ƙidaya.\n\nFunction Definitions:\n    - Don 0 <= x < 10: y = cos(x + 3.0)\n    - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n    - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\n    calculate_function_value(40) returns \"Not define\"",
      "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स: - x (int): फ़ंक्शन के लिए इनपुट मान।\n\nReturns:\n- std::string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है। अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample:\ncalculate_function_value(40) returns \"Not define\"",
      "hu": "Számítsa ki a függvény értékét egy adott bemenethez. Paraméterek: - x (int): A függvény bemeneti értéke. Visszatér: - std::string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza. Ellenkező esetben a kiszámított függvényértéket adja vissza, 5 tizedesjegyre kerekítve. Függvénydefiníciók: - Ha 0 <= x < 10: y = cos(x + 3.0) - Ha 10 <= x < 20: y = (cos(x + 7.5))^2 - Ha 20 <= x < 30: y = (cos(x + 4.0))^4 Példa: calculate_function_value(40) visszatér \"Not define\""
    },
    "docstring_bertscore": {
      "sq": "0.9863854764231067",
      "hy": "0.9512344537825056",
      "bn": "1",
      "bg": "0.9846454742852411",
      "zh": "0.9732464739784109",
      "fr": "0.991067591764861",
      "de": "0.9673054392816574",
      "ha": "0.962691652790979",
      "hi": "0.9894604733519078",
      "hu": "0.9652631217038566"
    }
  },
  {
    "task_id": "CPP/4",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "sq": "#include <cassert>\n#include <cstdio>\n/*\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Shembull thirrjeje: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hy": "#include <cassert>\n#include <cstdio>\n/*\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը։\nb (int): Երկրորդ ամբողջ թիվը։\nc (int): Երրորդ ամբողջ թիվը։\n\nՎերադարձնում է:\nTuple[int, int]: Tuple-ը հասկացություն չէ C-ում; փոխարենը մենք կվերադարձնենք հղումով։\n\n>>> Օրինակ զանգ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "bn": "#include <cassert>\n#include <cstdio>\n/*\nতিনটি ভিন্ন পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\nপ্যারামিটারসমূহ:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nফেরত দেয়:\nTuple[int, int]: C তে একটি টিউপল ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "bg": "#include <cassert>\n#include <cstdio>\n/*\nНамерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортеж не е концепция в C; вместо това ще върнем чрез препратка.\n\n>>> Примерно извикване: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "zh": "#include <cassert>\n#include <cstdio>\n/*\n寻找三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C语言中没有元组的概念，我们将通过引用返回。\n\n>>> 示例调用: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "fr": "#include <cassert>\n#include <cstdio>\n/*\nTrouver le maximum et le minimum de trois entiers distincts.\nParamètres :\na (int) : Le premier entier.\nb (int) : Le deuxième entier.\nc (int) : Le troisième entier.\n\nRenvoie :\nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous allons retourner par référence.\n\n>>> Exemple d'appel : \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "de": "#include <cassert>\n#include <cstdio>\n/*\nFinde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewert:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "ha": "#include <cassert>\n#include <cstdio>\n/*\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanci.\nSigogi:\na (int): Lamba ta farko.\nb (int): Lamba ta biyu.\nc (int): Lamba ta uku.\n\nDawowa:\nTuple[int, int]: Ba a amfani da ra'ayin tuple a cikin C; maimakon haka, za mu dawo ta hanyar nuni.\n\n>>> Misalin kira: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hi": "#include <cassert>\n#include <cstdio>\n/*\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nपैरामीटर्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी मान:\nTuple[int, int]: C में एक ट्यूपल की अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा लौटाएंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "hu": "#include <cassert>\n#include <cstdio>\n/*\nKeresse meg három különböző egész szám maximumát és minimumát.\nParaméterek:\na (int): Az első egész szám.\nb (int): A második egész szám.\nc (int): A harmadik egész szám.\n\nVisszatérési érték:\nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; helyette referencia szerint fogunk visszatérni.\n\n>>> Példa hívás: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)"
    },
    "prompt_bertscore": {
      "sq": "0.9974640859253275",
      "hy": "0.9927400595731748",
      "bn": "0.9668066783948788",
      "bg": "0.9927400595731748",
      "zh": "0.9785012407086888",
      "fr": "0.9795865571106636",
      "de": "0.9859830512711301",
      "ha": "0.9556589455200578",
      "hi": "0.9786865628541944",
      "hu": "0.9931178545579032"
    },
    "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}",
    "instruction": {
      "en": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 अक्षरों में हो।",
      "hu": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9267393551932832",
      "bn": "0.9110972126867858",
      "bg": "0.9788407625177538",
      "zh": "0.904821312162758",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9198274151940312",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}",
    "entry_point": "find_max_min",
    "signature": "void find_max_min(int a, int b, int c, int *max, int *min)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n",
      "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të dallueshëm.\nParametrat:\na (int): Numri i parë i plotë.\nb (int): Numri i dytë i plotë.\nc (int): Numri i tretë i plotë.\n\nKthen:\nTuple[int, int]: Një tuple nuk është një koncept në C; në vend të kësaj, ne do të kthejmë me referencë.\n\n>>> Thirrje shembull:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hy": "Երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը գտնել:\nՊարամետրեր:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nTuple[int, int]: Կապ չի հանդիսանում C-ում հասկացություն; փոխարենը մենք կվերադարձնենք հղումով:\n\n>>> Օրինակ կանչ:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bn": "তিনটি ভিন্ন পূর্ণসংখ্যার সর্বাধিক এবং সর্বনিম্ন মান খুঁজে বের করুন।\nParameters:\na (int): প্রথম পূর্ণসংখ্যা।\nb (int): দ্বিতীয় পূর্ণসংখ্যা।\nc (int): তৃতীয় পূর্ণসংখ্যা।\n\nReturns:\nTuple[int, int]: একটি টিউপল C তে একটি ধারণা নয়; পরিবর্তে, আমরা রেফারেন্স দ্বারা ফেরত দেব।\n\n>>> উদাহরণ কল:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "bg": "Намерете максимума и минимума на три различни цели числа.\nПараметри:\na (int): Първото цяло число.\nb (int): Второто цяло число.\nc (int): Третото цяло число.\n\nВръща:\nTuple[int, int]: Кортежът не е концепция в C; вместо това ще върнем чрез референция.\n\n>>> Примерно извикване:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "zh": "找出三个不同整数的最大值和最小值。\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\nTuple[int, int]: 在C语言中没有元组的概念，因此我们将通过引用返回。\n\n>>> 示例调用：\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "fr": "Trouver le maximum et le minimum de trois entiers distincts.  \nParamètres :  \na (int) : Le premier entier.  \nb (int) : Le deuxième entier.  \nc (int) : Le troisième entier.  \n\nRenvoie :  \nTuple[int, int] : Un tuple n'est pas un concept en C ; à la place, nous renverrons par référence.  \n\n>>> Exemple d'appel :  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "de": "Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\nParameter:\na (int): Die erste ganze Zahl.\nb (int): Die zweite ganze Zahl.\nc (int): Die dritte ganze Zahl.\n\nRückgabewerte:\nTuple[int, int]: Ein Tupel ist kein Konzept in C; stattdessen werden wir durch Referenz zurückgeben.\n\n>>> Beispielaufruf:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "ha": "Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.  \nSigogi:  \na (int): Lamba ta farko.  \nb (int): Lamba ta biyu.  \nc (int): Lamba ta uku.  \n\nDawowa:  \nTuple[int, int]: Tuple ba wani abu bane a cikin C; maimakon haka, za mu dawo ta hanyar tunani.  \n\n>>> Misalin kira:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "hi": "तीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\nमापदंड:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nTuple[int, int]: एक ट्यूपल C में एक अवधारणा नहीं है; इसके बजाय, हम संदर्भ द्वारा वापस करेंगे।\n\n>>> उदाहरण कॉल:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "hu": "Keresse meg három különböző egész szám maximumát és minimumát.  \nParaméterek:  \na (int): Az első egész szám.  \nb (int): A második egész szám.  \nc (int): A harmadik egész szám.  \n\nVisszatér:  \nTuple[int, int]: A tuple nem egy fogalom a C nyelvben; ehelyett referencia alapján térünk vissza.  \n\n>>> Példa hívás:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  "
    },
    "docstring_bertscore": {
      "sq": "0.9965237697015085",
      "hy": "0.9898650834380759",
      "bn": "0.9836650347244529",
      "bg": "0.9823270604778018",
      "zh": "0.971328697649519",
      "fr": "1",
      "de": "0.9890338152934448",
      "ha": "0.9655167727004382",
      "hi": "0.9682741596499645",
      "hu": "0.97587773063598"
    }
  },
  {
    "task_id": "CPP/5",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * Parameters:\n * - xa (double): x-coordinate of point A.\n * - ya (double): y-coordinate of point A.\n * - xb (double): x-coordinate of point B.\n * - yb (double): y-coordinate of point B.\n * \n * Returns:\n * double: The distance between points A and B.\n * \n * Examples:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n * \n * Parametrat:\n * - xa (double): koordinata x e pikës A.\n * - ya (double): koordinata y e pikës A.\n * - xb (double): koordinata x e pikës B.\n * - yb (double): koordinata y e pikës B.\n * \n * Kthen:\n * double: Distanca midis pikave A dhe B.\n * \n * Shembuj:\n * calculate_distance(0, 0, 3, 4) kthen 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n * \n * Պարամետրեր:\n * - xa (double): A կետի x-կոորդինատը։\n * - ya (double): A կետի y-կոորդինատը։\n * - xb (double): B կետի x-կոորդինատը։\n * - yb (double): B կետի y-կոորդինատը։\n * \n * Վերադարձնում է:\n * double: Հեռավորությունը A և B կետերի միջև։\n * \n * Օրինակներ:\n * calculate_distance(0, 0, 3, 4) վերադարձնում է 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n * \n * প্যারামিটারসমূহ:\n * - xa (double): বিন্দু A এর x-সমন্বয়।\n * - ya (double): বিন্দু A এর y-সমন্বয়।\n * - xb (double): বিন্দু B এর x-সমন্বয়।\n * - yb (double): বিন্দু B এর y-সমন্বয়।\n * \n * রিটার্নস:\n * double: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n * \n * উদাহরণ:\n * calculate_distance(0, 0, 3, 4) 5 রিটার্ন করে\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n * \n * Параметри:\n * - xa (double): x-координата на точка A.\n * - ya (double): y-координата на точка A.\n * - xb (double): x-координата на точка B.\n * - yb (double): y-координата на точка B.\n * \n * Връща:\n * double: Разстоянието между точките A и B.\n * \n * Примери:\n * calculate_distance(0, 0, 3, 4) връща 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * 计算两个点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n * \n * 参数:\n * - xa (double): 点 A 的 x 坐标。\n * - ya (double): 点 A 的 y 坐标。\n * - xb (double): 点 B 的 x 坐标。\n * - yb (double): 点 B 的 y 坐标。\n * \n * 返回:\n * double: 点 A 和 B 之间的距离。\n * \n * 示例:\n * calculate_distance(0, 0, 3, 4) 返回 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n * \n * Paramètres :\n * - xa (double) : coordonnée x du point A.\n * - ya (double) : coordonnée y du point A.\n * - xb (double) : coordonnée x du point B.\n * - yb (double) : coordonnée y du point B.\n * \n * Renvoie :\n * double : La distance entre les points A et B.\n * \n * Exemples :\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Berechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n * \n * Parameter:\n * - xa (double): x-Koordinate des Punktes A.\n * - ya (double): y-Koordinate des Punktes A.\n * - xb (double): x-Koordinate des Punktes B.\n * - yb (double): y-Koordinate des Punktes B.\n * \n * Rückgabewert:\n * double: Die Entfernung zwischen den Punkten A und B.\n * \n * Beispiele:\n * calculate_distance(0, 0, 3, 4) gibt 5 zurück\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Lissafin nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n * \n * Sigogi:\n * - xa (double): x-daftarin maki A.\n * - ya (double): y-daftarin maki A.\n * - xb (double): x-daftarin maki B.\n * - yb (double): y-daftarin maki B.\n * \n * Komawa:\n * double: Nisan tsakanin maki A da B.\n * \n * Misalai:\n * calculate_distance(0, 0, 3, 4) yana dawowa 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n * \n * पैरामीटर्स:\n * - xa (double): बिंदु A का x-निर्देशांक।\n * - ya (double): बिंदु A का y-निर्देशांक।\n * - xb (double): बिंदु B का x-निर्देशांक।\n * - yb (double): बिंदु B का y-निर्देशांक।\n * \n * रिटर्न करता है:\n * double: बिंदुओं A और B के बीच की दूरी।\n * \n * उदाहरण:\n * calculate_distance(0, 0, 3, 4) 5 लौटाता है\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n * \n * Paraméterek:\n * - xa (double): A pont x-koordinátája.\n * - ya (double): A pont y-koordinátája.\n * - xb (double): B pont x-koordinátája.\n * - yb (double): B pont y-koordinátája.\n * \n * Visszatérési érték:\n * double: Az A és B pontok közötti távolság.\n * \n * Példák:\n * calculate_distance(0, 0, 3, 4) visszaadja 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)"
    },
    "prompt_bertscore": {
      "sq": "0.9989675192793807",
      "hy": "0.999999801369619",
      "bn": "0.9959058305861089",
      "bg": "0.9989675192793807",
      "zh": "0.998229408783455",
      "fr": "0.999999801369619",
      "de": "0.9957727482308155",
      "ha": "0.999999801369619",
      "hi": "0.9959058305861089",
      "hu": "0.9708944916365768"
    },
    "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}",
    "instruction": {
      "en": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 अक्षरों का हो।",
      "hu": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.929259776098235",
      "hy": "0.8914036062983197",
      "bn": "0.8552647947728321",
      "bg": "0.8329214591013607",
      "zh": "0.9014431122060948",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() \n{\n    assert(fabs(calculate_distance(0, 0, 3, 4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0, 0, 0, 0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    //std::cout << \"All test cases passed!\\n\"; // printf can be replaced with std::cout\n    return 0;\n}",
    "entry_point": "calculate_distance",
    "signature": "double calculate_distance(double xa, double ya, double xb, double yb)",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\n\nExamples:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\nParametrat:\n- xa (double): koordinata x e pikës A.\n- ya (double): koordinata y e pikës A.\n- xb (double): koordinata x e pikës B.\n- yb (double): koordinata y e pikës B.\n\nKthen:\ndouble: Distanca midis pikave A dhe B.\n\nShembuj:\ncalculate_distance(0, 0, 3, 4) kthen 5",
      "hy": "Հաշվարկել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n\nՊարամետրեր՝\n- xa (double): A կետի x-կոորդինատը։\n- ya (double): A կետի y-կոորդինատը։\n- xb (double): B կետի x-կոորդինատը։\n- yb (double): B կետի y-կոորդինատը։\n\nՎերադարձնում է՝\ndouble: Հեռավորությունը A և B կետերի միջև։\n\nՕրինակներ՝\ncalculate_distance(0, 0, 3, 4) վերադարձնում է 5",
      "bn": "দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- xa (double): বিন্দু A এর x-সমন্বয়।\n- ya (double): বিন্দু A এর y-সমন্বয়।\n- xb (double): বিন্দু B এর x-সমন্বয়।\n- yb (double): বিন্দু B এর y-সমন্বয়।\n\nরিটার্নস:\ndouble: বিন্দু A এবং B এর মধ্যে দূরত্ব।\n\nউদাহরণ:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "bg": "Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n\nПараметри:\n- xa (double): x-координата на точка A.\n- ya (double): y-координата на точка A.\n- xb (double): x-координата на точка B.\n- yb (double): y-координата на точка B.\n\nВръща:\ndouble: Разстоянието между точките A и B.\n\nПримери:\ncalculate_distance(0, 0, 3, 4) връща 5",
      "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n参数：\n- xa (double): 点 A 的 x 坐标。\n- ya (double): 点 A 的 y 坐标。\n- xb (double): 点 B 的 x 坐标。\n- yb (double): 点 B 的 y 坐标。\n\n返回：\ndouble: 点 A 和 B 之间的距离。\n\n示例：\ncalculate_distance(0, 0, 3, 4) 返回 5",
      "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\nParamètres :\n- xa (double) : coordonnée x du point A.\n- ya (double) : coordonnée y du point A.\n- xb (double) : coordonnée x du point B.\n- yb (double) : coordonnée y du point B.\n\nRenvoie :\ndouble : La distance entre les points A et B.\n\nExemples :\ncalculate_distance(0, 0, 3, 4) renvoie 5",
      "de": "Berechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\nParameter:\n- xa (double): x-Koordinate des Punktes A.\n- ya (double): y-Koordinate des Punktes A.\n- xb (double): x-Koordinate des Punktes B.\n- yb (double): y-Koordinate des Punktes B.\n\nRückgabewert:\ndouble: Die Entfernung zwischen den Punkten A und B.\n\nBeispiele:\ncalculate_distance(0, 0, 3, 4) gibt 5 zurück",
      "ha": "Lissafi nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\nSigogi:\n- xa (double): x-kwatance na aya A.\n- ya (double): y-kwatance na aya A.\n- xb (double): x-kwatance na aya B.\n- yb (double): y-kwatance na aya B.\n\nDawowa:\ndouble: Nisan tsakanin wurare A da B.\n\nMisalai:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\nपैरामीटर्स:\n- xa (double): बिंदु A का x-निर्देशांक।\n- ya (double): बिंदु A का y-निर्देशांक।\n- xb (double): बिंदु B का x-निर्देशांक।\n- yb (double): बिंदु B का y-निर्देशांक।\n\nवापसी:\ndouble: बिंदु A और B के बीच की दूरी।\n\nउदाहरण:\ncalculate_distance(0, 0, 3, 4) 5 लौटाता है।",
      "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\nParaméterek:\n- xa (double): A pont x-koordinátája.\n- ya (double): A pont y-koordinátája.\n- xb (double): B pont x-koordinátája.\n- yb (double): B pont y-koordinátája.\n\nVisszatérési érték:\ndouble: A távolság A és B pontok között.\n\nPéldák:\ncalculate_distance(0, 0, 3, 4) visszaadja 5"
    },
    "docstring_bertscore": {
      "sq": "0.9646743812544692",
      "hy": "0.996680886332907",
      "bn": "0.9969617496916904",
      "bg": "1",
      "zh": "0.968692276602043",
      "fr": "1",
      "de": "0.9948177333587997",
      "ha": "0.9969617496916904",
      "hi": "0.9952044667106746",
      "hu": "0.9631590300775541"
    }
  },
  {
    "task_id": "CPP/6",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n * \n * Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit faktorialin e N modulo 10007.\n * \n * Parametrat:\n * - N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n * \n * Kthen:\n * int: Rezultati pas llogaritjes së faktorialit të N dhe\n * marrjes së modulo 10007.\n * \n * Shembuj:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվում է N-ի ֆակտորիալը 10007 մոդուլով։\n * \n * Պարամետրեր:\n * - N (int): Ամբողջ թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n * \n * Վերադարձնում է:\n * int: Արդյունքը N-ի ֆակտորիալը հաշվելուց և 10007 մոդուլ վերցնելուց հետո։\n * \n * Օրինակներ:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N এর ফ্যাক্টোরিয়াল 10007 দ্বারা মডুলো হিসাব করে।\n * \n * প্যারামিটার:\n * - N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n * \n * রিটার্নস:\n * int: N এর ফ্যাক্টোরিয়াল হিসাব করার পর এবং\n * 10007 দ্বারা মডুলো নেওয়ার পর ফলাফল।\n * \n * উদাহরণ:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява факториела на N модуло 10007.\n * \n * Параметри:\n * - N (int): Цяло число, представляващо входната стойност (N <= 10000).\n * \n * Връща:\n * int: Резултатът след изчисляване на факториела на N и\n * вземане на модуло 10007.\n * \n * Примери:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算 N 的阶乘模 10007。\n * \n * 参数:\n * - N (int): 表示输入值的整数 (N <= 10000)。\n * \n * 返回:\n * int: 计算 N 的阶乘并取模 10007 后的结果。\n * \n * 示例:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcule le factoriel de N modulo 10007.\n * \n * Paramètres :\n * - N (int) : Un entier représentant la valeur d'entrée (N <= 10000).\n * \n * Renvoie :\n * int : Le résultat après avoir calculé le factoriel de N et\n * pris le modulo 10007.\n * \n * Exemples :\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechnet die Fakultät von N modulo 10007.\n * \n * Parameter:\n * - N (int): Eine Ganzzahl, die den Eingabewert darstellt (N <= 10000).\n * \n * Rückgabewert:\n * int: Das Ergebnis nach der Berechnung der Fakultät von N und\n * der Modulo-Operation mit 10007.\n * \n * Beispiele:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafi na factorial na N modulo 10007.\n * \n * Sigogi:\n * - N (int): Wani cikakken lamba da ke wakiltar ƙimar shigarwa (N <= 10000).\n * \n * Komawa:\n * int: Sakamakon bayan lissafin factorial na N da\n * ɗaukar modulo 10007.\n * \n * Misalai:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N का फैक्टरियल 10007 से मॉड्यूलो के साथ गणना करता है।\n * \n * पैरामीटर्स:\n * - N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n * \n * रिटर्न्स:\n * int: N का फैक्टरियल गणना करने के बाद और\n * 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n * \n * उदाहरण:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Kiszámítja N faktoriálisát modulo 10007.\n * \n * Paraméterek:\n * - N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n * \n * Visszatérési érték:\n * int: Az eredmény, miután kiszámította N faktoriálisát és\n * elvégezte a modulo 10007 műveletet.\n * \n * Példák:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9945021096833353",
      "hy": "0.9919085927981628",
      "bn": "0.9930491284460651",
      "bg": "0.9945021096833353",
      "zh": "0.9861040171731803",
      "fr": "1",
      "de": "0.9804652979163618",
      "ha": "0.9918766133068162",
      "hi": "0.9893752609184439",
      "hu": "0.981433621023907"
    },
    "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "en": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\n将以下 CPP 代码的自然语言描述（文档字符串）用中文简明扼要地提供，字数不超过500个字符。",
      "fr": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8634835240489127",
      "bg": "0.8329214591013607",
      "zh": "0.8476298401866131",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.9536396690664571",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "process_request",
    "signature": "int process_request(int n)",
    "docstring": {
      "en": "Calculates the factorial of N modulo 10007.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after calculating the factorial of N and\ntaking the modulo 10007.\n\nExamples:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "sq": "Llogarit faktorielin e N modulo 10007.\n\nParametrat:\n- N (int): Një numër i plotë që përfaqëson vlerën hyrëse (N <= 10000).\n\nKthen:\nint: Rezultati pas llogaritjes së faktorielit të N dhe\nmarrjes së modulo 10007.\n\nShembuj:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "hy": "Հաշվում է N-ի ֆակտորիալը մոդուլո 10007-ով։\n\nՊարամետրեր՝\n- N (int): Ընդհանուր թիվ, որը ներկայացնում է մուտքային արժեքը (N <= 10000)։\n\nՎերադարձնում է՝\nint: Արդյունքը՝ N-ի ֆակտորիալը հաշվելուց հետո և\nմոդուլո 10007 վերցնելուց հետո։\n\nՕրինակներ՝\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "bn": "N এর ফ্যাক্টোরিয়াল 10007 দ্বারা মডুলো হিসাব করে।\n\nপ্যারামিটার:\n- N (int): একটি পূর্ণসংখ্যা যা ইনপুট মানকে উপস্থাপন করে (N <= 10000)।\n\nফেরত দেয়:\nint: N এর ফ্যাক্টোরিয়াল গণনা করার পর এবং 10007 দ্বারা মডুলো নেওয়ার পর ফলাফল।\n\nউদাহরণ:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "bg": "Изчислява факториела на N по модул 10007.\n\nПараметри:\n- N (int): Цяло число, представляващо входната стойност (N <= 10000).\n\nВръща:\nint: Резултатът след изчисляване на факториела на N и\nвземане на модул 10007.\n\nПримери:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "zh": "计算 N 的阶乘并取模 10007。\n\n参数：\n- N (int): 表示输入值的整数 (N <= 10000)。\n\n返回：\nint: 计算 N 的阶乘并取模 10007 后的结果。\n\n示例：\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "fr": "Calcule la factorielle de N modulo 10007.\n\nParamètres:\n- N (int): Un entier représentant la valeur d'entrée (N <= 10000).\n\nRenvoie:\nint: Le résultat après avoir calculé la factorielle de N et\nappliqué le modulo 10007.\n\nExemples:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "de": "Berechnet die Fakultät von N modulo 10007.\n\nParameter:\n- N (int): Eine ganze Zahl, die den Eingabewert darstellt (N <= 10000).\n\nRückgabewerte:\nint: Das Ergebnis nach der Berechnung der Fakultät von N und\nder Modulo-Operation mit 10007.\n\nBeispiele:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "ha": "Lissafi na factorial na N modulo 10007.\n\nSigogi:\n- N (int): Wani cikakken lamba wanda ke wakiltar darajar shigarwa (N <= 10000).\n\nDawowa:\nint: Sakamakon bayan lissafin factorial na N da\ndaukar modulo 10007.\n\nMisalai:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "hi": "N का फैक्टोरियल 10007 से मॉड्यूलो निकालता है।\n\nपैरामीटर्स:\n- N (int): एक पूर्णांक जो इनपुट मान का प्रतिनिधित्व करता है (N <= 10000)।\n\nवापसी:\nint: N का फैक्टोरियल निकालने और 10007 से मॉड्यूलो लेने के बाद का परिणाम।\n\nउदाहरण:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "hu": "Kiszámítja N faktoriálisát modulo 10007.\n\nParaméterek:\n- N (int): Egy egész szám, amely az input értéket jelöli (N <= 10000).\n\nVisszatérési érték:\nint: Az eredmény, miután kiszámítottuk N faktoriálisát és\nvettük a modulo 10007-et.\n\nPéldák:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266"
    },
    "docstring_bertscore": {
      "sq": "0.9910789136965801",
      "hy": "0.9939064171706117",
      "bn": "0.9918116611722178",
      "bg": "0.9939064171706117",
      "zh": "0.9682926322754007",
      "fr": "0.9815220115434674",
      "de": "0.9678822619081827",
      "ha": "0.9807984010653573",
      "hi": "0.9527710584101915",
      "hu": "0.9897882134806154"
    }
  },
  {
    "task_id": "CPP/7",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "sq": "#include <bits/stdc++.h>\n/*\nLlogarit sipërfaqen e një trekëndëshi duke dhënë bazën dhe lartësinë e tij.\n​    Parametrat:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​    Kthen:\n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hy": "#include <bits/stdc++.h>\n/*\nՀաշվարկել եռանկյան մակերեսը, տրված նրա հիմքը և բարձրությունը։\n​    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n​    Վերադարձնում է:\n​    float: Եռանկյան հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական։\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "bn": "#include <bits/stdc++.h>\n/*\nএকটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n​    প্যারামিটার:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n​    রিটার্নস:\n​    float: ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "bg": "#include <bits/stdc++.h>\n/*\nИзчислете площта на триъгълник, като се даде неговата основа и височина.\n​    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчислената площ на триъгълника, закръглена до един десетичен знак.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "zh": "#include <bits/stdc++.h>\n/*\n计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算出的三角形面积，保留一位小数。\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "fr": "#include <bits/stdc++.h>\n/*\nCalculer l'aire d'un triangle donné sa base et sa hauteur.\n​    Paramètres :\n- base (int) : La longueur de la base du triangle.\n- height (int) : La hauteur du triangle.\n​    Renvoie :\n​    float : L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "de": "#include <bits/stdc++.h>\n/*\nBerechne die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabe:\n    float: Die berechnete Fläche des Dreiecks, auf eine Dezimalstelle gerundet.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "ha": "#include <bits/stdc++.h>\n/*\nƘididdige yanki na alwatika la'akari da ginshiƙi da tsawo.\n​    Sigogi:\n- base (int): Tsawon ginshiƙin alwatika.\n- height (int): Tsawon alwatika.\n​    Komawa:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na ɗabi'u.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hi": "#include <bits/stdc++.h>\n/*\nत्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न करता है:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "hu": "#include <bits/stdc++.h>\n/*\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n​    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n​    Visszatér:\n​    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)"
    },
    "prompt_bertscore": {
      "sq": "0.9780082401029603",
      "hy": "0.9725689457487009",
      "bn": "0.9726291307541545",
      "bg": "0.9780082401029603",
      "zh": "0.9757798058581298",
      "fr": "0.9780082401029603",
      "de": "0.9759192443856164",
      "ha": "0.9757798058581298",
      "hi": "0.9753118326804117",
      "hu": "0.9689071946743227"
    },
    "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}",
    "instruction": {
      "en": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8537522244212515",
      "bg": "0.9881575205401952",
      "zh": "0.9087695938105666",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9134174141676543",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "float calculate_triangle_area(int base, int height)",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n    Parametra:\n- base (int): Gjatësia e bazës së trekëndëshit.\n- height (int): Lartësia e trekëndëshit.\n​    Kthen:\n​    float: Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hy": "Հաշվարկել եռանկյան մակերեսը՝ տրված դրա հիմքը և բարձրությունը։\n    Պարամետրեր:\n- base (int): Եռանկյան հիմքի երկարությունը։\n- height (int): Եռանկյան բարձրությունը։\n    Վերադարձնում է:\n    float: Եռանկյան հաշվարկված մակերեսը՝ կլորացված մինչև մեկ տասնորդական։\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bn": "ত্রিভুজের ভিত্তি এবং উচ্চতা প্রদত্ত হলে এর ক্ষেত্রফল গণনা করুন।\n    Parameters:\n- base (int): ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n- height (int): ত্রিভুজের উচ্চতা।\n    Returns:\n    float: ত্রিভুজের গণিত ক্ষেত্রফল, এক দশমিক স্থান পর্যন্ত গোলাকার।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "bg": "Изчисляване на лицето на триъгълник, като се дадат неговата основа и височина.\n    Параметри:\n- base (int): Дължината на основата на триъгълника.\n- height (int): Височината на триъгълника.\n​    Връща:\n​    float: Изчисленото лице на триъгълника, закръглено до един десетичен знак.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "zh": "计算给定底边和高的三角形面积。\n    参数:\n- base (int): 三角形的底边长度。\n- height (int): 三角形的高度。\n    返回:\n    float: 计算得到的三角形面积，四舍五入到小数点后一位。\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n    Paramètres:\n- base (int): La longueur de la base du triangle.\n- height (int): La hauteur du triangle.\n    Renvoie:\n    float: L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "de": "Berechne die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n    Parameter:\n- base (int): Die Basislänge des Dreiecks.\n- height (int): Die Höhe des Dreiecks.\n    Rückgabewert:\n    float: Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "ha": "Ƙididdige yanki na alwatika la'akari da tushenta da tsayinta.\n    Sigogi:\n- base (int): Tsawon tushe na alwatika.\n- height (int): Tsawon tsayi na alwatika.\n​    Mayarwa:\n​    float: Yankin da aka ƙididdige na alwatika, an zagaye zuwa wuri ɗaya na ɗigon goma.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hi": "त्रिभुज का क्षेत्रफल उसकी आधार और ऊँचाई के आधार पर गणना करें।\n    पैरामीटर्स:\n- base (int): त्रिभुज की आधार लंबाई।\n- height (int): त्रिभुज की ऊँचाई।\n    रिटर्न्स:\n    float: त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "hu": "Számítsa ki egy háromszög területét az alapja és magassága alapján.\n    Paraméterek:\n- base (int): A háromszög alapjának hossza.\n- height (int): A háromszög magassága.\n    Visszatér:\n    float: A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "docstring_bertscore": {
      "sq": "0.9749854829643714",
      "hy": "0.9749854829643714",
      "bn": "0.9588402097027126",
      "bg": "0.9768617455436269",
      "zh": "0.9800815440202024",
      "fr": "0.9800815440202024",
      "de": "0.9795335227989271",
      "ha": "0.9677209740387824",
      "hi": "0.9767703755683509",
      "hu": "0.9670039183632464"
    }
  },
  {
    "task_id": "CPP/8",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "sq": "#include <bits/stdc++.h>\n/*\nLlogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n​    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n​    Kthen:\n​    int: Distanca Hamming midis x dhe y, dmth, numri i biteve që duhet të ndryshohen\n​         për të transformuar x në y në binar.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hy": "#include <bits/stdc++.h>\n/*\nՀաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև բինար ներկայացման մեջ:\n​    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000):\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000):\n​    Վերադարձնում է:\n​    int: Հեմինգի հեռավորությունը x և y միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն\n​         x-ը y-ի վերածելու համար բինար տեսքով:\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "bn": "#include <bits/stdc++.h>\n/*\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n​    প্যারামিটার:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n​    রিটার্নস:\n​    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "bg": "#include <bits/stdc++.h>\n/*\nИзчислете разстоянието на Хаминг между две цели числа в двоична форма.\n​    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n​    Връща:\n​    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати,\n​         за да се преобразува x в y в двоична форма.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "zh": "#include <bits/stdc++.h>\n/*\n计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "fr": "#include <bits/stdc++.h>\n/*\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\n​    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le second entier positif (y <= 1,000,000,000).\n​    Renvoie:\n​    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés\n​         pour transformer x en y en binaire.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "de": "#include <bits/stdc++.h>\n/*\nBerechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabe:\n    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen,\n         um x in y in binärer Form zu transformieren.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "ha": "#include <bits/stdc++.h>\n/*\nƘididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n​    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n​    Komawa:\n​    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa\n​         don canza x zuwa y a cikin binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hi": "#include <bits/stdc++.h>\n/*\nदो पूर्णांकों के बीच द्विआधारी अभ्यRepresentation में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न करता है:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को द्विआधारी में y में बदलने के लिए कितने बिट्स को फ्लिप करने की आवश्यकता है।\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "hu": "#include <bits/stdc++.h>\n/*\nSzámítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni\n         ahhoz, hogy x-ből y-t alakítsunk binárisan.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)"
    },
    "prompt_bertscore": {
      "sq": "0.9654762521027072",
      "hy": "0.9666253288569939",
      "bn": "0.9534076687814084",
      "bg": "0.9684384269750804",
      "zh": "0.9745983523517343",
      "fr": "0.9773545475189744",
      "de": "0.9752844216878289",
      "ha": "0.9639636817511265",
      "hi": "0.962520830663289",
      "hu": "0.9626108102258978"
    },
    "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}",
    "instruction": {
      "en": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրումը (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 символа.",
      "zh": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\n将以下 CPP 代码的功能简洁地用中文自然语言描述（文档字符串），不超过 500 个字符。",
      "fr": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9421149357284319",
      "hy": "0.9267393551932832",
      "bn": "0.8480406078145932",
      "bg": "0.8365011292951701",
      "zh": "0.8330227605956885",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9430681629270182",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}",
    "entry_point": "hamming_distance",
    "signature": "int hamming_distance(int x, int y)",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n",
      "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n    Parametrat:\n- x (int): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (int): Numri i dytë pozitiv (y <= 1,000,000,000).\n    Kthen:\n    int: Distanca Hamming midis x dhe y, dmth numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\n    >>> hamming_distance(1,2)\n    2",
      "hy": "Հաշվարկել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկուական ներկայացմամբ։ \n    Պարամետրեր:\n- x (int): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։\n- y (int): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։\n    Վերադարձնում է:\n    int: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք անհրաժեշտ է փոխել, որպեսզի x-ը վերածվի y-ի երկուականում։\n    >>> hamming_distance(1,2)\n    2",
      "bn": "দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n    Parameters:\n- x (int): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n    Returns:\n    int: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\n    >>> hamming_distance(1,2)\n    2",
      "bg": "Изчисляване на разстоянието на Хаминг между две цели числа в двоична форма.\n    Параметри:\n- x (int): Първото положително цяло число (x <= 1,000,000,000).\n- y (int): Второто положително цяло число (y <= 1,000,000,000).\n    Връща:\n    int: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се преобразува x в y в двоична форма.\n    >>> hamming_distance(1,2)\n    2",
      "zh": "计算两个整数在二进制表示中的汉明距离。\n    参数:\n- x (int): 第一个正整数 (x <= 1,000,000,000)。\n- y (int): 第二个正整数 (y <= 1,000,000,000)。\n    返回:\n    int: x 和 y 之间的汉明距离，即需要翻转多少个位才能将 x 转换为 y。\n    >>> hamming_distance(1,2)\n    2",
      "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\n    Paramètres:\n- x (int): Le premier entier positif (x <= 1,000,000,000).\n- y (int): Le deuxième entier positif (y <= 1,000,000,000).\n    Renvoie:\n    int: La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\n    >>> hamming_distance(1,2)\n    2",
      "de": "Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n    Parameter:\n- x (int): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (int): Die zweite positive ganze Zahl (y <= 1.000.000.000).\n    Rückgabewert:\n    int: Die Hamming-Distanz zwischen x und y, d.h., die Anzahl der Bits, die umgekehrt werden müssen, um x in y in binär zu transformieren.\n    >>> hamming_distance(1,2)\n    2",
      "ha": "Ƙididdige nisan Hamming tsakanin lambobi biyu a cikin wakilcin binary.\n    Sigogi:\n- x (int): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (int): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n    Dawowa:\n    int: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.\n    >>> hamming_distance(1,2)\n    2",
      "hi": "दो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\n    पैरामीटर्स:\n- x (int): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (int): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n    रिटर्न्स:\n    int: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए जितने बिट्स को उलटना आवश्यक है।\n    >>> hamming_distance(1,2)\n    2",
      "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n    Paraméterek:\n- x (int): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (int): A második pozitív egész szám (y <= 1,000,000,000).\n    Visszatérési érték:\n    int: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni ahhoz, hogy x-et y-ra alakítsuk binárisan.\n    >>> hamming_distance(1,2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9930175462154806",
      "hy": "0.9893726787234903",
      "bn": "0.9737974746554017",
      "bg": "0.9957787071422466",
      "zh": "0.9859991403319939",
      "fr": "0.9946975619782736",
      "de": "0.990105028938366",
      "ha": "0.9635070305051272",
      "hi": "0.9722203494299847",
      "hu": "0.9730160627364104"
    }
  },
  {
    "task_id": "CPP/9",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.\n * Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3\n */\nint count_odd_numbers(int count, ...)",
      "sq": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Numëron numrin e numrave tek në një listë të dhënë numrash.\n * Parametrat:\n * - count (int): Numri i tërësishëm për t'u vlerësuar.\n * - ... (int): Një sekuencë tërësish.\n * Kthen:\n *   int: Numri i numrave tek në listën e dhënë.\n * Përdorimi:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) duhet të kthejë 3\n */\nint count_odd_numbers(int count, ...)",
      "hy": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Հաշվել տրված թվերի ցանկում կենտ ամբողջ թվերի քանակը։\n * Պարամետրեր:\n * - count (int): Արժևորելու ենթակա ամբողջ թվերի քանակը։\n * - ... (int): Ամբողջ թվերի հաջորդականություն։\n * Վերադարձնում է:\n *   int: Կենտ թվերի քանակը մուտքային ցանկում։\n * Օգտագործում:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3\n */\nint count_odd_numbers(int count, ...)",
      "bn": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * প্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\n * প্যারামিটার:\n * - count (int): মূল্যায়ন করার জন্য পূর্ণসংখ্যার সংখ্যা।\n * - ... (int): পূর্ণসংখ্যার একটি ক্রম।\n * রিটার্নস:\n *   int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n * ব্যবহার:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) 3 রিটার্ন করা উচিত\n */\nint count_odd_numbers(int count, ...)",
      "bg": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Брой на нечетните цели числа в даден списък от числа.\n * Параметри:\n * - count (int): Броят на целите числа за оценка.\n * - ... (int): Последователност от цели числа.\n * Връща:\n *   int: Броят на нечетните числа в входния списък.\n * Употреба:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) трябва да върне 3\n */\nint count_odd_numbers(int count, ...)",
      "zh": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * 计算给定数字列表中奇数的数量。\n * 参数:\n * - count (int): 要评估的整数数量。\n * - ... (int): 一系列整数。\n * 返回:\n *   int: 输入列表中奇数的数量。\n * 用法:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) 应返回 3\n */\nint count_odd_numbers(int count, ...)",
      "fr": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Compter le nombre d'entiers impairs dans une liste donnée de nombres.\n * Paramètres:\n * - count (int): Le nombre d'entiers à évaluer.\n * - ... (int): Une séquence d'entiers.\n * Retourne:\n *   int: Le nombre d'entiers impairs dans la liste d'entrée.\n * Utilisation:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) devrait retourner 3\n */\nint count_odd_numbers(int count, ...)",
      "de": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Zählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n * Parameter:\n * - count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n * - ... (int): Eine Sequenz von Ganzzahlen.\n * Rückgabe:\n *   int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n * Verwendung:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben\n */\nint count_odd_numbers(int count, ...)",
      "ha": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Ƙirga adadin lambobin da ba su daidai ba a cikin jerin lambobi da aka bayar.\n * Sigogi:\n * - count (int): Yawan lambobin da za a tantance.\n * - ... (int): Jerin lambobi.\n * Komawa:\n *   int: Adadin lambobin da ba su daidai ba a cikin jerin shigarwa.\n * Amfani:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3\n */\nint count_odd_numbers(int count, ...)",
      "hi": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।\n * पैरामीटर्स:\n * - count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।\n * - ... (int): पूर्णांकों का अनुक्रम।\n * रिटर्न करता है:\n *   int: इनपुट सूची में विषम संख्याओं की गिनती।\n * उपयोग:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) को 3 लौटाना चाहिए\n */\nint count_odd_numbers(int count, ...)",
      "hu": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Számolja meg a páratlan egész számok számát egy adott számok listájában.\n * Paraméterek:\n * - count (int): Az értékelendő egész számok száma.\n * - ... (int): Egy egész számok sorozata.\n * Visszatér:\n *   int: A bemeneti listában lévő páratlan számok száma.\n * Használat:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) vissza kell adja a 3-at\n */\nint count_odd_numbers(int count, ...)"
    },
    "prompt_bertscore": {
      "sq": "0.9726146307363389",
      "hy": "0.9965638930384775",
      "bn": "0.9965638930384775",
      "bg": "0.9799003931126986",
      "zh": "0.983551815407263",
      "fr": "0.995115083039209",
      "de": "0.9870216895335614",
      "ha": "0.9756393741787383",
      "hi": "0.9882964993190434",
      "hu": "0.9896964462445772"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}",
    "instruction": {
      "en": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9267393551932832",
      "bn": "0.8868565596156691",
      "bg": "0.8365011292951701",
      "zh": "0.9094427987050953",
      "fr": "0.9172954737269795",
      "de": "0.9389289044166322",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_odd_numbers",
    "signature": "int count_odd_numbers(int count, ...)",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\nParameters:\n- count (int): The number of integers to evaluate.\n- ... (int): A sequence of integers.\nReturns:\n  int: The count of odd numbers in the input list.\nUsage:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3",
      "sq": "Numëroni numrin e numrave tek në një listë të dhënë numrash.  \nParametrat:  \n- count (int): Numri i numrave për të vlerësuar.  \n- ... (int): Një sekuencë numrash të plotë.  \nKthen:  \n  int: Numri i numrave tek në listën e dhënë.  \nPërdorimi:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) duhet të kthejë 3  ",
      "hy": "Հաշվել տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\nՊարամետրեր՝\n- count (int): Ամբողջ թվերի քանակը գնահատելու համար։\n- ... (int): Ամբողջ թվերի հաջորդականություն։\nՎերադարձնում է՝\n  int: Կենտ թվերի քանակը մուտքագրված ցուցակում։\nՕգտագործում՝\n  count_odd_numbers(5, 1, 4, 3, 2, 5) պետք է վերադարձնի 3",
      "bn": "দেওয়া সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করুন।\nপ্যারামিটারসমূহ:\n- count (int): মূল্যায়ন করার পূর্ণসংখ্যার সংখ্যা।\n- ... (int): পূর্ণসংখ্যার একটি ক্রম।\nফেরত দেয়:\n  int: ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\nব্যবহার:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 3 ফেরত দেবে।",
      "bg": "Бройте броя на нечетните цели числа в даден списък от числа.\nПараметри:\n- count (int): Броят на целите числа за оценка.\n- ... (int): Последователност от цели числа.\nВръща:\n  int: Броят на нечетните числа в входния списък.\nИзползване:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) трябва да върне 3",
      "zh": "计算给定数字列表中奇数的数量。\n参数：\n- count (int): 要评估的整数数量。\n- ... (int): 一系列整数。\n返回：\n  int: 输入列表中奇数的数量。\n用法：\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 应返回 3",
      "fr": "Compter le nombre d'entiers impairs dans une liste donnée de nombres.\nParamètres:\n- count (int): Le nombre d'entiers à évaluer.\n- ... (int): Une séquence d'entiers.\nRenvoie:\n  int: Le nombre d'entiers impairs dans la liste d'entrée.\nUtilisation:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) devrait renvoyer 3",
      "de": "Zähle die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\nParameter:\n- count (int): Die Anzahl der zu bewertenden Ganzzahlen.\n- ... (int): Eine Sequenz von Ganzzahlen.\nRückgabe:\n  int: Die Anzahl der ungeraden Zahlen in der Eingabeliste.\nVerwendung:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) sollte 3 zurückgeben.",
      "ha": "Ƙirga adadin lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\nParameters:  \n- count (int): Yawan lambobin da za a tantance.  \n- ... (int): Jerin lambobi.  \nReturns:  \n  int: Yawan lambobin da ba su da ma'ana a cikin jerin shigarwa.  \nUsage:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) ya kamata ya dawo da 3",
      "hi": "दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनें।  \nपैरामीटर्स:  \n- count (int): मूल्यांकन करने के लिए पूर्णांकों की संख्या।  \n- ... (int): पूर्णांकों का अनुक्रम।  \nरिटर्न्स:  \n  int: इनपुट सूची में विषम संख्याओं की गिनती।  \nउपयोग:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) को 3 लौटाना चाहिए।",
      "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\nParaméterek:\n- count (int): Az értékelendő egész számok száma.\n- ... (int): Egy egész számok sorozata.\nVisszatér:\n  int: A páratlan számok száma a bemeneti listában.\nHasználat:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) esetén az eredmény 3 kell legyen."
    },
    "docstring_bertscore": {
      "sq": "0.9562540421416383",
      "hy": "0.959053737362325",
      "bn": "0.9897758983969912",
      "bg": "0.995206254384104",
      "zh": "0.9794707555985201",
      "fr": "0.9930342311674875",
      "de": "0.9811388535384512",
      "ha": "0.9651310325004685",
      "hi": "0.9614009525750143",
      "hu": "0.9755499905072725"
    }
  },
  {
    "task_id": "CPP/10",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculate the sum of even numbers in a given array.\n * \n * Parameters:\n * - numbers (vector<int>): A vector of integers.\n * - size (int): The size of the array.\n * \n * Returns:\n * int: The sum of even numbers in the input array.\n * \n * Examples:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Llogarit shumën e numrave çift në një varg të dhënë.\n * \n * Parametrat:\n * - numbers (vector<int>): Një vektor i numrave të plotë.\n * - size (int): Madhësia e vargut.\n * \n * Kthen:\n * int: Shuma e numrave çift në vargun hyrës.\n * \n * Shembuj:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Հաշվել տրված զանգվածի զույգ թվերի գումարը։\n * \n * Պարամետրեր:\n * - numbers (vector<int>): Թվերի վեկտոր։\n * - size (int): Զանգվածի չափը։\n * \n * Վերադարձնում է:\n * int: Մուտքային զանգվածի զույգ թվերի գումարը։\n * \n * Օրինակներ:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * প্রদত্ত অ্যারের মধ্যে জোড় সংখ্যাগুলির যোগফল গণনা করুন।\n * \n * প্যারামিটার:\n * - numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n * - size (int): অ্যারের আকার।\n * \n * রিটার্নস:\n * int: ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\n * \n * উদাহরণ:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Изчислява сумата на четните числа в даден масив.\n * \n * Параметри:\n * - numbers (vector<int>): Вектор от цели числа.\n * - size (int): Размерът на масива.\n * \n * Връща:\n * int: Сумата на четните числа в входния масив.\n * \n * Примери:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 计算给定数组中偶数的和。\n * \n * 参数:\n * - numbers (vector<int>): 整数向量。\n * - size (int): 数组的大小。\n * \n * 返回:\n * int: 输入数组中偶数的和。\n * \n * 示例:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculer la somme des nombres pairs dans un tableau donné.\n * \n * Paramètres:\n * - numbers (vector<int>): Un vecteur d'entiers.\n * - size (int): La taille du tableau.\n * \n * Renvoie:\n * int: La somme des nombres pairs dans le tableau d'entrée.\n * \n * Exemples:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Berechne die Summe der geraden Zahlen in einem gegebenen Array.\n * \n * Parameter:\n * - numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n * - size (int): Die Größe des Arrays.\n * \n * Rückgabewert:\n * int: Die Summe der geraden Zahlen im Eingabearray.\n * \n * Beispiele:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Lissafi jimillar lambobin da suka kasance ma'aurata a cikin wani jeri.\n * \n * Sigogi:\n * - numbers (vector<int>): Wani vector na lambobi.\n * - size (int): Girman jerin.\n * \n * Komawa:\n * int: Jimillar lambobin da suka kasance ma'aurata a cikin jerin shigarwa.\n * \n * Misalai:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * दिए गए array में सम संख्याओं का योग गणना करें।\n * \n * पैरामीटर्स:\n * - numbers (vector<int>): पूर्णांकों का एक वेक्टर।\n * - size (int): array का आकार।\n * \n * रिटर्न करता है:\n * int: इनपुट array में सम संख्याओं का योग।\n * \n * उदाहरण:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Számítsa ki a páros számok összegét egy adott tömbben.\n * \n * Paraméterek:\n * - numbers (vector<int>): Egész számok vektora.\n * - size (int): A tömb mérete.\n * \n * Visszatérési érték:\n * int: A bemeneti tömbben lévő páros számok összege.\n * \n * Példák:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)"
    },
    "prompt_bertscore": {
      "sq": "0.9987657108122492",
      "hy": "0.9773835475546055",
      "bn": "0.9966910164823398",
      "bg": "0.9877121287380387",
      "zh": "0.975108633800613",
      "fr": "1",
      "de": "0.9873988886271466",
      "ha": "0.9623517962090283",
      "hi": "0.9872896419175775",
      "hu": "0.9914217497342462"
    },
    "canonical_solution": "{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\n请为以下 CPP 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过 500 个字符。",
      "fr": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9156510128023916",
      "bn": "0.8736615434035214",
      "bg": "0.8365011292951701",
      "zh": "0.8736232077399817",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    std::vector<int> sample1 = {1, 4, 3, 2, 5};\n    std::vector<int> sample2 = {2, 2, 0, 0};\n    std::vector<int> sample3 = {7, 11, 19}; // Additional test with no even numbers\n    std::vector<int> sample4 = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1) == 6);\n    assert(calculate_even_sum(sample2) == 4);\n    assert(calculate_even_sum(sample3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4) == 12 + 14 + 16 + 18 + 20);\n\n    // std::cout << \"All tests passed successfully.\\n\";\n\n    return 0;\n}",
    "entry_point": "calculate_even_sum",
    "signature": "int calculate_even_sum(const std::vector<int>& numbers)",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given array.\n\nParameters:\n- numbers (vector<int>): A vector of integers.\n\nReturns:\nint: The sum of even numbers in the input array.\n\nExamples:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6\n",
      "sq": "Llogarit shumën e numrave çift në një varg të dhënë.\n\nParametrat:\n- numbers (vector<int>): Një vektor i numrave të plotë.\n\nKthen:\nint: Shuma e numrave çift në vargun hyrës.\n\nShembuj:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "hy": "Հաշվել տրված զանգվածում զույգ թվերի գումարը։\n\nՊարամետրեր:\n- numbers (vector<int>): Ամբողջ թվերի վեկտոր։\n\nՎերադարձնում է:\nint: Մուտքագրված զանգվածի զույգ թվերի գումարը։\n\nՕրինակներ:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "bn": "দেওয়া অ্যারেতে জোড় সংখ্যাগুলোর যোগফল গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- numbers (vector<int>): পূর্ণসংখ্যার একটি ভেক্টর।\n\nফেরত দেয়:\nint: ইনপুট অ্যারেতে জোড় সংখ্যাগুলোর যোগফল।\n\nউদাহরণ:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "bg": "Изчисляване на сумата от четни числа в даден масив.\n\nПараметри:\n- numbers (vector<int>): Вектор от цели числа.\n\nВръща:\nint: Сумата от четните числа в входния масив.\n\nПримери:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "zh": "计算给定数组中偶数的和。\n\n参数：\n- numbers (vector<int>): 一个整数向量。\n\n返回：\nint: 输入数组中偶数的和。\n\n示例：\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "fr": "Calculer la somme des nombres pairs dans un tableau donné.\n\nParamètres:\n- numbers (vector<int>): Un vecteur d'entiers.\n\nRenvoie:\nint: La somme des nombres pairs dans le tableau d'entrée.\n\nExemples:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "de": "Berechnen Sie die Summe der geraden Zahlen in einem gegebenen Array.\n\nParameter:\n- numbers (vector<int>): Ein Vektor von ganzen Zahlen.\n\nRückgabewert:\nint: Die Summe der geraden Zahlen im Eingabearray.\n\nBeispiele:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "ha": "Lissafa jimillar lambobin da suka zama lamba biyu a cikin jerin da aka bayar.\n\nMa'auni:\n- numbers (vector<int>): Wata vector na lambobi.\n\nDawowa:\nint: Jimillar lambobin da suka kasance ma'aurata a cikin jerin lambobin shigarwa.\n\nMisalai:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "hi": "दिए गए ऐरे में सम संख्या का योग गणना करें।\n\nपैरामीटर्स:\n- numbers (vector<int>): पूर्णांकों का एक वेक्टर।\n\nरिटर्न्स:\nint: इनपुट ऐरे में सम संख्याओं का योग।\n\nउदाहरण:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "hu": "Számítsa ki a páros számok összegét egy adott tömbben.\n\nParaméterek:\n- numbers (vector<int>): Egész számok vektora.\n\nVisszatérési érték:\nint: A bemeneti tömbben lévő páros számok összege.\n\nPéldák:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.978553480498901",
      "bn": "1",
      "bg": "0.9855474548455205",
      "zh": "0.9975447298600277",
      "fr": "0.9955383643811944",
      "de": "0.9677791727404256",
      "ha": "0.9951009802821555",
      "hi": "0.9930731627221704",
      "hu": "0.9860674691830699"
    }
  },
  {
    "task_id": "CPP/11",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Determines if two closed intervals intersect.\n *\n * @param a The lower bound of the first closed interval [a,b].\n * @param b The upper bound of the first closed interval [a,b].\n * @param c The lower bound of the second closed interval [c,d].\n * @param d The upper bound of the second closed interval [c,d].\n *\n * @return 1 if the intervals intersect, 0 otherwise.\n *\n * Examples:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Përcakton nëse dy intervale të mbyllura ndërpriten.\n *\n * @param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].\n * @param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].\n * @param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].\n * @param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n *\n * @return 1 nëse intervalet ndërpriten, 0 përndryshe.\n *\n * Shembuj:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Որոշում է՝ արդյոք երկու փակ միջակայքեր հատվում են։\n *\n * @param a Առաջին փակ միջակայքի [a,b] ստորին սահմանը։\n * @param b Առաջին փակ միջակայքի [a,b] վերին սահմանը։\n * @param c Երկրորդ փակ միջակայքի [c,d] ստորին սահմանը։\n * @param d Երկրորդ փակ միջակայքի [c,d] վերին սահմանը։\n *\n * @return 1 եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n *\n * Օրինակներ:\n * are_intervals_intersecting(1, 1, 1, 2) վերադարձնում է 1\n * are_intervals_intersecting(3, 5, 2, 6) վերադարձնում է 1\n * are_intervals_intersecting(3, 5, 4, 7) վերադարձնում է 1\n * are_intervals_intersecting(3, 5, 6, 7) վերադարձնում է 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * দুটি বন্ধ অন্তরাল একে অপরকে অতিক্রম করে কিনা তা নির্ধারণ করে।\n *\n * @param a প্রথম বন্ধ অন্তরাল [a,b] এর নিম্ন সীমা।\n * @param b প্রথম বন্ধ অন্তরাল [a,b] এর উপরের সীমা।\n * @param c দ্বিতীয় বন্ধ অন্তরাল [c,d] এর নিম্ন সীমা।\n * @param d দ্বিতীয় বন্ধ অন্তরাল [c,d] এর উপরের সীমা।\n *\n * @return অন্তরালগুলি অতিক্রম করলে 1, অন্যথায় 0।\n *\n * উদাহরণ:\n * are_intervals_intersecting(1, 1, 1, 2) 1 প্রদান করে\n * are_intervals_intersecting(3, 5, 2, 6) 1 প্রদান করে\n * are_intervals_intersecting(3, 5, 4, 7) 1 প্রদান করে\n * are_intervals_intersecting(3, 5, 6, 7) 0 প্রদান করে\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Определя дали два затворени интервала се пресичат.\n *\n * @param a Долна граница на първия затворен интервал [a,b].\n * @param b Горна граница на първия затворен интервал [a,b].\n * @param c Долна граница на втория затворен интервал [c,d].\n * @param d Горна граница на втория затворен интервал [c,d].\n *\n * @return 1 ако интервалите се пресичат, 0 в противен случай.\n *\n * Примери:\n * are_intervals_intersecting(1, 1, 1, 2) връща 1\n * are_intervals_intersecting(3, 5, 2, 6) връща 1\n * are_intervals_intersecting(3, 5, 4, 7) връща 1\n * are_intervals_intersecting(3, 5, 6, 7) връща 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 判断两个闭区间是否相交。\n *\n * @param a 第一个闭区间 [a,b] 的下界。\n * @param b 第一个闭区间 [a,b] 的上界。\n * @param c 第二个闭区间 [c,d] 的下界。\n * @param d 第二个闭区间 [c,d] 的上界。\n *\n * @return 如果区间相交返回 1，否则返回 0。\n *\n * 示例:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Détermine si deux intervalles fermés s'intersectent.\n *\n * @param a La borne inférieure du premier intervalle fermé [a,b].\n * @param b La borne supérieure du premier intervalle fermé [a,b].\n * @param c La borne inférieure du second intervalle fermé [c,d].\n * @param d La borne supérieure du second intervalle fermé [c,d].\n *\n * @return 1 si les intervalles s'intersectent, 0 sinon.\n *\n * Exemples :\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Bestimmt, ob zwei abgeschlossene Intervalle sich überschneiden.\n *\n * @param a Die untere Grenze des ersten abgeschlossenen Intervalls [a,b].\n * @param b Die obere Grenze des ersten abgeschlossenen Intervalls [a,b].\n * @param c Die untere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n * @param d Die obere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n *\n * @return 1, wenn die Intervalle sich überschneiden, 0 andernfalls.\n *\n * Beispiele:\n * are_intervals_intersecting(1, 1, 1, 2) gibt 1 zurück\n * are_intervals_intersecting(3, 5, 2, 6) gibt 1 zurück\n * are_intervals_intersecting(3, 5, 4, 7) gibt 1 zurück\n * are_intervals_intersecting(3, 5, 6, 7) gibt 0 zurück\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Yana tantance ko wasu zangon rufe guda biyu suna haduwa.\n *\n * @param a Ƙananan iyaka na zangon rufe na farko [a,b].\n * @param b Babban iyaka na zangon rufe na farko [a,b].\n * @param c Ƙananan iyaka na zangon rufe na biyu [c,d].\n * @param d Babban iyaka na zangon rufe na biyu [c,d].\n *\n * @return 1 idan zangon suna haduwa, 0 in ba haka ba.\n *\n * Misalai:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * यह निर्धारित करता है कि दो बंद अंतराल एक-दूसरे को काटते हैं या नहीं।\n *\n * @param a पहले बंद अंतराल [a,b] की निचली सीमा।\n * @param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n * @param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n * @param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n *\n * @return 1 यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा 0।\n *\n * उदाहरण:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Meghatározza, hogy két zárt intervallum metszi-e egymást.\n *\n * @param a Az első zárt intervallum alsó határa [a,b].\n * @param b Az első zárt intervallum felső határa [a,b].\n * @param c A második zárt intervallum alsó határa [c,d].\n * @param d A második zárt intervallum felső határa [c,d].\n *\n * @return 1, ha az intervallumok metszik egymást, különben 0.\n *\n * Példák:\n * are_intervals_intersecting(1, 1, 1, 2) visszaadja 1\n * are_intervals_intersecting(3, 5, 2, 6) visszaadja 1\n * are_intervals_intersecting(3, 5, 4, 7) visszaadja 1\n * are_intervals_intersecting(3, 5, 6, 7) visszaadja 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)"
    },
    "prompt_bertscore": {
      "sq": "0.9753777779669153",
      "hy": "0.9748899417510936",
      "bn": "0.9773122392478141",
      "bg": "0.9748899417510936",
      "zh": "0.9882990815139968",
      "fr": "1",
      "de": "0.9993643827806884",
      "ha": "0.9612704524146743",
      "hi": "0.978513158531551",
      "hu": "0.9978240041757628"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "en": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nՏվյալ CPP կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\n将以下CPP代码的自然语言描述（文档字符串）翻译成中文，限制在500个字符以内。",
      "fr": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nसीपीपी कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.8898209194222337",
      "bn": "0.8448917203840473",
      "bg": "0.9881575205401952",
      "zh": "0.8379724310606969",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.8917424697283652",
      "hi": "0.9395643230055628",
      "hu": "0.931788142218428"
    },
    "level": "",
    "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "are_intervals_intersecting",
    "signature": "int are_intervals_intersecting(int a, int b, int c, int d)",
    "docstring": {
      "en": "Determines if two closed intervals intersect.\n\n@param a The lower bound of the first closed interval [a,b].\n@param b The upper bound of the first closed interval [a,b].\n@param c The lower bound of the second closed interval [c,d].\n@param d The upper bound of the second closed interval [c,d].\n\n@return 1 if the intervals intersect, 0 otherwise.\n\nExamples:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0\n",
      "sq": "Determinon nëse dy intervale të mbyllura ndërpriten.\n\n@param a Kufiri i poshtëm i intervalit të parë të mbyllur [a,b].\n@param b Kufiri i sipërm i intervalit të parë të mbyllur [a,b].\n@param c Kufiri i poshtëm i intervalit të dytë të mbyllur [c,d].\n@param d Kufiri i sipërm i intervalit të dytë të mbyllur [c,d].\n\n@return 1 nëse intervalet ndërpriten, 0 përndryshe.\n\nShembuj:\nare_intervals_intersecting(1, 1, 1, 2) kthen 1\nare_intervals_intersecting(3, 5, 2, 6) kthen 1\nare_intervals_intersecting(3, 5, 4, 7) kthen 1\nare_intervals_intersecting(3, 5, 6, 7) kthen 0",
      "hy": "Որոշում է՝ արդյոք երկու փակ միջակայքերը հատվում են։\n\n@param a Առաջին փակ միջակայքի ստորին սահմանը [a,b]։\n@param b Առաջին փակ միջակայքի վերին սահմանը [a,b]։\n@param c Երկրորդ փակ միջակայքի ստորին սահմանը [c,d]։\n@param d Երկրորդ փակ միջակայքի վերին սահմանը [c,d]։\n\n@return 1՝ եթե միջակայքերը հատվում են, 0՝ հակառակ դեպքում։\n\nՕրինակներ:\nare_intervals_intersecting(1, 1, 1, 2) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 2, 6) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 4, 7) վերադարձնում է 1\nare_intervals_intersecting(3, 5, 6, 7) վերադարձնում է 0",
      "bn": "দুটি বন্ধ ইন্টারভাল পরস্পরকে অতিক্রম করে কিনা তা নির্ধারণ করে।\n\n@param a প্রথম বন্ধ ইন্টারভালের [a,b] নিম্ন সীমা।\n@param b প্রথম বন্ধ ইন্টারভালের [a,b] উপরের সীমা।\n@param c দ্বিতীয় বন্ধ ইন্টারভালের [c,d] নিম্ন সীমা।\n@param d দ্বিতীয় বন্ধ ইন্টারভালের [c,d] উপরের সীমা।\n\n@return 1 যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় 0।\n\nউদাহরণ:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "bg": "Определя дали два затворени интервала се пресичат.\n\n@param a Долна граница на първия затворен интервал [a,b].\n@param b Горна граница на първия затворен интервал [a,b].\n@param c Долна граница на втория затворен интервал [c,d].\n@param d Горна граница на втория затворен интервал [c,d].\n\n@return 1 ако интервалите се пресичат, 0 в противен случай.\n\nПримери:\nare_intervals_intersecting(1, 1, 1, 2) връща 1\nare_intervals_intersecting(3, 5, 2, 6) връща 1\nare_intervals_intersecting(3, 5, 4, 7) връща 1\nare_intervals_intersecting(3, 5, 6, 7) връща 0",
      "zh": "确定两个闭区间是否相交。\n\n@param a 第一个闭区间 [a,b] 的下界。\n@param b 第一个闭区间 [a,b] 的上界。\n@param c 第二个闭区间 [c,d] 的下界。\n@param d 第二个闭区间 [c,d] 的上界。\n\n@return 如果区间相交返回 1，否则返回 0。\n\n示例：\nare_intervals_intersecting(1, 1, 1, 2) 返回 1\nare_intervals_intersecting(3, 5, 2, 6) 返回 1\nare_intervals_intersecting(3, 5, 4, 7) 返回 1\nare_intervals_intersecting(3, 5, 6, 7) 返回 0",
      "fr": "Détermine si deux intervalles fermés s'intersectent.\n\n@param a La borne inférieure du premier intervalle fermé [a,b].\n@param b La borne supérieure du premier intervalle fermé [a,b].\n@param c La borne inférieure du second intervalle fermé [c,d].\n@param d La borne supérieure du second intervalle fermé [c,d].\n\n@return 1 si les intervalles s'intersectent, 0 sinon.\n\nExemples:\nare_intervals_intersecting(1, 1, 1, 2) retourne 1\nare_intervals_intersecting(3, 5, 2, 6) retourne 1\nare_intervals_intersecting(3, 5, 4, 7) retourne 1\nare_intervals_intersecting(3, 5, 6, 7) retourne 0",
      "de": "Bestimmt, ob zwei abgeschlossene Intervalle sich überschneiden.\n\n@param a Die untere Grenze des ersten abgeschlossenen Intervalls [a,b].\n@param b Die obere Grenze des ersten abgeschlossenen Intervalls [a,b].\n@param c Die untere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n@param d Die obere Grenze des zweiten abgeschlossenen Intervalls [c,d].\n\n@return 1, wenn sich die Intervalle überschneiden, 0 andernfalls.\n\nBeispiele:\nare_intervals_intersecting(1, 1, 1, 2) gibt 1 zurück\nare_intervals_intersecting(3, 5, 2, 6) gibt 1 zurück\nare_intervals_intersecting(3, 5, 4, 7) gibt 1 zurück\nare_intervals_intersecting(3, 5, 6, 7) gibt 0 zurück",
      "ha": "Yana tantance idan tazara biyu masu rufe suna hade.\n\n@param a Ƙananan iyaka na farkon rufaffiyar tazara [a,b].\n@param b Babban iyaka na farkon rufaffiyar tazara [a,b].\n@param c Ƙananan iyaka na na biyun rufaffiyar tazara [c,d].\n@param d Babban iyaka na na biyun rufaffiyar tazara [c,d].\n\n@return 1 idan tazarorin sun haɗu, 0 in ba haka ba.\n\nMisalai:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "hi": "दो बंद अंतरालों के प्रतिच्छेदन की जाँच करता है।\n\n@param a पहले बंद अंतराल [a,b] की निचली सीमा।\n@param b पहले बंद अंतराल [a,b] की ऊपरी सीमा।\n@param c दूसरे बंद अंतराल [c,d] की निचली सीमा।\n@param d दूसरे बंद अंतराल [c,d] की ऊपरी सीमा।\n\n@return 1 यदि अंतराल प्रतिच्छेदित होते हैं, अन्यथा 0।\n\nउदाहरण:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "hu": "Meghatározza, hogy két zárt intervallum metszi-e egymást.\n\n@param a Az első zárt intervallum [a,b] alsó határa.\n@param b Az első zárt intervallum [a,b] felső határa.\n@param c A második zárt intervallum [c,d] alsó határa.\n@param d A második zárt intervallum [c,d] felső határa.\n\n@return 1, ha az intervallumok metszik egymást, különben 0.\n\nPéldák:\nare_intervals_intersecting(1, 1, 1, 2) visszaadja 1\nare_intervals_intersecting(3, 5, 2, 6) visszaadja 1\nare_intervals_intersecting(3, 5, 4, 7) visszaadja 1\nare_intervals_intersecting(3, 5, 6, 7) visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9709507040344096",
      "hy": "0.9704871007250743",
      "bn": "0.9684261118914562",
      "bg": "0.9991939579137604",
      "zh": "0.984650638675148",
      "fr": "1",
      "de": "0.9948205141841343",
      "ha": "0.9709507040344096",
      "hi": "0.9552261299197827",
      "hu": "0.9972245376857996"
    }
  },
  {
    "task_id": "CPP/12",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * You are given three integers a, b, c, where two of them are equal, and the\n * third is different from the other two. Your task is to find the value that\n * occurs exactly once.\n *\n * Examples:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Ju jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe i\n * treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që\n * ndodh saktësisht një herë.\n *\n * Shembuj:\n *   extraNumber(0, 0, 1) kthen 1\n *   extraNumber(4, 3, 4) kthen 3\n */\nint extraNumber(int a, int b, int c)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Ձեզ տրված են երեք ամբողջ թվեր a, b, c, որտեղ երկուսը հավասար են, և\n * երրորդը տարբերվում է մյուս երկուսից։ Ձեր խնդիրը գտնել այն արժեքը,\n * որը հանդիպում է միայն մեկ անգամ։\n *\n * Օրինակներ:\n *   extraNumber(0, 0, 1) վերադարձնում է 1\n *   extraNumber(4, 3, 4) վերադարձնում է 3\n */\nint extraNumber(int a, int b, int c)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * আপনাকে তিনটি পূর্ণসংখ্যা দেওয়া হয়েছে a, b, c, যেখানে এদের মধ্যে দুটি সমান, এবং\n * তৃতীয়টি অন্য দুটি থেকে আলাদা। আপনার কাজ হল সেই মানটি খুঁজে বের করা যা\n * ঠিক একবার ঘটে।\n *\n * উদাহরণ:\n *   extraNumber(0, 0, 1) 1 ফেরত দেয়\n *   extraNumber(4, 3, 4) 3 ফেরত দেয়\n */\nint extraNumber(int a, int b, int c)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Дадени са ви три цели числа a, b, c, където две от тях са равни, а\n * третото е различно от другите две. Вашата задача е да намерите стойността,\n * която се среща точно веднъж.\n *\n * Примери:\n *   extraNumber(0, 0, 1) връща 1\n *   extraNumber(4, 3, 4) връща 3\n */\nint extraNumber(int a, int b, int c)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * 给定三个整数 a, b, c，其中两个相等，第三个与其他两个不同。\n * 你的任务是找到只出现一次的值。\n *\n * 示例:\n *   extraNumber(0, 0, 1) 返回 1\n *   extraNumber(4, 3, 4) 返回 3\n */\nint extraNumber(int a, int b, int c)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * On vous donne trois entiers a, b, c, où deux d'entre eux sont égaux, et le\n * troisième est différent des deux autres. Votre tâche est de trouver la valeur qui\n * apparaît exactement une fois.\n *\n * Exemples :\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Sie haben drei ganze Zahlen a, b, c, wobei zwei von ihnen gleich sind und die\n * dritte sich von den anderen beiden unterscheidet. Ihre Aufgabe ist es, den Wert zu finden,\n * der genau einmal vorkommt.\n *\n * Beispiele:\n *   extraNumber(0, 0, 1) gibt 1 zurück\n *   extraNumber(4, 3, 4) gibt 3 zurück\n */\nint extraNumber(int a, int b, int c)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * An ba ku lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, \n * kuma na uku ya bambanta da sauran biyun. Aikin ku shine nemo ƙimar da \n * ta bayyana sau ɗaya kawai.\n *\n * Misalai:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * आपको तीन पूर्णांक a, b, c दिए गए हैं, जहाँ इनमें से दो समान हैं, और\n * तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो\n * केवल एक बार आता है।\n *\n * उदाहरण:\n *   extraNumber(0, 0, 1) 1 लौटाता है\n *   extraNumber(4, 3, 4) 3 लौटाता है\n */\nint extraNumber(int a, int b, int c)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Három egész számot kap, a, b, c, ahol kettő közülük egyenlő, és a\n * harmadik különbözik a másik kettőtől. Az Ön feladata megtalálni azt az értéket,\n * amely pontosan egyszer fordul elő.\n *\n * Példák:\n *   extraNumber(0, 0, 1) visszaadja 1\n *   extraNumber(4, 3, 4) visszaadja 3\n */\nint extraNumber(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.984406124676094",
      "bn": "0.9923751755632138",
      "bg": "0.9971657430930132",
      "zh": "0.960738321623882",
      "fr": "0.9972060650603632",
      "de": "0.9873901488903811",
      "ha": "0.9758050319165213",
      "hi": "0.9807930380450695",
      "hu": "0.9862470310475254"
    },
    "canonical_solution": "{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}",
    "instruction": {
      "en": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简明的自然语言描述（文档字符串）。",
      "fr": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nBa da taƙaitaccen bayani a cikin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8439591507450884",
      "bg": "0.9881575205401952",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9246877019875739",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n\n    \n    return 0;\n}",
    "entry_point": "extraNumber",
    "signature": "int extraNumber(int a, int b, int c)",
    "docstring": {
      "en": "You are given three integers a, b, c, where two of them are equal, and the third is different from the other two. Your task is to find the value that occurs exactly once.\n\nExamples:\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3\n",
      "sq": "Ju jepen tre numra të plotë a, b, c, ku dy prej tyre janë të barabartë, dhe i treti është i ndryshëm nga dy të tjerët. Detyra juaj është të gjeni vlerën që ndodh saktësisht një herë.\n\nShembuj:\n  extraNumber(0, 0, 1) kthen 1\n  extraNumber(4, 3, 4) kthen 3",
      "hy": "Դուք տրված եք երեք ամբողջ թվերով՝ a, b, c, որտեղ երկուսը հավասար են, և երրորդը տարբերվում է մյուս երկուսից։ Ձեր խնդիրն է գտնել այն արժեքը, որը հանդիպում է ճիշտ մեկ անգամ։\n\nՕրինակներ:\n  extraNumber(0, 0, 1) վերադարձնում է 1\n  extraNumber(4, 3, 4) վերադարձնում է 3",
      "bn": "আপনাকে তিনটি পূর্ণসংখ্যা দেওয়া হয়েছে a, b, c, যেখানে তাদের মধ্যে দুটি সমান এবং তৃতীয়টি অন্য দুটি থেকে আলাদা। আপনার কাজ হল সেই মানটি খুঁজে বের করা যা ঠিক একবার ঘটে।\n\nউদাহরণ:\n  extraNumber(0, 0, 1) 1 ফেরত দেয়\n  extraNumber(4, 3, 4) 3 ফেরত দেয়",
      "bg": "Дадени са ви три цели числа a, b, c, където две от тях са равни, а третото е различно от другите две. Вашата задача е да намерите стойността, която се среща точно веднъж.\n\nПримери:\n  extraNumber(0, 0, 1) връща 1\n  extraNumber(4, 3, 4) връща 3",
      "zh": "你有三个整数 a, b, c，其中两个是相等的，第三个与其他两个不同。你的任务是找到那个只出现一次的值。\n\n示例：\n  extraNumber(0, 0, 1) 返回 1\n  extraNumber(4, 3, 4) 返回 3",
      "fr": "Vous disposez de trois entiers a, b, c, dont deux sont égaux, et le troisième est différent des deux autres. Votre tâche est de trouver la valeur qui apparaît exactement une fois.\n\nExemples :\n  extraNumber(0, 0, 1) renvoie 1\n  extraNumber(4, 3, 4) renvoie 3",
      "de": "Du hast drei ganze Zahlen a, b, c, wobei zwei von ihnen gleich sind und die dritte sich von den anderen beiden unterscheidet. Deine Aufgabe ist es, den Wert zu finden, der genau einmal vorkommt.\n\nBeispiele:\n  extraNumber(0, 0, 1) gibt 1 zurück\n  extraNumber(4, 3, 4) gibt 3 zurück",
      "ha": "An ba ku lambobi guda uku a, b, c, inda biyu daga cikinsu suna daidai, kuma na uku ya bambanta da sauran biyun. Aikin ku shi ne gano darajar da ta bayyana sau daya kawai.\n\nMisalai:\n  extraNumber(0, 0, 1) yana dawowa 1\n  extraNumber(4, 3, 4) yana dawowa 3",
      "hi": "आपको तीन पूर्णांक a, b, c दिए गए हैं, जिनमें से दो समान हैं, और तीसरा अन्य दो से भिन्न है। आपका कार्य उस मान को खोजना है जो केवल एक बार आता है।\n\nउदाहरण:\n  extraNumber(0, 0, 1) 1 लौटाता है\n  extraNumber(4, 3, 4) 3 लौटाता है",
      "hu": "Három egész számot kap, a, b, c, ahol kettő közülük egyenlő, és a harmadik különbözik a másik kettőtől. Az Ön feladata megtalálni azt az értéket, amely pontosan egyszer fordul elő.\n\nPéldák:\n  extraNumber(0, 0, 1) visszatér 1\n  extraNumber(4, 3, 4) visszatér 3"
    },
    "docstring_bertscore": {
      "sq": "0.9957483166939483",
      "hy": "0.9831742190529157",
      "bn": "0.21519567273105503",
      "bg": "0.9770560060562791",
      "zh": "0.9567017550204909",
      "fr": "0.9702477511159272",
      "de": "0.9787664122673705",
      "ha": "0.962070932850245",
      "hi": "0.964262620474584",
      "hu": "0.9869251551683785"
    }
  },
  {
    "task_id": "CPP/13",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n *\n * Parameters:\n * - subject_scores (list): A list containing the scores for each subject.\n *\n * Returns:\n *   int: The total score obtained by summing up the scores in all subjects.\n *\n * Examples:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n *\n * Parametrat:\n * - subject_scores (listë): Një listë që përmban pikët për secilën lëndë.\n *\n * Kthen:\n *   int: Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n *\n * Shembuj:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացած միավորների հիման վրա:\n *\n * Պարամետրեր:\n * - subject_scores (list): Ցանկ, որը պարունակում է յուրաքանչյուր առարկայի միավորները:\n *\n * Վերադարձնում է:\n *   int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n *\n * Օրինակներ:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * বিভিন্ন বিষয়ে স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n *\n * প্যারামিটার:\n * - subject_scores (list): প্রতিটি বিষয়ের স্কোর ধারণকারী একটি তালিকা।\n *\n * রিটার্নস:\n *   int: সমস্ত বিষয়ে স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n *\n * উদাহরণ:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Изчислява общия резултат за ученик въз основа на резултатите по различни предмети.\n *\n * Параметри:\n * - subject_scores (list): Списък, съдържащ резултатите за всеки предмет.\n *\n * Връща:\n *   int: Общият резултат, получен чрез събиране на резултатите по всички предмети.\n *\n * Примери:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算学生在不同科目中的总分。\n *\n * 参数:\n * - subject_scores (list): 包含每个科目分数的列表。\n *\n * 返回:\n *   int: 通过将所有科目的分数相加获得的总分。\n *\n * 示例:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n *\n * Paramètres:\n * - subject_scores (list): Une liste contenant les scores pour chaque matière.\n *\n * Renvoie:\n *   int: Le score total obtenu en additionnant les scores de toutes les matières.\n *\n * Exemples:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Berechnet die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n *\n * Parameter:\n * - subject_scores (list): Eine Liste, die die Punkte für jedes Fach enthält.\n *\n * Rückgabewert:\n *   int: Die Gesamtpunktzahl, die durch das Summieren der Punkte in allen Fächern erzielt wird.\n *\n * Beispiele:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Lissafa jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n *\n * Sigogi:\n * - subject_scores (list): Jerin da ke ɗauke da maki na kowane fanni.\n *\n * Komawa:\n *   int: Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n *\n * Misalai:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल अंक की गणना करें।\n *\n * पैरामीटर:\n * - subject_scores (list): प्रत्येक विषय के लिए अंक वाली एक सूची।\n *\n * रिटर्न करता है:\n *   int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n *\n * उदाहरण:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n *\n * Paraméterek:\n * - subject_scores (list): Egy lista, amely az egyes tantárgyak pontszámait tartalmazza.\n *\n * Visszatér:\n *   int: Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n *\n * Példák:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"
    },
    "prompt_bertscore": {
      "sq": "0.9917179076323693",
      "hy": "0.988852863016322",
      "bn": "0.9792240566652748",
      "bg": "0.9932654369310121",
      "zh": "0.9694760720856067",
      "fr": "0.9847384333035654",
      "de": "0.9815502170575744",
      "ha": "0.9927462171149869",
      "hi": "0.9668126373063098",
      "hu": "0.9895663433449994"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\n将以下 CPP 代码的功能描述为简洁的自然语言（文档字符串），并使用不超过 500 个字符的中文。",
      "fr": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8634835240489127",
      "bg": "0.8329214591013607",
      "zh": "0.845198008431603",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9134174141676543",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}",
    "entry_point": "calculate_total_score",
    "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n\nParameters:\n- score1 (int): The score for the first subject.\n- score2 (int): The score for the second subject.\n- score3 (int): The score for the third subject.\n- score4 (int): The score for the fourth subject.\n- score5 (int): The score for the fifth subject.\n\nReturns:\n  int: The total score obtained by summing up the scores in all subjects.\n\nExamples:\n  >>> calculate_total_score(100,100,100,100,100)\n  500\n",
      "sq": "Llogaritni rezultatin total për një student bazuar në rezultatet në lëndë të ndryshme.\n\nParametrat:\n- score1 (int): Rezultati për lëndën e parë.\n- score2 (int): Rezultati për lëndën e dytë.\n- score3 (int): Rezultati për lëndën e tretë.\n- score4 (int): Rezultati për lëndën e katërt.\n- score5 (int): Rezultati për lëndën e pestë.\n\nKthen:\n  int: Rezultati total i marrë duke mbledhur rezultatet në të gjitha lëndët.\n\nShembuj:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hy": "Հաշվարկել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա:\n\nՊարամետրեր:\n- score1 (int): Առաջին առարկայի միավորը:\n- score2 (int): Երկրորդ առարկայի միավորը:\n- score3 (int): Երրորդ առարկայի միավորը:\n- score4 (int): Չորրորդ առարկայի միավորը:\n- score5 (int): Հինգերորդ առարկայի միավորը:\n\nՎերադարձնում է:\n  int: Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով:\n\nՕրինակներ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "bn": "একজন শিক্ষার্থীর বিভিন্ন বিষয়ে প্রাপ্ত নম্বরের ভিত্তিতে মোট স্কোর গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- score1 (int): প্রথম বিষয়ের নম্বর।\n- score2 (int): দ্বিতীয় বিষয়ের নম্বর।\n- score3 (int): তৃতীয় বিষয়ের নম্বর।\n- score4 (int): চতুর্থ বিষয়ের নম্বর।\n- score5 (int): পঞ্চম বিষয়ের নম্বর।\n\nফেরত দেয়:\n  int: সব বিষয়ের নম্বর যোগ করে প্রাপ্ত মোট স্কোর।\n\nউদাহরণ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "bg": "Изчислява общия резултат за студент въз основа на резултатите по различни предмети.\n\nПараметри:\n- score1 (int): Резултатът за първия предмет.\n- score2 (int): Резултатът за втория предмет.\n- score3 (int): Резултатът за третия предмет.\n- score4 (int): Резултатът за четвъртия предмет.\n- score5 (int): Резултатът за петия предмет.\n\nВръща:\n  int: Общият резултат, получен чрез сумиране на резултатите по всички предмети.\n\nПримери:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "zh": "计算学生在不同科目中的总分。\n\n参数：\n- score1 (int): 第一科目的分数。\n- score2 (int): 第二科目的分数。\n- score3 (int): 第三科目的分数。\n- score4 (int): 第四科目的分数。\n- score5 (int): 第五科目的分数。\n\n返回：\n  int: 通过将所有科目的分数相加得到的总分。\n\n示例：\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n\nParamètres:\n- score1 (int): Le score pour la première matière.\n- score2 (int): Le score pour la deuxième matière.\n- score3 (int): Le score pour la troisième matière.\n- score4 (int): Le score pour la quatrième matière.\n- score5 (int): Le score pour la cinquième matière.\n\nRenvoie:\n  int: Le score total obtenu en additionnant les scores dans toutes les matières.\n\nExemples:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punkten in verschiedenen Fächern.\n\nParameter:\n- score1 (int): Die Punktzahl für das erste Fach.\n- score2 (int): Die Punktzahl für das zweite Fach.\n- score3 (int): Die Punktzahl für das dritte Fach.\n- score4 (int): Die Punktzahl für das vierte Fach.\n- score5 (int): Die Punktzahl für das fünfte Fach.\n\nRückgabewert:\n  int: Die Gesamtpunktzahl, die durch das Aufsummieren der Punkte in allen Fächern erzielt wird.\n\nBeispiele:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "ha": "Ƙididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n\nSigogi:\n- score1 (int): Makin fanni na farko.\n- score2 (int): Makin fanni na biyu.\n- score3 (int): Makin fanni na uku.\n- score4 (int): Makin fanni na huɗu.\n- score5 (int): Makin fanni na biyar.\n\nDawowa:\n  int: Jimillar maki da aka samu ta hanyar tara maki a duk fannoni.\n\nMisalai:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hi": "विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n\nमापदंड:\n- score1 (int): पहले विषय के लिए अंक।\n- score2 (int): दूसरे विषय के लिए अंक।\n- score3 (int): तीसरे विषय के लिए अंक।\n- score4 (int): चौथे विषय के लिए अंक।\n- score5 (int): पांचवें विषय के लिए अंक।\n\nवापसी:\n  int: सभी विषयों में अंकों को जोड़कर प्राप्त कुल अंक।\n\nउदाहरण:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n\nParaméterek:\n- score1 (int): Az első tantárgy pontszáma.\n- score2 (int): A második tantárgy pontszáma.\n- score3 (int): A harmadik tantárgy pontszáma.\n- score4 (int): A negyedik tantárgy pontszáma.\n- score5 (int): Az ötödik tantárgy pontszáma.\n\nVisszatér:\n  int: Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n\nPéldák:\n  >>> calculate_total_score(100,100,100,100,100)\n  500"
    },
    "docstring_bertscore": {
      "sq": "0.9749219212424401",
      "hy": "0.9830548421939137",
      "bn": "0.9571198719725694",
      "bg": "0.9936920949894751",
      "zh": "0.9557288634141821",
      "fr": "0.9884798351607386",
      "de": "0.9859858320964645",
      "ha": "0.9749219212424401",
      "hi": "0.9693606678342254",
      "hu": "0.968071953922071"
    }
  },
  {
    "task_id": "CPP/14",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "sq": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale \nqë përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\nKthen:\nint: Rezultati i secilës varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hy": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nՎերծանել թվերի շարք՝ բացահայտելու օրինաչափությունը և հասկանալու իրական արժեքները,\nորոնք ներկայացնում է յուրաքանչյուր թվանշան:\n\nՀաշվարկային հավասարումները տրված են հղման համար.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Հաստատուն սիմվոլների զանգված (C-ոճի տող), որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "bn": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nসংখ্যার একটি সিরিজ ডিকোড করুন যাতে প্যাটার্নটি প্রকাশ পায় এবং প্রতিটি অঙ্ক আসলে কোন মানটি উপস্থাপন করে তা বোঝা যায়।\n\nতুলনার জন্য প্রদত্ত সমীকরণ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটার:\n- data_str: একটি ধ্রুবক চরিত্রের অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nরিটার্নস:\nint: প্রতিটি ডেটা স্ট্রিং এর ফলাফল যা সমীকরণের ডান দিকের সাথে মিলে যায়।\n\nউদাহরণ ব্যবহার:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "bg": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nДекодирайте поредица от числа, за да разкриете модела и да разберете действителните стойности,\nкоито всяка цифра представлява.\n\nПредоставени уравнения за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (низ в стил C), представляващ поредица от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "zh": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\n解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "fr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles \nque chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "de": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, \ndie jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenfolge, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "ha": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nFassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nAn bayar da ƙa'idodi don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Tsayayyen jerin haruffa (salo na C) wanda ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nDawowa:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na ƙa'idar.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए समीकरण प्रदान किए गए हैं:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर कैरेक्टर ऐरे (C-शैली की स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करता है। लंबाई 100 से अधिक नहीं होती।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर संबंधित होता है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "hu": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n\nAz egyenletek referenciaként:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy konstans karaktertömb (C-stílusú string), amely egy számsorozatot képvisel. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adatstringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"
    },
    "prompt_bertscore": {
      "sq": "0.9790671386642573",
      "hy": "0.9626251116133323",
      "bn": "0.9684747763348098",
      "bg": "0.9744738111028255",
      "zh": "0.9751124077778527",
      "fr": "0.9840754050916709",
      "de": "0.9561928639842795",
      "ha": "0.9374675807033586",
      "hi": "0.9708470189755095",
      "hu": "0.9730863778912968"
    },
    "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\n请用中文为以下CPP代码提供一个简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8634835240489127",
      "bg": "0.9788407625177538",
      "zh": "0.8898046317309889",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "decode_numbers",
    "signature": "int decode_numbers(const char* data_str)",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);",
      "sq": "Dekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n\nEkuacionet e dhëna për referencë:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametrat:\n- data_str: Një varg karakteresh konstant (string në stilin C) që përfaqëson një seri numrash. Gjatësia nuk tejkalon 100.\n\nKthen:\nint: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\nShembull përdorimi:\nassert(decode_numbers(\"0000\") == 4);",
      "hy": "Թվերի շարք ապակոդավորել՝ բացահայտելու օրինաչափությունը և հասկանալու, թե իրականում ինչ արժեքներ են ներկայացնում յուրաքանչյուր թվանշան։\n\nՀաշվարկները տրված են հղման համար.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nՊարամետրեր:\n- data_str: Հաստատուն սիմվոլների զանգված (C ոճի տող), որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\nՎերադարձնում է:\nint: Յուրաքանչյուր տվյալների տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\nՕրինակ օգտագործում:\nassert(decode_numbers(\"0000\") == 4);",
      "bn": "সংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করতে এবং প্রতিটি অঙ্কের প্রকৃত মানগুলি বোঝার জন্য।\n\nতুলনার জন্য প্রদত্ত সমীকরণ:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- data_str: একটি ধ্রুব চরিত্রের অ্যারে (সি-স্টাইল স্ট্রিং) যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nint: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডানপাশের সাথে মিলে যায়।\n\nব্যবহারের উদাহরণ:\nassert(decode_numbers(\"0000\") == 4);",
      "bg": "Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n\nУравнения, предоставени за справка:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nПараметри:\n- data_str: Константен масив от символи (стринг в стил C), представляващ серия от числа. Дължината не надвишава 100.\n\nВръща:\nint: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\nПример за използване:\nassert(decode_numbers(\"0000\") == 4);",
      "zh": "解码一系列数字以揭示模式并理解每个数字代表的实际值。\n\n提供的方程用于参考：\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- data_str: 一个常量字符数组（C风格字符串），表示一系列数字。长度不超过100。\n\n返回：\nint: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nassert(decode_numbers(\"0000\") == 4);",
      "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n\nÉquations fournies à titre de référence :\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- data_str : Un tableau de caractères constant (chaîne de style C) représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nint : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nassert(decode_numbers(\"0000\") == 4);",
      "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n\nGleichungen zur Referenz:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- data_str: Ein konstantes Zeichenarray (C-Style-String), das eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nint: Das Ergebnis jeder Datenzeichenkette, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nassert(decode_numbers(\"0000\") == 4);",
      "ha": "Fassara jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar da kowace lamba ke wakilta.\n\nLissafin da aka bayar don tunani:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- data_str: Wata madaidaiciyar jerin haruffa (C-style string) da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n\nAbubuwan da ake dawowa da su:\nint: Sakamakon kowanne jerin bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nassert(decode_numbers(\"0000\") == 4);",
      "hi": "संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n\nसंदर्भ के लिए समीकरण दिए गए हैं:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- data_str: एक स्थिर वर्ण सरणी (C-शैली स्ट्रिंग) जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nवापसी:\nint: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हिस्से से मेल खाता है।\n\nउदाहरण उपयोग:\nassert(decode_numbers(\"0000\") == 4);",
      "hu": "Dekódoljon egy számok sorozatát, hogy felfedje a mintát, és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n\nAz egyenletek referenciaként szolgálnak:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParaméterek:\n- data_str: Egy állandó karaktertömb (C-stílusú string), amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n\nVisszatérési érték:\nint: Az egyes adat stringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\nPélda használat:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "docstring_bertscore": {
      "sq": "0.9691731607545284",
      "hy": "0.9430995465272218",
      "bn": "0.9584181201430134",
      "bg": "0.9723214522939314",
      "zh": "0.9623188235657766",
      "fr": "0.9877550329003423",
      "de": "0.9797812148840777",
      "ha": "0.9409100438370742",
      "hi": "0.9830375613507637",
      "hu": "0.9731908574717212"
    }
  },
  {
    "task_id": "CPP/15",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *\n * Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "sq": "#include <cassert>\n#include <iostream>\n/**\n * Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra,\n * duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\n * duhet të kenë ngjyra të ndryshme.\n * \n * @param n Numri i katrorëve.\n * @param m Numri i ngjyrave.\n * @return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n *         Rezultati është modulo 1000003.\n *\n * Shembuj:\n * count_coloring_methods(1,1) kthen 1\n * count_coloring_methods(2,2) kthen 2\n */\nint count_coloring_methods(int n, int m)",
      "hy": "#include <cassert>\n#include <iostream>\n/**\n * Հաշվում է քառակուսիների n քանակի տարբեր գունավորման մեթոդների քանակը m գույներով,\n * հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\n * պետք է ունենան տարբեր գույներ։\n * \n * @param n Քառակուսիների քանակը։\n * @param m Գույների քանակը։\n * @return Տարբեր գունավորման մեթոդների քանակը, որը բավարարում է նշված պայմաններին։\n *         Արդյունքը մոդուլո 1000003։\n *\n * Օրինակներ:\n * count_coloring_methods(1,1) վերադարձնում է 1\n * count_coloring_methods(2,2) վերադարձնում է 2\n */\nint count_coloring_methods(int n, int m)",
      "bn": "#include <cassert>\n#include <iostream>\n/**\n * nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\n * শর্তটি বিবেচনা করে যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n * \n * @param n বর্গক্ষেত্রের সংখ্যা।\n * @param m রঙের সংখ্যা।\n * @return নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা।\n *         ফলাফলটি 1000003 দ্বারা মডুলো।\n *\n * উদাহরণ:\n * count_coloring_methods(1,1) 1 রিটার্ন করে\n * count_coloring_methods(2,2) 2 রিটার্ন করে\n */\nint count_coloring_methods(int n, int m)",
      "bg": "#include <cassert>\n#include <iostream>\n/**\n * Брои броя на различните методи за оцветяване на n квадрата с m цвята,\n * като се има предвид изискването съседните квадрати и първият/последният квадрат\n * да имат различни цветове.\n * \n * @param n Броят на квадратите.\n * @param m Броят на цветовете.\n * @return Броят на различните методи за оцветяване, които удовлетворяват посочените условия.\n *         Резултатът е модуло 1000003.\n *\n * Примери:\n * count_coloring_methods(1,1) връща 1\n * count_coloring_methods(2,2) връща 2\n */\nint count_coloring_methods(int n, int m)",
      "zh": "#include <cassert>\n#include <iostream>\n/**\n * 计算使用 m 种颜色为 n 个方块着色的不同方法数，\n * 考虑到相邻方块以及第一个/最后一个方块必须有不同的颜色。\n * \n * @param n 方块的数量。\n * @param m 颜色的数量。\n * @return 满足指定条件的不同着色方法的数量。\n *         结果对 1000003 取模。\n *\n * 例子:\n * count_coloring_methods(1,1) 返回 1\n * count_coloring_methods(2,2) 返回 2\n */\nint count_coloring_methods(int n, int m)",
      "fr": "#include <cassert>\n#include <iostream>\n/**\n * Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs,\n * en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\n * doivent avoir des couleurs différentes.\n * \n * @param n Le nombre de carrés.\n * @param m Le nombre de couleurs.\n * @return Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées.\n *         Le résultat est modulo 1000003.\n *\n * Exemples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "de": "#include <cassert>\n#include <iostream>\n/**\n * Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben,\n * unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\n * unterschiedliche Farben haben müssen.\n * \n * @param n Die Anzahl der Quadrate.\n * @param m Die Anzahl der Farben.\n * @return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n *         Das Ergebnis ist modulo 1000003.\n *\n * Beispiele:\n * count_coloring_methods(1,1) gibt 1 zurück\n * count_coloring_methods(2,2) gibt 2 zurück\n */\nint count_coloring_methods(int n, int m)",
      "ha": "#include <cassert>\n#include <iostream>\n/**\n * Yana ƙididdige adadin hanyoyin launi daban-daban don murabba'i n tare da launuka m,\n * la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe\n * dole ne su sami launuka daban-daban.\n * \n * @param n Adadin murabba'ai.\n * @param m Adadin launuka.\n * @return Adadin hanyoyin launi daban-daban da suka cika sharuɗɗan da aka fayyace.\n *         Sakamakon yana cikin modulo 1000003.\n *\n * Misalai:\n * count_coloring_methods(1,1) yana dawowa 1\n * count_coloring_methods(2,2) yana dawowa 2\n */\nint count_coloring_methods(int n, int m)",
      "hi": "#include <cassert>\n#include <iostream>\n/**\n * n वर्गों के लिए m रंगों के विभिन्न रंगने के तरीकों की संख्या गिनता है,\n * इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्ग और पहले/अंतिम वर्ग\n * के रंग अलग-अलग होने चाहिए।\n * \n * @param n वर्गों की संख्या।\n * @param m रंगों की संख्या।\n * @return निर्दिष्ट शर्तों को संतुष्ट करने वाले विभिन्न रंगने के तरीकों की संख्या।\n *         परिणाम 1000003 के मापांक में है।\n *\n * उदाहरण:\n * count_coloring_methods(1,1) 1 लौटाता है\n * count_coloring_methods(2,2) 2 लौटाता है\n */\nint count_coloring_methods(int n, int m)",
      "hu": "#include <cassert>\n#include <iostream>\n/**\n * Megszámolja az n négyzet m színnel történő különböző színezési módszereit,\n * figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\n * különböző színűek legyenek.\n * \n * @param n A négyzetek száma.\n * @param m A színek száma.\n * @return A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\n *         Az eredmény modulo 1000003.\n *\n * Példák:\n * count_coloring_methods(1,1) visszaadja 1\n * count_coloring_methods(2,2) visszaadja 2\n */\nint count_coloring_methods(int n, int m)"
    },
    "prompt_bertscore": {
      "sq": "0.9845717824138771",
      "hy": "0.9809489628941818",
      "bn": "0.9558005689817356",
      "bg": "0.9864230175651223",
      "zh": "0.9507200010956253",
      "fr": "1",
      "de": "0.9911680987376648",
      "ha": "0.9738745432432432",
      "hi": "0.9775335134922869",
      "hu": "0.9762046762431635"
    },
    "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}",
    "instruction": {
      "en": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nՏվեք կարճ բնութագիր (docstring) CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9008792686255891",
      "bn": "0.8439591507450884",
      "bg": "0.8365011292951701",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}",
    "entry_point": "count_coloring_methods",
    "signature": "int count_coloring_methods(int n, int m)",
    "docstring": {
      "en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n\n@param n The number of squares.\n@param m The number of colors.\n@return The count of different coloring methods satisfying the specified conditions. The result is modulo 1000003.\n\nExamples:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2\n",
      "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për n katrorë me m ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\n@param n Numri i katrorëve.\n@param m Numri i ngjyrave.\n@return Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n\nShembuj:\ncount_coloring_methods(1,1) kthen 1\ncount_coloring_methods(2,2) kthen 2",
      "hy": "Հաշվում է n քառակուսիների տարբեր գունավորման մեթոդների քանակը m գույներով՝ հաշվի առնելով, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n\n@param n Քառակուսիների քանակը։\n@param m Գույների քանակը։\n@return Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։ Արդյունքը մոդուլո 1000003 է։\n\nՕրինակներ:\ncount_coloring_methods(1,1) վերադարձնում է 1\ncount_coloring_methods(2,2) վերադարձնում է 2",
      "bn": "nটি বর্গক্ষেত্রের জন্য mটি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রের রঙ ভিন্ন হতে হবে।\n\n@param n বর্গক্ষেত্রের সংখ্যা।\n@param m রঙের সংখ্যা।\n@return নির্দিষ্ট শর্তগুলি পূরণকারী বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফলটি 1000003 দ্বারা মডুলো।\n\nউদাহরণসমূহ:\ncount_coloring_methods(1,1) 1 ফেরত দেয়\ncount_coloring_methods(2,2) 2 ফেরত দেয়",
      "bg": "Брои броя на различните методи за оцветяване за n квадрата с m цвята, като се има предвид изискването съседните квадрати и първият/последният квадрат да са с различни цветове.\n\n@param n Броят на квадратите.\n@param m Броят на цветовете.\n@return Броят на различните методи за оцветяване, които удовлетворяват посочените условия. Резултатът е модуло 1000003.\n\nПримери:\ncount_coloring_methods(1,1) връща 1\ncount_coloring_methods(2,2) връща 2",
      "zh": "计算使用 m 种颜色对 n 个方块进行不同着色的方法数，考虑到相邻方块以及首尾方块必须具有不同颜色的要求。\n\n@param n 方块的数量。\n@param m 颜色的数量。\n@return 满足指定条件的不同着色方法的计数。结果取模 1000003。\n\n示例:\ncount_coloring_methods(1,1) 返回 1\ncount_coloring_methods(2,2) 返回 2",
      "fr": "Compte le nombre de méthodes de coloration différentes pour n carrés avec m couleurs, en tenant compte de l'exigence selon laquelle les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\n@param n Le nombre de carrés.\n@param m Le nombre de couleurs.\n@return Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n\nExemples :\ncount_coloring_methods(1,1) renvoie 1\ncount_coloring_methods(2,2) renvoie 2",
      "de": "Zählt die Anzahl der verschiedenen Färbemethoden für n Quadrate mit m Farben, unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate unterschiedliche Farben haben müssen.\n\n@param n Die Anzahl der Quadrate.\n@param m Die Anzahl der Farben.\n@return Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen. Das Ergebnis ist modulo 1000003.\n\nBeispiele:\ncount_coloring_methods(1,1) gibt 1 zurück\ncount_coloring_methods(2,2) gibt 2 zurück",
      "ha": "Yana ƙididdige adadin hanyoyin canza launi daban-daban don murabba'i n tare da launuka m, la'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe dole ne su sami launuka daban.\n\n@param n Yawan murabba'ai.\n@param m Yawan launuka.\n@return Adadin hanyoyin canza launi daban-daban da suka cika yanayin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n\nMisalai:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2",
      "hi": "n वर्गों के लिए m रंगों के साथ विभिन्न रंगाई विधियों की संख्या की गणना करता है, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\n@param n वर्गों की संख्या।\n@param m रंगों की संख्या।\n@return निर्दिष्ट शर्तों को संतुष्ट करने वाली विभिन्न रंगाई विधियों की गणना। परिणाम 1000003 के माड्यूलो में है।\n\nउदाहरण:\ncount_coloring_methods(1,1) 1 लौटाता है\ncount_coloring_methods(2,2) 2 लौटाता है",
      "hu": "Számolja meg az n négyzet különböző színezési módszereinek számát m színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n\n@param n A négyzetek száma.\n@param m A színek száma.\n@return A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek. Az eredmény modulo 1000003.\n\nPéldák:\ncount_coloring_methods(1,1) visszaadja 1\ncount_coloring_methods(2,2) visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9606326502611714",
      "hy": "0.9656500536861127",
      "bn": "0.9758664087042611",
      "bg": "0.9690128660370333",
      "zh": "0.9200923881223317",
      "fr": "1",
      "de": "0.9865630519837519",
      "ha": "0.9741993039162352",
      "hi": "0.9554871302404626",
      "hu": "0.980398160847572"
    }
  },
  {
    "task_id": "CPP/16",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *\n * Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Numëron numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n *\n * Parametrat:\n * - n (int): Numri i hedhjeve të monedhës.\n *\n * Kthen:\n * - unsigned long long: Numri i sekuencave të vlefshme.\n *\n * Shembuj:\n *   count_valid_coin_toss_sequences(1) kthen 2\n *   count_valid_coin_toss_sequences(2) kthen 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների մեջ չկան հաջորդական գլուխներ:\n *\n * Պարամետրեր:\n * - n (int): Մետաղադրամի նետումների քանակը:\n *\n * Վերադարձնում է:\n * - unsigned long long: Վավեր հաջորդականությունների քանակը:\n *\n * Օրինակներ:\n *   count_valid_coin_toss_sequences(1) վերադարձնում է 2\n *   count_valid_coin_toss_sequences(2) վերադարձնում է 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n টি ছোঁড়ায় কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n *\n * প্যারামিটার:\n * - n (int): কয়েন টসের সংখ্যা।\n *\n * রিটার্নস:\n * - unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n *\n * উদাহরণ:\n *   count_valid_coin_toss_sequences(1) রিটার্ন করে 2\n *   count_valid_coin_toss_sequences(2) রিটার্ন করে 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Брои броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n *\n * Параметри:\n * - n (int): Броят на хвърлянията на монетата.\n *\n * Връща:\n * - unsigned long long: Броят на валидните последователности.\n *\n * Примери:\n *   count_valid_coin_toss_sequences(1) връща 2\n *   count_valid_coin_toss_sequences(2) връща 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算在n次投掷中没有连续正面的有效投掷序列的数量。\n *\n * 参数:\n * - n (int): 投掷硬币的次数。\n *\n * 返回:\n * - unsigned long long: 有效序列的数量。\n *\n * 示例:\n *   count_valid_coin_toss_sequences(1) 返回 2\n *   count_valid_coin_toss_sequences(2) 返回 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Compter le nombre de séquences de lancers de pièces valides sans faces consécutives dans n lancers.\n *\n * Paramètres:\n * - n (int): Le nombre de lancers de pièces.\n *\n * Renvoie:\n * - unsigned long long: Le nombre de séquences valides.\n *\n * Exemples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Zählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n *\n * Parameter:\n * - n (int): Die Anzahl der Münzwürfe.\n *\n * Rückgabe:\n * - unsigned long long: Die Anzahl der gültigen Sequenzen.\n *\n * Beispiele:\n *   count_valid_coin_toss_sequences(1) gibt 2 zurück\n *   count_valid_coin_toss_sequences(2) gibt 3 zurück\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ƙididdige adadin sahihan jeri na jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n *\n * Sigogi:\n * - n (int): Adadin jefa tsabar kudi.\n *\n * Komawa:\n * - unsigned long long: Adadin jerin sahihan.\n *\n * Misalai:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * n उछालों में कोई लगातार हेड्स नहीं होने वाले वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n *\n * पैरामीटर्स:\n * - n (int): सिक्का उछालों की संख्या।\n *\n * रिटर्न्स:\n * - unsigned long long: वैध अनुक्रमों की गिनती।\n *\n * उदाहरण:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számolja meg az érvényes pénzfeldobás sorozatok számát, ahol nincs két egymást követő fej n dobás esetén.\n *\n * Paraméterek:\n * - n (int): A pénzfeldobások száma.\n *\n * Visszatérési érték:\n * - unsigned long long: Az érvényes sorozatok száma.\n *\n * Példák:\n *   count_valid_coin_toss_sequences(1) visszaadja 2\n *   count_valid_coin_toss_sequences(2) visszaadja 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9872423678868912",
      "hy": "0.9798823177480245",
      "bn": "0.9899886315350795",
      "bg": "0.9932666287132983",
      "zh": "0.9771644582443241",
      "fr": "0.9940887598604017",
      "de": "0.9932666287132983",
      "ha": "0.9680530840358728",
      "hi": "0.9917614076858159",
      "hu": "0.9778620481425186"
    },
    "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "en": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\n将以下 CPP 代码的功能描述为简洁的自然语言（文档字符串），使用不超过 500 个字符的中文。",
      "fr": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar CPP a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9232384947275433",
      "bn": "0.8664315961642326",
      "bg": "0.8329214591013607",
      "zh": "0.845198008431603",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9007126177359008",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_valid_coin_toss_sequences",
    "signature": "unsigned long long count_valid_coin_toss_sequences(int n)",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n- unsigned long long: The count of valid sequences.\n\nExamples:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3\n",
      "sq": "Numëroni numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka të njëpasnjëshme në n hedhje.\n\nParametrat:\n- n (int): Numri i hedhjeve të monedhës.\n\nKthen:\n- unsigned long long: Numri i sekuencave të vlefshme.\n\nShembuj:\n  count_valid_coin_toss_sequences(1) kthen 2\n  count_valid_coin_toss_sequences(2) kthen 3",
      "hy": "Հաշվել վավեր մետաղադրամի նետման հաջորդականությունների քանակը՝ առանց հաջորդական գլուխների n նետման դեպքում:\n\nՊարամետրեր:\n- n (int): Նետումների քանակը:\n\nՎերադարձնում է:\n- unsigned long long: Վավեր հաջորդականությունների քանակը:\n\nՕրինակներ:\n  count_valid_coin_toss_sequences(1) վերադարձնում է 2\n  count_valid_coin_toss_sequences(2) վերադարձնում է 3",
      "bn": "n টসের মধ্যে কোন পরপর হেড না থাকা বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- n (int): কয়েন টসের সংখ্যা।\n\nফেরত দেয়:\n- unsigned long long: বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\n  count_valid_coin_toss_sequences(1) ফেরত দেয় 2\n  count_valid_coin_toss_sequences(2) ফেরত দেয় 3",
      "bg": "Бройте броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\nПараметри:\n- n (int): Броят на хвърлянията на монетата.\n\nВръща:\n- unsigned long long: Броят на валидните последователности.\n\nПримери:\n  count_valid_coin_toss_sequences(1) връща 2\n  count_valid_coin_toss_sequences(2) връща 3",
      "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n\n参数：\n- n (int): 硬币投掷的次数。\n\n返回：\n- unsigned long long: 有效序列的数量。\n\n示例：\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "fr": "Compter le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n\nParamètres :\n- n (int) : Le nombre de lancers de pièce.\n\nRenvoie :\n- unsigned long long : Le compte des séquences valides.\n\nExemples :\n  count_valid_coin_toss_sequences(1) renvoie 2\n  count_valid_coin_toss_sequences(2) renvoie 3",
      "de": "Zähle die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe bei n Würfen.\n\nParameter:\n- n (int): Die Anzahl der Münzwürfe.\n\nGibt zurück:\n- unsigned long long: Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\n  count_valid_coin_toss_sequences(1) gibt 2 zurück\n  count_valid_coin_toss_sequences(2) gibt 3 zurück",
      "ha": "Ƙirga adadin jerin jefa tsabar kudi masu inganci tare da babu kawunan da ke jere a cikin jefa tsabar kudi n.\n\nSigogi:\n- n (int): Yawan jefa tsabar kudi.\n\nDawowa:\n- unsigned long long: Adadin sahihan jerin.\n\nMisalai:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "hi": "n उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\nपैरामीटर्स:\n- n (int): सिक्का उछालों की संख्या।\n\nवापसी:\n- unsigned long long: वैध अनुक्रमों की गिनती।\n\nउदाहरण:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "hu": "Számolja meg az érvényes pénzfeldobási sorozatok számát, ahol nincs egymást követő fej n dobás esetén.\n\nParaméterek:\n- n (int): A pénzfeldobások száma.\n\nVisszatér:\n- unsigned long long: Az érvényes sorozatok száma.\n\nPéldák:\n  count_valid_coin_toss_sequences(1) visszaadja 2\n  count_valid_coin_toss_sequences(2) visszaadja 3"
    },
    "docstring_bertscore": {
      "sq": "0.9821238615980031",
      "hy": "0.9668549455774703",
      "bn": "0.9759609567656337",
      "bg": "0.9851025227920024",
      "zh": "0.978462507784387",
      "fr": "0.9953651586889319",
      "de": "0.986523921798688",
      "ha": "0.9844448576003958",
      "hi": "0.9786748436617134",
      "hu": "0.985801304472483"
    }
  },
  {
    "task_id": "CPP/17",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *\n * Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në paraqitjen \n * binare të një numri të plotë jo-negativ.\n *\n * Parametrat:\n * - n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n *\n * Kthen:\n * - int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në paraqitjen \n *        binare të numrit të dhënë.\n *\n * Shembuj:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Գտնել ամենաերկար հաջորդական 1-երի հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի \n * երկբայական ներկայացման մեջ:\n *\n * Պարամետրեր:\n * - n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n *\n * Վերադարձնում է:\n * - int: Տրված ամբողջ թվի երկբայական ներկայացման մեջ ամենաերկար հաջորդական 1-երի \n *        հաջորդականության երկարությունը:\n *\n * Օրինակներ:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজুন।\n *\n * প্যারামিটার:\n * - n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n *\n * রিটার্ন করে:\n * - int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1 এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n *\n * উদাহরণ:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Намерете дължината на най-дългата последователна поредица от 1-ци в двоичното \n * представяне на неотрицателно цяло число.\n *\n * Параметри:\n * - n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n *\n * Връща:\n * - int: Дължината на най-дългата последователна поредица от 1-ци в двоичното \n *        представяне на даденото число.\n *\n * Примери:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 找到非负整数的二进制表示中最长连续1序列的长度。\n *\n * 参数：\n * - n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n *\n * 返回：\n * - int: 给定整数的二进制表示中最长连续1序列的长度。\n *\n * 示例：\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Trouver la longueur de la plus longue séquence consécutive de 1 dans la \n * représentation binaire d'un entier non négatif.\n *\n * Paramètres :\n * - n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n *\n * Renvoie :\n * - int : La longueur de la plus longue séquence consécutive de 1 dans la \n *         représentation binaire de l'entier donné.\n *\n * Exemples :\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n * Binärdarstellung einer nicht-negativen ganzen Zahl.\n *\n * Parameter:\n * - n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n *\n * Rückgabewerte:\n * - int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der \n *        Binärdarstellung der gegebenen Zahl.\n *\n * Beispiele:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Nemo tsawon mafi tsawo jere na 1s a cikin wakilcin binary \n * na lamba mara kyau.\n *\n * Sigogi:\n * - n (unsigned long long): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n *\n * Komawa:\n * - int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary \n *        na lambar da aka bayar.\n *\n * Misalai:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * एक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में लगातार 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n *\n * पैरामीटर:\n * - n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n *\n * लौटाता है:\n * - int: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में लगातार 1s के सबसे लंबे अनुक्रम की लंबाई।\n *\n * उदाहरण:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris \n * ábrázolásában.\n *\n * Paraméterek:\n * - n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n *\n * Visszatérési érték:\n * - int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris \n *        ábrázolásában.\n *\n * Példák:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)"
    },
    "prompt_bertscore": {
      "sq": "0.9803560512067927",
      "hy": "0.9837524320921082",
      "bn": "0.9881542799662224",
      "bg": "0.9931154709933308",
      "zh": "0.9855460644328533",
      "fr": "0.9952159872727747",
      "de": "0.9878324987489459",
      "ha": "0.9692122909395924",
      "hi": "0.9855460644328533",
      "hu": "0.9846744743208722"
    },
    "canonical_solution": "{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}",
    "instruction": {
      "en": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nՏվեք CPP կոդի հակիրճ նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (dokumentációs kommentet) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9267393551932832",
      "bn": "0.8961844409394485",
      "bg": "0.9881575205401952",
      "zh": "0.904821312162758",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.8907656055144356"
    },
    "level": "",
    "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}",
    "entry_point": "find_longest_consecutive_ones_length",
    "signature": "int find_longest_consecutive_ones_length(unsigned long long n)",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n  >>> find_longest_consecutive_ones_length(7)\n  3\n",
      "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (unsigned long long): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n- int: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hy": "Բացահայտեք 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի երկբայնի ներկայացման մեջ:\n\nՊարամետրեր:\n- n (unsigned long long): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n- int: Տրված ամբողջ թվի երկբայնի ներկայացման մեջ 1-երի ամենաերկար հաջորդական հաջորդականության երկարությունը:\n\nՕրինակներ:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ক্রমাগত অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n\nপ্যারামিটারসমূহ:\n- n (unsigned long long): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দেয়:\n- int: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনায় 1-এর দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "bg": "Намерете дължината на най-дългата последователна поредица от 1 в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (unsigned long long): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n- int: Дължината на най-дългата последователна поредица от 1 в двоичното представяне на даденото число.\n\nПримери:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "zh": "找到非负整数的二进制表示中最长连续1序列的长度。\n\n参数:\n- n (unsigned long long): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回:\n- int: 给定整数的二进制表示中最长连续1序列的长度。\n\n示例:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (unsigned long long) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\n- int : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\n  >>> find_longest_consecutive_ones_length(7)\n  3\n",
      "de": "Finden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (unsigned long long): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n- int: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n\nBeispiele:\n  >>> find_longest_consecutive_ones_length(7)\n  3\n",
      "ha": "Nemo tsawon jerin jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (unsigned long long): Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n- int: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hi": "एक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (unsigned long long): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n- int: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "hu": "Keresse meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (unsigned long long): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n- int: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\n  >>> find_longest_consecutive_ones_length(7)\n  3"
    },
    "docstring_bertscore": {
      "sq": "0.9678433303534999",
      "hy": "0.9822150329428981",
      "bn": "0.999999801369619",
      "bg": "0.9892745553152591",
      "zh": "0.9937016292477647",
      "fr": "0.999999801369619",
      "de": "0.9800777700429628",
      "ha": "0.9928858542728545",
      "hi": "0.9954231587601942",
      "hu": "0.9939540884620601"
    }
  },
  {
    "task_id": "CPP/18",
    "prompt": {
      "en": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.\n * Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "sq": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Gjeneron një identifikues unik duke ndërthurur dy fjalë në një model të specifikuar.\n * @param word1 Fjala e parë që do të përdoret në procesin e krijimit të ID-së.\n * @param word2 Fjala e dytë që do të përdoret në procesin e krijimit të ID-së.\n * @return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë,\n *         e kthyer mbrapsht, me karakteret nga fjala e parë.\n * Shembull Përdorimi:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "hy": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Ստեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի ձևով միահյուսելով:\n * @param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n * @param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n * @return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի նիշերը, հակառակ հերթականությամբ,\n *         առաջին բառի նիշերի հետ փոխարինելով:\n * Օրինակ օգտագործում:\n * \n * create_id(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\n * create_id(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "bn": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * একটি অনন্য শনাক্তকারী তৈরি করে দুটি শব্দকে একটি নির্দিষ্ট প্যাটার্নে আন্তঃবিন্যাস করে।\n * @param word1 শনাক্তকারী তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n * @param word2 শনাক্তকারী তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n * @return একটি অনন্য শনাক্তকারী যা দ্বিতীয় শব্দের অক্ষরগুলি, উল্টানো অবস্থায়,\n *         প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে বিন্যাস করে গঠিত।\n * উদাহরণ ব্যবহার:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "bg": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Генерира уникален идентификатор чрез преплитане на две думи в определен модел.\n * @param word1 Първата дума, която ще се използва в процеса на създаване на ID.\n * @param word2 Втората дума, която ще се използва в процеса на създаване на ID.\n * @return Уникален идентификатор, образуван чрез редуване на символи от втората дума,\n *         обърната, със символи от първата дума.\n * Пример за използване:\n * \n * create_id(\"fish\", \"cat\") връща \"ftiasch\"\n * create_id(\"icpc\", \"acm\") връща \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "zh": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * 通过以指定模式交错两个单词来生成唯一标识符。\n * @param word1 在ID创建过程中使用的第一个单词。\n * @param word2 在ID创建过程中使用的第二个单词。\n * @return 一个唯一标识符，由第二个单词的字符反转后与第一个单词的字符交替形成。\n * 示例用法:\n * \n * create_id(\"fish\", \"cat\") 返回 \"ftiasch\"\n * create_id(\"icpc\", \"acm\") 返回 \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "fr": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Génère un identifiant unique en entrelaçant deux mots selon un schéma spécifié.\n * @param word1 Le premier mot à utiliser dans le processus de création de l'ID.\n * @param word2 Le deuxième mot à utiliser dans le processus de création de l'ID.\n * @return Un identifiant unique formé en alternant des caractères du deuxième mot,\n *         inversé, avec des caractères du premier mot.\n * Exemple d'utilisation :\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "de": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generiert eine eindeutige Kennung, indem zwei Wörter in einem bestimmten Muster verflochten werden.\n * @param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n * @param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n * @return Eine eindeutige Kennung, die durch abwechselnde Zeichen des zweiten Wortes,\n *         umgekehrt, mit Zeichen des ersten Wortes gebildet wird.\n * Beispielverwendung:\n * \n * create_id(\"fish\", \"cat\") gibt \"ftiasch\" zurück\n * create_id(\"icpc\", \"acm\") gibt \"imccpac\" zurück\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "ha": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Yana samar da mai ganowa na musamman ta hanyar haɗa kalmomi biyu a cikin tsarin da aka fayyace.\n * @param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n * @param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n * @return Mai ganowa na musamman da aka samar ta hanyar musanya haruffa daga kalma ta biyu,\n *         a juye, tare da haruffa daga kalma ta farko.\n * Misalin Amfani:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "hi": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * दो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n * @param word1 पहचानकर्ता निर्माण प्रक्रिया में उपयोग के लिए पहला शब्द।\n * @param word2 पहचानकर्ता निर्माण प्रक्रिया में उपयोग के लिए दूसरा शब्द।\n * @return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के वर्णों को उल्टा करके,\n *         पहले शब्द के वर्णों के साथ बारी-बारी से बनता है।\n * उदाहरण उपयोग:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "hu": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Egyedi azonosítót generál két szó összefonásával egy meghatározott mintában.\n * @param word1 Az első szó, amelyet az azonosító létrehozásához használunk.\n * @param word2 A második szó, amelyet az azonosító létrehozásához használunk.\n * @return Egy egyedi azonosító, amely a második szó karaktereinek váltakozásával,\n *         fordítva, az első szó karaktereivel van kialakítva.\n * Példa használat:\n * \n * create_id(\"fish\", \"cat\") visszatér \"ftiasch\"\n * create_id(\"icpc\", \"acm\") visszatér \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9563712340664489",
      "bn": "0.9468145305437173",
      "bg": "0.9936781908628026",
      "zh": "0.9628171871917931",
      "fr": "0.9887191847698856",
      "de": "0.9718153420830545",
      "ha": "0.9785650010610011",
      "hi": "0.9636689142656707",
      "hu": "0.9620550424197623"
    },
    "canonical_solution": "{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}",
    "instruction": {
      "en": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nՏվյալ CPP կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.8608929866194557",
      "bn": "0.8448917203840473",
      "bg": "0.9881575205401952",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "create_id",
    "signature": "std::string create_id(const std::string& word1, const std::string& word2)",
    "docstring": {
      "en": "Generates a unique identifier by interweaving two words in a specified pattern.\n@param word1 The first word to be used in the ID creation process.\n@param word2 The second word to be used in the ID creation process.\n@return A unique identifier formed by alternating characters from the second word, reversed, with characters from the first word.\nExample Usage:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"\n\n",
      "sq": "Gjeneron një identifikues unik duke ndërthurur dy fjalë sipas një modeli të specifikuar.\n@param word1 Fjala e parë që do të përdoret në procesin e krijimit të ID-së.\n@param word2 Fjala e dytë që do të përdoret në procesin e krijimit të ID-së.\n@return Një identifikues unik i formuar duke alternuar karakteret nga fjala e dytë, e kthyer mbrapsht, me karakteret nga fjala e parë.\nShembull i Përdorimit:\n\ncreate_id(\"fish\", \"cat\") kthen \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") kthen \"imccpac\"",
      "hy": "Ստեղծում է եզակի նույնացուցիչ՝ երկու բառերը որոշակի նախշով միահյուսելով:\n@param word1 Առաջին բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@param word2 Երկրորդ բառը, որը կօգտագործվի ID ստեղծման գործընթացում:\n@return Եզակի նույնացուցիչ, որը ձևավորվում է երկրորդ բառի, հակադարձված, և առաջին բառի տառերը հերթագայելով:\nՕրինակ օգտագործում:\n\ncreate_id(\"fish\", \"cat\") վերադարձնում է \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") վերադարձնում է \"imccpac\"",
      "bn": "একটি নির্দিষ্ট প্যাটার্নে দুটি শব্দ একত্রিত করে একটি অনন্য শনাক্তকারী তৈরি করে।\n@param word1 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত প্রথম শব্দ।\n@param word2 আইডি তৈরির প্রক্রিয়ায় ব্যবহৃত দ্বিতীয় শব্দ।\n@return দ্বিতীয় শব্দের অক্ষরগুলি, উল্টো করে, প্রথম শব্দের অক্ষরগুলির সাথে পর্যায়ক্রমে মিলিয়ে গঠিত একটি অনন্য শনাক্তকারী।\nব্যবহারের উদাহরণ:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "bg": "Генерира уникален идентификатор чрез преплитане на две думи в определен модел.\n@param word1 Първата дума, която ще се използва в процеса на създаване на идентификатора.\n@param word2 Втората дума, която ще се използва в процеса на създаване на идентификатора.\n@return Уникален идентификатор, образуван чрез редуване на символи от втората дума, обърната, със символи от първата дума.\nПример за използване:\n\ncreate_id(\"fish\", \"cat\") връща \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") връща \"imccpac\"",
      "zh": "生成一个唯一标识符，通过以指定模式交织两个单词来实现。\n@param word1 用于创建ID的第一个单词。\n@param word2 用于创建ID的第二个单词。\n@return 一个唯一标识符，通过从第二个单词反向交替字符与第一个单词的字符形成。\n示例用法：\n\ncreate_id(\"fish\", \"cat\") 返回 \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") 返回 \"imccpac\"",
      "fr": "Génère un identifiant unique en entrelaçant deux mots selon un modèle spécifié.\n@param word1 Le premier mot à utiliser dans le processus de création de l'ID.\n@param word2 Le deuxième mot à utiliser dans le processus de création de l'ID.\n@return Un identifiant unique formé en alternant des caractères du deuxième mot, inversé, avec des caractères du premier mot.\nExemple d'utilisation :\n\ncreate_id(\"fish\", \"cat\") retourne \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") retourne \"imccpac\"",
      "de": "Erzeugt einen eindeutigen Bezeichner, indem zwei Wörter in einem bestimmten Muster miteinander verflochten werden.\n@param word1 Das erste Wort, das im ID-Erstellungsprozess verwendet wird.\n@param word2 Das zweite Wort, das im ID-Erstellungsprozess verwendet wird.\n@return Ein eindeutiger Bezeichner, der durch abwechselnde Zeichen aus dem zweiten Wort, umgekehrt, mit Zeichen aus dem ersten Wort gebildet wird.\nBeispielverwendung:\n\ncreate_id(\"fish\", \"cat\") gibt \"ftiasch\" zurück\ncreate_id(\"icpc\", \"acm\") gibt \"imccpac\" zurück",
      "ha": "Yana haifar da mai gano na musamman ta hanyar haɗa kalmomi biyu a cikin tsari da aka fayyace.\n@param word1 Kalma ta farko da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@param word2 Kalma ta biyu da za a yi amfani da ita a cikin tsarin ƙirƙirar ID.\n@return Mai gano na musamman da aka samar ta hanyar madadin haruffa daga kalma ta biyu, da aka juya, tare da haruffa daga kalma ta farko.\nMisalin Amfani:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "hi": "दो शब्दों को एक निर्दिष्ट पैटर्न में मिलाकर एक अद्वितीय पहचानकर्ता उत्पन्न करता है।\n@param word1 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला पहला शब्द।\n@param word2 आईडी निर्माण प्रक्रिया में उपयोग किए जाने वाला दूसरा शब्द।\n@return एक अद्वितीय पहचानकर्ता जो दूसरे शब्द के अक्षरों को उलट कर, पहले शब्द के अक्षरों के साथ बारी-बारी से बनता है।\nउदाहरण उपयोग:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "hu": "Egyedi azonosítót generál két szó meghatározott mintázat szerinti összefonásával.\n@param word1 Az első szó, amelyet az azonosító létrehozási folyamatában használunk.\n@param word2 A második szó, amelyet az azonosító létrehozási folyamatában használunk.\n@return Egyedi azonosító, amelyet a második szó visszafelé vett karaktereinek és az első szó karaktereinek váltakozásával hozunk létre.\nPélda használat:\n\ncreate_id(\"fish\", \"cat\") visszaadja \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") visszaadja \"imccpac\""
    },
    "docstring_bertscore": {
      "sq": "0.9893567882930075",
      "hy": "0.9585100860094325",
      "bn": "0.9457532484178479",
      "bg": "0.9499026370776668",
      "zh": "0.936740990769533",
      "fr": "0.9677851316518566",
      "de": "0.9648793678076972",
      "ha": "0.9686835368652774",
      "hi": "0.9268356909280852",
      "hu": "0.9509812000466862"
    }
  },
  {
    "task_id": "CPP/19",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of different permutation schemes for a binary string of length n,\n * where the number of '1's is m and the number of '0's is n - m.\n * \n * Parameters:\n * - n (int): Length of the binary string.\n * - m (int): Number of '1's in the binary string.\n * \n * Returns:\n * - int: The total number of different permutation schemes.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Numëron numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\n * ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n * \n * Parametrat:\n * - n (int): Gjatësia e vargut binar.\n * - m (int): Numri i '1'-ve në vargun binar.\n * \n * Kthen:\n * - int: Numri total i skemave të ndryshme të permutimit.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Հաշվել տարբեր փոխատեղման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\n * որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է։\n * \n * Պարամետրեր:\n * - n (int): Երկբայական տողի երկարությունը։\n * - m (int): '1'-երի քանակը երկբայական տողի մեջ։\n * \n * Վերադարձնում է:\n * - int: Տարբեր փոխատեղման սխեմաների ընդհանուր քանակը։\n */\nint count_permutations_of_binary_string(int n, int m)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * একটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\n * যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n * \n * প্যারামিটার:\n * - n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n * - m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n * \n * রিটার্নস:\n * - int: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।\n */\nint count_permutations_of_binary_string(int n, int m)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Пребройте броя на различните схеми на пермутации за двоична низ с дължина n,\n * където броят на '1'-ците е m и броят на '0'-ите е n - m.\n * \n * Параметри:\n * - n (int): Дължина на двоичната низ.\n * - m (int): Брой на '1'-ците в двоичната низ.\n * \n * Връща:\n * - int: Общият брой на различните схеми на пермутации.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 计算长度为 n 的二进制字符串的不同排列方案数量，\n * 其中 '1' 的数量为 m，'0' 的数量为 n - m。\n * \n * 参数:\n * - n (int): 二进制字符串的长度。\n * - m (int): 二进制字符串中 '1' 的数量。\n * \n * 返回:\n * - int: 不同排列方案的总数量。\n */\nint count_permutations_of_binary_string(int n, int m)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Compter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\n * où le nombre de '1' est m et le nombre de '0' est n - m.\n * \n * Paramètres :\n * - n (int) : Longueur de la chaîne binaire.\n * - m (int) : Nombre de '1' dans la chaîne binaire.\n * \n * Renvoie :\n * - int : Le nombre total de différents schémas de permutation.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Zählt die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\n * wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n * \n * Parameter:\n * - n (int): Länge des Binärstrings.\n * - m (int): Anzahl der '1's im Binärstring.\n * \n * Rückgabewert:\n * - int: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ƙirga yawan tsarin permutation daban-daban don kirtani na binary mai tsawon n,\n * inda adadin '1's shine m kuma adadin '0's shine n - m.\n * \n * Sigogi:\n * - n (int): Tsawon kirtani na binary.\n * - m (int): Adadin '1's a cikin kirtani na binary.\n * \n * Komawa:\n * - int: Jimillar yawan tsarin permutation daban-daban.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * एक बाइनरी स्ट्रिंग की विभिन्न क्रमचय योजनाओं की संख्या गिनें जिसकी लंबाई n है,\n * जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n * \n * पैरामीटर्स:\n * - n (int): बाइनरी स्ट्रिंग की लंबाई।\n * - m (int): बाइनरी स्ट्रिंग में '1's की संख्या।\n * \n * रिटर्न करता है:\n * - int: विभिन्न क्रमचय योजनाओं की कुल संख्या।\n */\nint count_permutations_of_binary_string(int n, int m)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén,\n * ahol az '1'-ek száma m és a '0'-k száma n - m.\n * \n * Paraméterek:\n * - n (int): A bináris karakterlánc hossza.\n * - m (int): Az '1'-ek száma a bináris karakterláncban.\n * \n * Visszatérési érték:\n * - int: A különböző permutációs sémák összes száma.\n */\nint count_permutations_of_binary_string(int n, int m)"
    },
    "prompt_bertscore": {
      "sq": "0.9949629321673362",
      "hy": "0.9893210348244214",
      "bn": "0.9975141407813484",
      "bg": "1",
      "zh": "0.9784992544048785",
      "fr": "0.9907583242615897",
      "de": "0.9916426267179571",
      "ha": "0.9856169754788827",
      "hi": "0.9881413689914551",
      "hu": "0.9891682880614054"
    },
    "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}",
    "instruction": {
      "en": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\n请用中文为以下CPP代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.963562249751055",
      "bn": "0.8448917203840473",
      "bg": "0.8329214591013607",
      "zh": "0.8898046317309889",
      "fr": "0.9126910228642098",
      "de": "0.9255146002638222",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.9320314644351958"
    },
    "level": "",
    "test": "int main() {\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}",
    "entry_point": "count_permutations_of_binary_string",
    "signature": "int count_permutations_of_binary_string(int n, int m)",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\n- int: The total number of different permutation schemes.",
      "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (int): Gjatësia e vargut binar.\n- m (int): Numri i '1'-ve në vargun binar.\n\nKthen:\n- int: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Հաշվել տարբեր փոխարկման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (int): Երկբայական տողի երկարությունը։\n- m (int): '1'-երի քանակը երկբայական տողի մեջ։\n\nՎերադարձնում է:\n- int: Տարբեր փոխարկման սխեմաների ընդհանուր քանակը։",
      "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (int): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (int): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nরিটার্নস:\n- int: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Бройте броя на различните схеми на пермутации за двоична низ с дължина n, където броят на '1'-ците е m и броят на '0'-ците е n - m.\n\nПараметри:\n- n (int): Дължина на двоичната низ.\n- m (int): Брой '1'-ци в двоичната низ.\n\nВръща:\n- int: Общият брой на различните схеми на пермутации.",
      "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数:\n- n (int): 二进制字符串的长度。\n- m (int): 二进制字符串中 '1' 的数量。\n\n返回:\n- int: 不同排列方案的总数量。",
      "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (int) : Longueur de la chaîne binaire.\n- m (int) : Nombre de '1' dans la chaîne binaire.\n\nRetourne :\n- int : Le nombre total de différents schémas de permutation.",
      "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (int): Länge des Binärstrings.\n- m (int): Anzahl der '1's im Binärstring.\n\nRückgabewert:\n- int: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Ƙididdige adadin tsarin juyawa daban-daban don igiyar binary mai tsawon n, inda adadin '1's yake m kuma adadin '0's yake n - m.\n\nSigogi:\n- n (int): Tsawon igiyar binary.\n- m (int): Adadin '1's a cikin igiyar binary.\n\nDawowa:\n- int: Jimlar adadin tsarin juyawa daban-daban.",
      "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1' की संख्या m है और '0' की संख्या n - m है।\n\nपैरामीटर्स:\n- n (int): बाइनरी स्ट्रिंग की लंबाई।\n- m (int): बाइनरी स्ट्रिंग में '1' की संख्या।\n\nवापसी:\n- int: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterlánc esetén, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (int): A bináris karakterlánc hossza.\n- m (int): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\n- int: A különböző permutációs sémák teljes száma."
    },
    "docstring_bertscore": {
      "sq": "0.9963597010067736",
      "hy": "0.9647280114573487",
      "bn": "0.9649989432970802",
      "bg": "0.9924401276978122",
      "zh": "0.9451994669155226",
      "fr": "0.9854634341943428",
      "de": "0.9940009652319843",
      "ha": "0.9963597010067736",
      "hi": "0.9840156173469794",
      "hu": "0.975421476650743"
    }
  },
  {
    "task_id": "CPP/20",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Answer a series of questions by providing choices A, B, C, or D for each question.\n *  \n *  Question 1:\n *  Constants like 1e6 belong to which data type?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2:\n *  Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *      A. int\n *      B. long long\n *      C. double\n *      D. None of the above\n *  \n *  Question 3:\n *  Which statement about left values in expressions is incorrect?\n *      A. Variable name expressions are left values.\n *      B. Increment operation requires the operand to be a left value.\n *      C. Pointer dereference expressions are left values.\n *      D. Prefix increment operation expressions are left values.\n *  \n *  Question 4:\n *  Which statement about functions is incorrect?\n *      A. Formal parameters of a function are local variables.\n *      B. Local variables are allocated space in the stack.\n *      C. The function type is the same as the return value type.\n *      D. A function can call itself from within its body.\n *  \n *  Question 5:\n *  Which statement about pointers is incorrect?\n *      A. Subtracting two pointers equals the difference in their address values.\n *      B. Pointer dereference involves resolving based on the pointer's type.\n *      C. int *p[4], p is an array of int pointers.\n *      D. Function names can be assigned to function pointers.\n *  \n *  You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nconst char* answer_questions()",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Përgjigju një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n *  \n *  Pyetja 1:\n *  Konstantet si 1e6 i përkasin cilit lloj të dhënash?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pyetja 2:\n *  Duke dhënë 21! = 51,090,942,171,709,440,000, cili lloj i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Asnjë nga të mësipërmet\n *  \n *  Pyetja 3:\n *  Cila deklaratë për vlerat e majta në shprehje është e pasaktë?\n *      A. Shprehjet e emrave të variablave janë vlera të majta.\n *      B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n *      C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n *      D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n *  \n *  Pyetja 4:\n *  Cila deklaratë për funksionet është e pasaktë?\n *      A. Parametrat formalë të një funksioni janë variabla lokale.\n *      B. Variablat lokale alokohen hapësirë në stack.\n *      C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n *      D. Një funksion mund të thërrasë vetveten nga brenda trupit të tij.\n *  \n *  Pyetja 5:\n *  Cila deklaratë për treguesit është e pasaktë?\n *      A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n *      B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n *      C. int *p[4], p është një varg treguesish int.\n *      D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n *  \n *  Supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.\n */\nconst char* answer_questions()",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով A, B, C կամ D ընտրանքները:\n *  \n *  Հարց 1:\n *  Նման հաստատունները, ինչպիսիք են 1e6-ը, որ տվյալների տիպին են պատկանում?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Հարց 2:\n *  Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Վերը նշվածներից ոչ մեկը\n *  \n *  Հարց 3:\n *  Որ հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է?\n *      A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n *      B. Ինքրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n *      C. Ցուցիչի ապահանել արտահայտությունները ձախ արժեքներ են:\n *      D. Նախածանց ինքրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\n *  \n *  Հարց 4:\n *  Որ հայտարարությունը ֆունկցիաների մասին սխալ է?\n *      A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n *      B. Տեղական փոփոխականները հատկացվում են ստեկում:\n *      C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n *      D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնի ներսից:\n *  \n *  Հարց 5:\n *  Որ հայտարարությունը ցուցիչների մասին սխալ է?\n *      A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n *      B. Ցուցիչի ապահանումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n *      C. int *p[4], p-ն int ցուցիչների զանգված է:\n *      D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n *  \n *  Դուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրանքները:\n */\nconst char* answer_questions()",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  প্রতিটি প্রশ্নের জন্য পছন্দ A, B, C, বা D প্রদান করে প্রশ্নগুলির উত্তর দিন।\n *  \n *  প্রশ্ন ১:\n *  1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  প্রশ্ন ২:\n *  21! = 51,090,942,171,709,440,000 দেওয়া হয়েছে, কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n *      A. int\n *      B. long long\n *      C. double\n *      D. উপরের কোনোটিই নয়\n *  \n *  প্রশ্ন ৩:\n *  এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n *      A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n *      B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n *      C. পয়েন্টার ডিরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n *      D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n *  \n *  প্রশ্ন ৪:\n *  ফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n *      A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n *      B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n *      C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালু টাইপ একই।\n *      D. একটি ফাংশন তার দেহের ভিতরে নিজেকে কল করতে পারে।\n *  \n *  প্রশ্ন ৫:\n *  পয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n *      A. দুটি পয়েন্টার বিয়োগ করার মানে তাদের ঠিকানা মানের পার্থক্য।\n *      B. পয়েন্টার ডিরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n *      C. int *p[4], p হল int পয়েন্টারগুলির একটি অ্যারে।\n *      D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n *  \n *  আপনি শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দেওয়ার কথা, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।\n */\nconst char* answer_questions()",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n *  \n *  Въпрос 1:\n *  Константи като 1e6 принадлежат към кой тип данни?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Въпрос 2:\n *  Дадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Нито едно от горните\n *  \n *  Въпрос 3:\n *  Кое твърдение за левите стойности в изразите е неправилно?\n *      A. Изразите с имена на променливи са леви стойности.\n *      B. Операцията на инкрементиране изисква операндът да е лява стойност.\n *      C. Изразите с разименуване на указатели са леви стойности.\n *      D. Изразите с префиксно инкрементиране са леви стойности.\n *  \n *  Въпрос 4:\n *  Кое твърдение за функциите е неправилно?\n *      A. Формалните параметри на функцията са локални променливи.\n *      B. Локалните променливи се разпределят в стека.\n *      C. Типът на функцията е същият като типа на връщаната стойност.\n *      D. Функцията може да извика сама себе си от тялото си.\n *  \n *  Въпрос 5:\n *  Кое твърдение за указателите е неправилно?\n *      A. Изваждането на два указателя е равно на разликата в стойностите на техните адреси.\n *      B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n *      C. int *p[4], p е масив от указатели към int.\n *      D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n *  \n *  Трябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.\n */\nconst char* answer_questions()",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  通过为每个问题提供选择A、B、C或D来回答一系列问题。\n *  \n *  问题 1:\n *  常量如1e6属于哪种数据类型？\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  问题 2:\n *  给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n *      A. int\n *      B. long long\n *      C. double\n *      D. 以上都不是\n *  \n *  问题 3:\n *  关于表达式中的左值，哪个说法是不正确的？\n *      A. 变量名表达式是左值。\n *      B. 增量操作要求操作数是左值。\n *      C. 指针解引用表达式是左值。\n *      D. 前缀增量操作表达式是左值。\n *  \n *  问题 4:\n *  关于函数，哪个说法是不正确的？\n *      A. 函数的形式参数是局部变量。\n *      B. 局部变量在栈中分配空间。\n *      C. 函数类型与返回值类型相同。\n *      D. 函数可以在其体内调用自身。\n *  \n *  问题 5:\n *  关于指针，哪个说法是不正确的？\n *      A. 两个指针相减等于它们地址值的差。\n *      B. 指针解引用涉及根据指针的类型进行解析。\n *      C. int *p[4], p是一个int指针数组。\n *      D. 函数名可以赋值给函数指针。\n *  \n *  你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。\n */\nconst char* answer_questions()",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n *  \n *  Question 1 :\n *  Les constantes comme 1e6 appartiennent à quel type de données ?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2 :\n *  Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Aucun des précédents\n *  \n *  Question 3 :\n *  Quelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n *      A. Les expressions de nom de variable sont des valeurs à gauche.\n *      B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n *      C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n *      D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.\n *  \n *  Question 4 :\n *  Quelle affirmation concernant les fonctions est incorrecte ?\n *      A. Les paramètres formels d'une fonction sont des variables locales.\n *      B. Les variables locales sont allouées dans la pile.\n *      C. Le type de la fonction est le même que le type de la valeur de retour.\n *      D. Une fonction peut s'appeler elle-même depuis son corps.\n *  \n *  Question 5 :\n *  Quelle affirmation concernant les pointeurs est incorrecte ?\n *      A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n *      B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n *      C. int *p[4], p est un tableau de pointeurs int.\n *      D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n *  \n *  Vous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.\n */\nconst char* answer_questions()",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n *  \n *  Frage 1:\n *  Konstanten wie 1e6 gehören zu welchem Datentyp?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Frage 2:\n *  Gegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Keine der oben genannten\n *  \n *  Frage 3:\n *  Welche Aussage über linke Werte in Ausdrücken ist falsch?\n *      A. Variablennamen-Ausdrücke sind linke Werte.\n *      B. Der Inkrementierungsoperator erfordert, dass der Operand ein linker Wert ist.\n *      C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n *      D. Präfix-Inkrement-Ausdrücke sind linke Werte.\n *  \n *  Frage 4:\n *  Welche Aussage über Funktionen ist falsch?\n *      A. Formale Parameter einer Funktion sind lokale Variablen.\n *      B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n *      C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n *      D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n *  \n *  Frage 5:\n *  Welche Aussage über Zeiger ist falsch?\n *      A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n *      B. Die Zeiger-Dereferenzierung erfolgt basierend auf dem Typ des Zeigers.\n *      C. int *p[4], p ist ein Array von int-Zeigern.\n *      D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n *  \n *  Sie sollen nur Zeichenfolgen ähnlich wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n */\nconst char* answer_questions()",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n *  \n *  Tambaya ta 1:\n *  Constants kamar 1e6 suna cikin wane nau'in bayanai?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Tambaya ta 2:\n *  An bayar da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Babu ɗaya daga cikin waɗanda ke sama\n *  \n *  Tambaya ta 3:\n *  Wane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n *      A. Maganganun sunayen canji ƙimar hagu ne.\n *      B. Aiki na ƙara yana buƙatar operand ya zama ƙimar hagu.\n *      C. Maganganun cirewa mai nuna alama ƙimar hagu ne.\n *      D. Maganganun aiki na ƙara na farko ƙimar hagu ne.\n *  \n *  Tambaya ta 4:\n *  Wane bayani game da ayyuka ba daidai ba ne?\n *      A. Sigogin tsari na aiki canje-canje na gida ne.\n *      B. Canje-canje na gida suna da sarari a cikin tsari.\n *      C. Nau'in aiki iri ɗaya ne da nau'in ƙimar dawowa.\n *      D. Aiki na iya kiran kansa daga cikin jikinsa.\n *  \n *  Tambaya ta 5:\n *  Wane bayani game da masu nuna alama ba daidai ba ne?\n *      A. Rage masu nuna alama biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n *      B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n *      C. int *p[4], p jerin masu nuna alama ne na int.\n *      D. Ana iya sanya sunayen ayyuka ga masu nuna alama na aiki.\n *  \n *  Ana tsammanin ka dawo da kirtani makamancin \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.\n */\nconst char* answer_questions()",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n *  \n *  प्रश्न 1:\n *  1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  प्रश्न 2:\n *  दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n *      A. int\n *      B. long long\n *      C. double\n *      D. उपरोक्त में से कोई नहीं\n *  \n *  प्रश्न 3:\n *  अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n *      A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n *      B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n *      C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n *      D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n *  \n *  प्रश्न 4:\n *  कार्यों के बारे में कौन सा कथन गलत है?\n *      A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n *      B. स्थानीय वेरिएबल स्टैक में स्थान आवंटित करते हैं।\n *      C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n *      D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\n *  \n *  प्रश्न 5:\n *  पॉइंटर्स के बारे में कौन सा कथन गलत है?\n *      A. दो पॉइंटर्स को घटाने से उनके पते के मूल्यों में अंतर होता है।\n *      B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n *      C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n *      D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n *  \n *  आपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े हैं।\n */\nconst char* answer_questions()",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésre.\n *  \n *  1. kérdés:\n *  Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  2. kérdés:\n *  Adott 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Egyik sem a fentiek közül\n *  \n *  3. kérdés:\n *  Melyik állítás helytelen a balértékekről kifejezésekben?\n *      A. A változónév kifejezések balértékek.\n *      B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n *      C. A pointer dereferálás kifejezések balértékek.\n *      D. A prefix inkrementáló művelet kifejezések balértékek.\n *  \n *  4. kérdés:\n *  Melyik állítás helytelen a függvényekről?\n *      A. A függvény formális paraméterei lokális változók.\n *      B. A lokális változók a veremben kapnak helyet.\n *      C. A függvény típusa megegyezik a visszatérési érték típusával.\n *      D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n *  \n *  5. kérdés:\n *  Melyik állítás helytelen a pointerekről?\n *      A. Két pointer kivonása az címértékeik különbségével egyenlő.\n *      B. A pointer dereferálás a pointer típusának megfelelően történik.\n *      C. int *p[4], p egy int pointerek tömbje.\n *      D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n *  \n *  Csak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdés választásait jelölik.\n */\nconst char* answer_questions()"
    },
    "prompt_bertscore": {
      "sq": "0.8853014823625469",
      "hy": "0.9371626830684701",
      "bn": "0.9547452457672972",
      "bg": "0.9375547794406329",
      "zh": "0.9394489187541816",
      "fr": "0.9556935072063578",
      "de": "0.9431213958691357",
      "ha": "0.8675566386424142",
      "hi": "0.9515278308552941",
      "hu": "0.9277188016021662"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nՏվեք CPP կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\n请用中文为以下CPP代码提供一个简明的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nसीपीपी कोड के लिए अधिकतम 500 वर्णों में एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें।",
      "hu": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9156510128023916",
      "bn": "0.8426287244529167",
      "bg": "0.8329214591013607",
      "zh": "0.8782326243622773",
      "fr": "0.9172954737269795",
      "de": "0.8909078248672566",
      "ha": "0.9536396690664571",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}",
    "entry_point": "answer_questions",
    "signature": "const char* answer_questions()",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPyetja 2:\nDuke dhënë 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga më sipër\n\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet e emrave të variablave janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\n\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të alokuar në stack.\n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë vetveten brenda trupit të tij.\n\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n\nJu supozohet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.",
      "hy": "Պատասխանել մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nՀարց 2:\nԵթե 21! = 51,090,942,171,709,440,000, ապա որ տվյալների տիպը կարող է պահել այս արժեքը?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\n\nՀարց 3:\nՈր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի դե-ռեֆերենս արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n\nՀարց 4:\nՈր հայտարարությունը ֆունկցիաների մասին սխալ է?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n\nՀարց 5:\nՈր հայտարարությունը ցուցիչների մասին սխալ է?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի դե-ռեֆերենսը ներառում է լուծում՝ հիմնված ցուցիչի տիպի վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիայի անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\nԴուք պետք է վերադարձնեք միայն \"AAAAA\" նման տողեր, որոնք ներկայացնում են հարցի ընտրանքները:",
      "bn": "একটি প্রশ্নের সিরিজের উত্তর দিন প্রতিটি প্রশ্নের জন্য A, B, C, বা D পছন্দ প্রদান করে।\n\nপ্রশ্ন ১:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nপ্রশ্ন ২:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তবে কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরের কোনোটিই নয়\n\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n    C. ফাংশন টাইপটি রিটার্ন ভ্যালু টাইপের মতোই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\n\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করে।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশন নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\nআপনাকে প্রশ্নের পছন্দের জন্য \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দিতে হবে।",
      "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горепосочените\n\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да е лява стойност.\n    C. Изразите за разименуване на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\n\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи са разпределени в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си от тялото си.\n\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Разименуването на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпроса.",
      "zh": "回答一系列问题，为每个问题提供选择A、B、C或D。\n\n问题1：\n像1e6这样的常量属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n问题2：\n给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n\n问题3：\n关于表达式中的左值，哪种说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n\n问题4：\n关于函数，哪种说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n\n问题5：\n关于指针，哪种说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及基于指针类型的解析。\n    C. int *p[4]，p是一个int指针数组。\n    D. 函数名可以赋值给函数指针。\n\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。",
      "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs à gauche.\n    B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération d'incrémentation préfixe sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\n\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamenausdrücke sind linke Werte.\n    B. Die Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenzierungsausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperation-Ausdrücke sind linke Werte.\n\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Die Zeiger-Dereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\nSie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya.\n\nTambaya ta 1:\nDindindin kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗanda ke sama\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin bayyana ba daidai ba ne?\n    A. Bayanan sunan canji suna ƙimar hagu.\n    B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Bayanan cirewa mai nuna suna ƙimar hagu.\n    D. Bayanan aiki na ƙaruwa na farko suna ƙimar hagu.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogi na zahiri na aiki suna da canje-canje na gida.\n    B. Canje-canje na gida suna samun sarari a cikin faifai.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna ba daidai ba ne?\n    A. Cirewa masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cirewa mai nuna yana haɗawa da warwarewa bisa nau'in mai nuna.\n    C. int *p[4], p tsari ne na masu nuna int.\n    D. Ana iya sanya sunayen ayyuka zuwa masu nuna ayyuka.\n\nAna tsammanin ka dawo da igiyoyi makamancin \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.",
      "hi": "प्रश्नों की एक श्रृंखला का उत्तर देकर प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करें।\n\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nप्रश्न 2:\n21! = 51,090,942,171,709,440,000 दिया गया है, इस मान को संग्रहीत करने के लिए कौन सा डेटा प्रकार उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\n\nप्रश्न 3:\nअभिव्यक्तियों में बाएं मानों के बारे में कौन सा कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएं मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएं मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएं मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएं मान हैं।\n\nप्रश्न 4:\nकार्य के बारे में कौन सा कथन गलत है?\n    A. किसी कार्य के औपचारिक पैरामीटर स्थानीय चर हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. कार्य प्रकार वही है जो वापसी मूल्य प्रकार है।\n    D. एक कार्य अपने शरीर के भीतर से खुद को कॉल कर सकता है।\n\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n    D. कार्य नामों को कार्य पॉइंटर्स को सौंपा जा सकता है।\n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े हैं।",
      "hu": "Válaszolj egy sor kérdésre azáltal, hogy választ adsz A, B, C vagy D lehetőségek közül minden kérdésre.\n\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\n2. kérdés:\nAdott a 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem\n\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferencia kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezések balértékek.\n\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a törzsén belül.\n\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferencia a pointer típusának alapján történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\nCsak olyan karakterláncokat kell visszaadnod, mint \"AAAAA\", amelyek a kérdések választásait jelölik."
    },
    "docstring_bertscore": {
      "sq": "0.9562458982960159",
      "hy": "0.9413035306219043",
      "bn": "0.9358666198322174",
      "bg": "0.9409469890879467",
      "zh": "0.9388345549856407",
      "fr": "0.949374677524876",
      "de": "0.9425342444627965",
      "ha": "0.9283121105503175",
      "hi": "0.9398940494380807",
      "hu": "0.935437578209182"
    }
  },
  {
    "task_id": "CPP/21",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * Example:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.\n */\nbool Is_Square(std::vector<int> squares)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Përcakton nëse është e mundur të montohen katrorët prej druri nga n kovë\n * në një katror më të madh, ku secila kovë përmban katrorë me një gjatësi anësore prej 1.\n * \n * Hyrja: vektor numrash\n * Shembull:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n * @return True nëse është e mundur të formohet një katror më i madh, False përndryshe.\n */\nbool Is_Square(std::vector<int> squares)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Որոշում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից\n * մեկ մեծ քառակուսի մեջ, որտեղ յուրաքանչյուր դույլ պարունակում է 1 կողմի երկարությամբ քառակուսիներ:\n * \n * Մուտք: թվերի վեկտոր\n * Օրինակ:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլում քառակուսիների քանակը:\n * @return Ճիշտ է, եթե հնարավոր է կազմել մեծ քառակուսի, Հակառակ դեպքում՝ Սխալ:\n */\nbool Is_Square(std::vector<int> squares)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * নির্ধারণ করে যে n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করে একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব কিনা,\n * যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে।\n * \n * ইনপুট: সংখ্যার ভেক্টর\n * উদাহরণ:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares প্রতিটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n * @return যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে True, অন্যথায় False।\n */\nbool Is_Square(std::vector<int> squares)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Определя дали е възможно да се сглобят дървените квадрати от n кофи\n * в един по-голям квадрат, където всяка кофа съдържа квадрати със страна 1.\n * \n * Вход: вектор от числа\n * Пример:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n * @return True ако е възможно да се формира по-голям квадрат, False в противен случай.\n */\nbool Is_Square(std::vector<int> squares)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * 确定是否可以将 n 个桶中的木块组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n * \n * 输入: 数字向量\n * 示例:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares 向量，包含每个桶中正方形的数量。\n * @return 如果可以形成更大的正方形则返回 True，否则返回 False。\n */\nbool Is_Square(std::vector<int> squares)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Détermine s'il est possible d'assembler les carrés en bois à partir de n seaux\n * en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n * \n * Entrée : vecteur de nombres\n * Exemple :\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vecteur contenant le nombre de carrés dans chaque seau.\n * @return True s'il est possible de former un carré plus grand, False sinon.\n */\nbool Is_Square(std::vector<int> squares)",
      "de": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zu einem einzigen größeren Quadrat zusammenzusetzen,\n * wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n * \n * Eingabe: Vektor von Zahlen\n * Beispiel:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n * @return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.\n */\nbool Is_Square(std::vector<int> squares)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Yana tantancewa idan yana yiwuwa a tara murabba'ai na katako daga guga n\n * zuwa murabba'i guda mafi girma, inda kowanne guga ya ƙunshi murabba'ai da ke da tsawon gefe 1.\n * \n * Shigarwa: vector na lambobi\n * Misali:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector da ke ƙunshe da adadin murabba'ai a kowanne guga.\n * @return True idan yana yiwuwa a samar da murabba'i mafi girma, False in ba haka ba.\n */\nbool Is_Square(std::vector<int> squares)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है,\n * जहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्ग होते हैं।\n * \n * इनपुट: संख्याओं का वेक्टर\n * उदाहरण:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares प्रत्येक बाल्टी में वर्गों की गिनती वाला वेक्टर।\n * @return True यदि एक बड़ा वर्ग बनाना संभव है, अन्यथा False।\n */\nbool Is_Square(std::vector<int> squares)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Meghatározza, hogy lehetséges-e a fából készült négyzeteket n vödörből\n * egyetlen nagyobb négyzetté összeállítani, ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n * \n * Bemenet: számokat tartalmazó vektor\n * Példa:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vektor, amely minden vödörben található négyzetek számát tartalmazza.\n * @return Igaz, ha lehetséges egy nagyobb négyzetet kialakítani, Hamis egyébként.\n */\nbool Is_Square(std::vector<int> squares)"
    },
    "prompt_bertscore": {
      "sq": "0.9924709154068726",
      "hy": "0.9792155155588903",
      "bn": "0.9595391900135744",
      "bg": "0.9738797076331501",
      "zh": "0.9497695547223733",
      "fr": "0.9962524406010148",
      "de": "0.9898209874934861",
      "ha": "0.9748043320568676",
      "hi": "0.9742702149622647",
      "hu": "0.9877482794673871"
    },
    "canonical_solution": "{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}",
    "instruction": {
      "en": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.9074010985564885",
      "bn": "0.8689845924516739",
      "bg": "0.9788407625177538",
      "zh": "0.8753791003083301",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.9583126474106839",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}",
    "entry_point": "Is_Square",
    "signature": "bool Is_Square(std::vector<int> squares)",
    "docstring": {
      "en": "Determines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\nExample:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n",
      "sq": "Përcakton nëse është e mundur të montohet një katror i madh prej druri nga n kovë\nnë një katror të vetëm më të madh, ku çdo kovë përmban katrorë me një gjatësi anësore prej 1.\n\nHyrja: vektor numrash\nShembull:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor që përmban numrin e katrorëve në secilën kovë.\n@return E vërtetë nëse është e mundur të formohet një katror më i madh, e rreme përndryshe.",
      "hy": "Վճռում է՝ արդյոք հնարավոր է հավաքել փայտե քառակուսիները n դույլերից մեկ մեծ քառակուսիի մեջ, որտեղ յուրաքանչյուր դույլ պարունակում է կողքի երկարությամբ 1 քառակուսիներ։\n\nՄուտք: թվերի վեկտոր  \nՕրինակ:  \n   >>> Is_Square({9})  \n   true  \n\n@param squares Վեկտոր, որը պարունակում է յուրաքանչյուր դույլում քառակուսիների քանակը։  \n@return True, եթե հնարավոր է կազմել մեծ քառակուսի, False՝ հակառակ դեպքում։  ",
      "bn": "বুঝায় যে এটি সম্ভব কিনা n বালতি থেকে কাঠের বর্গক্ষেত্রগুলি একত্রিত করে একটি বড় বর্গক্ষেত্র তৈরি করা, যেখানে প্রতিটি বালতিতে 1 পার্শ্ব দৈর্ঘ্যের বর্গক্ষেত্র রয়েছে।\n\nইনপুট: সংখ্যার ভেক্টর\nউদাহরণ:\n   >>> Is_Square({9})\n   true\n\n@param squares প্রতিটি বালতিতে বর্গক্ষেত্রের সংখ্যা ধারণকারী ভেক্টর।\n@return যদি একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব হয় তবে True, অন্যথায় False।",
      "bg": "Определя дали е възможно да се сглобят дървените квадрати от n кофи в един по-голям квадрат, където всяка кофа съдържа квадрати с дължина на страната 1.\n\nВход: вектор от числа\nПример:\n   >>> Is_Square({9})\n   true\n\n@param squares Вектор, съдържащ броя на квадратите във всяка кофа.\n@return True, ако е възможно да се образува по-голям квадрат, False в противен случай.",
      "zh": "确定是否可以将 n 个桶中的木方块组装成一个更大的正方形，其中每个桶包含边长为 1 的正方形。\n\n输入：数字向量\n示例：\n   >>> Is_Square({9})\n   true\n\n@param squares 向量，包含每个桶中正方形的数量。\n@return 如果可以形成一个更大的正方形，则返回 True，否则返回 False。",
      "fr": "Détermine s'il est possible d'assembler les carrés en bois de n seaux en un seul carré plus grand, où chaque seau contient des carrés avec une longueur de côté de 1.\n\nEntrée : vecteur de nombres\nExemple :\n   >>> Is_Square({9})\n   true\n\n@param squares Vecteur contenant le nombre de carrés dans chaque seau.\n@return True s'il est possible de former un carré plus grand, False sinon.",
      "de": "Bestimmt, ob es möglich ist, die Holzquadrate aus n Eimern zu einem einzigen größeren Quadrat zusammenzusetzen, wobei jeder Eimer Quadrate mit einer Seitenlänge von 1 enthält.\n\nEingabe: Vektor von Zahlen\nBeispiel:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor, der die Anzahl der Quadrate in jedem Eimer enthält.\n@return True, wenn es möglich ist, ein größeres Quadrat zu bilden, False andernfalls.",
      "ha": "Yana tantance ko zai yiwu a tara murabba'ai na katako daga guga n cikin guga guda ɗaya mafi girma, inda kowanne guga yana ɗauke da murabba'ai tare da tsawon gefe na 1.\n\nShigarwa: vector na lambobi\nMisali:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector mai ɗauke da adadin murabba'ai a kowane guga.\n@return Gaskiya idan zai yiwu a samar da murabba'i mafi girma, Karya in ba haka ba.",
      "hi": "यह निर्धारित करता है कि क्या n बाल्टियों से लकड़ी के वर्गों को एक बड़े वर्ग में इकट्ठा करना संभव है, जहाँ प्रत्येक बाल्टी में 1 की भुजा लंबाई वाले वर्ग होते हैं।\n\nइनपुट: संख्याओं का वेक्टर  \nउदाहरण:  \n   >>> Is_Square({9})  \n   true\n\n@param squares प्रत्येक बाल्टी में वर्गों की संख्या वाला वेक्टर।  \n@return यदि एक बड़ा वर्ग बनाना संभव है तो True, अन्यथा False।",
      "hu": "Meghatározza, hogy lehetséges-e a fa négyzeteket n vödörből egyetlen nagyobb négyzetté összeállítani, ahol minden vödör 1 oldalhosszúságú négyzeteket tartalmaz.\n\nBemenet: számok vektora\nPélda:\n   >>> Is_Square({9})\n   true\n\n@param squares Vektor, amely az egyes vödrökben lévő négyzetek számát tartalmazza.\n@return Igaz, ha lehetséges egy nagyobb négyzetet kialakítani, különben Hamis."
    },
    "docstring_bertscore": {
      "sq": "0.9685730983734221",
      "hy": "0.963989702331042",
      "bn": "0.9229475012193272",
      "bg": "0.9821451150487739",
      "zh": "0.9046441088677243",
      "fr": "0.9834374043077869",
      "de": "0.9826333485253577",
      "ha": "0.9522864002804664",
      "hi": "0.9449489940050376",
      "hu": "0.970360374541974"
    }
  },
  {
    "task_id": "CPP/22",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Given integers c and d, where a + b = c and a * b = d, this function\n * finds the possible value of a with the condition a <= b. When multiple \n * pairs (a, b) are possible, it returns the pair with the smallest a.\n * If no valid pair exists, it returns -1.\n *\n * Parameters:\n *  - c (int): The sum of a and b.\n *  - d (int): The product of a and b.\n *\n * Returns:\n *  - int: A possible value of a or -1 if no valid values exist.\n *\n * Examples:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, kjo funksion\n * gjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme disa \n * çifte (a, b), kthen çiftin me a më të vogël.\n * Nëse nuk ekziston asnjë çift i vlefshëm, kthen -1.\n *\n * Parametrat:\n *  - c (int): Shuma e a dhe b.\n *  - d (int): Produkti i a dhe b.\n *\n * Kthen:\n *  - int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n *\n * Shembuj:\n *  find_integers(7, 11) kthen -1\n *  find_integers(5, 6) kthen 2\n */\nint find_integers(int c, int d)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\n * գտնում է a-ի հնարավոր արժեքը պայմանով, որ a <= b։ Երբ հնարավոր են բազմաթիվ \n * զույգեր (a, b), այն վերադարձնում է զույգը ամենափոքր a-ով։\n * Եթե ոչ մի վավեր զույգ չի գոյություն ունենում, այն վերադարձնում է -1։\n *\n * Պարամետրեր:\n *  - c (int): a և b-ի գումարը։\n *  - d (int): a և b-ի արտադրյալը։\n *\n * Վերադարձնում է:\n *  - int: a-ի հնարավոր արժեք կամ -1, եթե վավեր արժեքներ չկան։\n *\n * Օրինակներ:\n *  find_integers(7, 11) վերադարձնում է -1\n *  find_integers(5, 6) վերադարձնում է 2\n */\nint find_integers(int c, int d)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * প্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি\n * a এর সম্ভাব্য মান খুঁজে বের করে শর্ত সাপেক্ষে a <= b। যখন একাধিক \n * জোড়া (a, b) সম্ভব, এটি সেই জোড়াটি ফেরত দেয় যেখানে a সবচেয়ে ছোট।\n * যদি কোন বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n *\n * প্যারামিটার:\n *  - c (int): a এবং b এর যোগফল।\n *  - d (int): a এবং b এর গুণফল।\n *\n * রিটার্নস:\n *  - int: a এর সম্ভাব্য মান অথবা যদি কোন বৈধ মান না থাকে তবে -1।\n *\n * উদাহরণ:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Дадени са цели числа c и d, където a + b = c и a * b = d, тази функция\n * намира възможната стойност на a с условието a <= b. Когато са възможни \n * множество двойки (a, b), тя връща двойката с най-малко a.\n * Ако не съществува валидна двойка, връща -1.\n *\n * Параметри:\n *  - c (int): Сумата на a и b.\n *  - d (int): Произведението на a и b.\n *\n * Връща:\n *  - int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n *\n * Примери:\n *  find_integers(7, 11) връща -1\n *  find_integers(5, 6) връща 2\n */\nint find_integers(int c, int d)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数\n * 找出满足条件 a <= b 的可能值 a。当存在多个\n * (a, b) 对时，返回 a 最小的对。\n * 如果不存在有效对，则返回 -1。\n *\n * 参数:\n *  - c (int): a 和 b 的和。\n *  - d (int): a 和 b 的积。\n *\n * 返回:\n *  - int: a 的可能值，或如果不存在有效值则返回 -1。\n *\n * 示例:\n *  find_integers(7, 11) 返回 -1\n *  find_integers(5, 6) 返回 2\n */\nint find_integers(int c, int d)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Étant donné les entiers c et d, où a + b = c et a * b = d, cette fonction\n * trouve la valeur possible de a avec la condition a <= b. Lorsque plusieurs \n * paires (a, b) sont possibles, elle retourne la paire avec le plus petit a.\n * Si aucune paire valide n'existe, elle retourne -1.\n *\n * Paramètres:\n *  - c (int): La somme de a et b.\n *  - d (int): Le produit de a et b.\n *\n * Renvoie:\n *  - int: Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n *\n * Exemples:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Gegeben sind die ganzen Zahlen c und d, wobei a + b = c und a * b = d. Diese Funktion\n * findet den möglichen Wert von a mit der Bedingung a <= b. Wenn mehrere \n * Paare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück.\n * Wenn kein gültiges Paar existiert, gibt sie -1 zurück.\n *\n * Parameter:\n *  - c (int): Die Summe von a und b.\n *  - d (int): Das Produkt von a und b.\n *\n * Rückgabewerte:\n *  - int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n *\n * Beispiele:\n *  find_integers(7, 11) gibt -1 zurück\n *  find_integers(5, 6) gibt 2 zurück\n */\nint find_integers(int c, int d)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * An ba da lambobin c da d, inda a + b = c kuma a * b = d, wannan aikin\n * yana nemo yuwuwar ƙimar a tare da yanayin a <= b. Idan an samu \n * ma'aurata (a, b) da dama, yana mayar da ma'aurata tare da ƙaramin a.\n * Idan babu ma'aurata masu inganci, yana mayar da -1.\n *\n * Sigogi:\n *  - c (int): Jimillar a da b.\n *  - d (int): Samfurin a da b.\n *\n * Yana Mayarwa:\n *  - int: Yuwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n *\n * Misalai:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * दिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, यह फ़ंक्शन\n * a के संभावित मान को खोजता है इस शर्त के साथ कि a <= b। जब कई \n * जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है।\n * यदि कोई मान्य जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n *\n * पैरामीटर्स:\n *  - c (int): a और b का योग।\n *  - d (int): a और b का गुणनफल।\n *\n * रिटर्न्स:\n *  - int: a का एक संभावित मान या -1 यदि कोई मान्य मान मौजूद नहीं है।\n *\n * उदाहरण:\n *  find_integers(7, 11) -1 लौटाता है\n *  find_integers(5, 6) 2 लौटाता है\n */\nint find_integers(int c, int d)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Adott két egész szám, c és d, ahol a + b = c és a * b = d, ez a függvény\n * megkeresi a lehetséges a értékét azzal a feltétellel, hogy a <= b. Ha több \n * (a, b) pár lehetséges, akkor a legkisebb a értékű párt adja vissza.\n * Ha nem létezik érvényes pár, akkor -1-et ad vissza.\n *\n * Paraméterek:\n *  - c (int): Az a és b összege.\n *  - d (int): Az a és b szorzata.\n *\n * Visszatérési érték:\n *  - int: Az a lehetséges értéke vagy -1, ha nem léteznek érvényes értékek.\n *\n * Példák:\n *  find_integers(7, 11) visszaadja -1\n *  find_integers(5, 6) visszaadja 2\n */\nint find_integers(int c, int d)"
    },
    "prompt_bertscore": {
      "sq": "0.9961523308889731",
      "hy": "0.9906053788681929",
      "bn": "0.9884212391983332",
      "bg": "0.99711330467242",
      "zh": "0.9707167174455505",
      "fr": "0.9990543207558928",
      "de": "0.9809354560282715",
      "ha": "0.9885588900523904",
      "hi": "0.9913842085922306",
      "hu": "0.9737901253313034"
    },
    "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nПредоставете кратко описание на C++ кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nसीपीपी कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.963562249751055",
      "bn": "0.8920847098748883",
      "bg": "0.8530995249891709",
      "zh": "0.904821312162758",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.9430681629270182",
      "hi": "0.9395643230055628",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    return 0;\n}",
    "entry_point": "find_integers",
    "signature": "int find_integers(int c, int d)",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, this function\nfinds the possible value of a with the condition a <= b. When multiple\npairs (a, b) are possible, it returns the pair with the smallest a.\nIf no valid pair exists, it returns -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a or -1 if no valid values exist.\n\nExamples:\nfind_integers(7, 11) returns -1\nfind_integers(5, 6) returns 2\n",
      "sq": "Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, kjo funksion\ngjen vlerën e mundshme të a me kushtin a <= b. Kur janë të mundshme shumë\nçifte (a, b), ajo kthen çiftin me a më të vogël.\nNëse nuk ekziston asnjë çift i vlefshëm, ajo kthen -1.\n\nParametrat:\n- c (int): Shuma e a dhe b.\n- d (int): Produkti i a dhe b.\n\nKthen:\n- int: Një vlerë e mundshme e a ose -1 nëse nuk ekzistojnë vlera të vlefshme.\n\nShembuj:\nfind_integers(7, 11) kthen -1\nfind_integers(5, 6) kthen 2",
      "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, այս ֆունկցիան\nգտնում է a-ի հնարավոր արժեքը պայմանով a <= b։ Երբ հնարավոր են մի քանի\nզույգեր (a, b), այն վերադարձնում է զույգը ամենափոքր a-ով։\nԵթե վավեր զույգ գոյություն չունի, այն վերադարձնում է -1։\n\nՊարամետրեր:\n- c (int): a և b-ի գումարը։\n- d (int): a և b-ի արտադրյալը։\n\nՎերադարձնում է:\n- int: a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չկան։\n\nՕրինակներ:\nfind_integers(7, 11) վերադարձնում է -1\nfind_integers(5, 6) վերադարձնում է 2",
      "bn": "দেওয়া পূর্ণসংখ্যা c এবং d এর জন্য, যেখানে a + b = c এবং a * b = d, এই ফাংশনটি a এর সম্ভাব্য মান খুঁজে বের করে শর্ত সহ a <= b। যখন একাধিক জোড়া (a, b) সম্ভব হয়, এটি সবচেয়ে ছোট a সহ জোড়াটি ফেরত দেয়। যদি কোনো বৈধ জোড়া না থাকে, এটি -1 ফেরত দেয়।\n\nপ্যারামিটারসমূহ:\n- c (int): a এবং b এর যোগফল।\n- d (int): a এবং b এর গুণফল।\n\nফেরত:\n- int: a এর একটি সম্ভাব্য মান অথবা যদি কোনো বৈধ মান না থাকে তবে -1।\n\nউদাহরণ:\nfind_integers(7, 11) returns -1\nfind_integers(5, 6) returns 2",
      "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, тази функция\nнамира възможната стойност на a с условието a <= b. Когато са възможни множество\nдвойки (a, b), тя връща двойката с най-малко a.\nАко не съществува валидна двойка, тя връща -1.\n\nПараметри:\n- c (int): Сумата на a и b.\n- d (int): Произведението на a и b.\n\nВръща:\n- int: Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\nfind_integers(7, 11) връща -1\nfind_integers(5, 6) връща 2",
      "zh": "给定整数 c 和 d，其中 a + b = c 且 a * b = d，此函数在 a <= b 的条件下找到 a 的可能值。当存在多个 (a, b) 对时，返回具有最小 a 的对。如果不存在有效对，则返回 -1。\n\n参数:\n- c (int): a 和 b 的和。\n- d (int): a 和 b 的积。\n\n返回:\n- int: a 的可能值，如果不存在有效值则返回 -1。\n\n示例:\nfind_integers(7, 11) 返回 -1\nfind_integers(5, 6) 返回 2",
      "fr": "Étant donné des entiers c et d, où a + b = c et a * b = d, cette fonction\ntrouve la valeur possible de a avec la condition a <= b. Lorsqu'il existe plusieurs\npaires (a, b) possibles, elle renvoie la paire avec le plus petit a.\nSi aucune paire valide n'existe, elle renvoie -1.\n\nParamètres:\n- c (int): La somme de a et b.\n- d (int): Le produit de a et b.\n\nRenvoie:\n- int: Une valeur possible de a ou -1 si aucune valeur valide n'existe.\n\nExemples:\nfind_integers(7, 11) renvoie -1\nfind_integers(5, 6) renvoie 2",
      "de": "Gegeben ganze Zahlen c und d, wobei a + b = c und a * b = d, findet diese Funktion den möglichen Wert von a mit der Bedingung a <= b. Wenn mehrere Paare (a, b) möglich sind, gibt sie das Paar mit dem kleinsten a zurück. Wenn kein gültiges Paar existiert, gibt sie -1 zurück.\n\nParameter:\n- c (int): Die Summe von a und b.\n- d (int): Das Produkt von a und b.\n\nRückgabewert:\n- int: Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\nfind_integers(7, 11) gibt -1 zurück\nfind_integers(5, 6) gibt 2 zurück",
      "ha": "An ba da lambobin c da d, inda a + b = c kuma a * b = d, wannan aikin yana nemo yiwuwar ƙimar a tare da yanayin a <= b. Lokacin da dama-dama (a, b) suna yiwuwa, yana dawo da ma'aurata tare da ƙaramin a. Idan babu ma'aurata masu inganci, yana dawo da -1.\n\nParameters:\n- c (int): Jimillar a da b.\n- d (int): Samfurin a da b.\n\nReturns:\n- int: Yiwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n\nExamples:\nfind_integers(7, 11) returns -1\nfind_integers(5, 6) returns 2",
      "hi": "दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, यह फ़ंक्शन a के संभावित मान को ढूंढता है जिसमें शर्त a <= b होती है। जब कई जोड़े (a, b) संभव होते हैं, तो यह सबसे छोटे a वाले जोड़े को लौटाता है। यदि कोई वैध जोड़ा मौजूद नहीं है, तो यह -1 लौटाता है।\n\nपैरामीटर्स:\n- c (int): a और b का योग।\n- d (int): a और b का गुणनफल।\n\nवापसी:\n- int: a का एक संभावित मान या -1 यदि कोई वैध मान मौजूद नहीं है।\n\nउदाहरण:\nfind_integers(7, 11) -1 लौटाता है\nfind_integers(5, 6) 2 लौटाता है",
      "hu": "Adott c és d egész számok, ahol a + b = c és a * b = d, ez a függvény\nmegtalálja a lehetséges a értékét azzal a feltétellel, hogy a <= b. Ha több\n(a, b) pár lehetséges, akkor a legkisebb a értékű párt adja vissza.\nHa nem létezik érvényes pár, akkor -1-et ad vissza.\n\nParaméterek:\n- c (int): Az a és b összege.\n- d (int): Az a és b szorzata.\n\nVisszatérési érték:\n- int: Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\nfind_integers(7, 11) visszaadja -1\nfind_integers(5, 6) visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9928431487409319",
      "hy": "0.9974402502796034",
      "bn": "0.9925237510882279",
      "bg": "0.9965958725298241",
      "zh": "0.974436865851953",
      "fr": "0.9926375662965609",
      "de": "0.9890447399644018",
      "ha": "0.9713414099939053",
      "hi": "0.9881385881661207",
      "hu": "0.9656752797445041"
    }
  },
  {
    "task_id": "CPP/23",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n  \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nNumëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga\nnjë grup i dhënë i brinjëve.\n  \nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër arbitrar i argumenteve të plotë që përfaqësojnë gjatësitë e brinjëve.\n  \nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n  \nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nՀաշվել սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողերից\nտրված կողերի բազմությունից:\n  \nԱրգումենտներ:\n- edges_count: Փոխանցված կողերի քանակը:\n- Կողերի երկարությունները ներկայացնող ամբողջ թվերի կամայական քանակի արգումենտներ:\n  \nՎերադարձնում է:\nint: Տարբեր սուր անկյուն ունեցող եռանկյունիների քանակը, որոնք կարող են կազմվել:\n  \nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো 3 প্রান্ত নির্বাচন করে গঠিত তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা গণনা করুন।\n\nআর্গুমেন্টসমূহ:\n- edges_count: প্রেরিত প্রান্তের সংখ্যা।\n- প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী একটি ইচ্ছামত সংখ্যক পূর্ণসংখ্যার আর্গুমেন্ট।\n\nফেরত দেয়:\nint: গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা।\n\nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nБройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от\nдадена група ръбове.\n  \nАргументи:\n- edges_count: Броят на предадените ръбове.\n- Произволен брой цели числа, представляващи дължините на ръбовете.\n  \nВръща:\nint: Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n  \nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\n计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCompter le nombre de triangles aigus qui peuvent être formés en sélectionnant 3 arêtes parmi\nun ensemble donné d'arêtes.\n  \nArguments:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n  \nRenvoie:\nint: Le nombre de triangles aigus distincts qui peuvent être formés.\n  \nExemples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nZählt die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus\neinem gegebenen Satz von Kanten ausgewählt werden.\n  \nArgumente:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n  \nRückgabewert:\nint: Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n  \nBeispiele:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nƘididdige adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane 3 gefuna daga\nwani saitin gefuna da aka bayar.\n  \nArgs:\n- edges_count: Adadin gefuna da aka wuce.\n- Yawan hujjojin lamba na duk wani tsawon gefuna.\n  \nReturns:\nint: Adadin kusurwoyi masu kaifi na daban-daban waɗanda za a iya samarwa.\n  \nMisalai:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोणीय त्रिभुजों की संख्या गिनें।\n\nआर्ग्स:\n- edges_count: पास की गई किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले कई पूर्णांक तर्क।\n\nवापसी:\nint: बनने वाले विशिष्ट तीव्र कोणीय त्रिभुजों की संख्या।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nSzámolja meg a hegyesszögű háromszögek számát, amelyek a megadott élek halmazából bármely 3 él kiválasztásával képezhetők.\n  \nArgumentumok:\n- edges_count: A megadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n  \nVisszatér:\nint: A különböző hegyesszögű háromszögek száma, amelyek képezhetők.\n  \nPéldák:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)"
    },
    "prompt_bertscore": {
      "sq": "0.9690446468979989",
      "hy": "0.9604658007411021",
      "bn": "0.9736157278567548",
      "bg": "0.9605740542987661",
      "zh": "0.9427598885756522",
      "fr": "0.9697251545834245",
      "de": "0.9714474786173779",
      "ha": "0.9369106211149367",
      "hi": "0.9776324314220423",
      "hu": "0.9715515609370402"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}",
    "instruction": {
      "en": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) për kodin CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nПредоставете кратко описание на кода на CPP на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9327771228856008",
      "hy": "0.963562249751055",
      "bn": "0.8696780111118667",
      "bg": "0.8329214591013607",
      "zh": "0.904821312162758",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}",
    "entry_point": "count_acute_triangles",
    "signature": "int count_acute_triangles(int edges_count, ...)",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "sq": "Numëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\nArgumentet:\n- edges_count: Numri i brinjëve të dhëna.\n- Një numër i pacaktuar argumentesh të tipit integer që përfaqësojnë gjatësitë e brinjëve.\n\nKthen:\nint: Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hy": "Հաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են ձևավորվել տրված կողերի հավաքածուից ցանկացած 3 կող ընտրելով:\n\nԱրգումենտներ:\n- edges_count: Անցկացված կողերի քանակը:\n- Անհայտ քանակի ամբողջ թվային արգումենտներ, որոնք ներկայացնում են կողերի երկարությունները:\n\nՎերադարձնում է:\nint: Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են ձևավորվել:\n\nՕրինակներ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bn": "তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা গণনা করুন যা একটি প্রদত্ত প্রান্তের সেট থেকে যেকোনো 3 প্রান্ত নির্বাচন করে তৈরি করা যেতে পারে।\n\nআর্গুমেন্টসমূহ:\n- edges_count: প্রান্তের সংখ্যা যা প্রদান করা হয়েছে।\n- প্রান্তের দৈর্ঘ্য উপস্থাপনকারী একটি ইচ্ছামত সংখ্যক পূর্ণসংখ্যার আর্গুমেন্ট।\n\nফেরত দেয়:\nint: পৃথক তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা যা তৈরি করা যেতে পারে।\n\nউদাহরণ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "bg": "Бройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\nАргументи:\n- edges_count: Броят на подадените ръбове.\n- Произволен брой цели аргументи, представляващи дължините на ръбовете.\n\nВръща:\nint: Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "zh": "计算可以通过从给定的边集中选择任意3条边形成的锐角三角形的数量。\n\n参数：\n- edges_count: 传递的边的数量。\n- 任意数量的整数参数，表示边的长度。\n\n返回：\nint: 可以形成的不同锐角三角形的数量。\n\n示例：\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes quelconques parmi un ensemble donné d'arêtes.\n\nArgs:\n- edges_count: Le nombre d'arêtes passées.\n- Un nombre arbitraire d'arguments entiers représentant les longueurs des arêtes.\n\nReturns:\nint: Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einer gegebenen Menge von Kanten ausgewählt werden.\n\nArgs:\n- edges_count: Die Anzahl der übergebenen Kanten.\n- Eine beliebige Anzahl von ganzzahligen Argumenten, die die Längen der Kanten darstellen.\n\nReturns:\nint: Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "ha": "Kirga adadin kusurwoyi masu kaifi waɗanda za a iya samarwa ta zaɓar kowane 3 gefuna daga cikin wani saiti na gefuna.\n\nArgs:\n- edges_count: Adadin gefuna da aka bayar.\n- Yawan hujjojin lamba masu zaman kansu da ke wakiltar tsawon gefuna.\n\nReturns:\nint: Adadin kusurwoyi masu kaifi na daban-daban da za a iya samarwa.\n\nMisalai:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hi": "तीव्र कोण वाले त्रिभुजों की संख्या गिनें जो कि दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनाए जा सकते हैं।\n\nआर्ग्स:\n- edges_count: पास किए गए किनारों की संख्या।\n- किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांक तर्कों की एक मनमानी संख्या।\n\nरिटर्न्स:\nint: विशिष्ट तीव्र कोण वाले त्रिभुजों की संख्या जो बनाई जा सकती है।\n\nउदाहरण:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek úgy alakíthatók ki, hogy kiválasztunk bármely 3 élt egy adott élsorozatból.\n\nArgs:\n- edges_count: Az átadott élek száma.\n- Tetszőleges számú egész szám argumentum, amelyek az élek hosszát képviselik.\n\nReturns:\nint: Az alakítható különböző hegyesszögű háromszögek száma.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9453988918180817",
      "hy": "0.9178158853252909",
      "bn": "0.9661678830894705",
      "bg": "0.9348387076103618",
      "zh": "0.9322825332368239",
      "fr": "0.969193421053394",
      "de": "0.9560264117249723",
      "ha": "0.9387924453448613",
      "hi": "0.9855001808148341",
      "hu": "0.9709711629636563"
    }
  },
  {
    "task_id": "CPP/24",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * \n * Parameters:\n * - integer_value (int): The input integer.\n * - char_value (char): The input character.\n * \n * Returns:\n * - char*: A string containing the integer and character separated by a comma.\n * \n * Example:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "sq": "#include <bits/stdc++.h>\n/**\n * Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n * \n * Parametrat:\n * - integer_value (int): Numri i plotë i futur.\n * - char_value (char): Karakteri i futur.\n * \n * Kthen:\n * - char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n * \n * Shembull:\n * process_integer_and_char(234, 'H') kthen \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hy": "#include <bits/stdc++.h>\n/**\n * Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով:\n * \n * Պարամետրեր:\n * - integer_value (int): Մուտքային ամբողջ թիվը:\n * - char_value (char): Մուտքային սիմվոլը:\n * \n * Վերադարձնում է:\n * - char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, որոնք բաժանված են ստորակետով:\n * \n * Օրինակ:\n * process_integer_and_char(234, 'H') վերադարձնում է \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "bn": "#include <bits/stdc++.h>\n/**\n * একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে কমা দ্বারা পৃথক একটি ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\n * \n * প্যারামিটার:\n * - integer_value (int): ইনপুট পূর্ণসংখ্যা।\n * - char_value (char): ইনপুট অক্ষর।\n * \n * ফেরত দেয়:\n * - char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n * \n * উদাহরণ:\n * process_integer_and_char(234, 'H') \"234,H\" ফেরত দেয়\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "bg": "#include <bits/stdc++.h>\n/**\n * Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n * \n * Параметри:\n * - integer_value (int): Входното цяло число.\n * - char_value (char): Входният символ.\n * \n * Връща:\n * - char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n * \n * Пример:\n * process_integer_and_char(234, 'H') връща \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "zh": "#include <bits/stdc++.h>\n/**\n * 读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n * \n * 参数:\n * - integer_value (int): 输入的整数。\n * - char_value (char): 输入的字符。\n * \n * 返回:\n * - char*: 一个包含整数和字符并用逗号分隔的字符串。\n * \n * 示例:\n * process_integer_and_char(234, 'H') 返回 \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "fr": "#include <bits/stdc++.h>\n/**\n * Lit un entier et un caractère, puis les retourne sous forme de chaîne formatée séparée par une virgule.\n * \n * Paramètres :\n * - integer_value (int) : L'entier d'entrée.\n * - char_value (char) : Le caractère d'entrée.\n * \n * Renvoie :\n * - char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n * \n * Exemple :\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "de": "#include <bits/stdc++.h>\n/**\n * Liest eine Ganzzahl und ein Zeichen ein und gibt sie dann als formatierten String, getrennt durch ein Komma, zurück.\n * \n * Parameter:\n * - integer_value (int): Die Eingabe-Ganzzahl.\n * - char_value (char): Das Eingabe-Zeichen.\n * \n * Rückgabewert:\n * - char*: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n * \n * Beispiel:\n * process_integer_and_char(234, 'H') gibt \"234,H\" zurück\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "ha": "#include <bits/stdc++.h>\n/**\n * Karanta lamba da harafi, sannan ya mayar da su a matsayin igiyar rubutu mai tsari da aka raba ta alamar rubutu.\n * \n * Sigogi:\n * - integer_value (int): Lambar shigarwa.\n * - char_value (char): Harafin shigarwa.\n * \n * Komawa:\n * - char*: Igiyar rubutu mai dauke da lamba da harafi da aka raba ta alamar rubutu.\n * \n * Misali:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hi": "#include <bits/stdc++.h>\n/**\n * एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n * \n * पैरामीटर्स:\n * - integer_value (int): इनपुट पूर्णांक।\n * - char_value (char): इनपुट वर्ण।\n * \n * रिटर्न्स:\n * - char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग किए गए होते हैं।\n * \n * उदाहरण:\n * process_integer_and_char(234, 'H') \"234,H\" लौटाता है\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "hu": "#include <bits/stdc++.h>\n/**\n * Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott sztringként.\n * \n * Paraméterek:\n * - integer_value (int): A bemeneti egész szám.\n * - char_value (char): A bemeneti karakter.\n * \n * Visszatérési érték:\n * - char*: Egy sztring, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.\n * \n * Példa:\n * process_integer_and_char(234, 'H') visszaadja \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)"
    },
    "prompt_bertscore": {
      "sq": "0.9930145667597651",
      "hy": "1",
      "bn": "0.990070665882447",
      "bg": "0.9879921975752979",
      "zh": "1",
      "fr": "0.9969414893928248",
      "de": "0.9836555004661632",
      "ha": "0.9682390020725213",
      "hi": "0.9843145560704369",
      "hu": "0.9761576008428582"
    },
    "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}",
    "instruction": {
      "en": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, като използвате най-много 500 знака.",
      "zh": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9421149357284319",
      "hy": "0.9483094227913859",
      "bn": "0.8448917203840473",
      "bg": "0.8487568689686051",
      "zh": "0.980880895161363",
      "fr": "0.9172954737269795",
      "de": "0.9389289044166322",
      "ha": "0.9536396690664571",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}",
    "entry_point": "process_integer_and_char",
    "signature": "char* process_integer_and_char(int integer_value, char char_value)",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\n\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n\nExample:\nprocess_integer_and_char(234, 'H') returns \"234,H\"",
      "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n\nParametrat:\n- integer_value (int): Numri i plotë i dhënë si hyrje.\n- char_value (char): Karakteri i dhënë si hyrje.\n\nKthen:\n- char*: Një varg që përmban numrin e plotë dhe karakterin e ndarë me presje.\n\nShembull:\nprocess_integer_and_char(234, 'H') kthen \"234,H\"",
      "hy": "Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որոնք բաժանված են ստորակետով։\n\nՊարամետրեր:\n- integer_value (int): Մուտքային ամբողջ թիվը։\n- char_value (char): Մուտքային սիմվոլը։\n\nՎերադարձնում է:\n- char*: Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n\nՕրինակ:\nprocess_integer_and_char(234, 'H') վերադարձնում է \"234,H\"",
      "bn": "একটি পূর্ণসংখ্যা এবং একটি চরিত্র পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসাবে ফেরত দেয়।\n\nপ্যারামিটার:\n- integer_value (int): ইনপুট পূর্ণসংখ্যা।\n- char_value (char): ইনপুট চরিত্র।\n\nফেরত:\n- char*: একটি স্ট্রিং যা পূর্ণসংখ্যা এবং চরিত্রকে একটি কমা দ্বারা পৃথক করে ধারণ করে।\n\nউদাহরণ:\nprocess_integer_and_char(234, 'H') \"234,H\" ফেরত দেয়।",
      "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n\nПараметри:\n- integer_value (int): Входното цяло число.\n- char_value (char): Входният символ.\n\nВръща:\n- char*: Низ, съдържащ цялото число и символа, разделени със запетая.\n\nПример:\nprocess_integer_and_char(234, 'H') връща \"234,H\"",
      "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n\n参数：\n- integer_value (int): 输入的整数。\n- char_value (char): 输入的字符。\n\n返回：\n- char*: 一个包含整数和字符并用逗号分隔的字符串。\n\n示例：\nprocess_integer_and_char(234, 'H') 返回 \"234,H\"",
      "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n\nParamètres :\n- integer_value (int) : L'entier d'entrée.\n- char_value (char) : Le caractère d'entrée.\n\nRenvoie :\n- char* : Une chaîne contenant l'entier et le caractère séparés par une virgule.\n\nExemple :\nprocess_integer_and_char(234, 'H') renvoie \"234,H\"",
      "de": "Liest eine ganze Zahl und ein Zeichen ein und gibt sie als formatierten String getrennt durch ein Komma zurück.\n\nParameter:\n- integer_value (int): Die Eingabe-Ganzzahl.\n- char_value (char): Das Eingabe-Zeichen.\n\nRückgabe:\n- char*: Ein String, der die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n\nBeispiel:\nprocess_integer_and_char(234, 'H') gibt \"234,H\" zurück.",
      "ha": "Karanta wata lamba da wata alama, sannan ya mayar da su a matsayin wani tsari na rubutu da aka raba su da alamar kwafa.\n\nSigogi:\n- integer_value (int): Lambar shigarwa.\n- char_value (char): Alamar shigarwa.\n\nDawowa:\n- char*: Wani rubutu da ke dauke da lambar da alamar da aka raba su da alamar kwafa.\n\nMisali:\nprocess_integer_and_char(234, 'H') yana dawowa \"234,H\"",
      "hi": "एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n\nमापदंड:\n- integer_value (int): इनपुट पूर्णांक।\n- char_value (char): इनपुट वर्ण।\n\nवापसी:\n- char*: एक स्ट्रिंग जिसमें पूर्णांक और वर्ण अल्पविराम से अलग किए गए हैं।\n\nउदाहरण:\nprocess_integer_and_char(234, 'H') returns \"234,H\"",
      "hu": "Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott karakterláncként, vesszővel elválasztva.\n\nParaméterek:\n- integer_value (int): A bemeneti egész szám.\n- char_value (char): A bemeneti karakter.\n\nVisszatérési érték:\n- char*: Egy karakterlánc, amely az egész számot és a karaktert tartalmazza, vesszővel elválasztva.\n\nPélda:\nprocess_integer_and_char(234, 'H') visszaadja \"234,H\""
    },
    "docstring_bertscore": {
      "sq": "0.975905538889325",
      "hy": "1",
      "bn": "0.9845131864514718",
      "bg": "0.9911516124160389",
      "zh": "0.9924095386191328",
      "fr": "0.9961120089216231",
      "de": "0.9914557155294033",
      "ha": "0.9715998281196316",
      "hi": "0.9822640946470138",
      "hu": "0.973713652634605"
    }
  },
  {
    "task_id": "CPP/25",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "sq": "#include <bits/stdc++.h>\n/*\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen,\ndhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "hy": "#include <bits/stdc++.h>\n/*\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով: Միայն տառերն են փոխարինվում,\nև բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որի տառերը տեղափոխված են 5 դիրքով:\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "bn": "#include <bits/stdc++.h>\n/*\nবর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫টি অবস্থানে স্থানান্তরিত করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়,\nএবং সমস্ত অক্ষর বড় হাতের।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট, যা স্থানেই পরিবর্তিত হয়।\n\nফেরত দেয়:\nstd::string&: রূপান্তরিত টেক্সট যার অক্ষরগুলি ৫টি অবস্থানে স্থানান্তরিত হয়েছে।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "bg": "#include <bits/stdc++.h>\n/*\nПремества всички символи с 5 позиции в азбучен ред. Само буквите се заменят,\nи всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Трансформираният текст със символи, преместени с 5 позиции.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "zh": "#include <bits/stdc++.h>\n/*\n将所有字符在字母顺序中移动5个位置。仅替换字母，且所有字母均为大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，直接修改。\n\n返回：\nstd::string&: 字符移动了5个位置的转换后文本。\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "fr": "#include <bits/stdc++.h>\n/*\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées,\net toutes les lettres sont en majuscules.\n\nParamètres :\ntext (std::string&): Le texte d'entrée à traiter, modifié sur place.\n\nRetourne :\nstd::string&: Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "de": "#include <bits/stdc++.h>\n/*\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt,\nund alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der Eingabetext, der verarbeitet und vor Ort modifiziert wird.\n\nRückgabewert:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "ha": "#include <bits/stdc++.h>\n/*\nYa matsar da duk haruffa da matsayi 5 a cikin tsarin haruffa. Ana maye gurbin haruffa kawai,\nkuma duk haruffa suna cikin manyan baƙaƙe.\n\nSigogi:\ntext (std::string&): Rubutun shigarwa da za a sarrafa, an gyara shi a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "hi": "#include <bits/stdc++.h>\n/*\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है,\nऔर सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर संशोधित किया गया।\n\nरिटर्न्स:\nstd::string&: परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "hu": "#include <bits/stdc++.h>\n/*\nMinden karaktert 5 pozícióval eltol az ábécében. Csak a betűk kerülnek cserére,\nés minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amely helyben módosul.\n\nVisszatér:\nstd::string&: Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolódtak.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)"
    },
    "prompt_bertscore": {
      "sq": "0.990600611739048",
      "hy": "0.9782998295023195",
      "bn": "0.9722090274982657",
      "bg": "0.9943253286442143",
      "zh": "0.9453774397369299",
      "fr": "0.9940142734675137",
      "de": "0.9798350437173382",
      "ha": "0.9884113076792815",
      "hi": "0.9756391755483572",
      "hu": "0.969921600030268"
    },
    "canonical_solution": "{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}",
    "instruction": {
      "en": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\n请用不超过500个字符的中文提供对该CPP代码的简洁自然语言描述（文档字符串）。",
      "fr": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nBa da takaitaccen bayanin harshe na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.963562249751055",
      "bn": "0.8552647947728321",
      "bg": "0.9881575205401952",
      "zh": "0.9264431972951602",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9536396690664571",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}",
    "entry_point": "shift_characters",
    "signature": "std::string& shift_characters(std::string& text)",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\nParametrat:\ntext (std::string&): Teksti hyrës që do të përpunohet, modifikohet në vend.\n\nKthen:\nstd::string&: Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Տեղաշարժում է բոլոր տառերը 5 դիրքով այբենական կարգով: Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են:\n\nՊարամետրեր:\ntext (std::string&): Մուտքային տեքստը, որը պետք է մշակվի, փոփոխվում է տեղում:\n\nՎերադարձնում է:\nstd::string&: Փոխակերպված տեքստը, որտեղ տառերը տեղաշարժված են 5 դիրքով:\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে স্থানান্তর করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের হয়।\n\nপ্যারামিটার:\ntext (std::string&): প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট, যা স্থানে পরিবর্তিত হয়।\n\nরিটার্নস:\nstd::string&: পরিবর্তিত টেক্সট যেখানে অক্ষরগুলি ৫ অবস্থানে স্থানান্তরিত হয়েছে।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Измества всички знаци с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n\nПараметри:\ntext (std::string&): Входният текст, който ще бъде обработен, модифициран на място.\n\nВръща:\nstd::string&: Преобразуваният текст със знаци, изместени с 5 позиции.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "将所有字符在字母表中移动5个位置。仅替换字母，且所有字母均为大写。\n\n参数：\ntext (std::string&): 要处理的输入文本，原地修改。\n\n返回：\nstd::string&: 字符移动5个位置后的转换文本。\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\nParamètres :\ntext (std::string&) : Le texte d'entrée à traiter, modifié sur place.\n\nRenvoie :\nstd::string& : Le texte transformé avec les caractères décalés de 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\nParameter:\ntext (std::string&): Der zu verarbeitende Eingabetext, der vor Ort modifiziert wird.\n\nRückgabewert:\nstd::string&: Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Canza duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baki.\n\nSigogi:\ntext (std::string&): Rubutun shigar da za a sarrafa, a gyara a wurin.\n\nDawowa:\nstd::string&: Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "अक्षरों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\nपैरामीटर्स:\ntext (std::string&): इनपुट टेक्स्ट जिसे संसाधित किया जाना है, स्थान पर ही संशोधित किया जाता है।\n\nवापसी:\nstd::string&: परिवर्तित टेक्स्ट जिसमें अक्षर 5 स्थानों से स्थानांतरित होते हैं।\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Az összes karaktert 5 pozícióval eltolja az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\nParaméterek:\ntext (std::string&): A feldolgozandó bemeneti szöveg, amely helyben módosul.\n\nVisszatérési érték:\nstd::string&: Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "sq": "0.9893798294172076",
      "hy": "0.9760215390318493",
      "bn": "0.9393674802979572",
      "bg": "0.9936801771666129",
      "zh": "0.9595981832367416",
      "fr": "0.9872560733831827",
      "de": "0.9736747210799221",
      "ha": "0.9771151979098275",
      "hi": "0.9762537379472791",
      "hu": "0.9600429166598788"
    }
  },
  {
    "task_id": "CPP/26",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classify the integer x based on the following method:\n * If x is a single-digit number, x belongs to its own class.\n * Otherwise, sum the digits of x, get a new x, and iterate until \n * the class is determined.\n *\n * Parameters:\n * - x (const char*): The integer to be classified in string form.\n *\n * Returns:\n * int: The class to which the integer x belongs.\n *\n * Usage:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\n * Nëse x është një numër njëshifror, x i përket klasës së vet.\n * Përndryshe, mblidhni shifrat e x, merrni një x të ri, dhe përsëritni derisa \n * klasa të përcaktohet.\n *\n * Parametrat:\n * - x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n *\n * Kthen:\n * int: Klasa së cilës i përket numri i plotë x.\n *\n * Përdorimi:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Դասակարգել ամբողջ թիվը x-ը հետևյալ մեթոդով.\n * Եթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\n * Հակառակ դեպքում, գումարել x-ի թվանշանները, ստանալ նոր x և կրկնել, մինչև \n * դասը որոշվի։\n *\n * Պարամետրեր:\n * - x (const char*): Դասակարգվող ամբողջ թիվը տողային ձևով։\n *\n * Վերադարձնում է:\n * int: Դասը, որին պատկանում է ամբողջ թիվը x-ը։\n *\n * Օգտագործում:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * নিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\n * যদি x এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\n * অন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান এবং পুনরাবৃত্তি করুন যতক্ষণ না \n * শ্রেণী নির্ধারিত হয়।\n *\n * প্যারামিটার:\n * - x (const char*): স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যা।\n *\n * রিটার্নস:\n * int: যে শ্রেণীতে পূর্ণসংখ্যা x অন্তর্ভুক্ত।\n *\n * ব্যবহার:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Класифицирайте цялото число x въз основа на следния метод:\n * Ако x е едноцифрено число, x принадлежи към своя собствен клас.\n * В противен случай, съберете цифрите на x, получете ново x и \n * итерайте, докато класът не бъде определен.\n *\n * Параметри:\n * - x (const char*): Цялото число, което ще бъде класифицирано, в стрингова форма.\n *\n * Връща:\n * int: Класът, към който принадлежи цялото число x.\n *\n * Употреба:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * 根据以下方法对整数 x 进行分类：\n * 如果 x 是一位数，x 属于它自己的类。\n * 否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n *\n * 参数：\n * - x (const char*): 需要分类的整数，字符串形式。\n *\n * 返回：\n * int: 整数 x 所属的类别。\n *\n * 用法：\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classifier l'entier x basé sur la méthode suivante :\n * Si x est un nombre à un seul chiffre, x appartient à sa propre classe.\n * Sinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à \n * ce que la classe soit déterminée.\n *\n * Paramètres :\n * - x (const char*): L'entier à classifier sous forme de chaîne de caractères.\n *\n * Renvoie :\n * int: La classe à laquelle appartient l'entier x.\n *\n * Utilisation :\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Klassifiziere die ganze Zahl x basierend auf der folgenden Methode:\n * Wenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\n * Andernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, \n * bis die Klasse bestimmt ist.\n *\n * Parameter:\n * - x (const char*): Die zu klassifizierende ganze Zahl in String-Form.\n *\n * Rückgabewert:\n * int: Die Klasse, zu der die ganze Zahl x gehört.\n *\n * Verwendung:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Rarraba lamba x bisa ga hanyar da ke biye:\n * Idan x lamba ce mai lamba guda ɗaya, x tana cikin ajinta na kanta.\n * In ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai \n * an tantance ajin.\n *\n * Sigogi:\n * - x (const char*): Lambar da za a rarraba a cikin tsarin kirtani.\n *\n * Komawa:\n * int: Aji da lambar x take ciki.\n *\n * Amfani:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\n * यदि x एकल-अंक संख्या है, तो x अपने स्वयं के वर्ग का है।\n * अन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें \n * जब तक कि वर्ग निर्धारित न हो जाए।\n *\n * पैरामीटर:\n * - x (const char*): पूर्णांक को स्ट्रिंग रूप में वर्गीकृत करने के लिए।\n *\n * लौटाता है:\n * int: वह वर्ग जिसमें पूर्णांक x आता है।\n *\n * उपयोग:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Osztályozza az egész számot x az alábbi módszer alapján:\n * Ha x egyjegyű szám, akkor x a saját osztályába tartozik.\n * Ellenkező esetben összeadja x számjegyeit, kap egy új x-et, és ismétli, \n * amíg az osztály meg nem határozódik.\n *\n * Paraméterek:\n * - x (const char*): Az egész szám, amelyet osztályozni kell, sztring formában.\n *\n * Visszatér:\n * int: Az osztály, amelyhez az egész szám x tartozik.\n *\n * Használat:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)"
    },
    "prompt_bertscore": {
      "sq": "0.9913166742626788",
      "hy": "0.9869372716216216",
      "bn": "0.9622449330640316",
      "bg": "0.9935031974971109",
      "zh": "0.9809406204181783",
      "fr": "0.9846832140576377",
      "de": "0.9910517013343783",
      "ha": "0.9707798819067197",
      "hi": "0.9730055353262156",
      "hu": "0.9731584807196124"
    },
    "canonical_solution": "{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nՏվեք CPP կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 символа.",
      "zh": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.9697354833632382",
      "bn": "0.8439591507450884",
      "bg": "0.8365011292951701",
      "zh": "0.8753791003083301",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.9200759018007059",
      "hi": "0.9117634189847768",
      "hu": "0.8846646733609491"
    },
    "level": "",
    "test": "int main() {\n    assert(classify_integer(\"24\") == 6);\n    assert(classify_integer(\"39\") == 3);\n    assert(classify_integer(\"123456789\") == 9);\n    assert(classify_integer(\"123456789012345678901234567890\") == 9);\n    assert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    // std::printf(\"All tests passed successfully!\\n\");\n    return 0;\n}",
    "entry_point": "classify_integer",
    "signature": "int classify_integer(const char *x)",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (const char*): The integer to be classified in string form.\n\nReturns:\nint: The class to which the integer x belongs.\n\nUsage:\n>>> classify_integer(\"24\")\n6",
      "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër njëshifror, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\n\nParametrat:\n- x (const char*): Numri i plotë që do të klasifikohet në formë stringu.\n\nKthen:\nint: Klasa së cilës i përket numri i plotë x.\n\nPërdorimi:\n>>> classify_integer(\"24\")\n6",
      "hy": "Դասակարգեք ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x, և կրկնեք մինչև դասը որոշվի։\n\nՊարամետրեր:  \n- x (const char*): Թիվը, որը պետք է դասակարգվի տողի ձևով։\n\nՎերադարձնում է:  \nint: Դասը, որին պատկանում է թիվ x-ը։\n\nՕգտագործում:  \n>>> classify_integer(\"24\")  \n6",
      "bn": "ইন্টিজার x নিম্নলিখিত পদ্ধতির ভিত্তিতে শ্রেণীবদ্ধ করুন:\nযদি x একটি একক-অঙ্কের সংখ্যা হয়, তাহলে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nপ্যারামিটার:\n- x (const char*): স্ট্রিং আকারে শ্রেণীবদ্ধ করার জন্য ইন্টিজার।\n\nরিটার্নস:\nint: যে শ্রেণীতে ইন্টিজার x অন্তর্ভুক্ত।\n\nব্যবহার:\n>>> classify_integer(\"24\")\n6",
      "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът не бъде определен.\n\nПараметри:\n- x (const char*): Цялото число, което трябва да бъде класифицирано, във вид на низ.\n\nВръща:\nint: Класът, към който принадлежи цялото число x.\n\nУпотреба:\n>>> classify_integer(\"24\")\n6",
      "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一个个位数，则 x 属于它自己的类。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n\n参数：\n- x (const char*): 以字符串形式表示的要分类的整数。\n\n返回：\nint: 整数 x 所属的类。\n\n用法：\n>>> classify_integer(\"24\")\n6",
      "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (const char*): L'entier à classer sous forme de chaîne de caractères.\n\nRenvoie :\nint : La classe à laquelle appartient l'entier x.\n\nUtilisation :\n>>> classify_integer(\"24\")\n6",
      "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\n\nParameter:\n\n- x (const char*): The integer to be classified in string form.  \n  - x (const char*): Die ganze Zahl, die in String-Form klassifiziert werden soll.\n\nGibt zurück:\n\nint: Die Klasse, zu der die ganze Zahl x gehört.\n\nVerwendung:\n\n>>> classify_integer(\"24\")\n6",
      "ha": "Rarraba lambar x bisa ga hanyar mai zuwa:\nIdan x lamba ce mai ɗigo ɗaya, x na cikin aji nasa.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nParameters:\n- x (const char*): Lambar da za a tantance a cikin tsarin kirtani.\n\nReturns:\nint: Ajin da lambar x ta ke ciki.\n\nUsage:\n>>> classify_integer(\"24\")\n6",
      "hi": "निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एक एकल अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nParameters:\n- x (const char*): स्ट्रिंग रूप में वर्गीकृत की जाने वाली पूर्णांक।\n\nReturns:\nint: वह श्रेणी जिसमें पूर्णांक x आता है।\n\nUsage:\n>>> classify_integer(\"24\")\n6",
      "hu": "Osztályozza az x egész számot az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként összegezze x számjegyeit, kapjon egy új x-et, és ismételje meg, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (const char*): Az osztályozandó egész szám sztring formában.\n\nVisszatér:\nint: Az osztály, amelyhez az x egész szám tartozik.\n\nHasználat:\n>>> classify_integer(\"24\")\n6"
    },
    "docstring_bertscore": {
      "sq": "0.988345958283921",
      "hy": "0.9583047021954425",
      "bn": "0.9283226379605123",
      "bg": "0.9928590391714147",
      "zh": "0.9472463529920871",
      "fr": "0.9758012579392816",
      "de": "0.999999801369619",
      "ha": "0.9650519776088166",
      "hi": "0.9446921649223595",
      "hu": "0.980978956081718"
    }
  },
  {
    "task_id": "CPP/27",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Transforms the case of a given letter.\n * \n * If the input is a lowercase letter, it returns the uppercase version,\n * and if the input is an uppercase letter, it returns the lowercase version.\n * Non-alphabetic characters are returned unchanged.\n *\n * Usage:\n *   char result = transform_letter_case('b'); // result will be 'B'\n *   char result = transform_letter_case('B'); // result will be 'b'\n *\n * @param letter The input letter to be transformed.\n * @return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n */\nchar transform_letter_case(char letter)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Transformon shkronjën e dhënë në shkronjë të madhe ose të vogël.\n * \n * Nëse hyrja është një shkronjë e vogël, kthen versionin e saj në shkronjë të madhe,\n * dhe nëse hyrja është një shkronjë e madhe, kthen versionin e saj në shkronjë të vogël.\n * Karakteret jo-alfabetike kthehen të pandryshuara.\n *\n * Përdorimi:\n *   char result = transform_letter_case('b'); // rezultati do të jetë 'B'\n *   char result = transform_letter_case('B'); // rezultati do të jetë 'b'\n *\n * @param letter Shkronja e hyrjes që do të transformohet.\n * @return Shkronja me rastin e saj të ndryshuar nëse është alfabetike, përndryshe shkronja origjinale.\n */\nchar transform_letter_case(char letter)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Փոխակերպում է տրված տառի գրությունը։\n * \n * Եթե մուտքագրվածը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\n * իսկ եթե մուտքագրվածը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n * Այլ ոչ այբենական նիշերը վերադարձվում են անփոփոխ։\n *\n * Օգտագործում:\n *   char result = transform_letter_case('b'); // result-ը կլինի 'B'\n *   char result = transform_letter_case('B'); // result-ը կլինի 'b'\n *\n * @param letter Մուտքագրված տառը, որը պետք է փոխակերպվի։\n * @return Տառը՝ իր գրությունը փոխված, եթե այն այբենական է, հակառակ դեպքում՝ բնօրինակ տառը։\n */\nchar transform_letter_case(char letter)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n * \n * যদি ইনপুট একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়,\n * এবং যদি ইনপুট একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n * অ্যালফাবেটিক নয় এমন অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেওয়া হয়।\n *\n * ব্যবহার:\n *   char result = transform_letter_case('b'); // result হবে 'B'\n *   char result = transform_letter_case('B'); // result হবে 'b'\n *\n * @param letter রূপান্তর করার জন্য ইনপুট অক্ষর।\n * @return অক্ষরটি যদি অ্যালফাবেটিক হয় তবে তার কেস বিপরীত অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি।\n */\nchar transform_letter_case(char letter)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Преобразува регистъра на дадена буква.\n * \n * Ако входът е малка буква, връща главната версия,\n * и ако входът е главна буква, връща малката версия.\n * Неалфабетни символи се връщат непроменени.\n *\n * Употреба:\n *   char result = transform_letter_case('b'); // result ще бъде 'B'\n *   char result = transform_letter_case('B'); // result ще бъде 'b'\n *\n * @param letter Входната буква, която ще бъде преобразувана.\n * @return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.\n */\nchar transform_letter_case(char letter)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 转换给定字母的大小写。\n * \n * 如果输入是小写字母，则返回大写版本，\n * 如果输入是大写字母，则返回小写版本。\n * 非字母字符将原样返回。\n *\n * 用法：\n *   char result = transform_letter_case('b'); // result 将是 'B'\n *   char result = transform_letter_case('B'); // result 将是 'b'\n *\n * @param letter 要转换的输入字母。\n * @return 如果是字母则返回大小写转换后的字母，否则返回原始字母。\n */\nchar transform_letter_case(char letter)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Transforme la casse d'une lettre donnée.\n * \n * Si l'entrée est une lettre minuscule, elle renvoie la version majuscule,\n * et si l'entrée est une lettre majuscule, elle renvoie la version minuscule.\n * Les caractères non alphabétiques sont renvoyés inchangés.\n *\n * Utilisation :\n *   char result = transform_letter_case('b'); // result sera 'B'\n *   char result = transform_letter_case('B'); // result sera 'b'\n *\n * @param letter La lettre d'entrée à transformer.\n * @return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.\n */\nchar transform_letter_case(char letter)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Transformiert den Fall eines gegebenen Buchstabens.\n * \n * Wenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\n * und wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\n * Nicht-alphabetische Zeichen werden unverändert zurückgegeben.\n *\n * Verwendung:\n *   char result = transform_letter_case('b'); // result wird 'B' sein\n *   char result = transform_letter_case('B'); // result wird 'b' sein\n *\n * @param letter Der Eingabebuchstabe, der transformiert werden soll.\n * @return Der Buchstabe mit umgekehrtem Fall, wenn er alphabetisch ist, ansonsten der ursprüngliche Buchstabe.\n */\nchar transform_letter_case(char letter)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Canza harafin da aka bayar daga babba zuwa ƙanana ko akasin haka.\n * \n * Idan harafin da aka shigar yana cikin ƙananan baƙaƙe, zai mayar da shi zuwa babba,\n * kuma idan harafin yana cikin manyan baƙaƙe, zai mayar da shi zuwa ƙanana.\n * Haruffan da ba na alphabet ba za a mayar da su ba tare da canji ba.\n *\n * Amfani:\n *   char result = transform_letter_case('b'); // result zai zama 'B'\n *   char result = transform_letter_case('B'); // result zai zama 'b'\n *\n * @param letter Harafin da za a canza.\n * @return Harafin da aka juya idan yana cikin alphabet, in ba haka ba asalin harafin.\n */\nchar transform_letter_case(char letter)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए अक्षर का केस बदलता है।\n * \n * यदि इनपुट एक लोअरकेस अक्षर है, तो यह अपरकेस संस्करण लौटाता है,\n * और यदि इनपुट एक अपरकेस अक्षर है, तो यह लोअरकेस संस्करण लौटाता है।\n * गैर-अक्षरात्मक वर्ण बिना परिवर्तन के लौटाए जाते हैं।\n *\n * उपयोग:\n *   char result = transform_letter_case('b'); // result होगा 'B'\n *   char result = transform_letter_case('B'); // result होगा 'b'\n *\n * @param letter इनपुट अक्षर जिसे परिवर्तित करना है।\n * @return अक्षर जिसका केस उल्टा हो गया है यदि यह अक्षरात्मक है, अन्यथा मूल अक्षर।\n */\nchar transform_letter_case(char letter)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Átalakítja egy adott betű esetét.\n * \n * Ha a bemenet kisbetű, akkor visszaadja a nagybetűs változatát,\n * és ha a bemenet nagybetű, akkor visszaadja a kisbetűs változatát.\n * Nem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n *\n * Használat:\n *   char result = transform_letter_case('b'); // result 'B' lesz\n *   char result = transform_letter_case('B'); // result 'b' lesz\n *\n * @param letter Az átalakítandó bemeneti betű.\n * @return A betű ellentétes esettel, ha alfabetikus, különben az eredeti betű.\n */\nchar transform_letter_case(char letter)"
    },
    "prompt_bertscore": {
      "sq": "0.971567252737142",
      "hy": "0.967957741452976",
      "bn": "0.9766092863293315",
      "bg": "0.9826003758821059",
      "zh": "0.9392244664236121",
      "fr": "0.993002847567284",
      "de": "0.9888208835249754",
      "ha": "0.9180023992530826",
      "hi": "0.9883821090132694",
      "hu": "0.9760118061431786"
    },
    "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 символа.",
      "zh": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nBayar da takaitaccen bayani a cikin yare na halitta (docstring) na lambar CPP cikin Hausa, ba fiye da haruffa 500 ba.",
      "hi": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8439591507450884",
      "bg": "0.8365011292951701",
      "zh": "0.9028147480535435",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.9166689935051955",
      "hi": "0.9117634189847768",
      "hu": "0.9330776506521065"
    },
    "level": "",
    "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to print a success message (optional)\n    \n    return 0;\n}",
    "entry_point": "transform_letter_case",
    "signature": "char transform_letter_case(char letter)",
    "docstring": {
      "en": "Transforms the case of a given letter.\n\nIf the input is a lowercase letter, it returns the uppercase version,\nand if the input is an uppercase letter, it returns the lowercase version.\nNon-alphabetic characters are returned unchanged.\n\nUsage:\n  char result = transform_letter_case('b'); // result will be 'B'\n  char result = transform_letter_case('B'); // result will be 'b'\n\n@param letter The input letter to be transformed.\n@return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n",
      "sq": "Transformon shkronjën e dhënë në rast tjetër.\n\nNëse hyrja është një shkronjë e vogël, kthen versionin e saj me shkronja të mëdha,\ndhe nëse hyrja është një shkronjë e madhe, kthen versionin e saj me shkronja të vogla.\nKarakteret jo-alfabetike kthehen të pandryshuara.\n\nPërdorimi:\n  char result = transform_letter_case('b'); // rezultati do të jetë 'B'\n  char result = transform_letter_case('B'); // rezultati do të jetë 'b'\n\n@param letter Shkronja hyrëse që do të transformohet.\n@return Shkronja me rastin e saj të kthyer nëse është alfabetike, përndryshe shkronja origjinale.",
      "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n\nԵթե մուտքագրվածը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը,\nիսկ եթե մուտքագրվածը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\nԱյլ ոչ այբբենական նշանները վերադարձվում են առանց փոփոխության։\n\nՕգտագործում:\n  char result = transform_letter_case('b'); // result-ը կլինի 'B'\n  char result = transform_letter_case('B'); // result-ը կլինի 'b'\n\n@param letter Մուտքագրված տառը, որը պետք է փոխակերպվի։\n@return Տառը՝ իր ռեգիստրով փոխված, եթե այն այբբենական է, հակառակ դեպքում՝ բնօրինակ տառը։",
      "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nযদি ইনপুটটি একটি ছোট হাতের অক্ষর হয়, এটি বড় হাতের সংস্করণটি ফেরত দেয়,\nএবং যদি ইনপুটটি একটি বড় হাতের অক্ষর হয়, এটি ছোট হাতের সংস্করণটি ফেরত দেয়।\nঅ্যালফাবেটিক নয় এমন অক্ষর অপরিবর্তিত অবস্থায় ফেরত দেওয়া হয়।\n\nব্যবহার:\n  char result = transform_letter_case('b'); // result হবে 'B'\n  char result = transform_letter_case('B'); // result হবে 'b'\n\n@param letter রূপান্তর করার জন্য ইনপুট অক্ষর।\n@return অক্ষরটি যদি অ্যালফাবেটিক হয় তবে তার কেস উল্টানো অবস্থায় ফেরত দেয়, অন্যথায় মূল অক্ষরটি।",
      "bg": "Преобразува регистъра на дадена буква.\n\nАко входът е малка буква, връща главната версия,\nа ако входът е главна буква, връща малката версия.\nНеалфабетните символи се връщат непроменени.\n\nУпотреба:\n  char result = transform_letter_case('b'); // result ще бъде 'B'\n  char result = transform_letter_case('B'); // result ще бъде 'b'\n\n@param letter Входната буква, която ще бъде преобразувана.\n@return Буквата с обърнат регистър, ако е алфабетна, в противен случай оригиналната буква.",
      "zh": "将给定字母的大小写转换。\n\n如果输入是小写字母，则返回大写版本，\n如果输入是大写字母，则返回小写版本。\n非字母字符将保持不变。\n\n用法:\n  char result = transform_letter_case('b'); // result 将是 'B'\n  char result = transform_letter_case('B'); // result 将是 'b'\n\n@param letter 要转换的输入字母。\n@return 如果是字母，则返回大小写反转的字母，否则返回原始字母。",
      "fr": "Transforme la casse d'une lettre donnée.\n\nSi l'entrée est une lettre minuscule, elle retourne la version majuscule,\net si l'entrée est une lettre majuscule, elle retourne la version minuscule.\nLes caractères non alphabétiques sont retournés inchangés.\n\nUtilisation :\n  char result = transform_letter_case('b'); // result sera 'B'\n  char result = transform_letter_case('B'); // result sera 'b'\n\n@param letter La lettre d'entrée à transformer.\n@return La lettre avec sa casse inversée si elle est alphabétique, sinon la lettre originale.",
      "de": "Verändert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nWenn die Eingabe ein Kleinbuchstabe ist, wird die Großbuchstabenversion zurückgegeben,\nund wenn die Eingabe ein Großbuchstabe ist, wird die Kleinbuchstabenversion zurückgegeben.\nNicht-alphabetische Zeichen werden unverändert zurückgegeben.\n\nVerwendung:\n  char result = transform_letter_case('b'); // result wird 'B' sein\n  char result = transform_letter_case('B'); // result wird 'b' sein\n\n@param letter Der Eingabebuchstabe, der umgewandelt werden soll.\n@return Der Buchstabe mit umgekehrter Groß-/Kleinschreibung, wenn er alphabetisch ist, andernfalls der ursprüngliche Buchstabe.",
      "ha": "Canza harafin da aka bayar daga babba zuwa ƙanana ko daga ƙanana zuwa babba.\n\nIdan harafin da aka shigar harafi ne ƙarami, zai mayar da shi babba,\nkuma idan harafin da aka shigar babba ne, zai mayar da shi ƙarami.\nHaruffan da ba na haruffa ba za a mayar da su ba tare da canji ba.\n\nAmfani:\n  char result = transform_letter_case('b'); // sakamakon zai zama 'B'\n  char result = transform_letter_case('B'); // sakamakon zai zama 'b'\n\n@param letter Harafin da aka shigar da za a canza.\n@return Harafin da aka juya yanayin idan harafi ne, in ba haka ba asalin harafin.",
      "hi": "दिए गए अक्षर के मामले को बदलता है।\n\nयदि इनपुट एक लोअरकेस अक्षर है, तो यह अपरकेस संस्करण लौटाता है,\nऔर यदि इनपुट एक अपरकेस अक्षर है, तो यह लोअरकेस संस्करण लौटाता है।\nगैर-अक्षरीय वर्ण अपरिवर्तित लौटाए जाते हैं।\n\nउपयोग:\n  char result = transform_letter_case('b'); // result होगा 'B'\n  char result = transform_letter_case('B'); // result होगा 'b'\n\n@param letter वह इनपुट अक्षर जिसे बदला जाना है।\n@return अक्षर जिसका मामला उलटा गया है यदि यह अक्षरीय है, अन्यथा मूल अक्षर।",
      "hu": "Átalakítja egy adott betű kis- és nagybetűs formáját.\n\nHa a bemenet kisbetű, akkor a nagybetűs változatát adja vissza,\nés ha a bemenet nagybetű, akkor a kisbetűs változatát adja vissza.\nA nem alfabetikus karakterek változatlanul kerülnek visszaadásra.\n\nHasználat:\n  char result = transform_letter_case('b'); // result 'B' lesz\n  char result = transform_letter_case('B'); // result 'b' lesz\n\n@param letter Az átalakítandó bemeneti betű.\n@return A betű megfordított kis- és nagybetűs változata, ha alfabetikus, különben az eredeti betű."
    },
    "docstring_bertscore": {
      "sq": "0.982072217698934",
      "hy": "0.977778623382484",
      "bn": "0.9860374759955336",
      "bg": "0.9871601349091428",
      "zh": "0.9513059607196782",
      "fr": "0.9796276735995377",
      "de": "0.9730917409115847",
      "ha": "0.9405296666573925",
      "hi": "0.984855426597995",
      "hu": "0.9750947296739405"
    }
  },
  {
    "task_id": "CPP/28",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Displays the ASCII information for a given character.\n * \n * @param character The input character for which ASCII information is to be displayed.\n * @return The corresponding ASCII code.\n * \n * Example:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Shfaq informacionin ASCII për një karakter të dhënë.\n * \n * @param character Karakteri i hyrjes për të cilin informacioni ASCII duhet të shfaqet.\n * @return Kodi përkatës ASCII.\n * \n * Shembull:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Ցուցադրում է տրված սիմվոլի ASCII տեղեկատվությունը։\n * \n * @param character Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n * @return Համապատասխանող ASCII կոդը։\n * \n * Օրինակ:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n * \n * @param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n * @return সংশ্লিষ্ট ASCII কোড।\n * \n * উদাহরণ:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Показва ASCII информацията за даден символ.\n * \n * @param character Входният символ, за който ще се покаже ASCII информацията.\n * @return Съответстващият ASCII код.\n * \n * Пример:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 显示给定字符的ASCII信息。\n * \n * @param character 要显示ASCII信息的输入字符。\n * @return 对应的ASCII码。\n * \n * 示例:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // 输出: 65\n * ```\n */\nint display_ascii_info(char character)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Affiche les informations ASCII pour un caractère donné.\n * \n * @param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n * @return Le code ASCII correspondant.\n * \n * Exemple:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n * \n * @param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n * @return Der entsprechende ASCII-Code.\n * \n * Beispiel:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Ausgabe: 65\n * ```\n */\nint display_ascii_info(char character)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Nuna bayanin ASCII don wata alama da aka bayar.\n * \n * @param character Alamar shigarwa wanda za a nuna bayanin ASCII.\n * @return Lambar ASCII da ta dace.\n * \n * Misali:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करता है।\n * \n * @param character वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n * @return संबंधित ASCII कोड।\n * \n * उदाहरण:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Megjeleníti egy adott karakter ASCII információit.\n * \n * @param character Az a bemeneti karakter, amelynek az ASCII információit meg kell jeleníteni.\n * @return A megfelelő ASCII kód.\n * \n * Példa:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Kimenet: 65\n * ```\n */\nint display_ascii_info(char character)"
    },
    "prompt_bertscore": {
      "sq": "0.9827175678069164",
      "hy": "0.9890064043008621",
      "bn": "0.9704940527884105",
      "bg": "0.9939854720622636",
      "zh": "0.9518901326703018",
      "fr": "0.990065104231778",
      "de": "0.9940005679712223",
      "ha": "0.9776161437307974",
      "hi": "0.9862551748931478",
      "hu": "0.9861447364012924"
    },
    "canonical_solution": "{\n    return character;\n}",
    "instruction": {
      "en": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "int display_ascii_info(char character)\n{\n    return character;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin harshen Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9232384947275433",
      "bn": "0.8867794910278275",
      "bg": "0.8329214591013607",
      "zh": "0.9087695938105666",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.9330776506521065"
    },
    "level": "",
    "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    \n    // Uncomment the line below to print a success message if compiled outside a test framework\n    // std::printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
    "entry_point": "display_ascii_info",
    "signature": "int display_ascii_info(char character)",
    "docstring": {
      "en": "Displays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.\n\nExample:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\n@param character Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n@return Kodi përkatës ASCII.\n\nShembull:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "hy": "Տպում է ASCII տեղեկատվությունը տրված սիմվոլի համար։\n\n@param character Մուտքային սիմվոլը, որի համար պետք է տպել ASCII տեղեկատվությունը։\n@return Համապատասխանող ASCII կոդը։\n\nՕրինակ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "bn": "একটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করে।\n\n@param character ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n@return সংশ্লিষ্ট ASCII কোড।\n\nউদাহরণ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "bg": "Показва ASCII информацията за даден символ.\n\n@param character Входният символ, за който трябва да се покаже ASCII информацията.\n@return Съответният ASCII код.\n\nПример:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Изход: 65\n```",
      "zh": "显示给定字符的ASCII信息。\n\n@param character 要显示ASCII信息的输入字符。\n@return 对应的ASCII代码。\n\n示例：\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // 输出: 65\n```",
      "fr": "Affiche les informations ASCII pour un caractère donné.\n\n@param character Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n@return Le code ASCII correspondant.\n\nExemple :\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Sortie : 65\n```",
      "de": "Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n\n@param character Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n@return Der entsprechende ASCII-Code.\n\nBeispiel:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Ausgabe: 65\n```",
      "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\n@param character Harafin shigarwa wanda za a nuna bayanin ASCII.\n@return Lambar ASCII da ta dace.\n\nMisali:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65\n```",
      "hi": "दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करता है।\n\n@param character वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n@return संबंधित ASCII कोड।\n\nउदाहरण:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // आउटपुट: 65\n```",
      "hu": "Megjeleníti a megadott karakter ASCII információját.\n\n@param character A bemeneti karakter, amelynek az ASCII információját meg kell jeleníteni.\n@return A megfelelő ASCII kód.\n\nPélda:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Kimenet: 65\n```"
    },
    "docstring_bertscore": {
      "sq": "0.976076162386634",
      "hy": "0.9617837133192686",
      "bn": "0.9489432523372682",
      "bg": "0.9813809839729327",
      "zh": "0.9666525412191957",
      "fr": "0.9766380877345816",
      "de": "0.9909029271789832",
      "ha": "0.9526961747565413",
      "hi": "0.9902782346306285",
      "hu": "0.9758101963064282"
    }
  },
  {
    "task_id": "CPP/29",
    "prompt": {
      "en": "#include <cassert> // Used for making assertions in test cases\n/**\n * @brief Evaluate the grade for an input integer.\n * \n * @param score The integer score to be evaluated.\n * @return char The grade corresponding to the input score.\n *              If the score is between 90 and 100 (inclusive), returns 'A'.\n *              Otherwise, returns 'B'.\n * \n * Examples:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "sq": "#include <cassert> // Përdoret për të bërë pohime në rastet e testimit\n/**\n * @brief Vlerëson notën për një numër të plotë hyrës.\n * \n * @param score Nota e plotë që do të vlerësohet.\n * @return char Nota që korrespondon me notën hyrëse.\n *              Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n *              Përndryshe, kthen 'B'.\n * \n * Shembuj:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "hy": "#include <cassert> // Օգտագործվում է թեստային դեպքերում հաստատումներ կատարելու համար\n/**\n * @brief Գնահատել գնահատականը մուտքային ամբողջ թվի համար։\n * \n * @param score Գնահատման ենթակա ամբողջ թիվը։\n * @return char Մուտքային գնահատականին համապատասխանող գնահատականը։\n *              Եթե գնահատականը 90-ից 100 միջակայքում է (ներառյալ), վերադարձնում է 'A'։\n *              Հակառակ դեպքում, վերադարձնում է 'B'։\n * \n * Օրինակներ:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "bn": "#include <cassert> // টেস্ট কেসে অ্যাসারশন করার জন্য ব্যবহৃত\n\n/**\n * @brief একটি পূর্ণসংখ্যার জন্য গ্রেড নির্ধারণ করুন।\n * \n * @param score মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n * @return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n *              যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তবে 'A' প্রদান করে।\n *              অন্যথায়, 'B' প্রদান করে।\n * \n * উদাহরণ:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "bg": "#include <cassert> // Използва се за правене на твърдения в тестовите случаи\n/**\n * @brief Оценява оценката за входно цяло число.\n * \n * @param score Цялото число, което трябва да бъде оценено.\n * @return char Оценката, съответстваща на входното число.\n *              Ако числото е между 90 и 100 (включително), връща 'A'.\n *              В противен случай връща 'B'.\n * \n * Примери:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "zh": "#include <cassert> // 用于在测试用例中进行断言\n/**\n * @brief 评估输入整数的等级。\n * \n * @param score 要评估的整数分数。\n * @return char 与输入分数对应的等级。\n *              如果分数在90到100之间（包括90和100），返回'A'。\n *              否则，返回'B'。\n * \n * 示例:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "fr": "#include <cassert> // Utilisé pour faire des assertions dans les cas de test\n/**\n * @brief Évaluer la note pour un entier en entrée.\n * \n * @param score Le score entier à évaluer.\n * @return char La note correspondant au score d'entrée.\n *              Si le score est entre 90 et 100 (inclus), retourne 'A'.\n *              Sinon, retourne 'B'.\n * \n * Exemples:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "de": "#include <cassert> // Wird für die Erstellung von Assertions in Testfällen verwendet\n/**\n * @brief Bewertet die Note für eine Eingabezahl.\n * \n * @param score Die zu bewertende Ganzzahl.\n * @return char Die Note, die der Eingabezahl entspricht.\n *              Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n *              Andernfalls wird 'B' zurückgegeben.\n * \n * Beispiele:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "ha": "#include <cassert> // Ana amfani da wannan don yin tabbaci a cikin gwaje-gwaje\n\n/**\n * @brief Kimanta darajar maki na adadi.\n * \n * @param score Maki na adadi da za a kimanta.\n * @return char Darajar da ta dace da maki da aka shigar.\n *              Idan maki yana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n *              In ba haka ba, zai dawo da 'B'.\n * \n * Misalai:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */ \nchar evaluate_integer_grade(int score)",
      "hi": "#include <cassert> // परीक्षण मामलों में दावे करने के लिए उपयोग किया जाता है\n/**\n * @brief एक इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n * \n * @param score मूल्यांकन के लिए पूर्णांक स्कोर।\n * @return char इनपुट स्कोर के अनुरूप ग्रेड।\n *              यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n *              अन्यथा, 'B' लौटाता है।\n * \n * उदाहरण:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "hu": "#include <cassert> // Használva az állítások megfogalmazására tesztesetekben\n/**\n * @brief Értékeli a bemeneti egész szám osztályzatát.\n * \n * @param score Az értékelendő egész szám pontszám.\n * @return char Az osztályzat, amely megfelel a bemeneti pontszámnak.\n *              Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n *              Egyébként 'B'-t ad vissza.\n * \n * Példák:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)"
    },
    "prompt_bertscore": {
      "sq": "0.9961201527672455",
      "hy": "0.990725351618338",
      "bn": "0.9673251036893799",
      "bg": "0.9765584369517867",
      "zh": "0.9745872290503964",
      "fr": "0.9949381033697069",
      "de": "0.9679257619616294",
      "ha": "0.962663248646491",
      "hi": "0.9645301755978379",
      "hu": "0.9836477538813029"
    },
    "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}",
    "instruction": {
      "en": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 символа.",
      "zh": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9056722197199609",
      "hy": "0.9401782895133417",
      "bn": "0.8566738786958936",
      "bg": "0.8365011292951701",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9536396690664571",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(evaluate_integer_grade(90) == 'A'); // Test for lower bound of 'A' grade\n    assert(evaluate_integer_grade(89) == 'B'); // Test for score just below 'A' grade\n    assert(evaluate_integer_grade(95) == 'A'); // Test for a score well within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Test for upper boundary of 'A' grade\n    assert(evaluate_integer_grade(101) == 'B'); // Test for score above 'A' grade range\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // std::cout << \"All tests passed\\n\";\n\n    return 0;\n}",
    "entry_point": "evaluate_integer_grade",
    "signature": "char evaluate_integer_grade(int score)",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n\n@param score The integer score to be evaluated.\n@return char The grade corresponding to the input score.\n             If the score is between 90 and 100 (inclusive), returns 'A'.\n             Otherwise, returns 'B'.\n\nExamples:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'\n",
      "sq": "Vlerësoni notën për një numër të plotë hyrës.\n\n@param score Numri i plotë i pikëve që do të vlerësohet.\n@return char Nota që korrespondon me pikët hyrëse.\n             Nëse pikët janë midis 90 dhe 100 (përfshirë), kthen 'A'.\n             Përndryshe, kthen 'B'.\n\nShembuj:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hy": "Հաշվարկել գնահատականը մուտքային ամբողջ թվի համար։\n\n@param score Գնահատվող ամբողջ թվային միավորը։\n@return char Մուտքային միավորին համապատասխան գնահատականը։\n             Եթե միավորը 90-ից 100-ի (ներառյալ) միջև է, վերադարձնում է 'A'։\n             Հակառակ դեպքում, վերադարձնում է 'B'։\n\nՕրինակներ:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "bn": "একটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n\n@param score মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n@return char ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n             যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), তবে 'A' ফেরত দেয়।\n             অন্যথায়, 'B' ফেরত দেয়।\n\nউদাহরণ:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "bg": "Оценете оценката за входящо цяло число.\n\n@param score Цялото число, което трябва да бъде оценено.\n@return char Оценката, съответстваща на входящия резултат.\n             Ако резултатът е между 90 и 100 (включително), връща 'A'.\n             В противен случай връща 'B'.\n\nПримери:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "zh": "评估输入整数的等级。\n\n@param score 要评估的整数分数。\n@return char 与输入分数对应的等级。\n如果分数在90到100之间（包括90和100），返回'A'。\n             否则，返回'B'。\n\n示例：\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "fr": "Évaluer la note pour un entier en entrée.\n\n@param score L'entier score à évaluer.\n@return char La note correspondant au score d'entrée.\n             Si le score est entre 90 et 100 (inclus), retourne 'A'.\n             Sinon, retourne 'B'.\n\nExemples :\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n\n@param score Die ganzzahlige Punktzahl, die bewertet werden soll.\n@return char Die Note, die der eingegebenen Punktzahl entspricht.\n             Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n             Andernfalls wird 'B' zurückgegeben.\n\nBeispiele:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "ha": "Kimanta darajar don shigar da cikakken lamba.\n\n@param score Lambar da za a tantance.\n@return char Darajar da ta dace da lambar shigarwa.\n             Idan lambar tana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n             In ba haka ba, yana dawowa 'B'.\n\nMisalai:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n\n@param score मूल्यांकन के लिए पूर्णांक स्कोर।\n@return char इनपुट स्कोर के अनुरूप ग्रेड।\n             यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n             अन्यथा, 'B' लौटाता है।\n\nउदाहरण:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "hu": "Értékelje egy bemeneti egész szám osztályzatát.\n\n@param score Az értékelendő egész szám pontszám.\n@return char Az osztályzat, amely megfelel a bemeneti pontszámnak.\n             Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n             Egyébként 'B'-t ad vissza.\n\nPéldák:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'"
    },
    "docstring_bertscore": {
      "sq": "0.9657807524768336",
      "hy": "0.9825666087173299",
      "bn": "0.9604497116802383",
      "bg": "0.9594641077295432",
      "zh": "0.9644461549466602",
      "fr": "0.9938839719375547",
      "de": "0.9662707736268467",
      "ha": "0.9750015720252352",
      "hi": "0.9465759754560944",
      "hu": "0.9959644265485141"
    }
  },
  {
    "task_id": "CPP/30",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Checks if a three-character string has exactly two characters that are the same.\n * \n * @param s A three-character string to be checked.\n * \n * @return Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n * Examples:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "sq": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n * \n * @param s Një varg me tre karaktere që do të kontrollohet.\n * \n * @return Kthen \"Yes\" nëse hyrja ka saktësisht dy karaktere të barabartë, përndryshe \"No\".\n * Shembuj:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "hy": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույնական նիշ:\n * \n * @param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի:\n * \n * @return Վերադարձնում է \"Yes\", եթե մուտքագրումը ունի հենց երկու հավասար նիշ, այլապես \"No\":\n * Օրինակներ:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "bn": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিংয়ে ঠিক দুটি অক্ষর একই কি না।\n * \n * @param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n * \n * @return \"Yes\" রিটার্ন করে যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে, অন্যথায় \"No\"।\n * উদাহরণ:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "bg": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Проверява дали низ от три знака има точно два еднакви знака.\n * \n * @param s Низ от три знака, който да бъде проверен.\n * \n * @return Връща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\n * Примери:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "zh": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * 检查一个三字符的字符串是否有且仅有两个字符相同。\n * \n * @param s 要检查的三字符字符串。\n * \n * @return 如果输入有且仅有两个相同的字符，返回 \"Yes\"，否则返回 \"No\"。\n * 示例:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "fr": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n * \n * @param s Une chaîne de trois caractères à vérifier.\n * \n * @return Renvoie \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\n * Exemples :\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "de": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Überprüft, ob ein drei Zeichen langer String genau zwei gleiche Zeichen hat.\n * \n * @param s Ein drei Zeichen langer String, der überprüft werden soll.\n * \n * @return Gibt \"Yes\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"No\".\n * Beispiele:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "ha": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Duba idan wata kirtani mai haruffa uku tana da ainihin haruffa biyu da suke daidai.\n * \n * @param s Wata kirtani mai haruffa uku da za a duba.\n * \n * @return Ya dawo da \"Yes\" idan shigarwar tana da ainihin haruffa biyu masu daidai, in ba haka ba \"No\".\n * Misalai:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "hi": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * जाँचता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n * \n * @param s एक तीन-अक्षरों की स्ट्रिंग जिसे जाँचना है।\n * \n * @return \"Yes\" लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा \"No\"।\n * उदाहरण:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "hu": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Ellenőrzi, hogy egy három karakterből álló stringben pontosan két azonos karakter van-e.\n * \n * @param s Egy három karakterből álló string, amelyet ellenőrizni kell.\n * \n * @return Visszatér \"Yes\"-szel, ha a bemenetben pontosan két egyenlő karakter van, különben \"No\"-val.\n * Példák:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])"
    },
    "prompt_bertscore": {
      "sq": "0.9900500083228193",
      "hy": "0.9857276126011192",
      "bn": "0.9794794953352857",
      "bg": "0.9728015419248928",
      "zh": "0.9556502057832922",
      "fr": "0.971561889716854",
      "de": "0.9813029222331859",
      "ha": "0.979822927264095",
      "hi": "0.9669314182741687",
      "hu": "0.9808520312682367"
    },
    "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, като използвате максимум 500 знака.",
      "zh": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9385419724343763",
      "hy": "0.8914036062983197",
      "bn": "0.8665912949905846",
      "bg": "0.8487568689686051",
      "zh": "0.8753791003083301",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}",
    "entry_point": "check_two_equal_digits",
    "signature": "const char* check_two_equal_digits(const char s[4])",
    "docstring": {
      "en": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n@param s A three-character string to be checked.\n \nReturns:\nReturns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\nExamples:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"\n",
      "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nParametrat:\n@param s Një varg me tre karaktere që do të kontrollohet.\n\nKthen:\nKthen \"Po\" nëse hyrja ka saktësisht dy karaktere të barabarta, përndryshe \"Jo\".\nShembuj:\n  >>> check_two_equal_digits(\"112\")\n  \"Po\"\n  >>> check_two_equal_digits(\"123\")\n  \"Jo\"",
      "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույն նիշ:\n\nՊարամետրեր:\n@param s Երեք նիշից բաղկացած տող, որը պետք է ստուգվի:\n\nՎերադարձնում է:\nՎերադարձնում է \"Yes\", եթե մուտքագրվածը ունի հենց երկու հավասար նիշ, հակառակ դեպքում՝ \"No\":\nՕրինակներ:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "bn": "পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিংয়ে ঠিক দুটি অক্ষর একই আছে কিনা।\n\nপ্যারামিটারসমূহ:\n@param s একটি তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nফেরত দেয়:\nযদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে \"Yes\" ফেরত দেয়, অন্যথায় \"No\"।\n\nউদাহরণসমূহ:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "bg": "Проверява дали низ с три знака има точно два еднакви знака.\n\nПараметри:\n@param s Низ с три знака, който да бъде проверен.\n\nВръща:\nВръща \"Yes\", ако входът има точно два еднакви знака, в противен случай \"No\".\nПримери:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数：\n@param s 要检查的三字符字符串。\n\n返回：\n如果输入恰好有两个相同的字符，则返回 \"Yes\"，否则返回 \"No\"。\n\n示例：\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nParamètres:\n@param s Une chaîne de trois caractères à vérifier.\n\nRetourne:\nRetourne \"Yes\" si l'entrée a exactement deux caractères égaux, sinon \"No\".\nExemples:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "de": "Prüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nParameter:\n@param s Ein dreistelliger String, der überprüft werden soll.\n\nRückgabe:\nGibt \"Ja\" zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls \"Nein\".\nBeispiele:\n  >>> check_two_equal_digits(\"112\")\n  \"Ja\"\n  >>> check_two_equal_digits(\"123\")\n  \"Nein\"",
      "ha": "Duba idan kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n\nSigogi:\n@param s Wani kirtani mai haruffa uku da za a duba.\n\nDawowa:\nYana dawowa \"Yes\" idan shigarwar tana da daidai haruffa biyu masu daidaituwa, in ba haka ba \"No\".\n\nMisalai:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "hi": "तीन-अक्षरों की स्ट्रिंग में जांच करता है कि क्या इसमें ठीक दो अक्षर समान हैं।\n\nपैरामीटर्स:\n@param s एक तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nवापसी:\nयदि इनपुट में ठीक दो समान अक्षर हैं तो \"Yes\" लौटाता है, अन्यथा \"No\"।\n\nउदाहरण:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "hu": "Ellenőrzi, hogy egy három karakter hosszú stringben pontosan két azonos karakter van-e.\n\nParaméterek:\n@param s Egy három karakter hosszú string, amelyet ellenőrizni kell.\n\nVisszatérési érték:\n\"Yes\"-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben \"No\"-t.\n\nPéldák:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\""
    },
    "docstring_bertscore": {
      "sq": "0.984314754700818",
      "hy": "0.9544774920136623",
      "bn": "0.9862629214780082",
      "bg": "0.9591369634919786",
      "zh": "0.9397182615508649",
      "fr": "0.9723828290816712",
      "de": "0.9523398318529648",
      "ha": "0.9492330540631981",
      "hi": "0.9303734966446975",
      "hu": "0.9736328100695237"
    }
  },
  {
    "task_id": "CPP/31",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n * \n * Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "sq": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Duke pasur një varg që përbëhet nga shkronjat e vogla të anglishtes, në secilën raund mund të ndryshoni\n * një nga karakteret në një karakter tjetër. Pyetja është: cili është numri minimal\n * i raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n * \n * Shembuj:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "hy": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Տրված է փոքրատառ անգլերեն տառերից բաղկացած տող, յուրաքանչյուր փուլում դուք կարող եք փոխել\n * տառերից մեկը մեկ այլ տառով: Հարցն այն է՝ ինչքա՞ն է նվազագույն\n * փուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն տառից:\n * \n * Օրինակներ:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "bn": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি\n * একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে\n * গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n * \n * উদাহরণসমূহ:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "bg": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените\n * един от символите на друг символ. Въпросът е: какъв е минималният\n * брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n * \n * Примери:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "zh": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * 给定一个由小写英文字母组成的字符串，每一轮你可以将其中一个字符更改为另一个字符。\n * 问题是：需要多少轮才能使字符串由相同的字符组成？\n * \n * 示例：\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "fr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer\n * l'un des caractères en un autre caractère. La question est : quel est le nombre minimum\n * de tours nécessaires pour que la chaîne soit composée du même caractère ?\n * \n * Exemples :\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "de": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. In jeder Runde kann\n * man eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Was ist die minimale\n * Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen?\n * \n * Beispiele:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "ha": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * An ba da wani kirtani da ya ƙunshi ƙananan haruffan Turanci, a kowace zagaye za ka iya canza\n * ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin\n * adadin zagaye da ake buƙata don sanya kirtanin ya ƙunshi harafi ɗaya kawai?\n * \n * Misalai:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "hi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * एक स्ट्रिंग दी गई है जिसमें छोटे अक्षरों वाले अंग्रेजी अक्षर हैं, प्रत्येक राउंड में आप\n * एक वर्ण को दूसरे वर्ण में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही वर्ण से\n * मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n * \n * उदाहरण:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "hu": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod\n * az egyik karaktert egy másik karakterre. A kérdés: mi a minimális körök száma,\n * amely ahhoz szükséges, hogy a karakterlánc ugyanabból a karakterből álljon?\n * \n * Példák:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)"
    },
    "prompt_bertscore": {
      "sq": "0.9964113449058427",
      "hy": "0.9570662417696899",
      "bn": "0.9804255718401549",
      "bg": "1",
      "zh": "0.9610620891449688",
      "fr": "0.9875077380759538",
      "de": "0.9628616803971449",
      "ha": "0.9740831051433299",
      "hi": "0.9725455073637388",
      "hu": "0.9816580733544763"
    },
    "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n",
    "instruction": {
      "en": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nՀամառոտ բնական լեզվով նկարագրեք (docstring) այս CPP կոդը հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.8528790452662222",
      "bn": "0.8961844409394485",
      "bg": "0.8365011292951701",
      "zh": "0.9903041190680392",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "int minRoundsToSameChar(const char* s)",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?\n\nExamples:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, në çdo raund mund të ndryshoni\nnjë nga karakteret në një karakter tjetër. Pyetja është: sa është numri minimal\ni raundeve të nevojshme për ta bërë vargun të përbërë nga i njëjti karakter?\n\nShembuj:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "hy": "Տրված է փոքրատառ անգլերեն տառերից կազմված տող, յուրաքանչյուր փուլում կարող եք փոխել\nտողերից մեկը մեկ այլ տառով։ Հարցն այն է՝ ինչքա՞ն է նվազագույն\nփուլերի քանակը, որը անհրաժեշտ է, որպեսզի տողը կազմված լինի նույն տառից։\n\nՕրինակներ:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "bn": "প্রদত্ত একটি স্ট্রিং যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, প্রতিটি রাউন্ডে আপনি একটি অক্ষরকে অন্য একটি অক্ষরে পরিবর্তন করতে পারেন। প্রশ্ন হল: স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কত রাউন্ড প্রয়োজন?\n\nউদাহরণসমূহ:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "bg": "Даден е низ, състоящ се от малки английски букви, като във всеки рунд можете да промените един от символите на друг символ. Въпросът е: какъв е минималният брой рундове, необходими, за да се направи низът съставен от един и същ символ?\n\nПримери:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "zh": "给定一个由小写英文字母组成的字符串，在每一轮中，你可以将其中一个字符更改为另一个字符。问题是：使字符串由相同字符组成所需的最少轮数是多少？\n\n示例：\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "fr": "Étant donné une chaîne composée de lettres minuscules anglaises, à chaque tour, vous pouvez changer l'un des caractères en un autre caractère. La question est : quel est le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère ?\n\nExemples :\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "de": "Angenommen, ein String besteht aus kleinen englischen Buchstaben. In jeder Runde können Sie eines der Zeichen in ein anderes Zeichen ändern. Die Frage ist: Wie viele Runden sind mindestens erforderlich, um den String aus demselben Zeichen zu machen?\n\nBeispiele:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "ha": "An ba da wata ƙirtani mai ƙunshi ƙananan haruffan Ingilishi, a kowace zagaye za ka iya canza ɗaya daga cikin haruffan zuwa wani harafi. Tambayar ita ce: menene mafi ƙarancin adadin zagaye da ake buƙata don sanya ƙirtanin ya ƙunshi harafi ɗaya kawai?\n\nMisalai:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "hi": "दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों का समावेश है, प्रत्येक राउंड में आप एक अक्षर को दूसरे अक्षर में बदल सकते हैं। प्रश्न यह है: स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए न्यूनतम कितने राउंड की आवश्यकता है?\n\nउदाहरण:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatod az egyik karaktert egy másikra. A kérdés az: mi a minimális körök száma, amely szükséges ahhoz, hogy a karakterlánc azonos karakterekből álljon?\n\nPéldák:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9941958216357796",
      "hy": "0.9481382034029338",
      "bn": "0.9828534309875443",
      "bg": "1",
      "zh": "0.9862811954730634",
      "fr": "0.984901508846395",
      "de": "0.9514295088166819",
      "ha": "0.9439312119326149",
      "hi": "0.9490038346034838",
      "hu": "0.9682173513609885"
    }
  },
  {
    "task_id": "CPP/32",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\n * the year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\n * immediately following the occurrence of event i.\n * Example usage:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, detyra është të gjendet\n * viti Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin\n * menjëherë pas ndodhjes së ngjarjes i.\n * Shembull përdorimi:\n *     apocalypseYear(6, {3,2,4,5,9,18}) kthen 36\n */\nint apocalypseYear(int n, int signs[])",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրն է գտնել\n * Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը։ i+1 իրադարձության համար հետհաշվարկը սկսվում է միայն\n * i իրադարձության տեղի ունենալուց անմիջապես հետո։\n * Օրինակ օգտագործում:\n *     apocalypseYear(6, {3,2,4,5,9,18}) վերադարձնում է 36\n */\nint apocalypseYear(int n, int signs[])",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * nটি ঘটনার একটি ক্রম দেওয়া হয়েছে, প্রতিটি a_i বছর পরপর ঘটে, কাজটি হল\n * n-তম ঘটনা ঘটে এমন বছর Y_n খুঁজে বের করা। ঘটনা i+1 এর জন্য কাউন্টডাউন কেবল তখনই শুরু হয়\n * যখন ঘটনা i ঘটে যাওয়ার পরের বছর।\n * উদাহরণ ব্যবহার:\n *     apocalypseYear(6, {3,2,4,5,9,18}) 36 প্রদান করে\n */\nint apocalypseYear(int n, int signs[])",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери\n * годината Y_n, когато се случва n-тото събитие. Обратното броене за събитие i+1 започва само в годината\n * непосредствено след настъпването на събитие i.\n * Пример за използване:\n *     apocalypseYear(6, {3,2,4,5,9,18}) връща 36\n */\nint apocalypseYear(int n, int signs[])",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个由 n 个事件组成的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。\n * 事件 i+1 的倒计时仅在事件 i 发生后的下一年开始。\n * 示例用法:\n *     apocalypseYear(6, {3,2,4,5,9,18}) 返回 36\n */\nint apocalypseYear(int n, int signs[])",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver\n * l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année\n * suivant immédiatement la survenue de l'événement i.\n * Exemple d'utilisation :\n *     apocalypseYear(6, {3,2,4,5,9,18}) retourne 36\n */\nint apocalypseYear(int n, int signs[])",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht die Aufgabe darin,\n * das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für Ereignis i+1 beginnt erst im Jahr\n * unmittelbar nach dem Auftreten von Ereignis i.\n * Beispielverwendung:\n *     apocalypseYear(6, {3,2,4,5,9,18}) gibt 36 zurück\n */\nint apocalypseYear(int n, int signs[])",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba da jerin abubuwan da suka faru na n, kowanne yana faruwa tare da maimaitawar a_i shekaru, aikin shine nemo\n * shekarar Y_n lokacin da abin da ya faru na n-th ya faru. Kirga don abin da ya faru i+1 kawai yana farawa a cikin shekarar\n * nan da nan bayan faruwar abin da ya faru i.\n * Misalin amfani:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * n घटनाओं के अनुक्रम को दिया गया है, प्रत्येक घटना a_i वर्षों की आवृत्ति के साथ होती है, कार्य यह है कि\n * वह वर्ष Y_n खोजें जब nवीं घटना होती है। घटना i+1 की उलटी गिनती केवल घटना i के होने के तुरंत बाद वाले वर्ष में शुरू होती है।\n * उदाहरण उपयोग:\n *     apocalypseYear(6, {3,2,4,5,9,18}) 36 लौटाता है\n */\nint apocalypseYear(int n, int signs[])",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy n eseményből álló sorozat, amelyek mindegyike a_i évenkénti periodicitással fordul elő, a feladat az,\n * hogy megtaláljuk az Y_n évet, amikor az n-edik esemény bekövetkezik. Az i+1-edik esemény visszaszámlálása csak\n * az i-edik esemény bekövetkezését követő évben kezdődik.\n * Példa használat:\n *     apocalypseYear(6, {3,2,4,5,9,18}) visszaadja 36\n */\nint apocalypseYear(int n, int signs[])"
    },
    "prompt_bertscore": {
      "sq": "0.9981604840412359",
      "hy": "0.9822857453585466",
      "bn": "0.9534352784043721",
      "bg": "0.9930135736078599",
      "zh": "0.9595934161075969",
      "fr": "0.9890012399109551",
      "de": "0.9909503998400505",
      "ha": "0.9687262423972",
      "hi": "0.9615608500317474",
      "hu": "0.9680580497953986"
    },
    "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}",
    "instruction": {
      "en": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nՏվեք կարճ բնութագիր (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\n将以下 CPP 代码的功能描述为简洁的自然语言（文档字符串），使用不超过 500 个字符的中文。",
      "fr": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar CPP a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakter használatával."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.8879615404253661",
      "bn": "0.8634835240489127",
      "bg": "0.9881575205401952",
      "zh": "0.845198008431603",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9200759018007059",
      "hi": "0.9117634189847768",
      "hu": "0.9519554820656623"
    },
    "level": "",
    "test": "int main() {\n    int arr1[] = {3,2,4,5,9,18};\n    assert(apocalypseYear(6, arr1) == 36);\n    int arr2[] = {1, 2,3,4,5};\n    assert(apocalypseYear(5, arr2) == 5);\n    int arr3[] = {1,1,1,1,1};\n    assert(apocalypseYear(5, arr3) == 5);\n    int arr4[] = {50,30,711,200,503,1006};\n    assert(apocalypseYear(6, arr4) == 2012);\n    int arr5[] = {1, 2};\n    assert(apocalypseYear(2, arr5) == 2);\n    int arr6[] = {3, 1, 2};\n    assert(apocalypseYear(3, arr6) == 6);\n    int arr7[] = {2, 3, 4};\n    assert(apocalypseYear(3, arr7) == 4);\n    int arr8[] = {1, 2, 3, 4};\n    assert(apocalypseYear(4, arr8) == 4);\n    int arr9[] = {5, 7, 11, 13};\n    assert(apocalypseYear(4, arr9) == 13);\n    int arr10[] = {2, 2, 2, 2, 2};\n    assert(apocalypseYear(5, arr10) == 10);\n    int arr11[] = {6, 10, 15};\n    assert(apocalypseYear(3, arr11) == 15);\n    int arr12[] = {4, 6, 14};\n    assert(apocalypseYear(3, arr12) == 14);\n    int arr13[] = {50, 30, 711, 200};\n    assert(apocalypseYear(4, arr13) == 800);\n    int arr14[] = {1, 1, 1, 1, 1, 1};\n    assert(apocalypseYear(6, arr14) == 6);\n    int arr15[] = {1000000, 999999};\n    assert(apocalypseYear(2, arr15) == 1999998);\n    return 0;\n}",
    "entry_point": "apocalypseYear",
    "signature": "int apocalypseYear(int n, int signs[])",
    "docstring": {
      "en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\nthe year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\nimmediately following the occurrence of event i.\nExample usage:\napocalypseYear(6, {3,2,4,5,9,18}) returns 36",
      "sq": "Duke pasur një sekuencë prej n ngjarjesh, secila që ndodh me një periodikë prej a_i vitesh, detyra është të gjendet viti Y_n kur ndodh ngjarja e n-të. Numërimi mbrapsht për ngjarjen i+1 fillon vetëm në vitin menjëherë pas ndodhjes së ngjarjes i.\nShembull përdorimi:\napocalypseYear(6, {3,2,4,5,9,18}) kthen 36",
      "hy": "Տրված է n իրադարձությունների հաջորդականություն, որոնցից յուրաքանչյուրը տեղի է ունենում a_i տարիների պարբերականությամբ, խնդիրը գտնելն է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը։ i+1 իրադարձության համար հետհաշվարկը սկսվում է միայն i իրադարձության տեղի ունենալուց անմիջապես հետո։ Օրինակ օգտագործում՝ apocalypseYear(6, {3,2,4,5,9,18}) վերադարձնում է 36",
      "bn": "একটি n ইভেন্টের ক্রম দেওয়া হয়েছে, যেখানে প্রতিটি ইভেন্ট a_i বছর পরপর ঘটে, কাজটি হল n-তম ইভেন্টটি কখন ঘটে সেই বছর Y_n খুঁজে বের করা। ইভেন্ট i+1 এর জন্য কাউন্টডাউন শুধুমাত্র ইভেন্ট i ঘটার পরের বছর থেকে শুরু হয়।\n\nউদাহরণ ব্যবহার:\napocalypseYear(6, {3,2,4,5,9,18}) 36 রিটার্ন করে",
      "bg": "Дадена е последователност от n събития, всяко от които се случва с периодичност от a_i години, задачата е да се намери годината Y_n, когато n-тото събитие се случва. Обратното броене за събитие i+1 започва само в годината непосредствено след настъпването на събитие i.\nПример за използване:\napocalypseYear(6, {3,2,4,5,9,18}) връща 36",
      "zh": "给定一个包含 n 个事件的序列，每个事件以 a_i 年为周期发生，任务是找到第 n 个事件发生的年份 Y_n。事件 i+1 的倒计时仅在事件 i 发生后的年份开始。\n\n示例用法：\napocalypseYear(6, {3,2,4,5,9,18}) 返回 36",
      "fr": "Étant donné une séquence de n événements, chacun se produisant avec une périodicité de a_i années, la tâche consiste à trouver l'année Y_n lorsque le n-ième événement se produit. Le compte à rebours pour l'événement i+1 ne commence que l'année suivant immédiatement la survenue de l'événement i.\nExemple d'utilisation :\napocalypseYear(6, {3,2,4,5,9,18}) retourne 36",
      "de": "Gegeben eine Sequenz von n Ereignissen, die jeweils mit einer Periodizität von a_i Jahren auftreten, besteht die Aufgabe darin, das Jahr Y_n zu finden, in dem das n-te Ereignis eintritt. Der Countdown für das Ereignis i+1 beginnt erst im Jahr unmittelbar nach dem Auftreten des Ereignisses i.\nBeispielverwendung:\napocalypseYear(6, {3,2,4,5,9,18}) gibt 36 zurück",
      "ha": "An ba da jerin abubuwan n, kowanne yana faruwa da tsawon lokaci na a_i shekaru, aikin shine nemo shekarar Y_n lokacin da abin n-th ya faru. Kirga don abin i+1 kawai yana farawa a shekarar da ke biye da faruwar abin i.\n\nMisalin amfani:\napocalypseYear(6, {3,2,4,5,9,18}) returns 36",
      "hi": "n घटनाओं के अनुक्रम को दिया गया है, जिनमें से प्रत्येक a_i वर्षों की आवृत्ति के साथ होती है, कार्य यह है कि nवीं घटना किस वर्ष Y_n में होती है, यह पता लगाना है। घटना i+1 की उलटी गिनती केवल घटना i के घटित होने के तुरंत बाद वाले वर्ष में ही शुरू होती है।\n\nउदाहरण उपयोग:\napocalypseYear(6, {3,2,4,5,9,18}) 36 लौटाता है",
      "hu": "Adott egy n eseményből álló sorozat, ahol mindegyik esemény a_i évenkénti periodicitással következik be, a feladat az, hogy megtaláljuk az Y_n évet, amikor az n-edik esemény bekövetkezik. Az i+1-edik esemény visszaszámlálása csak az i-edik esemény bekövetkezését követő évben kezdődik.\nPélda használat:\napocalypseYear(6, {3,2,4,5,9,18}) visszaadja 36"
    },
    "docstring_bertscore": {
      "sq": "0.9966101739172586",
      "hy": "0.9587452643805778",
      "bn": "0.9285623848304214",
      "bg": "0.9975995518451933",
      "zh": "0.9395420764028869",
      "fr": "0.9851758174026042",
      "de": "0.9870620115009116",
      "ha": "0.9511150769235037",
      "hi": "0.9157042457445089",
      "hu": "0.9546077935436211"
    }
  },
  {
    "task_id": "CPP/33",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * This problem introduces a custom modulo operation, denoted by \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\n * If x is a multiple of y, divide x by y repeatedly until x is no longer a\n * multiple of y, denoting this final value as x'. Then the result is x' % y.\n * For example:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Given a prime number p, you need to handle several queries where you're given\n * an integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n * Example:\n *    newModuloFactorial(3, 7) returns 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ky problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".\n * Kur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është x % y.\n * Nëse x është shumëfish i y, ndaj x me y në mënyrë të përsëritur derisa x të mos\n * jetë më shumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Atëherë rezultati është x' % y.\n * Për shembull:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Duke pasur një numër të plotë p, ju duhet të trajtoni disa kërkesa ku ju jepet\n * një numër i plotë n dhe duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.\n * Shembull:\n *    newModuloFactorial(3, 7) kthen 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Այս խնդիրը ներկայացնում է հատուկ մնացորդի գործողություն, որը նշվում է \"⊕\" նշանով:\n * Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է:\n * Եթե x-ը y-ի բազմապատիկ է, բաժանում ենք x-ը y-ի վրա բազմիցս, մինչև x-ը այլևս\n * y-ի բազմապատիկ չլինի, և այս վերջնական արժեքը նշում ենք որպես x': Ապա արդյունքը x' % y է:\n * Օրինակ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4:\n * Տրված է p պարզ թիվը, և անհրաժեշտ է մշակել մի քանի հարցումներ, որտեղ տրված է\n * n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p: Այստեղ n! նշում է n-ի ֆակտորիալը:\n * Օրինակ:\n *    newModuloFactorial(3, 7) վերադարձնում է 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * এই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" দ্বারা চিহ্নিত।\n * x ⊕ y গণনা করার সময়, যদি x y এর গুণিতক না হয়, ফলাফল হয় x % y।\n * যদি x y এর গুণিতক হয়, তবে x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর\n * y এর গুণিতক থাকে না, এই চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। তারপর ফলাফল হয় x' % y।\n * উদাহরণস্বরূপ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4।\n * একটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্নের সমাধান করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হয় এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\n * উদাহরণ:\n *    newModuloFactorial(3, 7) ফলাফল দেয় 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Този проблем въвежда персонализирана операция за модуло, обозначена с \"⊕\".\n * При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е x % y.\n * Ако x е кратно на y, разделете x на y многократно, докато x вече не е\n * кратно на y, обозначавайки тази крайна стойност като x'. Тогава резултатът е x' % y.\n * Например:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Дадено е просто число p, трябва да обработите няколко заявки, където ви е дадено\n * цяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.\n * Пример:\n *    newModuloFactorial(3, 7) връща 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 这个问题引入了一种自定义的模运算，用“⊕”表示。\n * 计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。\n * 如果 x 是 y 的倍数，则反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。\n * 例如：\n * - 4⊕5=4，\n * - 20⊕5=4，\n * - 100⊕5=4。\n * 给定一个素数 p，你需要处理若干查询，每个查询给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。\n * 示例：\n *    newModuloFactorial(3, 7) 返回 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Ce problème introduit une opération de modulo personnalisée, notée par \"⊕\".\n * Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.\n * Si x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un\n * multiple de y, notant cette valeur finale comme x'. Ensuite, le résultat est x' % y.\n * Par exemple :\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Étant donné un nombre premier p, vous devez traiter plusieurs requêtes où un\n * entier n vous est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.\n * Exemple :\n *    newModuloFactorial(3, 7) retourne 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Dieses Problem führt eine benutzerdefinierte Modulo-Operation ein, bezeichnet durch \"⊕\".\n * Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.\n * Wenn x ein Vielfaches von y ist, teile x wiederholt durch y, bis x kein Vielfaches von y\n * mehr ist, und bezeichne diesen Endwert als x'. Dann ist das Ergebnis x' % y.\n * Zum Beispiel:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Gegeben eine Primzahl p, müssen Sie mehrere Anfragen bearbeiten, bei denen Ihnen eine\n * ganze Zahl n gegeben ist und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.\n * Beispiel:\n *    newModuloFactorial(3, 7) gibt 6 zurück\n */ \nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Wannan matsalar tana gabatar da wani aiki na modulo na al'ada, wanda aka nuna da \"⊕\".\n * Lokacin da ake lissafin x ⊕ y, idan x ba shi ne ninki na y ba, sakamakon shi ne x % y.\n * Idan x ninki ne na y, raba x da y akai-akai har sai x ba shi ne ninki na y ba,\n * ana nuna wannan ƙimar ƙarshe da x'. Sannan sakamakon shi ne x' % y.\n * Alal misali:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * An ba da lamba mai lamba p, kana buƙatar magance tambayoyi da yawa inda aka ba ka\n * lamba n kuma dole ne ka lissafa n! ⊕ p. Anan, n! shine factorial na n.\n * Misali:\n *    newModuloFactorial(3, 7) yana dawowa 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * यह समस्या एक कस्टम मोड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" द्वारा निरूपित किया गया है।\n * जब x ⊕ y की गणना की जाती है, यदि x y का गुणज नहीं है, तो परिणाम x % y होता है।\n * यदि x y का गुणज है, तो x को y द्वारा बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो,\n * इस अंतिम मान को x' के रूप में निरूपित करते हैं। फिर परिणाम x' % y होता है।\n * उदाहरण के लिए:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4।\n * एक अभाज्य संख्या p दी गई है, आपको कई प्रश्नों को संभालना है जहाँ आपको एक पूर्णांक n दिया जाता है\n * और आपको n! ⊕ p की गणना करनी होती है। यहाँ, n! n का फैक्टोरियल है।\n * उदाहरण:\n *    newModuloFactorial(3, 7) 6 लौटाता है\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Ez a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.\n * Amikor az x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x % y.\n * Ha x osztható y-nal, osszuk el x-et y-nal ismételten, amíg x már nem\n * osztható y-nal, és ezt a végső értéket jelöljük x'-ként. Ekkor az eredmény x' % y.\n * Például:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Adott egy prímszám p, több lekérdezést kell kezelnie, ahol egy\n * egész számot n kap, és ki kell számítania n! ⊕ p értékét. Itt n! az n faktoriálisa.\n * Példa:\n *    newModuloFactorial(3, 7) visszatér 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)"
    },
    "prompt_bertscore": {
      "sq": "0.984076199613195",
      "hy": "0.9392250623147552",
      "bn": "0.984423206888863",
      "bg": "0.9915657567604966",
      "zh": "0.9758246963242437",
      "fr": "0.9863888531395842",
      "de": "0.9876076491576143",
      "ha": "0.9785576517369028",
      "hi": "0.9840740146790037",
      "hu": "0.9601758003847911"
    },
    "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}",
    "instruction": {
      "en": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.9156510128023916",
      "bn": "0.882825753293328",
      "bg": "0.8365011292951701",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9389289044166322",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}",
    "entry_point": "newModuloFactorial",
    "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
    "docstring": {
      "en": "This problem introduces a custom modulo operation, denoted by \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\nIf x is a multiple of y, divide x by y repeatedly until x is no longer a\nmultiple of y, denoting this final value as x'. Then the result is x' % y.\nFor example:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGiven a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\nExample:\n   newModuloFactorial(3, 7) returns 6\n",
      "sq": "Ky problem prezanton një operacion të personalizuar modulo, i shënuar me \"⊕\".  \nKur llogarit x ⊕ y, nëse x nuk është një shumëfish i y, rezultati është x % y.  \nNëse x është një shumëfish i y, ndaj x me y vazhdimisht derisa x të mos jetë më  \nnjë shumëfish i y, duke e shënuar këtë vlerë përfundimtare si x'. Atëherë rezultati është x' % y.  \nPër shembull:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nDuke pasur një numër të thjeshtë p, ju duhet të trajtoni disa kërkesa ku ju jepet  \nnjë numër i plotë n dhe duhet të llogaritni n! ⊕ p. Këtu, n! është faktoriali i n.  \nShembull:  \n   newModuloFactorial(3, 7) kthen 6  ",
      "hy": "Այս խնդիրը ներկայացնում է հատուկ մնացորդային գործողություն, որը նշված է \"⊕\" նշանով։  \nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x % y է։  \nԵթե x-ը y-ի բազմապատիկ է, բաժանեք x-ը y-ի վրա կրկնակիորեն, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, և այս վերջնական արժեքը նշեք որպես x'։ Այնուհետև արդյունքը x' % y է։  \nՕրինակ՝  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4։  \nՏրված է p պարզ թիվը, դուք պետք է մշակեք մի քանի հարցումներ, որտեղ տրված է n ամբողջ թիվը, և դուք պետք է հաշվարկեք n! ⊕ p։ Այստեղ, n! նշանակում է n-ի ֆակտորիալը։  \nՕրինակ՝  \n   newModuloFactorial(3, 7) վերադարձնում է 6  ",
      "bn": "এই সমস্যাটি একটি কাস্টম মডুলো অপারেশন পরিচয় করিয়ে দেয়, যা \"⊕\" দ্বারা নির্দেশিত। \nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x % y। \nযদি x y এর গুণিতক হয়, তাহলে x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, এই চূড়ান্ত মানটিকে x' হিসাবে নির্দেশিত করুন। তারপর ফলাফল হয় x' % y। \nউদাহরণস্বরূপ:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, আপনাকে বেশ কয়েকটি প্রশ্ন পরিচালনা করতে হবে যেখানে আপনাকে একটি পূর্ণসংখ্যা n দেওয়া হয় এবং আপনাকে n! ⊕ p গণনা করতে হবে। এখানে, n! হল n এর ফ্যাক্টোরিয়াল।\nউদাহরণ:\n   newModuloFactorial(3, 7) 6 প্রদান করে",
      "bg": "Този проблем въвежда персонализирана операция модуло, обозначена с \"⊕\".  \nКогато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е x % y.  \nАко x е кратно на y, разделете x на y многократно, докато x вече не е  \nкратно на y, като обозначите тази крайна стойност като x'. Тогава резултатът е x' % y.  \nНапример:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nДадено е просто число p, трябва да обработите няколко заявки, при които е дадено  \nцяло число n и трябва да изчислите n! ⊕ p. Тук n! е факториелът на n.  \nПример:  \n   newModuloFactorial(3, 7) връща 6  ",
      "zh": "这个问题引入了一个自定义的模运算，用“⊕”表示。  \n当计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x % y。  \n如果 x 是 y 的倍数，则反复将 x 除以 y，直到 x 不再是 y 的倍数，将此最终值记为 x'。然后结果是 x' % y。  \n例如：  \n- 4⊕5=4，  \n- 20⊕5=4，  \n- 100⊕5=4。  \n给定一个素数 p，你需要处理若干个查询，其中给定一个整数 n，你必须计算 n! ⊕ p。这里，n! 是 n 的阶乘。  \n示例：  \n   newModuloFactorial(3, 7) 返回 6  ",
      "fr": "Ce problème introduit une opération modulo personnalisée, notée par \"⊕\".  \nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est x % y.  \nSi x est un multiple de y, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en désignant cette valeur finale par x'. Ensuite, le résultat est x' % y.  \nPar exemple :  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nÉtant donné un nombre premier p, vous devez traiter plusieurs requêtes où un entier n vous est donné et vous devez calculer n! ⊕ p. Ici, n! est la factorielle de n.  \nExemple :  \n   newModuloFactorial(3, 7) renvoie 6  ",
      "de": "Dieses Problem führt eine benutzerdefinierte Modulo-Operation ein, bezeichnet durch \"⊕\".  \nBeim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis x % y.  \nWenn x ein Vielfaches von y ist, teile x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichne diesen Endwert als x'. Dann ist das Ergebnis x' % y.  \nZum Beispiel:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nGegeben eine Primzahl p, müssen Sie mehrere Anfragen bearbeiten, bei denen Ihnen eine ganze Zahl n gegeben wird und Sie n! ⊕ p berechnen müssen. Hierbei ist n! die Fakultät von n.  \nBeispiel:  \n   newModuloFactorial(3, 7) gibt 6 zurück  ",
      "ha": "Wannan matsalar tana gabatar da wani aiki na modulo na musamman, wanda aka nuna da \"⊕\". \nLokacin da ake lissafin x ⊕ y, idan x ba sau ɗaya ba ne na y, sakamakon shine x % y. \nIdan x sau ɗaya ne na y, raba x da y akai-akai har sai x ba sau ɗaya ba ne na y, ana nuna wannan ƙimar ƙarshe da x'. Sannan sakamakon shine x' % y. \nMisali:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nAn ba da lambar farko p, kuna buƙatar sarrafa tambayoyi da yawa inda aka ba ku \nwani lamba n kuma dole ne ku lissafa n! ⊕ p. Anan, n! shine factorial na n.\nMisali:\n   newModuloFactorial(3, 7) yana dawowa 6",
      "hi": "यह समस्या एक कस्टम मोड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे \"⊕\" द्वारा दर्शाया गया है।  \nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x % y होता है।  \nयदि x, y का गुणज है, तो x को y द्वारा बार-बार विभाजित करें जब तक कि x अब y का गुणज न रहे, इस अंतिम मान को x' के रूप में दर्शाते हुए। फिर परिणाम x' % y होता है।  \nउदाहरण के लिए:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4।  \nएक अभाज्य संख्या p दी गई है, आपको कई क्वेरीज़ को संभालना है जहाँ आपको एक पूर्णांक n दिया गया है और आपको n! ⊕ p की गणना करनी होगी। यहाँ, n! n का फैक्टोरियल है।  \nउदाहरण:  \n   newModuloFactorial(3, 7) 6 लौटाता है।  ",
      "hu": "Ez a probléma egy egyedi modulo műveletet vezet be, amelyet \"⊕\" jelöl.  \nAmikor x ⊕ y-t számítunk, ha x nem osztható y-nal, az eredmény x % y.  \nHa x osztható y-nal, osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és ezt a végső értéket jelöljük x'-ként. Ekkor az eredmény x' % y.  \nPéldául:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nAdott egy prímszám p, több lekérdezést kell kezelnie, ahol egy n egész számot kap, és ki kell számítania n! ⊕ p értékét. Itt n! az n faktoriálisa.  \nPélda:  \n   newModuloFactorial(3, 7) visszaadja 6  "
    },
    "docstring_bertscore": {
      "sq": "0.9851817763140353",
      "hy": "0.9554601165086418",
      "bn": "0.9780831237566104",
      "bg": "0.9867616823647868",
      "zh": "0.9832453287293261",
      "fr": "0.9839882063543967",
      "de": "0.9872596487300412",
      "ha": "0.9770983143274394",
      "hi": "0.985487468470448",
      "hu": "0.9549279857178494"
    }
  },
  {
    "task_id": "CPP/34",
    "prompt": {
      "en": "#include <cstdio>\n#include <cassert>\n/**\n * You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *\n * Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "sq": "#include <cstdio>\n#include <cassert>\n/**\n * Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\n * zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x,\n * me një kosto prej (j - i + 1). Gjeni koston minimale për të bërë të gjitha elementet në varg të barabartë.\n *\n * Shembuj:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "hy": "#include <cstdio>\n#include <cassert>\n/**\n * Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\n * ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք բոլոր տարրերը a[i]-ից a[j]-ով x-ով,\n * արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի բոլոր տարրերը զանգվածում հավասար լինեն։\n *\n * Օրինակներ:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "bn": "#include <cstdio>\n#include <cassert>\n/**\n * আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি\n * তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সব উপাদান x দিয়ে প্রতিস্থাপন করেন,\n * যার খরচ (j - i + 1)। অ্যারের সব উপাদান সমান করতে সর্বনিম্ন খরচ খুঁজে বের করুন।\n *\n * উদাহরণ:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "bg": "#include <cstdio>\n#include <cassert>\n/**\n * Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която\n * избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x,\n * на цена от (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n *\n * Примери:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "zh": "#include <cstdio>\n#include <cassert>\n/**\n * 给定一个由 n 个整数组成的数组 a。你可以执行最多一次操作，其中你选择三个整数 i, j, x (1 <= i <= j <= n)，\n * 并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。找到使数组中所有元素相等的最小代价。\n *\n * 示例:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "fr": "#include <cstdio>\n#include <cassert>\n/**\n * Vous avez un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous\n * sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x,\n * à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n *\n * Exemples :\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "de": "#include <cstdio>\n#include <cassert>\n/**\n * Gegeben ist ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation ausführen, bei der Sie\n * drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j] durch x ersetzen,\n * zu Kosten von (j - i + 1). Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n *\n * Beispiele:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "ha": "#include <cstdio>\n#include <cassert>\n/**\n * An ba ku wani jerin a na lambobi n. Kuna iya aiwatar da aƙalla aiki ɗaya inda za ku\n * zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x,\n * a kan kuɗin (j - i + 1). Nemo mafi ƙarancin kuɗi don sanya duk abubuwan cikin jerin su zama daidai.\n *\n * Misalai:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "hi": "#include <cstdio>\n#include <cassert>\n/**\n * आपको n पूर्णांकों की एक सरणी a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप\n * तीन पूर्णांक i, j, x (1 <= i <= j <= n) चुनते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदल देते हैं,\n * जिसकी लागत (j - i + 1) होती है। सभी तत्वों को सरणी में समान बनाने की न्यूनतम लागत खोजें।\n *\n * उदाहरण:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "hu": "#include <cstdio>\n#include <cassert>\n/**\n * Adott egy n egész számot tartalmazó tömb. Legfeljebb egy műveletet hajthatsz végre, ahol\n * kiválasztasz három egész számot i, j, x (1 <= i <= j <= n) és az a[i] és a[j] közötti összes elemet x-re cseréled,\n * (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n *\n * Példák:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])"
    },
    "prompt_bertscore": {
      "sq": "0.9961608719953576",
      "hy": "0.9706084638878866",
      "bn": "0.9946411509500598",
      "bg": "0.9902744606533888",
      "zh": "0.9823800947895381",
      "fr": "0.9939262802087152",
      "de": "0.984320316351487",
      "ha": "0.972905028353412",
      "hi": "0.9927615116543266",
      "hu": "0.9745069823764583"
    },
    "canonical_solution": "{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "en": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nՏվյալ C++ կոդի համար տրամադրել հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nДайте кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\n将以下CPP代码的自然语言描述（文档字符串）用中文简洁地提供，限制在500个字符以内。",
      "fr": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.8392641244285668",
      "bn": "0.8439591507450884",
      "bg": "0.8365011292951701",
      "zh": "0.8702298063103817",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.8667607267056073",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}",
    "entry_point": "makeEqualAgain",
    "signature": "int makeEqualAgain(int n, int a[])",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n\nExamples:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1\n",
      "sq": "Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j] me x, me një kosto prej (j - i + 1). Gjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n\nShembuj:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hy": "Դուք տրված եք n ամբողջ թվերի a զանգվածով։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ը բոլոր տարրերը x-ով, արժեքով (j - i + 1)։ Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։\n\nՕրինակներ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজুন।\n\nউদাহরণসমূহ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "bg": "Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.\n\nПримери:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "zh": "你有一个包含 n 个整数的数组 a。你最多可以执行一次操作，在其中选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。找出使数组中所有元素相等的最小代价。\n\n示例：\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "fr": "Vous disposez d'un tableau a de n entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j] par x, à un coût de (j - i + 1). Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n\nExemples :\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] durch x ersetzt, zu Kosten von (j - i + 1). Finde die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n\nBeispiele:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "ha": "An ba ku wani tsari a na n lambobi. Kuna iya yin aiki ɗaya kawai inda kuka zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j] da x, a kan farashi na (j - i + 1). Nemo mafi ƙarancin farashi don sanya duk abubuwan a cikin tsari su zama daidai.\n\nMisalai:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hi": "आपको n पूर्णांकों के एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदलते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने के लिए न्यूनतम लागत खोजें।\n\nउदाहरण:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "hu": "Meg van adva egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az összes elemet a[i]-től a[j]-ig x-re cseréled, (j - i + 1) költséggel. Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n\nPéldák:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1"
    },
    "docstring_bertscore": {
      "sq": "0.9962148994589992",
      "hy": "0.9587246068209503",
      "bn": "0.9970461676036302",
      "bg": "0.9849763925000452",
      "zh": "0.9881646087460362",
      "fr": "0.9929313406301115",
      "de": "0.9901975906959283",
      "ha": "0.9735966593401754",
      "hi": "0.9969532085853059",
      "hu": "0.9803731334195617"
    }
  },
  {
    "task_id": "CPP/35",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner\n * of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile\n * to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "sq": "#include <cassert>\n#include <iostream>\n/**\n * Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin\n * të një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhën me Dan për të lëvizur gurët nga grumbulli më i majtë që nuk është bosh\n * te grumbulli ngjitur në të djathtë. Ai që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përsosur, gjeni fituesin.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "hy": "#include <cassert>\n#include <iostream>\n/**\n * Տրված է քարերի N կույտերից բաղկացած հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրը պարունակում է քարերի դրական քանակ:\n * որոշեք խաղի հաղթողին, որը խաղում են Չարլին և Դանը: Չարլին սկսում է, հերթով Դանի հետ տեղափոխելով քարերը ձախից աջ հարևան կույտ:\n * Նա, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով կատարյալ խաղ, գտեք հաղթողին:\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "bn": "#include <cassert>\n#include <iostream>\n/**\n * ১ থেকে N পর্যন্ত নম্বরযুক্ত Nটি পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, প্রতিটিতে একটি ইতিবাচক সংখ্যক পাথর রয়েছে, চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন।\n * চার্লি শুরু করে, ড্যানের সাথে পালা করে বামদিকের প্রথম পূর্ণ স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে পাথর সরিয়ে নিয়ে যায়।\n * যে ব্যক্তি শুধুমাত্র শেষ স্তূপে পাথর সরাতে পারে সে হেরে যায়। নিখুঁত খেলার অনুমান করে, বিজয়ী খুঁজে বের করুন।\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "bg": "#include <cassert>\n#include <iostream>\n/**\n * Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя\n * в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан да мести камъни от най-лявата непразна купчина\n * към съседната дясна купчина. Този, който може да мести камъни само в последната купчина, губи. Приемайки перфектна игра, намерете победителя.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "zh": "#include <cassert>\n#include <iostream>\n/**\n * 给定一个编号从1到N的石堆序列，每堆包含正数个石头，确定Charlie和Dan玩的游戏的赢家。Charlie先开始，与Dan轮流\n * 从最左边的非空堆移动石头到相邻的右边堆。只能在最后一堆移动石头的人输。假设完美游戏，找出赢家。\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "fr": "#include <cassert>\n#include <iostream>\n/**\n * Étant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres, déterminez le gagnant\n * d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer des pierres du tas le plus à gauche non vide\n * vers le tas adjacent à droite. Celui qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant un jeu parfait, trouvez le gagnant.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "de": "#include <cassert>\n#include <iostream>\n/**\n * Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält, bestimme den Gewinner\n * eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt und wechselt sich mit Dan ab, indem sie Steine vom linken, nicht leeren Haufen\n * zum benachbarten rechten Haufen bewegen. Derjenige, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, beide spielen perfekt, finde den Gewinner.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "ha": "#include <cassert>\n#include <iostream>\n/**\n * An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, tantance wanda zai ci\n * wasa da Charlie da Dan suka buga. Charlie yana farawa, suna juyawa da Dan suna motsa duwatsu daga mafi hagu wanda ba komai a ciki\n * zuwa tarin da ke makwabta a dama. Wanda zai iya motsa duwatsu a cikin tarin karshe kadai zai yi asara. Idan ana wasa daidai, gano wanda zai ci.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "hi": "#include <cassert>\n#include <iostream>\n/**\n * 1 से N तक क्रमांकित पत्थरों के N ढेरों की एक श्रृंखला दी गई है, जिनमें से प्रत्येक में पत्थरों की एक सकारात्मक संख्या है, \n * चार्ली और डैन द्वारा खेले गए एक खेल के विजेता का निर्धारण करें। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से \n * दाएं सबसे निकट के ढेर से पत्थरों को दाएं सटे ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को ले जा सकता है, वह हार जाता है। \n * पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "hu": "#include <cassert>\n#include <iostream>\n/**\n * Adott egy N halomból álló kősorozat, amelyeket 1-től N-ig számoztak, mindegyik halom pozitív számú követ tartalmaz. Határozza meg a győztest\n * egy játékban, amelyet Charlie és Dan játszik. Charlie kezd, és Dan-nel felváltva lépnek, köveket mozgatva a bal szélső nem üres halomból\n * a szomszédos jobb halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Tökéletes játékot feltételezve találja meg a győztest.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])"
    },
    "prompt_bertscore": {
      "sq": "0.9857272153403571",
      "hy": "0.9552199723779706",
      "bn": "0.932801355792087",
      "bg": "0.9870828676909202",
      "zh": "0.9408081464516033",
      "fr": "0.9857272153403571",
      "de": "0.960710513370537",
      "ha": "0.9447749937912511",
      "hi": "0.9454135904662783",
      "hu": "0.9741162764169626"
    },
    "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "en": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nДайте кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\n将以下 CPP 代码的自然语言描述（文档字符串）用中文简明扼要地提供，字数不超过 500 个字符。",
      "fr": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8961844409394485",
      "bg": "0.8365011292951701",
      "zh": "0.8527972095492358",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.9536396690664571",
      "hi": "0.9117634189847768",
      "hu": "0.942440093662186"
    },
    "level": "",
    "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(std::string(gameWinner(3, test1)) == \"Dan\");\n    assert(std::string(gameWinner(5, test2)) == \"Charlie\");\n    assert(std::string(gameWinner(3, test3)) == \"Charlie\");\n    assert(std::string(gameWinner(4, test4)) == \"Charlie\");\n    assert(std::string(gameWinner(2, test5)) == \"Charlie\");\n    assert(std::string(gameWinner(2, test6)) == \"Charlie\");\n    assert(std::string(gameWinner(11, test7)) == \"Dan\");\n    assert(std::string(gameWinner(10, test8)) == \"Charlie\");\n    assert(std::string(gameWinner(10, test9)) == \"Charlie\");\n    assert(std::string(gameWinner(10, test10)) == \"Dan\");\n\n    return 0;\n}",
    "entry_point": "gameWinner",
    "signature": "const char* gameWinner(int n, const int piles[])",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"\n",
      "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, përcaktoni fituesin e një loje të luajtur nga Charlie dhe Dan. Charlie fillon, duke marrë radhën me Dan duke lëvizur gurë nga grumbulli më i majtë jo bosh në grumbullin fqinj në të djathtë. Ai që mund të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë të përsosur, gjeni fituesin.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "hy": "Տրված է քարերի N կույտերի հաջորդականություն, որոնք համարակալված են 1-ից մինչև N, և յուրաքանչյուրը պարունակում է դրական թվով քարեր: Պարզեք Չարլիի և Դենի խաղի հաղթողին: Չարլին սկսում է, հերթով Դենի հետ տեղափոխելով քարերը ձախից աջ առաջին ոչ դատարկ կույտից դեպի հարակից աջ կույտ: Նա, ով կարող է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է: Ենթադրելով կատարյալ խաղ, գտեք հաղթողին:\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "bn": "N সংখ্যক পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটি স্তূপে একটি ইতিবাচক সংখ্যক পাথর রয়েছে। চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করুন। চার্লি শুরু করে, ড্যানের সাথে পালা করে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানপাশের সংলগ্ন স্তূপে পাথর সরিয়ে নেয়। যে ব্যক্তি কেবলমাত্র শেষ স্তূপে পাথর সরাতে পারে, সে হেরে যায়। নিখুঁত খেলার ধরণ ধরে নিয়ে, বিজয়ী খুঁজে বের করুন।\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, определете победителя в игра, играна от Чарли и Дан. Чарли започва, като се редува с Дан да премества камъни от най-лявата непразна купчина към съседната дясна купчина. Този, който може да премества камъни само в последната купчина, губи. Приемайки перфектна игра, намерете победителя.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，确定Charlie和Dan玩游戏的赢家。Charlie开始，与Dan轮流从最左边的非空堆移动石头到相邻的右边堆。只能在最后一堆移动石头的人输。假设完美的游戏，找出赢家。\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "fr": "Étant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres, déterminez le gagnant d'un jeu joué par Charlie et Dan. Charlie commence, prenant des tours avec Dan pour déplacer des pierres du tas le plus à gauche non vide vers le tas adjacent à droite. Celui qui ne peut déplacer des pierres que dans le dernier tas perd. En supposant un jeu parfait, trouvez le gagnant.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "de": "Angenommen, es gibt eine Sequenz von N Steinhaufen, die von 1 bis N nummeriert sind, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Bestimmen Sie den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Charlie beginnt, abwechselnd mit Dan, indem er Steine vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegt. Derjenige, der nur noch Steine im letzten Haufen bewegen kann, verliert. Angenommen, es wird perfekt gespielt, finden Sie den Gewinner.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "ha": "An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadin duwatsu masu kyau, a tantance wanda ya ci nasara a wani wasa da Charlie da Dan suka buga. Charlie yana farawa, suna juyawa da Dan suna motsa duwatsu daga mafi hagu wanda ba komai ba zuwa tarin dama kusa. Wanda zai iya motsa duwatsu a cikin tarin karshe kadai zai yi rashin nasara. Idan aka dauka cikakken wasa, gano wanda ya ci nasara.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "hi": "N पत्थरों के ढेरों की एक अनुक्रमणिका दी गई है, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में पत्थरों की एक सकारात्मक संख्या है, चार्ली और डैन द्वारा खेले गए खेल के विजेता का निर्धारण करें। चार्ली शुरू करता है, डैन के साथ बारी-बारी से बाएं से दाएं सबसे पहले गैर-खाली ढेर से पत्थरों को अगले दाएं ढेर में ले जाता है। जो केवल अंतिम ढेर में पत्थरों को हिला सकता है, वह हार जाता है। पूर्ण खेल मानते हुए, विजेता का पता लगाएं।\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "hu": "Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz. Határozd meg a Charlie és Dan által játszott játék győztesét. Charlie kezd, Dan-nel felváltva lépéseket téve, a baloldali nem üres halomból köveket mozgatva a szomszédos jobb oldali halomba. Az veszít, aki csak az utolsó halomban tud köveket mozgatni. Feltételezve a tökéletes játékot, találd meg a győztest.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\""
    },
    "docstring_bertscore": {
      "sq": "0.988004314028541",
      "hy": "0.9614887472034317",
      "bn": "0.9461461393115349",
      "bg": "0.9768496290903838",
      "zh": "0.9437019924729007",
      "fr": "0.983813808879848",
      "de": "0.9361218598718472",
      "ha": "0.9398676315974032",
      "hi": "0.9059661926838926",
      "hu": "0.8950355628155426"
    }
  },
  {
    "task_id": "CPP/36",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right\n * and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n *\n * Example:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Duke pasur parasysh n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1.\n * Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa djathtas\n * dhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.\n * Detyra është të përcaktohet kostoja minimale totale e kërkuar për të hapur të gjitha dyert.\n *\n * Shembull:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Տրված են n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմացից:\n * Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու\n * և այնուհետև այդ դիրքում դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:\n * Խնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n *\n * Օրինակ:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * একটি বৃত্তে সাজানো n টি দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।\n * প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে\n * এবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\n * কাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n *\n * উদাহরণ:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Дадени са n врати, подредени в кръг, играчът започва пред врата 1.\n * Всеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно\n * и след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.\n * Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n *\n * Пример:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * 给定 n 个门按圆形排列，玩家从门 1 前面开始。\n * 每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，\n * 然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n * 任务是确定打开所有门所需的最小总成本。\n *\n * 示例:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.\n * À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite\n * puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.\n * La tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n *\n * Exemple:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Gegeben sind n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1.\n * In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen\n * und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n.\n * Die Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n *\n * Beispiel:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * An ba da n kofofi da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban kofa ta 1.\n * Kowanne juyawa, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama\n * sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n.\n * Aikin shine a tantance mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk kofofin.\n *\n * Misali:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू होता है।\n * प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है\n * और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\n * कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n *\n * उदाहरण:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\n * Minden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra,\n * majd kinyitja az adott pozíción lévő ajtót. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\n * A feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n *\n * Példa:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)"
    },
    "prompt_bertscore": {
      "sq": "0.99778507262108",
      "hy": "0.9829730064769273",
      "bn": "0.9672766378764074",
      "bg": "0.9928159363787301",
      "zh": "0.9708480121274147",
      "fr": "0.9967990714096228",
      "de": "0.9915603937402087",
      "ha": "0.9966207013274534",
      "hi": "0.952984188809042",
      "hu": "0.9720072190311343"
    },
    "canonical_solution": "{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}",
    "instruction": {
      "en": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\n请用不超过500个字符的中文，为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nBa da takaitaccen bayani na halayen lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.9483094227913859",
      "bn": "0.8448917203840473",
      "bg": "0.9788407625177538",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.8381637121176335",
      "hi": "0.8667607267056073",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    std::vector<int> costs1 = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    std::vector<int> costs2 = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    std::vector<int> costs3 = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    std::vector<int> costs4 = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    std::vector<int> costs5 = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    std::vector<int> costs6 = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    std::vector<int> costs7 = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    std::vector<int> costs8 = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    std::vector<int> costs9 = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    std::vector<int> costs10 = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n\n    return 0;\n}",
    "entry_point": "minTotalCost",
    "signature": "long long minTotalCost(int n, const std::vector<int>& C)",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps to the right\nand then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n",
      "sq": "Duke pasur n dyer të rregulluara në një rreth, lojtari fillon përballë derës 1.  \nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa në të djathtë  \ndhe pastaj të hapë derën në atë pozicion. Është e garantuar që C_i >= C_{i+1} për 1 <= i < n.  \nDetyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hy": "Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:  \nՅուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել C_i արժեքը՝ i քայլ աջ շարժվելու և այնուհետև այդ դիրքի դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար:  \nԽնդիրը կայանում է բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը որոշելու մեջ:\n\nՕրինակ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bn": "nটি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে।  \nপ্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে  \nএবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।  \nসমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করার কাজ।\n\nউদাহরণ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1.  \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки надясно  \nи след това да отвори вратата на тази позиция. Гарантирано е, че C_i >= C_{i+1} за 1 <= i < n.  \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "zh": "给定 n 个门按圆形排列，玩家从门 1 前开始。  \n每回合，玩家可以选择一个数字 i 并支付代价 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总成本。\n\n示例：  \n    >>> minTotalCost(3, (1, 1, 1))  \n    3  ",
      "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.  \nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite  \net ensuite ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n.  \nLa tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. \nIn jedem Zug kann der Spieler eine Zahl i wählen und die Kosten C_i zahlen, um i Schritte nach rechts zu gehen \nund dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n. \nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "ha": "An ba ƙofar n da aka shirya a cikin da'ira, ɗan wasan yana farawa a gaban ƙofa ta 1. \nKowane juyi, ɗan wasan na iya zaɓar lamba i kuma ya biya kuɗi C_i don matsawa matakai i zuwa dama \nsannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. \nAikin shi ne a tantance mafi ƙarancin jimillar kuɗi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hi": "दी गई n दरवाजों को एक वृत्त में व्यवस्थित किया गया है, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है। \nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए लागत C_i का भुगतान कर सकता है \nऔर फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी दी जाती है कि C_i >= C_{i+1} जहाँ 1 <= i < n। \nकार्य यह निर्धारित करना है कि सभी दरवाजों को खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\nMinden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra,\nmajd kinyitja az ajtót azon a helyen. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9962218515223354",
      "hy": "0.9731773506058108",
      "bn": "0.9638770789049952",
      "bg": "0.999999801369619",
      "zh": "0.9951814255864746",
      "fr": "0.9928052103381543",
      "de": "0.9854433725258582",
      "ha": "0.9849823514114763",
      "hi": "0.9612635003513382",
      "hu": "0.9615830966344233"
    }
  },
  {
    "task_id": "CPP/37",
    "prompt": {
      "en": "#include <cassert>\n#include <vector>\n/**\n * Computes the total number of handshakes in a classroom scenario given\n * the sequence of student IDs as they enter the classroom. It assumes\n * that students have IDs ranging from 0 to N-1 and that each student\n * will shake hands only with students already in the classroom with a\n * smaller ID.\n *\n * Examples:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "sq": "#include <cassert>\n#include <vector>\n/**\n * Llogarit numrin total të shtrëngimeve të duarve në një skenar klase duke pasur parasysh\n * sekuencën e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet\n * që studentët kanë ID që variojnë nga 0 deri në N-1 dhe që çdo student\n * do të shtrëngojë duart vetëm me studentët që tashmë janë në klasë me një\n * ID më të vogël.\n *\n * Shembuj:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "hy": "#include <cassert>\n#include <vector>\n/**\n * Հաշվում է ձեռքսեղմումների ընդհանուր քանակը դասարանում տրված\n * ուսանողների ID-ների հաջորդականությամբ, երբ նրանք մտնում են դասարան: Ենթադրվում է,\n * որ ուսանողները ունեն ID-ներ 0-ից մինչև N-1, և որ յուրաքանչյուր ուսանող\n * ձեռք կսեղմի միայն այն ուսանողների հետ, ովքեր արդեն դասարանում են ավելի փոքր ID-ով:\n *\n * Օրինակներ:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "bn": "#include <cassert>\n#include <vector>\n/**\n * একটি শ্রেণীকক্ষের পরিস্থিতিতে মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করে\n * যখন ছাত্রদের আইডির ক্রম অনুযায়ী তারা শ্রেণীকক্ষে প্রবেশ করে। এটি ধরে নেয়\n * যে ছাত্রদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি ছাত্র\n * শুধুমাত্র তাদের চেয়ে ছোট আইডি সহ ইতিমধ্যে শ্রেণীকক্ষে থাকা ছাত্রদের সাথে হ্যান্ডশেক করবে।\n *\n * উদাহরণ:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "bg": "#include <cassert>\n#include <vector>\n/**\n * Изчислява общия брой ръкостискания в класна стая, като се даде\n * последователността от идентификатори на учениците, когато влизат в класната стая. Предполага се,\n * че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик\n * ще се ръкува само с ученици, които вече са в класната стая с\n * по-малък идентификатор.\n *\n * Примери:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "zh": "#include <cassert>\n#include <vector>\n/**\n * 计算在教室场景中给定学生进入教室的顺序时的握手总数。假设学生的ID范围是从0到N-1，并且每个学生只会与已经在教室中且ID较小的学生握手。\n *\n * 示例:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "fr": "#include <cassert>\n#include <vector>\n/**\n * Calcule le nombre total de poignées de main dans un scénario de salle de classe donné\n * la séquence des identifiants des étudiants à mesure qu'ils entrent dans la salle de classe. Il suppose\n * que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant\n * serrera la main uniquement avec les étudiants déjà dans la salle de classe avec un\n * identifiant plus petit.\n *\n * Exemples :\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "de": "#include <cassert>\n#include <vector>\n/**\n * Berechnet die Gesamtanzahl der Händeschüttelvorgänge in einem Klassenzimmerszenario,\n * gegeben die Reihenfolge der Schüler-IDs, wie sie das Klassenzimmer betreten. Es wird\n * angenommen, dass die Schüler IDs im Bereich von 0 bis N-1 haben und dass jeder Schüler\n * nur mit Schülern Händeschütteln wird, die sich bereits mit einer kleineren ID im\n * Klassenzimmer befinden.\n *\n * Beispiele:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "ha": "#include <cassert>\n#include <vector>\n/**\n * Yana lissafin jimillar yawan musabaha a cikin yanayin aji da aka bayar\n * jerin lambobin dalibai yayin da suke shiga aji. Yana dauka\n * cewa dalibai suna da lambobi daga 0 zuwa N-1 kuma cewa kowane dalibi\n * zai yi musabaha ne kawai da daliban da suke cikin aji da\n * karamar lamba.\n *\n * Misalai:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "hi": "#include <cassert>\n#include <vector>\n/**\n * यह गणना करता है कि कक्षा परिदृश्य में कुल कितनी हाथ मिलाने की घटनाएँ होती हैं,\n * जब छात्रों के आईडी का क्रम दिया गया है जैसे वे कक्षा में प्रवेश करते हैं। यह मानता है\n * कि छात्रों के आईडी 0 से N-1 तक होते हैं और प्रत्येक छात्र केवल उन्हीं छात्रों से\n * हाथ मिलाएगा जो पहले से ही कक्षा में हैं और जिनका आईडी उससे छोटा है।\n *\n * उदाहरण:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "hu": "#include <cassert>\n#include <vector>\n/**\n * Kiszámítja a kézfogások teljes számát egy osztálytermi szituációban,\n * figyelembe véve a diákok azonosítóinak sorrendjét, ahogy belépnek az\n * osztályterembe. Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig\n * terjednek, és hogy minden diák csak azokkal a diákokkal fog kezet,\n * akik már az osztályteremben vannak és kisebb azonosítóval rendelkeznek.\n *\n * Példák:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)"
    },
    "prompt_bertscore": {
      "sq": "0.9783421377734799",
      "hy": "0.9715088554051177",
      "bn": "0.9484343613010568",
      "bg": "0.9598089300710196",
      "zh": "0.9302652430870335",
      "fr": "0.9869100592594199",
      "de": "0.9661944995605293",
      "ha": "0.933666788362256",
      "hi": "0.9448006171104045",
      "hu": "0.9473752641093788"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}",
    "instruction": {
      "en": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9545531701888366",
      "bn": "0.8439591507450884",
      "bg": "0.8365011292951701",
      "zh": "0.904821312162758",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.8412526131731071",
      "hi": "0.9117634189847768",
      "hu": "0.942440093662186"
    },
    "level": "",
    "test": "int main() {\n    assert(countHandshakes(4, {2, 1, 3, 0}) == 2);\n    assert(countHandshakes(6, {0, 1, 2, 3, 4, 5}) == 15);\n    assert(countHandshakes(3, {1, 2, 0}) == 1);\n    assert(countHandshakes(4, {3, 2, 1, 0}) == 0);\n    assert(countHandshakes(4, {0, 1, 2, 3}) == 6);\n    assert(countHandshakes(6, {5, 4, 3, 2, 1, 0}) == 0);\n    assert(countHandshakes(4, {0, 2, 1, 3}) == 5);\n    assert(countHandshakes(5, {3, 1, 4, 2, 0}) == 3);\n    assert(countHandshakes(4, {1, 0, 3, 2}) == 4);\n    assert(countHandshakes(3, {2, 0, 1}) == 1);\n    assert(countHandshakes(5, {1, 3, 0, 2, 4}) == 7);\n    assert(countHandshakes(5, {4, 3, 2, 1, 0}) == 0);\n\n    return 0;\n}",
    "entry_point": "countHandshakes",
    "signature": "long long countHandshakes(int n, const std::vector<int>& order)",
    "docstring": {
      "en": "Computes the total number of handshakes in a classroom scenario given the sequence of student IDs as they enter the classroom. It assumes that students have IDs ranging from 0 to N-1 and that each student will shake hands only with students already in the classroom with a smaller ID.\n\nExamples:\n>>> countHandshakes(3, {2, 1, 0})\n0\n",
      "sq": "Llogarit numrin total të shtrëngimeve të duarve në një skenar klase duke pasur parasysh rendin e ID-ve të studentëve ndërsa hyjnë në klasë. Supozohet se studentët kanë ID që variojnë nga 0 deri në N-1 dhe se çdo student do të shtrëngojë duart vetëm me studentët që janë tashmë në klasë me një ID më të vogël.\n\nShembuj:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "hy": "Հաշվում է ընդհանուր ձեռքսեղմումների թիվը դասարանում, երբ տրվում է ուսանողների ID-ների հաջորդականությունը, երբ նրանք մտնում են դասարան։ Ենթադրվում է, որ ուսանողները ունեն ID-ներ 0-ից մինչև N-1 և որ յուրաքանչյուր ուսանող ձեռք կսեղմի միայն այն ուսանողների հետ, որոնք արդեն դասարանում են և ունեն ավելի փոքր ID։\n\nՕրինակներ:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "bn": "ক্লাসরুমের দৃশ্যে শিক্ষার্থীদের আইডির ক্রম অনুযায়ী ক্লাসরুমে প্রবেশ করার সময় মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করে। এটি ধরে নেয় যে শিক্ষার্থীদের আইডি 0 থেকে N-1 পর্যন্ত এবং প্রতিটি শিক্ষার্থী কেবলমাত্র তাদের চেয়ে ছোট আইডি সহ ইতিমধ্যে ক্লাসরুমে থাকা শিক্ষার্থীদের সাথে হ্যান্ডশেক করবে।\n\nউদাহরণসমূহ:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "bg": "Изчислява общия брой ръкостискания в класна стая, като се вземе предвид последователността на идентификаторите на учениците при влизането им в класната стая. Предполага се, че учениците имат идентификатори в диапазона от 0 до N-1 и че всеки ученик ще се ръкува само с ученици, които вече са в класната стая с по-малък идентификатор.\n\nПримери:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "zh": "计算在一个教室场景中，根据学生进入教室的顺序，握手的总次数。假设学生的ID范围是从0到N-1，并且每个学生只会与已经在教室中且ID较小的学生握手。\n\n示例：\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "fr": "Calcule le nombre total de poignées de main dans un scénario de salle de classe donné la séquence des identifiants des étudiants lorsqu'ils entrent dans la salle de classe. Il suppose que les étudiants ont des identifiants allant de 0 à N-1 et que chaque étudiant serrera la main uniquement avec les étudiants déjà présents dans la salle de classe avec un identifiant plus petit.\n\nExemples :\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "de": "Berechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer-Szenario, gegeben die Sequenz der Schüler-IDs, während sie das Klassenzimmer betreten. Es wird angenommen, dass die Schüler IDs im Bereich von 0 bis N-1 haben und dass jeder Schüler nur mit Schülern Händeschütteln wird, die bereits im Klassenzimmer sind und eine kleinere ID haben.\n\nBeispiele:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "ha": "Yana ƙididdige jimillar yawan gaisuwar hannu a cikin yanayin aji la'akari da jerin lambobin dalibai yayin da suke shiga aji. Yana ɗauka cewa dalibai suna da lambobi daga 0 zuwa N-1 kuma cewa kowane dalibi zai gaisa da hannu kawai da daliban da suka riga sun shiga aji da ƙaramin lamba.\n\nMisalai:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "hi": "कक्षा परिदृश्य में हाथ मिलाने की कुल संख्या की गणना करता है, जब छात्रों की आईडी का अनुक्रम दिया जाता है जैसे वे कक्षा में प्रवेश करते हैं। यह मानता है कि छात्रों की आईडी 0 से N-1 तक होती हैं और प्रत्येक छात्र केवल उन छात्रों से हाथ मिलाएगा जो पहले से ही कक्षा में छोटे आईडी के साथ हैं।\n\nउदाहरण:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "hu": "Számítja az összes kézfogás számát egy osztálytermi szituációban, adott a diákok azonosítóinak sorrendje, ahogy belépnek az osztályterembe. Feltételezi, hogy a diákok azonosítói 0-tól N-1-ig terjednek, és hogy minden diák csak azokkal a diákokkal fog kezet, akik már az osztályteremben vannak, és kisebb azonosítóval rendelkeznek.\n\nPéldák:\n>>> countHandshakes(3, {2, 1, 0})\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9537987720016661",
      "hy": "0.9403485157498885",
      "bn": "0.9078456333492446",
      "bg": "0.9473565928535616",
      "zh": "0.9144417510426512",
      "fr": "0.9815776280501572",
      "de": "0.951879803890488",
      "ha": "0.9154263618414412",
      "hi": "0.9317434503826951",
      "hu": "0.931468943196105"
    }
  },
  {
    "task_id": "CPP/38",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n * \n * Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\n * gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\n * një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë\n * në një sekuencë.\n * \n * Shembull:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Një sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը,\n * գտնել մոդի (ամենահաճախ հանդիպող տարր) առավելագույն գումարը բոլոր նախածանցների համար\n * այս թվերից կազմված հաջորդականության։ Մոդը հաջորդականության ամենահաճախ հանդիպող տարրերի\n * մեջ ամենամեծ թիվն է։\n * \n * Օրինակ:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Հաջորդականություն, որը հասնում է իր առավելագույն արժեքին, դա (3,2,3,1,2,2) է։\n */\nlong long maxModeSum(int n, const int* counts)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া আছে যা ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে,\n * একটি ক্রম থেকে সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন\n * এই সংখ্যাগুলি থেকে নির্মিত। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n * \n * উদাহরণ:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।\n */\nlong long maxModeSum(int n, const int* counts)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\n * намерете максималната сума на режима (най-често срещания елемент) за всички префикси на\n * последователност, конструирана от тези числа. Режимът е най-голямото число сред\n * най-често срещаните елементи в последователност.\n * \n * Пример:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Последователност, която достига максималната си стойност, е (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n * 找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。\n * 众数是序列中最频繁元素中的最大数字。\n * \n * 示例：\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * 达到最大值的序列是 (3,2,3,1,2,2)。\n */\nlong long maxModeSum(int n, const int* counts)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n,\n * trouver la somme maximale de la mode (élément le plus fréquent) pour tous les préfixes\n * d'une séquence construite à partir de ces nombres. La mode est le plus grand nombre parmi\n * les éléments les plus fréquents dans une séquence.\n * \n * Exemple :\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Une séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\n * finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\n * Sequenz, die aus diesen Zahlen konstruiert wurde. Der Modus ist die größte Zahl\n * unter den häufigsten Elementen in einer Sequenz.\n * \n * Beispiel:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Eine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba n lambobi masu kyau waɗanda ke wakiltar adadin kowanne lamba daga 1 zuwa n,\n * nemo mafi girman jimlar yanayin (abu mafi yawan faruwa) don dukkan farkon\n * jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba daga cikin\n * abubuwan da suka fi yawa a cikin jerin.\n * \n * Misali:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Jerin da ya kai darajarsa mafi girma shine (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\n * उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें\n * जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n * \n * उदाहरण:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।\n */\nlong long maxModeSum(int n, const int* counts)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik,\n * keresse meg a módusz (leggyakrabban előforduló elem) maximális összegét az összes előtagra\n * egy ezen számokból felépített sorozat esetén. A módusz a legnagyobb szám a sorozat leggyakrabban\n * előforduló elemei között.\n * \n * Példa:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Egy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)"
    },
    "prompt_bertscore": {
      "sq": "0.9920230038976389",
      "hy": "0.9729813024197294",
      "bn": "0.9797982970968467",
      "bg": "0.990776598256645",
      "zh": "0.944660384061394",
      "fr": "0.9976760245418919",
      "de": "0.9986373955861007",
      "ha": "0.9444738701336022",
      "hi": "0.9484087379819033",
      "hu": "0.9547829855396939"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nПредоставете кратко описание на C++ кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8426287244529167",
      "bg": "0.8530995249891709",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9200759018007059",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}",
    "entry_point": "maxModeSum",
    "signature": "long long maxModeSum(int n, const int* counts)",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\nExample:\n>>> maxModeSum(3, {1, 2, 3})\n17\nA sequence that reaches its maximum value is (3,2,3,1,2,2).\n",
      "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\ngjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e\nnjë sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementet më të shpeshta në një sekuencë.\n\nShembull:\n>>> maxModeSum(3, {1, 2, 3})\n17\nNjë sekuencë që arrin vlerën e saj maksimale është (3,2,3,1,2,2).",
      "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, գտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարրը) բոլոր նախածանցների համար հաջորդականության, որը կազմված է այս թվերից: Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի մեջ հաջորդականության մեջ:\n\nՕրինակ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nՀաջորդականություն, որը հասնում է իր մաքսիմալ արժեքին, (3,2,3,1,2,2)-ն է:",
      "bn": "প্রদত্ত n ধনাত্মক পূর্ণসংখ্যা যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n\nউদাহরণ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nএকটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল (3,2,3,1,2,2)।",
      "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, изградена от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\n\nПример:\n>>> maxModeSum(3, {1, 2, 3})\n17\nПоследователност, която достига максималната си стойност, е (3,2,3,1,2,2).",
      "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。\n\n示例：\n>>> maxModeSum(3, {1, 2, 3})\n17\n一个达到其最大值的序列是 (3,2,3,1,2,2)。",
      "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\n\nExemple :\n>>> maxModeSum(3, {1, 2, 3})\n17\nUne séquence qui atteint sa valeur maximale est (3,2,3,1,2,2).",
      "de": "Gegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\nfinden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\naus diesen Zahlen konstruierten Sequenz. Der Modus ist die größte Zahl unter den\nhäufigsten Elementen in einer Sequenz.\n\nBeispiel:\n>>> maxModeSum(3, {1, 2, 3})\n17\nEine Sequenz, die ihren maximalen Wert erreicht, ist (3,2,3,1,2,2).",
      "ha": "An ba da n lambobi masu kyau da ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimillar yanayin (abun da aka fi samu) don dukkan abubuwan farko na jerin da aka gina daga wadannan lambobin. Yanayin shi ne mafi girman lamba a cikin abubuwan da aka fi samu a cikin jerin.\n\nMisali:\n>>> maxModeSum(3, {1, 2, 3})\n17\nJerin da ya kai matsakaicinsa shine (3,2,3,1,2,2).",
      "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n\nउदाहरण:\n>>> maxModeSum(3, {1, 2, 3})\n17\nएक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है (3,2,3,1,2,2)।",
      "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulási számát jelölik, \ntaláld meg a módusz (leggyakrabban előforduló elem) maximális összegét az ezekből a számokból \nfelépített sorozat minden prefixére. A módusz a legnagyobb szám a sorozat leggyakrabban előforduló elemei között.\n\nPélda:\n>>> maxModeSum(3, {1, 2, 3})\n17\nEgy sorozat, amely eléri a maximális értékét: (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "sq": "0.9949238019822724",
      "hy": "0.9622266590689763",
      "bn": "0.965083162578639",
      "bg": "0.9804307362300618",
      "zh": "0.9832683698535262",
      "fr": "1",
      "de": "1",
      "ha": "0.9535316141391741",
      "hi": "0.9675112203564096",
      "hu": "0.9362038942192146"
    }
  },
  {
    "task_id": "CPP/39",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example cases:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "sq": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\n * Një nënvarg është i përcaktuar nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut.\n * Shuma XOR e një nënvargu është rezultati i XOR-it të të gjitha elementeve nga L në R.\n * Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n *\n * Shembuj rastesh:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "hy": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Տրված է ամբողջ թվերի զանգված A, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR գումարը։\n * Ենթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= n, որտեղ n-ը զանգվածի չափն է։\n * Ենթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է։\n * Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR գումարների գումարն է։\n *\n * Օրինակ դեպքեր:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "bn": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হলে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\n * একটি উপঅ্যারে একটি ইন্ডেক্সের জোড়া (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\n * একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\n * চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলগুলির যোগফল।\n *\n * উদাহরণ কেস:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "bg": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\n * Подмасив се определя от двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива.\n * XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\n * Крайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n *\n * Примерни случаи:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "zh": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * 给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n * 子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。\n * 子数组的异或和是从L到R的所有元素的异或结果。\n * 最终结果是所有可能子数组的异或和的总和。\n *\n * 示例案例：\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "fr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\n * Un sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.\n * La somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\n * Le résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n *\n * Exemples de cas :\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "de": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\n * Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist.\n * Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\n * Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n *\n * Beispiel-Fälle:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "ha": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * An ba wani tsari A na lambobi, aikin shi ne a lissafa jumlar XOR na dukkan ƙananan tsaruka.\n * Ana ayyana ƙaramin tsari ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman tsari.\n * Jumlar XOR na ƙaramin tsari shine sakamakon XORing dukkan abubuwa daga L zuwa R.\n * Sakamakon ƙarshe shine jumlar XOR sums don dukkan yiwuwar ƙananan tsaruka.\n *\n * Misalan lokuta:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "hi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * दिए गए पूर्णांकों की एक array A के लिए, कार्य सभी उप-श्रृंखलाओं के XOR के योग की गणना करना है।\n * एक उप-श्रृंखला को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, जहाँ n array का आकार है।\n * एक उप-श्रृंखला का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\n * अंतिम परिणाम सभी संभावित उप-श्रृंखलाओं के लिए XOR योगों का योग है।\n *\n * उदाहरण मामले:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "hu": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Adott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámoljuk az összes részhalmaz XOR összegét.\n * Egy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\n * Egy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\n * A végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n *\n * Példa esetek:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)"
    },
    "prompt_bertscore": {
      "sq": "0.993520875601023",
      "hy": "0.9812496892910686",
      "bn": "0.9875712997978849",
      "bg": "0.9930342311674875",
      "zh": "0.9806712776214951",
      "fr": "0.993520875601023",
      "de": "0.993520875601023",
      "ha": "0.9771769719583293",
      "hi": "0.9834336303305472",
      "hu": "0.9795527899458876"
    },
    "canonical_solution": "{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}",
    "instruction": {
      "en": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nՏվեք CPP կոդի կարճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.9262475463698409",
      "bg": "0.9788407625177538",
      "zh": "0.9080992162745738",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9536396690664571",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    assert(sumOfXorSubarrays({1, 2, 3, 4, 5}) == 39);\n    assert(sumOfXorSubarrays({1, 1, 1}) == 4);\n    assert(sumOfXorSubarrays({2, 3, 1}) == 9);\n    assert(sumOfXorSubarrays({4, 5, 7, 9}) == 74);\n    assert(sumOfXorSubarrays({0, 0, 0, 0}) == 0);\n    assert(sumOfXorSubarrays({8, 8, 8, 8, 8}) == 72);\n    assert(sumOfXorSubarrays({3, 6, 9, 12, 15}) == 125);\n    assert(sumOfXorSubarrays({10, 20, 30, 40, 50}) == 390);\n    assert(sumOfXorSubarrays({16, 16, 16, 16, 16, 16}) == 192);\n    assert(sumOfXorSubarrays({1, 3, 5, 7, 9, 11, 13}) == 192);\n    assert(sumOfXorSubarrays({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) == 218);\n\n\n    return 0;\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "long long sumOfXorSubarrays(const std::vector<int>& A)",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n",
      "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogarisim shumën e XOR-it të të gjitha nënvargjeve. Një nënvarg është i përcaktuar nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= n, ku n është madhësia e vargut. Shuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R. Rezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembuj rastesh:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hy": "Տրված է ամբողջ թվերի A զանգվածը, խնդիրը բոլոր ենթազանգվածների XOR-ի գումարը հաշվարկելն է:\nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, որտեղ 1 <= L <= R <= n, n-ը զանգվածի չափն է:\nԵնթազանգվածի XOR գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ դեպքեր:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= n, যেখানে n হল অ্যারের আকার।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ কেস:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви. Подмасив се дефинира чрез двойка индекси (L, R) така че 1 <= L <= R <= n, където n е размерът на масива. XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R. Крайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПримерни случаи:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "zh": "给定一个整数数组A，任务是计算所有子数组的异或和之和。  \n子数组由一对索引(L, R)定义，其中1 <= L <= R <= n，n是数组的大小。  \n子数组的异或和是从L到R的所有元素进行异或运算的结果。  \n最终结果是所有可能子数组的异或和之和。\n\n示例案例:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.  \nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= n, où n est la taille du tableau.  \nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.  \nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nCas d'exemple :\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen. Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= n, wobei n die Größe des Arrays ist. Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R. Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispielhafte Fälle:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "ha": "An ba da wani jerin A na lambobin cikakkun lambobi, aikin shi ne lissafin jimillar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= n, inda n shine girman jerin.\nJimillar XOR na ƙaramin jeri shine sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shine jimillar XOR na dukkan yiwuwar ƙananan jerin.\n\nMisalan lamura:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hi": "दिए गए पूर्णांकों के एक array A के लिए, कार्य सभी उप-समुच्चयों के XOR का योग गणना करना है। \nएक उप-समुच्चय को (L, R) सूचकांकों की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= n, और n array का आकार है। \nएक उप-समुच्चय का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। \nअंतिम परिणाम सभी संभावित उप-समुच्चयों के XOR योगों का योग है।\n\nउदाहरण मामले:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "hu": "Adott egy A egész számokat tartalmazó tömb, a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= n, ahol n a tömb mérete.\nEgy részhalmaz XOR összege az L-től R-ig terjedő elemek XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda esetek:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "docstring_bertscore": {
      "sq": "0.9923926550367448",
      "hy": "0.9782283225651469",
      "bn": "0.9734709263089804",
      "bg": "0.9924031824469397",
      "zh": "0.9661307392082171",
      "fr": "0.9907644818034018",
      "de": "0.9924031824469397",
      "ha": "0.9500033426808514",
      "hi": "0.9749241061766316",
      "hu": "0.9592883198423272"
    }
  },
  {
    "task_id": "CPP/40",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being\n * positive integers and b >= k. Different legal representations of x are counted\n * only once. For example:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "sq": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\n * ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë\n * numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të x numërohen\n * vetëm një herë. Për shembull:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "hy": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Տրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի քանակը x,\n * որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b\n * դրական ամբողջ թվեր են և b >= k: x-ի տարբեր թույլատրելի ներկայացումները հաշվում են\n * միայն մեկ անգամ: Օրինակ՝\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "bn": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া হলে, ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন,\n * যেখানে 1 <= x <= n, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b\n * ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x এর বিভিন্ন বৈধ উপস্থাপনাগুলি শুধুমাত্র একবার গণনা করা হয়। উদাহরণস্বরূপ:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "bg": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,\n * където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са\n * положителни цели числа и b >= k. Различните легални представяния на x се броят\n * само веднъж. Например:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "zh": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * 给定两个正整数 n 和 k，找出多少个正整数 x，\n * 其中 1 <= x <= n，可以表示为 x = a^b，a 和 b 为\n * 正整数且 b >= k。x 的不同合法表示只计数一次。例如：\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "fr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Étant donnés deux entiers positifs n et k, trouver le nombre d'entiers positifs x,\n * où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant\n * des entiers positifs et b >= k. Les différentes représentations légales de x sont comptées\n * une seule fois. Par exemple :\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "de": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x,\n * wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b\n * positive ganze Zahlen sind und b >= k. Verschiedene zulässige Darstellungen von x werden\n * nur einmal gezählt. Zum Beispiel:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "ha": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * An ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x,\n * inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna\n * lambobi masu kyau kuma b >= k. Ana kirga bambance-bambancen halattattun wakilcin x\n * sau ɗaya kawai. Misali:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "hi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * दिए गए दो धनात्मक पूर्णांक n और k, ऐसे धनात्मक पूर्णांकों x की संख्या खोजें,\n * जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b\n * धनात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध निरूपण केवल एक बार गिने जाते हैं। उदाहरण के लिए:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "hu": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Két pozitív egész szám, n és k megadása esetén találjuk meg azon pozitív egész számok x számát,\n * ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. \n * Az x különböző érvényes ábrázolásait csak egyszer számoljuk. Például:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)"
    },
    "prompt_bertscore": {
      "sq": "0.9946373769728201",
      "hy": "0.9829382461602462",
      "bn": "0.9836187538456718",
      "bg": "0.9902847894332026",
      "zh": "0.9731177614915003",
      "fr": "1",
      "de": "0.9845874742139789",
      "ha": "0.9856052562864016",
      "hi": "0.9772828419514209",
      "hu": "0.9612190071459864"
    },
    "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}",
    "instruction": {
      "en": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nՏվեք հակիրճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\n将以下 CPP 代码的自然语言描述（文档字符串）翻译成中文，字数不超过 500 个字符。",
      "fr": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nFournir une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9401782895133417",
      "bn": "0.8439591507450884",
      "bg": "0.8329214591013607",
      "zh": "0.8402199338221066",
      "fr": "0.9697481957076245",
      "de": "0.9255146002638222",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.931788142218428"
    },
    "level": "",
    "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}",
    "entry_point": "countPowerNumbers",
    "signature": "int countPowerNumbers(int n, int k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of x are counted only once. For example:\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "sq": "Dhënë dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të x numërohen vetëm një herë. Për shembull:\n    >>> countPowerNumbers(99, 1)\n    99",
      "hy": "Տրված են երկու դրական ամբողջ թվեր՝ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k: x-ի տարբեր օրինական ներկայացումները հաշվում են միայն մեկ անգամ: Օրինակ՝\n    >>> countPowerNumbers(99, 1)\n    99",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন, যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। x এর বিভিন্ন বৈধ উপস্থাপনাগুলি কেবল একবার গণনা করা হয়। উদাহরণস্বরূপ:\n    >>> countPowerNumbers(99, 1)\n    99",
      "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b като положителни цели числа и b >= k. Различните легални представяния на x се броят само веднъж. Например:\n    >>> countPowerNumbers(99, 1)\n    99",
      "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，其中 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。不同的合法表示方法的 x 只计数一次。例如：\n    >>> countPowerNumbers(99, 1)\n    99",
      "fr": "Étant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés sous la forme x = a^b avec a et b étant des entiers positifs et b >= k. Différentes représentations légales de x sont comptées une seule fois. Par exemple :\n    >>> countPowerNumbers(99, 1)\n    99",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene gültige Darstellungen von x werden nur einmal gezählt. Zum Beispiel:\n    >>> countPowerNumbers(99, 1)\n    99",
      "ha": "An ba da lambobi masu kyau guda biyu n da k, nemo adadin lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b suna zama lambobi masu kyau kuma b >= k. Ana ƙidaya daban-daban halattattun wakilcin x sau ɗaya kawai. Alal misali:\n    >>> countPowerNumbers(99, 1)\n    99",
      "hi": "दो सकारात्मक पूर्णांक n और k दिए गए हैं, उन सकारात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b सकारात्मक पूर्णांक हैं और b >= k है। x के विभिन्न वैध निरूपणों को केवल एक बार गिना जाता है। उदाहरण के लिए:\n    >>> countPowerNumbers(99, 1)\n    99",
      "hu": "Két pozitív egész szám, n és k esetén, találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Az x különböző érvényes ábrázolásait csak egyszer számoljuk. Például:\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "sq": "0.9907090639270931",
      "hy": "0.9805816953196483",
      "bn": "0.9320916494406494",
      "bg": "0.9965227765496032",
      "zh": "0.957459331293758",
      "fr": "0.9892346306086711",
      "de": "0.9805816953196483",
      "ha": "0.9733851179843732",
      "hi": "0.9682858788424457",
      "hu": "0.9341248300209224"
    }
  },
  {
    "task_id": "CPP/41",
    "prompt": {
      "en": "#include <cassert>\n/* Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "sq": "#include <cassert>\n/* Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hy": "#include <cassert>\n/* Տրված է երեք ամբողջ թիվ՝ n, m և k, գտնել հաջորդականությունների քանակը, որոնք կազմված են n '(' և m ')',\nայնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվարկվի 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "bn": "#include <cassert>\n/* তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া আছে, n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা খুঁজে বের করুন,\nযাতে দীর্ঘতম ব্যালান্সড উপসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলো গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "bg": "#include <cassert>\n/* Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтакива че най-дългата балансирана подредена последователност е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "zh": "#include <cassert>\n/* 给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，\n使得最长的平衡子序列的长度为 2 * k。结果应以 1,000,000,007 (10^9 + 7) 为模计算。\n\n例如:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "fr": "#include <cassert>\n/* Étant donné trois entiers n, m, et k, trouver le nombre de séquences consistant en n '(' et m ')',\ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "de": "#include <cassert>\n/* Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen,\nso dass die längste ausbalancierte Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "ha": "#include <cassert>\n/* An ba da lambobi guda uku n, m, da k, nemo adadin jerin abubuwan da suka ƙunshi n '(' da m ')',\nta yadda mafi tsawon jere mai daidaito yana da tsawon 2 * k. Ya kamata a ƙididdige sakamakon modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hi": "#include <cassert>\n/* तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं,\nऐसे कि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) के माड्यूलो में गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "hu": "#include <cassert>\n/* Adott három egész szám: n, m és k. Meg kell találni az olyan sorozatok számát, amelyek n '(' és m ')' jelekből állnak,\núgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9931184504490463",
      "bn": "0.98077396952849",
      "bg": "0.9860388664082008",
      "zh": "0.9790015906385158",
      "fr": "0.9974746133355225",
      "de": "0.9859975512889455",
      "ha": "0.9779971168016224",
      "hi": "0.9961318719597266",
      "hu": "0.9525178046743721"
    },
    "canonical_solution": "{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nՀամառոտ բնութագրեք (docstring) տրված CPP կոդը հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa, ta amfani da haruffa 500 kacal.",
      "hi": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.8571055025138825",
      "bn": "0.8696780111118667",
      "bg": "0.8329214591013607",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9354709481131959",
      "hi": "0.9117634189847768",
      "hu": "0.9330776506521065"
    },
    "level": "",
    "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "sq": "Duke pasur tre numra të plotë n, m, dhe k, gjeni numrin e sekuencave që përbëhen nga n '(' dhe m ')',\ntë tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k. Rezultati duhet të llogaritet modulo 1,000,000,007 (10^9 + 7).\n\nPër shembull:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hy": "Երեք ամբողջ թիվ n, m և k ունենալով, գտնել հաջորդականությունների քանակը, որոնք բաղկացած են n '(' և m ')' նշաններից, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի 2 * k երկարությամբ։ Արդյունքը պետք է հաշվել 1,000,000,007 (10^9 + 7) մոդուլով։\n\nՕրինակ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bn": "তিনটি পূর্ণসংখ্যা n, m, এবং k দেওয়া হয়েছে, n টির '(' এবং m টির ')' নিয়ে গঠিত ক্রমের সংখ্যা খুঁজে বের করুন, যাতে দীর্ঘতম সুষম উপধারা 2 * k দৈর্ঘ্যের হয়। ফলাফলটি 1,000,000,007 (10^9 + 7) দ্বারা মডুলোতে গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "bg": "Дадени са три цели числа n, m и k, намерете броя на последователностите, състоящи се от n '(' и m ')',\nтака че най-дългата балансирана подпоследователност да е с дължина 2 * k. Резултатът трябва да бъде изчислен по модул 1,000,000,007 (10^9 + 7).\n\nНапример:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "zh": "给定三个整数 n, m 和 k，找出由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k。结果应取模 1,000,000,007 (10^9 + 7)。\n\n例如：\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "fr": "Étant donné trois entiers n, m, et k, trouvez le nombre de séquences constituées de n '(' et m ')', \ntelles que la plus longue sous-séquence équilibrée soit de longueur 2 * k. Le résultat doit être calculé modulo 1,000,000,007 (10^9 + 7).\n\nPar exemple :\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "de": "Gegeben drei ganze Zahlen n, m und k, finde die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, \nso dass die längste ausgeglichene Teilsequenz die Länge 2 * k hat. Das Ergebnis sollte modulo 1.000.000.007 (10^9 + 7) berechnet werden.\n\nZum Beispiel:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "ha": "An ba da lambobi guda uku n, m, da k, nemo yawan jerin lambobi da suka ƙunshi n '(' da m ')', \nta yadda mafi tsawon jeri mai daidaito yana da tsawon 2 * k. Sakamakon ya kamata a ƙididdige shi modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hi": "तीन पूर्णांक n, m, और k दिए गए हैं, उन अनुक्रमों की संख्या खोजें जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम 2 * k लंबाई का हो। परिणाम को 1,000,000,007 (10^9 + 7) से मापांकित करके गणना की जानी चाहिए।\n\nउदाहरण के लिए:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "hu": "Három egész szám, n, m és k megadása esetén találja meg az olyan sorozatok számát, amelyek n '(' és m ')' jelekből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k. Az eredményt 1,000,000,007 (10^9 + 7) modulo szerint kell kiszámítani.\n\nPéldául:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9996007529341199",
      "hy": "0.9759792307606889",
      "bn": "0.9691481333265181",
      "bg": "0.9942832190034349",
      "zh": "0.9623327276924489",
      "fr": "0.9964647764783411",
      "de": "0.9841463161377004",
      "ha": "0.9712804304669276",
      "hi": "0.9676981315449634",
      "hu": "0.9605236021819832"
    }
  },
  {
    "task_id": "CPP/42",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *\n * For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem \n * koordinativ Kartezian në plan me këndin e poshtëm të majtë në (0,0) dhe këndin \n * e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve \n * për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo \n * operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon nëpër \n * pika me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme \n * ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet poshtë. Përgjigjja duhet të \n * jetë modulo 10^9+7.\n *\n * Për shembull:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության \n * Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի-ձախ անկյունով (0,0) \n * կետում և վերևի-աջ անկյունով (n,m) կետում, դուք պետք է հաշվեք \n * սպասվող գործողությունների քանակը՝ թուղթը կտրելու համար այնպես, որ \n * մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ \n * պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է \n * ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն \n * շոշափում է եզրը): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասը \n * հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n *\n * Օրինակ:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * একটি আয়তাকার কাগজ n x m আকারের যা একটি সমতল কার্টেসিয়ান স্থানাঙ্ক \n * পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ, \n * আপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে \n * অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে \n * নির্বাচন করা হয় যা অক্ষের সাথে সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ \n * বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র \n * প্রান্ত স্পর্শ করে না)। এই লাইনের সাথে বরাবর কাগজের নিচের বা ডান অংশ \n * তারপর বাতিল করা হয়। উত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n *\n * উদাহরণস্বরূপ:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна \n * декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m). \n * Трябва да изчислите очаквания брой операции за рязане на хартията така, че \n * оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, \n * която е успоредна на осите, преминава през точки с цели координати и \n * пресича (не само докосва ръба) хартията. Долната или дясната част на хартията \n * по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n *\n * Например:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0)，右上角在 (n,m)，\n * 需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，\n * 该线通过整数坐标点，并切割（不仅仅是接触边缘）纸张。沿着这条线的底部或右侧部分的纸张将被丢弃。\n * 答案应对 10^9+7 取模。\n *\n * 例如：\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées \n * cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \n * vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que \n * la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard \n * qui est parallèle aux axes, passe par des points avec des coordonnées entières, \n * et coupe (sans se contenter de toucher le bord) le papier. La partie inférieure ou droite \n * du papier le long de cette ligne est ensuite éliminée. La réponse doit être modulo 10^9+7.\n *\n * Par exemple :\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem \n * platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), \n * müssen Sie die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass \n * die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, \n * die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier \n * durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser \n * Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n *\n * Zum Beispiel:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba takardar murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawar Cartesian \n * tare da kusurwar ƙasa-hagu a (0,0) da kuma kusurwar sama-dama a (n,m), \n * kana buƙatar lissafin yawan ayyukan da ake tsammanin za a yi don yanke takardar ta yadda \n * yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi a bazuwar \n * wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, \n * kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama \n * na takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n *\n * Alal misali:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए एक आयताकार कागज का आकार n x m है जो एक समतल कार्टेशियन निर्देशांक \n * प्रणाली पर रखा गया है, जिसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है। \n * आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है ताकि कागज का शेष क्षेत्रफल k से कम हो जाए। \n * प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, \n * पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूती नहीं है)। \n * इस रेखा के साथ कागज का निचला या दायां हिस्सा फिर त्याग दिया जाता है। उत्तर 10^9+7 के मापांक में होना चाहिए।\n *\n * उदाहरण के लिए:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy n x m méretű téglalap alakú papír, amely egy derékszögű koordináta-rendszerben \n * helyezkedik el, az alsó-bal sarka a (0,0) pontban, a jobb-felső sarka pedig az (n,m) pontban van. \n * Ki kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk, hogy a megmaradt terület \n * kisebb legyen, mint k. Minden művelet során véletlenszerűen kiválasztunk egy vonalat, amely \n * párhuzamos a tengelyekkel, egész koordinátákkal rendelkező pontokon halad át, és átvágja \n * (nem csak érinti a szélét) a papírt. A papír alsó vagy jobb oldali része ezután eldobásra kerül \n * ezen a vonalon. Az eredménynek 10^9+7 modulo szerint kell lennie.\n *\n * Például:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)"
    },
    "prompt_bertscore": {
      "sq": "0.9654341424619277",
      "hy": "0.9546213004095315",
      "bn": "0.9640753120252681",
      "bg": "0.9453804191926454",
      "zh": "0.9397208437458183",
      "fr": "0.9663706847085072",
      "de": "0.9653916355603862",
      "ha": "0.9535868333851019",
      "hi": "0.9379341634684095",
      "hu": "0.9389483701939737"
    },
    "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nՀամաձայն CPP կոդի, տրամադրել կարճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\n将以下CPP代码的功能描述为简洁的自然语言（文档字符串），使用不超过500个字符的中文。",
      "fr": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.8474848400084577",
      "bn": "0.8961844409394485",
      "bg": "0.8365011292951701",
      "zh": "0.845198008431603",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.942440093662186"
    },
    "level": "",
    "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}",
    "entry_point": "expectedCuts",
    "signature": "long long expectedCuts(int n, int m, long long k)",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n you need to calculate the expected number of operations to cut the paper such that \n the remaining area is less than k. In each operation, a line is randomly chosen \n that is parallel to the axes, passes through points with integer coordinates, \n and cuts through (not just touching the edge) the paper. The bottom or right part \n of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n",
      "sq": "Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, një vijë zgjidhet rastësisht që është paralele me boshtet, kalon nëpër pika me koordinata të plota, dhe pret (jo vetëm prek buzën) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije pastaj hidhet. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hy": "Ունենալով n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթ Cartesian կոորդինատային \nհամակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, \nպետք է հաշվարկել սպասվող գործողությունների քանակը, որպեսզի կտրենք թուղթը այնպես, որ \nմնացած մակերեսը լինի փոքր քան k: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է \nգիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով, \nև կտրում է (ոչ միայն հպվում է եզրին) թուղթը: Թղթի այդ գծի երկայնքով ներքևի կամ աջ մասը \nապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bn": "দেওয়া একটি আয়তাকার কাগজের আকার n x m যা একটি সমতল কার্টেসিয়ান স্থানাঙ্ক ব্যবস্থায় স্থাপন করা হয়েছে, যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ রয়েছে, আপনাকে কাগজ কাটার প্রত্যাশিত সংখ্যক অপারেশন গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে বেছে নেওয়া হয় যা অক্ষগুলোর সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের মধ্য দিয়ে কেটে যায় (শুধুমাত্র প্রান্ত স্পর্শ নয়)। এই লাইনের সাথে কাগজের নিচের বা ডান দিকের অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "bg": "Даден е правоъгълен лист хартия с размер n x m, разположен в равнинна \nдекартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). \nТрябва да изчислите очаквания брой операции за изрязване на хартията така, че \nоставащата площ да е по-малка от k. При всяка операция се избира произволна линия, \nкоято е успоредна на осите, минава през точки с цели координати и пресича (не само \nдокосва ръба) хартията. Долната или дясната част на хартията по тази линия след това \nсе изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nПример:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 位置，右上角在 (n,m) 位置，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的直线，该直线通过整数坐标的点，并切割（不仅仅是触及边缘）纸张。沿着这条线的纸张底部或右侧部分将被丢弃。答案应取模 10^9+7。\n\n例如：\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées \ncartésiennes plan avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), \nvous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que \nla surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard \nqui est parallèle aux axes, passe par des points avec des coordonnées entières, \net coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite \ndu papier le long de cette ligne est ensuite jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "de": "Gegeben ein rechteckiges Papier der Größe n x m, das auf einem kartesischen Koordinatensystem liegt, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m), müssen Sie die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "ha": "An ba takarda rectangle mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kuma kusurwar sama-dama a (n,m), kana buƙatar ƙididdige adadin ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi a bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana watsar da ɓangaren ƙasa ko dama na takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hi": "दिया गया एक आयताकार कागज जिसका आकार n x m है, एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसकी निचली-बाएँ कोना (0,0) पर है और ऊपरी-दाएँ कोना (n,m) पर है। आपको कागज को इस तरह से काटने के लिए अपेक्षित संचालन की संख्या की गणना करनी है कि शेष क्षेत्रफल k से कम हो। प्रत्येक संचालन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने तक नहीं)। इस रेखा के साथ कागज का निचला या दायाँ भाग तब हटा दिया जाता है। उत्तर को 10^9+7 के मापांक में होना चाहिए।\n\nउदाहरण के लिए:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "hu": "Adott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben helyezkedik el, az alsó-bal sarka a (0,0) pontban, a felső-jobb sarka pedig az (n,m) pontban van. Ki kell számítani a várható műveletek számát ahhoz, hogy a papírt úgy vágjuk el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután eldobásra kerül. Az eredményt 10^9+7 modullal kell megadni.\n\nPéldául:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9625863786890305",
      "hy": "0.9443983905888089",
      "bn": "0.9594208063064775",
      "bg": "0.9389074523354805",
      "zh": "0.9379401223798406",
      "fr": "0.9716254514387852",
      "de": "0.9621781932560038",
      "ha": "0.9646833196216158",
      "hi": "0.9371156076681647",
      "hu": "0.9347576664148995"
    }
  },
  {
    "task_id": "CPP/43",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "sq": "#include <bits/stdc++.h>\n/*\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandryshuara dhe duke renditur secilin segment (dmth, zgjidhni k-1 pika ndarëse 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hy": "#include <bits/stdc++.h>\n/*\nՈւնենալով n տարրերի q փոխատեղում և k ամբողջ թիվ, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 բաժանման կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "bn": "#include <bits/stdc++.h>\n/*\nএকটি n উপাদানের permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q, যেখানে f(p) হল বর্ণানুক্রমিকভাবে সবচেয়ে ছোট permutation যা p কে ঠিক k টি খালি নয় এমন ধারাবাহিক segment এ ভাগ করে এবং প্রতিটি segment কে সাজিয়ে পাওয়া যায় (অর্থাৎ, k-1 টি breakpoint নির্বাচন করুন 1 <= x_1 < x_2 < ... < x_{k-1} < n, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "bg": "#include <bits/stdc++.h>\n/*\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да се получи, като се раздели p на точно k непразни съседни сегмента и се сортира всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "zh": "#include <bits/stdc++.h>\n/*\n给定一个由 n 个元素组成的排列 q 和一个整数 k，找出有多少个 n 元素的排列 p 使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序（即选择 k-1 个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其划分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）可以获得的字典序最小的排列。结果应对 998244353 取模。\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "fr": "#include <bits/stdc++.h>\n/*\nÉtant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et le diviser en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "de": "#include <bits/stdc++.h>\n/*\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die durch Aufteilen von p in genau k nicht-leere zusammenhängende Segmente und Sortieren jedes Segments erhalten werden kann (d.h., wähle k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teile es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "ha": "#include <bits/stdc++.h>\n/*\nAn ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n inda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da abubuwa masu jere kuma a tsara kowanne sashe (wato, zaɓi k-1 wuraren tsagewa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma a raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya zama modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hi": "#include <bits/stdc++.h>\n/*\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली निरंतर खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात्, k-1 ब्रेकपॉइंट्स चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "hu": "#include <bits/stdc++.h>\n/*\nAdott egy q permutáció n elemről és egy egész szám k, találd meg azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) az a lexikográfiailag legkisebb permutáció, amelyet úgy kapunk, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és osszuk fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] részekre). Az eredménynek modulo 998244353 kell lennie.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])"
    },
    "prompt_bertscore": {
      "sq": "0.9718872462809892",
      "hy": "0.9633900372106977",
      "bn": "0.989649370844272",
      "bg": "0.9964997354254032",
      "zh": "0.9747747361300934",
      "fr": "0.9965146327039808",
      "de": "0.9906822488256534",
      "ha": "0.9519092011868812",
      "hi": "0.9935544441354178",
      "hu": "0.9718034242601924"
    },
    "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nՏրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) այս CPP կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nПредоставете кратко описание на кода на CPP на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\n请用中文为以下CPP代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9074010985564885",
      "bn": "0.8439591507450884",
      "bg": "0.8329214591013607",
      "zh": "0.8898046317309889",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}",
    "entry_point": "countPermutations",
    "signature": "int countPermutations(int n, int k, int qq[])",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n",
      "sq": "Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke ndarë p në saktësisht k segmente të pandara jo-bosh dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarëse 1 <= x_1 < x_2 < ... < x_{k-1} < n, dhe ndajeni në [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Rezultati duhet të jetë modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hy": "Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը, այնպես, որ f(p) = q, որտեղ f(p)-ն ամենափոքր լեքսիկոգրաֆիկ փոխատեղումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրման կետեր 1 <= x_1 < x_2 < ... < x_{k-1} < n, և բաժանել այն [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bn": "n উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া হয়েছে, n উপাদানের কতগুলি permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q হয়, যেখানে f(p) হল lexicographically ক্ষুদ্রতম permutation যা ঠিক k টি খালি নয় এমন সংলগ্ন segment-এ p ভাগ করে এবং প্রতিটি segment sort করে পাওয়া যায় (অর্থাৎ, k-1 টি breakpoint 1 <= x_1 < x_2 < ... < x_{k-1} < n নির্বাচন করুন, এবং এটিকে [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] তে ভাগ করুন)। ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x_1 < x_2 < ... < x_{k-1} < n, и го разделете на [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Резултатът трябва да бъде модуло 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找出有多少个由 n 个元素组成的排列 p 使得 f(p) = q，其中 f(p) 是可以通过将 p 精确地划分为 k 个非空连续段并对每个段进行排序而获得的字典序最小的排列（即，选择 k-1 个断点 1 <= x_1 < x_2 < ... < x_{k-1} < n，并将其划分为 [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]）。结果应对 998244353 取模。\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez k-1 points de rupture 1 <= x_1 < x_2 < ... < x_{k-1} < n, et divisez-le en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Le résultat doit être modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "de": "Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h. wähle k-1 Trennpunkte 1 <= x_1 < x_2 < ... < x_{k-1} < n, und teile es in [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Das Ergebnis sollte modulo 998244353 sein.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "ha": "An ba da permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n irin cewa f(p) = q, inda f(p) shine permutation mafi ƙanƙanta a cikin tsarin lexicographically wanda za a iya samu ta hanyar raba p zuwa daidai k sassa masu cike da abubuwa masu jere kuma a tsara kowanne sashe (wato, zaɓi k-1 wuraren tsayawa 1 <= x_1 < x_2 < ... < x_{k-1} < n, kuma a raba shi zuwa [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Sakamakon ya kasance modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hi": "दिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या ज्ञात करें p ताकि f(p) = q, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, k-1 ब्रेकपॉइंट चुनें 1 <= x_1 < x_2 < ... < x_{k-1} < n, और इसे [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] में विभाजित करें)। परिणाम 998244353 के मापांक में होना चाहिए।\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "hu": "Adott egy q permutáció n elemre és egy egész szám k, találd meg azon p permutációk számát n elemre, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk és minden szegmenst sorba rendezünk (azaz válasszunk k-1 töréspontot 1 <= x_1 < x_2 < ... < x_{k-1} < n, és osszuk fel [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] részekre). Az eredménynek 998244353-mal kell modulozni.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9846323646800927",
      "hy": "0.9873110939987293",
      "bn": "0.9692986951553425",
      "bg": "0.9970463662340112",
      "zh": "0.9679662825593605",
      "fr": "0.9964004202348857",
      "de": "0.999999801369619",
      "ha": "0.958689250613126",
      "hi": "0.999999801369619",
      "hu": "0.9752550243914357"
    }
  },
  {
    "task_id": "CPP/44",
    "prompt": {
      "en": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Given an array of n distinct integers representing the heights of Kira's friends, \n * find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \n * of the maximum and minimum values of the triplet is 1.\n * \n * Example usage:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "sq": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Duke pasur një varg prej n numrash të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës,\n * gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që maksimumi dhe minimumi i tresheve\n * të kenë si përbashkët vetëm numrin 1.\n * \n * Shembull përdorimi:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "hy": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Տրված է n տարբեր ամբողջ թվերից կազմված զանգված, որը ներկայացնում է Կիրայի ընկերների բարձրությունները,\n * գտնել եղանակների քանակը, որոնցով կարելի է ընտրել եռյակ (a, b, c) այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների \n * ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n * \n * Օրինակ օգտագործում:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "bn": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * কিরার বন্ধুদের উচ্চতা প্রতিনিধিত্বকারী n টি স্বতন্ত্র পূর্ণসংখ্যার একটি অ্যারে দেওয়া আছে,\n * এমন একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন\n * মানের গ্রেটেস্ট কমন ডিভাইজর (GCD) 1 হয়।\n * \n * উদাহরণ ব্যবহার:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "bg": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира,\n * намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД)\n * на максималната и минималната стойност на тройката да е 1.\n * \n * Пример за използване:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "zh": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * 给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友们的身高，\n * 找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n * \n * 示例用法:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "fr": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira,\n * trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD)\n * des valeurs maximale et minimale du triplet soit 1.\n * \n * Exemple d'utilisation :\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "de": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen, \n * finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) zu wählen, sodass der größte gemeinsame Teiler (GCD) \n * der maximalen und minimalen Werte des Tripels 1 ist.\n * \n * Beispielverwendung:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "ha": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokan Kira,\n * nemo adadin hanyoyin zaɓar triplet (a, b, c) ta yadda mafi girman abin raba kowa da kowa (GCD)\n * na mafi girma da mafi ƙanƙanta ƙima na triplet ɗin shine 1.\n * \n * Misalin amfani:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "hi": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kira के दोस्तों की ऊँचाइयों का प्रतिनिधित्व करने वाले n भिन्न पूर्णांकों के एक array को दिया गया है,\n * उन तरीकों की संख्या खोजें जिनसे एक त्रय (a, b, c) चुना जा सकता है ताकि त्रय के अधिकतम और न्यूनतम मानों का \n * महत्तम समापवर्तक (GCD) 1 हो।\n * \n * उदाहरण उपयोग:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "hu": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Adott egy tömb n különböző egész számmal, amelyek Kira barátainak magasságát képviselik,\n * meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas \n * legnagyobb és legkisebb értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n * \n * Példa használat:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)"
    },
    "prompt_bertscore": {
      "sq": "0.9376072178612261",
      "hy": "1",
      "bn": "0.9951156789303521",
      "bg": "0.9983654705944639",
      "zh": "0.9920412778926941",
      "fr": "0.9954972478923201",
      "de": "1",
      "ha": "0.9684690160537598",
      "hi": "0.9698620109159575",
      "hu": "0.9567319468384082"
    },
    "canonical_solution": "{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
    "instruction": {
      "en": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n请用不超过500个字符的中文为以下CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.9267393551932832",
      "bn": "0.8868565596156691",
      "bg": "0.8329214591013607",
      "zh": "0.8753791003083301",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(countTriplets({1, 5, 7}) == 1);\n    assert(countTriplets({1, 6, 2, 3}) == 3);\n    assert(countTriplets({16, 4, 8, 2}) == 0);\n    assert(countTriplets({10, 1, 6, 7, 9, 8, 4, 3, 5, 2}) == 77);\n    assert(countTriplets({4, 5, 9, 11, 14}) == 7);\n    assert(countTriplets({15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}) == 104);\n    assert(countTriplets({3, 7, 11, 13}) == 4);\n    assert(countTriplets({5, 12, 13, 17, 19}) == 10);\n    assert(countTriplets({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) == 87);\n    assert(countTriplets({1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}) == 122);\n\n    return 0;\n}",
    "entry_point": "countTriplets",
    "signature": "int countTriplets(const std::vector<int>& heights)",
    "docstring": {
      "en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\nExample usage:\n>>> countTriplets({1, 5, 7})\n1",
      "sq": "Jepet një varg me n numra të plotë të dallueshëm që përfaqësojnë lartësitë e miqve të Kirës, gjeni numrin e mënyrave për të zgjedhur një treshe (a, b, c) të tillë që faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale të treshes të jetë 1.\n\nShembull përdorimi:\n>>> countTriplets({1, 5, 7})\n1",
      "hy": "Տրված է n տարբեր ամբողջ թվերի զանգված, որոնք ներկայացնում են Կիրայի ընկերների բարձրությունները, գտնել եղանակների քանակը, որպեսզի ընտրել եռյակ (a, b, c), այնպես, որ եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\nՕրինակ օգտագործում:\n>>> countTriplets({1, 5, 7})\n1",
      "bn": "একটি n ভিন্ন পূর্ণসংখ্যার অ্যারে দেওয়া হয়েছে যা কিরার বন্ধুদের উচ্চতা উপস্থাপন করে, ট্রিপলেট (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা খুঁজুন যাতে ট্রিপলেটের সর্বাধিক এবং সর্বনিম্ন মানের গ্রেটেস্ট কমন ডিভাইসার (GCD) 1 হয়।\n\nব্যবহারের উদাহরণ:\n>>> countTriplets({1, 5, 7})\n1",
      "bg": "Даден е масив от n различни цели числа, представляващи височините на приятелите на Кира, намерете броя на начините да изберете тройка (a, b, c) така, че най-големият общ делител (НОД) на максималната и минималната стойност на тройката да е 1.\n\nПример за използване:\n>>> countTriplets({1, 5, 7})\n1",
      "zh": "给定一个由 n 个不同整数组成的数组，表示 Kira 的朋友的身高，找出选择一个三元组 (a, b, c) 的方法数，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n示例用法：\n>>> countTriplets({1, 5, 7})\n1",
      "fr": "Étant donné un tableau de n entiers distincts représentant les hauteurs des amis de Kira, trouver le nombre de façons de choisir un triplet (a, b, c) tel que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\nExemple d'utilisation :\n>>> countTriplets({1, 5, 7})\n1",
      "de": "Gegeben ein Array von n verschiedenen ganzen Zahlen, die die Höhen von Kiras Freunden darstellen, finde die Anzahl der Möglichkeiten, ein Tripel (a, b, c) so zu wählen, dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\nBeispielverwendung:\n>>> countTriplets({1, 5, 7})\n1",
      "ha": "An ba da wani tsari na lambobi daban-daban n da ke wakiltar tsayin abokai na Kira, nemo adadin hanyoyin da za a zaɓi triplet (a, b, c) ta yadda mafi girman raba mai yawa (GCD) na mafi girma da ƙananan ƙimomi na triplet ɗin ya zama 1.\n\nMisalin amfani:\n>>> countTriplets({1, 5, 7})\n1",
      "hi": "n अद्वितीय पूर्णांकों की एक array दी गई है जो कि किरा के दोस्तों की ऊँचाई का प्रतिनिधित्व करती है, उन तरीकों की संख्या खोजें जिनसे एक त्रिक (a, b, c) चुना जा सके ताकि त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\nउदाहरण उपयोग:\n>>> countTriplets({1, 5, 7})\n1",
      "hu": "Egy n különböző egész számot tartalmazó tömböt kapunk, amely Kira barátainak magasságát jelképezi. Meg kell találni, hányféleképpen lehet kiválasztani egy hármast (a, b, c) úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\nPélda használat:\n>>> countTriplets({1, 5, 7})\n1"
    },
    "docstring_bertscore": {
      "sq": "0.9864287778461723",
      "hy": "0.9845264946870012",
      "bn": "0.9957427550432792",
      "bg": "1",
      "zh": "1",
      "fr": "0.993190751907743",
      "de": "0.9949095005948378",
      "ha": "0.831414450400449",
      "hi": "0.9713920607410692",
      "hu": "0.9182810776776745"
    }
  },
  {
    "task_id": "CPP/45",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *\n * Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ju jepet një imazh 1 me n piksel, ku secili piksel ka një ngjyrë\n * të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku\n * zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë\n * në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur\n * dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve\n * të nevojshme për të bërë të gjithë piksela të së njëjtës ngjyrë.\n *\n * Shënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n *\n * Shembuj:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Ձեզ տրված է 1x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, \n * որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, \n * որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները \n * ընտրված գույնով: Երկու պիքսելներ միացված են, եթե նրանք հարևան են և ունեն \n * նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է \n * բոլոր պիքսելները նույն գույնի դարձնելու համար:\n *\n * Նշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնից:\n *\n * Օրինակներ:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * আপনাকে 1 বাই n পিক্সেল ইমেজ দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ \n * একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি \n * একটি রঙ বেছে নেন এবং একই রঙের সংযুক্ত সমস্ত পিক্সেলকে \n * নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় \n * এবং একই রঙ থাকে। সমস্ত পিক্সেলকে একই রঙে করতে \n * প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজুন।\n *\n * নোট: প্রতিটি রঙের জন্য, সর্বাধিক 20টি পিক্সেল সেই রঙের হতে পারে।\n *\n * উদাহরণ:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадено ви е изображение с размер 1 на n пиксела, където всеки пиксел има цвят,\n * представен от цяло число. Можете да извършите операция, при която избирате цвят\n * и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела\n * са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции,\n * необходими, за да направите всички пиксели с един и същи цвят.\n *\n * Забележка: За всеки цвят има най-много 20 пиксела от този цвят.\n *\n * Примери:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定一个1乘n像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，\n * 即选择一种颜色并将所有相连的同色像素更改为所选颜色。如果两个像素相邻且颜色相同，\n * 则它们是相连的。找出将所有像素变为同一颜色所需的最小操作次数。\n *\n * 注意：对于每种颜色，最多有20个该颜色的像素。\n *\n * 示例：\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Vous avez une image de 1 par n pixels, où chaque pixel a une couleur \n * représentée par un entier. Vous pouvez effectuer une opération où vous \n * choisissez une couleur et changez tous les pixels connectés de la même couleur \n * en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents \n * et ont la même couleur. Trouvez le nombre minimum d'opérations \n * nécessaires pour que tous les pixels soient de la même couleur.\n *\n * Remarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n *\n * Exemples :\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Sie haben ein 1xN-Pixel-Bild, bei dem jeder Pixel eine Farbe hat, \n * die durch eine ganze Zahl dargestellt wird. Sie können eine \n * Operation durchführen, bei der Sie eine Farbe auswählen und alle \n * verbundenen Pixel derselben Farbe in die gewählte Farbe ändern. \n * Zwei Pixel sind verbunden, wenn sie benachbart sind und die \n * gleiche Farbe haben. Finden Sie die minimale Anzahl von \n * Operationen, die erforderlich sind, um alle Pixel in die gleiche \n * Farbe zu ändern.\n *\n * Hinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n *\n * Beispiele:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * An ba ku hoton pixel 1 ta n, inda kowanne pixel yana da launi \n * wanda aka wakilta da lamba. Kuna iya aiwatar da aiki inda za ku \n * zaɓi launi kuma ku canza duk pixels da aka haɗa na launi ɗaya zuwa \n * launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa da juna \n * kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake \n * buƙata don sanya duk pixels su zama launi ɗaya.\n *\n * Lura: Ga kowanne launi, akwai a kalla pixels 20 na wannan launi.\n *\n * Misalai:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * आपको एक 1 बाय n पिक्सेल छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग \n * एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप \n * एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में \n * बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका \n * रंग समान होता है। सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक \n * न्यूनतम ऑपरेशनों की संख्या खोजें।\n *\n * नोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n *\n * उदाहरण:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Adott egy 1 x n képpontból álló kép, ahol minden képpont színét egy \n * egész szám reprezentálja. Végrehajtható egy olyan művelet, amely során \n * kiválaszt egy színt, és az összes összekapcsolt, azonos színű képpontot \n * megváltoztatja a kiválasztott színre. Két képpont akkor van összekapcsolva, \n * ha szomszédosak és azonos színűek. Határozza meg a minimális műveletek \n * számát, amelyek szükségesek ahhoz, hogy az összes képpont azonos színű legyen.\n *\n * Megjegyzés: Minden szín esetében legfeljebb 20 képpont van az adott színből.\n *\n * Példák:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)"
    },
    "prompt_bertscore": {
      "sq": "0.9852717558766441",
      "hy": "0.9874042516474346",
      "bn": "0.9801339824407956",
      "bg": "0.9795506050116962",
      "zh": "0.9510119877557466",
      "fr": "0.9844299603218182",
      "de": "0.9746827702636742",
      "ha": "0.9875119093139555",
      "hi": "0.9762096420026893",
      "hu": "0.9443179452844898"
    },
    "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}",
    "instruction": {
      "en": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nՏվեք կարճ բնութագրություն (docstring) այս CPP կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nসিপিপি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\n将以下CPP代码的自然语言描述（文档字符串）简洁地翻译成中文，字数不超过500个字符。",
      "fr": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570503513392071",
      "hy": "0.8947288775072247",
      "bn": "0.8867794910278275",
      "bg": "0.9881575205401952",
      "zh": "0.8479353337126448",
      "fr": "0.9172954737269795",
      "de": "0.9389289044166322",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}",
    "entry_point": "minOperations",
    "signature": "int minOperations(int n, int* pixels)",
    "docstring": {
      "en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2\n",
      "sq": "Ju jeni dhënë një imazh 1 me n piksel, ku secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të kryeni një operacion ku zgjidhni një ngjyrë dhe ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në ngjyrën e zgjedhur. Dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Gjeni numrin minimal të operacioneve të kërkuara për të bërë që të gjithë piksela të kenë të njëjtën ngjyrë.\n\nShënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n\nShembuj:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hy": "Դուք ունեք 1 x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք կատարել գործողություն, որտեղ ընտրում եք գույն և փոխում նույն գույնի բոլոր միացված պիքսելները ընտրված գույնով: Երկու պիքսել միացված են, եթե նրանք հարակից են և ունեն նույն գույնը: Գտեք նվազագույն գործողությունների քանակը, որը պահանջվում է, որպեսզի բոլոր պիքսելները ունենան նույն գույնը:\n\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n\nՕրինակներ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "bn": "আপনাকে একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা উপস্থাপিত হয়। আপনি একটি অপারেশন সম্পাদন করতে পারেন যেখানে আপনি একটি রঙ বেছে নেন এবং একই রঙের সমস্ত সংযুক্ত পিক্সেলকে নির্বাচিত রঙে পরিবর্তন করেন। দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। সমস্ত পিক্সেলকে একই রঙে করার জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করুন।\n\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সর্বাধিক ২০টি পিক্সেল সেই রঙের হতে পারে।\n\nউদাহরণ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "bg": "Дадено е изображение с размер 1 на n пиксела, където всеки пиксел има цвят, представен с цяло число. Можете да извършите операция, при която избирате цвят и променяте всички свързани пиксели със същия цвят на избрания цвят. Два пиксела са свързани, ако са съседни и имат същия цвят. Намерете минималния брой операции, необходими, за да направите всички пиксели с един и същ цвят.\n\nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "zh": "你有一个1 x n像素的图像，其中每个像素的颜色由一个整数表示。你可以执行一个操作，选择一种颜色并将所有连接的同色像素更改为所选颜色。如果两个像素是相邻的并且具有相同的颜色，则它们是连接的。找出将所有像素变为相同颜色所需的最小操作次数。\n\n注意：对于每种颜色，最多有20个该颜色的像素。\n\n示例：\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "fr": "Vous avez une image de 1 par n pixels, où chaque pixel a une couleur représentée par un entier. Vous pouvez effectuer une opération où vous choisissez une couleur et changez tous les pixels connectés de la même couleur en la couleur choisie. Deux pixels sont connectés s'ils sont adjacents et ont la même couleur. Trouvez le nombre minimum d'opérations nécessaires pour que tous les pixels aient la même couleur.\n\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "de": "Du hast ein 1 mal n Pixel-Bild, wobei jeder Pixel eine durch eine ganze Zahl dargestellte Farbe hat. Du kannst eine Operation durchführen, bei der du eine Farbe auswählst und alle verbundenen Pixel derselben Farbe in die gewählte Farbe änderst. Zwei Pixel sind verbunden, wenn sie benachbart sind und die gleiche Farbe haben. Finde die minimale Anzahl von Operationen, die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\n\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "ha": "An ba ku hoton pixel 1 ta n, inda kowane pixel yana da launi da aka wakilta ta hanyar lamba. Kuna iya aiwatar da aiki inda kuka zaɓi launi kuma ku canza duk pixels masu alaƙa na launi ɗaya zuwa launin da aka zaɓa. Ana haɗa pixels biyu idan suna kusa kuma suna da launi ɗaya. Nemo mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\n\nLura: Don kowane launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hi": "आपको 1 बाई n पिक्सेल छवि दी गई है, जहाँ प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक ऑपरेशन कर सकते हैं जहाँ आप एक रंग चुनते हैं और उसी रंग के सभी जुड़े पिक्सेल को चुने गए रंग में बदल देते हैं। दो पिक्सेल जुड़े होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। सभी पिक्सेल को एक ही रंग का बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या ज्ञात करें।\n\nध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "hu": "Meg van adva egy 1 x n képpontból álló kép, ahol minden képpont színét egy egész szám képviseli. Végrehajthatsz egy olyan műveletet, ahol kiválasztasz egy színt, és az összes összekapcsolt, azonos színű képpontot megváltoztatod a választott színre. Két képpont akkor van összekapcsolva, ha szomszédosak és azonos színűek. Találd meg a minimális műveletek számát, amelyek szükségesek ahhoz, hogy az összes képpont azonos színű legyen.\n\nMegjegyzés: Minden szín esetében legfeljebb 20 képpont van abból a színből.\n\nPéldák:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2"
    },
    "docstring_bertscore": {
      "sq": "0.9799133040874659",
      "hy": "0.9645260043598363",
      "bn": "0.9716093623779214",
      "bg": "0.9772754926273226",
      "zh": "0.9605724652557178",
      "fr": "0.9767562728112974",
      "de": "0.9924881962500226",
      "ha": "0.986096469218701",
      "hi": "0.970684936584585",
      "hu": "0.96756504918967"
    }
  },
  {
    "task_id": "CPP/46",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * @brief Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n *\n * Counts each number only once even if it is a multiple of both 3 and 5.\n * For example:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n The upper bound of the range to check for multiples.\n * @return The sum of the multiples of either 3 or 5 within the range.\n */\nint sumOfMultiples(int n)",
      "sq": "#include <cassert>\n#include <iostream>\n/**\n * @brief Llogarit shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n *\n * Numëron çdo numër vetëm një herë edhe nëse është shumëfish i të dyjave 3 dhe 5.\n * Për shembull:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfishat.\n * @return Shuma e shumëfishave të 3 ose 5 brenda intervalit.\n */\nint sumOfMultiples(int n)",
      "hy": "#include <cassert>\n#include <iostream>\n/**\n * @brief Հաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։\n *\n * Յուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի։\n * Օրինակ՝\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Շրջանակի վերին սահմանը բազմապատիկների ստուգման համար։\n * @return 3-ի կամ 5-ի բազմապատիկների գումարը տրված շրջակայքում։\n */\nint sumOfMultiples(int n)",
      "bn": "#include <cassert>\n#include <iostream>\n/**\n * @brief ১ থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক।\n *\n * প্রতিটি সংখ্যাকে শুধুমাত্র একবার গণনা করে, এমনকি যদি এটি 3 এবং 5 উভয়েরই গুণিতক হয়।\n * উদাহরণস্বরূপ:\n *     @code\n *     std::cout << sumOfMultiples(10); // আউটপুট: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n গুণিতকগুলির জন্য পরীক্ষা করার পরিসরের উপরের সীমা।\n * @return পরিসরের মধ্যে 3 বা 5 এর গুণিতকের যোগফল।\n */\nint sumOfMultiples(int n)",
      "bg": "#include <cassert>\n#include <iostream>\n/**\n * @brief Изчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n *\n * Брои всяко число само веднъж, дори ако е кратно и на 3, и на 5.\n * Например:\n *     @code\n *     std::cout << sumOfMultiples(10); // Извежда: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Горната граница на диапазона за проверка на кратни.\n * @return Сумата на кратните на 3 или 5 в рамките на диапазона.\n */\nint sumOfMultiples(int n)",
      "zh": "#include <cassert>\n#include <iostream>\n/**\n * @brief 计算从 1 到 n 的所有 3 或 5 的倍数的和。\n *\n * 每个数字只计算一次，即使它同时是 3 和 5 的倍数。\n * 例如：\n *     @code\n *     std::cout << sumOfMultiples(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n 要检查倍数的范围上限。\n * @return 范围内 3 或 5 的倍数的和。\n */\nint sumOfMultiples(int n)",
      "fr": "#include <cassert>\n#include <iostream>\n/**\n * @brief Calcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5.\n *\n * Compte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\n * Par exemple :\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n La limite supérieure de la plage à vérifier pour les multiples.\n * @return La somme des multiples de 3 ou 5 dans la plage.\n */\nint sumOfMultiples(int n)",
      "de": "#include <cassert>\n#include <iostream>\n/**\n * @brief Berechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n *\n * Zählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\n * Zum Beispiel:\n *     @code\n *     std::cout << sumOfMultiples(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n * @return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.\n */\nint sumOfMultiples(int n)",
      "ha": "#include <cassert>\n#include <iostream>\n/**\n * @brief Lissafin jimillar dukkan lambobi daga 1 zuwa n waɗanda suke masu yawa na 3 ko 5.\n *\n * Yana ƙidaya kowace lamba sau ɗaya kawai ko da kuwa tana da yawa na 3 da 5.\n * Alal misali:\n *     @code\n *     std::cout << sumOfMultiples(10); // Fitarwa: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Iyakar sama na kewayon da za a duba masu yawa.\n * @return Jimillar masu yawa na 3 ko 5 a cikin kewayon.\n */\nint sumOfMultiples(int n)",
      "hi": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1 से n तक के सभी संख्याओं का योग गणना करता है जो या तो 3 या 5 के गुणज हैं।\n *\n * प्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\n * उदाहरण के लिए:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n गुणजों की जाँच के लिए सीमा का ऊपरी बिंदु।\n * @return सीमा के भीतर या तो 3 या 5 के गुणजों का योग।\n */\nint sumOfMultiples(int n)",
      "hu": "#include <cassert>\n#include <iostream>\n/**\n * @brief Kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei.\n *\n * Minden számot csak egyszer számol, még akkor is, ha az 3-nak és 5-nek is többszöröse.\n * Például:\n *     @code\n *     std::cout << sumOfMultiples(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Az intervallum felső határa, amelyben a többszörösöket keressük.\n * @return Az intervallumban lévő 3 vagy 5 többszöröseinek összege.\n */\nint sumOfMultiples(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9832592328559986",
      "hy": "0.9681821937835454",
      "bn": "0.9769751634911978",
      "bg": "0.98326717807124",
      "zh": "0.956725193405453",
      "fr": "0.9823475194070485",
      "de": "0.9785753298408149",
      "ha": "0.9576013520161979",
      "hi": "0.9597733752328145",
      "hu": "0.9575572560716082"
    },
    "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nДайте кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\n将以下 CPP 代码的自然语言描述（文档字符串）翻译成中文，字数不超过 500 个字符。",
      "fr": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9267393551932832",
      "bn": "0.8634835240489127",
      "bg": "0.8365011292951701",
      "zh": "0.8402199338221066",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9068417554034943",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n\n    return 0;\n}",
    "entry_point": "sumOfMultiples",
    "signature": "int sumOfMultiples(int n)",
    "docstring": {
      "en": "Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\nCounts each number only once even if it is a multiple of both 3 and 5.\nFor example:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n The upper bound of the range to check for multiples.\n@return The sum of the multiples of either 3 or 5 within the range.",
      "sq": "Llogarit shumën e të gjitha numrave nga 1 deri në n që janë shumëfish i 3 ose 5.\n\nNumëron secilin numër vetëm një herë edhe nëse është shumëfish i të dyjave, 3 dhe 5.\nPër shembull:\n    std::cout << sumOfMultiples(10); // Shfaq: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kufiri i sipërm i intervalit për të kontrolluar për shumëfish.\n@return Shuma e shumëfishëve të 3 ose 5 brenda intervalit.",
      "hy": "Հաշվում է 1-ից n բոլոր թվերի գումարը, որոնք բազմապատիկ են կամ 3-ի, կամ 5-ի։\n\nՅուրաքանչյուր թիվ հաշվում է միայն մեկ անգամ, նույնիսկ եթե այն բազմապատիկ է և՛ 3-ի, և՛ 5-ի։\nՕրինակ՝\n    std::cout << sumOfMultiples(10); // Արդյունք՝ 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Շրջանակի վերին սահմանը բազմապատիկների ստուգման համար։\n@return 3-ի կամ 5-ի բազմապատիկների գումարը տրված շրջանակում։",
      "bn": "1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা 3 বা 5 এর গুণিতক।\n\nপ্রতিটি সংখ্যাকে কেবল একবার গণনা করা হয়, এমনকি যদি এটি 3 এবং 5 উভয়ের গুণিতক হয়।\nউদাহরণস্বরূপ:\n    std::cout << sumOfMultiples(10); // আউটপুট: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n গুণিতক চেক করার জন্য পরিসরের উপরের সীমা।\n@return পরিসরের মধ্যে 3 বা 5 এর গুণিতকের যোগফল।",
      "bg": "Изчислява сумата на всички числа от 1 до n, които са кратни на 3 или 5.\n\nБрои всяко число само веднъж, дори ако е кратно и на 3, и на 5.\nНапример:\n    std::cout << sumOfMultiples(10); // Извежда: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Горната граница на диапазона за проверка на кратни.\n@return Сумата на кратните на 3 или 5 в рамките на диапазона.",
      "zh": "计算从 1 到 n 的所有 3 或 5 的倍数的和。\n\n即使一个数字同时是 3 和 5 的倍数，也只计算一次。\n例如：\n    std::cout << sumOfMultiples(10); // 输出: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n 要检查倍数的范围上限。\n@return 范围内 3 或 5 的倍数之和。",
      "fr": "Calcule la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5.\n\nCompte chaque nombre une seule fois même s'il est un multiple à la fois de 3 et de 5.\nPar exemple :\n    std::cout << sumOfMultiples(10); // Affiche : 33 (3 + 5 + 6 + 9 + 10)\n\n@param n La limite supérieure de la plage à vérifier pour les multiples.\n@return La somme des multiples de 3 ou 5 dans la plage.",
      "de": "Berechnet die Summe aller Zahlen von 1 bis n, die Vielfache von entweder 3 oder 5 sind.\n\nZählt jede Zahl nur einmal, auch wenn sie ein Vielfaches von sowohl 3 als auch 5 ist.\nZum Beispiel:\n    std::cout << sumOfMultiples(10); // Gibt aus: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Die obere Grenze des Bereichs, in dem nach Vielfachen gesucht wird.\n@return Die Summe der Vielfachen von entweder 3 oder 5 innerhalb des Bereichs.",
      "ha": "Lissafi jimillar dukkan lambobi daga 1 zuwa n waɗanda suke lambobi masu yawa na 3 ko 5.\n\nYana ƙididdige kowanne lamba sau ɗaya kawai ko da kuwa yana ninkawa ne na 3 da 5.\nMisali:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Babban iyaka na zangon da za a duba don ninkawa.\n@return Jimillar lambobin da suke ninkawa na ko dai 3 ko 5 a cikin zangon.",
      "hi": "1 से n तक के सभी संख्याओं का योग गणना करता है जो या तो 3 या 5 के गुणज हैं।\n\nप्रत्येक संख्या को केवल एक बार गिना जाता है, भले ही वह 3 और 5 दोनों का गुणज हो।\nउदाहरण के लिए:\n    std::cout << sumOfMultiples(10); // आउटपुट: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n वह ऊपरी सीमा है जिस रेंज में गुणजों की जांच की जानी है।\n@return उस रेंज के भीतर 3 या 5 के गुणजों का योग।",
      "hu": "Számítja az 1-től n-ig terjedő összes szám összegét, amelyek 3 vagy 5 többszörösei.\n\nMinden számot csak egyszer számol, még akkor is, ha az 3-nak és 5-nek is többszöröse.\nPéldául:\n    std::cout << sumOfMultiples(10); // Kimenet: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n A tartomány felső határa, amelyet a többszörösök ellenőrzésére használunk.\n@return A 3 vagy 5 többszöröseinek összege a tartományon belül."
    },
    "docstring_bertscore": {
      "sq": "0.9538182377790074",
      "hy": "0.9549436775179512",
      "bn": "0.9557209181989407",
      "bg": "0.9723083426887831",
      "zh": "0.9278127537723958",
      "fr": "0.9562345763642969",
      "de": "0.9651296420878013",
      "ha": "0.9760243198571839",
      "hi": "0.9403779130462817",
      "hu": "0.9591453059679821"
    }
  },
  {
    "task_id": "CPP/47",
    "prompt": {
      "en": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).\n * Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "sq": "#include <cassert>\n#include <cctype> // Për isalnum dhe tolower\n#include <cstring> // Për strlen\n/**\n * Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë,\n * numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe\n * prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).\n * Shembuj:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "hy": "#include <cassert>\n#include <cctype> // isalnum և tolower-ի համար\n#include <cstring> // strlen-ի համար\n/**\n * Սահմանել, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն,\n * թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույն ձևով առաջ և\n * հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\n * Օրինակներ:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "bn": "#include <cassert>\n#include <cctype> // isalnum এবং tolower এর জন্য\n#include <cstring> // strlen এর জন্য\n/**\n * নির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ,\n * সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং\n * পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন, এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n * উদাহরণ:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "bg": "#include <cassert>\n#include <cctype> // За isalnum и tolower\n#include <cstring> // За strlen\n/**\n * Определете дали даден низ е палиндром. Палиндром е дума, фраза,\n * число или друга последователност от символи, която се чете еднакво напред и\n * назад (като се игнорират интервали, пунктуация и главни букви).\n * Примери:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "zh": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * 确定给定的字符串是否是回文。回文是指正读和反读都相同的单词、短语、\n * 数字或其他字符序列（忽略空格、标点和大小写）。\n * 例子:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "fr": "#include <cassert>\n#include <cctype> // Pour isalnum et tolower\n#include <cstring> // Pour strlen\n/**\n * Déterminer si une chaîne de caractères donnée est un palindrome. Un palindrome est un mot, une phrase,\n * un nombre ou une autre séquence de caractères qui se lit de la même manière à l'endroit et à l'envers\n * (en ignorant les espaces, la ponctuation et la capitalisation).\n * Exemples :\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "de": "#include <cassert>\n#include <cctype> // Für isalnum und tolower\n#include <cstring> // Für strlen\n/**\n * Bestimmen, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz,\n * eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird\n * (unter Ignorierung von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\n * Beispiele:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "ha": "#include <cassert>\n#include <cctype> // Don amfani da isalnum da tolower\n#include <cstring> // Don amfani da strlen\n/**\n * Tantance idan wani kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla,\n * lamba, ko wata jerin haruffa da ake karantawa iri daya gaba da baya\n * (ba tare da la'akari da sarari, rubutu, da manyan baki ba).\n * Misalai:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "hi": "#include <cassert>\n#include <cctype> // isalnum और tolower के लिए\n#include <cstring> // strlen के लिए\n/**\n * यह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं। एक पालिंड्रोम एक शब्द, वाक्यांश,\n * संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से पढ़ने पर समान होता है\n * (स्पेस, विराम चिह्न, और कैपिटलाइज़ेशन को नजरअंदाज करते हुए)।\n * उदाहरण:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "hu": "#include <cassert>\n#include <cctype> // isalnum és tolower használatához\n#include <cstring> // strlen használatához\n/**\n * Meghatározza, hogy egy adott string palindróm-e. Egy palindróm egy szó, kifejezés,\n * szám vagy más karakterlánc, amely előre és hátrafelé olvasva is ugyanaz\n * (figyelmen kívül hagyva a szóközöket, írásjeleket és nagybetűket).\n * Példák:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9933113205490312",
      "bn": "0.9944304041157818",
      "bg": "0.9993349854842952",
      "zh": "0.9867106343568608",
      "fr": "0.9977093944459057",
      "de": "0.9757345181312539",
      "ha": "0.9870389703767115",
      "hi": "0.958000201821316",
      "hu": "0.9768863757108752"
    },
    "canonical_solution": "{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}",
    "instruction": {
      "en": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nПредоставете кратко описание на CPP кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\n将以下CPP代码的自然语言描述（文档字符串）用中文简明扼要地提供，字数不超过500个字符。",
      "fr": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9066764949264733",
      "hy": "0.9483094227913859",
      "bn": "0.9129117012175395",
      "bg": "0.9788407625177538",
      "zh": "0.8433139992674871",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9663945203542315",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}",
    "entry_point": "isPalindrome",
    "signature": "bool isPalindrome(const char* str)",
    "docstring": {
      "en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\nExamples:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "sq": "Përcaktoni nëse një varg i dhënë është një palindrom. Një palindrom është një fjalë, frazë, numër, ose sekuencë tjetër karakteresh që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit dhe kapitalizimin).\nShembuj:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "hy": "Սահմանել, արդյոք տրված տողը պալինդրոմ է: Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն, որը կարդացվում է նույնը առաջ և հետ (անտեսելով բացատները, կետադրությունը և մեծատառերը):\nՕրինակներ:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "bn": "একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন। একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "bg": "Определете дали даден низ е палиндром. Палиндром е дума, фраза, число или друга последователност от символи, която се чете еднакво напред и назад (като се игнорират интервали, пунктуация и главни букви).\nПримери:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "zh": "确定给定的字符串是否是回文。回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点和大小写）。\n\n示例：\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "fr": "Déterminer si une chaîne donnée est un palindrome. Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères qui se lit de la même façon à l'endroit et à l'envers (en ignorant les espaces, la ponctuation et la capitalisation).\nExemples :\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "de": "Bestimmen Sie, ob ein gegebener String ein Palindrom ist. Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge, die vorwärts und rückwärts gleich gelesen wird (unter Ignorieren von Leerzeichen, Satzzeichen und Groß-/Kleinschreibung).\nBeispiele:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "ha": "Gano idan wata kirtani da aka bayar palindrome ne. Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa da ke karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutu, da manyan ba).\n\nMisalai:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "hi": "दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं, यह निर्धारित करें। एक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्थान, विराम चिह्न, और बड़े अक्षरों की अनदेखी करते हुए)।\n\nउदाहरण:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e. A palindróm egy olyan szó, kifejezés, szám vagy más karakterlánc, amely előre és visszafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és nagybetűket).\n\nPéldák:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9955097616063253",
      "bn": "0.9990139987885428",
      "bg": "1",
      "zh": "0.998143600458848",
      "fr": "1",
      "de": "0.9926339909497022",
      "ha": "1",
      "hi": "0.9734600016380234",
      "hu": "0.9990139987885428"
    }
  },
  {
    "task_id": "CPP/48",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/*\nGiven a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> addDigits(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n*/\nint addDigits(int num)",
      "sq": "#include <cassert>\n#include <cstdio>\n/*\nDuke pasur një numër të plotë jo-negativ num, kjo funksion e redukton atë në një shifër të vetme duke shtuar vazhdimisht të gjitha shifrat e tij.\nPër shembull:\n    >>> addDigits(38)\n    2\nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.\n*/\nint addDigits(int num)",
      "hy": "#include <cassert>\n#include <cstdio>\n/*\nՏրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն նվազեցնում է մինչև միանիշ՝ կրկնակիորեն գումարելով նրա բոլոր թվանշանները:\nՕրինակ:\n    >>> addDigits(38)\n    2\nՀաշվարկը կատարվում է, քանի որ 3 + 8 = 11, և հետագայում 1 + 1 = 2: Վերադարձվում է 2, քանի որ դա միանիշ թիվ է:\n*/\nint addDigits(int num)",
      "bn": "#include <cassert>\n#include <cstdio>\n/*\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হয়েছে, এই ফাংশনটি বারবার এর সমস্ত অঙ্ক যোগ করে এটিকে একটি একক অঙ্কে হ্রাস করে।\nউদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\nগণনা হল কারণ 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় যেহেতু এটি একটি একক অঙ্কের সংখ্যা।\n*/\nint addDigits(int num)",
      "bg": "#include <cassert>\n#include <cstdio>\n/*\nДадено е неотрицателно цяло число num, тази функция го свежда до едноцифрено число, като многократно събира всички негови цифри.\nНапример:\n    >>> addDigits(38)\n    2\nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. 2 се връща, тъй като е едноцифрено число.\n*/\nint addDigits(int num)",
      "zh": "#include <cassert>\n#include <cstdio>\n/*\n给定一个非负整数 num，此函数通过重复相加其所有数字将其减少到一位数字。\n例如：\n    >>> addDigits(38)\n    2\n计算过程是因为 3 + 8 = 11，进一步 1 + 1 = 2。返回 2 因为它是一个一位数。\n*/\nint addDigits(int num)",
      "fr": "#include <cassert>\n#include <cstdio>\n/*\nÉtant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en ajoutant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> addDigits(38)\n    2\nLe calcul est le suivant : 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.\n*/\nint addDigits(int num)",
      "de": "#include <cassert>\n#include <cstdio>\n/*\nGegeben eine nicht-negative ganze Zahl num, reduziert diese Funktion sie auf eine einstellige Zahl, indem sie wiederholt alle ihre Ziffern addiert.\nZum Beispiel:\n    >>> addDigits(38)\n    2\nDie Berechnung erfolgt, weil 3 + 8 = 11 und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es eine einstellige Zahl ist.\n*/\nint addDigits(int num)",
      "ha": "#include <cassert>\n#include <cstdio>\n/*\nAn ba da wani lamba mara kyau num, wannan aikin yana rage shi zuwa lamba guda ta hanyar ƙara duk lambobinsa akai-akai.\nMisali:\n    >>> addDigits(38)\n    2\nLissafin yana nufin 3 + 8 = 11, kuma gaba 1 + 1 = 2. 2 ana dawowa da shi tunda lamba guda ce.\n*/\nint addDigits(int num)",
      "hi": "#include <cassert>\n#include <cstdio>\n/*\nदिया गया एक गैर-ऋणात्मक पूर्णांक num, यह फ़ंक्शन इसे एकल अंक में घटाता है सभी अंकों को बार-बार जोड़कर।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\nगणना इसलिए है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2. 2 लौटाया जाता है क्योंकि यह एकल अंक संख्या है।\n*/\nint addDigits(int num)",
      "hu": "#include <cassert>\n#include <cstdio>\n/*\nEgy nem negatív egész számot megadva, ez a függvény egyetlen számjegyre csökkenti azt az összes számjegyének ismételt összeadásával.\nPéldául:\n    >>> addDigits(38)\n    2\nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2 kerül visszaadásra, mivel ez egy egyjegyű szám.\n*/\nint addDigits(int num)"
    },
    "prompt_bertscore": {
      "sq": "0.9945317056101095",
      "hy": "0.9698208944270832",
      "bn": "0.9808333600124195",
      "bg": "0.9773638831468832",
      "zh": "0.9736939882268825",
      "fr": "0.9734246454301992",
      "de": "0.9847582963416689",
      "ha": "0.966426102584816",
      "hi": "0.9970968183507941",
      "hu": "0.9889567467056033"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9570398239290123",
      "hy": "0.9483094227913859",
      "bn": "0.8696780111118667",
      "bg": "0.8329214591013607",
      "zh": "0.9981961013673174",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9235080361546076",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}",
    "entry_point": "addDigits",
    "signature": "int addDigits(int num)",
    "docstring": {
      "en": "Given a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> addDigits(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n",
      "sq": "Duke pasur një numër të plotë jo-negativ num, kjo funksion e redukton atë në një shifër të vetme duke mbledhur vazhdimisht të gjitha shifrat e tij.\nPër shembull:\n    >>> addDigits(38)\n    2\nLlogaritja është sepse 3 + 8 = 11, dhe më tej 1 + 1 = 2. 2 kthehet pasi është një numër me një shifër.",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, այս ֆունկցիան այն նվազեցնում է մինչև մեկանիշ թիվ՝ բազմիցս գումարելով դրա բոլոր թվանշանները:\nՕրինակ:\n    >>> addDigits(38)\n    2\nՀաշվարկը հետևյալն է՝ 3 + 8 = 11, և հետագայում 1 + 1 = 2: 2-ը վերադարձվում է, քանի որ այն մեկանիշ թիվ է:",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এই ফাংশনটি বারবার এর সমস্ত অঙ্ক যোগ করে এটিকে একটি একক অঙ্কে কমিয়ে দেয়। উদাহরণস্বরূপ:\n    >>> addDigits(38)\n    2\nগণনা এই কারণে যে 3 + 8 = 11, এবং আরও 1 + 1 = 2। 2 ফেরত দেওয়া হয় কারণ এটি একটি একক অঙ্কের সংখ্যা।",
      "bg": "Дадено е неотрицателно цяло число num, тази функция го намалява до едноцифрено число, като многократно събира всички негови цифри.\nНапример:\n    >>> addDigits(38)\n    2\nИзчислението е, защото 3 + 8 = 11, и по-нататък 1 + 1 = 2. Връща се 2, тъй като е едноцифрено число.",
      "zh": "给定一个非负整数 num，此函数通过重复相加其所有数字将其减少到一位数字。  \n例如：  \n    >>> addDigits(38)  \n    2  \n计算过程是因为 3 + 8 = 11，然后 1 + 1 = 2。返回 2，因为它是一个一位数。",
      "fr": "Étant donné un entier non négatif num, cette fonction le réduit à un seul chiffre en ajoutant de manière répétée tous ses chiffres.\nPar exemple :\n    >>> addDigits(38)\n    2\nLe calcul est parce que 3 + 8 = 11, et ensuite 1 + 1 = 2. 2 est retourné car c'est un nombre à un seul chiffre.",
      "de": "Angenommen, eine nicht-negative ganze Zahl num, reduziert diese Funktion sie auf eine einstellige Zahl, indem sie wiederholt alle ihre Ziffern addiert.\n\nBeispiel:\n    >>> addDigits(38)\n    2\n\nDie Berechnung erfolgt, weil 3 + 8 = 11 und weiter 1 + 1 = 2. 2 wird zurückgegeben, da es sich um eine einstellige Zahl handelt.",
      "ha": "An ba da wani lamba mai kyau wanda ba shi da alamar rashin kyau num, wannan aikin yana rage shi zuwa lamba guda ta hanyar kara dukkan lambobinsa akai-akai.\nMisali:\n    >>> addDigits(38)\n    2\nLissafin yana nufin 3 + 8 = 11, kuma daga baya 1 + 1 = 2. 2 ana dawowa da shi saboda yana lamba guda ce.",
      "hi": "गैर-ऋणात्मक पूर्णांक num को दिया गया है, यह फ़ंक्शन इसे एकल अंक तक घटाता है सभी अंकों को बार-बार जोड़कर।\nउदाहरण के लिए:\n    >>> addDigits(38)\n    2\nगणना इसलिए है क्योंकि 3 + 8 = 11, और आगे 1 + 1 = 2। 2 लौटाया जाता है क्योंकि यह एकल-अंक संख्या है।",
      "hu": "Adott egy nem negatív egész szám, ez a függvény egyetlen számjegyre csökkenti azáltal, hogy ismételten összeadja az összes számjegyét.\nPéldául:\n    >>> addDigits(38)\n    2\nA számítás azért van, mert 3 + 8 = 11, és tovább 1 + 1 = 2. 2 kerül visszaadásra, mivel ez egy egyjegyű szám."
    },
    "docstring_bertscore": {
      "sq": "0.9814219018314259",
      "hy": "0.9542627725717635",
      "bn": "0.9648757924608387",
      "bg": "0.9767842796950233",
      "zh": "0.9564888232520216",
      "fr": "0.9876380396059127",
      "de": "0.9689695646139677",
      "ha": "0.9224038498664348",
      "hi": "0.9963799613056392",
      "hu": "0.9904198580923063"
    }
  },
  {
    "task_id": "CPP/49",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\n * your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\n * stone wins the game. Given the number of stones n, determine if you can win the game if both you\n * and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe\n * kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit\n * fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju\n * ashtu edhe kundërshtari juaj luani në mënyrë optimale.\n * Shënim: Ju gjithmonë bëni lëvizjen e parë.\n *\n * Ja disa raste:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք և\n * ձեր հակառակորդը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին\n * քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և\n * ձեր հակառակորդը խաղում եք օպտիմալ կերպով։\n * Նշում. Դուք միշտ առաջինն եք խաղում։\n *\n * Ահա որոշ դեպքեր.\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * আপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি n পাথর দিয়ে শুরু করেন, এবং আপনি এবং\n * আপনার প্রতিদ্বন্দ্বী পালা করে 1 থেকে 3 পাথর পাইল থেকে সরান। যে শেষ পাথরটি সরায় সে গেমটি জেতে। পাথরের সংখ্যা n দেওয়া হলে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিদ্বন্দ্বী উভয়ই সর্বোত্তমভাবে খেলেন।\n * লক্ষ্য করুন: আপনি সবসময় প্রথম পালা নেন।\n *\n * এখানে কিছু উদাহরণ:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Играете игра, наречена Ним. В тази игра започвате с купчина от n камъка и вие и вашият\n * противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне\n * последния камък, печели играта. Като се има предвид броят на камъните n, определете дали\n * можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\n * Забележка: Винаги вие правите първия ход.\n *\n * Ето някои случаи:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最优策略，你是否能赢得游戏。\n * 注意：你总是先走。\n *\n * 这里有一些情况：\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et\n * votre adversaire prenez à tour de rôle 1 à 3 pierres du tas. Celui qui enlève la dernière\n * pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\n * Remarque : Vous prenez toujours le premier tour.\n *\n * Voici quelques cas :\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und\n * dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten\n * Stein entfernt, gewinnt das Spiel. Gegeben die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du\n * als auch dein Gegner optimal spielen.\n * Hinweis: Du bist immer der Erste, der an der Reihe ist.\n *\n * Hier sind einige Fälle:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Kuna wasa da wani wasa mai suna Nim. A cikin wannan wasa, kuna farawa da tarin duwatsu n, ku da\n * abokin hamayyarku kuna juyawa don cire duwatsu 1 zuwa 3 daga tarin. Wanda ya cire dutse na ƙarshe\n * shi ne ya lashe wasan. An ba da adadin duwatsu n, tantance idan za ku iya cin nasara a wasan idan\n * ku da abokin hamayyarku kuna wasa da kyau.\n * Lura: Kullum kuna fara juyawa.\n *\n * Ga wasu lokuta:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और\n * आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो आखिरी पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम तरीके से खेलते हैं।\n * नोट: आप हमेशा पहली बारी लेते हैं।\n *\n * यहाँ कुछ मामले हैं:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az\n * ellenfeled felváltva távolítotok el 1-től 3-ig terjedő köveket a halomból. Az nyer, aki az utolsó\n * követ eltávolítja. Adott a kövek száma n, határozd meg, hogy megnyerheted-e a játékot, ha te és\n * az ellenfeled is optimálisan játszotok.\n * Megjegyzés: Mindig te kezded az első lépést.\n *\n * Íme néhány eset:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.9908065914441813",
      "hy": "0.975968504720113",
      "bn": "0.9732989123990041",
      "bg": "0.9823695673793433",
      "zh": "0.9722614659188589",
      "fr": "0.9900948987889332",
      "de": "0.9873587652901776",
      "ha": "0.984189617560766",
      "hi": "0.9872812994415741",
      "hu": "0.9784235762297042"
    },
    "canonical_solution": "{\n    return n % 4 != 0;\n}",
    "instruction": {
      "en": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nՏվեք CPP կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nনিচের CPP কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nПредоставете кратко описание на CPP кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\n请用最多500个字符的中文对该CPP代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar CPP a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9421149357284319",
      "hy": "0.9166451578594712",
      "bn": "0.8736615434035214",
      "bg": "0.8329214591013607",
      "zh": "0.900264088797473",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.937009340414311",
      "hi": "0.9117634189847768",
      "hu": "0.9545905127004711"
    },
    "level": "",
    "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}",
    "entry_point": "canWinNim",
    "signature": "bool canWinNim(int n)",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\nyour opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\nstone wins the game. Given the number of stones n, determine if you can win the game if both you\nand your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. \nShënim: Ju gjithmonë merrni radhën e parë.\n\nJa disa raste:\n    >>> canWinNim(1)\n    true",
      "hy": "Դուք խաղում եք Նիմ կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերի կույտով, և դուք ու ձեր հակառակորդը հերթով հեռացնում եք 1-ից 3 քարեր կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը՝ n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե և դուք, և ձեր հակառակորդը խաղում եք օպտիմալ կերպով։\nՆշում: Դուք միշտ առաջին հերթն եք կատարում։\n\nԱհա որոշ դեպքեր.\n    >>> canWinNim(1)\n    true",
      "bn": "তুমি একটি খেলা খেলছো যার নাম নিম। এই খেলায়, তুমি একটি স্তূপ থেকে n টি পাথর দিয়ে শুরু করো, এবং তুমি ও তোমার প্রতিদ্বন্দ্বী পালাক্রমে ১ থেকে ৩ টি পাথর স্তূপ থেকে সরিয়ে নাও। যে ব্যক্তি শেষ পাথরটি সরায়, সে খেলায় জিতে যায়। প্রদত্ত পাথরের সংখ্যা n, নির্ধারণ করো তুমি খেলাটি জিততে পারবে কিনা যদি তুমি এবং তোমার প্রতিদ্বন্দ্বী উভয়েই সর্বোত্তমভাবে খেলে।\nনোট: তুমি সবসময় প্রথম পালা নাও।\n\nকিছু উদাহরণ এখানে:\n    >>> canWinNim(1)\n    true",
      "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.  \nЗабележка: Винаги вие започвате първи.\n\nЕто някои случаи:\n    >>> canWinNim(1)\n    true",
      "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都采取最佳策略，你是否能赢得游戏。\n注意：你总是先手。\n\n以下是一些情况：\n    >>> canWinNim(1)\n    true",
      "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle 1 à 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :\n    >>> canWinNim(1)\n    true",
      "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine vom Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer als Erster an der Reihe.\n\nHier sind einige Fälle:\n    >>> canWinNim(1)\n    true\n",
      "ha": "Kana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin adawarka kuna juyawa don cire 1 zuwa 3 daga cikin duwatsun. Wanda ya cire dutse na ƙarshe shi ne ya ci wasan. Idan aka ba da adadin duwatsu n, tantance ko zaka iya cin wasa idan kai da abokin adawarka kuna wasa cikin hikima.\nLura: Kai ne kake fara wasa.\n\nGa wasu lokuta:\n    >>> canWinNim(1)\n    true",
      "hi": "आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से ढेर से 1 से 3 पत्थर हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों सर्वोत्तम तरीके से खेलते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ मामले हैं:\n    >>> canWinNim(1)\n    true",
      "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyeri a játékot, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha te és az ellenfeled is optimálisan játszik.\nMegjegyzés: Mindig te kezded az első lépést.\n\nÍme néhány eset:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "sq": "0.9948342196804256",
      "hy": "0.9724148085730179",
      "bn": "0.9801397427218457",
      "bg": "0.9781838293597951",
      "zh": "0.959867724663806",
      "fr": "0.9780644525007932",
      "de": "0.9948342196804256",
      "ha": "0.9428858202372282",
      "hi": "0.9867195727240073",
      "hu": "0.9769400059137546"
    }
  },
  {
    "task_id": "CPP/50",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\n * Examples:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "sq": "#include <cassert>\n#include <cstdio>\n/**\n * Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose prodhimin e a dhe b nëse shuma është tek.\n * Shembuj:\n *    evenSumOrOddProduct(2, 3) kthen 6\n *    evenSumOrOddProduct(5, 5) kthen 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "hy": "#include <cassert>\n#include <cstdio>\n/**\n * Տրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b-ի արտադրյալը, եթե գումարը կենտ է։\n * Օրինակներ:\n *    evenSumOrOddProduct(2, 3) վերադարձնում է 6\n *    evenSumOrOddProduct(5, 5) վերադարձնում է 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "bn": "#include <cassert>\n#include <cstdio>\n/**\n * দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তাহলে যোগফল ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তাহলে a এবং b এর গুণফল ফেরত দিন।\n * উদাহরণস্বরূপ:\n *    evenSumOrOddProduct(2, 3) 6 ফেরত দেয়\n *    evenSumOrOddProduct(5, 5) 10 ফেরত দেয়\n */\nint evenSumOrOddProduct(int a, int b)",
      "bg": "#include <cassert>\n#include <cstdio>\n/**\n * Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.\n * Примери:\n *    evenSumOrOddProduct(2, 3) връща 6\n *    evenSumOrOddProduct(5, 5) връща 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "zh": "#include <cassert>\n#include <cstdio>\n/**\n * 给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n * 例子:\n *    evenSumOrOddProduct(2, 3) 返回 6\n *    evenSumOrOddProduct(5, 5) 返回 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "fr": "#include <cassert>\n#include <cstdio>\n/**\n * Étant donné deux entiers a et b, retourner la somme si la somme est paire, ou le produit de a et b si la somme est impaire.\n * Exemples :\n *    evenSumOrOddProduct(2, 3) retourne 6\n *    evenSumOrOddProduct(5, 5) retourne 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "de": "#include <cassert>\n#include <cstdio>\n/**\n * Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.\n * Beispiele:\n *    evenSumOrOddProduct(2, 3) gibt 6 zurück\n *    evenSumOrOddProduct(5, 5) gibt 10 zurück\n */\nint evenSumOrOddProduct(int a, int b)",
      "ha": "#include <cassert>\n#include <cstdio>\n/**\n * Idan aka ba da lambobi guda biyu a da b, a mayar da jumlar idan jumlar ta zama lamba mai mafarin biyu, ko kuma samfurin a da b idan jumlar ta zama lamba mai mafarin daya.\n * Misalai:\n *    evenSumOrOddProduct(2, 3) yana mayar da 6\n *    evenSumOrOddProduct(5, 5) yana mayar da 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "hi": "#include <cassert>\n#include <cstdio>\n/**\n * दिए गए दो पूर्णांक a और b के लिए, योग को लौटाएं यदि योग सम है, या a और b का गुणनफल यदि योग विषम है।\n * उदाहरण:\n *    evenSumOrOddProduct(2, 3) 6 लौटाता है\n *    evenSumOrOddProduct(5, 5) 10 लौटाता है\n */\nint evenSumOrOddProduct(int a, int b)",
      "hu": "#include <cassert>\n#include <cstdio>\n/**\n * Két egész szám, a és b esetén adja vissza az összeget, ha az összeg páros, vagy a és b szorzatát, ha az összeg páratlan.\n * Példák:\n *    evenSumOrOddProduct(2, 3) visszaadja 6\n *    evenSumOrOddProduct(5, 5) visszaadja 10\n */\nint evenSumOrOddProduct(int a, int b)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.9816143746706487",
      "bg": "0.999999801369619",
      "zh": "0.9662574653913173",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9698439355512832",
      "hi": "0.983437602938168",
      "hu": "0.9882730609340812"
    },
    "canonical_solution": "{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}",
    "instruction": {
      "en": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "sq": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit CPP në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nՏվեք CPP կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nসিপিপি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nПредоставете кратко описание на CPP кода на български език, използвайки не повече от 500 знака.",
      "zh": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\n将以下CPP代码的自然语言描述（文档字符串）翻译成中文，字数不超过500个字符。",
      "fr": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nFournissez une description concise en langage naturel (docstring) du code CPP en français en utilisant au maximum 500 caractères.",
      "de": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des CPP-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar CPP cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nसीपीपी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a CPP kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9239007284179136",
      "hy": "0.9267393551932832",
      "bn": "0.8665912949905846",
      "bg": "0.8365011292951701",
      "zh": "0.8402199338221066",
      "fr": "0.9172954737269795",
      "de": "0.9255146002638222",
      "ha": "0.9134174141676543",
      "hi": "0.9117634189847768",
      "hu": "0.942633559653314"
    },
    "level": "",
    "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}",
    "entry_point": "evenSumOrOddProduct",
    "signature": "int evenSumOrOddProduct(int a, int b)",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "sq": "Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift, ose produktin e a dhe b nëse shuma është tek.\nShembuj:\nevenSumOrOddProduct(2, 3) kthen 6\nevenSumOrOddProduct(5, 5) kthen 10",
      "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ a և b արտադրյալը, եթե գումարը կենտ է:\nՕրինակներ:\nevenSumOrOddProduct(2, 3) վերադարձնում է 6\nevenSumOrOddProduct(5, 5) վերադարձնում է 10",
      "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণ:\nevenSumOrOddProduct(2, 3) 6 ফেরত দেয়\nevenSumOrOddProduct(5, 5) 10 ফেরত দেয়",
      "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или произведението на a и b, ако сумата е нечетна.\nПримери:\nevenSumOrOddProduct(2, 3) връща 6\nevenSumOrOddProduct(5, 5) връща 10",
      "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n示例：\nevenSumOrOddProduct(2, 3) 返回 6\nevenSumOrOddProduct(5, 5) 返回 10",
      "fr": "Étant donné deux entiers a et b, renvoyez la somme si la somme est paire, ou le produit de a et b si la somme est impaire.\nExemples :\nevenSumOrOddProduct(2, 3) renvoie 6\nevenSumOrOddProduct(5, 5) renvoie 10",
      "de": "Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist, oder das Produkt von a und b, wenn die Summe ungerade ist.\nBeispiele:\nevenSumOrOddProduct(2, 3) gibt 6 zurück\nevenSumOrOddProduct(5, 5) gibt 10 zurück",
      "ha": "An ba da lambobi guda biyu a da b, mayar da jumlar idan jumlar tana da lamba mai ma'ana, ko kuma samfurin a da b idan jumlar tana da lamba mai wauta.\nMisalai:\nevenSumOrOddProduct(2, 3) yana mayar da 6\nevenSumOrOddProduct(5, 5) yana mayar da 10",
      "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n\nउदाहरण:\nevenSumOrOddProduct(2, 3) 6 लौटाता है\nevenSumOrOddProduct(5, 5) 10 लौटाता है",
      "hu": "Két egész szám, a és b esetén adja vissza az összeget, ha az összeg páros, vagy a és b szorzatát, ha az összeg páratlan.\nPéldák:\nevenSumOrOddProduct(2, 3) visszaadja 6\nevenSumOrOddProduct(5, 5) visszaadja 10"
    },
    "docstring_bertscore": {
      "sq": "0.9993671636060228",
      "hy": "1",
      "bn": "0.9902456592481387",
      "bg": "1",
      "zh": "0.9439685544442494",
      "fr": "1",
      "de": "1",
      "ha": "0.9533327851277582",
      "hi": "0.9321017795900821",
      "hu": "0.9827924514605666"
    }
  }
]