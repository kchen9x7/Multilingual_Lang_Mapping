[
  {
    "task_id": "Common Lisp/1",
    "prompt": {
      "en": "(defun has-close-elements (numbers threshold)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "sq": "(defun has-close-elements (numbers threshold)\n;;Kontrollo nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se\n;;pragu i dhënë.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "hy": "(defun has-close-elements (numbers threshold)\n;;Ստուգել, արդյոք տրված թվերի ցուցակում կան երկու թվեր, որոնք միմյանցից ավելի մոտ են, քան\n;;տրված շեմը։\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "bn": "(defun has-close-elements (numbers threshold)\n;;প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "bg": "(defun has-close-elements (numbers threshold)\n;;Проверете дали в дадения списък от числа, има две числа, които са по-близо едно до друго от\n;;дадения праг.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "zh": "(defun has-close-elements (numbers threshold)\n;;检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "fr": "(defun has-close-elements (numbers threshold)\n;;Vérifie si, dans la liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que\n;;le seuil donné.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "de": "(defun has-close-elements (numbers threshold)\n;;Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n;;der gegebene Schwellenwert.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "ha": "(defun has-close-elements (numbers threshold)\n;; Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da ke kusa da juna fiye da\n;; ƙayyadadden ƙofa.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "hi": "(defun has-close-elements (numbers threshold)\n;;जाँचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ एक-दूसरे के जितना करीब हैं\n;;दिए गए सीमा से।\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "hu": "(defun has-close-elements (numbers threshold)\n;;Ellenőrzi, hogy a megadott számok listájában van-e bármely két szám, amelyek közelebb vannak egymáshoz, mint a megadott küszöbérték.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t"
    },
    "prompt_bertscore": {
      "sq": "0.9815456485588107",
      "hy": "0.9683099131185509",
      "bn": "0.9696778805527381",
      "bg": "0.9688072835926622",
      "zh": "0.9524580169296806",
      "fr": "0.9645329564231724",
      "de": "0.9745685577945791",
      "ha": "0.965452416456983",
      "hi": "0.9579308798183348",
      "hu": "0.9560951378368104"
    },
    "canonical_solution": "(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)",
    "instruction": {
      "en": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用不超过500个字符的中文。",
      "fr": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.918271940680147",
      "bn": "0.8727891587700162",
      "bg": "0.8335809119663965",
      "zh": "0.9072010777627865",
      "fr": "0.9711523138711601",
      "de": "0.93952539145088",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun check-has-close-elements ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)",
    "entry_point": "has-close-elements",
    "signature": "(defun has-close-elements (numbers threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hy": "Ստուգեք, արդյոք տրված թվերի ցուցակում կան որևէ երկու թիվ, որոնք ավելի մոտ են միմյանց, քան տրված շեմը։\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি নির্দিষ্ট সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "bg": "Проверете дали в даден списък от числа има две числа, които са по-близо едно до друго от даден праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "zh": "检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \n'nil  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nt'",
      "fr": "Vérifiez si, dans la liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "ha": "Duba idan a cikin jerin lambobi da aka bayar, akwai kowanne lambobi biyu da ke kusa da juna fiye da ƙayyadadden tazara.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hi": "दिए गए संख्याओं की सूची में जांचें कि क्या कोई दो संख्याएं दी गई सीमा से अधिक निकट हैं।\n\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hu": "Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám közelebb egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'"
    },
    "docstring_bertscore": {
      "sq": "0.9796161530374377",
      "hy": "0.9547222046430972",
      "bn": "0.9366623331386431",
      "bg": "0.9578418934076312",
      "zh": "0.9426480596711295",
      "fr": "0.9646656415177037",
      "de": "0.9646414086112175",
      "ha": "0.9493693145045881",
      "hi": "0.9501499319020551",
      "hu": "0.9547222046430972"
    }
  },
  {
    "task_id": "Common Lisp/2",
    "prompt": {
      "en": "(defun bin-search (obj vec)\n;; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.\n;; Example:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "sq": "(defun bin-search (obj vec)\n;; Kërkimi binar për 'obj' në vektorin e renditur 'vec'.\n;; Kthen 't' nëse 'obj' gjendet, 'nil' përndryshe.\n;; Shembull:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "hy": "(defun bin-search (obj vec)\n;; Երկբևեռ որոնում 'obj'-ի համար դասավորված վեկտորում 'vec'.\n;; Վերադարձնում է 't', եթե 'obj'-ը գտնվել է, 'nil' հակառակ դեպքում.\n;; Օրինակ:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "bn": "(defun bin-search (obj vec)\n;; সাজানো ভেক্টর 'vec' এ 'obj' এর জন্য বাইনারি অনুসন্ধান।\n;; 'obj' পাওয়া গেলে 't' ফেরত দেয়, অন্যথায় 'nil'।\n;; উদাহরণ:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "bg": "(defun bin-search (obj vec)\n;; Двоично търсене на 'obj' в сортиран вектор 'vec'.\n;; Връща 't', ако 'obj' е намерен, 'nil' в противен случай.\n;; Пример:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "zh": "(defun bin-search (obj vec)\n;; 在排序向量'vec'中二分查找'obj'。\n;; 如果找到'obj'，返回't'，否则返回'nil'。\n;; 示例:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "fr": "(defun bin-search (obj vec)\n;; Recherche binaire pour 'obj' dans le vecteur trié 'vec'.\n;; Renvoie 't' si 'obj' est trouvé, 'nil' sinon.\n;; Exemple:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "de": "(defun bin-search (obj vec)\n;; Binäre Suche nach 'obj' im sortierten Vektor 'vec'.\n;; Gibt 't' zurück, wenn 'obj' gefunden wird, 'nil' andernfalls.\n;; Beispiel:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "ha": "(defun bin-search (obj vec)\n;; Bincike na binary don 'obj' a cikin vector mai tsari 'vec'.\n;; Ya dawo da 't' idan an sami 'obj', 'nil' in ba haka ba.\n;; Misali:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "hi": "(defun bin-search (obj vec)\n;; क्रमबद्ध वेक्टर 'vec' में 'obj' के लिए बाइनरी खोज।\n;; 'obj' मिलने पर 't' लौटाता है, अन्यथा 'nil'।\n;; उदाहरण:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "hu": "(defun bin-search (obj vec)\n;; Bináris keresés az 'obj' elemre a rendezett 'vec' vektorban.\n;; 't'-t ad vissza, ha az 'obj' megtalálható, különben 'nil'-t.\n;; Példa:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t"
    },
    "prompt_bertscore": {
      "sq": "0.9954579190768752",
      "hy": "0.9954579190768752",
      "bn": "0.9575534820943685",
      "bg": "0.9951560008977022",
      "zh": "0.9340318710025981",
      "fr": "0.9954579190768752",
      "de": "0.9954579190768752",
      "ha": "0.9954579190768752",
      "hi": "0.9707796832763387",
      "hu": "0.9526165239737464"
    },
    "canonical_solution": "(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))",
    "instruction": {
      "en": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nՏրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\n提供一段简洁的自然语言描述（文档字符串），用中文描述这段Common Lisp代码，限制在500个字符以内。",
      "fr": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakter felhasználásával."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9452918300427039",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8893148092113569",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8808811618629965",
      "hu": "0.9428284160571092"
    },
    "level": "",
    "test": "(defun check-bin-search ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check-bin-search)",
    "entry_point": "bin-search",
    "signature": "(defun bin-search (obj vec)",
    "docstring": {
      "en": "Binary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "sq": "Kërkimi binar për 'obj' në vektorin e renditur 'vec'.\nKthen 't' nëse 'obj' gjendet, 'nil' përndryshe.\nShembull:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "hy": "Բինար որոնում 'obj'-ի համար դասավորված վեկտոր 'vec'-ում: Վերադարձնում է 't', եթե 'obj'-ը գտնվել է, 'nil' հակառակ դեպքում:\nՕրինակ:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "bn": "বাইনারি সার্চ 'obj' এর জন্য সাজানো ভেক্টর 'vec' এ। \n'obj' পাওয়া গেলে 't' রিটার্ন করে, অন্যথায় 'nil' রিটার্ন করে। \nউদাহরণ:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "bg": "Двоично търсене на 'obj' в сортиран вектор 'vec'.  \nВръща 't', ако 'obj' е намерен, 'nil' в противен случай.  \nПример:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "zh": "在排序向量 'vec' 中二分查找 'obj'。\n如果找到 'obj'，返回 't'，否则返回 'nil'。\n示例:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "fr": "Recherche binaire pour 'obj' dans le vecteur trié 'vec'.  \nRenvoie 't' si 'obj' est trouvé, 'nil' sinon.  \nExemple:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "de": "Binäre Suche nach 'obj' im sortierten Vektor 'vec'.\nGibt 't' zurück, wenn 'obj' gefunden wird, andernfalls 'nil'.\nBeispiel:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "ha": "Binciken binary don 'obj' a cikin vector da aka tsara 'vec'.  \nYana mayar da 't' idan an sami 'obj', 'nil' in ba haka ba.  \nMisali:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "hi": "सॉर्टेड वेक्टर 'vec' में 'obj' के लिए बाइनरी खोज।  \nयदि 'obj' पाया जाता है तो 't' लौटाता है, अन्यथा 'nil'।  \nउदाहरण:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "hu": "Bináris keresés 'obj' elemre a rendezett 'vec' vektorban.\n't' értéket ad vissza, ha 'obj' megtalálható, különben 'nil'-t.\nPélda:\n>>> bin-search 3 '#(1 2 3 4 5)\nt"
    },
    "docstring_bertscore": {
      "sq": "0.9936078757079163",
      "hy": "1",
      "bn": "0.9631286396292558",
      "bg": "0.9931643340670654",
      "zh": "0.9387417945976974",
      "fr": "0.9936078757079163",
      "de": "0.9683651323644785",
      "ha": "0.9936078757079163",
      "hi": "0.9683651323644785",
      "hu": "0.942952957306018"
    }
  },
  {
    "task_id": "Common Lisp/3",
    "prompt": {
      "en": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n;; Example:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "sq": "(defun parse-date (date-str)\n\"Analizo një varg date në formatin 'DD MMM YYYY' dhe kthe një listë (ditë muaj vit).\"\n;; Shembull:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "hy": "(defun parse-date (date-str)\n\"Վերլուծել ամսաթվի տողը 'DD MMM YYYY' ձևաչափով և վերադարձնել ցուցակ (օր ամիս տարի):\"\n;; Օրինակ:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "bn": "(defun parse-date (date-str)\n\"তারিখের স্ট্রিং 'DD MMM YYYY' ফরম্যাটে পার্স করে একটি তালিকা (দিন মাস বছর) রিটার্ন করে।\"\n;; উদাহরণ:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "bg": "(defun parse-date (date-str)\n\"Парсирайте низ за дата във формат 'DD MMM YYYY' и върнете списък (ден месец година).\"\n;; Пример:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "zh": "(defun parse-date (date-str)\n\"解析格式为 'DD MMM YYYY' 的日期字符串，并返回一个列表 (day month year)。\"\n;; 示例:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "fr": "(defun parse-date (date-str)\n\"Analyser une chaîne de date au format 'DD MMM YYYY' et retourner une liste (jour mois année).\"\n;; Exemple:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "de": "(defun parse-date (date-str)\n\"Analysiere einen Datumsstring im Format 'DD MMM YYYY' und gebe eine Liste (Tag Monat Jahr) zurück.\"\n;; Beispiel:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "ha": "(defun parse-date (date-str)\n\"Fassara wani kwanan wata a cikin tsarin 'DD MMM YYYY' kuma dawo da jerin (rana wata shekara).\"\n;; Misali:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "hi": "(defun parse-date (date-str)\n\"तारीख स्ट्रिंग को 'DD MMM YYYY' प्रारूप में पार्स करें और एक सूची (दिन महीना वर्ष) लौटाएं।\"\n;; उदाहरण:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "hu": "(defun parse-date (date-str)\n\"Dátum karakterlánc elemzése 'DD MMM YYYY' formátumban, és egy lista visszaadása (nap hónap év).\"\n;; Példa:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9740652284090368",
      "bn": "0.973543426398058",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.989979494537552",
      "hi": "0.984695926402024",
      "hu": "0.9630593176262746"
    },
    "canonical_solution": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))",
    "instruction": {
      "en": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8777588909035091",
      "fr": "0.9711523138711601",
      "de": "0.93952539145088",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9330307738821823"
    },
    "level": "",
    "test": "(defun check-parse-date ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check-parse-date)",
    "entry_point": "parse-date",
    "signature": "(defun parse-date (date-str)",
    "docstring": {
      "en": "\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "sq": "\"Analizo një varg date në formatin 'DD MMM YYYY' dhe kthe një listë (ditë muaj vit).\"\nShembull:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "hy": "\"Վերլուծել ամսաթվի տողը 'DD MMM YYYY' ձևաչափով և վերադարձնել ցուցակ (օր ամիս տարի):\"\nՕրինակ:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "bn": "\"একটি তারিখ স্ট্রিং 'DD MMM YYYY' ফরম্যাটে পার্স করুন এবং একটি তালিকা (দিন মাস বছর) রিটার্ন করুন।\"\nউদাহরণ:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "bg": "\"Парсирайте низ за дата във формат 'DD MMM YYYY' и върнете списък (ден месец година).\"\nПример:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "zh": "将格式为 'DD MMM YYYY' 的日期字符串解析为一个列表（天 月 年）。  \n示例：  \n>>> parse-date \"16 Aug 1980\"  \n16 8 1980",
      "fr": "\"Analyser une chaîne de date au format 'JJ MMM AAAA' et retourner une liste (jour mois année).\"\nExemple:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "de": "\"Analysiere einen Datumsstring im Format 'DD MMM YYYY' und gib eine Liste zurück (Tag Monat Jahr).\"\nBeispiel:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "ha": "\"Fassara wani jeren kwanan wata a cikin tsarin 'DD MMM YYYY' kuma dawo da jerin (rana wata shekara).\"\n\nMisali:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "hi": "\"तारीख स्ट्रिंग को 'DD MMM YYYY' प्रारूप में पार्स करें और एक सूची (दिन माह वर्ष) लौटाएं।\"\nउदाहरण:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "hu": "\"Parsoljon egy dátum karakterláncot a 'NN HHH ÉÉÉÉ' formátumban, és adjon vissza egy listát (nap hónap év).\"\nPélda:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980"
    },
    "docstring_bertscore": {
      "sq": "0.955950932180179",
      "hy": "0.9393362953281348",
      "bn": "0.8377386431022188",
      "bg": "0.985037967918166",
      "zh": "0.950069486597736",
      "fr": "0.9749199349386298",
      "de": "0.9749199349386298",
      "ha": "0.953178250691313",
      "hi": "0.9827729856832251",
      "hu": "0.8324860613061322"
    }
  },
  {
    "task_id": "Common Lisp/4",
    "prompt": {
      "en": "(defun fourth-element (lst)\n;; use car and cdr to return the fourth element in list\n;; Example:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "sq": "(defun fourth-element (lst)\n;; përdor car dhe cdr për të kthyer elementin e katërt në listë\n;; Shembull:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "hy": "(defun fourth-element (lst)\n;; օգտագործել car և cdr՝ ցուցակի չորրորդ տարրը վերադարձնելու համար\n;; Օրինակ:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "bn": "(defun fourth-element (lst)\n;; তালিকার চতুর্থ উপাদান ফেরত দিতে car এবং cdr ব্যবহার করুন\n;; উদাহরণ:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "bg": "(defun fourth-element (lst)\n;; използвайте car и cdr, за да върнете четвъртия елемент в списъка\n;; Пример:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "zh": "(defun fourth-element (lst)\n;; 使用 car 和 cdr 返回列表中的第四个元素\n;; 示例:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "fr": "(defun fourth-element (lst)\n;; utiliser car et cdr pour retourner le quatrième élément de la liste\n;; Exemple:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "de": "(defun fourth-element (lst)\n;; Verwenden Sie car und cdr, um das vierte Element in der Liste zurückzugeben\n;; Beispiel:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "ha": "(defun fourth-element (lst)\n;; yi amfani da car da cdr don dawo da abu na huɗu a cikin jerin\n;; Misali:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "hi": "(defun fourth-element (lst)\n;; car और cdr का उपयोग करके सूची में चौथा तत्व लौटाएं\n;; उदाहरण:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "hu": "(defun fourth-element (lst)\n;; használd a car és cdr függvényeket, hogy visszaadja a lista negyedik elemét\n;; Példa:\n;; >>> fourth-element '(a b c d e f)\n;; 'd"
    },
    "prompt_bertscore": {
      "sq": "0.9862629214780082",
      "hy": "0.9828730953952668",
      "bn": "0.9813053057977584",
      "bg": "0.9862629214780082",
      "zh": "0.9845104056261373",
      "fr": "0.9828730953952668",
      "de": "0.9845104056261373",
      "ha": "0.9752027846012236",
      "hi": "0.969204544354732",
      "hu": "0.9592909020372807"
    },
    "canonical_solution": "(car (cdr (cdr (cdr lst)))))",
    "instruction": {
      "en": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\n请用最多500个字符的中文提供对以下Common Lisp代码的简洁自然语言描述（文档字符串）。",
      "fr": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9332107330073999",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8529358535551981",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.9077727359994049",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-fourth-element ()\n(assert (equal (fourth-element '(a b c d e f)) 'd))\n(assert (equal (fourth-element '(1 2 3 4 5 6)) 4))\n(assert (equal (fourth-element '(\"one\" \"two\" \"three\" \"four\" \"five\")) \"four\")))\n\n(check-fourth-element)",
    "entry_point": "fourth-element",
    "signature": "(defun fourth-element (lst)",
    "docstring": {
      "en": "use car and cdr to return the fourth element in list\nExample:\n>>> fourth-element '(a b c d e f)\n'd",
      "sq": "përdor car dhe cdr për të kthyer elementin e katërt në listë\nShembull:\n>>> fourth-element '(a b c d e f)\n'd",
      "hy": "օգտագործեք car և cdr՝ ցուցակի չորրորդ տարրը վերադարձնելու համար\nՕրինակ:\n>>> fourth-element '(a b c d e f)\n'd",
      "bn": "car এবং cdr ব্যবহার করে তালিকার চতুর্থ উপাদান ফেরত দিন\nউদাহরণ:\n>>> fourth-element '(a b c d e f)\n'd",
      "bg": "използвайте car и cdr, за да върнете четвъртия елемент в списъка\nПример:\n>>> fourth-element '(a b c d e f)\n'd",
      "zh": "使用 car 和 cdr 返回列表中的第四个元素  \n示例:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "fr": "utiliser car et cdr pour retourner le quatrième élément dans la liste\nExemple:\n>>> fourth-element '(a b c d e f)\n'd",
      "de": "Verwenden Sie car und cdr, um das vierte Element in der Liste zurückzugeben\nBeispiel:\n>>> fourth-element '(a b c d e f)\n'd",
      "ha": "yi amfani da car da cdr don dawo da abu na huɗu a cikin jerin\nMisali:\n>>> fourth-element '(a b c d e f)\n'd",
      "hi": "सूची में चौथा तत्व लौटाने के लिए car और cdr का उपयोग करें  \nउदाहरण:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "hu": "használja a car és cdr függvényeket a negyedik elem visszaadásához a listában\nPélda:\n>>> fourth-element '(a b c d e f)\n'd"
    },
    "docstring_bertscore": {
      "sq": "0.9929210118502976",
      "hy": "0.9821508753298239",
      "bn": "0.986740428914016",
      "bg": "0.9929210118502976",
      "zh": "0.9919358051603646",
      "fr": "0.9929210118502976",
      "de": "0.9929210118502976",
      "ha": "0.9734794674153648",
      "hi": "0.9919358051603646",
      "hu": "0.9607752668747545"
    }
  },
  {
    "task_id": "Common Lisp/5",
    "prompt": {
      "en": "(defun count-a-in-list (lst)\n;; Calculate the number of times' a 'appears in the list.\n;; Example:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "sq": "(defun count-a-in-list (lst)\n;; Llogarit numrin e herëve që 'a' shfaqet në listë.\n;; Shembull:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "hy": "(defun count-a-in-list (lst)\n;; Հաշվեք, թե քանի անգամ 'a' է հայտնվում ցուցակում:\n;; Օրինակ:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "bn": "(defun count-a-in-list (lst)\n;; তালিকায় 'a' কতবার উপস্থিত আছে তা গণনা করুন।\n;; উদাহরণ:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "bg": "(defun count-a-in-list (lst)\n;; Изчислете колко пъти 'a' се появява в списъка.\n;; Пример:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "zh": "(defun count-a-in-list (lst)\n;; 计算列表中出现'a'的次数。\n;; 例子:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "fr": "(defun count-a-in-list (lst)\n;; Calculer le nombre de fois que 'a' apparaît dans la liste.\n;; Exemple:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "de": "(defun count-a-in-list (lst)\n;; Berechne, wie oft 'a' in der Liste vorkommt.\n;; Beispiel:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "ha": "(defun count-a-in-list (lst)\n;; Lissafi nawa sau 'a' ya bayyana a cikin jerin.\n;; Misali:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "hi": "(defun count-a-in-list (lst)\n;; सूची में 'a' कितनी बार आता है, यह गणना करें।\n;; उदाहरण:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "hu": "(defun count-a-in-list (lst)\n;; Számolja meg, hogy hányszor fordul elő az 'a' a listában.\n;; Példa:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3"
    },
    "prompt_bertscore": {
      "sq": "0.9671864596834175",
      "hy": "0.93614351058338",
      "bn": "0.9447982335458321",
      "bg": "0.9610682466867809",
      "zh": "0.9692977020034373",
      "fr": "0.9692977020034373",
      "de": "0.9491959101819446",
      "ha": "0.9474996067279067",
      "hi": "0.9474996067279067",
      "hu": "0.9420493877026903"
    },
    "canonical_solution": "(loop for item in lst\ncounting (eql item 'a)))",
    "instruction": {
      "en": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8778232471469645",
      "bg": "0.8388862829106369",
      "zh": "0.8724534734260673",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-count-a-in-list ()\n(assert (equal (count-a-in-list '(a b c d a e f a)) 3))\n(assert (equal (count-a-in-list '(1 2 3 4 5)) 0))\n(assert (equal (count-a-in-list '(a a a a)) 4))\n(assert (equal (count-a-in-list '(b c d)) 0)))\n\n(check-count-a-in-list)",
    "entry_point": "count-a-in-list",
    "signature": "(defun count-a-in-list (lst)",
    "docstring": {
      "en": "Calculate the number of times' a 'appears in the list.\nExample:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "sq": "Llogarit numrin e herëve që 'a' shfaqet në listë.\nShembull:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "hy": "Հաշվեք, թե քանի անգամ է 'a' հայտնվում ցուցակում:\nՕրինակ:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "bn": "তালিকায় 'a' কতবার উপস্থিত হয়েছে তা গণনা করুন।\nউদাহরণ:  \n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "bg": "Изчислете колко пъти 'a' се появява в списъка.\nПример:\n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "zh": "计算列表中'a'出现的次数。\n示例：\n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "fr": "Calculer le nombre de fois où 'a' apparaît dans la liste.\nExemple:\n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "de": "Berechnen Sie, wie oft 'a' in der Liste vorkommt.\nBeispiel:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "ha": "Ƙididdige yawan lokutan da 'a' ya bayyana a cikin jerin.\nMisali:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "hi": "सूची में 'a' कितनी बार आता है, इसकी गणना करें।\nउदाहरण:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "hu": "Számolja ki, hogy az 'a' hányszor fordul elő a listában.\nPélda:\n>>> count-a-in-list '(a b c d a e f a)\n3"
    },
    "docstring_bertscore": {
      "sq": "0.9596760463461074",
      "hy": "0.9129464615342205",
      "bn": "0.9596760463461074",
      "bg": "0.93954843257508",
      "zh": "0.914411956485496",
      "fr": "0.9596760463461074",
      "de": "0.9267403483451884",
      "ha": "0.9596760463461074",
      "hi": "0.9197620657986707",
      "hu": "0.9361236475452765"
    }
  },
  {
    "task_id": "Common Lisp/6",
    "prompt": {
      "en": "(defun ordered-union (list1 list2)\n;; Write a version of union that preserves the order of the elements in the original lists:\n;; Example:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "sq": "(defun ordered-union (list1 list2)\n;; Shkruani një version të union që ruan rendin e elementeve në listat origjinale:\n;; Shembull:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "hy": "(defun ordered-union (list1 list2)\n;; Գրեք միության մի տարբերակ, որը պահպանում է սկզբնական ցուցակների տարրերի կարգը:\n;; Օրինակ:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "bn": "(defun ordered-union (list1 list2)\n;; একটি union এর এমন একটি সংস্করণ লিখুন যা মূল তালিকাগুলির উপাদানগুলির ক্রম সংরক্ষণ করে:\n;; উদাহরণ:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "bg": "(defun ordered-union (list1 list2)\n;; Напишете версия на обединение, която запазва реда на елементите в оригиналните списъци:\n;; Пример:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "zh": "(defun ordered-union (list1 list2)\n;; 编写一个版本的union，保持原始列表中元素的顺序：\n;; 例子:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "fr": "(defun ordered-union (list1 list2)\n;; Écrire une version de union qui préserve l'ordre des éléments dans les listes originales :\n;; Exemple:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "de": "(defun ordered-union (list1 list2)\n;; Schreiben Sie eine Version von Union, die die Reihenfolge der Elemente in den ursprünglichen Listen beibehält:\n;; Beispiel:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "ha": "(defun ordered-union (list1 list2)\n;; Rubuta wani sigar haɗin da ke kiyaye tsarin abubuwan cikin jerin asali:\n;; Misali:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "hi": "(defun ordered-union (list1 list2)\n;; तत्वों के क्रम को मूल सूचियों में संरक्षित करने वाला संघ का एक संस्करण लिखें:\n;; उदाहरण:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "hu": "(defun ordered-union (list1 list2)\n;; Írj egy olyan union függvényt, amely megőrzi az elemek sorrendjét az eredeti listákban:\n;; Példa:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6"
    },
    "prompt_bertscore": {
      "sq": "0.9952354530501162",
      "hy": "0.9916062773582277",
      "bn": "0.9916062773582277",
      "bg": "0.9952354530501162",
      "zh": "0.9930527037929238",
      "fr": "0.9952354530501162",
      "de": "0.9952354530501162",
      "ha": "0.9952354530501162",
      "hi": "0.9952354530501162",
      "hu": "0.9740167625960642"
    },
    "canonical_solution": "(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))",
    "instruction": {
      "en": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nՏրամադրեք համառոտ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\n请用中文为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9315233679205085",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8618400562762301",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.8808811618629965",
      "hu": "0.9330307738821823"
    },
    "level": "",
    "test": "(defun check-ordered-union ()\n(assert (equal (ordered-union '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))\n(assert (equal (ordered-union '(1 2 3) '(3 4 5)) '(1 2 3 4 5)))\n(assert (equal (ordered-union '(a b c) '(b c d)) '(a b c d)))\n(assert (equal (ordered-union '() '(1 2 3)) '(1 2 3)))\n(assert (equal (ordered-union '(1 2 3) '()) '(1 2 3))))\n\n(check-ordered-union)",
    "entry_point": "ordered-union",
    "signature": "(defun ordered-union (list1 list2)",
    "docstring": {
      "en": "Write a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "sq": "Shkruani një version të union që ruan rendin e elementeve në listat origjinale:\nShembull:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hy": "Գրեք union-ի մի տարբերակ, որը պահպանում է սկզբնական ցուցակների տարրերի հերթականությունը:\nՕրինակ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "bn": "মূল তালিকার উপাদানগুলির ক্রম সংরক্ষণ করে এমন একটি union এর সংস্করণ লিখুন:\nউদাহরণ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "bg": "Напишете версия на union, която запазва реда на елементите в оригиналните списъци:\nПример:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "zh": "编写一个保留原始列表中元素顺序的union版本：\n示例：\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "fr": "Écrivez une version de union qui préserve l'ordre des éléments dans les listes originales:\nExemple:\n>>> ordered-union '(1 2 3) '(4 5 6)  \n1 2 3 4 5 6",
      "de": "Schreiben Sie eine Version von union, die die Reihenfolge der Elemente in den ursprünglichen Listen beibehält:\nBeispiel:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "ha": "Rubuta wata sigar union wadda ke kiyaye tsarin abubuwan cikin jerin asali:\n\nMisali:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hi": "मूल सूचियों में तत्वों के क्रम को बनाए रखने वाला union का एक संस्करण लिखें:\nउदाहरण:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hu": "Írj egy olyan union verziót, amely megőrzi az elemek sorrendjét az eredeti listákban:\nPélda:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6"
    },
    "docstring_bertscore": {
      "sq": "0.9951204460594969",
      "hy": "0.9839264323058948",
      "bn": "0.9897683504425119",
      "bg": "0.9951204460594969",
      "zh": "0.9897683504425119",
      "fr": "0.9951204460594969",
      "de": "0.9926945732159178",
      "ha": "0.9951204460594969",
      "hi": "0.9926945732159178",
      "hu": "0.9951204460594969"
    }
  },
  {
    "task_id": "Common Lisp/7",
    "prompt": {
      "en": "(defun occurrences (lst)\n;; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\n;; Example:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "sq": "(defun occurrences (lst)\n;; merr një listë dhe kthen një listë që tregon numrin e herëve që çdo element (eql) shfaqet, të renditur nga elementi më i zakonshëm te elementi më pak i zakonshëm\n;; Shembull:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "hy": "(defun occurrences (lst)\n;; ընդունում է ցուցակ և վերադարձնում ցուցակ, որը ցույց է տալիս, թե քանի անգամ է յուրաքանչյուր (eql) տարր հանդիպում, դասավորված ամենահաճախ հանդիպող տարրից մինչև ամենաքիչ հանդիպողը\n;; Օրինակ:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "bn": "(defun occurrences (lst)\n;; একটি তালিকা নেয় এবং একটি তালিকা ফেরত দেয় যা প্রতিটি (eql) উপাদান কতবার উপস্থিত হয়েছে তা নির্দেশ করে, সবচেয়ে সাধারণ উপাদান থেকে সবচেয়ে কম সাধারণ উপাদান পর্যন্ত সাজানো\n;; উদাহরণ:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "bg": "(defun occurrences (lst)\n;; приема списък и връща списък, указващ броя на появяванията на всеки (eql) елемент, сортиран от най-често срещания елемент до най-рядко срещания\n;; Пример:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "zh": "(defun occurrences (lst)\n;; 接受一个列表并返回一个列表，指示每个 (eql) 元素出现的次数，从最常见的元素到最不常见的元素排序\n;; 例子:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "fr": "(defun occurrences (lst)\n;; prend une liste et renvoie une liste indiquant le nombre de fois que chaque élément (eql) apparaît, triée de l'élément le plus commun à l'élément le moins commun\n;; Exemple:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "de": "(defun occurrences (lst)\n;; nimmt eine Liste und gibt eine Liste zurück, die angibt, wie oft jedes (eql) Element vorkommt, sortiert vom häufigsten Element zum seltensten\n;; Beispiel:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "ha": "(defun occurrences (lst)\n;; yana ɗaukar jerin kuma yana dawo da jerin da ke nuna adadin lokutan da kowane (eql) abu ya bayyana, an jera daga abu mafi yawan zuwa mafi ƙarancin\n;; Misali:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "hi": "(defun occurrences (lst)\n;; एक सूची लेता है और एक सूची लौटाता है जो यह दर्शाता है कि प्रत्येक (eql) तत्व कितनी बार प्रकट होता है, सबसे सामान्य तत्व से लेकर सबसे कम सामान्य तत्व तक क्रमबद्ध\n;; उदाहरण:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "hu": "(defun occurrences (lst)\n;; vesz egy listát, és visszaad egy listát, amely jelzi, hogy az egyes (eql) elemek hányszor fordulnak elő, a leggyakoribb elemtől a legkevésbé gyakoriig rendezve\n;; Példa:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "prompt_bertscore": {
      "sq": "0.9741536189285972",
      "hy": "0.9545108619176761",
      "bn": "0.9784192063613215",
      "bg": "0.9651987654604014",
      "zh": "0.953690717074383",
      "fr": "0.9766017383748522",
      "de": "0.9769725812962444",
      "ha": "0.9746223866278396",
      "hi": "0.9807074283508433",
      "hu": "0.9802031058133958"
    },
    "canonical_solution": "(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))",
    "instruction": {
      "en": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9452918300427039",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8810039154384761",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9436978212348989",
      "hi": "0.8808811618629965",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-occurrences ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check-occurrences)",
    "entry_point": "occurrences",
    "signature": "(defun occurrences (lst)",
    "docstring": {
      "en": "takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "sq": "merr një listë dhe kthen një listë që tregon numrin e herëve që secili element (eql) shfaqet, të renditur nga elementi më i zakonshëm te elementi më pak i zakonshëm\nShembull:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hy": "վերցնում է ցուցակ և վերադարձնում ցուցակ, որը ցույց է տալիս, թե քանի անգամ է յուրաքանչյուր (eql) տարրը հանդիպում, դասավորված ամենահաճախ հանդիպող տարրից մինչև ամենաքիչ հանդիպողը\nՕրինակ:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "bn": "একটি তালিকা গ্রহণ করে এবং প্রতিটি (eql) উপাদান কতবার প্রদর্শিত হয়েছে তা নির্দেশ করে একটি তালিকা প্রদান করে, সবচেয়ে সাধারণ উপাদান থেকে সবচেয়ে কম সাধারণ উপাদান পর্যন্ত সাজানো\nউদাহরণ:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "bg": "приема списък и връща списък, показващ броя на пъти, когато всеки (eql) елемент се появява, сортиран от най-често срещания елемент до най-рядко срещания  \nПример:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "zh": "接收一个列表并返回一个列表，指示每个（eql）元素出现的次数，从最常见的元素到最不常见的元素排序\n示例:\n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "fr": "prend une liste et renvoie une liste indiquant le nombre de fois que chaque élément (eql) apparaît, triée de l'élément le plus commun à l'élément le moins commun\nExemple:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "de": "nimmt eine Liste und gibt eine Liste zurück, die angibt, wie oft jedes (eql) Element vorkommt, sortiert vom häufigsten zum seltensten Element\nBeispiel:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "ha": "yana ɗaukar jerin kuma yana mayar da jeri yana nuna adadin lokutan da kowane (eql) abu ya bayyana, an jera daga mafi yawan abu zuwa mafi ƙarancin abu\nMisali:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hi": "एक सूची लेता है और एक सूची लौटाता है जो यह दर्शाता है कि प्रत्येक (eql) तत्व कितनी बार प्रकट होता है, सबसे सामान्य तत्व से लेकर सबसे कम सामान्य तत्व तक क्रमबद्ध\n\nउदाहरण:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hu": "visszaad egy listát, amely jelzi, hogy az egyes (eql) elemek hányszor fordulnak elő, a leggyakoribb elemtől a legkevésbé gyakoriig rendezve  \nPélda:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "docstring_bertscore": {
      "sq": "0.9678528646117895",
      "hy": "0.9602963690260793",
      "bn": "0.9569204470700103",
      "bg": "0.9806589625378709",
      "zh": "1",
      "fr": "0.9770029717445428",
      "de": "0.9738948035421088",
      "ha": "0.9473762572612839",
      "hi": "0.9817595734791852",
      "hu": "0.9388095275576303"
    }
  },
  {
    "task_id": "Common Lisp/8",
    "prompt": {
      "en": "(defun list-to-dots (lst)\n;; takes a list and prints it in dot natation\n;; Example:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "sq": "(defun list-to-dots (lst)\n;; merr një listë dhe e printon atë në notacion pikash\n;; Shembull:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "hy": "(defun list-to-dots (lst)\n;; ընդունում է ցուցակ և տպում այն կետային նշումով\n;; Օրինակ:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "bn": "(defun list-to-dots (lst)\n;; একটি তালিকা নেয় এবং এটি ডট নোটেশনে প্রিন্ট করে\n;; উদাহরণ:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "bg": "(defun list-to-dots (lst)\n;; приема списък и го отпечатва в точкова нотация\n;; Пример:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "zh": "(defun list-to-dots (lst)\n;; 接受一个列表并以点表示法打印\n;; 例子:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "fr": "(defun list-to-dots (lst)\n;; prend une liste et l'imprime en notation pointée\n;; Exemple:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "de": "(defun list-to-dots (lst)\n;; nimmt eine Liste und gibt sie in Punktnotation aus\n;; Beispiel:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "ha": "(defun list-to-dots (lst)\n;; yana ɗaukar jerin kuma yana buga shi a cikin tsarin doti\n;; Misali:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "hi": "(defun list-to-dots (lst)\n;; एक सूची लेता है और इसे डॉट नोटेशन में प्रिंट करता है\n;; उदाहरण:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "hu": "(defun list-to-dots (lst)\n;; egy listát vesz át és pontozott jelöléssel nyomtatja ki\n;; Példa:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))"
    },
    "prompt_bertscore": {
      "sq": "0.9730200353440311",
      "hy": "0.9656689235723109",
      "bn": "0.9756920112297125",
      "bg": "0.9656689235723109",
      "zh": "0.9652964916078706",
      "fr": "0.9730200353440311",
      "de": "0.9694297912068255",
      "ha": "0.9785060078378337",
      "hi": "0.9756920112297125",
      "hu": "0.9730200353440311"
    },
    "canonical_solution": "(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))",
    "instruction": {
      "en": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nՏրամադրեք Common Lisp կոդի համառոտ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\n请用中文为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9041169438364577",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8524768187446264",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9543551356989448",
      "hi": "0.9077727359994049",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-list-to-dots ()\n;; 测试 'list-to-dots' 函数。\n(assert (equal (list-to-dots '(a b c)) '(a . (b . (c . nil)))))\n(assert (equal (list-to-dots '(1 2 3)) '(1 . (2 . (3 . nil)))))\n(assert (equal (list-to-dots '(x y)) '(x . (y . nil))))\n(assert (equal (list-to-dots '()) 'nil)))\n\n(check-list-to-dots)",
    "entry_point": "list-to-dots",
    "signature": "(defun list-to-dots (lst)",
    "docstring": {
      "en": "takes a list and prints it in dot natation\nExample:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "sq": "merr një listë dhe e printon atë në notacion me pika\nShembull:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "hy": "վերցնում է ցուցակ և տպում այն կետային նշումով\nՕրինակ:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "bn": "একটি তালিকা নেয় এবং এটি ডট নোটেশনে প্রিন্ট করে\nউদাহরণ:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "bg": "взема списък и го отпечатва в точкова нотация\nПример:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "zh": "将列表转换为点表示法并打印\n示例:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "fr": "prend une liste et l'imprime en notation par points\nExemple :\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "de": "nimmt eine Liste und gibt sie in Punktnotation aus\nBeispiel:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "ha": "yana ɗaukar jeri kuma yana buga shi a cikin tsarin dige-dige\nMisali:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "hi": "एक सूची लेता है और इसे डॉट नोटेशन में प्रिंट करता है\nउदाहरण:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "hu": "vesz egy listát, és pontozott jelöléssel nyomtatja ki\nPélda:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))"
    },
    "docstring_bertscore": {
      "sq": "0.9561745899892243",
      "hy": "0.9534380592297067",
      "bn": "0.9710319438602529",
      "bg": "0.9624105908018147",
      "zh": "0.9191155239084021",
      "fr": "0.9624105908018147",
      "de": "0.9710319438602529",
      "ha": "0.9710319438602529",
      "hi": "0.9710319438602529",
      "hu": "0.9578820167446003"
    }
  },
  {
    "task_id": "Common Lisp/9",
    "prompt": {
      "en": "(defun contains-nil? (lst)\n;; Check if the list contains nil elements\n;; Example:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "sq": "(defun contains-nil? (lst)\n;; Kontrollo nëse lista përmban elemente nil\n;; Shembull:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "hy": "(defun contains-nil? (lst)\n;; Ստուգել, արդյոք ցուցակը պարունակում է nil տարրեր\n;; Օրինակ:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "bn": "(defun contains-nil? (lst)\n;; তালিকায় nil উপাদান আছে কিনা পরীক্ষা করুন\n;; উদাহরণ:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "bg": "(defun contains-nil? (lst)\n;; Проверка дали списъкът съдържа nil елементи\n;; Пример:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "zh": "(defun contains-nil? (lst)\n;; 检查列表是否包含nil元素\n;; 示例:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "fr": "(defun contains-nil? (lst)\n;; Vérifie si la liste contient des éléments nil\n;; Exemple:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "de": "(defun contains-nil? (lst)\n;; Überprüfen, ob die Liste nil-Elemente enthält\n;; Beispiel:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "ha": "(defun contains-nil? (lst)\n;; Duba idan jerin yana dauke da abubuwan nil\n;; Misali:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "hi": "(defun contains-nil? (lst)\n;; जाँचें कि सूची में nil तत्व हैं या नहीं\n;; उदाहरण:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "hu": "(defun contains-nil? (lst)\n;; Ellenőrzi, hogy a lista tartalmaz-e nil elemeket\n;; Példa:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9894795418684872",
      "bg": "1",
      "zh": "0.9894795418684872",
      "fr": "0.9950765487452883",
      "de": "1",
      "ha": "1",
      "hi": "0.9723250276407901",
      "hu": "0.9950765487452883"
    },
    "canonical_solution": "(loop for item in lst\nthereis (null item)))",
    "instruction": {
      "en": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nՏրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\n请提供一段简洁的中文自然语言描述（文档字符串），用于描述以下 Common Lisp 代码，字数不超过 500 个字符。",
      "fr": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9452918300427039",
      "bn": "0.8389377747125264",
      "bg": "0.8335809119663965",
      "zh": "0.8695838603112562",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9349640433807949"
    },
    "level": "",
    "test": "(defun check-contains-nil? ()\n(assert (equal (contains-nil? '(1 2 3 nil 4 5)) t))\n(assert (equal (contains-nil? '(1 2 3 4 5)) nil))\n(assert (equal (contains-nil? '(nil 1 2 3)) t))\n(assert (equal (contains-nil? '()) nil))\n(assert (equal (contains-nil? '(nil)) t)))\n\n(check-contains-nil?)",
    "entry_point": "contains-nil?",
    "signature": "(defun contains-nil? (lst)",
    "docstring": {
      "en": "Check if the list contains nil elements\nExample:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "sq": "Kontrollo nëse lista përmban elemente nil  \nShembull:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "hy": "Ստուգել, արդյոք ցուցակը պարունակում է nil տարրեր  \nՕրինակ:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "bn": "তালিকায় nil উপাদান আছে কিনা পরীক্ষা করুন\nউদাহরণ:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "bg": "Проверете дали списъкът съдържа nil елементи  \nПример:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "zh": "检查列表是否包含 nil 元素\n示例：\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "fr": "Vérifiez si la liste contient des éléments nil  \nExemple:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "de": "Überprüfen Sie, ob die Liste nil-Elemente enthält  \nBeispiel:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "ha": "Duba ko jerin yana dauke da abubuwan da ba su da kima  \nMisali:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "hi": "सूची में nil तत्व शामिल हैं या नहीं, यह जांचें  \nउदाहरण:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "hu": "Ellenőrizze, hogy a lista tartalmaz-e nil elemeket  \nPélda:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9442426643700775",
      "bg": "1",
      "zh": "0.9842603299764144",
      "fr": "1",
      "de": "1",
      "ha": "0.975302099791741",
      "hi": "0.9700451481272716",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/10",
    "prompt": {
      "en": "(defun index-of-element (element lst)\n;; Returns the index of the element in the list, or nil if the element is not in the list.\n;; Example:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "sq": "(defun index-of-element (element lst)\n;; Kthen indeksin e elementit në listë, ose nil nëse elementi nuk është në listë.\n;; Shembull:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "hy": "(defun index-of-element (element lst)\n;; Վերադարձնում է տարրի ինդեքսը ցուցակում, կամ nil, եթե տարրը ցուցակում չէ։\n;; Օրինակ:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "bn": "(defun index-of-element (element lst)\n;; তালিকায় উপাদানের সূচক প্রদান করে, অথবা উপাদানটি তালিকায় না থাকলে nil প্রদান করে।\n;; উদাহরণ:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "bg": "(defun index-of-element (element lst)\n;; Връща индекса на елемента в списъка или nil, ако елементът не е в списъка.\n;; Пример:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "zh": "(defun index-of-element (element lst)\n;; 返回列表中元素的索引，如果元素不在列表中则返回nil。\n;; 示例:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "fr": "(defun index-of-element (element lst)\n;; Renvoie l'indice de l'élément dans la liste, ou nil si l'élément n'est pas dans la liste.\n;; Exemple:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "de": "(defun index-of-element (element lst)\n;; Gibt den Index des Elements in der Liste zurück oder nil, wenn das Element nicht in der Liste ist.\n;; Beispiel:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "ha": "(defun index-of-element (element lst)\n;; Yana dawo da maƙasudin abin a cikin jerin, ko kuma nil idan abin ba ya cikin jerin.\n;; Misali:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "hi": "(defun index-of-element (element lst)\n;; सूची में तत्व का सूचकांक लौटाता है, या यदि तत्व सूची में नहीं है तो nil लौटाता है।\n;; उदाहरण:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "hu": "(defun index-of-element (element lst)\n;; Visszaadja az elem indexét a listában, vagy nil értéket, ha az elem nincs a listában.\n;; Példa:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.980272030555615",
      "bg": "0.9875919573575126",
      "zh": "0.9975937915641434",
      "fr": "1",
      "de": "0.9875919573575126",
      "ha": "1",
      "hi": "0.9921104012652943",
      "hu": "1"
    },
    "canonical_solution": "(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))",
    "instruction": {
      "en": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用不超过500个字符的中文。",
      "fr": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nBa da takaitaccen bayani a cikin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakter használatával."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8675367756043106",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.8898221112045199",
      "hu": "0.9428284160571092"
    },
    "level": "",
    "test": "(defun check-index-of-element ()\n;; 测试 'index-of-element' 函数。\n(assert (equal (index-of-element 'a '(a b c d e)) 0))\n(assert (equal (index-of-element 'c '(a b c d e)) 2))\n(assert (equal (index-of-element 'e '(a b c d e)) 4))\n(assert (equal (index-of-element 'f '(a b c d e)) nil))\n(assert (equal (index-of-element 3 '(1 2 3 4 5)) 2)))\n\n(check-index-of-element)",
    "entry_point": "index-of-element",
    "signature": "(defun index-of-element (element lst)",
    "docstring": {
      "en": "Returns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0",
      "sq": "Kthen indeksin e elementit në listë, ose nil nëse elementi nuk është në listë.\nShembull:\n>>> index-of-element 'a '(a b c d e)\n0",
      "hy": "Վերադարձնում է տարրի ինդեքսը ցանկում, կամ nil, եթե տարրը ցանկում չէ:\nՕրինակ:\n>>> index-of-element 'a '(a b c d e)\n0",
      "bn": "তালিকায় উপাদানের সূচক প্রদান করে, অথবা তালিকায় উপাদান না থাকলে nil প্রদান করে।\nউদাহরণ:\n>>> index-of-element 'a '(a b c d e)\n0",
      "bg": "Връща индекса на елемента в списъка или nil, ако елементът не е в списъка.\nПример:\n>>> index-of-element 'a '(a b c d e)\n0",
      "zh": "返回列表中元素的索引，如果元素不在列表中，则返回nil。\n示例：\n>>> index-of-element 'a '(a b c d e)\n0",
      "fr": "Renvoie l'indice de l'élément dans la liste, ou nil si l'élément n'est pas dans la liste.\nExemple:\n>>> index-of-element 'a '(a b c d e)\n0",
      "de": "Gibt den Index des Elements in der Liste zurück oder nil, wenn das Element nicht in der Liste ist.\nBeispiel:\n>>> index-of-element 'a '(a b c d e)\n0",
      "ha": "Yana dawo da lambar inda aka samu abin a cikin jerin, ko kuma nil idan ba a sami abin a cikin jerin ba.\nMisali:\n>>> index-of-element 'a '(a b c d e)\n0",
      "hi": "सूची में तत्व का सूचकांक लौटाता है, या यदि तत्व सूची में नहीं है तो nil लौटाता है।\nउदाहरण:\n>>> index-of-element 'a '(a b c d e)\n0",
      "hu": "Visszaadja az elem indexét a listában, vagy nil értéket, ha az elem nincs a listában.\nPélda:\n>>> index-of-element 'a '(a b c d e)\n0"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.950558911856606",
      "bg": "0.9878795741492511",
      "zh": "0.9837017813449443",
      "fr": "1",
      "de": "0.9878795741492511",
      "ha": "0.9916678527763485",
      "hi": "0.9883608555624986",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/11",
    "prompt": {
      "en": "(defun contains-list? (lst)\n;; Check if the list contains a list element.\n;; Example:\n;; >>> ontains-list? '(1 2 (3 4) 5)\n;; t",
      "sq": "(defun contains-list? (lst)\n;; Kontrollo nëse lista përmban një element listë.\n;; Shembull:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "hy": "(defun contains-list? (lst)\n;; Ստուգել, արդյոք ցուցակը պարունակում է ցուցակի տարր։\n;; Օրինակ:\n;; >>> ontains-list? '(1 2 (3 4) 5)\n;; t",
      "bn": "(defun contains-list? (lst)\n;; তালিকায় কোনো তালিকা উপাদান আছে কিনা তা পরীক্ষা করুন।\n;; উদাহরণ:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "bg": "(defun contains-list? (lst)\n;; Проверете дали списъкът съдържа елемент, който е списък.\n;; Пример:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "zh": "(defun contains-list? (lst)\n;; 检查列表是否包含列表元素。\n;; 示例:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "fr": "(defun contains-list? (lst)\n;; Vérifie si la liste contient un élément de type liste.\n;; Exemple:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "de": "(defun contains-list? (lst)\n;; Überprüfen, ob die Liste ein Listenelement enthält.\n;; Beispiel:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "ha": "(defun contains-list? (lst)\n;; Duba idan jerin yana dauke da wani jeri.\n;; Misali:\n;; >>> ontains-list? '(1 2 (3 4) 5)\n;; t",
      "hi": "(defun contains-list? (lst)\n;; जाँचें कि सूची में कोई सूची तत्व है या नहीं।\n;; उदाहरण:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "hu": "(defun contains-list? (lst)\n;; Ellenőrzi, hogy a lista tartalmaz-e listaelemet.\n;; Példa:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t"
    },
    "prompt_bertscore": {
      "sq": "0.9707580325648059",
      "hy": "0.9707580325648059",
      "bn": "0.9601243551161031",
      "bg": "0.951993817729202",
      "zh": "0.9707580325648059",
      "fr": "0.9472566817719009",
      "de": "0.9707580325648059",
      "ha": "0.9448963569540634",
      "hi": "0.9390746991163118",
      "hu": "0.9655845056603711"
    },
    "canonical_solution": "(loop for item in lst\nthereis (listp item)))",
    "instruction": {
      "en": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段Common Lisp代码，字数不超过500个字符。",
      "fr": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8778232471469645",
      "bg": "0.8388862829106369",
      "zh": "0.8791729405860965",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9252847849129647",
      "hi": "0.9077727359994049",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun check-contains-list? ()\n;; 测试 'contains-list?' 函数。\n(assert (equal (contains-list? '(1 2 (3 4) 5)) t))\n(assert (equal (contains-list? '(1 2 3 4 5)) nil))\n(assert (equal (contains-list? '((1 2) 3 4 5)) t))\n(assert (equal (contains-list? '()) nil))\n(assert (equal (contains-list? '(\"string\" 123 (a b))) t)))\n\n(check-contains-list?)",
    "entry_point": "contains-list?",
    "signature": "(defun contains-list? (lst)",
    "docstring": {
      "en": "Check if the list contains a list element.\nExample:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "sq": "Kontrolloni nëse lista përmban një element liste.  \nShembull:  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt",
      "hy": "Ստուգել, արդյոք ցուցակը պարունակում է ցուցակի տարր:\nՕրինակ:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "bn": "তালিকায় একটি তালিকা উপাদান আছে কিনা তা পরীক্ষা করুন।  \nউদাহরণ:  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt",
      "bg": "Проверете дали списъкът съдържа елемент, който е списък.\nПример:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "zh": "检查列表是否包含列表元素。\n\n示例：\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "fr": "Vérifiez si la liste contient un élément de type liste.\nExemple:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "de": "Überprüfen Sie, ob die Liste ein Listenelement enthält.  \nBeispiel:  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt",
      "ha": "Duba idan jerin yana dauke da wani abu mai jerin.\nMisali:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "hi": "सूची में सूची तत्व है या नहीं, इसकी जाँच करें।  \nउदाहरण:  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt",
      "hu": "Ellenőrizze, hogy a lista tartalmaz-e listaelemet.  \nPélda:  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt"
    },
    "docstring_bertscore": {
      "sq": "0.9613834731014832",
      "hy": "1",
      "bn": "0.9651216968725599",
      "bg": "0.9665053561068488",
      "zh": "0.98666633978189",
      "fr": "0.9679867414886071",
      "de": "1",
      "ha": "0.9015176666702351",
      "hi": "0.9651216968725599",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/12",
    "prompt": {
      "en": "(defun sum-non-nil-elements (lst)\n;; Calculate the sum of all non nil elements in the list.\n;; Example:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "sq": "(defun sum-non-nil-elements (lst)\n;; Llogarit shumën e të gjitha elementeve që nuk janë nil në listë.\n;; Shembull:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "hy": "(defun sum-non-nil-elements (lst)\n;; Հաշվել ցուցակի բոլոր ոչ nil տարրերի գումարը։\n;; Օրինակ:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "bn": "(defun sum-non-nil-elements (lst)\n;; তালিকার সমস্ত nil নয় এমন উপাদানের যোগফল গণনা করুন।\n;; উদাহরণ:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "bg": "(defun sum-non-nil-elements (lst)\n;; Изчислете сумата на всички елементи, които не са nil, в списъка.\n;; Пример:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "zh": "(defun sum-non-nil-elements (lst)\n;; 计算列表中所有非 nil 元素的和。\n;; 例子:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "fr": "(defun sum-non-nil-elements (lst)\n;; Calculer la somme de tous les éléments non nuls dans la liste.\n;; Exemple:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "de": "(defun sum-non-nil-elements (lst)\n;; Berechne die Summe aller nicht-nil-Elemente in der Liste.\n;; Beispiel:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "ha": "(defun sum-non-nil-elements (lst)\n;; Lissafi jimillar dukkan abubuwan da ba su da nil a cikin jerin.\n;; Misali:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "hi": "(defun sum-non-nil-elements (lst)\n;; सूची में सभी गैर-शून्य तत्वों का योग गणना करें।\n;; उदाहरण:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "hu": "(defun sum-non-nil-elements (lst)\n;; Számítsd ki az összes nem nil elem összegét a listában.\n;; Példa:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12"
    },
    "prompt_bertscore": {
      "sq": "0.9728708639278739",
      "hy": "0.9900831795964522",
      "bn": "0.9900831795964522",
      "bg": "0.9742535300102578",
      "zh": "0.9900831795964522",
      "fr": "0.9900831795964522",
      "de": "0.9900831795964522",
      "ha": "0.9900831795964522",
      "hi": "0.9900831795964522",
      "hu": "0.9900831795964522"
    },
    "canonical_solution": "(loop for item in lst\nwhen (not (null item))\nsum item))",
    "instruction": {
      "en": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\n请用中文为以下 Common Lisp 代码提供简明的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8727891587700162",
      "bg": "0.8335809119663965",
      "zh": "0.8618400562762301",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8995998903413434",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-sum-non-nil-elements ()\n(assert (equal (sum-non-nil-elements '(1 2 nil 4 5)) 12))\n(assert (equal (sum-non-nil-elements '(nil nil nil)) 0))\n(assert (equal (sum-non-nil-elements '(3 4 nil 6)) 13))\n(assert (equal (sum-non-nil-elements '()) 0))\n(assert (equal (sum-non-nil-elements '(nil 7 8)) 15)))\n\n(check-sum-non-nil-elements)",
    "entry_point": "sum-non-nil-elements",
    "signature": "(defun sum-non-nil-elements (lst)",
    "docstring": {
      "en": "Calculate the sum of all non nil elements in the list.\nExample:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "sq": "Llogarit shumën e të gjitha elementeve që nuk janë nil në listë.\nShembull:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "hy": "Հաշվարկել ցուցակի բոլոր ոչ nil տարրերի գումարը։\nՕրինակ:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "bn": "তালিকার সমস্ত নন-নিল উপাদানের যোগফল গণনা করুন।\nউদাহরণ:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "bg": "Изчислете сумата на всички ненулеви елементи в списъка.\nПример:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "zh": "计算列表中所有非 nil 元素的和。\n示例：\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "fr": "Calculer la somme de tous les éléments non nuls dans la liste.\nExemple:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "de": "Berechne die Summe aller nicht-nil Elemente in der Liste.\nBeispiel:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "ha": "Ƙididdige jimillar dukkan abubuwan da ba su da ƙima a cikin jerin.\nMisali:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "hi": "सभी गैर-शून्य तत्वों का सूची में योग गणना करें।\nउदाहरण:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "hu": "Számítsa ki az összes nem nil elemek összegét a listában.\nPélda:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12"
    },
    "docstring_bertscore": {
      "sq": "0.9646710045379917",
      "hy": "0.9849612965910866",
      "bn": "1",
      "bg": "0.9812594221797394",
      "zh": "0.9849612965910866",
      "fr": "0.9812594221797394",
      "de": "0.9849612965910866",
      "ha": "0.9763196832337827",
      "hi": "0.9812594221797394",
      "hu": "0.9849612965910866"
    }
  },
  {
    "task_id": "Common Lisp/13",
    "prompt": {
      "en": "(defun conditional-square (x)\n;; If x is a positive integer less than or equal to 5, return x; otherwise, return the square of x.\n;; Example:\n;; >>> conditional-square 3\n;; 3",
      "sq": "(defun conditional-square (x)\n;; Nëse x është një numër i plotë pozitiv më i vogël ose i barabartë me 5, kthe x; përndryshe, kthe katrorin e x.\n;; Shembull:\n;; >>> conditional-square 3\n;; 3",
      "hy": "(defun conditional-square (x)\n;; Եթե x-ը դրական ամբողջ թիվ է, որը փոքր կամ հավասար է 5-ին, վերադարձնել x; հակառակ դեպքում, վերադարձնել x-ի քառակուսին։\n;; Օրինակ:\n;; >>> conditional-square 3\n;; 3",
      "bn": "(defun conditional-square (x)\n;; যদি x একটি ধনাত্মক পূর্ণসংখ্যা হয় যা 5 এর সমান বা তার চেয়ে ছোট, তাহলে x ফেরত দিন; অন্যথায়, x এর বর্গফল ফেরত দিন।\n;; উদাহরণ:\n;; >>> conditional-square 3\n;; 3",
      "bg": "(defun conditional-square (x)\n;; Ако x е положително цяло число, по-малко или равно на 5, върни x; в противен случай върни квадрата на x.\n;; Пример:\n;; >>> conditional-square 3\n;; 3",
      "zh": "(defun conditional-square (x)\n;; 如果 x 是小于或等于 5 的正整数，则返回 x；否则，返回 x 的平方。\n;; 示例:\n;; >>> conditional-square 3\n;; 3",
      "fr": "(defun conditional-square (x)\n;; Si x est un entier positif inférieur ou égal à 5, retourner x ; sinon, retourner le carré de x.\n;; Exemple:\n;; >>> conditional-square 3\n;; 3",
      "de": "(defun conditional-square (x)\n;; Wenn x eine positive ganze Zahl kleiner oder gleich 5 ist, gib x zurück; andernfalls gib das Quadrat von x zurück.\n;; Beispiel:\n;; >>> conditional-square 3\n;; 3",
      "ha": "(defun conditional-square (x)\n;; Idan x lamba ce mai kyau ƙasa da ko daidai da 5, dawo da x; in ba haka ba, dawo da murabba'in x.\n;; Misali:\n;; >>> conditional-square 3\n;; 3",
      "hi": "(defun conditional-square (x)\n;; यदि x एक सकारात्मक पूर्णांक है जो 5 से कम या बराबर है, तो x लौटाएं; अन्यथा, x का वर्ग लौटाएं।\n;; उदाहरण:\n;; >>> conditional-square 3\n;; 3",
      "hu": "(defun conditional-square (x)\n;; Ha x egy pozitív egész szám, amely kisebb vagy egyenlő 5-tel, akkor térjen vissza x-szel; ellenkező esetben térjen vissza x négyzetével.\n;; Példa:\n;; >>> conditional-square 3\n;; 3"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9867745933395541",
      "bn": "0.9684431941042252",
      "bg": "0.9914267154937721",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9882085060602449",
      "hi": "0.9867745933395541",
      "hu": "0.9600353687053995"
    },
    "canonical_solution": "(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))",
    "instruction": {
      "en": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nՏրամադրել հակիրճ բնութագիր (docstring) այս Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Common Lisp 代码，字数不超过 500 个字符。",
      "fr": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9046719171210692",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.88778376623434",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.9077727359994049",
      "hu": "0.9349640433807949"
    },
    "level": "",
    "test": "(defun check-conditional-square ()\n;; 测试 'conditional-square' 函数。\n(assert (equal (conditional-square 3) 3))\n(assert (equal (conditional-square 5) 5))\n(assert (equal (conditional-square 6) 36))\n(assert (equal (conditional-square -3) 9))\n(assert (equal (conditional-square 2.5) 6.25)))\n\n(check-conditional-square)",
    "entry_point": "conditional-square",
    "signature": "(defun conditional-square (x)",
    "docstring": {
      "en": "If x is a positive integer less than or equal to 5, return x; otherwise, return the square of x.\nExample:\n>>> conditional-square 3\n3",
      "sq": "Nëse x është një numër i plotë pozitiv më i vogël ose i barabartë me 5, kthe x; përndryshe, kthe katrorin e x.\nShembull:\n>>> conditional-square 3\n3",
      "hy": "Եթե x-ը դրական ամբողջ թիվ է, որը փոքր կամ հավասար է 5-ին, վերադարձնել x-ը. հակառակ դեպքում, վերադարձնել x-ի քառակուսին:\nՕրինակ:\n>>> conditional-square 3\n3",
      "bn": "যদি x একটি ধনাত্মক পূর্ণসংখ্যা হয় যা ৫ এর চেয়ে কম বা সমান, তাহলে x ফেরত দিন; অন্যথায়, x এর বর্গফল ফেরত দিন।\nউদাহরণ:\n>>> conditional-square 3\n3",
      "bg": "Ако x е положително цяло число, по-малко или равно на 5, върнете x; в противен случай върнете квадрата на x.\nПример:\n>>> conditional-square 3\n3",
      "zh": "如果 x 是小于或等于 5 的正整数，则返回 x；否则，返回 x 的平方。\n示例：\n>>> conditional-square 3\n3",
      "fr": "Si x est un entier positif inférieur ou égal à 5, retourner x ; sinon, retourner le carré de x.\nExemple:\n>>> conditional-square 3\n3",
      "de": "Wenn x eine positive ganze Zahl kleiner oder gleich 5 ist, gib x zurück; andernfalls gib das Quadrat von x zurück.\nBeispiel:\n>>> conditional-square 3\n3",
      "ha": "Idan x lamba ce mai kyau ƙasa da ko daidai da 5, dawo da x; in ba haka ba, dawo da murabba'in x.\nMisali:\n>>> conditional-square 3\n3",
      "hi": "यदि x एक धनात्मक पूर्णांक है जो 5 से कम या उसके बराबर है, तो x लौटाएं; अन्यथा, x का वर्ग लौटाएं।  \nउदाहरण:  \n>>> conditional-square 3  \n3",
      "hu": "Ha x egy pozitív egész szám, amely kisebb vagy egyenlő 5-tel, akkor adja vissza x-et; ellenkező esetben adja vissza x négyzetét.\nPélda:\n>>> conditional-square 3\n3"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9713046633734138",
      "bn": "0.9719245887926238",
      "bg": "0.9845409947048167",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9829360612260548",
      "hi": "0.9719245887926238",
      "hu": "0.9719245887926238"
    }
  },
  {
    "task_id": "Common Lisp/14",
    "prompt": {
      "en": "(defun lines-from-file (filename)\n;; Read each line from the file and return them as a string list.",
      "sq": "(defun lines-from-file (filename)\n;; Lexoni çdo rresht nga skedari dhe kthejini ato si një listë me vargje.",
      "hy": "(defun lines-from-file (filename)\n;; Կարդացեք ֆայլի յուրաքանչյուր տողը և վերադարձեք դրանք որպես տողերի ցուցակ։",
      "bn": "(defun lines-from-file (filename)\n;; ফাইল থেকে প্রতিটি লাইন পড়ুন এবং সেগুলিকে একটি স্ট্রিং তালিকা হিসাবে ফেরত দিন।",
      "bg": "(defun lines-from-file (filename)\n;; Прочетете всеки ред от файла и ги върнете като списък от низове.",
      "zh": "(defun lines-from-file (filename)\n;; 从文件中读取每一行并将它们作为字符串列表返回。",
      "fr": "(defun lines-from-file (filename)\n;; Lire chaque ligne du fichier et les retourner sous forme de liste de chaînes.",
      "de": "(defun lines-from-file (filename)\n;; Lies jede Zeile aus der Datei und gib sie als Stringliste zurück.",
      "ha": "(defun lines-from-file (filename)\n;; Karanta kowane layi daga fayil ɗin kuma mayar da su azaman jerin kirtani.",
      "hi": "(defun lines-from-file (filename)\n;; फ़ाइल से प्रत्येक पंक्ति पढ़ें और उन्हें एक स्ट्रिंग सूची के रूप में लौटाएं।",
      "hu": "(defun lines-from-file (filename)\n;; Olvassa be a fájl minden sorát, és adja vissza őket egy karakterlánc listaként."
    },
    "prompt_bertscore": {
      "sq": "0.9849328924465985",
      "hy": "0.9754145245874067",
      "bn": "0.9849328924465985",
      "bg": "0.9849328924465985",
      "zh": "0.9849328924465985",
      "fr": "0.9849328924465985",
      "de": "0.9798384204338157",
      "ha": "0.9849328924465985",
      "hi": "0.9849328924465985",
      "hu": "0.9554329041464401"
    },
    "canonical_solution": "(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))",
    "instruction": {
      "en": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nՏվեք Common Lisp կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nПредоставете кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\n请用中文为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nलिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9204082104281772",
      "bn": "0.8685243658588161",
      "bg": "0.8458594476004492",
      "zh": "0.8524768187446264",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9543551356989448",
      "hi": "0.9012364060506898",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun check-lines-from-file ()\n(let ((lines (lines-from-file \"../data/Common Lisp/file.txt\")))\n(assert (equal (first lines) \"First line of the file\"))\n(assert (equal (second lines) \"Second line of the file\"))))\n\n(check-lines-from-file)",
    "entry_point": "lines-from-file",
    "signature": "(defun lines-from-file (filename)",
    "docstring": {
      "en": "Read each line from the file and return them as a string list.",
      "sq": "Lexoni secilën rresht nga skedari dhe kthejini ato si një listë vargjesh.",
      "hy": "Ֆայլից կարդացեք յուրաքանչյուր տողը և վերադարձեք դրանք որպես տողերի ցուցակ։",
      "bn": "ফাইল থেকে প্রতিটি লাইন পড়ুন এবং সেগুলিকে একটি স্ট্রিং তালিকা হিসাবে ফেরত দিন।",
      "bg": "Прочетете всеки ред от файла и ги върнете като списък от низове.",
      "zh": "从文件中读取每一行，并将它们作为字符串列表返回。",
      "fr": "Lire chaque ligne du fichier et les retourner sous forme de liste de chaînes.",
      "de": "Lese jede Zeile aus der Datei und gib sie als String-Liste zurück.",
      "ha": "Read kowane layi daga fayil ɗin kuma dawo da su azaman jerin kirtani.",
      "hi": "फाइल से प्रत्येक पंक्ति पढ़ें और उन्हें एक स्ट्रिंग सूची के रूप में लौटाएं।",
      "hu": "Olvassa be a fájl minden sorát, és adja vissza őket karakterláncok listájaként."
    },
    "docstring_bertscore": {
      "sq": "0.9725437196903095",
      "hy": "0.8963920096876299",
      "bn": "0.9725437196903095",
      "bg": "0.9725437196903095",
      "zh": "0.9725437196903095",
      "fr": "0.9548777322314476",
      "de": "0.9649490870714406",
      "ha": "0.9725437196903095",
      "hi": "0.9725437196903095",
      "hu": "0.9548777322314476"
    }
  },
  {
    "task_id": "Common Lisp/15",
    "prompt": {
      "en": "(defun nondecreasing? (numbers)\n;; Check if the real number list is in non decreasing order.\n;; Example:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "sq": "(defun nondecreasing? (numbers)\n;; Kontrolloni nëse lista e numrave realë është në rend jo-zbritës.\n;; Shembull:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "hy": "(defun nondecreasing? (numbers)\n;; Ստուգել, արդյոք իրական թվերի ցանկը ոչ նվազող կարգով է:\n;; Օրինակ:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "bn": "(defun nondecreasing? (numbers)\n;; পরীক্ষা করুন যে বাস্তব সংখ্যার তালিকা অ-হ্রাসমান ক্রমে আছে কিনা।\n;; উদাহরণ:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "bg": "(defun nondecreasing? (numbers)\n;; Проверете дали списъкът от реални числа е в ненамаляващ ред.\n;; Пример:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "zh": "(defun nondecreasing? (numbers)\n;; 检查实数列表是否按非递减顺序排列。\n;; 例子:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "fr": "(defun nondecreasing? (numbers)\n;; Vérifie si la liste de nombres réels est dans un ordre non décroissant.\n;; Exemple:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "de": "(defun nondecreasing? (numbers)\n;; Überprüfen, ob die Liste der reellen Zahlen in nicht abnehmender Reihenfolge ist.\n;; Beispiel:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "ha": "(defun nondecreasing? (numbers)\n;; Duba idan jerin lambobin ainihi suna cikin tsari mai ƙaruwa ba tare da raguwa ba.\n;; Misali:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "hi": "(defun nondecreasing? (numbers)\n;; जाँचें कि वास्तविक संख्या सूची गैर-घटते क्रम में है या नहीं।\n;; उदाहरण:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "hu": "(defun nondecreasing? (numbers)\n;; Ellenőrzi, hogy a valós számok listája nem csökkenő sorrendben van-e.\n;; Példa:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t"
    },
    "prompt_bertscore": {
      "sq": "0.9662519037406484",
      "hy": "0.9594698680105931",
      "bn": "0.9662519037406484",
      "bg": "0.9662519037406484",
      "zh": "0.9601042934476186",
      "fr": "0.9586489286457759",
      "de": "0.9662519037406484",
      "ha": "0.962731577497567",
      "hi": "0.9662519037406484",
      "hu": "0.959195559454384"
    },
    "canonical_solution": "(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))",
    "instruction": {
      "en": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nՏվեք Common Lisp կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (docstring) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nДайте кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9518458380953311",
      "bn": "0.8727891587700162",
      "bg": "0.8335809119663965",
      "zh": "0.88778376623434",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-nondecreasing? ()\n(assert (equal (nondecreasing? '(1.0 2.0 2.0 3.0 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 3.0 3.9 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 1.0 4.0 5.0)) nil))\n(assert (equal (nondecreasing? '(5.0 5.0 5.0 5.0)) t))\n(assert (equal (nondecreasing? '(1.0)) t))\n(assert (equal (nondecreasing? '()) t)))\n\n(check-nondecreasing?)",
    "entry_point": "nondecreasing?",
    "signature": "(defun nondecreasing? (numbers)",
    "docstring": {
      "en": "Check if the real number list is in non decreasing order.\nExample:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "sq": "Kontrolloni nëse lista e numrave realë është në rend jo-zbritës. Shembull: >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0) t",
      "hy": "Ստուգել, արդյոք իրական թվերի ցանկը ոչ նվազող կարգով է:\nՕրինակ:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "bn": "বাস্তব সংখ্যা তালিকা অ-হ্রাসমান ক্রমে আছে কিনা পরীক্ষা করুন।  \nউদাহরণ:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "bg": "Проверете дали списъкът от реални числа е в ненамаляващ ред.\nПример:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "zh": "检查实数列表是否为非递减顺序。  \n示例：  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "fr": "Vérifiez si la liste de nombres réels est dans un ordre non décroissant.\nExemple:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "de": "Überprüfen Sie, ob die Liste der reellen Zahlen in nicht absteigender Reihenfolge ist.  \nBeispiel:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "ha": "Duba idan jerin lambobin gaske suna cikin tsari mara raguwa. Misali: >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0) t",
      "hi": "गैर-घटते क्रम में वास्तविक संख्या सूची की जाँच करें।  \nउदाहरण:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "hu": "Ellenőrizze, hogy a valós számok listája nem csökkenő sorrendben van-e.  \nPélda:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt"
    },
    "docstring_bertscore": {
      "sq": "0.9575278587752151",
      "hy": "0.9575278587752151",
      "bn": "0.9575278587752151",
      "bg": "0.9575278587752151",
      "zh": "0.9522458796827353",
      "fr": "0.9508868506156946",
      "de": "0.9575278587752151",
      "ha": "0.9522458796827353",
      "hi": "0.9447424184087614",
      "hu": "0.9575278587752151"
    }
  },
  {
    "task_id": "Common Lisp/16",
    "prompt": {
      "en": "(defun make-change (cents)\n;; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\n;; Example:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "sq": "(defun make-change (cents)\n;; Përkufizo një funksion që pranon një numër të plotë cents dhe kthen katër vlera, duke treguar numrat si 25-, 10-, 5-, 1-, duke përdorur numrin minimal të monedhave. (Përkthim: 25- është 25 cent, e kështu me radhë)\n;; Shembull:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "hy": "(defun make-change (cents)\n;; Սահմանել ֆունկցիա, որը ընդունում է ամբողջ թիվ cents և վերադարձնում է չորս արժեք, ցուցադրելով թվերը որպես 25-, 10-, 5-, 1-, օգտագործելով մետաղադրամների նվազագույն քանակը։ (Թարգմանություն՝ 25- ը 25 ցենտ է, և այսպես շարունակ)\n;; Օրինակ:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "bn": "(defun make-change (cents)\n;; একটি ফাংশন সংজ্ঞায়িত করুন যা একটি পূর্ণসংখ্যা cents গ্রহণ করে এবং চারটি মান ফেরত দেয়, সংখ্যাগুলি 25-, 10-, 5-, 1- হিসাবে প্রদর্শন করে, সর্বনিম্ন সংখ্যক কয়েন ব্যবহার করে। (অনুবাদ: 25- হল 25 সেন্ট, এবং এভাবে চলতে থাকে)\n;; উদাহরণ:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "bg": "(defun make-change (cents)\n;; Дефинирайте функция, която приема цяло число cents и връща четири стойности, показвайки числата като 25-, 10-, 5-, 1-, използвайки минималния брой монети. (Превод: 25- е 25 цента и така нататък)\n;; Пример:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "zh": "(defun make-change (cents)\n;; 定义一个函数，接受一个整数cents并返回四个值，显示为25-，10-，5-，1-，使用最少数量的硬币。（翻译：25-是25美分，依此类推）\n;; 示例：\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "fr": "(defun make-change (cents)\n;; Définir une fonction qui accepte un entier cents et retourne quatre valeurs, affichant les nombres comme 25-, 10-, 5-, 1-, en utilisant le nombre minimum de pièces. (Traduction : 25- est 25 cents, et ainsi de suite)\n;; Exemple:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "de": "(defun make-change (cents)\n;; Definiere eine Funktion, die eine ganze Zahl cents akzeptiert und vier Werte zurückgibt, wobei die Zahlen als 25-, 10-, 5-, 1- angezeigt werden, unter Verwendung der minimalen Anzahl von Münzen. (Übersetzung: 25- sind 25 Cent, und so weiter)\n;; Beispiel:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "ha": "(defun make-change (cents)\n;; Ƙirƙiri wata aiki da ke karɓar cikakken lamba cents kuma tana dawowa da ƙima huɗu, tana nuna lambobin azaman 25-, 10-, 5-, 1-, ta amfani da mafi ƙarancin adadin tsabar kuɗi. (Fassara: 25- yana nufin 25 cents, da sauransu)\n;; Misali:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "hi": "(defun make-change (cents)\n;; एक फ़ंक्शन परिभाषित करें जो एक पूर्णांक cents को स्वीकार करता है और चार मान लौटाता है, 25-, 10-, 5-, 1- के रूप में संख्याएँ प्रदर्शित करते हुए, सिक्कों की न्यूनतम संख्या का उपयोग करते हुए। (अनुवाद: 25- का अर्थ है 25 सेंट, और इसी प्रकार)\n;; उदाहरण:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "hu": "(defun make-change (cents)\n;; Definiálj egy függvényt, amely egy egész számot, centet fogad, és négy értéket ad vissza, megjelenítve a számokat 25-, 10-, 5-, 1-, a lehető legkevesebb érme felhasználásával. (Fordítás: 25- az 25 cent, és így tovább)\n;; Példa:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3"
    },
    "prompt_bertscore": {
      "sq": "0.9939969926243636",
      "hy": "0.9934654577247143",
      "bn": "0.9797573792383535",
      "bg": "0.9903578854134234",
      "zh": "0.9719019449291858",
      "fr": "0.999999801369619",
      "de": "0.9842392751560247",
      "ha": "0.9640951750633715",
      "hi": "0.9836737744612184",
      "hu": "0.948651662937909"
    },
    "canonical_solution": "(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))",
    "instruction": {
      "en": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\n请用不超过500个字符的中文为以下Common Lisp代码提供简明的自然语言描述（文档字符串）。",
      "fr": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8531444154552847",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8911982224843297",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun check-make-change ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check-make-change)",
    "entry_point": "make-change",
    "signature": "(defun make-change (cents)",
    "docstring": {
      "en": "Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "sq": "Përcaktoni një funksion që pranon një numër të plotë cent dhe kthen katër vlera, duke shfaqur numrat si 25-, 10-, 5-, 1-, duke përdorur numrin minimal të monedhave. (Përkthimi: 25- është 25 cent, e kështu me radhë)\nShembull:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hy": "Սահմանեք ֆունկցիա, որը ընդունում է ամբողջ թիվ cents և վերադարձնում է չորս արժեքներ՝ ցուցադրելով թվերը որպես 25-, 10-, 5-, 1-, օգտագործելով մետաղադրամների նվազագույն քանակը։ (Թարգմանություն՝ 25- նշանակում է 25 ցենտ, և այդպես շարունակ)\n\nՕրինակ:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "bn": "একটি ফাংশন সংজ্ঞায়িত করুন যা একটি পূর্ণসংখ্যা cents গ্রহণ করে এবং চারটি মান ফেরত দেয়, সংখ্যা গুলি 25-, 10-, 5-, 1- হিসাবে প্রদর্শন করে, সর্বনিম্ন সংখ্যক কয়েন ব্যবহার করে। (অনুবাদ: 25- হল 25 সেন্ট, এবং এভাবে চলতে থাকে)\nউদাহরণ:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "bg": "Определете функция, която приема цяло число cents и връща четири стойности, показвайки числата като 25-, 10-, 5-, 1-, използвайки минималния брой монети. (Превод: 25- е 25 цента, и така нататък)\nПример:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "zh": "定义一个函数，该函数接受一个整数cents并返回四个值，显示为25-，10-，5-，1-的数量，使用最少数量的硬币。（翻译：25-是25美分，以此类推）\n\n示例：\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "fr": "Définir une fonction qui accepte un entier cents et retourne quatre valeurs, affichant les nombres comme 25-, 10-, 5-, 1-, en utilisant le nombre minimum de pièces. (Traduction : 25- est 25 cents, et ainsi de suite)\nExemple:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "de": "Definieren Sie eine Funktion, die eine ganze Zahl in Cents akzeptiert und vier Werte zurückgibt, wobei die Zahlen als 25-, 10-, 5-, 1- angezeigt werden, unter Verwendung der minimalen Anzahl von Münzen. (Übersetzung: 25- sind 25 Cents, und so weiter)\nBeispiel:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "ha": "Ƙayyade wata aiki wadda ke karɓar cikakken lamba cents kuma tana mayar da ƙima huɗu, tana nuna lambobin a matsayin 25-, 10-, 5-, 1-, ta amfani da mafi ƙarancin adadin tsabar kuɗi. (Fassara: 25- yana nufin 25 cents, da sauransu)\n\nMisali:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hi": "एक फ़ंक्शन परिभाषित करें जो एक पूर्णांक सेंट्स को स्वीकार करता है और चार मान लौटाता है, संख्याओं को 25-, 10-, 5-, 1- के रूप में प्रदर्शित करता है, सिक्कों की न्यूनतम संख्या का उपयोग करते हुए। (अनुवाद: 25- का अर्थ है 25 सेंट्स, और इसी तरह)\n\nउदाहरण:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hu": "Határozz meg egy függvényt, amely elfogad egy egész számot (cents) és négy értéket ad vissza, megjelenítve a számokat 25-, 10-, 5-, 1-, a lehető legkevesebb érme használatával. (Fordítás: 25- az 25 cent, és így tovább)\nPélda:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3"
    },
    "docstring_bertscore": {
      "sq": "0.977044286863798",
      "hy": "0.9920772299916614",
      "bn": "0.9930179434762426",
      "bg": "0.9930179434762426",
      "zh": "0.9619610902495327",
      "fr": "1",
      "de": "0.9743828383883115",
      "ha": "0.9288019330699495",
      "hi": "0.98785633439467",
      "hu": "0.9469027224328967"
    }
  },
  {
    "task_id": "Common Lisp/17",
    "prompt": {
      "en": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\n;; Example:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "sq": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Përkufizo një funksion që pranon 8 numra realë që përfaqësojnë pikat fundore të dy segmenteve të vijës në hapësirën dy-dimensionale. Nëse segmentet e vijës nuk ndërpriten, kthe false, ose kthe dy vlera që përfaqësojnë koordinatat x dhe y të pikës së ndërprerjes\n;; Shembull:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "hy": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Սահմանել ֆունկցիա, որը ընդունում է 8 իրական թվեր, որոնք ներկայացնում են երկու գծային հատվածների վերջնակետերը երկչափ տարածությունում։ Եթե գծային հատվածները չեն հատվում, վերադարձնել false, կամ վերադարձնել երկու արժեք, որոնք ներկայացնում են հատման կետի x և y կոորդինատները\n;; Օրինակ:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "bn": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; দুটি রেখাংশের প্রান্তবিন্দু উপস্থাপনকারী ৮টি বাস্তব সংখ্যা গ্রহণ করে এমন একটি ফাংশন সংজ্ঞায়িত করুন। যদি রেখাংশগুলি ছেদ না করে, তবে false ফেরত দিন, অথবা ছেদ বিন্দুর x এবং y স্থানাঙ্ক উপস্থাপনকারী দুটি মান ফেরত দিন\n;; উদাহরণ:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "bg": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Дефинирайте функция, която приема 8 реални числа, представляващи крайните точки на два линейни сегмента в двумерното пространство. Ако линейните сегменти не се пресичат, върнете false, или върнете две стойности, представляващи x и y координатите на точката на пресичане\n;; Пример:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "zh": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; 定义一个函数，该函数接受 8 个实数，表示二维空间中两条线段的端点。如果线段不相交，则返回 false，否则返回两个值，表示交点的 x 和 y 坐标\n;; 示例:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "fr": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Définir une fonction qui accepte 8 nombres réels représentant les extrémités de deux segments de ligne dans un espace bidimensionnel. Si les segments de ligne ne se croisent pas, retourner faux, ou retourner deux valeurs représentant les coordonnées x et y du point d'intersection\n;; Exemple:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "de": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Definiere eine Funktion, die 8 reelle Zahlen akzeptiert, die die Endpunkte von zwei Liniensegmenten im zweidimensionalen Raum darstellen. Wenn die Liniensegmente sich nicht schneiden, gib false zurück, oder gib zwei Werte zurück, die die x- und y-Koordinaten des Schnittpunkts darstellen\n;; Beispiel:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "ha": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Ƙayyade wani aiki wanda ke karɓar lambobi 8 na ainihi waɗanda ke wakiltar ƙarshen layuka guda biyu a cikin sarari mai girma biyu. Idan layukan ba su haɗu ba, dawo da ƙarya, ko kuma dawo da ƙimar x da y waɗanda ke wakiltar maɓuɓɓugar haɗuwar\n;; Misali:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "hi": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; एक फ़ंक्शन परिभाषित करें जो दो-आयामी स्थान में दो रेखा खंडों के अंत बिंदुओं का प्रतिनिधित्व करने वाले 8 वास्तविक संख्याएँ स्वीकार करता है। यदि रेखा खंड प्रतिच्छेद नहीं करते हैं, तो false लौटाएँ, या प्रतिच्छेदन बिंदु के x और y निर्देशांक का प्रतिनिधित्व करने वाले दो मान लौटाएँ\n;; उदाहरण:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "hu": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Definiálj egy függvényt, amely 8 valós számot fogad el, amelyek két vonalszakasz végpontjait képviselik kétdimenziós térben. Ha a vonalszakaszok nem metszik egymást, adjon vissza hamisat, vagy adjon vissza két értéket, amelyek a metszéspont x és y koordinátáit képviselik\n;; Példa:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5"
    },
    "prompt_bertscore": {
      "sq": "0.9937729375545562",
      "hy": "0.9871565595622841",
      "bn": "0.9609458903720633",
      "bg": "0.9967023384140588",
      "zh": "0.97192578057491",
      "fr": "0.996214104937475",
      "de": "0.999999801369619",
      "ha": "0.9648003129160454",
      "hi": "0.9893718842019662",
      "hu": "0.999999801369619"
    },
    "canonical_solution": "(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))",
    "instruction": {
      "en": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\n请提供一段中文的简洁自然语言描述（文档字符串），用于描述这段Common Lisp代码，字数不超过500个字符。",
      "fr": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar Common Lisp a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nलिखे गए Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.918271940680147",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8547370338504224",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9202179225231458",
      "hi": "0.9003421720752707",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun check-segments-intersect? ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check-segments-intersect?)",
    "entry_point": "segments-intersect?",
    "signature": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)",
    "docstring": {
      "en": "Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "sq": "Përcaktoni një funksion që pranon 8 numra realë që përfaqësojnë pikat fundore të dy segmenteve të vijës në hapësirën dy-dimensionale. Nëse segmentet e vijës nuk kryqëzohen, kthe false, ose kthe dy vlera që përfaqësojnë koordinatat x dhe y të pikës së kryqëzimit\nShembull:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hy": "Սահմանեք ֆունկցիա, որը ընդունում է 8 իրական թվեր, որոնք ներկայացնում են երկու գծային հատվածների վերջնակետերը երկչափ տարածությունում։ Եթե գծային հատվածները չեն հատվում, վերադարձնել false, կամ վերադարձնել երկու արժեք, որոնք ներկայացնում են հատման կետի x և y կոորդինատները։\nՕրինակ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "bn": "একটি ফাংশন সংজ্ঞায়িত করুন যা দ্বিমাত্রিক স্থানে দুটি রেখাংশের প্রান্তবিন্দু উপস্থাপনকারী ৮টি বাস্তব সংখ্যা গ্রহণ করে। যদি রেখাংশগুলি ছেদ না করে, তাহলে false ফেরত দিন, অথবা ছেদ বিন্দুর x এবং y স্থানাঙ্ক উপস্থাপনকারী দুটি মান ফেরত দিন।\n\nউদাহরণ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "bg": "Определете функция, която приема 8 реални числа, представляващи краищата на два линейни сегмента в двумерно пространство. Ако линейните сегменти не се пресичат, върнете false, или върнете две стойности, представляващи x и y координатите на точката на пресичане.\n\nПример:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "zh": "定义一个函数，该函数接受 8 个实数，表示二维空间中两条线段的端点。如果线段不相交，则返回 false；如果相交，则返回两个值，表示交点的 x 和 y 坐标。\n\n示例：\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "fr": "Définir une fonction qui accepte 8 nombres réels représentant les extrémités de deux segments de ligne dans un espace bidimensionnel. Si les segments de ligne ne se croisent pas, retourner faux, ou retourner deux valeurs représentant les coordonnées x et y du point d'intersection\nExemple:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "de": "Definieren Sie eine Funktion, die 8 reelle Zahlen akzeptiert, die die Endpunkte von zwei Liniensegmenten im zweidimensionalen Raum darstellen. Wenn sich die Liniensegmente nicht schneiden, geben Sie false zurück, oder geben Sie zwei Werte zurück, die die x- und y-Koordinaten des Schnittpunkts darstellen.\nBeispiel:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "ha": "Ƙayyade wata aiki da ke karɓar lambobi 8 na ainihi da ke wakiltar ƙarshen layuka biyu a cikin sararin samaniya mai girma biyu. Idan layukan ba su haɗu ba, dawo da ƙarya, ko kuma dawo da ƙimar x da y da ke wakiltar wurin haɗuwar su\nMisali:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hi": "एक फ़ंक्शन परिभाषित करें जो दो-आयामी स्थान में दो रेखा खंडों के सिरों का प्रतिनिधित्व करने वाले 8 वास्तविक संख्याएँ स्वीकार करता है। यदि रेखा खंड एक-दूसरे को प्रतिच्छेदित नहीं करते हैं, तो false लौटाएँ, या प्रतिच्छेदन बिंदु के x और y निर्देशांक का प्रतिनिधित्व करने वाले दो मान लौटाएँ।\n\nउदाहरण:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hu": "Határozz meg egy függvényt, amely 8 valós számot fogad el, amelyek két vonalszakasz végpontjait képviselik kétdimenziós térben. Ha a vonalszakaszok nem metszik egymást, adjon vissza hamisat, vagy adjon vissza két értéket, amelyek a metszéspont x és y koordinátáit képviselik.\nPélda:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5"
    },
    "docstring_bertscore": {
      "sq": "0.99496174038505",
      "hy": "0.9824492181621383",
      "bn": "0.9899016314281863",
      "bg": "0.9824492181621383",
      "zh": "0.9504536377546575",
      "fr": "0.9945473974102113",
      "de": "0.99496174038505",
      "ha": "0.9504262267620747",
      "hi": "0.9875504436078764",
      "hu": "0.9875504436078764"
    }
  },
  {
    "task_id": "Common Lisp/18",
    "prompt": {
      "en": "(defun quicksort (list)\n;; Quickly sort the list\n;; Example:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "sq": "(defun quicksort (list)\n;; Shpejt rendit listën\n;; Shembull:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "hy": "(defun quicksort (list)\n;; Արագ տեսակավորել ցուցակը\n;; Օրինակ:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "bn": "(defun quicksort (list)\n;; তালিকাটি দ্রুত সাজান\n;; উদাহরণ:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "bg": "(defun quicksort (list)\n;; Бързо сортиране на списъка\n;; Пример:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "zh": "(defun quicksort (list)\n;; 快速排序列表\n;; 示例:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "fr": "(defun quicksort (list)\n;; Trier rapidement la liste\n;; Exemple:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "de": "(defun quicksort (list)\n;; Schnelles Sortieren der Liste\n;; Beispiel:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "ha": "(defun quicksort (list)\n;; Saurin sauri na jerin\n;; Misali:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "hi": "(defun quicksort (list)\n;; सूची को तेजी से सॉर्ट करें\n;; उदाहरण:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "hu": "(defun quicksort (list)\n;; Gyorsan rendezze a listát\n;; Példa:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9"
    },
    "prompt_bertscore": {
      "sq": "0.9829579105679687",
      "hy": "0.9859099552909092",
      "bn": "0.9657100400611852",
      "bg": "0.9680747347474056",
      "zh": "0.9499795070351272",
      "fr": "0.9859099552909092",
      "de": "0.9680747347474056",
      "ha": "0.9666296987253767",
      "hi": "0.9859099552909092",
      "hu": "0.9859099552909092"
    },
    "canonical_solution": "(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))",
    "instruction": {
      "en": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nPërshkruani shkurtimisht në gjuhë natyrore (docstring) kodin Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\n请用不超过500个字符的中文，为以下Common Lisp代码提供简明的自然语言描述（文档字符串）。",
      "fr": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar Common Lisp cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.8937351297109072",
      "hy": "0.9305089625645633",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8751743123854832",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9140675314047815",
      "hi": "0.8808811618629965",
      "hu": "0.9443179452844898"
    },
    "level": "",
    "test": "(defun check-quicksort ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check-quicksort)",
    "entry_point": "quicksort",
    "signature": "(defun quicksort (list)",
    "docstring": {
      "en": "Quickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "sq": "Shpejt rendit listën\nShembull:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "hy": "Արագ տեսակավորել ցուցակը  \nՕրինակ:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9",
      "bn": "তালিকাটি দ্রুত সাজান\nউদাহরণ:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "bg": "Бързо сортиране на списъка  \nПример:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "zh": "快速排序列表  \n示例:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9",
      "fr": "Trier rapidement la liste  \nExemple:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "de": "Schnell die Liste sortieren  \nBeispiel:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "ha": "Saurin jera jerin abubuwa\n\nMisali:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "hi": "सूची को जल्दी से छांटें  \nउदाहरण:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "hu": "Gyorsan rendezze a listát  \nPélda:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9831472053210949",
      "bg": "0.9320469576049165",
      "zh": "0.9522665372423629",
      "fr": "0.9572060775579385",
      "de": "0.9773452118910658",
      "ha": "0.9688033109850415",
      "hi": "0.9773452118910658",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/19",
    "prompt": {
      "en": "(defun enqueue-front (object queue)\n;; Define a function that accepts two input parameters, object and queue, and can insert the object into the beginning of the queue\n;; Example:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "sq": "(defun enqueue-front (object queue)\n;; Përkufizo një funksion që pranon dy parametra hyrës, object dhe queue, dhe mund të fusë objektin në fillim të queue\n;; Shembull:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "hy": "(defun enqueue-front (object queue)\n;; Սահմանել ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ object և queue, և կարող է տեղադրել object-ը queue-ի սկզբում\n;; Օրինակ:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "bn": "(defun enqueue-front (object queue)\n;; একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, object এবং queue, এবং queue এর শুরুতে object সন্নিবেশ করতে পারে\n;; উদাহরণ:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "bg": "(defun enqueue-front (object queue)\n;; Дефинирайте функция, която приема два входни параметъра, object и queue, и може да вмъкне обекта в началото на опашката\n;; Пример:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "zh": "(defun enqueue-front (object queue)\n;; 定义一个函数，接受两个输入参数，object 和 queue，可以将 object 插入到 queue 的开头\n;; 示例:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "fr": "(defun enqueue-front (object queue)\n;; Définir une fonction qui accepte deux paramètres d'entrée, object et queue, et peut insérer l'objet au début de la queue\n;; Exemple:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "de": "(defun enqueue-front (object queue)\n;; Definieren Sie eine Funktion, die zwei Eingabeparameter, object und queue, akzeptiert und das Objekt am Anfang der Warteschlange einfügen kann\n;; Beispiel:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "ha": "(defun enqueue-front (object queue)\n;; Ƙirƙiri wata aiki da ke karɓar shigarwa guda biyu, abu da layi, kuma zai iya saka abu a farkon layin\n;; Misali:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "hi": "(defun enqueue-front (object queue)\n;; एक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर स्वीकार करता है, object और queue, और object को queue की शुरुआत में डाल सकता है\n;; उदाहरण:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "hu": "(defun enqueue-front (object queue)\n;; Definiálj egy függvényt, amely két bemeneti paramétert fogad, object és queue, és képes az objektumot a sor elejére beszúrni\n;; Példa:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4"
    },
    "prompt_bertscore": {
      "sq": "0.993475587874147",
      "hy": "0.980642674846626",
      "bn": "0.9905797555490394",
      "bg": "0.9802634894492304",
      "zh": "0.9760002855810787",
      "fr": "0.993475587874147",
      "de": "0.9830695408421103",
      "ha": "0.9577427768474948",
      "hi": "0.993475587874147",
      "hu": "0.9718743353062219"
    },
    "canonical_solution": "(cons object queue))",
    "instruction": {
      "en": "(defun enqueue-front (object queue)\n(cons object queue))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun enqueue-front (object queue)\n(cons object queue))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun enqueue-front (object queue)\n(cons object queue))\n\nՏվեք Common Lisp կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun enqueue-front (object queue)\n(cons object queue))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun enqueue-front (object queue)\n(cons object queue))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun enqueue-front (object queue)\n(cons object queue))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，限制在最多500个字符以内。",
      "fr": "(defun enqueue-front (object queue)\n(cons object queue))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun enqueue-front (object queue)\n(cons object queue))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun enqueue-front (object queue)\n(cons object queue))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun enqueue-front (object queue)\n(cons object queue))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "(defun enqueue-front (object queue)\n(cons object queue))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9671614322554071",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8872859984994665",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-enqueue-front ()\n(let ((queue '(2 3 4)))\n(setq queue (enqueue-front 1 queue))\n(assert (equal queue '(1 2 3 4))))\n(let ((queue '()))\n(setq queue (enqueue-front 'a queue))\n(assert (equal queue '(a)))))\n\n(check-enqueue-front)",
    "entry_point": "enqueue-front",
    "signature": "(defun enqueue-front (object queue)",
    "docstring": {
      "en": "Define a function that accepts two input parameters, object and queue, and can insert the object into the beginning of the queue\nExample:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "sq": "Përcaktoni një funksion që pranon dy parametra hyrës, objektin dhe radhën, dhe mund të fusë objektin në fillim të radhës\nShembull:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "hy": "Սահմանեք ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ օբյեկտ և հերթ, և կարող է օբյեկտը տեղադրել հերթի սկզբում։\nՕրինակ:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "bn": "একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, অবজেক্ট এবং কিউ, এবং কিউয়ের শুরুতে অবজেক্টটি সন্নিবেশ করতে পারে\n\nউদাহরণ:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "bg": "Дефинирайте функция, която приема два входни параметъра, object и queue, и може да вмъкне object в началото на queue\nПример:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "zh": "定义一个函数，该函数接受两个输入参数，object 和 queue，并可以将 object 插入到 queue 的开头  \n示例：  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "fr": "Définir une fonction qui accepte deux paramètres d'entrée, objet et queue, et peut insérer l'objet au début de la queue\nExemple:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "de": "Definieren Sie eine Funktion, die zwei Eingabeparameter akzeptiert, Objekt und Warteschlange, und das Objekt am Anfang der Warteschlange einfügen kann\nBeispiel:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "ha": "Ƙirƙiri wata aiki da ke karɓar abubuwa biyu na shigarwa, object da queue, kuma za ta iya saka object ɗin a farkon queue\nMisali:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "hi": "एक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर स्वीकार करता है, object और queue, और object को queue की शुरुआत में डाल सकता है।\nउदाहरण:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "hu": "Definiáljon egy függvényt, amely két bemeneti paramétert fogad, objektumot és sort, és képes az objektumot a sor elejére beszúrni.\nPélda:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4"
    },
    "docstring_bertscore": {
      "sq": "0.978484953017444",
      "hy": "0.9381379582393513",
      "bn": "0.9747395785526501",
      "bg": "1",
      "zh": "0.9787451588165997",
      "fr": "0.9918849557828197",
      "de": "1",
      "ha": "0.9402460224732746",
      "hi": "0.9918849557828197",
      "hu": "0.9478579359352935"
    }
  },
  {
    "task_id": "Common Lisp/20",
    "prompt": {
      "en": "(defun move-first-instance-to-front (object queue)\n;; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\n;; Example:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "sq": "(defun move-first-instance-to-front (object queue)\n;; Përkufizo një funksion që merr dy parametra hyrës, object dhe queue, dhe mund të zhvendosë në mënyrë destruktive instancën e parë të object (eql ekuivalentisht) në fillim të queue\n;; Shembull:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "hy": "(defun move-first-instance-to-front (object queue)\n;; Սահմանել ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ object և queue, և կարող է կործանարար կերպով տեղափոխել object-ի առաջին օրինակը (eql համարժեքորեն) դեպի queue-ի սկիզբ\n;; Օրինակ:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "bn": "(defun move-first-instance-to-front (object queue)\n;; একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, object এবং queue, এবং queue এর শুরুতে object এর প্রথম instance (eql সমতুল্য) ধ্বংসাত্মকভাবে সরাতে পারে\n;; উদাহরণ:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "bg": "(defun move-first-instance-to-front (object queue)\n;; Дефинирайте функция, която приема два входни параметъра, object и queue, и може разрушително да премести първия екземпляр на object (еквивалентно на eql) в началото на queue\n;; Пример:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "zh": "(defun move-first-instance-to-front (object queue)\n;; 定义一个函数，该函数接受两个输入参数，object 和 queue，并且可以破坏性地将 object 的第一个实例（等价于 eql）移动到队列的开头\n;; 例子:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "fr": "(defun move-first-instance-to-front (object queue)\n;; Définir une fonction qui prend deux paramètres d'entrée, object et queue, et peut déplacer de manière destructive la première instance de object (équivalent eql) au début de la queue\n;; Exemple:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "de": "(defun move-first-instance-to-front (object queue)\n;; Definiere eine Funktion, die zwei Eingabeparameter, object und queue, übernimmt und die erste Instanz von object (äquivalent zu eql) destruktiv an den Anfang der queue verschieben kann\n;; Beispiel:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "ha": "(defun move-first-instance-to-front (object queue)\n;; Ƙirƙiri wata aiki da ke ɗaukar shigarwa guda biyu, object da queue, kuma zai iya motsa farkon samfurin object (eql daidai) zuwa farkon queue\n;; Misali:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "hi": "(defun move-first-instance-to-front (object queue)\n;; एक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर लेता है, object और queue, और queue की शुरुआत में object के पहले instance (eql के समकक्ष) को विनाशकारी रूप से स्थानांतरित कर सकता है\n;; उदाहरण:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "hu": "(defun move-first-instance-to-front (object queue)\n;; Definiálj egy függvényt, amely két bemeneti paramétert vesz, object és queue, és képes az object első előfordulását (eql ekvivalensen) romboló módon a queue elejére mozgatni\n;; Példa:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d"
    },
    "prompt_bertscore": {
      "sq": "0.9874713887162244",
      "hy": "0.980147489306706",
      "bn": "0.9769974100938738",
      "bg": "0.9683037555767388",
      "zh": "0.9663456572804968",
      "fr": "0.9825948142314369",
      "de": "0.9708039161828249",
      "ha": "0.9377363276088988",
      "hi": "0.9718320270350614",
      "hu": "0.9620606040704311"
    },
    "canonical_solution": "(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))",
    "instruction": {
      "en": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nՏվեք Common Lisp կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\n提供一段简洁的自然语言描述（文档字符串），用中文描述这段Common Lisp代码，限制在500个字符以内。",
      "fr": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nBa da takaitaccen bayani a cikin harshen halitta (docstring) na lambar Common Lisp a Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9671614322554071",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.9041548822392355",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.8898221112045199",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-move-first-instance-to-front ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check-move-first-instance-to-front)",
    "entry_point": "move-first-instance-to-front",
    "signature": "(defun move-first-instance-to-front (object queue)",
    "docstring": {
      "en": "Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "sq": "Përcaktoni një funksion që merr dy parametra hyrës, objektin dhe radhën, dhe mund të zhvendosë në mënyrë destruktive instancën e parë të objektit (ekuivalent me eql) në fillim të radhës.\nShembull:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "hy": "Սահմանեք ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ օբյեկտ և հերթ, և կարող է կործանարար կերպով տեղափոխել օբյեկտի առաջին օրինակը (հավասարապես eql) հերթի սկիզբ:\nՕրինակ:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "bn": "একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, object এবং queue, এবং queue-এর শুরুতে object-এর প্রথম instance (eql সমতুল্য) ধ্বংসাত্মকভাবে সরাতে পারে।\n\nউদাহরণ:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "bg": "Определете функция, която приема два входни параметъра, обект и опашка, и може разрушително да премести първия екземпляр на обекта (еквивалентен на eql) в началото на опашката.\nПример:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "zh": "定义一个函数，该函数接受两个输入参数，object 和 queue，并且可以破坏性地将 object 的第一个实例（等价于 eql）移动到队列的开头。\n示例：\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "fr": "Définir une fonction qui prend deux paramètres d'entrée, objet et queue, et peut déplacer de manière destructive la première instance de l'objet (équivalent eql) au début de la queue.\nExemple:\n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d",
      "de": "Definieren Sie eine Funktion, die zwei Eingabeparameter, object und queue, übernimmt und die erste Instanz von object (äquivalent zu eql) destruktiv an den Anfang der queue verschieben kann.\nBeispiel:\n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d",
      "ha": "Ƙirƙiri wata aiki da ke ɗaukar sigogi biyu na shigarwa, object da queue, kuma zai iya motsa farkon samfurin object (eql daidai) zuwa farkon queue cikin lalacewa\nMisali:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "hi": "एक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर लेता है, object और queue, और object के पहले उदाहरण को (eql के समकक्ष) queue की शुरुआत में विनाशकारी रूप से स्थानांतरित कर सकता है।\n\nउदाहरण:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "hu": "Határozz meg egy függvényt, amely két bemeneti paramétert vesz, objektumot és sort, és képes az objektum első példányát (eql egyenértékűen) romboló módon a sor elejére mozgatni.\nPélda:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d"
    },
    "docstring_bertscore": {
      "sq": "0.9441387806807964",
      "hy": "0.958541469609636",
      "bn": "0.9548020540562733",
      "bg": "0.9332615823849448",
      "zh": "0.9441236847718377",
      "fr": "0.9589957372910629",
      "de": "0.9531403122885354",
      "ha": "1",
      "hi": "0.9384080955575588",
      "hu": "0.9587418876641003"
    }
  },
  {
    "task_id": "Common Lisp/21",
    "prompt": {
      "en": "(defun find-substring-index (haystack needle)\n;; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.\n;; Example:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Returns 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Returns -1",
      "sq": "(defun find-substring-index (haystack needle)\n;; Gjen ndodhjen e parë të nënvargut 'needle' brenda vargut 'haystack'.\n;; Kthen indeksin e karakterit të parë të ndodhjes së parë të 'needle'.\n;; Nëse 'needle' nuk është pjesë e 'haystack', kthen -1.\n;; Shembull:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Kthen 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Kthen -1",
      "hy": "(defun find-substring-index (haystack needle)\n;; Գտնում է 'needle' ենթատողի առաջին հանդիպումը 'haystack' տողի ներսում:\n;; Վերադարձնում է 'needle'-ի առաջին հանդիպման առաջին սիմվոլի ինդեքսը:\n;; Եթե 'needle'-ը 'haystack'-ի մաս չէ, վերադարձնում է -1:\n;; Օրինակ:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Վերադարձնում է 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Վերադարձնում է -1",
      "bn": "(defun find-substring-index (haystack needle)\n;; স্ট্রিং 'haystack' এর মধ্যে 'needle' সাবস্ট্রিংয়ের প্রথম উপস্থিতি খুঁজে বের করে।\n;; 'needle' এর প্রথম উপস্থিতির প্রথম অক্ষরের সূচক প্রদান করে।\n;; যদি 'needle' 'haystack' এর অংশ না হয়, তাহলে -1 প্রদান করে।\n;; উদাহরণ:\n;; (find-substring-index \"apple pie\" \"pie\") ;; 6 প্রদান করে\n;; (find-substring-index \"hello world\" \"bye\") ;; -1 প্রদান করে",
      "bg": "(defun find-substring-index (haystack needle)\n;; Намира първото появяване на подниз 'needle' в низа 'haystack'.\n;; Връща индекса на първия символ на първото появяване на 'needle'.\n;; Ако 'needle' не е част от 'haystack', връща -1.\n;; Пример:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Връща 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Връща -1",
      "zh": "(defun find-substring-index (haystack needle)\n;; 查找字符串 'haystack' 中子字符串 'needle' 的第一次出现。\n;; 返回 'needle' 第一次出现的第一个字符的索引。\n;; 如果 'needle' 不是 'haystack' 的一部分，则返回 -1。\n;; 示例:\n;; (find-substring-index \"apple pie\" \"pie\") ;; 返回 6\n;; (find-substring-index \"hello world\" \"bye\") ;; 返回 -1",
      "fr": "(defun find-substring-index (haystack needle)\n;; Trouve la première occurrence de la sous-chaîne 'needle' dans la chaîne 'haystack'.\n;; Renvoie l'index du premier caractère de la première occurrence de 'needle'.\n;; Si 'needle' ne fait pas partie de 'haystack', renvoie -1.\n;; Exemple:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Renvoie 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Renvoie -1",
      "de": "(defun find-substring-index (haystack needle)\n;; Findet das erste Vorkommen des Teilstrings 'needle' innerhalb des Strings 'haystack'.\n;; Gibt den Index des ersten Zeichens des ersten Vorkommens von 'needle' zurück.\n;; Wenn 'needle' kein Teil von 'haystack' ist, wird -1 zurückgegeben.\n;; Beispiel:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Gibt 6 zurück\n;; (find-substring-index \"hello world\" \"bye\") ;; Gibt -1 zurück",
      "ha": "(defun find-substring-index (haystack needle)\n;; Yana nemo bayyanar farko na ƙaramin kirtani 'needle' a cikin kirtani 'haystack'.\n;; Yana dawowa da alamar harafin farko na bayyanar farko na 'needle'.\n;; Idan 'needle' ba ya cikin 'haystack', yana dawowa -1.\n;; Misali:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Yana dawowa 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Yana dawowa -1",
      "hi": "(defun find-substring-index (haystack needle)\n;; स्ट्रिंग 'haystack' के भीतर सबस्ट्रिंग 'needle' की पहली घटना को खोजता है।\n;; 'needle' की पहली घटना के पहले अक्षर का इंडेक्स लौटाता है।\n;; यदि 'needle' 'haystack' का हिस्सा नहीं है, तो -1 लौटाता है।\n;; उदाहरण:\n;; (find-substring-index \"apple pie\" \"pie\") ;; 6 लौटाता है\n;; (find-substring-index \"hello world\" \"bye\") ;; -1 लौटाता है",
      "hu": "(defun find-substring-index (haystack needle)\n;; Megkeresi a 'needle' részsztring első előfordulását a 'haystack' sztringben.\n;; Visszaadja a 'needle' első előfordulásának első karakterének indexét.\n;; Ha a 'needle' nem része a 'haystack'-nek, -1-et ad vissza.\n;; Példa:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Visszaadja: 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Visszaadja: -1"
    },
    "prompt_bertscore": {
      "sq": "0.9965891190968689",
      "hy": "0.9865646410268002",
      "bn": "0.984178494259428",
      "bg": "0.9948513018931947",
      "zh": "0.9895854118615788",
      "fr": "0.9948513018931947",
      "de": "0.9928971762045734",
      "ha": "0.9795990708246687",
      "hi": "0.9741848038984198",
      "hu": "0.9732436931530765"
    },
    "canonical_solution": "(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))",
    "instruction": {
      "en": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，限制在最多500个字符以内。",
      "fr": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8872859984994665",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.8898221112045199",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun test-find-substring-index ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(test-find-substring-index)",
    "entry_point": "find-substring-index",
    "signature": "(defun find-substring-index (haystack needle)",
    "docstring": {
      "en": "Finds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1",
      "sq": "Gjen shfaqjen e parë të nënvargut 'needle' brenda vargut 'haystack'.\nKthen indeksin e karakterit të parë të shfaqjes së parë të 'needle'.\nNëse 'needle' nuk është pjesë e 'haystack', kthen -1.\nShembull:\n(find-substring-index \"apple pie\" \"pie\") Kthen 6\n(find-substring-index \"hello world\" \"bye\") Kthen -1",
      "hy": "Գտնում է 'needle' ենթատողի առաջին հանդիպումը 'haystack' տողի մեջ: \nՎերադարձնում է 'needle'-ի առաջին հանդիպման առաջին սիմվոլի ինդեքսը: \nԵթե 'needle'-ը 'haystack'-ի մաս չէ, վերադարձնում է -1: \nՕրինակ:\n(find-substring-index \"apple pie\" \"pie\") Վերադարձնում է 6\n(find-substring-index \"hello world\" \"bye\") Վերադարձնում է -1",
      "bn": "স্ট্রিং 'haystack' এর মধ্যে 'needle' সাবস্ট্রিংয়ের প্রথম উপস্থিতি খুঁজে বের করে।\n'needle' এর প্রথম উপস্থিতির প্রথম অক্ষরের সূচক ফেরত দেয়।\nযদি 'needle', 'haystack' এর অংশ না হয়, তাহলে -1 ফেরত দেয়।\nউদাহরণ:  \n(find-substring-index \"apple pie\" \"pie\") Returns 6  \n(find-substring-index \"hello world\" \"bye\") Returns -1",
      "bg": "Намира първото появяване на подниз 'needle' в низа 'haystack'.\nВръща индекса на първия символ от първото появяване на 'needle'.\nАко 'needle' не е част от 'haystack', връща -1.\nПример:\n(find-substring-index \"apple pie\" \"pie\") Връща 6\n(find-substring-index \"hello world\" \"bye\") Връща -1",
      "zh": "找到字符串 'haystack' 中子字符串 'needle' 的第一次出现。\n返回 'needle' 第一次出现的第一个字符的索引。\n如果 'needle' 不是 'haystack' 的一部分，返回 -1。\n示例：\n(find-substring-index \"apple pie\" \"pie\") 返回 6\n(find-substring-index \"hello world\" \"bye\") 返回 -1",
      "fr": "Trouve la première occurrence de la sous-chaîne 'needle' dans la chaîne 'haystack'.\nRenvoie l'index du premier caractère de la première occurrence de 'needle'.\nSi 'needle' ne fait pas partie de 'haystack', renvoie -1.\nExemple:\n(find-substring-index \"apple pie\" \"pie\") Renvoie 6\n(find-substring-index \"hello world\" \"bye\") Renvoie -1",
      "de": "Findet das erste Vorkommen des Teilstrings 'needle' innerhalb des Strings 'haystack'.\nGibt den Index des ersten Zeichens des ersten Vorkommens von 'needle' zurück.\nWenn 'needle' kein Teil von 'haystack' ist, wird -1 zurückgegeben.\nBeispiel:\n(find-substring-index \"apple pie\" \"pie\") Gibt 6 zurück\n(find-substring-index \"hello world\" \"bye\") Gibt -1 zurück",
      "ha": "Yana nemo bayyanar farko na ƙaramin kirtani 'needle' a cikin kirtani 'haystack'.\nYana mayar da alamar harafin farko na bayyanar farko na 'needle'.\nIdan 'needle' ba wani ɓangare na 'haystack' ba ne, yana mayar da -1.\nMisali:\n(find-substring-index \"apple pie\" \"pie\") Yana mayar da 6\n(find-substring-index \"hello world\" \"bye\") Yana mayar da -1",
      "hi": "पहली बार 'haystack' स्ट्रिंग के भीतर 'needle' सबस्ट्रिंग की उपस्थिति को खोजता है।\nपहली बार 'needle' की उपस्थिति के पहले अक्षर का इंडेक्स लौटाता है।\nयदि 'needle', 'haystack' का हिस्सा नहीं है, तो -1 लौटाता है।\nउदाहरण:\n(find-substring-index \"apple pie\" \"pie\") 6 लौटाता है\n(find-substring-index \"hello world\" \"bye\") -1 लौटाता है",
      "hu": "Megkeresi a 'needle' részszöveg első előfordulását a 'haystack' szövegen belül.\nVisszaadja a 'needle' első előfordulásának első karakterének indexét.\nHa a 'needle' nem része a 'haystack'-nek, -1-et ad vissza.\nPélda:\n(find-substring-index \"apple pie\" \"pie\") Visszaadja: 6\n(find-substring-index \"hello world\" \"bye\") Visszaadja: -1"
    },
    "docstring_bertscore": {
      "sq": "0.9822259576138551",
      "hy": "0.9755938878214813",
      "bn": "0.8806575040539513",
      "bg": "0.9930987860413238",
      "zh": "0.9745894139845878",
      "fr": "0.9793899130334389",
      "de": "0.9901826934173507",
      "ha": "0.9912793317510443",
      "hi": "0.9726672677873132",
      "hu": "0.9373851490952291"
    }
  },
  {
    "task_id": "Common Lisp/22",
    "prompt": {
      "en": "(defun min-n-for-sum-greater-than-k (k)\n;; Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; is greater than a given integer k.\n;; The function returns the smallest such n.\n;; Example:\n;; (min-n-for-sum-greater-than-k 2) ;; Returns 4\n;; (min-n-for-sum-greater-than-k 3) ;; Returns 11",
      "sq": "(defun min-n-for-sum-greater-than-k (k)\n;; Llogarit numrin më të vogël të plotë n të tillë që shuma S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; është më e madhe se një numër i plotë i dhënë k.\n;; Funksioni kthen numrin më të vogël të tillë n.\n;; Shembull:\n;; (min-n-for-sum-greater-than-k 2) ;; Kthen 4\n;; (min-n-for-sum-greater-than-k 3) ;; Kthen 11",
      "hy": "(defun min-n-for-sum-greater-than-k (k)\n;; Հաշվում է ամենափոքր ամբողջ թիվը n, այնպես որ գումարը S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; մեծ լինի տրված ամբողջ թիվ k-ից։\n;; Ֆունկցիան վերադարձնում է այդպիսի ամենափոքր n-ը։\n;; Օրինակ:\n;; (min-n-for-sum-greater-than-k 2) ;; Վերադարձնում է 4\n;; (min-n-for-sum-greater-than-k 3) ;; Վերադարձնում է 11",
      "bn": "(defun min-n-for-sum-greater-than-k (k)\n;; এমন ক্ষুদ্রতম পূর্ণসংখ্যা n গণনা করে যার জন্য যোগফল S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; একটি প্রদত্ত পূর্ণসংখ্যা k এর চেয়ে বেশি হয়।\n;; ফাংশনটি এমন ক্ষুদ্রতম n প্রদান করে।\n;; উদাহরণ:\n;; (min-n-for-sum-greater-than-k 2) ;; 4 প্রদান করে\n;; (min-n-for-sum-greater-than-k 3) ;; 11 প্রদান করে",
      "bg": "(defun min-n-for-sum-greater-than-k (k)\n;; Изчислява най-малкото цяло число n, такова че сумата S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; е по-голяма от дадено цяло число k.\n;; Функцията връща най-малкото такова n.\n;; Пример:\n;; (min-n-for-sum-greater-than-k 2) ;; Връща 4\n;; (min-n-for-sum-greater-than-k 3) ;; Връща 11",
      "zh": "(defun min-n-for-sum-greater-than-k (k)\n;; 计算最小的整数 n，使得和 S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; 大于给定的整数 k。\n;; 该函数返回最小的这样的 n。\n;; 示例:\n;; (min-n-for-sum-greater-than-k 2) ;; 返回 4\n;; (min-n-for-sum-greater-than-k 3) ;; 返回 11",
      "fr": "(defun min-n-for-sum-greater-than-k (k)\n;; Calcule le plus petit entier n tel que la somme S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; soit supérieure à un entier donné k.\n;; La fonction renvoie le plus petit n tel.\n;; Exemple:\n;; (min-n-for-sum-greater-than-k 2) ;; Renvoie 4\n;; (min-n-for-sum-greater-than-k 3) ;; Renvoie 11",
      "de": "(defun min-n-for-sum-greater-than-k (k)\n;; Berechnet die kleinste ganze Zahl n, so dass die Summe S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; größer als eine gegebene ganze Zahl k ist.\n;; Die Funktion gibt das kleinste solche n zurück.\n;; Beispiel:\n;; (min-n-for-sum-greater-than-k 2) ;; Gibt 4 zurück\n;; (min-n-for-sum-greater-than-k 3) ;; Gibt 11 zurück",
      "ha": "(defun min-n-for-sum-greater-than-k (k)\n;; Lissafi mafi ƙarancin cikakken lamba n wanda jimillar S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; ya fi wani cikakken lamba k da aka bayar.\n;; Aikin yana dawo da mafi ƙarancin irin wannan n.\n;; Misali:\n;; (min-n-for-sum-greater-than-k 2) ;; Yana dawowa 4\n;; (min-n-for-sum-greater-than-k 3) ;; Yana dawowa 11",
      "hi": "(defun min-n-for-sum-greater-than-k (k)\n;; ऐसा सबसे छोटा पूर्णांक n गणना करता है जिसके लिए योग S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; दिए गए पूर्णांक k से अधिक है।\n;; फ़ंक्शन ऐसा सबसे छोटा n लौटाता है।\n;; उदाहरण:\n;; (min-n-for-sum-greater-than-k 2) ;; 4 लौटाता है\n;; (min-n-for-sum-greater-than-k 3) ;; 11 लौटाता है",
      "hu": "(defun min-n-for-sum-greater-than-k (k)\n;; Kiszámítja a legkisebb n egész számot, amelyre az S_n = 1 + 1/2 + 1/3 + ... + 1/n összeg\n;; nagyobb, mint egy adott k egész szám.\n;; A függvény visszaadja a legkisebb ilyen n értéket.\n;; Példa:\n;; (min-n-for-sum-greater-than-k 2) ;; Visszaadja: 4\n;; (min-n-for-sum-greater-than-k 3) ;; Visszaadja: 11"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9973073665546911",
      "bn": "0.980010831604554",
      "bg": "0.9956259603792307",
      "zh": "0.987349032401507",
      "fr": "1",
      "de": "1",
      "ha": "0.9802203866565459",
      "hi": "0.9876177793070472",
      "hu": "0.9791849264802109"
    },
    "canonical_solution": "(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))",
    "instruction": {
      "en": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nՏվեք Common Lisp կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Common Lisp a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्णों का उपयोग हो।",
      "hu": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9671614322554071",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8724534734260673",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9202179225231458",
      "hi": "0.89135951035373",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun test-min-n-for-sum-greater-than-k ()\n(assert (equal (min-n-for-sum-greater-than-k 1) 2))\n(assert (equal (min-n-for-sum-greater-than-k 2) 4))\n(assert (equal (min-n-for-sum-greater-than-k 3) 11))\n(assert (equal (min-n-for-sum-greater-than-k 4) 31))\n(assert (equal (min-n-for-sum-greater-than-k 5) 83))\n(assert (equal (min-n-for-sum-greater-than-k 0) 1)))\n\n(test-min-n-for-sum-greater-than-k)",
    "entry_point": "min-n-for-sum-greater-than-k",
    "signature": "(defun min-n-for-sum-greater-than-k (k)",
    "docstring": {
      "en": "Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11",
      "sq": "Llogarit numrin më të vogël të plotë n të tillë që shuma S_n = 1 + 1/2 + 1/3 + ... + 1/n\nështë më e madhe se një numër i dhënë i plotë k.\nFunksioni kthen numrin më të vogël të tillë n.\nShembull:\n(min-n-for-sum-greater-than-k 2) Kthen 4\n(min-n-for-sum-greater-than-k 3) Kthen 11",
      "hy": "Հաշվում է ամենափոքր ամբողջ թիվը n, այնպես, որ S_n = 1 + 1/2 + 1/3 + ... + 1/n գումարը մեծ լինի տրված ամբողջ թիվ k-ից։ \nՖունկցիան վերադարձնում է այդպիսի ամենափոքր n-ը։ \nՕրինակ:\n(min-n-for-sum-greater-than-k 2) Վերադարձնում է 4\n(min-n-for-sum-greater-than-k 3) Վերադարձնում է 11",
      "bn": "সর্বনিম্ন পূর্ণসংখ্যা n গণনা করে যা S_n = 1 + 1/2 + 1/3 + ... + 1/n এর যোগফল একটি প্রদত্ত পূর্ণসংখ্যা k এর চেয়ে বড় হয়।\nফাংশনটি এমন সর্বনিম্ন n ফেরত দেয়।\nউদাহরণ:\n(min-n-for-sum-greater-than-k 2) 4 ফেরত দেয়\n(min-n-for-sum-greater-than-k 3) 11 ফেরত দেয়",
      "bg": "Изчислява най-малкото цяло число n, такова че сумата S_n = 1 + 1/2 + 1/3 + ... + 1/n\nе по-голяма от дадено цяло число k.\nФункцията връща най-малкото такова n.\nПример:\n(min-n-for-sum-greater-than-k 2) Връща 4\n(min-n-for-sum-greater-than-k 3) Връща 11",
      "zh": "计算最小整数 n，使得和 S_n = 1 + 1/2 + 1/3 + ... + 1/n 大于给定的整数 k。\n该函数返回这样的最小 n。\n示例：\n(min-n-for-sum-greater-than-k 2) 返回 4\n(min-n-for-sum-greater-than-k 3) 返回 11",
      "fr": "Calcule le plus petit entier n tel que la somme S_n = 1 + 1/2 + 1/3 + ... + 1/n\nsoit supérieure à un entier donné k.\nLa fonction renvoie le plus petit tel n.\nExemple:\n(min-n-for-sum-greater-than-k 2) Renvoie 4\n(min-n-for-sum-greater-than-k 3) Renvoie 11",
      "de": "Berechnet die kleinste ganze Zahl n, sodass die Summe S_n = 1 + 1/2 + 1/3 + ... + 1/n\ngrößer als eine gegebene ganze Zahl k ist.\nDie Funktion gibt das kleinste solche n zurück.\nBeispiel:\n(min-n-for-sum-greater-than-k 2) Gibt 4 zurück\n(min-n-for-sum-greater-than-k 3) Gibt 11 zurück",
      "ha": "Yana ƙididdige ƙaramin cikakken lamba n wanda yake sa jumlar S_n = 1 + 1/2 + 1/3 + ... + 1/n\nya fi wani cikakken lamba k da aka bayar.\nAikin yana mayar da ƙaramin irin wannan n.\nMisali:\n(min-n-for-sum-greater-than-k 2) Yana Mayar da 4\n(min-n-for-sum-greater-than-k 3) Yana Mayar da 11",
      "hi": "सबसे छोटा पूर्णांक n की गणना करता है ताकि योग S_n = 1 + 1/2 + 1/3 + ... + 1/n\nदिए गए पूर्णांक k से अधिक हो।\nफंक्शन सबसे छोटा ऐसा n लौटाता है।\nउदाहरण:\n(min-n-for-sum-greater-than-k 2) 4 लौटाता है\n(min-n-for-sum-greater-than-k 3) 11 लौटाता है",
      "hu": "Kiszámítja a legkisebb n egész számot, amelyre az S_n = 1 + 1/2 + 1/3 + ... + 1/n összeg nagyobb, mint egy adott k egész szám. A függvény visszaadja a legkisebb ilyen n értéket.\nPélda:\n(min-n-for-sum-greater-than-k 2) Visszaadja 4\n(min-n-for-sum-greater-than-k 3) Visszaadja 11"
    },
    "docstring_bertscore": {
      "sq": "0.9914048661518583",
      "hy": "0.9871190184202685",
      "bn": "0.9783435281861472",
      "bg": "0.999999801369619",
      "zh": "0.9757504085617367",
      "fr": "0.9977423670891574",
      "de": "0.999999801369619",
      "ha": "0.9761176761362702",
      "hi": "0.9902001728908817",
      "hu": "0.9835446647135457"
    }
  },
  {
    "task_id": "Common Lisp/23",
    "prompt": {
      "en": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Counts the number of apples that Fengfeng can reach.\n;; 'apple-heights' is a list of integers representing the heights of apples.\n;; 'fengfeng-height' is an integer representing Fengfeng's maximum reach height.\n;; Fengfeng can reach apples at or below her maximum height.\n;; Example:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Returns 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Returns 10",
      "sq": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Numëron numrin e mollëve që Fengfeng mund të arrijë.\n;; 'apple-heights' është një listë e numrave të plotë që përfaqësojnë lartësitë e mollëve.\n;; 'fengfeng-height' është një numër i plotë që përfaqëson lartësinë maksimale që Fengfeng mund të arrijë.\n;; Fengfeng mund të arrijë mollët në ose nën lartësinë e saj maksimale.\n;; Shembull:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Kthen 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Kthen 10",
      "hy": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Հաշվում է խնձորների քանակը, որոնք Ֆենգֆենգը կարող է հասնել։\n;; 'apple-heights' ցուցակը ամբողջ թվերի ցուցակ է, որը ներկայացնում է խնձորների բարձրությունները։\n;; 'fengfeng-height' ամբողջ թիվ է, որը ներկայացնում է Ֆենգֆենգի առավելագույն հասանելիության բարձրությունը։\n;; Ֆենգֆենգը կարող է հասնել խնձորներին, որոնք գտնվում են իր առավելագույն բարձրության վրա կամ դրանից ցածր։\n;; Օրինակ:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Վերադարձնում է 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Վերադարձնում է 10",
      "bn": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; ফেংফেং কতগুলি আপেল পৌঁছাতে পারে তা গণনা করে।\n;; 'apple-heights' হল আপেলের উচ্চতাগুলির একটি তালিকা যা পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়।\n;; 'fengfeng-height' হল একটি পূর্ণসংখ্যা যা ফেংফেং এর সর্বাধিক পৌঁছানোর উচ্চতা প্রতিনিধিত্ব করে।\n;; ফেংফেং তার সর্বাধিক উচ্চতা বা তার নিচে থাকা আপেল পৌঁছাতে পারে।\n;; উদাহরণ:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; 4 ফেরত দেয়\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; 10 ফেরত দেয়",
      "bg": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Брои броя на ябълките, които Фенгфенг може да достигне.\n;; 'apple-heights' е списък от цели числа, представляващи височините на ябълките.\n;; 'fengfeng-height' е цяло число, представляващо максималната височина, която Фенгфенг може да достигне.\n;; Фенгфенг може да достигне ябълки на или под нейната максимална височина.\n;; Пример:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Връща 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Връща 10",
      "zh": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; 计算凤凤可以够到的苹果数量。\n;; 'apple-heights' 是一个整数列表，表示苹果的高度。\n;; 'fengfeng-height' 是一个整数，表示凤凤的最大够到高度。\n;; 凤凤可以够到高度在其最大高度以下或等于其最大高度的苹果。\n;; 例子:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; 返回 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; 返回 10",
      "fr": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Compte le nombre de pommes que Fengfeng peut atteindre.\n;; 'apple-heights' est une liste d'entiers représentant les hauteurs des pommes.\n;; 'fengfeng-height' est un entier représentant la hauteur maximale que Fengfeng peut atteindre.\n;; Fengfeng peut atteindre les pommes à ou en dessous de sa hauteur maximale.\n;; Exemple:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Retourne 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Retourne 10",
      "de": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Zählt die Anzahl der Äpfel, die Fengfeng erreichen kann.\n;; 'apple-heights' ist eine Liste von ganzen Zahlen, die die Höhen der Äpfel darstellen.\n;; 'fengfeng-height' ist eine ganze Zahl, die die maximale Reichhöhe von Fengfeng darstellt.\n;; Fengfeng kann Äpfel in oder unter ihrer maximalen Höhe erreichen.\n;; Beispiel:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Gibt 4 zurück\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Gibt 10 zurück",
      "ha": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Yana ƙididdige yawan tuffa da Fengfeng za ta iya kaiwa.\n;; 'apple-heights' jerin lambobi ne da ke wakiltar tsayin tuffa.\n;; 'fengfeng-height' lamba ce da ke wakiltar iyakar tsayin da Fengfeng za ta iya kaiwa.\n;; Fengfeng za ta iya kaiwa tuffa a ko ƙasa da iyakar tsayinta.\n;; Misali:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Yana dawowa 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Yana dawowa 10",
      "hi": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; गिनती करता है कि फेंगफेंग कितने सेब तक पहुँच सकती है।\n;; 'apple-heights' पूर्णांकों की एक सूची है जो सेबों की ऊँचाई का प्रतिनिधित्व करती है।\n;; 'fengfeng-height' एक पूर्णांक है जो फेंगफेंग की अधिकतम पहुँच ऊँचाई का प्रतिनिधित्व करता है।\n;; फेंगफेंग उन सेबों तक पहुँच सकती है जो उसकी अधिकतम ऊँचाई पर या उससे नीचे हैं।\n;; उदाहरण:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; 4 लौटाता है\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; 10 लौटाता है",
      "hu": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Megszámolja, hogy hány almát ér el Fengfeng.\n;; Az 'apple-heights' egy egész számokat tartalmazó lista, amely az almák magasságát jelöli.\n;; A 'fengfeng-height' egy egész szám, amely Fengfeng maximális elérési magasságát jelöli.\n;; Fengfeng eléri az almákat, amelyek az ő maximális magasságán vagy az alatt vannak.\n;; Példa:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Visszaadja: 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Visszaadja: 10"
    },
    "prompt_bertscore": {
      "sq": "0.979378988362482",
      "hy": "0.9722288905363692",
      "bn": "0.9769497388024254",
      "bg": "0.9843010492045265",
      "zh": "0.963141153343261",
      "fr": "0.977004759417972",
      "de": "0.9830689449509672",
      "ha": "0.9787048368492496",
      "hi": "0.9866409150931176",
      "hu": "0.9694190651662496"
    },
    "canonical_solution": "(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))",
    "instruction": {
      "en": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nՏվեք Common Lisp կոդի կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nПредоставете кратко описание на Common Lisp кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用不超过 500 个字符的中文。",
      "fr": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9131842221003194",
      "bn": "0.8685243658588161",
      "bg": "0.8335809119663965",
      "zh": "0.8950796587601324",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.8830803974418148",
      "hi": "0.8898221112045199",
      "hu": "0.9443179452844898"
    },
    "level": "",
    "test": "(defun test-count-reachable-apples ()\n(assert (equal (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4))\n(assert (equal (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10))\n(assert (equal (count-reachable-apples '(110 115 120 125 130 135 140 145 150 155) 120) 3))\n(assert (equal (count-reachable-apples '(200 199 198 197 196 195 194 193 192 191) 190) 0))\n(assert (equal (count-reachable-apples '(101 102 103 104 105 106 107 108 109 110) 105) 5)))\n\n(test-count-reachable-apples)",
    "entry_point": "count-reachable-apples",
    "signature": "(defun count-reachable-apples (apple-heights fengfeng-height)",
    "docstring": {
      "en": "Counts the number of apples that Fengfeng can reach.\n'apple-heights' is a list of integers representing the heights of apples.\n'fengfeng-height' is an integer representing Fengfeng's maximum reach height.\nFengfeng can reach apples at or below her maximum height.\nExample:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "sq": "Numëron numrin e mollëve që Fengfeng mund të arrijë.  \n'apple-heights' është një listë e numrave të plotë që përfaqësojnë lartësitë e mollëve.  \n'fengfeng-height' është një numër i plotë që përfaqëson lartësinë maksimale të arritjes së Fengfeng.  \nFengfeng mund të arrijë mollët që janë në ose nën lartësinë e saj maksimale.  \nShembull:  \n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Kthen 4  \n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Kthen 10",
      "hy": "Հաշվում է այն խնձորների քանակը, որոնք Ֆենգֆենգը կարող է հասնել:\n'apple-heights' ցուցակը ամբողջ թվերի ցուցակ է, որը ներկայացնում է խնձորների բարձրությունները:\n'fengfeng-height' ամբողջ թիվ է, որը ներկայացնում է Ֆենգֆենգի առավելագույն հասանելի բարձրությունը:\nՖենգֆենգը կարող է հասնել խնձորներին, որոնք գտնվում են իր առավելագույն բարձրության վրա կամ ներքևում:\nՕրինակ:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Վերադարձնում է 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Վերադարձնում է 10",
      "bn": "Fengfeng কতগুলি আপেল পৌঁছাতে পারে তা গণনা করে।\n'apple-heights' হল আপেলের উচ্চতা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n'fengfeng-height' হল Fengfeng এর সর্বাধিক পৌঁছানোর উচ্চতা উপস্থাপনকারী একটি পূর্ণসংখ্যা।\nFengfeng তার সর্বাধিক উচ্চতা বা তার নিচে থাকা আপেলগুলিতে পৌঁছাতে পারে।\nউদাহরণ:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "bg": "Брои броя на ябълките, които Фенгфенг може да достигне.\n'apple-heights' е списък от цели числа, представляващи височините на ябълките.\n'fengfeng-height' е цяло число, представляващо максималната височина, която Фенгфенг може да достигне.\nФенгфенг може да достигне ябълки на или под нейната максимална височина.\nПример:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Връща 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Връща 10",
      "zh": "计算风风可以够到的苹果数量。\n'apple-heights' 是一个整数列表，表示苹果的高度。\n'fengfeng-height' 是一个整数，表示风风的最大可及高度。\n风风可以够到高度不超过她最大高度的苹果。\n示例：\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 返回 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 返回 10",
      "fr": "Compte le nombre de pommes que Fengfeng peut atteindre.\n'apple-heights' est une liste d'entiers représentant les hauteurs des pommes.\n'fengfeng-height' est un entier représentant la hauteur maximale que Fengfeng peut atteindre.\nFengfeng peut atteindre les pommes à ou en dessous de sa hauteur maximale.\nExemple:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "de": "Zählt die Anzahl der Äpfel, die Fengfeng erreichen kann.\n'apple-heights' ist eine Liste von ganzen Zahlen, die die Höhen der Äpfel darstellen.\n'fengfeng-height' ist eine ganze Zahl, die die maximale Reichhöhe von Fengfeng darstellt.\nFengfeng kann Äpfel in oder unter ihrer maximalen Höhe erreichen.\nBeispiel:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Gibt 4 zurück\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Gibt 10 zurück",
      "ha": "Yana ƙididdige yawan tuffa da Fengfeng zai iya kaiwa.\n'apple-heights' jerin lambobi ne da ke wakiltar tsayin tuffa.\n'fengfeng-height' lamba ce da ke wakiltar iyakar tsayin da Fengfeng zai iya kaiwa.\nFengfeng na iya kaiwa tuffa a ko ƙasa da iyakar tsayinta.\nMisali:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "hi": "Fengfeng कितने सेब तक पहुँच सकती है, यह गिनता है।\n'apple-heights' पूर्णांकों की एक सूची है जो सेबों की ऊँचाई का प्रतिनिधित्व करती है।\n'fengfeng-height' एक पूर्णांक है जो Fengfeng की अधिकतम पहुँच ऊँचाई का प्रतिनिधित्व करता है।\nFengfeng उन सेबों तक पहुँच सकती है जो उसकी अधिकतम ऊँचाई पर या उससे नीचे हैं।\nउदाहरण:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "hu": "Számolja meg, hány almát érhet el Fengfeng.\n'apple-heights' egy egész számokat tartalmazó lista, amely az almák magasságát jelenti.\n'fengfeng-height' egy egész szám, amely Fengfeng maximális elérési magasságát jelenti.\nFengfeng elérheti az almákat a maximális magasságán vagy az alatt.\nPélda:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Visszaadja 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Visszaadja 10"
    },
    "docstring_bertscore": {
      "sq": "0.9709548752724114",
      "hy": "0.9526302294700378",
      "bn": "0.9545527729280745",
      "bg": "0.983830692462236",
      "zh": "0.9589576002579041",
      "fr": "0.9739410844208899",
      "de": "0.9769608621037633",
      "ha": "0.9581980376808268",
      "hi": "0.9636204484526981",
      "hu": "0.976953512779665"
    }
  },
  {
    "task_id": "Common Lisp/24",
    "prompt": {
      "en": "(defun count-remaining-trees (road-length regions)\n;; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.\n;; Example:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Returns 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Returns 7",
      "sq": "(defun count-remaining-trees (road-length regions)\n;; Numëron numrin e pemëve të mbetura në një rrugë me gjatësi 'road-length' pas heqjes së pemëve në 'regions' të specifikuara.\n;; Çdo rajon është një listë me dy numra të plotë që përfaqësojnë pikat e fillimit dhe të mbarimit në rrugë.\n;; Funksioni kthen numrin e pemëve të mbetura pas heqjes.\n;; Shembull:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Kthen 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Kthen 7",
      "hy": "(defun count-remaining-trees (road-length regions)\n;; Հաշվում է ճանապարհի վրա մնացած ծառերի քանակը 'road-length' երկարությամբ՝ հեռացնելուց հետո 'regions' նշված տարածքներում գտնվող ծառերը։\n;; Յուրաքանչյուր տարածք ցուցակ է երկու ամբողջ թվերից, որոնք ներկայացնում են ճանապարհի վրա սկսման և ավարտի կետերը։\n;; Ֆունկցիան վերադարձնում է հեռացումից հետո մնացած ծառերի քանակը։\n;; Օրինակ:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Վերադարձնում է 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Վերադարձնում է 7",
      "bn": "(defun count-remaining-trees (road-length regions)\n;; নির্দিষ্ট 'regions' থেকে গাছ অপসারণের পর 'road-length' দৈর্ঘ্যের একটি সড়কে অবশিষ্ট গাছের সংখ্যা গণনা করে।\n;; প্রতিটি অঞ্চল দুটি পূর্ণসংখ্যার একটি তালিকা যা সড়কের শুরুর এবং শেষের পয়েন্টগুলি উপস্থাপন করে।\n;; ফাংশনটি অপসারণের পর অবশিষ্ট গাছের সংখ্যা প্রদান করে।\n;; উদাহরণ:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; 4 প্রদান করে\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; 7 প্রদান করে",
      "bg": "(defun count-remaining-trees (road-length regions)\n;; Брои броя на останалите дървета на път с дължина 'road-length' след премахване на дървета в определените 'regions'.\n;; Всеки регион е списък от две цели числа, представляващи началната и крайната точка на пътя.\n;; Функцията връща броя на останалите дървета след премахването.\n;; Пример:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Връща 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Връща 7",
      "zh": "(defun count-remaining-trees (road-length regions)\n;; 计算在长度为 'road-length' 的道路上，在指定的 'regions' 中移除树木后剩余的树木数量。\n;; 每个区域是一个包含两个整数的列表，表示道路上的起点和终点。\n;; 该函数返回移除后剩余的树木数量。\n;; 例子:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; 返回 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; 返回 7",
      "fr": "(defun count-remaining-trees (road-length regions)\n;; Compte le nombre d'arbres restants sur une route de longueur 'road-length' après avoir enlevé les arbres dans les 'regions' spécifiées.\n;; Chaque région est une liste de deux entiers représentant les points de début et de fin sur la route.\n;; La fonction renvoie le nombre d'arbres restants après le retrait.\n;; Exemple:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Renvoie 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Renvoie 7",
      "de": "(defun count-remaining-trees (road-length regions)\n;; Zählt die Anzahl der verbleibenden Bäume auf einer Straße der Länge 'road-length', nachdem Bäume in den angegebenen 'regions' entfernt wurden.\n;; Jede Region ist eine Liste von zwei ganzen Zahlen, die die Start- und Endpunkte auf der Straße darstellen.\n;; Die Funktion gibt die Anzahl der verbleibenden Bäume nach der Entfernung zurück.\n;; Beispiel:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Gibt 4 zurück\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Gibt 7 zurück",
      "ha": "(defun count-remaining-trees (road-length regions)\n;; Yana ƙididdige yawan bishiyoyin da suka rage a kan hanya mai tsawon 'road-length' bayan cire bishiyoyi a wuraren da aka fayyace 'regions'.\n;; Kowace yanki jerin lambobi biyu ne da ke wakiltar wuraren farawa da ƙarshe a kan hanya.\n;; Aikin yana dawo da yawan bishiyoyin da suka rage bayan cirewa.\n;; Misali:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Yana dawowa 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Yana dawowa 7",
      "hi": "(defun count-remaining-trees (road-length regions)\n;; 'road-length' लंबाई की सड़क पर शेष पेड़ों की संख्या की गणना करता है, निर्दिष्ट 'regions' में पेड़ों को हटाने के बाद।\n;; प्रत्येक क्षेत्र सड़क पर प्रारंभ और अंत बिंदुओं का प्रतिनिधित्व करने वाले दो पूर्णांकों की एक सूची है।\n;; यह फ़ंक्शन हटाने के बाद शेष पेड़ों की संख्या लौटाता है।\n;; उदाहरण:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; 4 लौटाता है\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; 7 लौटाता है",
      "hu": "(defun count-remaining-trees (road-length regions)\n;; Megszámolja a megmaradt fák számát egy 'road-length' hosszúságú úton, miután eltávolította a fákat a megadott 'regions' területeken.\n;; Minden terület egy két egész számot tartalmazó lista, amely az út kezdő és végpontját jelöli.\n;; A függvény visszaadja az eltávolítás után megmaradt fák számát.\n;; Példa:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Visszaadja 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Visszaadja 7"
    },
    "prompt_bertscore": {
      "sq": "0.9878251494248476",
      "hy": "0.9895305898764131",
      "bn": "0.9703655389318809",
      "bg": "0.9898740218052224",
      "zh": "0.9773551434101175",
      "fr": "0.989717898325729",
      "de": "0.9816608541798109",
      "ha": "0.9758608470535921",
      "hi": "0.9775637053102042",
      "hu": "0.9794274541754545"
    },
    "canonical_solution": "(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))",
    "instruction": {
      "en": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nՏվեք Common Lisp կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nДайте кратко описание на кода на Common Lisp на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9340523299318447",
      "bn": "0.8727891587700162",
      "bg": "0.8335809119663965",
      "zh": "0.882369896568853",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9543551356989448",
      "hi": "0.8995998903413434",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun test-count-remaining-trees ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(test-count-remaining-trees)",
    "entry_point": "count-remaining-trees",
    "signature": "(defun count-remaining-trees (road-length regions)",
    "docstring": {
      "en": "Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7",
      "sq": "Numëron numrin e pemëve të mbetura në një rrugë me gjatësi 'road-length' pasi të hiqen pemët në 'regions' e specifikuara.\nÇdo rajon është një listë me dy numra të plotë që përfaqësojnë pikat e fillimit dhe të mbarimit në rrugë.\nFunksioni kthen numrin e pemëve të mbetura pas heqjes.\nShembull:\n(count-remaining-trees 10 '((2 5) (7 9))) Kthen 4\n(count-remaining-trees 15 '((1 3) (5 10))) Kthen 7",
      "hy": "Հաշվում է ճանապարհի երկարությամբ մնացած ծառերի քանակը 'road-length' հետո 'regions'-ում նշված ծառերի հեռացումից:\nՅուրաքանչյուր տարածաշրջան ցուցակ է երկու ամբողջ թվերով, որոնք ներկայացնում են ճանապարհի սկզբնակետն ու վերջնակետը:\nՖունկցիան վերադարձնում է հեռացումից հետո մնացած ծառերի քանակը:\nՕրինակ:\n(count-remaining-trees 10 '((2 5) (7 9))) Վերադարձնում է 4\n(count-remaining-trees 15 '((1 3) (5 10))) Վերադարձնում է 7",
      "bn": "গণনা করে একটি নির্দিষ্ট 'regions' থেকে গাছ অপসারণের পর 'road-length' দৈর্ঘ্যের একটি সড়কে কতগুলি গাছ অবশিষ্ট রয়েছে।\nপ্রতিটি অঞ্চল দুটি পূর্ণসংখ্যার একটি তালিকা যা সড়কের শুরু এবং শেষ বিন্দু প্রতিনিধিত্ব করে।\nফাংশনটি অপসারণের পর অবশিষ্ট গাছের সংখ্যা ফেরত দেয়।\nউদাহরণ:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7",
      "bg": "Брои броя на дърветата, останали на път с дължина 'road-length' след премахване на дървета в определени 'regions'.  \nВсеки регион е списък от две цели числа, представляващи началната и крайната точка на пътя.  \nФункцията връща броя на дърветата, останали след премахването.  \nПример:  \n(count-remaining-trees 10 '((2 5) (7 9))) Връща 4  \n(count-remaining-trees 15 '((1 3) (5 10))) Връща 7  ",
      "zh": "计算在指定“区域”移除树木后，长度为“road-length”的道路上剩余的树木数量。  \n每个区域是一个包含两个整数的列表，表示道路上的起点和终点。  \n该函数返回移除后剩余的树木数量。  \n示例：  \n(count-remaining-trees 10 '((2 5) (7 9))) 返回 4  \n(count-remaining-trees 15 '((1 3) (5 10))) 返回 7  ",
      "fr": "Compte le nombre d'arbres restants sur une route de longueur 'road-length' après avoir enlevé les arbres dans les 'regions' spécifiées.\nChaque région est une liste de deux entiers représentant les points de début et de fin sur la route.\nLa fonction retourne le nombre d'arbres restants après le retrait.\nExemple:\n(count-remaining-trees 10 '((2 5) (7 9))) Retourne 4\n(count-remaining-trees 15 '((1 3) (5 10))) Retourne 7",
      "de": "Zählt die Anzahl der verbleibenden Bäume auf einer Straße der Länge 'road-length', nachdem Bäume in angegebenen 'regions' entfernt wurden.  \nJede Region ist eine Liste von zwei ganzen Zahlen, die die Start- und Endpunkte auf der Straße darstellen.  \nDie Funktion gibt die Anzahl der verbleibenden Bäume nach der Entfernung zurück.  \nBeispiel:  \n(count-remaining-trees 10 '((2 5) (7 9))) Gibt 4 zurück  \n(count-remaining-trees 15 '((1 3) (5 10))) Gibt 7 zurück",
      "ha": "Yana ƙidaya adadin bishiyoyin da suka rage a kan hanya mai tsawon 'road-length' bayan cire bishiyoyi a wuraren da aka fayyace 'regions'.\nKowane yanki jerin lambobi biyu ne da ke wakiltar wuraren farawa da ƙarewa a kan hanya.\nAikin yana dawowa da adadin bishiyoyin da suka rage bayan cirewa.\nMisali:\n(count-remaining-trees 10 '((2 5) (7 9))) Yana dawowa 4\n(count-remaining-trees 15 '((1 3) (5 10))) Yana dawowa 7",
      "hi": "सड़क की लंबाई 'road-length' पर शेष पेड़ों की संख्या की गणना करता है, निर्दिष्ट 'regions' में पेड़ों को हटाने के बाद।\nप्रत्येक क्षेत्र दो पूर्णांकों की एक सूची है जो सड़क पर आरंभ और अंत बिंदुओं का प्रतिनिधित्व करती है।\nयह फ़ंक्शन हटाने के बाद शेष पेड़ों की संख्या लौटाता है।\n\nउदाहरण:\n(count-remaining-trees 10 '((2 5) (7 9))) 4 लौटाता है\n(count-remaining-trees 15 '((1 3) (5 10))) 7 लौटाता है",
      "hu": "Számolja meg az úton maradó fák számát egy 'út-hossz' hosszúságú úton, miután eltávolította a fákat a megadott 'területeken'.\nMinden terület két egész számot tartalmazó lista, amely az út kezdő- és végpontját jelöli.\nA függvény visszaadja az eltávolítás után maradó fák számát.\nPélda:\n(count-remaining-trees 10 '((2 5) (7 9))) Visszaad 4\n(count-remaining-trees 15 '((1 3) (5 10))) Visszaad 7"
    },
    "docstring_bertscore": {
      "sq": "0.9879087728152632",
      "hy": "0.9403020362407264",
      "bn": "0.9577564823437862",
      "bg": "0.9925060729843157",
      "zh": "0.9685776668721858",
      "fr": "0.99170459939684",
      "de": "0.9807503325131469",
      "ha": "0.9621674672154279",
      "hi": "0.9490409784847373",
      "hu": "0.9635187496976083"
    }
  },
  {
    "task_id": "Common Lisp/25",
    "prompt": {
      "en": "(defun larger-prime-factor (n)\n;; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.\n;; Example:\n;; (larger-prime-factor 15) ;; Returns 5\n;; (larger-prime-factor 33) ;; Returns 11",
      "sq": "(defun larger-prime-factor (n)\n;; Gjen faktorin më të madh prim të një numri të plotë pozitiv 'n', i cili dihet se është produkt i dy numrave të ndryshëm prim.\n;; Funksioni kthen faktorin më të madh nga dy faktorët prim.\n;; Shembull:\n;; (larger-prime-factor 15) ;; Kthen 5\n;; (larger-prime-factor 33) ;; Kthen 11",
      "hy": "(defun larger-prime-factor (n)\n;; Գտնում է դրական ամբողջ թիվ 'n'-ի ավելի մեծ պարզ գործակիցը, որը հայտնի է որպես երկու տարբեր պարզ թվերի արտադրյալ։\n;; Ֆունկցիան վերադարձնում է երկու պարզ գործակիցներից մեծը։\n;; Օրինակ:\n;; (larger-prime-factor 15) ;; Վերադարձնում է 5\n;; (larger-prime-factor 33) ;; Վերադարձնում է 11",
      "bn": "(defun larger-prime-factor (n)\n;; একটি ধনাত্মক পূর্ণসংখ্যা 'n' এর বৃহত্তর মৌলিক গুণক খুঁজে বের করে, যা দুটি পৃথক মৌলিক সংখ্যার গুণফল হিসেবে পরিচিত।\n;; ফাংশনটি দুটি মৌলিক গুণকের মধ্যে বৃহত্তরটি ফেরত দেয়।\n;; উদাহরণ:\n;; (larger-prime-factor 15) ;; 5 ফেরত দেয়\n;; (larger-prime-factor 33) ;; 11 ফেরত দেয়",
      "bg": "(defun larger-prime-factor (n)\n;; Намира по-големия прост делител на положително цяло число 'n', което е известно, че е произведение на две различни прости числа.\n;; Функцията връща по-големия от двата прости делителя.\n;; Пример:\n;; (larger-prime-factor 15) ;; Връща 5\n;; (larger-prime-factor 33) ;; Връща 11",
      "zh": "(defun larger-prime-factor (n)\n;; 查找正整数 'n' 的较大素因子，已知 'n' 是两个不同素数的乘积。\n;; 该函数返回两个素因子中较大的一个。\n;; 示例:\n;; (larger-prime-factor 15) ;; 返回 5\n;; (larger-prime-factor 33) ;; 返回 11",
      "fr": "(defun larger-prime-factor (n)\n;; Trouve le plus grand facteur premier d'un entier positif 'n', qui est connu pour être le produit de deux nombres premiers distincts.\n;; La fonction renvoie le plus grand des deux facteurs premiers.\n;; Exemple:\n;; (larger-prime-factor 15) ;; Renvoie 5\n;; (larger-prime-factor 33) ;; Renvoie 11",
      "de": "(defun larger-prime-factor (n)\n;; Findet den größeren Primfaktor einer positiven ganzen Zahl 'n', die als Produkt von zwei verschiedenen Primzahlen bekannt ist.\n;; Die Funktion gibt den größeren der beiden Primfaktoren zurück.\n;; Beispiel:\n;; (larger-prime-factor 15) ;; Gibt 5 zurück\n;; (larger-prime-factor 33) ;; Gibt 11 zurück",
      "ha": "(defun larger-prime-factor (n)\n;; Nemi babbar lamba mai lamba ta farko na lamba mai kyau 'n', wanda aka sani shine samfurin lambobi biyu masu lamba daban-daban.\n;; Aikin yana dawowa da babbar daga cikin lambobin farko guda biyu.\n;; Misali:\n;; (larger-prime-factor 15) ;; Yana dawowa 5\n;; (larger-prime-factor 33) ;; Yana dawowa 11",
      "hi": "(defun larger-prime-factor (n)\n;; एक सकारात्मक पूर्णांक 'n' का बड़ा अभाज्य गुणक खोजता है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल होता है।\n;; यह फ़ंक्शन दोनों अभाज्य गुणकों में से बड़े गुणक को लौटाता है।\n;; उदाहरण:\n;; (larger-prime-factor 15) ;; 5 लौटाता है\n;; (larger-prime-factor 33) ;; 11 लौटाता है",
      "hu": "(defun larger-prime-factor (n)\n;; Megkeresi egy pozitív egész szám 'n' nagyobb prímtényezőjét, amelyről ismert, hogy két különböző prímszám szorzata.\n;; A függvény visszaadja a két prímtényező közül a nagyobbat.\n;; Példa:\n;; (larger-prime-factor 15) ;; Visszaadja: 5\n;; (larger-prime-factor 33) ;; Visszaadja: 11"
    },
    "prompt_bertscore": {
      "sq": "0.9916732157966365",
      "hy": "0.984389042463325",
      "bn": "0.98580070858134",
      "bg": "0.9965207902457929",
      "zh": "0.9625244060101477",
      "fr": "0.9951432885533159",
      "de": "0.9965207902457929",
      "ha": "0.9726670691569321",
      "hi": "0.9809326752029369",
      "hu": "0.9889430412093119"
    },
    "canonical_solution": "(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))",
    "instruction": {
      "en": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nՏվեք Common Lisp կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\n提供一段简洁的自然语言描述（文档字符串），用中文描述这段Common Lisp代码，限制在500个字符以内。",
      "fr": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9340523299318447",
      "bn": "0.8874754918829738",
      "bg": "0.8388862829106369",
      "zh": "0.8893148092113569",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.913432708706994",
      "hi": "0.8898221112045199",
      "hu": "0.9443179452844898"
    },
    "level": "",
    "test": "(defun test-larger-prime-factor ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(test-larger-prime-factor)",
    "entry_point": "larger-prime-factor",
    "signature": "(defun larger-prime-factor (n)",
    "docstring": {
      "en": "Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11",
      "sq": "Gjen faktorin më të madh prim të një numri të plotë pozitiv 'n', i cili dihet se është prodhimi i dy numrave të ndryshëm prim.\nFunksioni kthen më të madhin nga dy faktorët prim.\nShembull:\n(larger-prime-factor 15) Kthen 5\n(larger-prime-factor 33) Kthen 11",
      "hy": "Գտնում է դրական ամբողջ թիվ 'n'-ի մեծագույն պարզ գործակիցը, որը հայտնի է որպես երկու տարբեր պարզ թվերի արտադրյալ։\nՖունկցիան վերադարձնում է երկու պարզ գործակիցներից մեծագույնը։\nՕրինակ:\n(larger-prime-factor 15) Վերադարձնում է 5\n(larger-prime-factor 33) Վերադարձնում է 11",
      "bn": "একটি ধনাত্মক পূর্ণসংখ্যা 'n' এর বৃহত্তর মৌলিক গুণক খুঁজে বের করে, যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল হিসেবে পরিচিত।\nফাংশনটি দুটি মৌলিক গুণকের মধ্যে বড়টি ফেরত দেয়।\nউদাহরণ:\n(larger-prime-factor 15) 5 ফেরত দেয়\n(larger-prime-factor 33) 11 ফেরত দেয়",
      "bg": "Намира по-големия прост множител на положително цяло число 'n', което е известно, че е произведение на две различни прости числа.\nФункцията връща по-големия от двата прости множителя.\nПример:\n(larger-prime-factor 15) Връща 5\n(larger-prime-factor 33) Връща 11",
      "zh": "找到一个正整数 'n' 的较大质因数，该整数已知是两个不同质数的乘积。\n该函数返回两个质因数中较大的一个。\n示例：\n(larger-prime-factor 15) 返回 5\n(larger-prime-factor 33) 返回 11",
      "fr": "Trouve le plus grand facteur premier d'un entier positif 'n', qui est connu pour être le produit de deux nombres premiers distincts.\nLa fonction renvoie le plus grand des deux facteurs premiers.\nExemple :\n(larger-prime-factor 15) Renvoie 5\n(larger-prime-factor 33) Renvoie 11",
      "de": "Findet den größeren Primfaktor einer positiven ganzen Zahl 'n', die als Produkt von zwei verschiedenen Primzahlen bekannt ist. Die Funktion gibt den größeren der beiden Primfaktoren zurück. \n\nBeispiel:\n(larger-prime-factor 15) Gibt 5 zurück\n(larger-prime-factor 33) Gibt 11 zurück",
      "ha": "Yana nemo babbar abin da ke ninka lamba mai kyau na 'n', wanda aka sani cewa yana samuwa daga ninkin lambobi biyu masu kyau daban-daban.\nAikin yana dawo da babbar daga cikin lambobin ninkin guda biyu.\nMisali:\n(larger-prime-factor 15) Yana dawowa 5\n(larger-prime-factor 33) Yana dawowa 11",
      "hi": "दो भिन्न अभाज्य संख्याओं के गुणनफल के रूप में ज्ञात एक धनात्मक पूर्णांक 'n' के बड़े अभाज्य गुणक को खोजता है। \nयह फ़ंक्शन दो अभाज्य गुणकों में से बड़े को लौटाता है।\n\nउदाहरण:\n(larger-prime-factor 15) 5 लौटाता है\n(larger-prime-factor 33) 11 लौटाता है",
      "hu": "Megkeresi egy pozitív egész szám 'n' nagyobb prímtényezőjét, amelyről ismert, hogy két különböző prímszám szorzata.\nA függvény visszaadja a két prímtényező közül a nagyobbat.\nPélda:\n(larger-prime-factor 15) Visszaadja 5\n(larger-prime-factor 33) Visszaadja 11"
    },
    "docstring_bertscore": {
      "sq": "0.9776258766194681",
      "hy": "0.9714623758959555",
      "bn": "0.9660691637900962",
      "bg": "0.9951985077992437",
      "zh": "0.9434473483244139",
      "fr": "0.9820660601571221",
      "de": "0.9738888446306777",
      "ha": "0.9856380302992724",
      "hi": "0.9897308093004963",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/26",
    "prompt": {
      "en": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n;; 'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\n;; The function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\n;; Example:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Returns 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Returns 0",
      "sq": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analizon një orar javor për të gjetur ditën kur Binbin do të jetë më e pakënaqur.\n;; 'weekly-schedule' është një listë me shtatë çifte (një për çdo ditë) që përfaqësojnë orët e shkollës dhe orët e klasave shtesë.\n;; Funksioni kthen ditën e javës (1-7) në të cilën Binbin është më e pakënaqur, ose 0 nëse ajo nuk është e pakënaqur asnjë ditë.\n;; Shembull:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Kthen 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Kthen 0",
      "hy": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Վերլուծում է շաբաթական ժամանակացույցը՝ պարզելու, թե որ օրը Բինբինը կլինի ամենաանհաջող:\n;; 'weekly-schedule'-ը յոթ զույգերի ցուցակ է (յուրաքանչյուր օրվա համար մեկ)՝ ներկայացնելով դպրոցական ժամերը և լրացուցիչ դասերի ժամերը:\n;; Ֆունկցիան վերադարձնում է շաբաթվա օրը (1-7), երբ Բինբինը ամենաանհաջող է, կամ 0, եթե նա ոչ մի օր անհաջող չէ:\n;; Օրինակ:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Վերադարձնում է 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Վերադարձնում է 0",
      "bn": "(defun day-of-max-unhappiness (weekly-schedule)\n;; একটি সাপ্তাহিক সময়সূচী বিশ্লেষণ করে বের করে যে দিন বিনবিন সবচেয়ে বেশি অখুশি হবে।\n;; 'weekly-schedule' হল সাতটি জোড়ার একটি তালিকা (প্রতিটি দিনের জন্য একটি) যা স্কুলের ঘণ্টা এবং অতিরিক্ত ক্লাসের ঘণ্টা উপস্থাপন করে।\n;; ফাংশনটি সেই সপ্তাহের দিন (1-7) ফেরত দেয় যেদিন বিনবিন সবচেয়ে বেশি অখুশি, অথবা 0 যদি সে কোনো দিন অখুশি না হয়।\n;; উদাহরণ:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; 3 ফেরত দেয়\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; 0 ফেরত দেয়",
      "bg": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Анализира седмичен график, за да открие деня, в който Бинбин ще бъде най-нещастна.\n;; 'weekly-schedule' е списък от седем двойки (по една за всеки ден), представляващи учебни часове и часове за допълнителни класове.\n;; Функцията връща деня от седмицата (1-7), в който Бинбин е най-нещастна, или 0, ако тя не е нещастна нито един ден.\n;; Пример:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Връща 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Връща 0",
      "zh": "(defun day-of-max-unhappiness (weekly-schedule)\n;; 分析每周的日程安排，以找出彬彬最不开心的那一天。\n;; 'weekly-schedule' 是一个包含七对元素的列表（每一天对应一对），表示上学时间和额外课程时间。\n;; 该函数返回彬彬最不开心的那一天的星期几（1-7），如果她没有任何一天不开心，则返回0。\n;; 示例:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; 返回 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; 返回 0",
      "fr": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analyse un emploi du temps hebdomadaire pour déterminer le jour où Binbin sera le plus malheureux.\n;; 'weekly-schedule' est une liste de sept paires (une pour chaque jour) représentant les heures d'école et les heures de cours supplémentaires.\n;; La fonction renvoie le jour de la semaine (1-7) où Binbin est le plus malheureux, ou 0 si elle n'est pas malheureuse un jour quelconque.\n;; Exemple:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Renvoie 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Renvoie 0",
      "de": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analysiert einen Wochenplan, um herauszufinden, an welchem Tag Binbin am unglücklichsten sein wird.\n;; 'weekly-schedule' ist eine Liste von sieben Paaren (eines für jeden Tag), die Schulstunden und zusätzliche Unterrichtsstunden darstellen.\n;; Die Funktion gibt den Wochentag (1-7) zurück, an dem Binbin am unglücklichsten ist, oder 0, wenn sie an keinem Tag unglücklich ist.\n;; Beispiel:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Gibt 3 zurück\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Gibt 0 zurück",
      "ha": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Yana nazarin jadawalin mako-mako don gano ranar da Binbin za ta fi jin bakin ciki.\n;; 'weekly-schedule' jerin ma'aurata ne guda bakwai (daya don kowace rana) suna wakiltar awanni makaranta da awanni karin aji.\n;; Aikin yana mayar da ranar mako (1-7) a kan wacce Binbin ta fi jin bakin ciki, ko 0 idan ba ta jin bakin ciki kowace rana.\n;; Misali:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Yana mayar da 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Yana mayar da 0",
      "hi": "(defun day-of-max-unhappiness (weekly-schedule)\n;; एक साप्ताहिक कार्यक्रम का विश्लेषण करता है ताकि यह पता लगाया जा सके कि बिनबिन किस दिन सबसे अधिक दुखी होगी।\n;; 'weekly-schedule' सात जोड़ों की एक सूची है (प्रत्येक दिन के लिए एक) जो स्कूल के घंटे और अतिरिक्त कक्षा के घंटे दर्शाती है।\n;; यह फ़ंक्शन उस सप्ताह के दिन (1-7) को लौटाता है जिस दिन बिनबिन सबसे अधिक दुखी होती है, या 0 अगर वह किसी भी दिन दुखी नहीं है।\n;; उदाहरण:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; 3 लौटाता है\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; 0 लौटाता है",
      "hu": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Elemzi a heti időbeosztást, hogy megtudja, melyik napon lesz Binbin a legboldogtalanabb.\n;; A 'weekly-schedule' egy hét párból álló lista (minden napra egy), amely az iskolai órákat és a plusz órákat képviseli.\n;; A függvény visszaadja a hét napját (1-7), amelyen Binbin a legboldogtalanabb, vagy 0-t, ha egy nap sem boldogtalan.\n;; Példa:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Visszaadja: 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Visszaadja: 0"
    },
    "prompt_bertscore": {
      "sq": "0.9949174458100792",
      "hy": "0.9799476671433849",
      "bn": "0.9826724787104215",
      "bg": "0.9816689980254333",
      "zh": "0.9406583791443031",
      "fr": "0.9889873357842827",
      "de": "0.9738137623466465",
      "ha": "0.9758157579570972",
      "hi": "0.9748490238926004",
      "hu": "0.9449378707036997"
    },
    "canonical_solution": "(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))",
    "instruction": {
      "en": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nՏվեք Common Lisp կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar Common Lisp a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9131842221003194",
      "bn": "0.8685243658588161",
      "bg": "0.8335809119663965",
      "zh": "0.8724534734260673",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.8999461030954872",
      "hi": "0.8898221112045199",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun test-day-of-max-unhappiness ()\n(assert (equal (day-of-max-unhappiness '((5 3) (6 2) (7 2) (5 3) (5 4) (0 4) (0 6))) 3))\n(assert (equal (day-of-max-unhappiness '((4 4) (4 4) (4 4) (4 4) (4 4) (4 4) (4 4))) 0))\n(assert (equal (day-of-max-unhappiness '((3 3) (3 3) (3 3) (3 3) (3 3) (3 3) (3 3))) 0))\n(assert (equal (day-of-max-unhappiness '((2 6) (3 5) (4 4) (5 3) (6 2) (7 1) (1 7))) 0))\n(assert (equal (day-of-max-unhappiness '((5 0) (0 5) (6 3) (3 6) (2 7) (7 2) (4 4))) 3)))\n(test-day-of-max-unhappiness)",
    "entry_point": "day-of-max-unhappiness",
    "signature": "(defun day-of-max-unhappiness (weekly-schedule)",
    "docstring": {
      "en": "Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0",
      "sq": "Analizon një orar javor për të gjetur ditën kur Binbin do të jetë më e pakënaqur.\n'weekly-schedule' është një listë me shtatë çifte (një për çdo ditë) që përfaqësojnë orët e shkollës dhe orët e klasave shtesë.\nFunksioni kthen ditën e javës (1-7) në të cilën Binbin është më e pakënaqur, ose 0 nëse ajo nuk është e pakënaqur asnjë ditë.\nShembull:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Kthen 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Kthen 0",
      "hy": "Վերլուծում է շաբաթական ժամանակացույցը՝ պարզելու համար, թե որ օրը Բինբինը կլինի ամենաանհաջողը:\n'weekly-schedule'-ը ցուցակ է յոթ զույգերով (յուրաքանչյուր օրվա համար մեկ)՝ ներկայացնելով դպրոցական ժամերը և լրացուցիչ դասերի ժամերը:\nՖունկցիան վերադարձնում է շաբաթվա օրը (1-7), երբ Բինբինը ամենաանհաջողն է, կամ 0, եթե նա ոչ մի օր դժգոհ չէ:\nՕրինակ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Վերադարձնում է 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Վերադարձնում է 0",
      "bn": "সপ্তাহিক সময়সূচী বিশ্লেষণ করে বের করা যে দিনটিতে বিনবিন সবচেয়ে অসুখী হবে। \n'weekly-schedule' হল সাতটি জোড়ার একটি তালিকা (প্রতিটি দিনের জন্য একটি) যা স্কুলের ঘণ্টা এবং অতিরিক্ত ক্লাসের ঘণ্টা উপস্থাপন করে। \nফাংশনটি সেই সপ্তাহের দিনটি (১-৭) ফেরত দেয় যেদিন বিনবিন সবচেয়ে অসুখী, অথবা ০ যদি সে কোনো দিনই অসুখী না হয়। \nউদাহরণ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0",
      "bg": "Анализира седмичен график, за да открие деня, в който Бинбин ще бъде най-нещастна.\n'weekly-schedule' е списък от седем двойки (по една за всеки ден), представляващи учебни часове и часове за допълнителни класове.\nФункцията връща деня от седмицата (1-7), в който Бинбин е най-нещастна, или 0, ако тя не е нещастна нито един ден.\nПример:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Връща 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Връща 0",
      "zh": "分析一个每周的日程安排，以找出哪一天彬彬会最不开心。  \n'weekly-schedule' 是一个包含七对元素的列表（每一天对应一对），表示学校时间和额外课程时间。  \n该函数返回彬彬最不开心的那一天（1-7），如果她没有哪天不开心，则返回0。  \n示例：  \n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) 返回 3  \n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) 返回 0",
      "fr": "Analyse un emploi du temps hebdomadaire pour déterminer le jour où Binbin sera le plus malheureux.\n'weekly-schedule' est une liste de sept paires (une pour chaque jour) représentant les heures d'école et les heures de cours supplémentaires.\nLa fonction renvoie le jour de la semaine (1-7) où Binbin est le plus malheureux, ou 0 si elle n'est pas malheureuse un jour quelconque.\nExemple:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Renvoie 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Renvoie 0",
      "de": "Analysiert einen Wochenplan, um herauszufinden, an welchem Tag Binbin am unglücklichsten sein wird.\n'weekly-schedule' ist eine Liste von sieben Paaren (eines für jeden Tag), die Schulstunden und zusätzliche Unterrichtsstunden darstellen.\nDie Funktion gibt den Wochentag (1-7) zurück, an dem Binbin am unglücklichsten ist, oder 0, wenn sie an keinem Tag unglücklich ist.\nBeispiel:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Gibt 3 zurück\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Gibt 0 zurück",
      "ha": "Analiza jadawalin mako-mako don gano ranar da Binbin zai fi rashin jin daɗi.\n'weekly-schedule' jerin nau'i-nau'i guda bakwai ne (daya ga kowace rana) wanda ke wakiltar awanni na makaranta da awanni na karin aji.\nAikin yana dawo da ranar mako (1-7) a kan wacce Binbin zai fi rashin jin daɗi, ko 0 idan ba ta jin rashin jin daɗi a kowace rana.\n\nMisali:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0",
      "hi": "साप्ताहिक अनुसूची का विश्लेषण करता है ताकि यह पता लगाया जा सके कि किस दिन बिनबिन सबसे अधिक दुखी होगी।\n'weekly-schedule' सात जोड़ों की एक सूची है (प्रत्येक दिन के लिए एक) जो स्कूल के घंटे और अतिरिक्त कक्षा के घंटे दर्शाती है।\nयह फ़ंक्शन उस सप्ताह के दिन (1-7) को लौटाता है जिस दिन बिनबिन सबसे अधिक दुखी होती है, या 0 यदि वह किसी दिन दुखी नहीं होती है।\nउदाहरण:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0",
      "hu": "Elemzi a heti időbeosztást, hogy megtudja, melyik napon lesz Binbin a legboldogtalanabb.\nA 'weekly-schedule' egy hét párból álló lista (egy minden napra), amely az iskolai órákat és a plusz órákat képviseli.\nA függvény visszaadja a hét azon napját (1-7), amelyen Binbin a legboldogtalanabb, vagy 0-t, ha egyik napon sem boldogtalan.\nPélda:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Visszaadja: 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Visszaadja: 0"
    },
    "docstring_bertscore": {
      "sq": "0.992706888299542",
      "hy": "0.9824655058533832",
      "bn": "0.9841016243019676",
      "bg": "0.9860702500084043",
      "zh": "0.9232168440160106",
      "fr": "0.9842305354192592",
      "de": "0.9668553428382324",
      "ha": "0.985003406231866",
      "hi": "0.9850365775054988",
      "hu": "0.9542836287617722"
    }
  },
  {
    "task_id": "Common Lisp/27",
    "prompt": {
      "en": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7",
      "sq": "(defun calculate-year-end-amount (monthly-budgets)\n;; Llogarit nëse Jinjin mund të ndjekë planin e saj të kursimeve pa mbetur pa para në asnjë muaj.\n;; 'monthly-budgets' është një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n;; Nëse është e suksesshme, kthen shumën totale të parave që Jinjin do të ketë deri në fund të vitit, duke përfshirë 20% interes mbi kursimet.\n;; Përndryshe, kthen -X, ku X është muaji i parë që Jinjin mbetet pa para.\n;; Shembull:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Kthen -7",
      "hy": "(defun calculate-year-end-amount (monthly-budgets)\n;; Հաշվում է՝ արդյոք Ջինջինը կարող է հետևել իր խնայողությունների պլանին՝ առանց որևէ ամսում գումարը սպառելու:\n;; 'monthly-budgets' ցուցակը 12 ամբողջ թվերի ցուցակ է, որը ներկայացնում է Ջինջինի ամսական բյուջեն:\n;; Եթե հաջող է, վերադարձնում է գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում՝ ներառյալ խնայողությունների 20% տոկոսադրույքը:\n;; Հակառակ դեպքում, վերադարձնում է -X, որտեղ X-ը այն առաջին ամիսն է, երբ Ջինջինը սպառվում է գումարից:\n;; Օրինակ:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Վերադարձնում է -7",
      "bn": "(defun calculate-year-end-amount (monthly-budgets)\n;; হিসাব করে যে জিনজিন তার সঞ্চয় পরিকল্পনা অনুসরণ করতে পারে কিনা কোনো মাসে টাকা শেষ না করে।\n;; 'monthly-budgets' একটি তালিকা যা জিনজিনের মাসিক বাজেটের ১২টি পূর্ণসংখ্যা উপস্থাপন করে।\n;; যদি সফল হয়, তাহলে বছরের শেষে জিনজিনের মোট অর্থের পরিমাণ ফেরত দেয়, সঞ্চয়ের উপর ২০% সুদ সহ।\n;; অন্যথায়, -X ফেরত দেয়, যেখানে X হল প্রথম মাস যখন জিনজিনের টাকা শেষ হয়ে যায়।\n;; উদাহরণ:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; -7 ফেরত দেয়",
      "bg": "(defun calculate-year-end-amount (monthly-budgets)\n;; Изчислява дали Джинджин може да следва своя план за спестявания, без да остане без пари в който и да е месец.\n;; 'monthly-budgets' е списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n;; Ако е успешно, връща общата сума пари, която Джинджин ще има до края на годината, включително 20% лихва върху спестяванията.\n;; В противен случай връща -X, където X е първият месец, в който Джинджин остава без пари.\n;; Пример:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Връща -7",
      "zh": "(defun calculate-year-end-amount (monthly-budgets)\n;; 计算金金是否可以按照她的储蓄计划而不在任何一个月用完钱。\n;; 'monthly-budgets' 是一个包含12个整数的列表，代表金金每月的预算。\n;; 如果成功，返回金金到年底时将拥有的总金额，包括储蓄的20%利息。\n;; 否则，返回 -X，其中 X 是金金用完钱的第一个月份。\n;; 例子:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; 返回 -7",
      "fr": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calcule si Jinjin peut suivre son plan d'épargne sans manquer d'argent au cours d'un mois.\n;; 'monthly-budgets' est une liste de 12 entiers représentant le budget mensuel de Jinjin.\n;; Si réussi, retourne le montant total d'argent que Jinjin aura à la fin de l'année, y compris 20% d'intérêt sur les économies.\n;; Sinon, retourne -X, où X est le premier mois où Jinjin manque d'argent.\n;; Exemple:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Retourne -7",
      "de": "(defun calculate-year-end-amount (monthly-budgets)\n;; Berechnet, ob Jinjin ihren Sparplan einhalten kann, ohne in einem Monat kein Geld mehr zu haben.\n;; 'monthly-budgets' ist eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n;; Bei Erfolg wird der Gesamtbetrag zurückgegeben, den Jinjin bis zum Jahresende haben wird, einschließlich 20% Zinsen auf die Ersparnisse.\n;; Andernfalls wird -X zurückgegeben, wobei X der erste Monat ist, in dem Jinjin kein Geld mehr hat.\n;; Beispiel:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Gibt -7 zurück",
      "ha": "(defun calculate-year-end-amount (monthly-budgets)\n;; Yana ƙididdige ko Jinjin za ta iya bin shirin ajiyarta ba tare da ƙare kuɗi a kowane wata ba.\n;; 'monthly-budgets' jerin lambobi 12 ne da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n;; Idan an yi nasara, yana dawo da jimlar kuɗin da Jinjin za ta samu zuwa ƙarshen shekara, ciki har da riba 20% akan ajiya.\n;; In ba haka ba, yana dawo da -X, inda X shine watan farko da Jinjin ta ƙare da kuɗi.\n;; Misali:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Yana dawo da -7",
      "hi": "(defun calculate-year-end-amount (monthly-budgets)\n;; गणना करता है कि क्या जिनजिन अपनी बचत योजना का पालन कर सकती है बिना किसी महीने में पैसे खत्म किए।\n;; 'monthly-budgets' जिनजिन के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की एक सूची है।\n;; यदि सफल होता है, तो वह कुल राशि लौटाता है जो जिनजिन के पास वर्ष के अंत तक होगी, जिसमें बचत पर 20% ब्याज शामिल है।\n;; अन्यथा, -X लौटाता है, जहाँ X वह पहला महीना है जब जिनजिन के पैसे खत्म हो जाते हैं।\n;; उदाहरण:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; -7 लौटाता है",
      "hu": "(defun calculate-year-end-amount (monthly-budgets)\n;; Kiszámítja, hogy Jinjin követheti-e a megtakarítási tervét anélkül, hogy bármelyik hónapban kifogyna a pénzből.\n;; A 'monthly-budgets' egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelenti.\n;; Siker esetén visszaadja az év végére Jinjin által megtakarított teljes összeget, beleértve a megtakarításokra vonatkozó 20%-os kamatot.\n;; Ellenkező esetben visszaadja -X-et, ahol X az első hónap, amikor Jinjin kifogy a pénzből.\n;; Példa:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Visszaadja -7"
    },
    "prompt_bertscore": {
      "sq": "0.98988315880275",
      "hy": "0.9627693172699636",
      "bn": "0.9622459262159367",
      "bg": "0.9824917250636798",
      "zh": "0.982600773142868",
      "fr": "0.9856602769019484",
      "de": "0.9732875904672851",
      "ha": "0.9597930396405369",
      "hi": "0.9873470460976966",
      "hu": "0.9642578533454391"
    },
    "canonical_solution": "(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest",
    "instruction": {
      "en": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nՏվեք Common Lisp կոդի կարճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Common Lisp a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9131842221003194",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8921750866982592",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9202179225231458",
      "hi": "0.8808811618629965",
      "hu": "0.9349640433807949"
    },
    "level": "",
    "test": "(defun test-calculate-year-end-amount ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(test-calculate-year-end-amount)",
    "entry_point": "calculate-year-end-amount",
    "signature": "(defun calculate-year-end-amount (monthly-budgets)",
    "docstring": {
      "en": "Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7",
      "sq": "Llogarit nëse Jinjin mund të ndjekë planin e saj të kursimeve pa mbetur pa para në asnjë muaj.\n'monthly-budgets' është një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\nNëse është e suksesshme, kthen shumën totale të parave që Jinjin do të ketë deri në fund të vitit, duke përfshirë 20% interes mbi kursimet.\nPërndryshe, kthen -X, ku X është muaji i parë kur Jinjin mbetet pa para.\nShembull:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Kthen -7",
      "hy": "Հաշվարկում է՝ արդյոք Ջինջինը կարող է հետևել իր խնայողությունների պլանին՝ առանց որևէ ամսում գումարը սպառելու:\n'monthly-budgets' ցուցակ է, որը պարունակում է 12 ամբողջ թիվ, որոնք ներկայացնում են Ջինջինի ամսական բյուջեն:\nԵթե հաջողվում է, վերադարձնում է գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում՝ ներառյալ խնայողությունների 20% տոկոսադրույքը:\nՀակառակ դեպքում, վերադարձնում է -X, որտեղ X-ը այն առաջին ամիսն է, երբ Ջինջինը սպառվում է գումարից:\nՕրինակ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Վերադարձնում է -7",
      "bn": "Jinjin তার সঞ্চয় পরিকল্পনা অনুসরণ করতে পারে কিনা তা গণনা করে, যাতে কোনো মাসে তার টাকা ফুরিয়ে না যায়।\n'monthly-budgets' হল ১২টি পূর্ণসংখ্যার একটি তালিকা যা Jinjin এর মাসিক বাজেটকে উপস্থাপন করে।\nযদি সফল হয়, তবে বছরের শেষে Jinjin এর মোট টাকা ফেরত দেয়, যার মধ্যে সঞ্চয়ের উপর ২০% সুদ অন্তর্ভুক্ত থাকে।\nঅন্যথায়, -X ফেরত দেয়, যেখানে X হল প্রথম মাস যখন Jinjin এর টাকা ফুরিয়ে যায়।\nউদাহরণ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7",
      "bg": "Изчислява дали Джинджин може да следва своя план за спестявания, без да остане без пари в нито един месец.\n'monthly-budgets' е списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\nАко е успешно, връща общата сума пари, която Джинджин ще има до края на годината, включително 20% лихва върху спестяванията.\nВ противен случай, връща -X, където X е първият месец, в който Джинджин остава без пари.\nПример:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Връща -7",
      "zh": "计算金金是否可以在不在任何一个月用完钱的情况下遵循她的储蓄计划。\n'monthly-budgets' 是一个包含12个整数的列表，代表金金每月的预算。\n如果成功，返回金金到年底时将拥有的总金额，包括储蓄的20%利息。\n否则，返回 -X，其中 X 是金金用完钱的第一个月。\n示例：\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) 返回 -7",
      "fr": "Calcule si Jinjin peut suivre son plan d'épargne sans manquer d'argent au cours d'un mois quelconque.\n'monthly-budgets' est une liste de 12 entiers représentant le budget mensuel de Jinjin.\nSi réussi, retourne le montant total d'argent que Jinjin aura à la fin de l'année, y compris 20% d'intérêts sur les économies.\nSinon, retourne -X, où X est le premier mois où Jinjin manque d'argent.\nExemple:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Retourne -7",
      "de": "Berechnet, ob Jinjin ihren Sparplan einhalten kann, ohne in einem Monat kein Geld mehr zu haben.\n'monthly-budgets' ist eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\nWenn erfolgreich, wird der Gesamtbetrag zurückgegeben, den Jinjin bis zum Jahresende haben wird, einschließlich 20% Zinsen auf die Ersparnisse.\nAndernfalls wird -X zurückgegeben, wobei X der erste Monat ist, in dem Jinjin kein Geld mehr hat.\nBeispiel:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Gibt -7 zurück",
      "ha": "Yana lissafin ko Jinjin za ta iya bin shirin ajiyarta ba tare da ta kare da kudi a kowane wata ba.\n'monthly-budgets' jerin lambobi 12 ne da ke wakiltar kasafin kudin wata-wata na Jinjin.\nIdan ya yi nasara, yana mayar da jimlar kudin da Jinjin za ta samu zuwa ƙarshen shekara, ciki har da riba 20% akan ajiyar.\nIn ba haka ba, yana mayar da -X, inda X shine watan farko da Jinjin ta kare da kudi.\nMisali:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Yana mayar da -7",
      "hi": "जांच करता है कि क्या जिनजिन अपनी बचत योजना का पालन कर सकती है बिना किसी महीने में पैसे खत्म किए।\n'monthly-budgets' 12 पूर्णांकों की एक सूची है जो जिनजिन के मासिक बजट का प्रतिनिधित्व करती है।\nयदि सफल होता है, तो वर्ष के अंत तक जिनजिन के पास कुल कितनी राशि होगी, यह 20% ब्याज सहित लौटाता है।\nअन्यथा, -X लौटाता है, जहां X वह पहला महीना है जब जिनजिन के पैसे खत्म हो जाते हैं।\nउदाहरण:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7 लौटाता है।",
      "hu": "Kiszámítja, hogy Jinjin követheti-e megtakarítási tervét anélkül, hogy bármely hónapban kifogyna a pénzből.\nA 'monthly-budgets' egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelenti.\nHa sikeres, visszaadja azt az összeget, amely Jinjin év végére rendelkezésére áll, beleértve a megtakarítások 20%-os kamatát.\nEllenkező esetben visszaadja -X-et, ahol X az első hónap, amikor Jinjin kifogy a pénzből.\nPélda:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Visszaadja -7"
    },
    "docstring_bertscore": {
      "sq": "0.9865423944241243",
      "hy": "0.9776997671212131",
      "bn": "0.9325900130666659",
      "bg": "0.9797551943041621",
      "zh": "0.965572389207128",
      "fr": "0.9648557307923541",
      "de": "0.9595449502946243",
      "ha": "0.9690690784348662",
      "hi": "0.9706315050120866",
      "hu": "0.9704388335424827"
    }
  },
  {
    "task_id": "Common Lisp/28",
    "prompt": {
      "en": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.\n;; Example:\n;; (total-cigarettes-smoked 4 3) ;; Returns 5\n;; (total-cigarettes-smoked 10 4) ;; Returns 13",
      "sq": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Llogarit numrin total të cigareve që Peter mund të pijë.\n;; 'initial-cigarettes' është numri fillestar i cigareve.\n;; 'butt-to-cigarette-ratio' është numri i bishtave të cigareve të nevojshme për të marrë një cigare të re.\n;; Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n;; Shembull:\n;; (total-cigarettes-smoked 4 3) ;; Kthen 5\n;; (total-cigarettes-smoked 10 4) ;; Kthen 13",
      "hy": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Հաշվում է ընդհանուր ծխախոտների քանակը, որ Պետրոսը կարող է ծխել։\n;; 'initial-cigarettes' մեկնարկային ծխախոտների քանակն է։\n;; 'butt-to-cigarette-ratio' ծխախոտի մնացորդների քանակն է, որը պահանջվում է նոր ծխախոտ ստանալու համար։\n;; Ֆունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որ Պետրոսը կարող է ծխել։\n;; Օրինակ:\n;; (total-cigarettes-smoked 4 3) ;; Վերադարձնում է 5\n;; (total-cigarettes-smoked 10 4) ;; Վերադարձնում է 13",
      "bn": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; পিটার মোট কতগুলো সিগারেট খেতে পারবে তা গণনা করে।\n;; 'initial-cigarettes' হল প্রাথমিক সিগারেটের সংখ্যা।\n;; 'butt-to-cigarette-ratio' হল নতুন সিগারেট পেতে প্রয়োজনীয় সিগারেটের অবশিষ্টাংশের সংখ্যা।\n;; ফাংশনটি পিটার মোট কতগুলো সিগারেট খেতে পারবে তা ফেরত দেয়।\n;; উদাহরণ:\n;; (total-cigarettes-smoked 4 3) ;; 5 ফেরত দেয়\n;; (total-cigarettes-smoked 10 4) ;; 13 ফেরত দেয়",
      "bg": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Изчислява общия брой цигари, които Петър може да изпуши.\n;; 'initial-cigarettes' е началният брой цигари.\n;; 'butt-to-cigarette-ratio' е броят на фасовете, необходими за получаване на нова цигара.\n;; Функцията връща общия брой цигари, които Петър може да изпуши.\n;; Пример:\n;; (total-cigarettes-smoked 4 3) ;; Връща 5\n;; (total-cigarettes-smoked 10 4) ;; Връща 13",
      "zh": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; 计算彼得可以抽的香烟总数。\n;; 'initial-cigarettes' 是起始的香烟数量。\n;; 'butt-to-cigarette-ratio' 是获得一支新香烟所需的烟头数量。\n;; 该函数返回彼得可以抽的香烟总数。\n;; 示例：\n;; (total-cigarettes-smoked 4 3) ;; 返回 5\n;; (total-cigarettes-smoked 10 4) ;; 返回 13",
      "fr": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calcule le nombre total de cigarettes que Peter peut fumer.\n;; 'initial-cigarettes' est le nombre initial de cigarettes.\n;; 'butt-to-cigarette-ratio' est le nombre de mégots de cigarette nécessaires pour obtenir une nouvelle cigarette.\n;; La fonction renvoie le nombre total de cigarettes que Peter peut fumer.\n;; Exemple:\n;; (total-cigarettes-smoked 4 3) ;; Renvoie 5\n;; (total-cigarettes-smoked 10 4) ;; Renvoie 13",
      "de": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n;; 'initial-cigarettes' ist die anfängliche Anzahl der Zigaretten.\n;; 'butt-to-cigarette-ratio' ist die Anzahl der Zigarettenstummel, die benötigt werden, um eine neue Zigarette zu bekommen.\n;; Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n;; Beispiel:\n;; (total-cigarettes-smoked 4 3) ;; Gibt 5 zurück\n;; (total-cigarettes-smoked 10 4) ;; Gibt 13 zurück",
      "ha": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Lissafi jimillar adadin sigari da Peter zai iya sha.\n;; 'initial-cigarettes' shine adadin sigari na farko.\n;; 'butt-to-cigarette-ratio' shine adadin bututun sigari da ake bukata don samun sabuwar sigari.\n;; Aikin yana dawowa da jimillar adadin sigari da Peter zai iya sha.\n;; Misali:\n;; (total-cigarettes-smoked 4 3) ;; Yana dawowa 5\n;; (total-cigarettes-smoked 10 4) ;; Yana dawowa 13",
      "hi": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है।\n;; 'initial-cigarettes' सिगरेट की प्रारंभिक संख्या है।\n;; 'butt-to-cigarette-ratio' वह संख्या है जितने सिगरेट बट्स से एक नई सिगरेट मिलती है।\n;; यह फ़ंक्शन वह कुल संख्या लौटाता है जितनी सिगरेट पीटर पी सकता है।\n;; उदाहरण:\n;; (total-cigarettes-smoked 4 3) ;; 5 लौटाता है\n;; (total-cigarettes-smoked 10 4) ;; 13 लौटाता है",
      "hu": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Kiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n;; 'initial-cigarettes' a kezdő cigaretták száma.\n;; 'butt-to-cigarette-ratio' az új cigaretta megszerzéséhez szükséges csikkek száma.\n;; A függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\n;; Példa:\n;; (total-cigarettes-smoked 4 3) ;; Visszaadja 5\n;; (total-cigarettes-smoked 10 4) ;; Visszaadja 13"
    },
    "prompt_bertscore": {
      "sq": "0.9887591094764736",
      "hy": "0.9729368092143775",
      "bn": "0.9908532695837244",
      "bg": "0.9864009695928274",
      "zh": "0.9875605737573091",
      "fr": "0.9924131139659914",
      "de": "0.9947154387125668",
      "ha": "0.9864694970742844",
      "hi": "0.9783024116972729",
      "hu": "0.9900871522040728"
    },
    "canonical_solution": "(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))",
    "instruction": {
      "en": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nՏվյալ Common Lisp կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过 500 个字符。",
      "fr": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.8895658780129849",
      "bn": "0.8671945354577876",
      "bg": "0.8388862829106369",
      "zh": "0.8826614859682123",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9436978212348989",
      "hi": "0.8808811618629965",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun test-total-cigarettes-smoked ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(test-total-cigarettes-smoked)",
    "entry_point": "total-cigarettes-smoked",
    "signature": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13",
      "sq": "Llogarit numrin total të cigareve që Peter mund të pijë.  \n'initial-cigarettes' është numri fillestar i cigareve.  \n'butt-to-cigarette-ratio' është numri i bishtave të cigareve të nevojshme për të marrë një cigare të re.  \nFunksioni kthen numrin total të cigareve që Peter mund të pijë.  \nShembull:  \n(total-cigarettes-smoked 4 3) Kthen 5  \n(total-cigarettes-smoked 10 4) Kthen 13",
      "hy": "Հաշվում է ընդհանուր ծխախոտների քանակը, որոնք Պետերը կարող է ծխել:\n'initial-cigarettes' -ը մեկնարկային ծխախոտների քանակն է:\n'butt-to-cigarette-ratio' -ը ծխախոտի մնացորդների քանակն է, որոնք անհրաժեշտ են նոր ծխախոտ ստանալու համար:\nՖունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որոնք Պետերը կարող է ծխել:\nՕրինակ:\n(total-cigarettes-smoked 4 3) Վերադարձնում է 5\n(total-cigarettes-smoked 10 4) Վերադարձնում է 13",
      "bn": "সর্বমোট কতগুলি সিগারেট পিটার ধূমপান করতে পারে তা গণনা করে।  \n'initial-cigarettes' হল প্রাথমিক সিগারেটের সংখ্যা।  \n'butt-to-cigarette-ratio' হল নতুন সিগারেট পেতে যতগুলি সিগারেটের বাট প্রয়োজন।  \nফাংশনটি পিটার সর্বমোট কতগুলি সিগারেট ধূমপান করতে পারে তা ফেরত দেয়।  \nউদাহরণ:  \n(total-cigarettes-smoked 4 3) ফেরত দেয় 5  \n(total-cigarettes-smoked 10 4) ফেরত দেয় 13  ",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши.\n'initial-cigarettes' е началният брой цигари.\n'butt-to-cigarette-ratio' е броят на фасовете, необходими за получаване на нова цигара.\nФункцията връща общия брой цигари, които Петър може да изпуши.\nПример:\n(total-cigarettes-smoked 4 3) Връща 5\n(total-cigarettes-smoked 10 4) Връща 13",
      "zh": "计算彼得可以抽的香烟总数。  \n'initial-cigarettes' 是起始香烟数量。  \n'butt-to-cigarette-ratio' 是获得一支新香烟所需的烟蒂数量。  \n该函数返回彼得可以抽的香烟总数。  \n示例：  \n(total-cigarettes-smoked 4 3) 返回 5  \n(total-cigarettes-smoked 10 4) 返回 13  ",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer.  \n'initial-cigarettes' est le nombre initial de cigarettes.  \n'butt-to-cigarette-ratio' est le nombre de mégots de cigarette nécessaires pour obtenir une nouvelle cigarette.  \nLa fonction renvoie le nombre total de cigarettes que Peter peut fumer.  \nExemple:\n(total-cigarettes-smoked 4 3) Renvoie 5  \n(total-cigarettes-smoked 10 4) Renvoie 13  ",
      "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n'initial-cigarettes' ist die Anfangsanzahl der Zigaretten.\n'butt-to-cigarette-ratio' ist die Anzahl der Zigarettenstummel, die benötigt werden, um eine neue Zigarette zu bekommen.\nDie Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\nBeispiel:\n(total-cigarettes-smoked 4 3) Gibt 5 zurück\n(total-cigarettes-smoked 10 4) Gibt 13 zurück",
      "ha": "Yana ƙididdige adadin sigari da duka Peter zai iya sha.\n'initial-cigarettes' shine adadin sigari na farko.\n'butt-to-cigarette-ratio' shine adadin bututun sigari da ake buƙata don samun sabon sigari.\nAikin yana dawowa da adadin sigari da duka Peter zai iya sha.\nMisali:\n(total-cigarettes-smoked 4 3) Yana dawowa 5\n(total-cigarettes-smoked 10 4) Yana dawowa 13",
      "hi": "कुल सिगरेट की संख्या की गणना करता है जो पीटर पी सकता है।  \n'initial-cigarettes' प्रारंभिक सिगरेट की संख्या है।  \n'butt-to-cigarette-ratio' वह संख्या है जो एक नई सिगरेट प्राप्त करने के लिए आवश्यक सिगरेट बट्स की है।  \nयह फ़ंक्शन कुल सिगरेट की संख्या लौटाता है जो पीटर पी सकता है।  \nउदाहरण:  \n(total-cigarettes-smoked 4 3) 5 लौटाता है  \n(total-cigarettes-smoked 10 4) 13 लौटाता है  ",
      "hu": "Kiszámítja, hogy összesen hány cigarettát tud elszívni Péter.\n'initial-cigarettes' a kezdő cigaretták száma.\n'butt-to-cigarette-ratio' az a cigarettacsikkek száma, amely szükséges egy új cigaretta megszerzéséhez.\nA függvény visszaadja az összes cigaretták számát, amit Péter el tud szívni.\nPélda:\n(total-cigarettes-smoked 4 3) Visszaadja 5\n(total-cigarettes-smoked 10 4) Visszaadja 13"
    },
    "docstring_bertscore": {
      "sq": "0.9889257603661619",
      "hy": "0.9795194200418738",
      "bn": "0.9867720111446006",
      "bg": "0.9825964032744852",
      "zh": "0.9815035389180312",
      "fr": "0.9814441484341018",
      "de": "0.9929100871793407",
      "ha": "0.9763480873782707",
      "hi": "0.986131229535382",
      "hu": "0.9914018866961428"
    }
  },
  {
    "task_id": "Common Lisp/29",
    "prompt": {
      "en": "(defun divisible-five-digit-numbers (k)\n;; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.\n;; Example:\n;; (divisible-five-digit-numbers 15) ;; Returns (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Returns a list of numbers or 'No' if no such numbers exist",
      "sq": "(defun divisible-five-digit-numbers (k)\n;; Gjen të gjitha numrat pesë-shifrorë midis 10000 dhe 30000 ku tre nën-numra\n;; (të formuar nga shifra të njëpasnjëshme) janë të pjestueshëm me 'k'.\n;; Çdo nën-numër përbëhet nga tre shifra të njëpasnjëshme nga numri origjinal.\n;; Funksioni kthen një listë të tillë numrash pesë-shifrorë.\n;; Shembull:\n;; (divisible-five-digit-numbers 15) ;; Kthen (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Kthen një listë numrash ose 'Jo' nëse nuk ekzistojnë të tillë numra",
      "hy": "(defun divisible-five-digit-numbers (k)\n;; Գտնում է բոլոր հինգանիշ թվերը 10000-ից 30000 միջակայքում, որտեղ երեք ենթաթվերը \n;; (կազմված հաջորդական թվանշաններից) բաժանվում են 'k'-ի վրա:\n;; Յուրաքանչյուր ենթաթիվ կազմված է սկզբնական թվի երեք հաջորդական թվանշաններից:\n;; Ֆունկցիան վերադարձնում է այդպիսի հինգանիշ թվերի ցուցակը:\n;; Օրինակ:\n;; (divisible-five-digit-numbers 15) ;; Վերադարձնում է (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Վերադարձնում է թվերի ցուցակ կամ 'Ոչ' եթե այդպիսի թվեր չկան",
      "bn": "(defun divisible-five-digit-numbers (k)\n;; এমন সব পাঁচ অঙ্কের সংখ্যা খুঁজে বের করে যা 10000 এবং 30000 এর মধ্যে অবস্থিত\n;; যেখানে তিনটি উপ-সংখ্যা (ক্রমাগত অঙ্ক দ্বারা গঠিত) 'k' দ্বারা বিভাজ্য।\n;; প্রতিটি উপ-সংখ্যা মূল সংখ্যার তিনটি ক্রমাগত অঙ্ক নিয়ে গঠিত।\n;; ফাংশনটি এমন পাঁচ অঙ্কের সংখ্যার একটি তালিকা ফেরত দেয়।\n;; উদাহরণ:\n;; (divisible-five-digit-numbers 15) ;; (22555 25555 28555 30000) ফেরত দেয়\n;; (divisible-five-digit-numbers 7) ;; সংখ্যার একটি তালিকা বা 'No' ফেরত দেয় যদি এমন কোনো সংখ্যা না থাকে",
      "bg": "(defun divisible-five-digit-numbers (k)\n;; Намира всички петцифрени числа между 10000 и 30000, при които три подчисла\n;; (образувани от последователни цифри) са делими на 'k'.\n;; Всяко подчисло се състои от три последователни цифри от оригиналното число.\n;; Функцията връща списък с такива петцифрени числа.\n;; Пример:\n;; (divisible-five-digit-numbers 15) ;; Връща (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Връща списък от числа или 'No', ако няма такива числа",
      "zh": "(defun divisible-five-digit-numbers (k)\n;; 查找所有介于10000和30000之间的五位数，其中三个子数字\n;; （由连续的数字组成）能被 'k' 整除。\n;; 每个子数字由原始数字中的三个连续数字组成。\n;; 该函数返回这样的五位数的列表。\n;; 示例：\n;; (divisible-five-digit-numbers 15) ;; 返回 (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; 返回一个数字列表或 'No' 如果不存在这样的数字",
      "fr": "(defun divisible-five-digit-numbers (k)\n;; Trouve tous les nombres à cinq chiffres entre 10000 et 30000 où trois sous-nombres \n;; (formés par des chiffres consécutifs) sont divisibles par 'k'.\n;; Chaque sous-nombre est composé de trois chiffres consécutifs du nombre original.\n;; La fonction renvoie une liste de ces nombres à cinq chiffres.\n;; Exemple:\n;; (divisible-five-digit-numbers 15) ;; Renvoie (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Renvoie une liste de nombres ou 'No' si aucun de ces nombres n'existe",
      "de": "(defun divisible-five-digit-numbers (k)\n;; Findet alle fünfstelligen Zahlen zwischen 10000 und 30000, bei denen drei Teilzahlen \n;; (gebildet durch aufeinanderfolgende Ziffern) durch 'k' teilbar sind.\n;; Jede Teilzahl besteht aus drei aufeinanderfolgenden Ziffern der ursprünglichen Zahl.\n;; Die Funktion gibt eine Liste solcher fünfstelliger Zahlen zurück.\n;; Beispiel:\n;; (divisible-five-digit-numbers 15) ;; Gibt (22555 25555 28555 30000) zurück\n;; (divisible-five-digit-numbers 7) ;; Gibt eine Liste von Zahlen oder 'No' zurück, wenn keine solchen Zahlen existieren",
      "ha": "(defun divisible-five-digit-numbers (k)\n;; Nemi duk lambobin da suka ƙunshi lambobi biyar tsakanin 10000 da 30000 inda lambobi uku \n;; (wanda aka kafa ta lambobi masu jere) suna kasu kashi da 'k'.\n;; Kowace ƙaramar lamba tana ƙunshe da lambobi uku masu jere daga ainihin lambar.\n;; Aikin yana dawowa da jerin irin waɗannan lambobin da suka ƙunshi lambobi biyar.\n;; Misali:\n;; (divisible-five-digit-numbers 15) ;; Yana dawowa (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Yana dawowa da jerin lambobi ko 'A'a' idan babu irin waɗannan lambobin",
      "hi": "(defun divisible-five-digit-numbers (k)\n;; उन सभी पाँच-अंकीय संख्याओं को खोजता है जो 10000 और 30000 के बीच हैं जहाँ तीन उप-संख्याएँ \n;; (लगातार अंकों द्वारा बनाई गई) 'k' से विभाज्य हैं।\n;; प्रत्येक उप-संख्या मूल संख्या से लगातार तीन अंकों से बनी होती है।\n;; फ़ंक्शन ऐसी पाँच-अंकीय संख्याओं की एक सूची लौटाता है।\n;; उदाहरण:\n;; (divisible-five-digit-numbers 15) ;; (22555 25555 28555 30000) लौटाता है\n;; (divisible-five-digit-numbers 7) ;; संख्याओं की एक सूची लौटाता है या 'No' अगर ऐसी कोई संख्या मौजूद नहीं है",
      "hu": "(defun divisible-five-digit-numbers (k)\n;; Megtalálja az összes ötjegyű számot 10000 és 30000 között, ahol három részszám\n;; (egymást követő számjegyekből képzett) osztható 'k'-val.\n;; Minden részszám az eredeti szám három egymást követő számjegyéből áll.\n;; A függvény visszaad egy listát az ilyen ötjegyű számokról.\n;; Példa:\n;; (divisible-five-digit-numbers 15) ;; Visszaadja: (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Visszaad egy számok listáját vagy 'No'-t, ha nem léteznek ilyen számok"
    },
    "prompt_bertscore": {
      "sq": "0.9931655258493516",
      "hy": "0.9416046542795532",
      "bn": "0.967479042234682",
      "bg": "0.9875190600076728",
      "zh": "0.9755710453276623",
      "fr": "0.9857182769732105",
      "de": "0.9937705539899838",
      "ha": "0.9508348094558634",
      "hi": "0.9897602065968895",
      "hu": "0.9890628153290759"
    },
    "canonical_solution": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))",
    "instruction": {
      "en": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nՏվեք Common Lisp կոդի կարճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用不超过500个字符的中文。",
      "fr": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9464661328553821",
      "hy": "0.9162655752013136",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8675367756043106",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9670521855458379",
      "hi": "0.8898221112045199",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun test-divisible-five-digit-numbers ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(test-divisible-five-digit-numbers)",
    "entry_point": "divisible-five-digit-numbers",
    "signature": "(defun divisible-five-digit-numbers (k)",
    "docstring": {
      "en": "Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist",
      "sq": "Gjen të gjitha numrat pesë-shifrorë midis 10000 dhe 30000 ku tre nën-numra \n(të formuar nga shifra të njëpasnjëshme) janë të pjestueshëm me 'k'.\nÇdo nën-numër përbëhet nga tre shifra të njëpasnjëshme nga numri origjinal.\nFunksioni kthen një listë të tillë numrash pesë-shifrorë.\nShembull:\n(divisible-five-digit-numbers 15) Kthen (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Kthen një listë numrash ose 'Jo' nëse nuk ekzistojnë numra të tillë",
      "hy": "Գտնում է բոլոր հնգանիշ թվերը 10000-ից 30000 միջակայքում, որտեղ երեք ենթաթվերը \n(կազմված հաջորդական թվանշաններից) բաժանվում են 'k'-ի վրա:\nՅուրաքանչյուր ենթաթիվ կազմված է սկզբնական թվի երեք հաջորդական թվանշաններից:\nՖունկցիան վերադարձնում է նման հնգանիշ թվերի ցուցակը:\nՕրինակ:\n(divisible-five-digit-numbers 15) Վերադարձնում է (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Վերադարձնում է թվերի ցուցակ կամ 'Ոչ' եթե նման թվեր չկան",
      "bn": "10000 এবং 30000 এর মধ্যে সমস্ত পাঁচ-অঙ্কের সংখ্যা খুঁজে বের করে যেখানে তিনটি উপ-সংখ্যা (ক্রমাগত অঙ্ক দ্বারা গঠিত) 'k' দ্বারা বিভাজ্য। \nপ্রতিটি উপ-সংখ্যা মূল সংখ্যার তিনটি ক্রমাগত অঙ্ক নিয়ে গঠিত। \nফাংশনটি এই ধরনের পাঁচ-অঙ্কের সংখ্যার একটি তালিকা প্রদান করে। \nউদাহরণ:\n(divisible-five-digit-numbers 15) প্রদান করে (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) সংখ্যা বা 'No' প্রদান করে যদি এমন কোনো সংখ্যা না থাকে",
      "bg": "Намира всички петцифрени числа между 10000 и 30000, където три под-числа (образувани от последователни цифри) са делими на 'k'. Всяко под-число се състои от три последователни цифри от оригиналното число. Функцията връща списък с такива петцифрени числа. Пример: (divisible-five-digit-numbers 15) Връща (22555 25555 28555 30000) (divisible-five-digit-numbers 7) Връща списък с числа или 'No', ако такива числа не съществуват.",
      "zh": "查找10000到30000之间的所有五位数，其中三个子数字（由连续数字组成）可以被 'k' 整除。\n每个子数字由原始数字中的三个连续数字组成。\n该函数返回这样五位数的列表。\n示例：\n(divisible-five-digit-numbers 15) 返回 (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) 返回一个数字列表或 'No' 如果不存在这样的数字",
      "fr": "Trouve tous les nombres à cinq chiffres entre 10000 et 30000 où trois sous-nombres (formés par des chiffres consécutifs) sont divisibles par 'k'. Chaque sous-nombre se compose de trois chiffres consécutifs du nombre original. La fonction renvoie une liste de ces nombres à cinq chiffres. Exemple : (divisible-five-digit-numbers 15) Renvoie (22555 25555 28555 30000) (divisible-five-digit-numbers 7) Renvoie une liste de nombres ou 'No' si aucun de ces nombres n'existe.",
      "de": "Findet alle fünfstelligen Zahlen zwischen 10000 und 30000, bei denen drei Teilzahlen (gebildet durch aufeinanderfolgende Ziffern) durch 'k' teilbar sind. Jede Teilzahl besteht aus drei aufeinanderfolgenden Ziffern der ursprünglichen Zahl. Die Funktion gibt eine Liste solcher fünfstelligen Zahlen zurück. Beispiel: (divisible-five-digit-numbers 15) Gibt (22555 25555 28555 30000) zurück (divisible-five-digit-numbers 7) Gibt eine Liste von Zahlen oder 'Nein' zurück, wenn keine solchen Zahlen existieren.",
      "ha": "Nemo duk lambobin da suka ƙunshi haruffa biyar tsakanin 10000 da 30000 inda lambobi uku (wanda aka samar da su ta hanyar lambobi masu jere) suna raba 'k'. Kowanne lamba uku ya ƙunshi lambobi uku masu jere daga asalin lambar. Aikin yana dawowa da jerin irin waɗannan lambobin da suka ƙunshi haruffa biyar. Misali: (divisible-five-digit-numbers 15) Yana dawowa (22555 25555 28555 30000) (divisible-five-digit-numbers 7) Yana dawowa da jerin lambobi ko 'A'a' idan babu irin waɗannan lambobin da suke akwai",
      "hi": "10000 और 30000 के बीच सभी पाँच-अंकीय संख्याएँ खोजता है जहाँ तीन उप-संख्याएँ \n(लगातार अंकों द्वारा बनाई गई) 'k' द्वारा विभाज्य हैं।\nप्रत्येक उप-संख्या मूल संख्या से लगातार तीन अंकों से बनी होती है।\nयह फ़ंक्शन ऐसी पाँच-अंकीय संख्याओं की एक सूची लौटाता है।\nउदाहरण:\n(divisible-five-digit-numbers 15) लौटाता है (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) संख्याओं की एक सूची लौटाता है या 'No' यदि ऐसी कोई संख्या मौजूद नहीं है",
      "hu": "Megtalálja az összes ötjegyű számot 10000 és 30000 között, ahol három részszám \n(egymást követő számjegyekből képzett) osztható 'k'-val.\nMinden részszám az eredeti szám három egymást követő számjegyéből áll.\nA függvény visszaad egy listát az ilyen ötjegyű számokról.\nPélda:\n(divisible-five-digit-numbers 15) Visszaadja (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Visszaad egy számokból álló listát vagy 'No'-t, ha nem léteznek ilyen számok."
    },
    "docstring_bertscore": {
      "sq": "0.9859898047040851",
      "hy": "0.9741053517460058",
      "bn": "0.9218443080830594",
      "bg": "0.9882645198276967",
      "zh": "0.9586566752306364",
      "fr": "0.980210256507113",
      "de": "0.9946957743048443",
      "ha": "0.9616975077338994",
      "hi": "0.9499977810301824",
      "hu": "0.9847324743921344"
    }
  },
  {
    "task_id": "Common Lisp/30",
    "prompt": {
      "en": "(defun count-digit-two (L R)\n;; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.\n;; Example:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "sq": "(defun count-digit-two (L R)\n;; Kjo funksion numëron shfaqjet e shifrës '2' në të gjitha numrat brenda një diapazoni të dhënë [L, R].\n;; Të dy L dhe R janë përfshirës.\n;; Ai iteron nëpër secilin numër në diapazon dhe numëron sa herë shfaqet '2' në secilin numër.\n;; Shembull:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "hy": "(defun count-digit-two (L R)\n;; Այս ֆունկցիան հաշվում է '2' թվանշանի հանդիպումների քանակը տրված միջակայքում [L, R] գտնվող բոլոր ամբողջ թվերում:\n;; Ե՛վ L, և՛ R ներառյալ են:\n;; Այն անցնում է միջակայքի յուրաքանչյուր թվով և հաշվում, թե քանի անգամ '2' է հայտնվում յուրաքանչյուր թվում:\n;; Օրինակ:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "bn": "(defun count-digit-two (L R)\n;; এই ফাংশনটি একটি নির্দিষ্ট পরিসর [L, R] এর মধ্যে সকল পূর্ণসংখ্যায় অঙ্ক '2' এর উপস্থিতি গণনা করে।\n;; উভয় L এবং R অন্তর্ভুক্ত।\n;; এটি পরিসরের প্রতিটি সংখ্যার মধ্য দিয়ে পুনরাবৃত্তি করে এবং প্রতিটি সংখ্যায় '2' কতবার উপস্থিত হয় তা গণনা করে।\n;; উদাহরণ:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "bg": "(defun count-digit-two (L R)\n;; Тази функция брои появяванията на цифрата '2' във всички цели числа в даден диапазон [L, R].\n;; И L, и R са включени.\n;; Тя преминава през всяко число в диапазона и брои колко пъти '2' се появява във всяко число.\n;; Пример:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "zh": "(defun count-digit-two (L R)\n;; 此函数计算给定范围 [L, R] 内所有整数中数字 '2' 的出现次数。\n;; L 和 R 都是包含在内的。\n;; 它遍历范围内的每个数字，并计算每个数字中出现 '2' 的次数。\n;; 示例:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "fr": "(defun count-digit-two (L R)\n;; Cette fonction compte les occurrences du chiffre '2' dans tous les entiers d'un intervalle donné [L, R].\n;; L et R sont tous deux inclusifs.\n;; Elle parcourt chaque nombre de l'intervalle et compte combien de fois '2' apparaît dans chaque nombre.\n;; Exemple:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "de": "(defun count-digit-two (L R)\n;; Diese Funktion zählt die Vorkommen der Ziffer '2' in allen Ganzzahlen innerhalb eines gegebenen Bereichs [L, R].\n;; Sowohl L als auch R sind inklusive.\n;; Sie iteriert durch jede Zahl im Bereich und zählt, wie oft '2' in jeder Zahl erscheint.\n;; Beispiel:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "ha": "(defun count-digit-two (L R)\n;; Wannan aikin yana ƙirga yawan fitowar lamba '2' a cikin dukkan lambobi a cikin kewayon da aka bayar [L, R].\n;; Duk L da R suna ciki.\n;; Yana zagayawa ta kowanne lamba a cikin kewayon kuma yana ƙirga sau nawa '2' ta bayyana a kowanne lamba.\n;; Misali:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "hi": "(defun count-digit-two (L R)\n;; यह फ़ंक्शन दिए गए रेंज [L, R] के भीतर सभी पूर्णांकों में अंक '2' की घटनाओं की गिनती करता है।\n;; दोनों L और R सम्मिलित हैं।\n;; यह रेंज में प्रत्येक संख्या के माध्यम से इटररेट करता है और गिनता है कि प्रत्येक संख्या में '2' कितनी बार दिखाई देता है।\n;; उदाहरण:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "hu": "(defun count-digit-two (L R)\n;; Ez a függvény megszámolja a '2' számjegy előfordulásait az összes egész szám között egy adott [L, R] tartományban.\n;; Mind L, mind R beleértendő.\n;; Végigmegy a tartomány minden számán, és megszámolja, hogy hányszor jelenik meg a '2' az egyes számokban.\n;; Példa:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9"
    },
    "prompt_bertscore": {
      "sq": "0.994864610128724",
      "hy": "0.990748591372919",
      "bn": "0.9957723509700535",
      "bg": "0.9926445183598971",
      "zh": "0.9780227401207758",
      "fr": "0.9898195970808189",
      "de": "0.995536179447003",
      "ha": "0.991664674690252",
      "hi": "0.9966536739707053",
      "hu": "0.9845165631679494"
    },
    "canonical_solution": "(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))",
    "instruction": {
      "en": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过 500 个字符。",
      "fr": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8685243658588161",
      "bg": "0.8335809119663965",
      "zh": "0.8707825946608018",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9543551356989448",
      "hi": "0.8822235059780303",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun test-count-digit-two ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(test-count-digit-two)",
    "entry_point": "count-digit-two",
    "signature": "(defun count-digit-two (L R)",
    "docstring": {
      "en": "This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "sq": "Kjo funksion numëron shfaqjet e shifrës '2' në të gjitha numrat e plotë brenda një intervali të dhënë [L, R].\nTë dy L dhe R janë përfshirës.\nAjo iteron nëpër çdo numër në interval dhe numëron sa herë '2' shfaqet në secilin numër.\nShembull:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "hy": "Այս ֆունկցիան հաշվում է '2' թվանշանի հանդիպումները տրված միջակայքում [L, R] գտնվող բոլոր ամբողջ թվերի մեջ: \nԵ՛վ L, և՛ R ներառյալ են: \nԱյն անցնում է միջակայքի յուրաքանչյուր թվի միջով և հաշվում, թե քանի անգամ է '2'-ը հանդիպում յուրաքանչյուր թվի մեջ: \nՕրինակ:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "bn": "এই ফাংশনটি একটি প্রদত্ত সীমার [L, R] মধ্যে সমস্ত পূর্ণসংখ্যায় ডিজিট '2' এর উপস্থিতি গণনা করে। \nউভয় L এবং R অন্তর্ভুক্ত। \nএটি সীমার প্রতিটি সংখ্যার মধ্য দিয়ে পুনরাবৃত্তি করে এবং প্রতিটি সংখ্যায় '2' কতবার উপস্থিত হয়েছে তা গণনা করে। \nউদাহরণ:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "bg": "Тази функция брои появяванията на цифрата '2' във всички цели числа в даден диапазон [L, R]. И L, и R са включени. Тя преминава през всяко число в диапазона и брои колко пъти '2' се появява във всяко число. Пример: >>> count-digit-two 2 22 6 >>> count-digit-two 10 25 9",
      "zh": "该函数计算给定范围 [L, R] 内所有整数中数字 '2' 出现的次数。  \nL 和 R 都是包含在内的。  \n它遍历范围内的每个数字，并计算每个数字中 '2' 出现的次数。  \n示例:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "fr": "Cette fonction compte les occurrences du chiffre '2' dans tous les entiers d'un intervalle donné [L, R].\nLes deux L et R sont inclusifs.\nElle parcourt chaque nombre de l'intervalle et compte combien de fois '2' apparaît dans chaque nombre.\nExemple:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "de": "Diese Funktion zählt die Vorkommen der Ziffer '2' in allen ganzen Zahlen innerhalb eines gegebenen Bereichs [L, R].\nSowohl L als auch R sind inklusive.\nSie iteriert durch jede Zahl im Bereich und zählt, wie oft '2' in jeder Zahl erscheint.\nBeispiel:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "ha": "Wannan aikin yana ƙirga yawan bayyanar lamba '2' a cikin dukkan lambobi a cikin kewayon da aka bayar [L, R]. \nDuka L da R suna ciki. \nYana zagayawa ta kowace lamba a cikin kewayon kuma yana ƙirga sau nawa '2' ya bayyana a kowace lamba. \nMisali:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "hi": "इस फ़ंक्शन में दिए गए सीमा [L, R] के भीतर सभी पूर्णांकों में अंक '2' की घटनाओं की गिनती की जाती है।  \nदोनों L और R शामिल हैं।  \nयह सीमा के प्रत्येक संख्या के माध्यम से दोहराता है और गिनता है कि प्रत्येक संख्या में '2' कितनी बार दिखाई देता है।  \nउदाहरण:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "hu": "Ez a függvény megszámolja a '2' számjegy előfordulásait egy adott [L, R] tartományon belüli összes egész szám esetén.\nMind L, mind R beleértendő.\nVégigmegy a tartomány minden számán, és megszámolja, hogy hányszor jelenik meg a '2' az egyes számokban.\nPélda:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9961870912056543",
      "bn": "1",
      "bg": "0.987508532597478",
      "zh": "0.9700616344488975",
      "fr": "0.9884518282770126",
      "de": "0.9921642300985547",
      "ha": "0.9760515322193856",
      "hi": "0.9693785445685186",
      "hu": "0.9891643154537848"
    }
  },
  {
    "task_id": "Common Lisp/31",
    "prompt": {
      "en": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "sq": "(defun represent-as-powers-of-two (n)\n;; Kjo funksion merr një numër të plotë pozitiv 'n' dhe kthen përfaqësimin e tij si një shumë e fuqive të dyshit.\n;; Fuqitë shprehen në një format specifik ku a^b përfaqësohet si a(b), dhe termat mblidhen pa hapësira.\n;; Në mënyrë specifike, 2^0 përfaqësohet si 2()\n;; Shembull:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "hy": "(defun represent-as-powers-of-two (n)\n;; Այս ֆունկցիան ընդունում է դրական ամբողջ թիվ 'n' և վերադարձնում է դրա ներկայացումը որպես երկուսի աստիճանների գումար։\n;; Աստիճանները արտահայտվում են հատուկ ձևաչափով, որտեղ a^b արտահայտվում է որպես a(b), և անդամները գումարվում են առանց բացատների։\n;; Մասնավորապես, 2^0 արտահայտվում է որպես 2()\n;; Օրինակ:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "bn": "(defun represent-as-powers-of-two (n)\n;; এই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যা 'n' গ্রহণ করে এবং এটি দুই এর ঘাতের যোগফল হিসাবে উপস্থাপন করে ফেরত দেয়।\n;; ঘাতগুলি একটি নির্দিষ্ট ফরম্যাটে প্রকাশ করা হয় যেখানে a^b কে a(b) হিসাবে উপস্থাপন করা হয়, এবং পদগুলি ফাঁকা স্থান ছাড়াই যোগ করা হয়।\n;; বিশেষভাবে, 2^0 কে 2() হিসাবে উপস্থাপন করা হয়\n;; উদাহরণ:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "bg": "(defun represent-as-powers-of-two (n)\n;; Тази функция приема положително цяло число 'n' и връща неговото представяне като сума от степени на две.\n;; Степените са изразени в специфичен формат, където a^b е представено като a(b), а членовете се сумират без интервали.\n;; По-конкретно, 2^0 е представено като 2()\n;; Пример:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "zh": "(defun represent-as-powers-of-two (n)\n;; 此函数接受一个正整数 'n' 并返回其作为二的幂之和的表示。\n;; 幂以特定格式表示，其中 a^b 表示为 a(b)，并且项之间没有空格。\n;; 特别地，2^0 表示为 2()\n;; 示例：\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "fr": "(defun represent-as-powers-of-two (n)\n;; Cette fonction prend un entier positif 'n' et renvoie sa représentation comme une somme de puissances de deux.\n;; Les puissances sont exprimées dans un format spécifique où a^b est représenté comme a(b), et les termes sont additionnés sans espaces.\n;; Plus précisément, 2^0 est représenté comme 2()\n;; Exemple:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "de": "(defun represent-as-powers-of-two (n)\n;; Diese Funktion nimmt eine positive ganze Zahl 'n' und gibt deren Darstellung als Summe von Zweierpotenzen zurück.\n;; Die Potenzen werden in einem spezifischen Format ausgedrückt, wobei a^b als a(b) dargestellt wird, und Terme ohne Leerzeichen summiert werden.\n;; Speziell wird 2^0 als 2() dargestellt.\n;; Beispiel:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "ha": "(defun represent-as-powers-of-two (n)\n;; Wannan aikin yana ɗaukar lamba mai kyau 'n' kuma yana mayar da wakilarta a matsayin jumla na ikon biyu.\n;; Ana bayyana ikon a cikin wani tsari na musamman inda a^b ake wakilta da a(b), kuma ana tara sharuɗɗa ba tare da sarari ba.\n;; Musamman, 2^0 ana wakilta da 2()\n;; Misali:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "hi": "(defun represent-as-powers-of-two (n)\n;; यह फ़ंक्शन एक धनात्मक पूर्णांक 'n' लेता है और इसे दो की शक्तियों के योग के रूप में प्रस्तुत करता है।\n;; शक्तियों को एक विशेष प्रारूप में व्यक्त किया जाता है जहाँ a^b को a(b) के रूप में प्रस्तुत किया जाता है, और पदों को बिना स्पेस के जोड़ा जाता है।\n;; विशेष रूप से, 2^0 को 2() के रूप में प्रस्तुत किया जाता है।\n;; उदाहरण:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "hu": "(defun represent-as-powers-of-two (n)\n;; Ez a függvény egy pozitív egész számot, 'n'-t vesz, és visszaadja annak ábrázolását a kettő hatványainak összegeként.\n;; A hatványok egy specifikus formátumban vannak kifejezve, ahol a^b úgy van ábrázolva, mint a(b), és a tagok szóközök nélkül vannak összegezve.\n;; Különösen, a 2^0 úgy van ábrázolva, mint 2()\n;; Példa:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\""
    },
    "prompt_bertscore": {
      "sq": "0.9953176860278646",
      "hy": "0.9897981449996671",
      "bn": "0.9832469177723744",
      "bg": "0.9970656333809716",
      "zh": "0.9859387566961593",
      "fr": "0.9925199771109882",
      "de": "0.9932286903105206",
      "ha": "0.9886949518633993",
      "hi": "0.9800743933264852",
      "hu": "0.9872407788438429"
    },
    "canonical_solution": "(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))",
    "instruction": {
      "en": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nՏվեք Common Lisp կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Common Lisp 代码，字数不超过 500 个字符。",
      "fr": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nBa da takaitaccen bayanin yare na al'ada (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9518458380953311",
      "bn": "0.8437486025411914",
      "bg": "0.8388862829106369",
      "zh": "0.88778376623434",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.84275028624611",
      "hi": "0.8898221112045199",
      "hu": "0.9449470077012273"
    },
    "level": "",
    "test": "(defun test-represent-as-powers-of-two ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(test-represent-as-powers-of-two)",
    "entry_point": "represent-as-powers-of-two",
    "signature": "(defun represent-as-powers-of-two (n)",
    "docstring": {
      "en": "This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "sq": "Kjo funksion merr një numër të plotë pozitiv 'n' dhe kthen përfaqësimin e tij si një shumë e fuqive të dyshit. \nFuqitë shprehen në një format specifik ku a^b përfaqësohet si a(b), dhe termat mblidhen pa hapësira.\nSpecifikisht, 2^0 përfaqësohet si 2()\nShembull:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hy": "Այս ֆունկցիան ընդունում է դրական ամբողջ թիվ 'n' և վերադարձնում է դրա ներկայացումը որպես երկուսի աստիճանների գումար։ \nԱստիճանները արտահայտվում են հատուկ ձևաչափով, որտեղ a^b արտահայտվում է որպես a(b), և անդամները գումարվում են առանց բացատների։\nՄասնավորապես, 2^0 արտահայտվում է որպես 2()\nՕրինակ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "bn": "এই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যা 'n' গ্রহণ করে এবং এটিকে দুইয়ের ঘাতের যোগফল হিসেবে প্রকাশ করে। \nঘাতগুলি একটি নির্দিষ্ট বিন্যাসে প্রকাশ করা হয় যেখানে a^b কে a(b) হিসেবে উপস্থাপন করা হয়, এবং পদগুলি কোনো ফাঁক ছাড়াই যোগ করা হয়।\nবিশেষভাবে, 2^0 কে 2() হিসেবে উপস্থাপন করা হয়।\nউদাহরণ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "bg": "Тази функция приема положително цяло число 'n' и връща неговото представяне като сума от степени на две. Степените са изразени в специфичен формат, където a^b е представено като a(b), а членовете се събират без интервали. По-специално, 2^0 е представено като 2()\nПример:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "zh": "该函数接受一个正整数 'n' 并返回其作为二的幂之和的表示形式。  \n幂以特定格式表示，其中 a^b 表示为 a(b)，各项之间没有空格。  \n具体来说，2^0 表示为 2()  \n示例：  \n>>> represent-as-powers-of-two(10)  \n\"2+2(2()+2)\"  \n>>> represent-as-powers-of-two(26)  \n\"2+2(2()+2)+2(2(2))\"",
      "fr": "Cette fonction prend un entier positif 'n' et renvoie sa représentation comme une somme de puissances de deux. \nLes puissances sont exprimées dans un format spécifique où a^b est représenté comme a(b), et les termes sont additionnés sans espaces.\nEn particulier, 2^0 est représenté comme 2()\nExemple:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "de": "Diese Funktion nimmt eine positive ganze Zahl 'n' und gibt deren Darstellung als Summe von Potenzen von zwei zurück. \nDie Potenzen werden in einem speziellen Format ausgedrückt, wobei a^b als a(b) dargestellt wird, und die Terme ohne Leerzeichen summiert werden.\nInsbesondere wird 2^0 als 2() dargestellt.\nBeispiel:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "ha": "Wannan aikin yana ɗaukar cikakken lamba mai kyau 'n' kuma yana mayar da wakilarsa a matsayin jumlar ƙarfin biyu. \nAna bayyana ƙarfin a cikin takamaiman tsari inda a^b aka wakilta a matsayin a(b), kuma ana haɗa sharuɗɗa ba tare da sarari ba.\nMusamman, 2^0 ana wakilta shi a matsayin 2()\nMisali:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hi": "यह फ़ंक्शन एक धनात्मक पूर्णांक 'n' लेता है और इसे दो की शक्तियों के योग के रूप में दर्शाता है। \nशक्तियों को एक विशेष प्रारूप में व्यक्त किया जाता है जहाँ a^b को a(b) के रूप में दर्शाया जाता है, और पदों को बिना स्थान के जोड़ा जाता है।\nविशेष रूप से, 2^0 को 2() के रूप में दर्शाया जाता है।\nउदाहरण:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hu": "Ez a függvény egy pozitív egész számot, 'n'-t vesz át, és visszaadja annak ábrázolását kettő hatványainak összegeként. \nA hatványok egy speciális formátumban vannak kifejezve, ahol a^b úgy van ábrázolva, mint a(b), és a tagok szóközök nélkül vannak összegezve.\nKonkrétan, 2^0 úgy van ábrázolva, mint 2()\nPélda:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\""
    },
    "docstring_bertscore": {
      "sq": "0.9913867907871842",
      "hy": "0.9822660809508241",
      "bn": "0.9638270240489745",
      "bg": "0.9840771927651003",
      "zh": "0.9718586435061202",
      "fr": "0.9840771927651003",
      "de": "0.979526570735591",
      "ha": "0.977215307621869",
      "hi": "0.9755595247655622",
      "hu": "0.9868246481955748"
    }
  },
  {
    "task_id": "Common Lisp/32",
    "prompt": {
      "en": "(defun create-largest-number (numbers)\n;; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\n;; Example:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "sq": "(defun create-largest-number (numbers)\n;; Kjo funksion merr një listë të numrave të plotë pozitivë dhe i riorganizon ato për të formuar numrin më të madh të mundshëm.\n;; E bën këtë duke bashkuar numrat në një renditje të tillë që kombinimi i tyre shifror jep vlerën maksimale.\n;; Shembull:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "hy": "(defun create-largest-number (numbers)\n;; Այս ֆունկցիան ընդունում է դրական ամբողջ թվերի ցուցակ և վերադասավորում է դրանք՝ կազմելու ամենամեծ հնարավոր թիվը։\n;; Այն դա անում է՝ թվերը միացնելով այնպիսի հերթականությամբ, որ նրանց թվանշանային համադրությունը տալիս է առավելագույն արժեք։\n;; Օրինակ:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "bn": "(defun create-largest-number (numbers)\n;; এই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যার তালিকা গ্রহণ করে এবং সেগুলিকে পুনর্বিন্যাস করে সবচেয়ে বড় সম্ভাব্য সংখ্যা তৈরি করে।\n;; এটি সংখ্যাগুলিকে এমন একটি ক্রমে সংযুক্ত করে যার ফলে তাদের অঙ্ক-ভিত্তিক সংমিশ্রণ সর্বাধিক মান প্রদান করে।\n;; উদাহরণ:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "bg": "(defun create-largest-number (numbers)\n;; Тази функция приема списък от положителни цели числа и ги пренарежда, за да образува най-голямото възможно число.\n;; Това се постига чрез конкатениране на числата в ред, при който тяхната комбинация по цифри дава максималната стойност.\n;; Пример:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "zh": "(defun create-largest-number (numbers)\n;; 此函数接受一个正整数列表，并重新排列它们以形成可能的最大数字。\n;; 它通过以一种顺序连接整数来实现，使得它们的数字组合产生最大值。\n;; 示例:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "fr": "(defun create-largest-number (numbers)\n;; Cette fonction prend une liste d'entiers positifs et les réarrange pour former le plus grand nombre possible.\n;; Elle le fait en concaténant les entiers dans un ordre tel que leur combinaison chiffre par chiffre donne la valeur maximale.\n;; Exemple:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "de": "(defun create-largest-number (numbers)\n;; Diese Funktion nimmt eine Liste von positiven ganzen Zahlen und ordnet sie so an, dass die größtmögliche Zahl entsteht.\n;; Dies geschieht, indem die Zahlen in einer Reihenfolge verkettet werden, die ihre ziffernweise Kombination den maximalen Wert ergibt.\n;; Beispiel:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "ha": "(defun create-largest-number (numbers)\n;; Wannan aikin yana ɗaukar jerin lambobi masu kyau kuma yana sake tsara su don samar da mafi girman adadi mai yiwuwa.\n;; Yana yin wannan ta hanyar haɗa lambobin a cikin tsari wanda haɗin su na lambobi zai ba da mafi girman ƙima.\n;; Misali:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "hi": "(defun create-largest-number (numbers)\n;; यह फ़ंक्शन सकारात्मक पूर्णांकों की एक सूची लेता है और उन्हें पुनर्व्यवस्थित करता है ताकि सबसे बड़ा संभव संख्या बन सके।\n;; यह ऐसा इस प्रकार करता है कि पूर्णांकों को इस क्रम में जोड़ता है जिससे उनकी अंक-वार संयोजन अधिकतम मान देता है।\n;; उदाहरण:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "hu": "(defun create-largest-number (numbers)\n;; Ez a függvény egy pozitív egész számok listáját veszi, és úgy rendezi át őket, hogy a lehető legnagyobb számot alkossák. \n;; Ezt úgy éri el, hogy az egész számokat olyan sorrendben fűzi össze, hogy a számjegyek szerinti kombinációjuk a maximális értéket adja.\n;; Példa:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\""
    },
    "prompt_bertscore": {
      "sq": "0.9662922257079984",
      "hy": "0.9807098119154158",
      "bn": "0.9663949176149935",
      "bg": "0.9668692469649048",
      "zh": "0.9664074313289986",
      "fr": "0.9814747375127811",
      "de": "0.9754794767220051",
      "ha": "0.9579189619954728",
      "hi": "0.9795943036955239",
      "hu": "0.9834578632370334"
    },
    "canonical_solution": "(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))",
    "instruction": {
      "en": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nՏվեք Common Lisp կոդի հակիրճ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过 500 个字符。",
      "fr": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9379659443293751",
      "hy": "0.9671614322554071",
      "bn": "0.8724495008184465",
      "bg": "0.8388862829106369",
      "zh": "0.8707825946608018",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9436978212348989",
      "hi": "0.8808811618629965",
      "hu": "0.9349640433807949"
    },
    "level": "",
    "test": "(defun test-create-largest-number ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(test-create-largest-number)",
    "entry_point": "create-largest-number",
    "signature": "(defun create-largest-number (numbers)",
    "docstring": {
      "en": "This function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "sq": "Kjo funksion merr një listë të numrave të plotë pozitivë dhe i riorganizon ata për të formuar numrin më të madh të mundshëm. \nE bën këtë duke bashkuar numrat në një renditje të tillë që kombinimi i tyre sipas shifrave jep vlerën maksimale.\nShembull:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hy": "Այս ֆունկցիան ընդունում է դրական ամբողջ թվերի ցուցակ և վերադասավորում է դրանք՝ կազմելու համար հնարավոր ամենամեծ թիվը։  \nԱյն դա անում է՝ ամբողջ թվերը միացնելով այնպիսի հերթականությամբ, որ նրանց թվանշանային համադրությունը տա առավելագույն արժեքը։  \nՕրինակ՝  \n>>> create-largest-number '(56 9 45)  \n\"95645\"  \n>>> create-largest-number '(5 50 56)  \n\"56550\"",
      "bn": "এই ফাংশনটি ধনাত্মক পূর্ণসংখ্যার একটি তালিকা গ্রহণ করে এবং সেগুলিকে পুনর্বিন্যাস করে সবচেয়ে বড় সম্ভাব্য সংখ্যা তৈরি করে। এটি এমন একটি ক্রমে পূর্ণসংখ্যাগুলিকে সংযুক্ত করে যাতে তাদের অঙ্ক-ভিত্তিক সংমিশ্রণ সর্বাধিক মান প্রদান করে।\n\nউদাহরণ:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "bg": "Тази функция приема списък от положителни цели числа и ги пренарежда, за да образува най-голямото възможно число. \nТя прави това, като конкатенира числата в ред, такъв че тяхната комбинация по цифри дава максималната стойност.\nПример:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "zh": "这个函数接受一个正整数列表，并重新排列它们以形成可能的最大数字。  \n它通过以一种顺序连接整数来实现，使得它们的数字组合产生最大值。  \n示例：  \n>>> create-largest-number '(56 9 45)  \n\"95645\"  \n>>> create-largest-number '(5 50 56)  \n\"56550\"  ",
      "fr": "Cette fonction prend une liste d'entiers positifs et les réorganise pour former le plus grand nombre possible. Elle le fait en concaténant les entiers dans un ordre tel que leur combinaison chiffre par chiffre donne la valeur maximale.\nExemple:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "de": "Diese Funktion nimmt eine Liste von positiven ganzen Zahlen und ordnet sie so an, dass die größtmögliche Zahl entsteht. \nDies geschieht, indem die ganzen Zahlen in einer Reihenfolge verkettet werden, sodass ihre ziffernweise Kombination den maximalen Wert ergibt.\nBeispiel:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "ha": "Wannan aikin yana ɗaukar jerin lambobi masu kyau kuma yana sake tsara su don ƙirƙirar mafi girman adadi mai yiwuwa. \nYana yin wannan ta hanyar haɗa lambobin a cikin tsari wanda haɗin gwiwar lambobinsu zai ba da mafi girman ƙima.\nMisali:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hi": "यह फ़ंक्शन सकारात्मक पूर्णांकों की एक सूची लेता है और उन्हें पुनर्व्यवस्थित करता है ताकि सबसे बड़ा संभव संख्या बन सके। \nयह ऐसा इस तरह से करता है कि पूर्णांकों को इस क्रम में जोड़ता है जिससे उनके अंक-वार संयोजन का अधिकतम मान प्राप्त हो सके।\nउदाहरण:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hu": "Ez a függvény pozitív egész számok listáját veszi, és úgy rendezi át őket, hogy a lehető legnagyobb számot alkossa meg. \nEzt úgy éri el, hogy az egész számokat olyan sorrendben fűzi össze, hogy számjegyenkénti kombinációjuk a maximális értéket adja.\nPélda:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\""
    },
    "docstring_bertscore": {
      "sq": "0.963579530594205",
      "hy": "0.9802054893779683",
      "bn": "0.972096999963362",
      "bg": "0.9792002210195506",
      "zh": "0.9777102945314079",
      "fr": "0.9770611704461859",
      "de": "0.9763470942263656",
      "ha": "0.9311318674394887",
      "hi": "0.9931347381402912",
      "hu": "0.9789114124455259"
    }
  },
  {
    "task_id": "Common Lisp/33",
    "prompt": {
      "en": "(defun add-numbers (a b)\n\"Add two numbers together.\"\n;; Example:\n;; >>> add-numbers 1 2\n;; 3",
      "sq": "(defun add-numbers (a b)\n\"Shto dy numra së bashku.\"\n;; Shembull:\n;; >>> add-numbers 1 2\n;; 3",
      "hy": "(defun add-numbers (a b)\n\"Երկու թվեր գումարել իրար։\"\n;; Օրինակ:\n;; >>> add-numbers 1 2\n;; 3",
      "bn": "(defun add-numbers (a b)\n\"দুটি সংখ্যাকে একসাথে যোগ করুন।\"\n;; উদাহরণ:\n;; >>> add-numbers 1 2\n;; 3",
      "bg": "(defun add-numbers (a b)\n\"Събира две числа заедно.\"\n;; Пример:\n;; >>> add-numbers 1 2\n;; 3",
      "zh": "(defun add-numbers (a b)\n\"将两个数字相加。\"\n;; 示例:\n;; >>> add-numbers 1 2\n;; 3",
      "fr": "(defun add-numbers (a b)\n\"Ajouter deux nombres ensemble.\"\n;; Exemple:\n;; >>> add-numbers 1 2\n;; 3",
      "de": "(defun add-numbers (a b)\n\"Zwei Zahlen zusammen addieren.\"\n;; Beispiel:\n;; >>> add-numbers 1 2\n;; 3",
      "ha": "(defun add-numbers (a b)\n\"Ƙara lambobi biyu tare.\"\n;; Misali:\n;; >>> add-numbers 1 2\n;; 3",
      "hi": "(defun add-numbers (a b)\n\"दो संख्याओं को एक साथ जोड़ें।\"\n;; उदाहरण:\n;; >>> add-numbers 1 2\n;; 3",
      "hu": "(defun add-numbers (a b)\n\"Két szám összeadása.\"\n;; Példa:\n;; >>> add-numbers 1 2\n;; 3"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "0.995149048834366",
      "zh": "0.9832947876942039",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "1",
      "hu": "0.9808967231039696"
    },
    "canonical_solution": "(+ a b))",
    "instruction": {
      "en": "(defun add-numbers (a b)\n(+ a b))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun add-numbers (a b)\n(+ a b))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun add-numbers (a b)\n(+ a b))\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun add-numbers (a b)\n(+ a b))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun add-numbers (a b)\n(+ a b))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun add-numbers (a b)\n(+ a b))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "(defun add-numbers (a b)\n(+ a b))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun add-numbers (a b)\n(+ a b))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun add-numbers (a b)\n(+ a b))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun add-numbers (a b)\n(+ a b))\n\nसामान्य लिस्प कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun add-numbers (a b)\n(+ a b))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9452918300427039",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8724534734260673",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8995998903413434",
      "hu": "0.9443179452844898"
    },
    "level": "",
    "test": "(defun test_add()\n(assert (equal (add-numbers 1 2) 3))\n(assert (equal (add-numbers 20 10) 30))\n(assert (equal (add-numbers -1 -2) -3))\n)\n;; 运行测试\n(test_add)",
    "entry_point": "add-numbers",
    "signature": "(defun add-numbers (a b)",
    "docstring": {
      "en": "\"Add two numbers together.\"\nExample:\n>>> add-numbers 1 2\n3",
      "sq": "\"Shto dy numra së bashku.\"\nShembull:\n>>> add-numbers 1 2 \n3",
      "hy": "\"Երկու թվեր գումարել իրար։\"\nՕրինակ:\n>>> add-numbers 1 2\n3",
      "bn": "\"দুটি সংখ্যা একসাথে যোগ করে।\"\nউদাহরণ:\n>>> add-numbers 1 2\n3",
      "bg": "\"Съберете две числа заедно.\"\nПример:\n>>> add-numbers 1 2\n3",
      "zh": "\"将两个数字相加。\"\n示例：\n>>> add-numbers 1 2\n3",
      "fr": "\"Ajouter deux nombres ensemble.\"\nExemple:\n>>> add-numbers 1 2\n3",
      "de": "\"Zwei Zahlen zusammen addieren.\"\nBeispiel:\n>>> add-numbers 1 2\n3",
      "ha": "\"Ƙara lambobi biyu tare.\"\n\nMisali:\n>>> add-numbers 1 2\n3",
      "hi": "\"दो संख्याओं को एक साथ जोड़ें।\"\nउदाहरण:\n>>> add-numbers 1 2\n3",
      "hu": "\"Adjunk össze két számot.\"\nPélda:\n>>> add-numbers 1 2\n3"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9477331960560037",
      "bn": "1",
      "bg": "1",
      "zh": "0.9674897682752578",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "1",
      "hu": "0.9674897682752578"
    }
  },
  {
    "task_id": "Common Lisp/34",
    "prompt": {
      "en": "(defun count-valid-sequences (n)\n;; This function calculates the number of valid sequences that can be formed from a given positive integer 'n'.\n;; A valid sequence is one that starts with 'n' and can have additional numbers appended, each no more than half of the last number in the sequence.\n;; Example:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "sq": "(defun count-valid-sequences (n)\n;; Kjo funksion llogarit numrin e sekuencave të vlefshme që mund të formohen nga një numër i dhënë pozitiv 'n'.\n;; Një sekuencë e vlefshme është ajo që fillon me 'n' dhe mund të ketë numra shtesë të bashkangjitur, secili jo më shumë se gjysma e numrit të fundit në sekuencë.\n;; Shembull:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "hy": "(defun count-valid-sequences (n)\n;; Այս ֆունկցիան հաշվում է վավեր հաջորդականությունների քանակը, որոնք կարող են կազմվել տրված դրական ամբողջ թիվ 'n'-ից:\n;; Վավեր հաջորդականությունը մեկն է, որը սկսվում է 'n'-ով և կարող է ունենալ հավելյալ թվեր, որոնցից յուրաքանչյուրը չի գերազանցում հաջորդականության վերջին թվի կեսը:\n;; Օրինակ:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "bn": "(defun count-valid-sequences (n)\n;; এই ফাংশনটি একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা 'n' থেকে গঠিত বৈধ ক্রমের সংখ্যা গণনা করে।\n;; একটি বৈধ ক্রম হল এমন একটি যা 'n' দিয়ে শুরু হয় এবং অতিরিক্ত সংখ্যা যোগ করা যেতে পারে, প্রতিটি সংখ্যা ক্রমের শেষ সংখ্যার অর্ধেকের বেশি নয়।\n;; উদাহরণ:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "bg": "(defun count-valid-sequences (n)\n;; Тази функция изчислява броя на валидните последователности, които могат да бъдат формирани от дадено положително цяло число 'n'.\n;; Валидна последователност е такава, която започва с 'n' и може да има допълнителни числа, всяко от които не е повече от половината на последното число в последователността.\n;; Пример:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "zh": "(defun count-valid-sequences (n)\n;; 此函数计算可以从给定正整数 'n' 形成的有效序列的数量。\n;; 有效序列是指以 'n' 开头，并且可以附加其他数字，每个数字不超过序列中最后一个数字的一半。\n;; 示例：\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "fr": "(defun count-valid-sequences (n)\n;; Cette fonction calcule le nombre de séquences valides qui peuvent être formées à partir d'un entier positif 'n' donné.\n;; Une séquence valide est celle qui commence par 'n' et peut avoir des nombres supplémentaires ajoutés, chacun ne dépassant pas la moitié du dernier nombre de la séquence.\n;; Exemple:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "de": "(defun count-valid-sequences (n)\n;; Diese Funktion berechnet die Anzahl der gültigen Sequenzen, die aus einer gegebenen positiven Ganzzahl 'n' gebildet werden können.\n;; Eine gültige Sequenz beginnt mit 'n' und kann zusätzliche Zahlen angehängt haben, wobei jede nicht mehr als die Hälfte der letzten Zahl in der Sequenz beträgt.\n;; Beispiel:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "ha": "(defun count-valid-sequences (n)\n;; Wannan aikin yana ƙididdige adadin jerin da za a iya samarwa daga wani adadi mai kyau 'n'.\n;; Jeri mai kyau shine wanda ya fara da 'n' kuma zai iya samun ƙarin lambobi da aka haɗa, kowanne ba fiye da rabin adadin ƙarshe a cikin jerin ba.\n;; Misali:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "hi": "(defun count-valid-sequences (n)\n;; यह फ़ंक्शन उन मान्य अनुक्रमों की संख्या की गणना करता है जो दिए गए धनात्मक पूर्णांक 'n' से बनाए जा सकते हैं।\n;; एक मान्य अनुक्रम वह है जो 'n' से शुरू होता है और इसमें अतिरिक्त संख्याएँ जोड़ी जा सकती हैं, प्रत्येक संख्या अनुक्रम में अंतिम संख्या से आधी से अधिक नहीं हो सकती।\n;; उदाहरण:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "hu": "(defun count-valid-sequences (n)\n;; Ez a függvény kiszámítja a megadott pozitív egész 'n' számból képezhető érvényes sorozatok számát.\n;; Egy érvényes sorozat az, amely 'n'-nel kezdődik, és további számok fűzhetők hozzá, amelyek mindegyike legfeljebb a sorozat utolsó számának fele lehet.\n;; Példa:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4"
    },
    "prompt_bertscore": {
      "sq": "0.9886444997466165",
      "hy": "0.9701863743281874",
      "bn": "0.9614774252717128",
      "bg": "0.9819667449666045",
      "zh": "0.9720495273022947",
      "fr": "0.9825759443452385",
      "de": "0.9806265857857622",
      "ha": "0.9807527160777193",
      "hi": "0.9777565754101891",
      "hu": "0.9611304179960448"
    },
    "canonical_solution": "(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))",
    "instruction": {
      "en": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nՏվյալ Common Lisp կոդի համար տրամադրեք հակիրճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nBayar da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.8633782499469642",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8777588909035091",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8822235059780303",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun test-count-valid-sequences ()\n(assert (equal (count-valid-sequences 6) 6))\n(assert (equal (count-valid-sequences 4) 4))\n(assert (equal (count-valid-sequences 10) 14))\n(assert (equal (count-valid-sequences 2) 2))\n(assert (equal (count-valid-sequences 1) 1)))\n\n(test-count-valid-sequences)",
    "entry_point": "count-valid-sequences",
    "signature": "(defun count-valid-sequences (n)",
    "docstring": {
      "en": "This function calculates the number of valid sequences that can be formed from a given positive integer 'n'.\nA valid sequence is one that starts with 'n' and can have additional numbers appended, each no more than half of the last number in the sequence.\nExample:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "sq": "Kjo funksion llogarit numrin e sekuencave të vlefshme që mund të formohen nga një numër i dhënë pozitiv 'n'.\nNjë sekuencë e vlefshme është ajo që fillon me 'n' dhe mund të ketë numra shtesë të bashkangjitur, secili jo më shumë se gjysma e numrit të fundit në sekuencë.\nShembull:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "hy": "Այս ֆունկցիան հաշվարկում է վավեր հաջորդականությունների քանակը, որոնք կարող են կազմվել տրված դրական ամբողջ թիվ 'n'-ից:\nՎավեր հաջորդականություն է այն, որը սկսվում է 'n'-ով և կարող է ունենալ հավելյալ թվեր, որոնցից յուրաքանչյուրը ոչ ավելի քան հաջորդականության վերջին թվի կեսն է:\nՕրինակ:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "bn": "এই ফাংশনটি একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা 'n' থেকে গঠিত বৈধ ক্রমগুলির সংখ্যা গণনা করে। একটি বৈধ ক্রম হল এমন একটি যা 'n' দিয়ে শুরু হয় এবং এতে অতিরিক্ত সংখ্যা যোগ করা যেতে পারে, প্রতিটি সংখ্যা ক্রমের শেষ সংখ্যার অর্ধেকের বেশি নয়।\n\nউদাহরণ:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "bg": "Тази функция изчислява броя на валидните последователности, които могат да бъдат формирани от дадено положително цяло число 'n'. Валидна последователност е такава, която започва с 'n' и може да има добавени допълнителни числа, всяко не повече от половината на последното число в последователността. Пример:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "zh": "此函数计算可以从给定正整数 'n' 形成的有效序列的数量。  \n有效序列是以 'n' 开头的序列，可以附加其他数字，每个数字不超过序列中最后一个数字的一半。  \n示例：  \n>>> count-valid-sequences 6  \n6  \n>>> count-valid-sequences 4  \n4  ",
      "fr": "Cette fonction calcule le nombre de séquences valides qui peuvent être formées à partir d'un entier positif 'n' donné.  \nUne séquence valide est celle qui commence par 'n' et peut avoir des nombres supplémentaires ajoutés, chacun ne dépassant pas la moitié du dernier nombre de la séquence.  \nExemple:\n>>> count-valid-sequences 6  \n6  \n>>> count-valid-sequences 4  \n4  ",
      "de": "Diese Funktion berechnet die Anzahl der gültigen Sequenzen, die aus einer gegebenen positiven Ganzzahl 'n' gebildet werden können. Eine gültige Sequenz beginnt mit 'n' und kann zusätzliche Zahlen angehängt haben, wobei jede Zahl nicht mehr als die Hälfte der letzten Zahl in der Sequenz betragen darf.\nBeispiel:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "ha": "Wannan aikin yana ƙididdige adadin jerin da za a iya ƙirƙira daga wani lamba mai kyau 'n'.\nJerin da ya dace shine wanda ya fara da 'n' kuma zai iya samun ƙarin lambobi da aka haɗa, kowanne ba fiye da rabin lambar ƙarshe a cikin jerin ba.\nMisali:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "hi": "यह फ़ंक्शन उन वैध अनुक्रमों की संख्या की गणना करता है जो दिए गए धनात्मक पूर्णांक 'n' से बनाए जा सकते हैं। एक वैध अनुक्रम वह होता है जो 'n' से शुरू होता है और इसमें अतिरिक्त संख्याएँ जोड़ी जा सकती हैं, प्रत्येक संख्या अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं हो सकती।\nउदाहरण:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "hu": "Ez a függvény kiszámítja, hogy hány érvényes sorozat képezhető egy adott pozitív egész 'n' számjegyből.\nEgy érvényes sorozat olyan, amely 'n'-nel kezdődik, és további számok fűzhetők hozzá, amelyek mindegyike legfeljebb a sorozat utolsó számának fele lehet.\nPélda:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9845600632213961",
      "hy": "0.9741571942754559",
      "bn": "0.9584189146645375",
      "bg": "0.9919060106032094",
      "zh": "0.953399922196548",
      "fr": "0.9790667414034953",
      "de": "0.9629621873699485",
      "ha": "0.9710200260373908",
      "hi": "0.9708688683174233",
      "hu": "0.9367693949140209"
    }
  },
  {
    "task_id": "Common Lisp/35",
    "prompt": {
      "en": "(defun construct-preorder (inorder postorder)\n;; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.\n;; Example:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "sq": "(defun construct-preorder (inorder postorder)\n;; Kjo funksion rindërton kalimin e paravendosjes së një peme binare nga kalimet e saj në rend dhe pasrend.\n;; Nyjet e pemës binare përfaqësohen nga shkronja të mëdha të dallueshme.\n;; Supozohet se pema nuk ka më shumë se 8 nyje.\n;; Shembull:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "hy": "(defun construct-preorder (inorder postorder)\n;; Այս ֆունկցիան վերակառուցում է բինար ծառի նախորդական շրջանցումը իր ներսային և հետին շրջանցումներից:\n;; Բինար ծառի հանգույցները ներկայացված են տարբեր մեծատառերով:\n;; Ենթադրվում է, որ ծառը ունի ոչ ավելի, քան 8 հանգույց:\n;; Օրինակ:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "bn": "(defun construct-preorder (inorder postorder)\n;; এই ফাংশনটি একটি বাইনারি গাছের ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে প্রিঅর্ডার ট্রাভার্সাল পুনর্গঠন করে।\n;; বাইনারি গাছের নোডগুলি পৃথক বড় হাতের অক্ষর দ্বারা উপস্থাপিত হয়।\n;; অনুমান করা হয় যে গাছটিতে ৮টির বেশি নোড নেই।\n;; উদাহরণ:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "bg": "(defun construct-preorder (inorder postorder)\n;; Тази функция реконструира предварителното обхождане на двоично дърво от неговите обхождания по ред и след ред.\n;; Възлите на двоичното дърво са представени чрез различни главни букви.\n;; Предполага се, че дървото има не повече от 8 възела.\n;; Пример:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "zh": "(defun construct-preorder (inorder postorder)\n;; 此函数从二叉树的中序遍历和后序遍历重建前序遍历。\n;; 二叉树的节点由不同的大写字母表示。\n;; 假设树最多有8个节点。\n;; 示例:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "fr": "(defun construct-preorder (inorder postorder)\n;; Cette fonction reconstruit le parcours en préordre d'un arbre binaire à partir de ses parcours en ordre et en postordre.\n;; Les nœuds de l'arbre binaire sont représentés par des lettres majuscules distinctes.\n;; On suppose que l'arbre n'a pas plus de 8 nœuds.\n;; Exemple:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "de": "(defun construct-preorder (inorder postorder)\n;; Diese Funktion rekonstruiert die Preorder-Traversierung eines Binärbaums aus seinen Inorder- und Postorder-Traversierungen.\n;; Die Knoten des Binärbaums werden durch unterschiedliche Großbuchstaben dargestellt.\n;; Es wird angenommen, dass der Baum nicht mehr als 8 Knoten hat.\n;; Beispiel:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "ha": "(defun construct-preorder (inorder postorder)\n;; Wannan aikin yana sake gina tsarin preorder na itacen binary daga tsarin inorder da postorder.\n;; Ana wakiltar gungun itacen binary ta hanyar manyan haruffa daban-daban.\n;; Ana tsammanin cewa itacen ba shi da fiye da nodes 8.\n;; Misali:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "hi": "(defun construct-preorder (inorder postorder)\n;; यह फ़ंक्शन एक बाइनरी ट्री के प्रीऑर्डर ट्रैवर्सल को उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से पुनर्निर्मित करता है।\n;; बाइनरी ट्री के नोड्स को विशिष्ट अपरकेस अक्षरों द्वारा दर्शाया गया है।\n;; यह माना जाता है कि ट्री में 8 से अधिक नोड्स नहीं हैं।\n;; उदाहरण:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "hu": "(defun construct-preorder (inorder postorder)\n;; Ez a függvény egy bináris fa preorder bejárását rekonstruálja az inorder és postorder bejárások alapján.\n;; A bináris fa csomópontjait különböző nagybetűk képviselik.\n;; Feltételezzük, hogy a fának legfeljebb 8 csomópontja van.\n;; Példa:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\""
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9831442258653794",
      "bn": "0.9877043821531784",
      "bg": "0.9961088308355266",
      "zh": "0.9655000877484313",
      "fr": "1",
      "de": "0.9961088308355266",
      "ha": "0.9727496993954426",
      "hi": "0.9950258979981244",
      "hu": "0.9677044877171564"
    },
    "canonical_solution": "(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))",
    "instruction": {
      "en": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用不超过500个字符的中文。",
      "fr": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9452918300427039",
      "bn": "0.8778232471469645",
      "bg": "0.8388862829106369",
      "zh": "0.8666423429985105",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.9077727359994049",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun test-construct-preorder ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(test-construct-preorder)",
    "entry_point": "construct-preorder",
    "signature": "(defun construct-preorder (inorder postorder)",
    "docstring": {
      "en": "This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "sq": "Kjo funksion rindërton kalimin paraprak të një peme binare nga kalimet e saj në rend dhe pas rendit. \nNyjet e pemës binare përfaqësohen nga shkronja të mëdha të dallueshme. \nSupozohen që pema nuk ka më shumë se 8 nyje.\nShembull:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "hy": "Այս ֆունկցիան վերականգնում է բինար ծառի նախնական շրջանցումը նրա ներսանցման և հետանցման շրջանցումներից:\nԲինար ծառի հանգույցները ներկայացված են տարբեր մեծատառերով:\nԵնթադրվում է, որ ծառը ունի ոչ ավելի, քան 8 հանգույց:\nՕրինակ:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "bn": "এই ফাংশনটি একটি বাইনারি গাছের প্রিঅর্ডার ট্রাভার্সাল পুনর্গঠন করে তার ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে।\nবাইনারি গাছের নোডগুলি আলাদা বড় হাতের অক্ষর দ্বারা উপস্থাপিত হয়।\nধরা হয়েছে যে গাছের নোড সংখ্যা ৮ এর বেশি নয়।\nউদাহরণ:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "bg": "Тази функция реконструира обхождането в предварителен ред на двоично дърво от неговите обхождания в среден и следходов ред.\nВъзлите на двоичното дърво са представени чрез различни главни букви.\nПредполага се, че дървото има не повече от 8 възела.\nПример:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "zh": "该函数从二叉树的中序遍历和后序遍历重建其前序遍历。  \n二叉树的节点由不同的大写字母表示。  \n假设树的节点不超过8个。  \n示例：  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  ",
      "fr": "Cette fonction reconstruit le parcours préordre d'un arbre binaire à partir de ses parcours en ordre et postordre.  \nLes nœuds de l'arbre binaire sont représentés par des lettres majuscules distinctes.  \nIl est supposé que l'arbre n'a pas plus de 8 nœuds.  \nExemple:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  ",
      "de": "Diese Funktion rekonstruiert die Preorder-Traversierung eines Binärbaums aus seinen Inorder- und Postorder-Traversierungen.\nDie Knoten des Binärbaums werden durch unterschiedliche Großbuchstaben dargestellt.\nEs wird angenommen, dass der Baum nicht mehr als 8 Knoten hat.\nBeispiel:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "ha": "Wannan aikin yana sake gina tafiyar preorder na itacen binary daga tafiyar inorder da postorder na itacen.\nAna wakiltar nodes na itacen binary ta hanyar manyan haruffa daban-daban.\nAna tsammanin cewa itacen ba shi da fiye da nodes 8.\nMisali:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "hi": "यह फ़ंक्शन एक बाइनरी ट्री के प्रीऑर्डर ट्रैवर्सल को उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से पुनर्निर्मित करता है। बाइनरी ट्री के नोड्स को विशिष्ट अपरकेस अक्षरों द्वारा दर्शाया गया है। यह माना जाता है कि ट्री में 8 से अधिक नोड्स नहीं हैं। \n\nउदाहरण:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "hu": "Ez a függvény újraépíti egy bináris fa preorder bejárását az inorder és postorder bejárásokból.\nA bináris fa csomópontjait különböző nagybetűk képviselik.\nFeltételezzük, hogy a fának legfeljebb 8 csomópontja van.\nPélda:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\""
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9809473738511335",
      "bn": "0.9777126780959804",
      "bg": "0.9809473738511335",
      "zh": "0.9809414149397024",
      "fr": "0.999999801369619",
      "de": "0.995497049261939",
      "ha": "0.9635831059410636",
      "hi": "0.9901064193510333",
      "hu": "0.9773525612151641"
    }
  },
  {
    "task_id": "Common Lisp/36",
    "prompt": {
      "en": "(defun count-prime-sums (numbers k)\n;; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\n;; Example:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) and (3+4) are prime\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Only (1+2+5) is prime",
      "sq": "(defun count-prime-sums (numbers k)\n;; Kjo funksion numëron numrin e mënyrave për të zgjedhur 'k' numra të plotë nga një listë prej 'n' numrash të plotë në mënyrë që shuma e tyre të jetë një numër i thjeshtë.\n;; Ai konsideron të gjitha kombinimet e mundshme të 'k' numrave të plotë nga lista dhe kontrollon nëse shuma e tyre është e thjeshtë.\n;; Shembull:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) dhe (3+4) janë të thjeshtë\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Vetëm (1+2+5) është i thjeshtë",
      "hy": "(defun count-prime-sums (numbers k)\n;; Այս ֆունկցիան հաշվում է եղանակների քանակը, որոնցով կարելի է ընտրել 'k' ամբողջ թիվ 'n' ամբողջ թվերի ցուցակից այնպես, որ նրանց գումարը լինի պարզ թիվ։\n;; Այն հաշվի է առնում ցուցակից 'k' ամբողջ թվերի բոլոր հնարավոր համակցությունները և ստուգում է, արդյոք նրանց գումարը պարզ է։\n;; Օրինակ:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) և (3+4) պարզ են\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Միայն (1+2+5) պարզ է",
      "bn": "(defun count-prime-sums (numbers k)\n;; এই ফাংশনটি 'n' পূর্ণসংখ্যার একটি তালিকা থেকে 'k' পূর্ণসংখ্যা বাছাই করার উপায়গুলির সংখ্যা গণনা করে যাতে তাদের যোগফল একটি মৌলিক সংখ্যা হয়।\n;; এটি তালিকা থেকে 'k' পূর্ণসংখ্যার সমস্ত সম্ভাব্য সমন্বয় বিবেচনা করে এবং তাদের যোগফল মৌলিক কিনা তা পরীক্ষা করে।\n;; উদাহরণ:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) এবং (3+4) মৌলিক\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; শুধুমাত্র (1+2+5) মৌলিক",
      "bg": "(defun count-prime-sums (numbers k)\n;; Тази функция брои броя на начините за избор на 'k' цели числа от списък с 'n' цели числа, така че тяхната сума да е просто число.\n;; Тя разглежда всички възможни комбинации от 'k' цели числа от списъка и проверява дали тяхната сума е просто число.\n;; Пример:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) и (3+4) са прости\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Само (1+2+5) е просто",
      "zh": "(defun count-prime-sums (numbers k)\n;; 此函数计算从'n'个整数的列表中选择'k'个整数，使其和为质数的方式数量。\n;; 它考虑列表中'k'个整数的所有可能组合，并检查它们的和是否为质数。\n;; 例子:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) 和 (3+4) 是质数\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; 只有 (1+2+5) 是质数",
      "fr": "(defun count-prime-sums (numbers k)\n;; Cette fonction compte le nombre de façons de sélectionner 'k' entiers d'une liste de 'n' entiers de sorte que leur somme soit un nombre premier.\n;; Elle considère toutes les combinaisons possibles de 'k' entiers de la liste et vérifie si leur somme est un nombre premier.\n;; Exemple:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) et (3+4) sont premiers\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Seul (1+2+5) est premier",
      "de": "(defun count-prime-sums (numbers k)\n;; Diese Funktion zählt die Anzahl der Möglichkeiten, 'k' ganze Zahlen aus einer Liste von 'n' ganzen Zahlen auszuwählen, sodass ihre Summe eine Primzahl ist.\n;; Sie berücksichtigt alle möglichen Kombinationen von 'k' ganzen Zahlen aus der Liste und prüft, ob ihre Summe eine Primzahl ist.\n;; Beispiel:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) und (3+4) sind prim\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Nur (1+2+5) ist prim",
      "ha": "(defun count-prime-sums (numbers k)\n;; Wannan aikin yana ƙirga yawan hanyoyin zaɓar 'k' lambobi daga jerin 'n' lambobi ta yadda jimlarsu ta zama lamba mai firam.\n;; Yana la'akari da dukkan yiwuwar haɗuwa na 'k' lambobi daga jerin kuma yana duba idan jimlarsu ta zama mai firam.\n;; Misali:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) da (3+4) suna da firam\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Sai dai (1+2+5) ne mai firam",
      "hi": "(defun count-prime-sums (numbers k)\n;; यह फ़ंक्शन 'n' पूर्णांकों की सूची से 'k' पूर्णांकों का चयन करने के तरीकों की संख्या की गणना करता है ताकि उनका योग एक अभाज्य संख्या हो।\n;; यह सूची से 'k' पूर्णांकों के सभी संभावित संयोजनों पर विचार करता है और जांचता है कि उनका योग अभाज्य है या नहीं।\n;; उदाहरण:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) और (3+4) अभाज्य हैं\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; केवल (1+2+5) अभाज्य है",
      "hu": "(defun count-prime-sums (numbers k)\n;; Ez a függvény megszámolja, hogy hányféleképpen lehet kiválasztani 'k' egész számot egy 'n' egész számot tartalmazó listából úgy, hogy összegük prímszám legyen.\n;; Minden lehetséges 'k' egész szám kombinációt figyelembe vesz a listából, és ellenőrzi, hogy összegük prímszám-e.\n;; Példa:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) és (3+4) prímszámok\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Csak (1+2+5) prímszám"
    },
    "prompt_bertscore": {
      "sq": "0.9984641898938382",
      "hy": "0.9923680248694965",
      "bn": "0.9969283797876765",
      "bg": "0.9927913062114818",
      "zh": "0.9791720155054437",
      "fr": "0.9942764655704797",
      "de": "0.9942764655704797",
      "ha": "0.9829235475120496",
      "hi": "0.9850912008602833",
      "hu": "0.9771352595783119"
    },
    "canonical_solution": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))",
    "instruction": {
      "en": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nՏվեք Common Lisp կոդի համառոտ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\n请用不超过500个字符的中文，为以下Common Lisp代码提供简明的自然语言描述（文档字符串）。",
      "fr": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Common Lisp a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nइस Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रींग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9571526459854401",
      "hy": "0.9131842221003194",
      "bn": "0.8727891587700162",
      "bg": "0.8458594476004492",
      "zh": "0.8751743123854832",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9202179225231458",
      "hi": "0.8980746076453764",
      "hu": "0.9443179452844898"
    },
    "level": "",
    "test": "(defun test-count-prime-sums ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(test-count-prime-sums)",
    "entry_point": "count-prime-sums",
    "signature": "(defun count-prime-sums (numbers k)",
    "docstring": {
      "en": "This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime",
      "sq": "Kjo funksion numëron numrin e mënyrave për të zgjedhur 'k' numra të plotë nga një listë me 'n' numra të plotë në mënyrë që shuma e tyre të jetë një numër i thjeshtë.\nAi konsideron të gjitha kombinimet e mundshme të 'k' numrave të plotë nga lista dhe kontrollon nëse shuma e tyre është e thjeshtë.\nShembull:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) dhe (3+4) janë të thjeshtë\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Vetëm (1+2+5) është i thjeshtë",
      "hy": "Այս ֆունկցիան հաշվում է եղանակների քանակը՝ ընտրելու 'k' ամբողջ թվեր 'n' ամբողջ թվերի ցուցակից այնպես, որ դրանց գումարը լինի պարզ թիվ:  \nԱյն դիտարկում է ցուցակից 'k' ամբողջ թվերի բոլոր հնարավոր կոմբինացիաները և ստուգում, արդյոք դրանց գումարը պարզ է:  \nՕրինակ:  \n>>> count-prime-sums '(1 2 3 4) 2  \n2 ; (1+2) և (3+4) պարզ են  \n>>> count-prime-sums '(1 2 3 4 5 6) 3  \n1 ; Միայն (1+2+5) պարզ է  ",
      "bn": "এই ফাংশনটি একটি তালিকার 'n' পূর্ণসংখ্যা থেকে 'k' পূর্ণসংখ্যা বেছে নেওয়ার উপায়গুলির সংখ্যা গণনা করে যাতে তাদের যোগফল একটি মৌলিক সংখ্যা হয়। এটি তালিকা থেকে 'k' পূর্ণসংখ্যার সমস্ত সম্ভাব্য সমন্বয় বিবেচনা করে এবং তাদের যোগফল মৌলিক কিনা তা পরীক্ষা করে।\nউদাহরণ:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) এবং (3+4) মৌলিক\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; শুধুমাত্র (1+2+5) মৌলিক",
      "bg": "Тази функция брои броя на начините за избор на 'k' цели числа от списък с 'n' цели числа, така че тяхната сума да е просто число. Тя разглежда всички възможни комбинации от 'k' цели числа от списъка и проверява дали тяхната сума е просто число.\nПример:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) и (3+4) са прости\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Само (1+2+5) е просто",
      "zh": "该函数计算从一个包含 'n' 个整数的列表中选择 'k' 个整数，使其和为质数的方式数量。\n它考虑列表中 'k' 个整数的所有可能组合，并检查其和是否为质数。\n示例：\n>>> count-prime-sums '(1 2 3 4) 2  \n2 ; (1+2) 和 (3+4) 是质数  \n>>> count-prime-sums '(1 2 3 4 5 6) 3  \n1 ; 只有 (1+2+5) 是质数  ",
      "fr": "Cette fonction compte le nombre de façons de sélectionner 'k' entiers à partir d'une liste de 'n' entiers de telle sorte que leur somme soit un nombre premier.  \nElle considère toutes les combinaisons possibles de 'k' entiers de la liste et vérifie si leur somme est un nombre premier.  \nExemple:\n>>> count-prime-sums '(1 2 3 4) 2  \n2 ; (1+2) et (3+4) sont premiers  \n>>> count-prime-sums '(1 2 3 4 5 6) 3  \n1 ; Seul (1+2+5) est premier  ",
      "de": "Diese Funktion zählt die Anzahl der Möglichkeiten, 'k' ganze Zahlen aus einer Liste von 'n' ganzen Zahlen auszuwählen, so dass ihre Summe eine Primzahl ist.\nSie berücksichtigt alle möglichen Kombinationen von 'k' ganzen Zahlen aus der Liste und überprüft, ob ihre Summe eine Primzahl ist.\nBeispiel:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) und (3+4) sind prim\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Nur (1+2+5) ist prim",
      "ha": "Wannan aikin yana ƙidaya adadin hanyoyin zaɓar 'k' lambobi daga jerin 'n' lambobi ta yadda jimlar su ta zama lamba mai firam.\nYana la'akari da dukkan yiwuwar haɗuwa na 'k' lambobi daga jerin kuma yana duba ko jimlar su firam ce.\nMisali:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) da (3+4) suna da firam\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Sai dai (1+2+5) ne firam",
      "hi": "यह फ़ंक्शन 'n' पूर्णांकों की सूची से 'k' पूर्णांकों का चयन करने के तरीकों की संख्या गिनता है ताकि उनका योग एक अभाज्य संख्या हो।\nयह सूची से 'k' पूर्णांकों के सभी संभव संयोजनों पर विचार करता है और जांचता है कि उनका योग अभाज्य है या नहीं।\nउदाहरण:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) और (3+4) अभाज्य हैं\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; केवल (1+2+5) अभाज्य है",
      "hu": "Ez a függvény megszámolja, hányféleképpen lehet kiválasztani 'k' egész számot egy 'n' egész számot tartalmazó listából úgy, hogy összegük prímszám legyen.\nMinden lehetséges 'k' egész szám kombinációt figyelembe vesz a listából, és ellenőrzi, hogy összegük prímszám-e.\nPélda:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) és (3+4) prímszámok\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Csak (1+2+5) prímszám"
    },
    "docstring_bertscore": {
      "sq": "0.9982325868695515",
      "hy": "0.9932251149636621",
      "bn": "0.9925114360046037",
      "bg": "0.9915993252948915",
      "zh": "0.9924025865557966",
      "fr": "0.9934044781977366",
      "de": "0.9915993252948915",
      "ha": "0.9779587811380825",
      "hi": "0.9895172816408838",
      "hu": "0.9822092726618482"
    }
  },
  {
    "task_id": "Common Lisp/37",
    "prompt": {
      "en": "(defun calculate-table-tennis-scores (record)\n;; This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \n;; and calculates the scores under 11-point and 21-point systems.\n;; 'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\n;; The function returns two lists: the first list contains the scores under the 11-point system, \n;; and the second list contains the scores under the 21-point system.\n;; Example:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "sq": "(defun calculate-table-tennis-scores (record)\n;; Kjo funksion merr një varg të regjistrimeve të ndeshjeve të pingpongut (të përbërë nga 'W', 'L', dhe 'E') \n;; dhe llogarit pikët sipas sistemeve me 11 pikë dhe 21 pikë.\n;; 'W' tregon një pikë të fituar nga lojtari, 'L' tregon një pikë të fituar nga kundërshtari, dhe 'E' shënon fundin e regjistrimit.\n;; Funksioni kthen dy lista: lista e parë përmban pikët sipas sistemit me 11 pikë, \n;; dhe lista e dytë përmban pikët sipas sistemit me 21 pikë.\n;; Shembull:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "hy": "(defun calculate-table-tennis-scores (record)\n;; Այս ֆունկցիան ընդունում է սեղանի թենիսի խաղերի գրառումների տող (կազմված 'W', 'L' և 'E') \n;; և հաշվարկում է միավորները 11 միավորի և 21 միավորի համակարգերով:\n;; 'W' նշանակում է խաղացողի կողմից վաստակած միավոր, 'L' նշանակում է մրցակցի կողմից վաստակած միավոր, իսկ 'E' նշում է գրառման ավարտը:\n;; Ֆունկցիան վերադարձնում է երկու ցուցակներ: առաջին ցուցակը պարունակում է միավորները 11 միավորի համակարգով, \n;; իսկ երկրորդ ցուցակը պարունակում է միավորները 21 միավորի համակարգով:\n;; Օրինակ:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "bn": "(defun calculate-table-tennis-scores (record)\n;; এই ফাংশনটি টেবিল টেনিস ম্যাচের রেকর্ডের একটি স্ট্রিং নেয় (যা 'W', 'L', এবং 'E' নিয়ে গঠিত)\n;; এবং ১১-পয়েন্ট এবং ২১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি গণনা করে।\n;; 'W' নির্দেশ করে খেলোয়াড়ের দ্বারা জয়ী একটি পয়েন্ট, 'L' নির্দেশ করে প্রতিপক্ষের দ্বারা জয়ী একটি পয়েন্ট, এবং 'E' রেকর্ডের শেষ নির্দেশ করে।\n;; ফাংশনটি দুটি তালিকা ফেরত দেয়: প্রথম তালিকায় ১১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি থাকে,\n;; এবং দ্বিতীয় তালিকায় ২১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি থাকে।\n;; উদাহরণ:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "bg": "(defun calculate-table-tennis-scores (record)\n;; Тази функция приема низ от записи на мачове по тенис на маса (съставени от 'W', 'L' и 'E') \n;; и изчислява резултатите по системите с 11 точки и 21 точки.\n;; 'W' означава точка, спечелена от играча, 'L' означава точка, спечелена от противника, а 'E' отбелязва края на записа.\n;; Функцията връща два списъка: първият списък съдържа резултатите по системата с 11 точки, \n;; а вторият списък съдържа резултатите по системата с 21 точки.\n;; Пример:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "zh": "(defun calculate-table-tennis-scores (record)\n;; 此函数接受一个乒乓球比赛记录的字符串（由 'W', 'L', 和 'E' 组成）\n;; 并计算在11分制和21分制下的得分。\n;; 'W' 表示玩家赢得一分，'L' 表示对手赢得一分，'E' 标记记录的结束。\n;; 函数返回两个列表：第一个列表包含11分制下的得分，\n;; 第二个列表包含21分制下的得分。\n;; 示例：\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "fr": "(defun calculate-table-tennis-scores (record)\n;; Cette fonction prend une chaîne de caractères des enregistrements de matchs de tennis de table (composée de 'W', 'L', et 'E')\n;; et calcule les scores selon les systèmes de 11 points et de 21 points.\n;; 'W' indique un point gagné par le joueur, 'L' indique un point gagné par l'adversaire, et 'E' marque la fin de l'enregistrement.\n;; La fonction renvoie deux listes : la première liste contient les scores selon le système de 11 points,\n;; et la deuxième liste contient les scores selon le système de 21 points.\n;; Exemple:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "de": "(defun calculate-table-tennis-scores (record)\n;; Diese Funktion nimmt einen String von Tischtennis-Spielaufzeichnungen (bestehend aus 'W', 'L' und 'E') \n;; und berechnet die Punkte nach dem 11-Punkte- und 21-Punkte-System.\n;; 'W' zeigt einen vom Spieler gewonnenen Punkt an, 'L' zeigt einen vom Gegner gewonnenen Punkt an, und 'E' markiert das Ende der Aufzeichnung.\n;; Die Funktion gibt zwei Listen zurück: Die erste Liste enthält die Punkte nach dem 11-Punkte-System, \n;; und die zweite Liste enthält die Punkte nach dem 21-Punkte-System.\n;; Beispiel:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "ha": "(defun calculate-table-tennis-scores (record)\n;; Wannan aiki yana ɗaukar wani rubutu na rikodin wasannin tebur na tennis (wanda aka haɗa da 'W', 'L', da 'E') \n;; kuma yana ƙididdige maki a ƙarƙashin tsarin maki 11 da maki 21.\n;; 'W' yana nuna maki da ɗan wasa ya ci, 'L' yana nuna maki da abokin hamayya ya ci, kuma 'E' yana nuna ƙarshen rikodin.\n;; Aikin yana mayar da jerin abubuwa guda biyu: jerin farko yana ɗauke da maki a ƙarƙashin tsarin maki 11, \n;; kuma jerin na biyu yana ɗauke da maki a ƙarƙashin tsarin maki 21.\n;; Misali:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "hi": "(defun calculate-table-tennis-scores (record)\n;; यह फ़ंक्शन टेबल टेनिस मैच रिकॉर्ड्स की एक स्ट्रिंग लेता है (जो 'W', 'L', और 'E' से बनी होती है)\n;; और 11-पॉइंट और 21-पॉइंट सिस्टम के तहत स्कोर की गणना करता है।\n;; 'W' खिलाड़ी द्वारा जीता गया एक पॉइंट इंगित करता है, 'L' प्रतिद्वंद्वी द्वारा जीता गया एक पॉइंट इंगित करता है, और 'E' रिकॉर्ड के अंत को चिह्नित करता है।\n;; फ़ंक्शन दो सूचियाँ लौटाता है: पहली सूची 11-पॉइंट सिस्टम के तहत स्कोर को शामिल करती है,\n;; और दूसरी सूची 21-पॉइंट सिस्टम के तहत स्कोर को शामिल करती है।\n;; उदाहरण:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "hu": "(defun calculate-table-tennis-scores (record)\n;; Ez a függvény egy asztalitenisz mérkőzés rekordjait tartalmazó karakterláncot vesz (amely 'W', 'L' és 'E' karakterekből áll), \n;; és kiszámítja a pontszámokat 11 pontos és 21 pontos rendszerek szerint.\n;; A 'W' azt jelzi, hogy a játékos nyert egy pontot, az 'L' azt jelzi, hogy az ellenfél nyert egy pontot, az 'E' pedig a rekord végét jelöli.\n;; A függvény két listát ad vissza: az első lista a pontszámokat tartalmazza a 11 pontos rendszer szerint, \n;; a második lista pedig a pontszámokat tartalmazza a 21 pontos rendszer szerint.\n;; Példa:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "prompt_bertscore": {
      "sq": "0.9861443391405303",
      "hy": "0.9855283863289411",
      "bn": "0.9931114983857101",
      "bg": "0.9886232462958457",
      "zh": "0.9777541918456166",
      "fr": "0.984195179211435",
      "de": "0.9813267578789102",
      "ha": "0.9810379493048854",
      "hi": "0.9880247729577877",
      "hu": "0.9653658136108517"
    },
    "canonical_solution": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))",
    "instruction": {
      "en": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nՏրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\n请提供一段中文的简洁自然语言描述（文档字符串），用于描述这段 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.918271940680147",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8686320235253371",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.8898221112045199",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun test-calculate-table-tennis-scores ()\n(assert (equal (calculate-table-tennis-scores \"WWLLWE\") '((\"3:2\") (\"3:2\"))))\n(assert (equal (calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\") '((\"11:0\" \"2:1\") (\"13:1\"))))\n(assert (equal (calculate-table-tennis-scores \"WLWLWLWLWLE\") '((\"5:5\") (\"5:5\"))))\n(assert (equal (calculate-table-tennis-scores \"LWE\") '((\"1:1\") (\"1:1\")))))\n\n(test-calculate-table-tennis-scores)",
    "entry_point": "calculate-table-tennis-scores",
    "signature": "(defun calculate-table-tennis-scores (record)",
    "docstring": {
      "en": "This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "sq": "Kjo funksion merr një varg të regjistrimeve të ndeshjeve të pingpongut (të përbëra nga 'W', 'L', dhe 'E') dhe llogarit pikët sipas sistemeve me 11 pikë dhe 21 pikë. 'W' tregon një pikë të fituar nga lojtari, 'L' tregon një pikë të fituar nga kundërshtari, dhe 'E' shënon fundin e regjistrimit. Funksioni kthen dy lista: lista e parë përmban pikët sipas sistemit me 11 pikë, dhe lista e dytë përmban pikët sipas sistemit me 21 pikë.\nShembull:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hy": "Այս ֆունկցիան ընդունում է սեղանի թենիսի խաղերի գրառումների տող (կազմված 'W', 'L' և 'E' տառերից) և հաշվարկում է միավորները 11-միավորային և 21-միավորային համակարգերով: 'W' նշում է խաղացողի կողմից հաղթած միավոր, 'L' նշում է հակառակորդի կողմից հաղթած միավոր, իսկ 'E' նշում է գրառման ավարտը: Ֆունկցիան վերադարձնում է երկու ցուցակներ. առաջին ցուցակը պարունակում է միավորները 11-միավորային համակարգով, իսկ երկրորդ ցուցակը պարունակում է միավորները 21-միավորային համակարգով:\nՕրինակ:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "bn": "এই ফাংশনটি একটি টেবিল টেনিস ম্যাচের রেকর্ডের স্ট্রিং (যা 'W', 'L', এবং 'E' দ্বারা গঠিত) গ্রহণ করে এবং ১১-পয়েন্ট এবং ২১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলো গণনা করে। 'W' নির্দেশ করে খেলোয়াড়ের দ্বারা জয়ী হওয়া একটি পয়েন্ট, 'L' নির্দেশ করে প্রতিপক্ষের দ্বারা জয়ী হওয়া একটি পয়েন্ট, এবং 'E' রেকর্ডের সমাপ্তি চিহ্নিত করে। ফাংশনটি দুটি তালিকা প্রদান করে: প্রথম তালিকায় ১১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলো থাকে, এবং দ্বিতীয় তালিকায় ২১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলো থাকে। \nউদাহরণ:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "bg": "Тази функция приема низ от записи на мачове по тенис на маса (съставен от 'W', 'L' и 'E') и изчислява резултатите по системите за 11 точки и 21 точки. 'W' означава точка, спечелена от играча, 'L' означава точка, спечелена от противника, а 'E' отбелязва края на записа. Функцията връща два списъка: първият списък съдържа резултатите по системата за 11 точки, а вторият списък съдържа резултатите по системата за 21 точки. Пример:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "zh": "此函数接受一串乒乓球比赛记录（由 'W'、'L' 和 'E' 组成），并计算在 11 分制和 21 分制下的得分。\n'W' 表示玩家赢得一分，'L' 表示对手赢得一分，'E' 标志记录的结束。\n函数返回两个列表：第一个列表包含 11 分制下的得分，第二个列表包含 21 分制下的得分。\n示例：\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "fr": "Cette fonction prend une chaîne d'enregistrements de matchs de tennis de table (composée de 'W', 'L' et 'E') et calcule les scores selon les systèmes à 11 points et à 21 points. 'W' indique un point gagné par le joueur, 'L' indique un point gagné par l'adversaire, et 'E' marque la fin de l'enregistrement. La fonction renvoie deux listes : la première liste contient les scores selon le système à 11 points, et la deuxième liste contient les scores selon le système à 21 points.\nExemple:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "de": "Diese Funktion nimmt einen String von Tischtennis-Spielaufzeichnungen (bestehend aus 'W', 'L' und 'E') und berechnet die Punktestände nach dem 11-Punkte- und 21-Punkte-System. 'W' zeigt einen vom Spieler gewonnenen Punkt an, 'L' zeigt einen vom Gegner gewonnenen Punkt an, und 'E' markiert das Ende der Aufzeichnung. Die Funktion gibt zwei Listen zurück: Die erste Liste enthält die Punktestände nach dem 11-Punkte-System, und die zweite Liste enthält die Punktestände nach dem 21-Punkte-System. Beispiel:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "ha": "Wannan aikin yana ɗaukar kirtani na rikodin wasannin tebur na tennis (wanda aka haɗa da 'W', 'L', da 'E') kuma yana ƙididdige maki a ƙarƙashin tsarin maki na 11 da 21. 'W' yana nuna maki da ɗan wasa ya ci, 'L' yana nuna maki da abokin hamayya ya ci, kuma 'E' yana nuna ƙarshen rikodin. Aikin yana dawowa da jerin biyu: jerin na farko yana ƙunshe da maki a ƙarƙashin tsarin maki na 11, kuma jerin na biyu yana ƙunshe da maki a ƙarƙashin tsarin maki na 21.\n\nMisali:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hi": "यह फ़ंक्शन टेबल टेनिस मैच रिकॉर्ड्स की एक स्ट्रिंग लेता है (जो 'W', 'L', और 'E' से बनी होती है) और 11-पॉइंट और 21-पॉइंट सिस्टम के तहत स्कोर की गणना करता है। 'W' खिलाड़ी द्वारा जीता गया एक पॉइंट इंगित करता है, 'L' प्रतिद्वंद्वी द्वारा जीता गया एक पॉइंट इंगित करता है, और 'E' रिकॉर्ड के अंत को चिह्नित करता है। फ़ंक्शन दो सूचियाँ लौटाता है: पहली सूची 11-पॉइंट सिस्टम के तहत स्कोर को शामिल करती है, और दूसरी सूची 21-पॉइंट सिस्टम के तहत स्कोर को शामिल करती है।\nउदाहरण:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hu": "Ez a függvény egy asztalitenisz mérkőzés rekordjait tartalmazó karakterláncot (amely 'W', 'L' és 'E' karakterekből áll) fogad, és kiszámítja a pontszámokat a 11 pontos és 21 pontos rendszerek szerint. A 'W' azt jelzi, hogy a játékos nyert egy pontot, az 'L' azt jelzi, hogy az ellenfél nyert egy pontot, az 'E' pedig a rekord végét jelöli. A függvény két listát ad vissza: az első lista a 11 pontos rendszer szerinti pontszámokat tartalmazza, a második lista pedig a 21 pontos rendszer szerinti pontszámokat tartalmazza.\nPélda:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "docstring_bertscore": {
      "sq": "0.9659889171161582",
      "hy": "0.9725492813409784",
      "bn": "0.9914529347040688",
      "bg": "0.9861278528189045",
      "zh": "0.9876716081403076",
      "fr": "0.9810210657224975",
      "de": "0.9755150315602104",
      "ha": "0.9648601006607369",
      "hi": "0.990383508732577",
      "hu": "0.9574277490631734"
    }
  },
  {
    "task_id": "Common Lisp/38",
    "prompt": {
      "en": "(defun count-output-sequences (n)\n;; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\n;; Example:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "sq": "(defun count-output-sequences (n)\n;; Kjo funksion llogarit numrin total të sekuencave të ndryshme të daljes që mund të merren duke përdorur një stack \n;; me operacionet push dhe pop në një sekuencë numrash nga 1 në n.\n;; Operacionet janë: \n;; 1. Shtyje numrin tjetër nga sekuenca e hyrjes në stack.\n;; 2. Nxirr numrin në krye të stack dhe shtoje atë në sekuencën e daljes.\n;; Ai numëron të gjitha sekuencat e mundshme të këtyre operacioneve që rezultojnë në të gjitha numrat që lëvizin nga sekuenca e hyrjes në sekuencën e daljes.\n;; Shembull:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "hy": "(defun count-output-sequences (n)\n;; Այս ֆունկցիան հաշվարկում է տարբեր ելքային հաջորդականությունների ընդհանուր քանակը, որոնք կարելի է ստանալ օգտագործելով push և pop գործողություններով \n;; 1-ից n թվերի հաջորդականության վրա:\n;; Գործողությունները հետևյալն են՝ \n;; 1. Մուտքային հաջորդականությունից հաջորդ թիվը դնել stack-ի վրա:\n;; 2. Stack-ի վերևի թիվը հանել և ավելացնել ելքային հաջորդականությանը:\n;; Այն հաշվում է բոլոր հնարավոր հաջորդականությունները այս գործողությունների, որոնք բերում են բոլոր թվերի տեղափոխմանը մուտքային հաջորդականությունից ելքային հաջորդականություն:\n;; Օրինակ:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "bn": "(defun count-output-sequences (n)\n;; এই ফাংশনটি স্ট্যাক ব্যবহার করে বিভিন্ন আউটপুট সিকোয়েন্সের মোট সংখ্যা গণনা করে \n;; যেখানে অপারেশনগুলি হল পুশ এবং পপ একটি সংখ্যা সিকোয়েন্সের উপর ১ থেকে n পর্যন্ত।\n;; অপারেশনগুলি হল:\n;; ১. ইনপুট সিকোয়েন্স থেকে পরবর্তী সংখ্যাটি স্ট্যাকে পুশ করুন।\n;; ২. স্ট্যাকের উপরের সংখ্যাটি পপ করুন এবং এটি আউটপুট সিকোয়েন্সে যোগ করুন।\n;; এটি এই অপারেশনগুলির সমস্ত সম্ভাব্য সিকোয়েন্স গণনা করে যা ইনপুট সিকোয়েন্স থেকে সমস্ত সংখ্যা আউটপুট সিকোয়েন্সে স্থানান্তরিত করে।\n;; উদাহরণ:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "bg": "(defun count-output-sequences (n)\n;; Тази функция изчислява общия брой различни изходни последователности, които могат да бъдат получени чрез използване на стек \n;; с операции push и pop върху последователност от числа от 1 до n.\n;; Операциите са:\n;; 1. Поставяне на следващото число от входната последователност в стека.\n;; 2. Изваждане на горното число от стека и добавянето му към изходната последователност.\n;; Тя брои всички възможни последователности от тези операции, които водят до преместване на всички числа от входната последователност към изходната последователност.\n;; Пример:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "zh": "(defun count-output-sequences (n)\n;; 此函数计算通过使用堆栈对从1到n的数字序列进行压入和弹出操作可以获得的不同输出序列的总数。\n;; 操作包括：\n;; 1. 将输入序列中的下一个数字压入堆栈。\n;; 2. 从堆栈中弹出顶部数字并将其添加到输出序列。\n;; 它计算所有可能的操作序列，这些操作序列导致所有数字从输入序列移动到输出序列。\n;; 示例:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "fr": "(defun count-output-sequences (n)\n;; Cette fonction calcule le nombre total de séquences de sortie différentes qui peuvent être obtenues en utilisant une pile\n;; avec les opérations push et pop sur une séquence de nombres de 1 à n.\n;; Les opérations sont :\n;; 1. Empiler le nombre suivant de la séquence d'entrée sur la pile.\n;; 2. Dépiler le nombre du haut de la pile et l'ajouter à la séquence de sortie.\n;; Elle compte toutes les séquences possibles de ces opérations qui entraînent le déplacement de tous les nombres de la séquence d'entrée à la séquence de sortie.\n;; Exemple:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "de": "(defun count-output-sequences (n)\n;; Diese Funktion berechnet die Gesamtanzahl der verschiedenen Ausgabesequenzen, die durch die Verwendung eines Stacks \n;; mit den Operationen push und pop auf einer Zahlenfolge von 1 bis n erhalten werden können.\n;; Die Operationen sind: \n;; 1. Die nächste Zahl aus der Eingabesequenz auf den Stack legen.\n;; 2. Die oberste Zahl vom Stack nehmen und zur Ausgabesequenz hinzufügen.\n;; Sie zählt alle möglichen Sequenzen dieser Operationen, die dazu führen, dass alle Zahlen von der Eingabesequenz in die Ausgabesequenz verschoben werden.\n;; Beispiel:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "ha": "(defun count-output-sequences (n)\n;; Wannan aikin yana ƙididdige jimillar adadin jerin fitarwa daban-daban da za a iya samu ta amfani da sito\n;; tare da ayyuka tura da fitarwa akan jerin lambobi daga 1 zuwa n.\n;; Ayyukan sune:\n;; 1. Tura lamba ta gaba daga jerin shigarwa zuwa sito.\n;; 2. Fitar da lamba ta sama daga sito kuma ƙara ta zuwa jerin fitarwa.\n;; Yana ƙididdige dukkan yiwuwar jerin waɗannan ayyukan da ke haifar da duk lambobi suna motsawa daga jerin shigarwa zuwa jerin fitarwa.\n;; Misali:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "hi": "(defun count-output-sequences (n)\n;; यह फ़ंक्शन उन सभी विभिन्न आउटपुट अनुक्रमों की कुल संख्या की गणना करता है जो 1 से n तक की संख्याओं के अनुक्रम पर पुश और पॉप ऑपरेशनों का उपयोग करके एक स्टैक द्वारा प्राप्त किए जा सकते हैं।\n;; ऑपरेशन्स हैं:\n;; 1. इनपुट अनुक्रम से अगली संख्या को स्टैक पर पुश करें।\n;; 2. स्टैक से शीर्ष संख्या को पॉप करें और इसे आउटपुट अनुक्रम में जोड़ें।\n;; यह उन सभी संभावित अनुक्रमों की गणना करता है जो इन ऑपरेशनों के परिणामस्वरूप सभी संख्याओं को इनपुट अनुक्रम से आउटपुट अनुक्रम में स्थानांतरित करते हैं।\n;; उदाहरण:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "hu": "(defun count-output-sequences (n)\n;; Ez a függvény kiszámítja a különböző kimeneti sorozatok teljes számát, amelyeket egy verem használatával lehet elérni \n;; a push és pop műveletekkel egy 1-től n-ig terjedő számsorozaton.\n;; A műveletek a következők: \n;; 1. A következő számot a bemeneti sorozatból a verembe helyezzük.\n;; 2. A verem tetején lévő számot kivesszük és hozzáadjuk a kimeneti sorozathoz.\n;; Minden lehetséges műveletsorozatot megszámol, amely az összes számot a bemeneti sorozatból a kimeneti sorozatba mozgatja.\n;; Példa:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14"
    },
    "prompt_bertscore": {
      "sq": "0.9787612478774635",
      "hy": "0.9675865012708218",
      "bn": "0.9611522673379587",
      "bg": "0.9876239368488592",
      "zh": "0.9656371427113454",
      "fr": "0.9821729233021188",
      "de": "0.993162347763255",
      "ha": "0.9516899132462187",
      "hi": "0.9615721719634663",
      "hu": "0.9553923835487089"
    },
    "canonical_solution": "(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))",
    "instruction": {
      "en": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8685243658588161",
      "bg": "0.8335809119663965",
      "zh": "0.8724534734260673",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.8822235059780303",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun test-count-output-sequences ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(test-count-output-sequences)",
    "entry_point": "count-output-sequences",
    "signature": "(defun count-output-sequences (n)",
    "docstring": {
      "en": "This function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "sq": "Kjo funksion llogarit numrin total të sekuencave të ndryshme të daljes që mund të merren duke përdorur një stack me operacionet shtytje dhe tërheqje mbi një sekuencë numrash nga 1 deri në n.  \nOperacionet janë:  \n1. Shtyje numrin e radhës nga sekuenca hyrëse në stack.  \n2. Tërheq numrin në krye të stack dhe shtoje atë në sekuencën e daljes.  \nNumëron të gjitha sekuencat e mundshme të këtyre operacioneve që rezultojnë në të gjitha numrat që lëvizin nga sekuenca hyrëse në sekuencën e daljes.  \nShembull:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "hy": "Այս ֆունկցիան հաշվարկում է տարբեր ելքային հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ստացվել օգտագործելով push և pop գործողություններով stack-ի վրա, 1-ից n թվերի հաջորդականության համար:\nԳործողությունները հետևյալն են՝ \n1. Հաջորդ թիվը մուտքային հաջորդականությունից տեղադրել stack-ի վրա:\n2. Հանել stack-ի վերևի թիվը և ավելացնել այն ելքային հաջորդականությանը:\nԱյն հաշվում է բոլոր հնարավոր հաջորդականությունները այս գործողությունների, որոնք բերում են բոլոր թվերի տեղափոխմանը մուտքային հաջորդականությունից ելքային հաջորդականություն:\nՕրինակ:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "bn": "এই ফাংশনটি মোট ভিন্ন আউটপুট সিকোয়েন্সের সংখ্যা গণনা করে যা একটি স্ট্যাক ব্যবহার করে প্রাপ্ত হতে পারে পুশ এবং পপ অপারেশনগুলির মাধ্যমে ১ থেকে n পর্যন্ত সংখ্যার একটি সিকোয়েন্সে। \nঅপারেশনগুলি হল: \n1. ইনপুট সিকোয়েন্স থেকে পরবর্তী সংখ্যাটি স্ট্যাকে পুশ করুন।\n2. স্ট্যাকের শীর্ষ সংখ্যাটি পপ করুন এবং এটি আউটপুট সিকোয়েন্সে যোগ করুন।\nএটি এই অপারেশনগুলির সমস্ত সম্ভাব্য সিকোয়েন্স গণনা করে যা সমস্ত সংখ্যাকে ইনপুট সিকোয়েন্স থেকে আউটপুট সিকোয়েন্সে স্থানান্তরিত করে।\nউদাহরণ:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "bg": "Тази функция изчислява общия брой различни изходни последователности, които могат да бъдат получени чрез използване на стек с операции push и pop върху последователност от числа от 1 до n.  \nОперациите са:  \n1. Поставете следващото число от входната последователност в стека.  \n2. Извадете най-горното число от стека и го добавете към изходната последователност.  \nТя брои всички възможни последователности от тези операции, които водят до преместване на всички числа от входната последователност към изходната последователност.  \nПример:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "zh": "该函数计算通过对从1到n的数字序列使用栈操作（压入和弹出）可以获得的不同输出序列的总数。  \n操作包括：  \n1. 将输入序列中的下一个数字压入栈中。  \n2. 从栈中弹出顶部数字并将其添加到输出序列中。  \n它计算所有可能的操作序列，这些操作序列会导致所有数字从输入序列移动到输出序列。  \n示例：  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "fr": "Cette fonction calcule le nombre total de séquences de sortie différentes qui peuvent être obtenues en utilisant une pile avec les opérations push et pop sur une séquence de nombres de 1 à n.  \nLes opérations sont :  \n1. Empiler le nombre suivant de la séquence d'entrée sur la pile.  \n2. Dépiler le nombre du haut de la pile et l'ajouter à la séquence de sortie.  \nElle compte toutes les séquences possibles de ces opérations qui aboutissent à ce que tous les nombres soient déplacés de la séquence d'entrée à la séquence de sortie.  \nExemple:\n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "de": "Diese Funktion berechnet die Gesamtanzahl der verschiedenen Ausgabesequenzen, die durch die Verwendung eines Stacks mit den Operationen push und pop auf einer Zahlenfolge von 1 bis n erhalten werden können.  \nDie Operationen sind:  \n1. Die nächste Zahl aus der Eingabesequenz auf den Stack legen.  \n2. Die oberste Zahl vom Stack entfernen und zur Ausgabesequenz hinzufügen.  \nSie zählt alle möglichen Sequenzen dieser Operationen, die dazu führen, dass alle Zahlen von der Eingabesequenz zur Ausgabesequenz verschoben werden.  \nBeispiel:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "ha": "Wannan aikin yana ƙididdige jimillar adadin jerin fitarwa daban-daban da za a iya samu ta amfani da turawa da fitarwa a kan jerin lambobi daga 1 zuwa n.\nAyyukan sune:\n1. Tura lamba ta gaba daga jerin shigarwa zuwa kan turawa.\n2. Fitar da lamba ta sama daga turawa kuma ƙara ta zuwa jerin fitarwa.\nYana ƙididdige dukkan yiwuwar jerin waɗannan ayyukan da ke haifar da dukkan lambobi suna motsawa daga jerin shigarwa zuwa jerin fitarwa.\nMisali:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "hi": "यह फ़ंक्शन उन सभी विभिन्न आउटपुट अनुक्रमों की कुल संख्या की गणना करता है जिन्हें 1 से n तक की संख्याओं के अनुक्रम पर पुश और पॉप संचालन का उपयोग करके एक स्टैक के माध्यम से प्राप्त किया जा सकता है। \nसंचालन हैं: \n1. इनपुट अनुक्रम से अगली संख्या को स्टैक पर पुश करें।\n2. स्टैक से शीर्ष संख्या को पॉप करें और इसे आउटपुट अनुक्रम में जोड़ें।\nयह उन सभी संभावित अनुक्रमों की गणना करता है जो इन संक्रियाओं के माध्यम से इनपुट अनुक्रम से आउटपुट अनुक्रम में सभी संख्याओं को स्थानांतरित करने का परिणाम देते हैं।\nउदाहरण:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "hu": "Ez a függvény kiszámítja a különböző kimeneti sorozatok összes számát, amelyeket egy verem használatával lehet elérni, a push és pop műveletekkel egy 1-től n-ig terjedő számsorozaton.\nA műveletek a következők:\n1. A következő számot a bemeneti sorozatból a verembe helyezzük.\n2. A verem tetején lévő számot kivesszük, és hozzáadjuk a kimeneti sorozathoz.\nSzámolja az összes lehetséges műveletsorozatot, amelyek eredményeként az összes szám átkerül a bemeneti sorozatból a kimeneti sorozatba.\nPélda:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14"
    },
    "docstring_bertscore": {
      "sq": "0.97329235759643",
      "hy": "0.9662181365758724",
      "bn": "0.969193421053394",
      "bg": "0.9853327354036218",
      "zh": "0.9722845070430589",
      "fr": "0.9823532796880985",
      "de": "0.9872824912238602",
      "ha": "0.9401993443337314",
      "hi": "0.960340266340288",
      "hu": "0.9469756197827366"
    }
  },
  {
    "task_id": "Common Lisp/39",
    "prompt": {
      "en": "(defun max-herb-value (time-limit herb-info)\n;; This function calculates the maximum total value of herbs that can be collected within a given time limit.\n;; 'time-limit' is the total time available for collecting herbs.\n;; 'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\n;; The function uses a dynamic programming approach to determine the maximum value that can be obtained.\n;; Example:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "sq": "(defun max-herb-value (time-limit herb-info)\n;; Kjo funksion llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohor.\n;; 'time-limit' është koha totale e disponueshme për mbledhjen e bimëve.\n;; 'herb-info' është një listë çiftesh, ku çdo çift përmban dy numra të plotë: koha e kërkuar për të mbledhur një bimë dhe vlera e saj.\n;; Funksioni përdor një qasje të programimit dinamik për të përcaktuar vlerën maksimale që mund të merret.\n;; Shembull:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "hy": "(defun max-herb-value (time-limit herb-info)\n;; Այս ֆունկցիան հաշվարկում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակային սահմանափակման ընթացքում։\n;; 'time-limit'-ը խոտաբույսերի հավաքման համար հասանելի ընդհանուր ժամանակն է։\n;; 'herb-info' ցուցակ է զույգերով, որտեղ յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ՝ խոտաբույսի հավաքման համար պահանջվող ժամանակը և դրա արժեքը։\n;; Ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում առավելագույն արժեքը որոշելու համար։\n;; Օրինակ:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "bn": "(defun max-herb-value (time-limit herb-info)\n;; এই ফাংশনটি প্রদত্ত সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক মোট মূল্যমানের ভেষজ সংগ্রহ করা যায় তা গণনা করে।\n;; 'time-limit' হল ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n;; 'herb-info' হল জোড়ার একটি তালিকা, প্রতিটি জোড়ায় দুটি পূর্ণসংখ্যা থাকে: একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মূল্যমান।\n;; ফাংশনটি সর্বাধিক মূল্যমান নির্ধারণ করতে একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে যা অর্জন করা যেতে পারে।\n;; উদাহরণ:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "bg": "(defun max-herb-value (time-limit herb-info)\n;; Тази функция изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено времево ограничение.\n;; 'time-limit' е общото време, налично за събиране на билки.\n;; 'herb-info' е списък от двойки, всяка двойка съдържаща две цели числа: времето, необходимо за събиране на билка и нейната стойност.\n;; Функцията използва подход на динамично програмиране, за да определи максималната стойност, която може да бъде получена.\n;; Пример:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "zh": "(defun max-herb-value (time-limit herb-info)\n;; 此函数计算在给定时间限制内可以收集的草药的最大总价值。\n;; 'time-limit' 是收集草药的总可用时间。\n;; 'herb-info' 是一个对的列表，每对包含两个整数：收集一种草药所需的时间及其价值。\n;; 该函数使用动态规划方法来确定可以获得的最大价值。\n;; 例子:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "fr": "(defun max-herb-value (time-limit herb-info)\n;; Cette fonction calcule la valeur totale maximale des herbes qui peuvent être collectées dans une limite de temps donnée.\n;; 'time-limit' est le temps total disponible pour la collecte des herbes.\n;; 'herb-info' est une liste de paires, chaque paire contenant deux entiers : le temps nécessaire pour collecter une herbe et sa valeur.\n;; La fonction utilise une approche de programmation dynamique pour déterminer la valeur maximale qui peut être obtenue.\n;; Exemple:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "de": "(defun max-herb-value (time-limit herb-info)\n;; Diese Funktion berechnet den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gesammelt werden können.\n;; 'time-limit' ist die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n;; 'herb-info' ist eine Liste von Paaren, wobei jedes Paar zwei ganze Zahlen enthält: die benötigte Zeit zum Sammeln eines Krauts und dessen Wert.\n;; Die Funktion verwendet einen dynamischen Programmieransatz, um den maximalen Wert zu bestimmen, der erreicht werden kann.\n;; Beispiel:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "ha": "(defun max-herb-value (time-limit herb-info)\n;; Wannan aikin yana ƙididdige jimillar darajar ganyayyaki mafi girma da za a iya tattarawa a cikin iyakar lokaci da aka bayar.\n;; 'time-limit' shine jimillar lokacin da ake da shi don tattara ganyayyaki.\n;; 'herb-info' jerin ma'aurata ne, kowanne ma'aurata suna dauke da lambobi biyu: lokacin da ake bukata don tattara wani ganye da darajarsa.\n;; Aikin yana amfani da hanyar shirye-shiryen motsi don tantance darajar da za a iya samu.\n;; Misali:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "hi": "(defun max-herb-value (time-limit herb-info)\n;; यह फ़ंक्शन अधिकतम कुल मूल्य की गणना करता है जो दिए गए समय सीमा के भीतर जड़ी-बूटियों को एकत्रित करके प्राप्त किया जा सकता है।\n;; 'time-limit' जड़ी-बूटियों को एकत्रित करने के लिए उपलब्ध कुल समय है।\n;; 'herb-info' जोड़ों की एक सूची है, प्रत्येक जोड़ा दो पूर्णांक शामिल करता है: जड़ी-बूटी को एकत्रित करने के लिए आवश्यक समय और उसका मूल्य।\n;; फ़ंक्शन अधिकतम मूल्य निर्धारित करने के लिए एक गतिशील प्रोग्रामिंग दृष्टिकोण का उपयोग करता है।\n;; उदाहरण:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "hu": "(defun max-herb-value (time-limit herb-info)\n;; Ez a függvény kiszámítja a maximális összértéket, amelyet a megadott időkorláton belül gyűjthető gyógynövényekből lehet elérni.\n;; A 'time-limit' a gyógynövények gyűjtésére rendelkezésre álló összes idő.\n;; A 'herb-info' egy párokból álló lista, ahol minden pár két egész számot tartalmaz: a gyógynövény gyűjtéséhez szükséges időt és annak értékét.\n;; A függvény dinamikus programozási megközelítést alkalmaz a maximális elérhető érték meghatározásához.\n;; Példa:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14"
    },
    "prompt_bertscore": {
      "sq": "0.9946850482642685",
      "hy": "0.9852930093274148",
      "bn": "0.9938521910765892",
      "bg": "0.9956205973589428",
      "zh": "0.9906796666307",
      "fr": "1",
      "de": "0.9930586627043548",
      "ha": "0.9788484466147379",
      "hi": "0.9783514734013886",
      "hu": "0.9694506473968342"
    },
    "canonical_solution": "(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))",
    "instruction": {
      "en": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nՏվեք կարճ բնութագիր (docstring) Common Lisp կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nনিচে দেওয়া Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\n请为以下 Common Lisp 代码提供简明的自然语言描述（文档字符串），使用不超过 500 个字符的中文。",
      "fr": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9571526459854401",
      "hy": "0.9038871284856004",
      "bn": "0.8669917338387509",
      "bg": "0.8335809119663965",
      "zh": "0.8666423429985105",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9443179452844898"
    },
    "level": "",
    "test": "(defun test-max-herb-value ()\n(assert (equal (max-herb-value 70 '((71 100) (69 1) (1 2))) 3))\n(assert (equal (max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))) 14))\n(assert (equal (max-herb-value 15 '((5 10) (10 15) (20 25))) 25))\n(assert (equal (max-herb-value 100 '((50 60) (50 70))) 130))\n(assert (equal (max-herb-value 5 '((2 3) (2 4) (1 1))) 8)))\n\n(test-max-herb-value)",
    "entry_point": "max-herb-value",
    "signature": "(defun max-herb-value (time-limit herb-info)",
    "docstring": {
      "en": "This function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "sq": "Kjo funksion llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri kohor të dhënë.\n'time-limit' është koha totale e disponueshme për mbledhjen e bimëve.\n'herb-info' është një listë çiftesh, ku secili çift përmban dy numra të plotë: koha e nevojshme për të mbledhur një bimë dhe vlera e saj.\nFunksioni përdor një qasje të programimit dinamik për të përcaktuar vlerën maksimale që mund të merret.\nShembull:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "hy": "Այս ֆունկցիան հաշվարկում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել տրված ժամանակային սահմանափակման շրջանակներում։  \n'time-limit' -ը խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակն է։  \n'herb-info' -ն զույգերի ցուցակ է, որտեղ յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ՝ խոտաբույս հավաքելու համար պահանջվող ժամանակը և դրա արժեքը։  \nՖունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար հնարավոր առավելագույն արժեքը։  \nՕրինակ:  \n>>> max-herb-value 70 '((71 100) (69 1) (1 2))  \n3  \n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))  \n14  ",
      "bn": "এই ফাংশনটি একটি নির্দিষ্ট সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক ঔষধি গাছের মোট মান সংগ্রহ করা যায় তা গণনা করে।\n'time-limit' হল ঔষধি গাছ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n'herb-info' হল জোড়ার একটি তালিকা, প্রতিটি জোড়ায় দুটি পূর্ণসংখ্যা থাকে: একটি ঔষধি গাছ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মান।\nফাংশনটি সর্বাধিক মান নির্ধারণ করতে একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে যা প্রাপ্ত হতে পারে।\nউদাহরণ:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "bg": "Тази функция изчислява максималната обща стойност на билки, които могат да бъдат събрани в рамките на даден времеви лимит.\n'time-limit' е общото време, налично за събиране на билки.\n'herb-info' е списък от двойки, всяка двойка съдържаща два цели числа: времето, необходимо за събиране на билка и нейната стойност.\nФункцията използва динамично програмиране, за да определи максималната стойност, която може да бъде получена.\nПример:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "zh": "此函数计算在给定时间限制内可以收集的草药的最大总价值。\n'time-limit' 是可用于收集草药的总时间。\n'herb-info' 是一个对列表，每对包含两个整数：收集一种草药所需的时间及其价值。\n该函数使用动态规划方法来确定可以获得的最大价值。\n示例：\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "fr": "Cette fonction calcule la valeur totale maximale des herbes qui peuvent être collectées dans une limite de temps donnée.\n'time-limit' est le temps total disponible pour la collecte des herbes.\n'herb-info' est une liste de paires, chaque paire contenant deux entiers : le temps nécessaire pour collecter une herbe et sa valeur.\nLa fonction utilise une approche de programmation dynamique pour déterminer la valeur maximale qui peut être obtenue.\nExemple:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "de": "Diese Funktion berechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines gegebenen Zeitlimits gesammelt werden können.\n'time-limit' ist die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n'herb-info' ist eine Liste von Paaren, wobei jedes Paar zwei ganze Zahlen enthält: die zum Sammeln eines Krauts benötigte Zeit und dessen Wert.\nDie Funktion verwendet einen dynamischen Programmieransatz, um den maximalen Wert zu bestimmen, der erzielt werden kann.\nBeispiel:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "ha": "Wannan aikin yana ƙididdige jimillar ƙimar ganyayyaki mafi girma da za a iya tattarawa a cikin iyakar lokaci da aka bayar.\n'time-limit' shine jimillar lokacin da ake da shi don tattara ganyayyaki.\n'herb-info' jerin ma'aurata ne, kowanne ma'aurata suna ɗauke da lambobi biyu: lokacin da ake buƙata don tattara ganye da ƙimar sa.\nAikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade ƙimar da za a iya samu.\nMisali:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "hi": "यह फ़ंक्शन एक दिए गए समय सीमा के भीतर एकत्र किए जा सकने वाले जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है।  \n'time-limit' जड़ी-बूटियों को एकत्र करने के लिए उपलब्ध कुल समय है।  \n'herb-info' जोड़ों की एक सूची है, प्रत्येक जोड़े में दो पूर्णांक होते हैं: एक जड़ी-बूटी को एकत्र करने के लिए आवश्यक समय और उसका मूल्य।  \nफ़ंक्शन यह निर्धारित करने के लिए एक गतिशील प्रोग्रामिंग दृष्टिकोण का उपयोग करता है कि अधिकतम मूल्य क्या प्राप्त किया जा सकता है।  \nउदाहरण:  \n>>> max-herb-value 70 '((71 100) (69 1) (1 2))  \n3  \n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))  \n14  ",
      "hu": "Ez a függvény kiszámítja a maximálisan összegyűjthető gyógynövények összértékét egy adott időkorláton belül.\nA 'time-limit' az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\nA 'herb-info' egy párokból álló lista, ahol minden pár két egész számot tartalmaz: a gyógynövény gyűjtéséhez szükséges időt és annak értékét.\nA függvény dinamikus programozási megközelítést alkalmaz a maximálisan elérhető érték meghatározására.\nPélda:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14"
    },
    "docstring_bertscore": {
      "sq": "0.994870569040155",
      "hy": "0.9821876219503154",
      "bn": "0.9789435905672536",
      "bg": "0.9934090466965003",
      "zh": "0.9952720010402265",
      "fr": "1",
      "de": "0.9932304779839499",
      "ha": "0.9822124507479447",
      "hi": "0.9851484064100214",
      "hu": "0.9803683662904168"
    }
  },
  {
    "task_id": "Common Lisp/40",
    "prompt": {
      "en": "(defun min-box-space (box-capacity item-volumes)\n;; This function calculates the minimum remaining space in a box after optimally packing a given set of items.\n;; Each item has a specific volume, and the box has a fixed capacity.\n;; The function returns the smallest possible remaining space in the box.\n;; Example:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "sq": "(defun min-box-space (box-capacity item-volumes)\n;; Kjo funksion llogarit hapësirën minimale të mbetur në një kuti pas paketimit optimal të një grupi të dhënë artikujsh.\n;; Çdo artikull ka një vëllim specifik, dhe kutia ka një kapacitet të caktuar.\n;; Funksioni kthen hapësirën më të vogël të mundshme të mbetur në kuti.\n;; Shembull:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "hy": "(defun min-box-space (box-capacity item-volumes)\n;; Այս ֆունկցիան հաշվարկում է արկղում մնացած նվազագույն ազատ տարածքը, երբ օպտիմալ կերպով տեղադրվում է տրված իրերի հավաքածուն:\n;; Յուրաքանչյուր իր ունի որոշակի ծավալ, և արկղը ունի ֆիքսված տարողություն:\n;; Ֆունկցիան վերադարձնում է արկղում մնացած հնարավոր ամենափոքր ազատ տարածքը:\n;; Օրինակ:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "bn": "(defun min-box-space (box-capacity item-volumes)\n;; এই ফাংশনটি একটি নির্দিষ্ট সেটের আইটেমগুলি সর্বোত্তমভাবে প্যাক করার পরে একটি বাক্সে সর্বনিম্ন অবশিষ্ট স্থান গণনা করে।\n;; প্রতিটি আইটেমের একটি নির্দিষ্ট আয়তন থাকে, এবং বাক্সের একটি নির্দিষ্ট ক্ষমতা থাকে।\n;; ফাংশনটি বাক্সে সম্ভাব্য সর্বনিম্ন অবশিষ্ট স্থান প্রদান করে।\n;; উদাহরণ:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "bg": "(defun min-box-space (box-capacity item-volumes)\n;; Тази функция изчислява минималното оставащо пространство в кутия след оптимално опаковане на даден набор от предмети.\n;; Всеки предмет има специфичен обем, а кутията има фиксиран капацитет.\n;; Функцията връща най-малкото възможно оставащо пространство в кутията.\n;; Пример:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "zh": "(defun min-box-space (box-capacity item-volumes)\n;; 此函数计算在最佳方式包装给定物品集后，箱子中剩余的最小空间。\n;; 每个物品都有特定的体积，箱子有固定的容量。\n;; 该函数返回箱子中可能的最小剩余空间。\n;; 示例:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "fr": "(defun min-box-space (box-capacity item-volumes)\n;; Cette fonction calcule l'espace restant minimum dans une boîte après avoir emballé de manière optimale un ensemble donné d'articles.\n;; Chaque article a un volume spécifique, et la boîte a une capacité fixe.\n;; La fonction renvoie le plus petit espace restant possible dans la boîte.\n;; Exemple:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "de": "(defun min-box-space (box-capacity item-volumes)\n;; Diese Funktion berechnet den minimal verbleibenden Platz in einer Box nach optimalem Packen einer gegebenen Menge von Gegenständen.\n;; Jeder Gegenstand hat ein spezifisches Volumen, und die Box hat eine feste Kapazität.\n;; Die Funktion gibt den kleinstmöglichen verbleibenden Platz in der Box zurück.\n;; Beispiel:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "ha": "(defun min-box-space (box-capacity item-volumes)\n;; Wannan aikin yana ƙididdige ƙaramin sarari da ya rage a cikin akwati bayan an cika shi da kyau da saitin abubuwa da aka bayar.\n;; Kowane abu yana da takamaiman girma, kuma akwatin yana da iyaka dindindin.\n;; Aikin yana dawowa da ƙaramin sarari mai yiwuwa da ya rage a cikin akwatin.\n;; Misali:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "hi": "(defun min-box-space (box-capacity item-volumes)\n;; यह फ़ंक्शन दिए गए वस्तुओं के सेट को अनुकूल रूप से पैक करने के बाद बॉक्स में बची हुई न्यूनतम जगह की गणना करता है।\n;; प्रत्येक वस्तु की एक विशिष्ट मात्रा होती है, और बॉक्स की एक निश्चित क्षमता होती है।\n;; फ़ंक्शन बॉक्स में बची हुई सबसे छोटी संभव जगह को लौटाता है।\n;; उदाहरण:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "hu": "(defun min-box-space (box-capacity item-volumes)\n;; Ez a függvény kiszámítja a minimális fennmaradó helyet egy dobozban, miután optimálisan bepakoltuk a megadott tárgyakat.\n;; Minden tárgynak van egy adott térfogata, és a doboznak van egy fix kapacitása.\n;; A függvény visszaadja a dobozban lévő legkisebb lehetséges fennmaradó helyet.\n;; Példa:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0"
    },
    "prompt_bertscore": {
      "sq": "0.9937042114427181",
      "hy": "0.9684805366158598",
      "bn": "0.979987591849973",
      "bg": "1",
      "zh": "0.9889478083384567",
      "fr": "1",
      "de": "0.9916003184467966",
      "ha": "0.9753418258679479",
      "hi": "0.9895121172509769",
      "hu": "0.9899435424385846"
    },
    "canonical_solution": "(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))",
    "instruction": {
      "en": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nՏրամադրեք կարճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\n请为以下 Common Lisp 代码提供简明的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nनिम्नलिखित Common Lisp कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9283575969075745",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8724534734260673",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.920036771615642",
      "hi": "0.9077727359994049",
      "hu": "0.9349640433807949"
    },
    "level": "",
    "test": "(defun test-min-box-space ()\n(assert (equal (min-box-space 20 '(5 5 10 6)) 0))\n(assert (equal (min-box-space 25 '(7 8 5 10)) 0))\n(assert (equal (min-box-space 12 '(3 2 2 5)) 0))\n(assert (equal (min-box-space 30 '(10 10 12)) 8))\n(assert (equal (min-box-space 8 '(1 2 3 4)) 0))\n(assert (equal (min-box-space 18 '(2 5 6 8)) 2))\n(assert (equal (min-box-space 11 '(1 2 3)) 5)))\n\n(test-min-box-space)",
    "entry_point": "min-box-space",
    "signature": "(defun min-box-space (box-capacity item-volumes)",
    "docstring": {
      "en": "This function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "sq": "Kjo funksion llogarit hapësirën minimale të mbetur në një kuti pasi të jetë paketuar në mënyrë optimale një grup i caktuar artikujsh.\nÇdo artikull ka një vëllim specifik, dhe kutia ka një kapacitet të caktuar.\nFunksioni kthen hapësirën më të vogël të mundshme të mbetur në kuti.\nShembull:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hy": "Այս ֆունկցիան հաշվարկում է արկղում մնացած նվազագույն տարածքը՝ տրված իրերի հավաքածուն օպտիմալ կերպով փաթեթավորելուց հետո: \nՅուրաքանչյուր իր ունի որոշակի ծավալ, և արկղը ունի ֆիքսված տարողություն: \nՖունկցիան վերադարձնում է արկղում հնարավոր ամենափոքր մնացած տարածքը:\nՕրինակ:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "bn": "এই ফাংশনটি একটি নির্দিষ্ট সেটের আইটেমগুলি সর্বোত্তমভাবে প্যাক করার পরে একটি বাক্সে অবশিষ্ট সর্বনিম্ন স্থান গণনা করে। \nপ্রতিটি আইটেমের একটি নির্দিষ্ট আয়তন থাকে, এবং বাক্সটির একটি নির্দিষ্ট ক্ষমতা থাকে। \nফাংশনটি বাক্সে সম্ভাব্য সবচেয়ে ছোট অবশিষ্ট স্থানটি প্রদান করে।\n\nউদাহরণ:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "bg": "Тази функция изчислява минималното оставащо пространство в кутия след оптимално опаковане на даден набор от предмети. Всеки предмет има специфичен обем, а кутията има фиксиран капацитет. Функцията връща най-малкото възможно оставащо пространство в кутията.\nПример:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "zh": "该函数计算在优化包装给定物品集后箱子中剩余的最小空间。\n每个物品都有特定的体积，箱子有固定的容量。\n该函数返回箱子中可能的最小剩余空间。\n示例：\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "fr": "Cette fonction calcule l'espace restant minimum dans une boîte après avoir emballé de manière optimale un ensemble donné d'articles. Chaque article a un volume spécifique, et la boîte a une capacité fixe. La fonction renvoie le plus petit espace restant possible dans la boîte.\nExemple:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "de": "Diese Funktion berechnet den minimal verbleibenden Raum in einer Box nach optimalem Packen eines gegebenen Satzes von Gegenständen. Jeder Gegenstand hat ein spezifisches Volumen, und die Box hat eine feste Kapazität. Die Funktion gibt den kleinstmöglichen verbleibenden Raum in der Box zurück. Beispiel:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "ha": "Wannan aikin yana ƙididdige ƙaramin sarari da ya rage a cikin akwati bayan an cika shi da kyau tare da saitin abubuwa da aka bayar.\nKowane abu yana da takamaiman girma, kuma akwatin yana da ƙarfin da aka kayyade.\nAikin yana mayar da ƙaramin yuwuwar sarari da ya rage a cikin akwatin.\n\nMisali:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hi": "यह फ़ंक्शन दिए गए वस्तुओं के सेट को सबसे अच्छे तरीके से पैक करने के बाद बॉक्स में बची हुई न्यूनतम जगह की गणना करता है। \nप्रत्येक वस्तु का एक विशिष्ट आयतन होता है, और बॉक्स की एक निश्चित क्षमता होती है। \nफ़ंक्शन बॉक्स में सबसे छोटी संभव बची हुई जगह को लौटाता है। \nउदाहरण:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hu": "Ez a függvény kiszámítja a minimális fennmaradó helyet egy dobozban, miután optimálisan bepakoltunk egy adott tárgykészletet.\nMinden tárgynak van egy adott térfogata, és a doboznak van egy rögzített kapacitása.\nA függvény visszaadja a lehető legkisebb fennmaradó helyet a dobozban.\nPélda:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9814117716819931",
      "hy": "0.9952066516448661",
      "bn": "0.9798495437351536",
      "bg": "1",
      "zh": "0.9767717659810181",
      "fr": "1",
      "de": "0.9970763594215475",
      "ha": "0.9299067152492656",
      "hi": "0.993987855626836",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/41",
    "prompt": {
      "en": "(defun calculate-expression (a b c)\n  ;; Computes the value of the expression (a+b)*c for given integers a, b, and c.\n  ;; Returns the result of the computation.\n  ;; Example:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "sq": "(defun calculate-expression (a b c)\n  ;; Llogarit vlerën e shprehjes (a+b)*c për numrat e plotë të dhënë a, b, dhe c.\n  ;; Kthen rezultatin e llogaritjes.\n  ;; Shembull:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "hy": "(defun calculate-expression (a b c)\n  ;; Հաշվում է (a+b)*c արտահայտության արժեքը տրված ամբողջ թվերի a, b և c համար:\n  ;; Վերադարձնում է հաշվարկի արդյունքը:\n  ;; Օրինակ:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "bn": "(defun calculate-expression (a b c)\n  ;; প্রদত্ত পূর্ণসংখ্যা a, b, এবং c এর জন্য (a+b)*c অভিব্যক্তির মান গণনা করে।\n  ;; গণনার ফলাফল প্রদান করে।\n  ;; উদাহরণ:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "bg": "(defun calculate-expression (a b c)\n  ;; Изчислява стойността на израза (a+b)*c за дадени цели числа a, b и c.\n  ;; Връща резултата от изчислението.\n  ;; Пример:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "zh": "(defun calculate-expression (a b c)\n  ;; 计算表达式 (a+b)*c 的值，给定整数 a, b 和 c。\n  ;; 返回计算结果。\n  ;; 示例:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "fr": "(defun calculate-expression (a b c)\n  ;; Calcule la valeur de l'expression (a+b)*c pour les entiers donnés a, b, et c.\n  ;; Retourne le résultat du calcul.\n  ;; Exemple:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "de": "(defun calculate-expression (a b c)\n  ;; Berechnet den Wert des Ausdrucks (a+b)*c für gegebene ganze Zahlen a, b und c.\n  ;; Gibt das Ergebnis der Berechnung zurück.\n  ;; Beispiel:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "ha": "(defun calculate-expression (a b c)\n  ;; Lissafi darajar bayyana (a+b)*c don lambobin a, b, da c da aka bayar.\n  ;; Mayar da sakamakon lissafin.\n  ;; Misali:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "hi": "(defun calculate-expression (a b c)\n  ;; दिए गए पूर्णांक a, b, और c के लिए अभिव्यक्ति (a+b)*c का मान गणना करता है।\n  ;; गणना के परिणाम को लौटाता है।\n  ;; उदाहरण:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "hu": "(defun calculate-expression (a b c)\n  ;; Kiszámítja a (a+b)*c kifejezés értékét a megadott egész számokkal a, b és c.\n  ;; Visszaadja a számítás eredményét.\n  ;; Példa:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0"
    },
    "prompt_bertscore": {
      "sq": "0.9867950522688006",
      "hy": "0.9926906006082972",
      "bn": "0.9886105339514595",
      "bg": "0.9926906006082972",
      "zh": "0.9776109793408905",
      "fr": "0.9886105339514595",
      "de": "0.9926906006082972",
      "ha": "0.979276296455487",
      "hi": "0.9886105339514595",
      "hu": "0.9853013518034183"
    },
    "canonical_solution": "  (* (+ a b) c))",
    "instruction": {
      "en": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս Common Lisp կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.8921522442044402",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.8777588909035091",
      "fr": "0.9711523138711601",
      "de": "0.93952539145088",
      "ha": "0.922724439301425",
      "hi": "0.8995998903413434",
      "hu": "0.9443179452844898"
    },
    "level": "",
    "test": "(defun check-calculate-expression ()\n  (assert (= (calculate-expression 1 2 3) 9))\n  (assert (= (calculate-expression -1 2 3) 3))\n  (assert (= (calculate-expression 0 0 0) 0))\n  (assert (= (calculate-expression 100 -100 1) 0))\n  (assert (= (calculate-expression -5 -5 -5) 50))\n  (assert (= (calculate-expression 10 20 30) 900))\n  (assert (= (calculate-expression 0 10 -2) -20)))",
    "entry_point": "calculate-expression",
    "signature": "(defun calculate-expression (a b c)",
    "docstring": {
      "en": "Computes the value of the expression (a+b)*c for given integers a, b, and c.\n   Returns the result of the computation.\n   Example:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "sq": "Llogarit vlerën e shprehjes (a+b)*c për numrat e dhënë të plotë a, b, dhe c.\n   Kthen rezultatin e llogaritjes.\n   Shembull:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hy": "Հաշվում է (a+b)*c արտահայտության արժեքը տրված ամբողջ թվերի a, b և c համար:\nՎերադարձնում է հաշվարկի արդյունքը:\nՕրինակ:\n>>> (calculate-expression 1 2 3)\n9\n>>> (calculate-expression -1 2 3)\n3\n>>> (calculate-expression 0 0 0)\n0",
      "bn": "প্রদত্ত পূর্ণসংখ্যা a, b, এবং c এর জন্য (a+b)*c অভিব্যক্তির মান গণনা করে।\n   গণনার ফলাফল প্রদান করে।\n   উদাহরণ:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "bg": "Изчислява стойността на израза (a+b)*c за дадени цели числа a, b и c.  \nВръща резултата от изчислението.  \nПример:  \n>>> (calculate-expression 1 2 3)  \n9  \n>>> (calculate-expression -1 2 3)  \n3  \n>>> (calculate-expression 0 0 0)  \n0",
      "zh": "计算给定整数 a、b 和 c 的表达式 (a+b)*c 的值。  \n返回计算结果。  \n示例：  \n>>> (calculate-expression 1 2 3)  \n9  \n>>> (calculate-expression -1 2 3)  \n3  \n>>> (calculate-expression 0 0 0)  \n0  ",
      "fr": "Calcule la valeur de l'expression (a+b)*c pour des entiers donnés a, b, et c.\nRenvoie le résultat du calcul.\nExemple:\n>>> (calculate-expression 1 2 3)\n9\n>>> (calculate-expression -1 2 3)\n3\n>>> (calculate-expression 0 0 0)\n0",
      "de": "Berechnet den Wert des Ausdrucks (a+b)*c für gegebene ganze Zahlen a, b und c.  \nGibt das Ergebnis der Berechnung zurück.  \nBeispiel:  \n>>> (calculate-expression 1 2 3)  \n9  \n>>> (calculate-expression -1 2 3)  \n3  \n>>> (calculate-expression 0 0 0)  \n0  ",
      "ha": "Lissafa darajar bayyana (a+b)*c don lambobin a, b, da c da aka bayar.\n   Mayar da sakamakon lissafin.\n   Misali:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hi": "दिए गए पूर्णांक a, b, और c के लिए अभिव्यक्ति (a+b)*c का मान गणना करता है।\n   गणना के परिणाम को लौटाता है।\n   उदाहरण:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hu": "Számítja ki a kifejezés (a+b)*c értékét a megadott a, b és c egészekre.\nVisszaadja a számítás eredményét.\nPélda:\n>>> (calculate-expression 1 2 3)\n9\n>>> (calculate-expression -1 2 3)\n3\n>>> (calculate-expression 0 0 0)\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9664270957367211",
      "hy": "0.985066173432273",
      "bn": "0.948224806249065",
      "bg": "0.985066173432273",
      "zh": "0.9717778009410389",
      "fr": "0.9809408190485593",
      "de": "0.985066173432273",
      "ha": "0.9655884782679919",
      "hi": "0.97820011705104",
      "hu": "0.97820011705104"
    }
  },
  {
    "task_id": "Common Lisp/42",
    "prompt": {
      "en": "(defun char-to-ascii (char)\n  ;; Converts a single visible character (excluding space) to its ASCII code.\n  ;; Input: A character (not a string) that is visible and not a space.\n  ;; Output: An integer representing the ASCII code of the input character.\n  ;; Example:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "sq": "(defun char-to-ascii (char)\n  ;; Konverton një karakter të vetëm të dukshëm (përjashto hapësirën) në kodin e tij ASCII.\n  ;; Hyrja: Një karakter (jo një varg) që është i dukshëm dhe jo një hapësirë.\n  ;; Dalja: Një numër i plotë që përfaqëson kodin ASCII të karakterit të dhënë.\n  ;; Shembull:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "hy": "(defun char-to-ascii (char)\n  ;; Տեսանելի մեկ սիմվոլը (բացառությամբ բացատը) փոխակերպում է իր ASCII կոդին։\n  ;; Մուտք: Տեսանելի սիմվոլ (ոչ տող), որը բացատ չէ։\n  ;; Ելք: Թվային արժեք, որը ներկայացնում է մուտքային սիմվոլի ASCII կոդը։\n  ;; Օրինակ:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "bn": "(defun char-to-ascii (char)\n  ;; একটি একক দৃশ্যমান অক্ষর (স্পেস বাদে) এর ASCII কোডে রূপান্তর করে।\n  ;; ইনপুট: একটি অক্ষর (স্ট্রিং নয়) যা দৃশ্যমান এবং স্পেস নয়।\n  ;; আউটপুট: ইনপুট অক্ষরের ASCII কোডের প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা।\n  ;; উদাহরণ:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "bg": "(defun char-to-ascii (char)\n  ;; Преобразува един видим символ (с изключение на интервал) в неговия ASCII код.\n  ;; Вход: Символ (не низ), който е видим и не е интервал.\n  ;; Изход: Цяло число, представляващо ASCII кода на входния символ.\n  ;; Пример:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "zh": "(defun char-to-ascii (char)\n  ;; 将单个可见字符（不包括空格）转换为其ASCII码。\n  ;; 输入：一个可见且不是空格的字符（不是字符串）。\n  ;; 输出：一个整数，表示输入字符的ASCII码。\n  ;; 示例：\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "fr": "(defun char-to-ascii (char)\n  ;; Convertit un seul caractère visible (à l'exclusion de l'espace) en son code ASCII.\n  ;; Entrée : Un caractère (pas une chaîne) qui est visible et n'est pas un espace.\n  ;; Sortie : Un entier représentant le code ASCII du caractère d'entrée.\n  ;; Exemple:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "de": "(defun char-to-ascii (char)\n  ;; Konvertiert ein einzelnes sichtbares Zeichen (außer Leerzeichen) in seinen ASCII-Code.\n  ;; Eingabe: Ein Zeichen (kein String), das sichtbar ist und kein Leerzeichen.\n  ;; Ausgabe: Eine ganze Zahl, die den ASCII-Code des Eingabezeichens darstellt.\n  ;; Beispiel:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "ha": "(defun char-to-ascii (char)\n  ;; Canza alamar harafi guda ɗaya (ban da sarari) zuwa lambar ASCII ɗinta.\n  ;; Shigarwa: Wani harafi (ba kirtani ba) wanda yake bayyane kuma ba sarari ba.\n  ;; Fitarwa: Wani lamba wanda yake wakiltar lambar ASCII na harafin da aka shigar.\n  ;; Misali:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "hi": "(defun char-to-ascii (char)\n  ;; एकल दृश्य वर्ण (स्पेस को छोड़कर) को उसके ASCII कोड में परिवर्तित करता है।\n  ;; इनपुट: एक वर्ण (स्ट्रिंग नहीं) जो दृश्य है और स्पेस नहीं है।\n  ;; आउटपुट: इनपुट वर्ण के ASCII कोड का प्रतिनिधित्व करने वाला एक पूर्णांक।\n  ;; उदाहरण:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "hu": "(defun char-to-ascii (char)\n  ;; Egyetlen látható karaktert (kivéve a szóközt) alakít át ASCII kóddá.\n  ;; Bemenet: Egy karakter (nem egy string), amely látható és nem szóköz.\n  ;; Kimenet: Egy egész szám, amely a bemeneti karakter ASCII kódját jelöli.\n  ;; Példa:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33"
    },
    "prompt_bertscore": {
      "sq": "0.9932221355079465",
      "hy": "0.9726352882959666",
      "bn": "1",
      "bg": "0.9948610347818654",
      "zh": "0.9655525261690245",
      "fr": "1",
      "de": "0.9947911168877411",
      "ha": "0.9664026641998539",
      "hi": "1",
      "hu": "1"
    },
    "canonical_solution": "  (char-code char))",
    "instruction": {
      "en": "defun char-to-ascii (char)\n  (char-code char))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "defun char-to-ascii (char)\n  (char-code char))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "defun char-to-ascii (char)\n  (char-code char))\n\nՏրամադրեք համառոտ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "defun char-to-ascii (char)\n  (char-code char))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "defun char-to-ascii (char)\n  (char-code char))\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "defun char-to-ascii (char)\n  (char-code char))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过500个字符。",
      "fr": "defun char-to-ascii (char)\n  (char-code char))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "defun char-to-ascii (char)\n  (char-code char))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "defun char-to-ascii (char)\n  (char-code char))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "defun char-to-ascii (char)\n  (char-code char))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "defun char-to-ascii (char)\n  (char-code char))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.8984500190655323",
      "bn": "0.8727891587700162",
      "bg": "0.8335809119663965",
      "zh": "0.8923915938135872",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-char-to-ascii ()\n  (assert (= (char-to-ascii #\\A) 65))\n  (assert (= (char-to-ascii #\\!) 33))\n  (assert (= (char-to-ascii #\\~) 126))\n  (assert (= (char-to-ascii #\\0) 48))\n  (assert (= (char-to-ascii #\\Z) 90)))\n\n(check-char-to-ascii)",
    "entry_point": "char-to-ascii",
    "signature": "defun char-to-ascii (char)",
    "docstring": {
      "en": "Converts a single visible character (excluding space) to its ASCII code.\n Input: A character (not a string) that is visible and not a space.\n Output: An integer representing the ASCII code of the input character.\n Example:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "sq": "Konverton një karakter të vetëm të dukshëm (përjashtuar hapësirën) në kodin e tij ASCII.  \nHyrja: Një karakter (jo një varg) që është i dukshëm dhe jo një hapësirë.  \nDalja: Një numër i plotë që përfaqëson kodin ASCII të karakterit të hyrjes.  \nShembull:  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33",
      "hy": "Վերածում է մեկ տեսանելի սիմվոլը (բացառությամբ բացատանիշի) իր ASCII կոդին:\nՄուտք: Սիմվոլ (ոչ տող), որը տեսանելի է և ոչ բացատանիշ:\nԵլք: Թիվ, որը ներկայացնում է մուտքագրված սիմվոլի ASCII կոդը:\nՕրինակ:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "bn": "একটি একক দৃশ্যমান অক্ষর (স্পেস বাদে) তার ASCII কোডে রূপান্তর করে।\nইনপুট: একটি অক্ষর (স্ট্রিং নয়) যা দৃশ্যমান এবং স্পেস নয়।\nআউটপুট: ইনপুট অক্ষরের ASCII কোড উপস্থাপনকারী একটি পূর্ণসংখ্যা।\nউদাহরণ:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "bg": "Преобразува един видим символ (с изключение на интервал) в неговия ASCII код.  \nВход: Символ (не низ), който е видим и не е интервал.  \nИзход: Цяло число, представляващо ASCII кода на входния символ.  \nПример:  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33",
      "zh": "将单个可见字符（不包括空格）转换为其ASCII码。  \n输入：一个可见且不是空格的字符（不是字符串）。  \n输出：一个整数，表示输入字符的ASCII码。  \n示例：  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33  ",
      "fr": "Convertit un seul caractère visible (à l'exclusion de l'espace) en son code ASCII.\nEntrée : Un caractère (pas une chaîne) qui est visible et n'est pas un espace.\nSortie : Un entier représentant le code ASCII du caractère d'entrée.\nExemple :\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "de": "Konvertiert ein einzelnes sichtbares Zeichen (außer Leerzeichen) in seinen ASCII-Code.\nEingabe: Ein Zeichen (kein String), das sichtbar ist und kein Leerzeichen ist.\nAusgabe: Eine Ganzzahl, die den ASCII-Code des Eingabezeichens darstellt.\nBeispiel:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "ha": "Canza wata harafi mai gani guda daya (ban da sarari) zuwa lambar ASCII dinta.\nShigarwa: Wani hali guda (ba kirtani ba) wanda ake iya gani kuma ba sarari ba.\nFitarwa: Lamba mai lamba wadda ke wakiltar lambar ASCII na halin da aka shigar.\nMisali:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "hi": "एकल दृश्य वर्ण (स्पेस को छोड़कर) को इसके ASCII कोड में परिवर्तित करता है।\n इनपुट: एक वर्ण (स्टリング नहीं) जो दृश्य है और स्पेस नहीं है।\n आउटपुट: इनपुट वर्ण के ASCII कोड का एक पूर्णांक।\n उदाहरण:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "hu": "Egyetlen látható karaktert (a szóköz kivételével) alakít át ASCII kóddá.\nBemenet: Egy karakter (nem egy string), amely látható és nem szóköz.\nKimenet: Egy egész szám, amely a bemeneti karakter ASCII kódját képviseli.\nPélda:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9810019972059181",
      "bg": "0.9926379635573229",
      "zh": "0.9603049101324638",
      "fr": "0.9926248539521746",
      "de": "0.9904101252036356",
      "ha": "0.99204048337117",
      "hi": "1",
      "hu": "0.9763115393881603"
    }
  },
  {
    "task_id": "Common Lisp/43",
    "prompt": {
      "en": "(defun ascii-to-char (code)\n  ;; Converts an ASCII code to its corresponding character.\n  ;; Input: An integer representing the ASCII code, guaranteed to be within the range of visible characters (<128 and >0).\n  ;; Output: The character corresponding to the ASCII code.\n  ;; Example:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "sq": "(defun ascii-to-char (code)\n  ;; Konverton një kod ASCII në karakterin përkatës.\n  ;; Hyrja: Një numër i plotë që përfaqëson kodin ASCII, i garantuar të jetë brenda intervalit të karaktereve të dukshëm (<128 dhe >0).\n  ;; Dalja: Karakteri që korrespondon me kodin ASCII.\n  ;; Shembull:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "hy": "(defun ascii-to-char (code)\n  ;; Վերափոխում է ASCII կոդը համապատասխանող սիմվոլի:\n  ;; Մուտք: Թիվ, որը ներկայացնում է ASCII կոդը, երաշխավորված է, որ գտնվում է տեսանելի սիմվոլների տիրույթում (<128 և >0):\n  ;; Ելք: Սիմվոլը, որը համապատասխանում է ASCII կոդին:\n  ;; Օրինակ:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "bn": "(defun ascii-to-char (code)\n  ;; একটি ASCII কোডকে তার সংশ্লিষ্ট অক্ষরে রূপান্তর করে।\n  ;; ইনপুট: একটি পূর্ণসংখ্যা যা ASCII কোডকে প্রতিনিধিত্ব করে, দৃশ্যমান অক্ষরের সীমার মধ্যে থাকার নিশ্চয়তা দেওয়া হয় (<128 এবং >0)।\n  ;; আউটপুট: ASCII কোডের সাথে সংশ্লিষ্ট অক্ষর।\n  ;; উদাহরণ:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "bg": "(defun ascii-to-char (code)\n  ;; Преобразува ASCII код в съответстващия му символ.\n  ;; Вход: Цяло число, представляващо ASCII кода, гарантирано в диапазона на видимите символи (<128 и >0).\n  ;; Изход: Символът, съответстващ на ASCII кода.\n  ;; Пример:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "zh": "(defun ascii-to-char (code)\n  ;; 将ASCII码转换为其对应的字符。\n  ;; 输入：一个表示ASCII码的整数，保证在可见字符范围内（<128 且 >0）。\n  ;; 输出：与ASCII码对应的字符。\n  ;; 示例：\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "fr": "(defun ascii-to-char (code)\n  ;; Convertit un code ASCII en son caractère correspondant.\n  ;; Entrée : Un entier représentant le code ASCII, garanti d'être dans la plage des caractères visibles (<128 et >0).\n  ;; Sortie : Le caractère correspondant au code ASCII.\n  ;; Exemple:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "de": "(defun ascii-to-char (code)\n  ;; Konvertiert einen ASCII-Code in das entsprechende Zeichen.\n  ;; Eingabe: Eine Ganzzahl, die den ASCII-Code darstellt, garantiert im Bereich der sichtbaren Zeichen (<128 und >0).\n  ;; Ausgabe: Das Zeichen, das dem ASCII-Code entspricht.\n  ;; Beispiel:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "ha": "(defun ascii-to-char (code)\n  ;; Canza lambar ASCII zuwa harafin da ya dace.\n  ;; Shigarwa: Lamba mai wakiltar lambar ASCII, an tabbatar da cewa tana cikin kewayon haruffa masu gani (<128 da >0).\n  ;; Fitarwa: Harafin da ya dace da lambar ASCII.\n  ;; Misali:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "hi": "(defun ascii-to-char (code)\n  ;; एक ASCII कोड को उसके संबंधित वर्ण में परिवर्तित करता है।\n  ;; इनपुट: एक पूर्णांक जो ASCII कोड का प्रतिनिधित्व करता है, जो दृश्यमान वर्णों की सीमा के भीतर होने की गारंटी है (<128 और >0)।\n  ;; आउटपुट: ASCII कोड के अनुरूप वर्ण।\n  ;; उदाहरण:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "hu": "(defun ascii-to-char (code)\n  ;; Egy ASCII kódot alakít át a megfelelő karakterré.\n  ;; Bemenet: Egy egész szám, amely az ASCII kódot jelöli, garantáltan a látható karakterek tartományán belül van (<128 és >0).\n  ;; Kimenet: Az ASCII kódnak megfelelő karakter.\n  ;; Példa:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!"
    },
    "prompt_bertscore": {
      "sq": "0.9931444710289619",
      "hy": "0.9866133054701537",
      "bn": "0.9971961335413115",
      "bg": "0.9920438600876476",
      "zh": "0.977118177365543",
      "fr": "0.996601235550112",
      "de": "0.9937268553061561",
      "ha": "0.9649488884410595",
      "hi": "1",
      "hu": "0.99678894126019"
    },
    "canonical_solution": "  (code-char code))",
    "instruction": {
      "en": "defun ascii-to-char (code)\n  (code-char code))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "defun ascii-to-char (code)\n  (code-char code))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "defun ascii-to-char (code)\n  (code-char code))\n\nՏրամադրեք հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "defun ascii-to-char (code)\n  (code-char code))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "defun ascii-to-char (code)\n  (code-char code))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "defun ascii-to-char (code)\n  (code-char code))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Common Lisp 代码，字数不超过 500 个字符。",
      "fr": "defun ascii-to-char (code)\n  (code-char code))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "defun ascii-to-char (code)\n  (code-char code))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "defun ascii-to-char (code)\n  (code-char code))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "defun ascii-to-char (code)\n  (code-char code))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "defun ascii-to-char (code)\n  (code-char code))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.918271940680147",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.88778376623434",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9543551356989448",
      "hi": "0.8898221112045199",
      "hu": "0.9443179452844898"
    },
    "level": "",
    "test": "(defun check-ascii-to-char ()\n  (assert (char= (ascii-to-char 65) #\\A))\n  (assert (char= (ascii-to-char 33) #\\!))\n  (assert (char= (ascii-to-char 126) #\\~))\n  (assert (char= (ascii-to-char 48) #\\0))\n  (assert (char= (ascii-to-char 90) #\\Z)))\n\n(check-ascii-to-char)",
    "entry_point": "ascii-to-char",
    "signature": "defun ascii-to-char (code)",
    "docstring": {
      "en": "Converts an ASCII code to its corresponding character.\n Input: An integer representing the ASCII code, guaranteed to be within the range of visible characters (<128 and >0).\n Output: The character corresponding to the ASCII code.\n Example:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "sq": "Kthen një kod ASCII në karakterin përkatës.\nHyrja: Një numër i plotë që përfaqëson kodin ASCII, i garantuar të jetë brenda intervalit të karaktereve të dukshme (<128 dhe >0).\nDalja: Karakteri që korrespondon me kodin ASCII.\nShembull:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "hy": "Վերափոխում է ASCII կոդը նրա համապատասխան նիշին:\nՄուտք: Թիվ, որը ներկայացնում է ASCII կոդը, երաշխավորված է, որ գտնվում է տեսանելի նիշերի տիրույթում (<128 և >0):\nԵլք: Նիշ, որը համապատասխանում է ASCII կոդին:\nՕրինակ:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "bn": "ASCII কোডকে এর সংশ্লিষ্ট অক্ষরে রূপান্তর করে।\nইনপুট: একটি পূর্ণসংখ্যা যা ASCII কোডকে উপস্থাপন করে, দৃশ্যমান অক্ষরের সীমার মধ্যে থাকার নিশ্চয়তা রয়েছে (<128 এবং >0)।  \nআউটপুট: ASCII কোডের সাথে সম্পর্কিত অক্ষর।  \nউদাহরণ:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!  ",
      "bg": "Преобразува ASCII код в съответстващия му символ.\nВход: Цяло число, представляващо ASCII кода, гарантирано в диапазона на видимите символи (<128 и >0).  \nИзход: Символът, съответстващ на ASCII кода.  \nПример:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!",
      "zh": "将 ASCII 码转换为其对应的字符。\n输入：一个表示 ASCII 码的整数，保证在可见字符范围内（<128 且 >0）。  \n输出：与 ASCII 码对应的字符。  \n示例：  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!",
      "fr": "Convertit un code ASCII en son caractère correspondant.\nEntrée : Un entier représentant le code ASCII, garanti d'être dans la plage des caractères visibles (<128 et >0).  \nSortie : Le caractère correspondant au code ASCII.  \nExemple :  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!",
      "de": "Konvertiert einen ASCII-Code in das entsprechende Zeichen.\nEingabe: Eine ganze Zahl, die den ASCII-Code darstellt, garantiert im Bereich der sichtbaren Zeichen (<128 und >0).\nAusgabe: Das Zeichen, das dem ASCII-Code entspricht.\nBeispiel:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "ha": "Canza lambar ASCII zuwa harafin da ya dace.\n Shigarwa: Wani lamba da ke wakiltar lambar ASCII, wanda aka tabbatar da cewa yana cikin kewayon haruffan da ake iya gani (<128 da >0).\n Fitarwa: Harafin da ya dace da lambar ASCII.\n Misali:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "hi": "ASCII कोड को उसके संबंधित वर्ण में परिवर्तित करता है।\nइनपुट: ASCII कोड का प्रतिनिधित्व करने वाला एक पूर्णांक, जो दृश्यमान वर्णों की सीमा के भीतर होने की गारंटी है (<128 और >0)।  \nआउटपुट: ASCII कोड के अनुरूप वर्ण।  \nउदाहरण:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!  ",
      "hu": "Átalakít egy ASCII kódot a megfelelő karakterré.\n Bemenet: Egy egész szám, amely az ASCII kódot képviseli, garantáltan a látható karakterek tartományán belül van (<128 és >0).\n Kimenet: Az ASCII kódnak megfelelő karakter.\n Példa:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!"
    },
    "docstring_bertscore": {
      "sq": "0.9914209552127221",
      "hy": "0.9889813768728517",
      "bn": "0.9780310825967793",
      "bg": "0.9959072209987762",
      "zh": "0.974665092159762",
      "fr": "0.9947041167808478",
      "de": "0.9913285920855409",
      "ha": "0.9862414693968564",
      "hi": "0.9827282938474924",
      "hu": "0.9956694604326773"
    }
  },
  {
    "task_id": "Common Lisp/44",
    "prompt": {
      "en": "(defun reverse-three-digit (num)\n  ;; Reverses a three-digit number.\n  ;; Input: A three-digit integer 'num'.\n  ;; Output: The three-digit integer in reverse order. Leading zeros are preserved in the output.\n  ;; Example:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; For Common Lisp, leading zeros are not typically displayed in integer output.",
      "sq": "(defun reverse-three-digit (num)\n  ;; Kthen një numër treshe.\n  ;; Hyrja: Një numër i plotë treshe 'num'.\n  ;; Dalja: Numri i plotë treshe në rend të kundërt. Zerosat kryesues ruhen në dalje.\n  ;; Shembull:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Për Common Lisp, zerosat kryesues zakonisht nuk shfaqen në daljen e numrave të plotë.",
      "hy": "(defun reverse-three-digit (num)\n  ;; Շրջում է եռանիշ թիվը։\n  ;; Մուտք՝ եռանիշ ամբողջ թիվ 'num'։\n  ;; Ելք՝ եռանիշ ամբողջ թիվը հակառակ կարգով։ Առաջատար զրոները պահպանվում են ելքում։\n  ;; Օրինակ:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Common Lisp-ում առաջատար զրոները սովորաբար չեն ցուցադրվում ամբողջ թվերի ելքում։",
      "bn": "(defun reverse-three-digit (num)\n  ;; একটি তিন অঙ্কের সংখ্যা উল্টায়।\n  ;; ইনপুট: একটি তিন অঙ্কের পূর্ণসংখ্যা 'num'।\n  ;; আউটপুট: উল্টানো ক্রমে তিন অঙ্কের পূর্ণসংখ্যা। আউটপুটে শূন্যের পূর্ববর্তী অবস্থান সংরক্ষিত হয়।\n  ;; উদাহরণ:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Common Lisp এর জন্য, পূর্ণসংখ্যার আউটপুটে সাধারণত শূন্যের পূর্ববর্তী অবস্থান প্রদর্শিত হয় না।",
      "bg": "(defun reverse-three-digit (num)\n  ;; Обръща трицифрено число.\n  ;; Вход: Трицифрено цяло число 'num'.\n  ;; Изход: Трицифреното цяло число в обратен ред. Водещите нули се запазват в изхода.\n  ;; Пример:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; За Common Lisp, водещите нули обикновено не се показват в изхода за цели числа.",
      "zh": "(defun reverse-three-digit (num)\n  ;; 反转一个三位数。\n  ;; 输入：一个三位整数 'num'。\n  ;; 输出：反转后的三位整数。输出中保留前导零。\n  ;; 示例：\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; 对于Common Lisp，前导零通常不在整数输出中显示。",
      "fr": "(defun reverse-three-digit (num)\n  ;; Inverse un nombre à trois chiffres.\n  ;; Entrée : Un entier à trois chiffres 'num'.\n  ;; Sortie : L'entier à trois chiffres dans l'ordre inverse. Les zéros en tête sont préservés dans la sortie.\n  ;; Exemple:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Pour Common Lisp, les zéros en tête ne sont généralement pas affichés dans la sortie des entiers.",
      "de": "(defun reverse-three-digit (num)\n  ;; Kehrt eine dreistellige Zahl um.\n  ;; Eingabe: Eine dreistellige ganze Zahl 'num'.\n  ;; Ausgabe: Die dreistellige ganze Zahl in umgekehrter Reihenfolge. Führende Nullen werden in der Ausgabe beibehalten.\n  ;; Beispiel:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; In Common Lisp werden führende Nullen in der Regel nicht in der Ganzzahlausgabe angezeigt.",
      "ha": "(defun reverse-three-digit (num)\n  ;; Juya lamba mai tsawon uku.\n  ;; Shigarwa: Lamba mai tsawon uku 'num'.\n  ;; Fitarwa: Lamba mai tsawon uku a jujjuyawar tsari. Ana kiyaye sifili na gaba a fitarwa.\n  ;; Misali:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; A cikin Common Lisp, ba a nuna sifili na gaba a cikin fitarwar lambobi.",
      "hi": "(defun reverse-three-digit (num)\n  ;; एक तीन-अंकीय संख्या को उलट देता है।\n  ;; इनपुट: एक तीन-अंकीय पूर्णांक 'num'।\n  ;; आउटपुट: उलटे क्रम में तीन-अंकीय पूर्णांक। आउटपुट में अग्रणी शून्य संरक्षित रहते हैं।\n  ;; उदाहरण:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; कॉमन लिस्प के लिए, अग्रणी शून्य आमतौर पर पूर्णांक आउटपुट में प्रदर्शित नहीं होते हैं।",
      "hu": "(defun reverse-three-digit (num)\n  ;; Megfordít egy háromjegyű számot.\n  ;; Bemenet: Egy háromjegyű egész szám 'num'.\n  ;; Kimenet: A háromjegyű egész szám fordított sorrendben. A kezdő nullák megmaradnak a kimenetben.\n  ;; Példa:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; A Common Lisp esetében a kezdő nullák általában nem jelennek meg az egész számok kimenetén."
    },
    "prompt_bertscore": {
      "sq": "0.9749278801538712",
      "hy": "0.9881475265332672",
      "bn": "0.9827032664194819",
      "bg": "0.9860076814383784",
      "zh": "0.969956161716568",
      "fr": "0.9805125719470481",
      "de": "0.9947843634547859",
      "ha": "0.9613306374201279",
      "hi": "0.9911398932235578",
      "hu": "0.973713851264986"
    },
    "canonical_solution": "  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))",
    "instruction": {
      "en": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\n请用不超过500个字符的中文，为以下Common Lisp代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8531444154552847",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9543551356989448",
      "hi": "0.8898221112045199",
      "hu": "0.9349640433807949"
    },
    "level": "",
    "test": "(defun check-reverse-three-digit ()\n  (assert (= (reverse-three-digit 123) 321))\n  (assert (= (reverse-three-digit 100) 1)) ;; Note: Leading zeros are not displayed in integers.\n  (assert (= (reverse-three-digit 250) 52))\n  (assert (= (reverse-three-digit 999) 999))\n  (assert (= (reverse-three-digit 500) 5)))\n\n(check-reverse-three-digit)",
    "entry_point": "reverse-three-digit",
    "signature": "(defun reverse-three-digit (num)",
    "docstring": {
      "en": "Reverses a three-digit number.\n Input: A three-digit integer 'num'.\n Output: The three-digit integer in reverse order. Leading zeros are preserved in the output.\n Example:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; For Common Lisp, leading zeros are not typically displayed in integer output.",
      "sq": "Kthen një numër tre-shifror.\nHyrja: Një numër i plotë tre-shifror 'num'.\nDalja: Numri i plotë tre-shifror në rend të kundërt. Zerot përpara ruhen në dalje.\nShembull:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Për Common Lisp, zerot përpara zakonisht nuk shfaqen në daljen e numrave të plotë.",
      "hy": "Եռանիշ թիվը շրջում է:\nՄուտք: Եռանիշ ամբողջ թիվ 'num':\nԵլք: Եռանիշ ամբողջ թիվը հակառակ կարգով: Առաջատար զրոները պահպանվում են ելքում:\nՕրինակ:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Common Lisp-ի դեպքում, առաջատար զրոները սովորաբար չեն ցուցադրվում ամբողջ թվի ելքում:",
      "bn": "তিন অঙ্কের একটি সংখ্যা উল্টো করে।\nইনপুট: একটি তিন অঙ্কের পূর্ণসংখ্যা 'num'।\nআউটপুট: উল্টো ক্রমে তিন অঙ্কের পূর্ণসংখ্যা। আউটপুটে শূন্যের পূর্ববর্তী অবস্থান সংরক্ষিত থাকে।\nউদাহরণ:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; কমন লিস্পের জন্য, পূর্ণসংখ্যার আউটপুটে সাধারণত শূন্যের পূর্ববর্তী অবস্থান প্রদর্শিত হয় না।",
      "bg": "Обръща трицифрено число.\nВход: Трицифрено цяло число 'num'.  \nИзход: Трицифреното цяло число в обратен ред. Водещите нули се запазват в изхода.  \nПример:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; За Common Lisp, водещите нули обикновено не се показват в изхода за цели числа.",
      "zh": "反转一个三位数。\n输入：一个三位整数 'num'。\n输出：反转顺序的三位整数。输出中保留前导零。\n示例：\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; 对于 Common Lisp，前导零通常不会在整数输出中显示。",
      "fr": "Renverse un nombre à trois chiffres.\nEntrée : Un entier à trois chiffres 'num'.\nSortie : L'entier à trois chiffres dans l'ordre inverse. Les zéros initiaux sont préservés dans la sortie.\nExemple :\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Pour Common Lisp, les zéros initiaux ne sont généralement pas affichés dans la sortie des entiers.",
      "de": "Kehrt eine dreistellige Zahl um.\nEingabe: Eine dreistellige ganze Zahl 'num'.\nAusgabe: Die dreistellige ganze Zahl in umgekehrter Reihenfolge. Führende Nullen bleiben in der Ausgabe erhalten.\nBeispiel:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; In Common Lisp werden führende Nullen in der Ganzzahlausgabe normalerweise nicht angezeigt.",
      "ha": "Juya lamba mai tsawon uku.\nInput: Lamba mai tsawon uku 'num'.  \nOutput: Lambar mai tsawon uku a jujjuyawar tsari. Ana kiyaye sifili na farko a cikin fitarwa.  \nMisali:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; A cikin Common Lisp, ba a nuna sifili na farko a cikin fitarwar lambobi.",
      "hi": "तीन अंकों की संख्या को उलटता है।\nइनपुट: एक तीन अंकों की पूर्णांक 'num'।\nआउटपुट: उल्टे क्रम में तीन अंकों की पूर्णांक। आउटपुट में अग्रणी शून्य संरक्षित रहते हैं।\nउदाहरण:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; कॉमन लिस्प के लिए, अग्रणी शून्य आमतौर पर पूर्णांक आउटपुट में प्रदर्शित नहीं होते।",
      "hu": "Megfordít egy háromjegyű számot.\nBemenet: Egy háromjegyű egész szám 'num'.\nKimenet: A háromjegyű egész szám fordított sorrendben. A kezdő nullák megmaradnak a kimenetben.\nPélda:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; A Common Lisp-ben a kezdő nullák általában nem jelennek meg az egész szám kimenetében."
    },
    "docstring_bertscore": {
      "sq": "0.9582602089900907",
      "hy": "0.9669937882138137",
      "bn": "0.9710839850200841",
      "bg": "0.9894634528076233",
      "zh": "0.9725320004978284",
      "fr": "0.9739613447197555",
      "de": "0.9937594306886459",
      "ha": "0.9505908913479526",
      "hi": "0.9880714510973309",
      "hu": "0.9542349643184187"
    }
  },
  {
    "task_id": "Common Lisp/45",
    "prompt": {
      "en": "(defun int-bool-int-conversion (int)\n  ;; Converts an integer to a boolean and then back to an integer.\n  ;; Input: An integer within the range of integer values.\n  ;; Output: An integer resulting from the conversion of the initial integer to a boolean and then back to an integer.\n  ;; The output is 1 for any non-zero input integer, and 0 for an input of 0.\n  ;; Example:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "sq": "(defun int-bool-int-conversion (int)\n  ;; Konverton një numër të plotë në një boolean dhe pastaj përsëri në një numër të plotë.\n  ;; Hyrja: Një numër i plotë brenda intervalit të vlerave të numrave të plotë.\n  ;; Dalja: Një numër i plotë që rezulton nga konvertimi i numrit fillestar të plotë në një boolean dhe pastaj përsëri në një numër të plotë.\n  ;; Dalja është 1 për çdo hyrje të numrit të plotë jo-zero, dhe 0 për një hyrje prej 0.\n  ;; Shembull:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "hy": "(defun int-bool-int-conversion (int)\n  ;; Փոխակերպում է ամբողջ թիվը տրամաբանական արժեքի, այնուհետև հետ ամբողջ թվի:\n  ;; Մուտք: Ամբողջ թիվ, որը գտնվում է ամբողջ թվերի միջակայքում:\n  ;; Ելք: Ամբողջ թիվ, որը ստացվում է սկզբնական ամբողջ թիվը տրամաբանական արժեքի և ապա ամբողջ թվի փոխակերպելուց:\n  ;; Ելքը 1 է ցանկացած ոչ զրոյական մուտքային ամբողջ թվի համար, և 0՝ 0 մուտքի համար:\n  ;; Օրինակ:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "bn": "(defun int-bool-int-conversion (int)\n  ;; একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে।\n  ;; ইনপুট: পূর্ণসংখ্যার মানের সীমার মধ্যে একটি পূর্ণসংখ্যা।\n  ;; আউটপুট: প্রাথমিক পূর্ণসংখ্যাকে একটি বুলিয়ানে এবং তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তরের ফলে প্রাপ্ত একটি পূর্ণসংখ্যা।\n  ;; আউটপুটটি যেকোনো অ-শূন্য ইনপুট পূর্ণসংখ্যার জন্য 1, এবং 0 ইনপুটের জন্য 0।\n  ;; উদাহরণ:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "bg": "(defun int-bool-int-conversion (int)\n  ;; Преобразува цяло число в булева стойност и след това обратно в цяло число.\n  ;; Вход: Цяло число в рамките на диапазона от стойности на цяло число.\n  ;; Изход: Цяло число, получено от преобразуването на първоначалното цяло число в булева стойност и след това обратно в цяло число.\n  ;; Изходът е 1 за всяко ненулево входно цяло число и 0 за вход от 0.\n  ;; Пример:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "zh": "(defun int-bool-int-conversion (int)\n  ;; 将整数转换为布尔值，然后再转换回整数。\n  ;; 输入：一个在整数值范围内的整数。\n  ;; 输出：从初始整数转换为布尔值然后再转换回整数的结果。\n  ;; 对于任何非零输入整数，输出为1，对于输入为0，输出为0。\n  ;; 示例:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "fr": "(defun int-bool-int-conversion (int)\n  ;; Convertit un entier en booléen puis de nouveau en entier.\n  ;; Entrée : Un entier dans la plage des valeurs entières.\n  ;; Sortie : Un entier résultant de la conversion de l'entier initial en booléen puis de nouveau en entier.\n  ;; La sortie est 1 pour toute entrée entière non nulle, et 0 pour une entrée de 0.\n  ;; Exemple:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "de": "(defun int-bool-int-conversion (int)\n  ;; Konvertiert eine ganze Zahl in einen booleschen Wert und dann zurück in eine ganze Zahl.\n  ;; Eingabe: Eine ganze Zahl innerhalb des Bereichs von Ganzzahlen.\n  ;; Ausgabe: Eine ganze Zahl, die aus der Umwandlung der ursprünglichen ganzen Zahl in einen booleschen Wert und dann zurück in eine ganze Zahl resultiert.\n  ;; Die Ausgabe ist 1 für jede von Null verschiedene Eingabeganzzahl und 0 für eine Eingabe von 0.\n  ;; Beispiel:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "ha": "(defun int-bool-int-conversion (int)\n  ;; Yana canza lamba mai cikakken adadi zuwa boolean sannan kuma ya mayar da ita zuwa lamba mai cikakken adadi.\n  ;; Shigarwa: Lamba mai cikakken adadi a cikin kewayon ƙimar lambobi.\n  ;; Fitarwa: Lamba mai cikakken adadi sakamakon canza lamba mai cikakken adadi na farko zuwa boolean sannan kuma ya mayar da ita zuwa lamba mai cikakken adadi.\n  ;; Fitarwa yana da 1 don kowace lamba mai cikakken adadi da ba sifili ba, kuma 0 don shigarwa na 0.\n  ;; Misali:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "hi": "(defun int-bool-int-conversion (int)\n  ;; एक पूर्णांक को एक boolean में और फिर एक पूर्णांक में परिवर्तित करता है।\n  ;; इनपुट: पूर्णांक मानों की सीमा के भीतर एक पूर्णांक।\n  ;; आउटपुट: प्रारंभिक पूर्णांक को एक boolean में और फिर एक पूर्णांक में परिवर्तित करने से प्राप्त पूर्णांक।\n  ;; आउटपुट किसी भी गैर-शून्य इनपुट पूर्णांक के लिए 1 है, और 0 के इनपुट के लिए 0 है।\n  ;; उदाहरण:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "hu": "(defun int-bool-int-conversion (int)\n  ;; Egy egész számot logikai értékké, majd vissza egész számmá alakít.\n  ;; Bemenet: Egy egész szám az egész számok tartományán belül.\n  ;; Kimenet: Egy egész szám, amely az eredeti egész szám logikai értékké, majd vissza egész számmá történő átalakításából származik.\n  ;; A kimenet 1 bármely nem nulla bemeneti egész szám esetén, és 0, ha a bemenet 0.\n  ;; Példa:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1"
    },
    "prompt_bertscore": {
      "sq": "0.9917939830683057",
      "hy": "0.9768049372546509",
      "bn": "0.9933323753694209",
      "bg": "0.9830101503581808",
      "zh": "0.9552094449677758",
      "fr": "0.9917939830683057",
      "de": "0.9785409667848959",
      "ha": "0.9792451114856645",
      "hi": "0.9714367525768021",
      "hu": "0.974613448260693"
    },
    "canonical_solution": "  (if (= int 0) 0 1))",
    "instruction": {
      "en": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nՏրամադրել համառոտ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9315233679205085",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8923915938135872",
      "fr": "0.9711523138711601",
      "de": "0.93952539145088",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9330307738821823"
    },
    "level": "",
    "test": "(defun check-int-bool-int-conversion ()\n  (assert (= (int-bool-int-conversion 3) 1))\n  (assert (= (int-bool-int-conversion 0) 0))\n  (assert (= (int-bool-int-conversion -5) 1))\n  (assert (= (int-bool-int-conversion 1) 1))\n  (assert (= (int-bool-int-conversion 100) 1)))\n\n(check-int-bool-int-conversion)",
    "entry_point": "int-bool-int-conversion",
    "signature": "(defun int-bool-int-conversion (int)",
    "docstring": {
      "en": "Converts an integer to a boolean and then back to an integer.\n Input: An integer within the range of integer values.\n Output: An integer resulting from the conversion of the initial integer to a boolean and then back to an integer.\n The output is 1 for any non-zero input integer, and 0 for an input of 0.\n Example:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "sq": "Konverton një numër të plotë në një boolean dhe pastaj përsëri në një numër të plotë.  \nHyrja: Një numër i plotë brenda intervalit të vlerave të numrave të plotë.  \nDalja: Një numër i plotë që rezulton nga konvertimi i numrit fillestar të plotë në një boolean dhe pastaj përsëri në një numër të plotë.  \nDalja është 1 për çdo hyrje të numrit të plotë që nuk është zero, dhe 0 për një hyrje prej 0.  \nShembull:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "hy": "Փոխակերպում է ամբողջ թիվը տրամաբանական արժեքի և ապա հետ ամբողջ թվի:\nՄուտք: Ամբողջ թիվ, որը գտնվում է ամբողջ թվերի արժեքների տիրույթում:\nԵլք: Ամբողջ թիվ, որը ստացվում է սկզբնական ամբողջ թիվը տրամաբանական արժեքի և ապա հետ ամբողջ թվի փոխակերպումից:\nԵլքը 1 է ցանկացած ոչ զրո մուտքային ամբողջ թվի համար, և 0՝ 0 մուտքի համար:\nՕրինակ:\n>>> (int-bool-int-conversion 3)\n1\n>>> (int-bool-int-conversion 0)\n0\n>>> (int-bool-int-conversion -5)\n1",
      "bn": "একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে।\nইনপুট: পূর্ণসংখ্যার মানের পরিসরের মধ্যে একটি পূর্ণসংখ্যা।\nআউটপুট: প্রাথমিক পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তরের ফলে প্রাপ্ত একটি পূর্ণসংখ্যা।\nআউটপুটটি যেকোনো শূন্য ব্যতীত ইনপুট পূর্ণসংখ্যার জন্য 1 এবং 0 এর জন্য 0 হয়।\nউদাহরণ:\n>>> (int-bool-int-conversion 3)\n1\n>>> (int-bool-int-conversion 0)\n0\n>>> (int-bool-int-conversion -5)\n1",
      "bg": "Преобразува цяло число в булева стойност и след това обратно в цяло число.  \nВход: Цяло число в рамките на диапазона на целочислените стойности.  \nИзход: Цяло число, получено от преобразуването на първоначалното цяло число в булева стойност и след това обратно в цяло число.  \nИзходът е 1 за всяко ненулево входно цяло число и 0 за входно число 0.  \nПример:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "zh": "将整数转换为布尔值，然后再转换回整数。\n输入：一个在整数值范围内的整数。\n输出：将初始整数转换为布尔值然后再转换回整数的结果整数。  \n对于任何非零输入整数，输出为1；对于输入为0，输出为0。  \n示例：  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "fr": "Convertit un entier en un booléen puis de nouveau en un entier.\nEntrée : Un entier dans la plage des valeurs entières.  \nSortie : Un entier résultant de la conversion de l'entier initial en un booléen puis de nouveau en un entier.  \nLa sortie est 1 pour toute entrée entière non nulle, et 0 pour une entrée de 0.  \nExemple :  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1",
      "de": "Konvertiert eine Ganzzahl in einen Booleschen Wert und dann zurück in eine Ganzzahl.  \nEingabe: Eine Ganzzahl innerhalb des Bereichs von Ganzzahlwerten.  \nAusgabe: Eine Ganzzahl, die aus der Umwandlung der ursprünglichen Ganzzahl in einen Booleschen Wert und dann zurück in eine Ganzzahl resultiert.  \nDie Ausgabe ist 1 für jede von null verschiedene Eingabeganzzahl und 0 für eine Eingabe von 0.  \nBeispiel:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "ha": "Yana canza lamba mai lamba zuwa boolean sannan kuma ya mayar da ita zuwa lamba mai lamba.  \nShigarwa: Lamba cikin kewayon ƙimar lamba.  \nFitarwa: Lamba da aka samu daga jujjuyawar lambar farko zuwa boolean sannan kuma zuwa lamba.  \nFitarwar ita ce 1 don kowace lamba mai shigarwa da ba ta zama sifili ba, kuma 0 don shigarwa na 0.  \nMisali:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "hi": "पूर्णांक को बूलियन में और फिर वापस पूर्णांक में परिवर्तित करता है।\nइनपुट: पूर्णांक मानों की सीमा के भीतर एक पूर्णांक।  \nआउटपुट: प्रारंभिक पूर्णांक को बूलियन में और फिर वापस पूर्णांक में परिवर्तित करने से प्राप्त पूर्णांक।  \nआउटपुट किसी भी गैर-शून्य इनपुट पूर्णांक के लिए 1 होता है, और 0 के इनपुट के लिए 0 होता है।  \nउदाहरण:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "hu": "Egy egész számot logikai értékké, majd vissza egész számmá alakít.\nBemenet: Egy egész szám az egész számok tartományán belül.  \nKimenet: Egy egész szám, amely az eredeti egész szám logikai értékké, majd vissza egész számmá történő átalakításából származik.  \nA kimenet 1 bármely nem nulla bemeneti egész szám esetén, és 0, ha a bemenet 0.  \nPélda:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  "
    },
    "docstring_bertscore": {
      "sq": "0.9929690804025081",
      "hy": "0.9795114748266324",
      "bn": "0.9776147533181302",
      "bg": "0.9716975542671008",
      "zh": "0.9446681306462543",
      "fr": "0.990890413464978",
      "de": "0.9817099158839264",
      "ha": "0.9636854005872966",
      "hi": "0.9700519015602268",
      "hu": "0.970736381853273"
    }
  },
  {
    "task_id": "Common Lisp/46",
    "prompt": {
      "en": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Calculates the nth term of an arithmetic sequence given the first two terms.\n  ;; Input: Three integers 'a1' and 'a2' representing the first two terms of the sequence, and 'n' the term number to find.\n  ;; Output: The value of the nth term in the arithmetic sequence.\n  ;; Example:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "sq": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Llogarit termin e n-të të një progresioni aritmetik duke dhënë dy termat e parë.\n  ;; Hyrja: Tre numra të plotë 'a1' dhe 'a2' që përfaqësojnë dy termat e parë të progresionit, dhe 'n' numri i termit për të gjetur.\n  ;; Dalja: Vlera e termit të n-të në progresionin aritmetik.\n  ;; Shembull:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "hy": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով առաջին երկու անդամները:\n  ;; Մուտքագրում: Երեք ամբողջ թիվ 'a1' և 'a2', որոնք ներկայացնում են հաջորդականության առաջին երկու անդամները, և 'n'՝ այն անդամի համարը, որը պետք է գտնել:\n  ;; Ելք: Թվաբանական հաջորդականության n-րդ անդամի արժեքը:\n  ;; Օրինակ:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "bn": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; একটি গাণিতিক ক্রমের n তম পদ গণনা করে প্রথম দুটি পদ দেওয়া হলে।\n  ;; ইনপুট: তিনটি পূর্ণসংখ্যা 'a1' এবং 'a2' ক্রমের প্রথম দুটি পদ উপস্থাপন করে, এবং 'n' খুঁজতে চাওয়া পদ সংখ্যা।\n  ;; আউটপুট: গাণিতিক ক্রমের n তম পদের মান।\n  ;; উদাহরণ:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "bg": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Изчислява n-тия член на аритметична прогресия, дадени първите два члена.\n  ;; Вход: Три цели числа 'a1' и 'a2', представляващи първите два члена на прогресията, и 'n' номерът на члена, който трябва да се намери.\n  ;; Изход: Стойността на n-тия член в аритметичната прогресия.\n  ;; Пример:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "zh": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; 计算等差数列的第n项，给定前两项。\n  ;; 输入：三个整数 'a1' 和 'a2' 表示数列的前两项，'n' 表示要查找的项数。\n  ;; 输出：等差数列中第n项的值。\n  ;; 示例:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "fr": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Calcule le nième terme d'une suite arithmétique étant donné les deux premiers termes.\n  ;; Entrée : Trois entiers 'a1' et 'a2' représentant les deux premiers termes de la suite, et 'n' le numéro du terme à trouver.\n  ;; Sortie : La valeur du nième terme dans la suite arithmétique.\n  ;; Exemple:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "de": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Berechnet das n-te Glied einer arithmetischen Folge, gegeben die ersten beiden Glieder.\n  ;; Eingabe: Drei ganze Zahlen 'a1' und 'a2', die die ersten beiden Glieder der Folge darstellen, und 'n', die Nummer des zu findenden Glieds.\n  ;; Ausgabe: Der Wert des n-ten Glieds in der arithmetischen Folge.\n  ;; Beispiel:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "ha": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Lissafi na n na jerin lissafi da aka bayar da farkon sharuɗɗa biyu.\n  ;; Shigarwa: Lambobi guda uku 'a1' da 'a2' suna wakiltar farkon sharuɗɗa biyu na jerin, da 'n' lambar sharadi don samu.\n  ;; Fitarwa: Ƙimar na n na jerin lissafi.\n  ;; Misali:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "hi": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; पहले दो पद दिए जाने पर एक अंकगणितीय अनुक्रम का nth पद गणना करता है।\n  ;; इनपुट: तीन पूर्णांक 'a1' और 'a2' जो अनुक्रम के पहले दो पदों का प्रतिनिधित्व करते हैं, और 'n' वह पद संख्या है जिसे खोजना है।\n  ;; आउटपुट: अंकगणितीय अनुक्रम में nth पद का मान।\n  ;; उदाहरण:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "hu": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Kiszámítja egy számtani sorozat n-edik tagját az első két tag alapján.\n  ;; Bemenet: Három egész szám 'a1' és 'a2', amelyek a sorozat első két tagját képviselik, és 'n', a keresett tag sorszáma.\n  ;; Kimenet: Az n-edik tag értéke a számtani sorozatban.\n  ;; Példa:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29"
    },
    "prompt_bertscore": {
      "sq": "0.9803536676422202",
      "hy": "0.9830468969786723",
      "bn": "0.9892826991608815",
      "bg": "0.9791958511511679",
      "zh": "0.9866798466478004",
      "fr": "1",
      "de": "0.9717674721612252",
      "ha": "0.9936017181661042",
      "hi": "0.9937266566757751",
      "hu": "0.9620900013668243"
    },
    "canonical_solution": "  (+ a1 (* (1- n) (- a2 a1))))",
    "instruction": {
      "en": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nՏվեք Common Lisp կոդի հակիրճ նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nПредоставете кратко описание на кода на Common Lisp на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\n请用不超过500个字符的中文为以下Common Lisp代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nBa da takaitaccen bayani a cikin yare na halitta (docstring) na lambar Common Lisp cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8727891587700162",
      "bg": "0.8335809119663965",
      "zh": "0.8531444154552847",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9370049705459284",
      "hi": "0.8808811618629965",
      "hu": "0.9349640433807949"
    },
    "level": "",
    "test": "(defun check-nth-term-arithmetic-sequence ()\n  (assert (= (nth-term-arithmetic-sequence 1 4 100) 298))\n  (assert (= (nth-term-arithmetic-sequence 2 5 10) 29))\n  (assert (= (nth-term-arithmetic-sequence 0 3 4) 9))\n  (assert (= (nth-term-arithmetic-sequence -3 1 5) 13))\n  (assert (= (nth-term-arithmetic-sequence 100 -100 50) -9700)))\n\n(check-nth-term-arithmetic-sequence)",
    "entry_point": "nth-term-arithmetic-sequence",
    "signature": "(defun nth-term-arithmetic-sequence (a1 a2 n)",
    "docstring": {
      "en": "Calculates the nth term of an arithmetic sequence given the first two terms.\n Input: Three integers 'a1' and 'a2' representing the first two terms of the sequence, and 'n' the term number to find.\n Output: The value of the nth term in the arithmetic sequence.\n Example:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "sq": "Llogarit termin e n-të të një progresioni aritmetik duke pasur parasysh dy termat e parë.\nHyrja: Tre numra të plotë 'a1' dhe 'a2' që përfaqësojnë dy termat e parë të progresionit, dhe 'n' numri i termit për të gjetur.\nDalja: Vlera e termit të n-të në progresionin aritmetik.\nShembull:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "hy": "Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով առաջին երկու անդամները:\nՄուտք: Երեք ամբողջ թիվ 'a1' և 'a2', որոնք ներկայացնում են հաջորդականության առաջին երկու անդամները, և 'n'՝ այն անդամի համարը, որը պետք է գտնել:\nԵլք: Թվաբանական հաջորդականության n-րդ անդամի արժեքը:\nՕրինակ:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "bn": "nth পদ নির্ণয় করে একটি গাণিতিক ক্রমের, প্রথম দুটি পদ দেওয়া হলে।  \nইনপুট: তিনটি পূর্ণসংখ্যা 'a1' এবং 'a2' যা ক্রমের প্রথম দুটি পদকে উপস্থাপন করে, এবং 'n' হল যে পদটি খুঁজে বের করতে হবে।  \nআউটপুট: গাণিতিক ক্রমের nth পদের মান।  \nউদাহরণ:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29",
      "bg": "Изчислява n-тия член на аритметична прогресия, като се дадат първите два члена.\nВход: Три цели числа 'a1' и 'a2', представляващи първите два члена на прогресията, и 'n' номерът на члена, който трябва да се намери.\nИзход: Стойността на n-тия член в аритметичната прогресия.\nПример:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "zh": "计算给定前两个项的等差数列的第n项。  \n输入：三个整数 'a1' 和 'a2' 表示数列的前两个项，以及 'n' 表示要查找的项的编号。  \n输出：等差数列中第n项的值。  \n示例：  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "fr": "Calcule le nième terme d'une suite arithmétique donnée les deux premiers termes.  \nEntrée : Trois entiers 'a1' et 'a2' représentant les deux premiers termes de la suite, et 'n' le numéro du terme à trouver.  \nSortie : La valeur du nième terme dans la suite arithmétique.  \nExemple:\n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "de": "Berechnet das n-te Glied einer arithmetischen Folge, gegeben die ersten beiden Glieder.\nEingabe: Drei ganze Zahlen 'a1' und 'a2', die die ersten beiden Glieder der Folge darstellen, und 'n', die Nummer des zu findenden Gliedes.\nAusgabe: Der Wert des n-ten Gliedes in der arithmetischen Folge.\nBeispiel:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "ha": "Yana ƙididdige sharadi na n na jerin lissafi da aka bayar da sharuɗɗan farko biyu.  \nShigarwa: Lamba uku 'a1' da 'a2' suna wakiltar sharuɗɗan farko biyu na jerin, da 'n' lambar sharadi don samu.  \nFitarwa: Darajar sharadi na n a cikin jerin lissafi.  \nMisali:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "hi": "गणितीय अनुक्रम के nवें पद की गणना करता है जब पहले दो पद दिए गए हों।  \nइनपुट: तीन पूर्णांक 'a1' और 'a2' जो अनुक्रम के पहले दो पदों का प्रतिनिधित्व करते हैं, और 'n' वह पद संख्या है जिसे खोजना है।  \nआउटपुट: गणितीय अनुक्रम में nवें पद का मान।  \nउदाहरण:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "hu": "Kiszámítja egy számtani sorozat n-edik tagját az első két tag alapján.  \nBemenet: Három egész szám 'a1' és 'a2', amelyek a sorozat első két tagját képviselik, és 'n', amely a keresett tag sorszáma.  \nKimenet: Az n-edik tag értéke a számtani sorozatban.  \nPélda:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29"
    },
    "docstring_bertscore": {
      "sq": "0.9577316535461569",
      "hy": "0.9771076499553482",
      "bn": "0.9405052351205251",
      "bg": "0.966266403758464",
      "zh": "0.9722868906076314",
      "fr": "0.9866927576225677",
      "de": "0.9656135056960022",
      "ha": "0.9738777213293398",
      "hi": "0.9674071380367473",
      "hu": "0.9436777595664143"
    }
  },
  {
    "task_id": "Common Lisp/47",
    "prompt": {
      "en": "(defun multiply-a-b (a b)\n  ;; Multiplies two positive integers A and B and returns the product.\n  ;; Input: Two positive integers 'a' and 'b', where 1 <= a, b <= 50000.\n  ;; Output: The product of 'a' and 'b'.\n  ;; Example:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "sq": "(defun multiply-a-b (a b)\n  ;; Shumzon dy numra të plotë pozitivë A dhe B dhe kthen produktin.\n  ;; Hyrja: Dy numra të plotë pozitivë 'a' dhe 'b', ku 1 <= a, b <= 50000.\n  ;; Dalja: Produkti i 'a' dhe 'b'.\n  ;; Shembull:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "hy": "(defun multiply-a-b (a b)\n  ;; Երկու դրական ամբողջ թիվ A և B բազմապատկում է և վերադարձնում արտադրյալը։\n  ;; Մուտք: Երկու դրական ամբողջ թիվ 'a' և 'b', որտեղ 1 <= a, b <= 50000։\n  ;; Ելք: 'a' և 'b' արտադրյալը։\n  ;; Օրինակ:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "bn": "(defun multiply-a-b (a b)\n  ;; দুটি ধনাত্মক পূর্ণসংখ্যা A এবং B গুণ করে গুণফল প্রদান করে।\n  ;; ইনপুট: দুটি ধনাত্মক পূর্ণসংখ্যা 'a' এবং 'b', যেখানে 1 <= a, b <= 50000।\n  ;; আউটপুট: 'a' এবং 'b' এর গুণফল।\n  ;; উদাহরণ:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "bg": "(defun multiply-a-b (a b)\n  ;; Умножава две положителни цели числа A и B и връща произведението.\n  ;; Вход: Две положителни цели числа 'a' и 'b', където 1 <= a, b <= 50000.\n  ;; Изход: Произведението на 'a' и 'b'.\n  ;; Пример:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "zh": "(defun multiply-a-b (a b)\n  ;; 乘以两个正整数A和B并返回乘积。\n  ;; 输入：两个正整数'a'和'b'，其中1 <= a, b <= 50000。\n  ;; 输出：'a'和'b'的乘积。\n  ;; 示例:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "fr": "(defun multiply-a-b (a b)\n  ;; Multiplie deux entiers positifs A et B et retourne le produit.\n  ;; Entrée : Deux entiers positifs 'a' et 'b', où 1 <= a, b <= 50000.\n  ;; Sortie : Le produit de 'a' et 'b'.\n  ;; Exemple:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "de": "(defun multiply-a-b (a b)\n  ;; Multipliziert zwei positive ganze Zahlen A und B und gibt das Produkt zurück.\n  ;; Eingabe: Zwei positive ganze Zahlen 'a' und 'b', wobei 1 <= a, b <= 50000.\n  ;; Ausgabe: Das Produkt von 'a' und 'b'.\n  ;; Beispiel:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "ha": "(defun multiply-a-b (a b)\n  ;; Ninka lambobi guda biyu masu kyau A da B kuma dawo da samfurin.\n  ;; Shigarwa: Lambobi guda biyu masu kyau 'a' da 'b', inda 1 <= a, b <= 50000.\n  ;; Fitarwa: Samfurin 'a' da 'b'.\n  ;; Misali:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "hi": "(defun multiply-a-b (a b)\n  ;; दो धनात्मक पूर्णांक A और B को गुणा करता है और गुणनफल लौटाता है।\n  ;; इनपुट: दो धनात्मक पूर्णांक 'a' और 'b', जहाँ 1 <= a, b <= 50000।\n  ;; आउटपुट: 'a' और 'b' का गुणनफल।\n  ;; उदाहरण:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "hu": "(defun multiply-a-b (a b)\n  ;; Két pozitív egész szám, A és B szorzása és a szorzat visszaadása.\n  ;; Bemenet: Két pozitív egész szám 'a' és 'b', ahol 1 <= a, b <= 50000.\n  ;; Kimenet: Az 'a' és 'b' szorzata.\n  ;; Példa:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.9781864115547486",
      "bg": "0.999999801369619",
      "zh": "0.9910135643012196",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9805455445903",
      "hi": "0.999999801369619",
      "hu": "0.9786653094034237"
    },
    "canonical_solution": "  (* a b))",
    "instruction": {
      "en": "(defun multiply-a-b (a b)\n  (* a b))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun multiply-a-b (a b)\n  (* a b))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun multiply-a-b (a b)\n  (* a b))\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun multiply-a-b (a b)\n  (* a b))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun multiply-a-b (a b)\n  (* a b))\n\nПредоставете кратко описание на кода на Common Lisp на български език, използвайки максимум 500 знака.",
      "zh": "(defun multiply-a-b (a b)\n  (* a b))\n\n请用中文为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "(defun multiply-a-b (a b)\n  (* a b))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun multiply-a-b (a b)\n  (* a b))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun multiply-a-b (a b)\n  (* a b))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun multiply-a-b (a b)\n  (* a b))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "(defun multiply-a-b (a b)\n  (* a b))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9482959159254755",
      "bn": "0.8727891587700162",
      "bg": "0.8458594476004492",
      "zh": "0.8524768187446264",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.922724439301425",
      "hi": "0.8898221112045199",
      "hu": "0.9434086154001121"
    },
    "level": "",
    "test": "(defun check-multiply-a-b ()\n  (assert (= (multiply-a-b 3 4) 12))\n  (assert (= (multiply-a-b 36 18) 648))\n  (assert (= (multiply-a-b 1 50000) 50000))\n  (assert (= (multiply-a-b 50000 50000) 2500000000))\n  (assert (= (multiply-a-b 123 456) 56088)))\n\n(check-multiply-a-b)",
    "entry_point": "multiply-a-b",
    "signature": "(defun multiply-a-b (a b)",
    "docstring": {
      "en": "Multiplies two positive integers A and B and returns the product.\n Input: Two positive integers 'a' and 'b', where 1 <= a, b <= 50000.\n Output: The product of 'a' and 'b'.\n Example:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "sq": "Shumëzon dy numra të plotë pozitivë A dhe B dhe kthen produktin. \nHyrja: Dy numra të plotë pozitivë 'a' dhe 'b', ku 1 <= a, b <= 50000.  \nDalja: Produkti i 'a' dhe 'b'.  \nShembull:  \n>>> (multiply-a-b 3 4)  \n12  \n>>> (multiply-a-b 36 18)  \n648  ",
      "hy": "Բազմապատկում է երկու դրական ամբողջ թիվ A-ն և B-ն և վերադարձնում է արդյունքը։\nՄուտք: Երկու դրական ամբողջ թվեր 'a' և 'b', որտեղ 1 <= a, b <= 50000։\nԵլք: 'a' և 'b' թվերի արտադրյալը։\nՕրինակ:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা A এবং B গুণ করে গুণফল প্রদান করে।\nইনপুট: দুটি ধনাত্মক পূর্ণসংখ্যা 'a' এবং 'b', যেখানে 1 <= a, b <= 50000।\nআউটপুট: 'a' এবং 'b' এর গুণফল।\nউদাহরণ:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "bg": "Умножава две положителни цели числа A и B и връща произведението.\nВход: Две положителни цели числа 'a' и 'b', където 1 <= a, b <= 50000.\nИзход: Произведението на 'a' и 'b'.\nПример:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "zh": "将两个正整数 A 和 B 相乘并返回乘积。\n输入：两个正整数 'a' 和 'b'，其中 1 <= a, b <= 50000。\n输出：'a' 和 'b' 的乘积。\n示例：\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "fr": "Multiplie deux entiers positifs A et B et renvoie le produit.\nEntrée : Deux entiers positifs 'a' et 'b', où 1 <= a, b <= 50000.\nSortie : Le produit de 'a' et 'b'.\nExemple :\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "de": "Multipliziert zwei positive ganze Zahlen A und B und gibt das Produkt zurück.\nEingabe: Zwei positive ganze Zahlen 'a' und 'b', wobei 1 <= a, b <= 50000.\nAusgabe: Das Produkt von 'a' und 'b'.\nBeispiel:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "ha": "Ninka lambobi guda biyu masu kyau A da B kuma ya dawo da sakamakon.\n Shigarwa: Lambobi guda biyu masu kyau 'a' da 'b', inda 1 <= a, b <= 50000.\n Fitarwa: Samfurin 'a' da 'b'.\n Misali:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "hi": "दो सकारात्मक पूर्णांकों A और B को गुणा करता है और गुणनफल लौटाता है।\nइनपुट: दो सकारात्मक पूर्णांक 'a' और 'b', जहाँ 1 <= a, b <= 50000।  \nआउटपुट: 'a' और 'b' का गुणनफल।  \nउदाहरण:  \n>>> (multiply-a-b 3 4)  \n12  \n>>> (multiply-a-b 36 18)  \n648  ",
      "hu": "Két pozitív egész számot, A-t és B-t szoroz össze, és visszaadja a szorzatot.\n Bemenet: Két pozitív egész szám 'a' és 'b', ahol 1 <= a, b <= 50000.\n Kimenet: 'a' és 'b' szorzata.\n Példa:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9608614724601235",
      "bn": "0.967764871352991",
      "bg": "1",
      "zh": "0.9874088201461985",
      "fr": "0.9874088201461985",
      "de": "1",
      "ha": "0.9616607611134079",
      "hi": "0.9781381443721571",
      "hu": "0.963750551352276"
    }
  },
  {
    "task_id": "Common Lisp/48",
    "prompt": {
      "en": "(defun power-of-two (n)\n  ;; Calculates 2 raised to the power of n, where n is a non-negative integer.\n  ;; Input: A non-negative integer 'n' (0 <= n < 31).\n  ;; Output: An integer representing 2^n.\n  ;; Example:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "sq": "(defun power-of-two (n)\n  ;; Llogarit 2 ngritur në fuqinë e n, ku n është një numër i plotë jo-negativ.\n  ;; Hyrja: Një numër i plotë jo-negativ 'n' (0 <= n < 31).\n  ;; Dalja: Një numër i plotë që përfaqëson 2^n.\n  ;; Shembull:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "hy": "(defun power-of-two (n)\n  ;; Հաշվարկում է 2-ը բարձրացված n աստիճանի, որտեղ n-ը ոչ բացասական ամբողջ թիվ է։\n  ;; Մուտքագրում: Ոչ բացասական ամբողջ թիվ 'n' (0 <= n < 31)։\n  ;; Ելք: Ամբողջ թիվ, որը ներկայացնում է 2^n։\n  ;; Օրինակ:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "bn": "(defun power-of-two (n)\n  ;; n এর ঘাত হিসাবে 2 এর মান গণনা করে, যেখানে n একটি অ-ঋণাত্মক পূর্ণসংখ্যা।\n  ;; ইনপুট: একটি অ-ঋণাত্মক পূর্ণসংখ্যা 'n' (0 <= n < 31)।\n  ;; আউটপুট: 2^n এর মান হিসাবে একটি পূর্ণসংখ্যা।\n  ;; উদাহরণ:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "bg": "(defun power-of-two (n)\n  ;; Изчислява 2 на степен n, където n е неотрицателно цяло число.\n  ;; Вход: Неотрицателно цяло число 'n' (0 <= n < 31).\n  ;; Изход: Цяло число, представляващо 2^n.\n  ;; Пример:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "zh": "(defun power-of-two (n)\n  ;; 计算2的n次方，其中n是非负整数。\n  ;; 输入：一个非负整数'n' (0 <= n < 31)。\n  ;; 输出：一个整数，表示2的n次方。\n  ;; 例子:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "fr": "(defun power-of-two (n)\n  ;; Calcule 2 élevé à la puissance de n, où n est un entier non négatif.\n  ;; Entrée : Un entier non négatif 'n' (0 <= n < 31).\n  ;; Sortie : Un entier représentant 2^n.\n  ;; Exemple:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "de": "(defun power-of-two (n)\n  ;; Berechnet 2 hoch n, wobei n eine nicht-negative ganze Zahl ist.\n  ;; Eingabe: Eine nicht-negative ganze Zahl 'n' (0 <= n < 31).\n  ;; Ausgabe: Eine ganze Zahl, die 2^n darstellt.\n  ;; Beispiel:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "ha": "(defun power-of-two (n)\n  ;; Lissafi na 2 da aka ɗaga zuwa ƙarfin n, inda n yake zama lamba mai kyau mara kyau.\n  ;; Shigarwa: Lamba mai kyau mara kyau 'n' (0 <= n < 31).\n  ;; Fitarwa: Lamba mai wakiltar 2^n.\n  ;; Misali:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "hi": "(defun power-of-two (n)\n  ;; n की घात में 2 की गणना करता है, जहाँ n एक गैर-ऋणात्मक पूर्णांक है।\n  ;; इनपुट: एक गैर-ऋणात्मक पूर्णांक 'n' (0 <= n < 31)।\n  ;; आउटपुट: एक पूर्णांक जो 2^n का प्रतिनिधित्व करता है।\n  ;; उदाहरण:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "hu": "(defun power-of-two (n)\n  ;; Kiszámítja a 2-t n hatványára emelve, ahol n egy nem negatív egész szám.\n  ;; Bemenet: Egy nem negatív egész szám 'n' (0 <= n < 31).\n  ;; Kimenet: Egy egész szám, amely 2^n-et reprezentál.\n  ;; Példa:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.98529976276037",
      "bn": "0.96637505457689",
      "bg": "0.9766631151625921",
      "zh": "0.9696113393750915",
      "fr": "1",
      "de": "0.9883902528588918",
      "ha": "0.9766237863471471",
      "hi": "1",
      "hu": "1"
    },
    "canonical_solution": "  (expt 2 n))",
    "instruction": {
      "en": "(defun power-of-two (n)\n  (expt 2 n))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun power-of-two (n)\n  (expt 2 n))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun power-of-two (n)\n  (expt 2 n))\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) Common Lisp կոդի համար հայերեն՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun power-of-two (n)\n  (expt 2 n))\n\nনিচের Common Lisp কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun power-of-two (n)\n  (expt 2 n))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun power-of-two (n)\n  (expt 2 n))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Common Lisp 代码，字数不超过 500 个字符。",
      "fr": "(defun power-of-two (n)\n  (expt 2 n))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun power-of-two (n)\n  (expt 2 n))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun power-of-two (n)\n  (expt 2 n))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "(defun power-of-two (n)\n  (expt 2 n))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun power-of-two (n)\n  (expt 2 n))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9571526459854401",
      "hy": "0.9452918300427039",
      "bn": "0.8685243658588161",
      "bg": "0.8388862829106369",
      "zh": "0.88778376623434",
      "fr": "0.9711523138711601",
      "de": "0.93952539145088",
      "ha": "0.922724439301425",
      "hi": "0.8784169533558777",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun check-power-of-two ()\n  (assert (= (power-of-two 3) 8))\n  (assert (= (power-of-two 10) 1024))\n  (assert (= (power-of-two 0) 1))\n  (assert (= (power-of-two 5) 32))\n  (assert (= (power-of-two 15) 32768)))\n\n(check-power-of-two)",
    "entry_point": "power-of-two",
    "signature": "(defun power-of-two (n)",
    "docstring": {
      "en": "Calculates 2 raised to the power of n, where n is a non-negative integer.\n Input: A non-negative integer 'n' (0 <= n < 31).\n Output: An integer representing 2^n.\n Example:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "sq": "Llogarit 2 të ngritur në fuqinë e n, ku n është një numër i plotë jo-negativ.\nInput: Një numër i plotë jo-negativ 'n' (0 <= n < 31).\nOutput: Një numër i plotë që përfaqëson 2^n.\nShembull:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "hy": "Հաշվարկում է 2-ը n աստիճանի, որտեղ n-ը ոչ բացասական ամբողջ թիվ է։\nՄուտք: Ոչ բացասական ամբողջ թիվ 'n' (0 <= n < 31)։\nԵլք: Ամբողջ թիվ, որը ներկայացնում է 2^n։\nՕրինակ:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "bn": "2 কে n এর ঘাত হিসাবে গণনা করে, যেখানে n একটি অ-ঋণাত্মক পূর্ণসংখ্যা।\nInput: একটি অ-ঋণাত্মক পূর্ণসংখ্যা 'n' (0 <= n < 31)।\nOutput: একটি পূর্ণসংখ্যা যা 2^n উপস্থাপন করে।\nউদাহরণ:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "bg": "Изчислява 2 на степен n, където n е неотрицателно цяло число.\nВход: Неотрицателно цяло число 'n' (0 <= n < 31).\nИзход: Цяло число, представляващо 2^n.\nПример:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "zh": "计算2的n次幂，其中n是非负整数。\n输入：一个非负整数'n' (0 <= n < 31)。\n输出：一个整数，表示2^n。\n示例：\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "fr": " Calcule 2 élevé à la puissance de n, où n est un entier non négatif.\n Entrée : Un entier non négatif 'n' (0 <= n < 31).\n Sortie : Un entier représentant 2^n.\n Exemple :\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "de": "Berechnet 2 hoch n, wobei n eine nicht-negative ganze Zahl ist.\nEingabe: Eine nicht-negative ganze Zahl 'n' (0 <= n < 31).\nAusgabe: Eine ganze Zahl, die 2^n darstellt.\nBeispiel:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "ha": "Yana lissafin 2 da aka ɗaga zuwa ikon n, inda n ba shi da ƙima mara kyau.\n Shigarwa: Lamba mai kyau mara kyau 'n' (0 <= n < 31).\n Fitarwa: Lamba mai wakiltar 2^n.\n Misali:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "hi": "गणना करता है 2 को n की शक्ति तक, जहाँ n एक गैर-ऋणात्मक पूर्णांक है।\n इनपुट: एक गैर-ऋणात्मक पूर्णांक 'n' (0 <= n < 31)।\n आउटपुट: एक पूर्णांक जो 2^n का प्रतिनिधित्व करता है।\n उदाहरण:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "hu": "Számítja a 2-t az n-edik hatványra emelve, ahol n egy nem negatív egész szám.\n Bemenet: Egy nem negatív egész szám 'n' (0 <= n < 31).\n Kimenet: Egy egész szám, amely a 2^n-et képviseli.\n Példa:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024"
    },
    "docstring_bertscore": {
      "sq": "0.9972056677996012",
      "hy": "0.9758642237700696",
      "bn": "0.9844281726483889",
      "bg": "0.9738747418736242",
      "zh": "0.9709826835257563",
      "fr": "0.9972056677996012",
      "de": "0.9873681009180862",
      "ha": "1",
      "hi": "0.9643529972979549",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/49",
    "prompt": {
      "en": "(defun judge-sign (n)\n  ;; Determines if an integer N is positive, negative, or zero.\n  ;; Input: An integer 'N' (-10^9 <= N <= 10^9).\n  ;; Output: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.\n  ;; Example:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "sq": "(defun judge-sign (n)\n  ;; Përcakton nëse një numër i plotë N është pozitiv, negativ, apo zero.\n  ;; Hyrja: Një numër i plotë 'N' (-10^9 <= N <= 10^9).\n  ;; Dalja: Një varg \"positive\" nëse N > 0, \"zero\" nëse N = 0, ose \"negative\" nëse N < 0.\n  ;; Shembull:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "hy": "(defun judge-sign (n)\n  ;; Որոշում է, արդյոք ամբողջ թիվ N-ը դրական է, բացասական, թե զրո:\n  ;; Մուտք: Ամբողջ թիվ 'N' (-10^9 <= N <= 10^9):\n  ;; Ելք: Տող \"positive\", եթե N > 0, \"zero\", եթե N = 0, կամ \"negative\", եթե N < 0:\n  ;; Օրինակ:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "bn": "(defun judge-sign (n)\n  ;; একটি পূর্ণসংখ্যা N ধনাত্মক, ঋণাত্মক, বা শূন্য কিনা তা নির্ধারণ করে।\n  ;; ইনপুট: একটি পূর্ণসংখ্যা 'N' (-10^9 <= N <= 10^9)।\n  ;; আউটপুট: একটি স্ট্রিং \"positive\" যদি N > 0, \"zero\" যদি N = 0, অথবা \"negative\" যদি N < 0।\n  ;; উদাহরণ:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "bg": "(defun judge-sign (n)\n  ;; Определя дали цяло число N е положително, отрицателно или нула.\n  ;; Вход: Цяло число 'N' (-10^9 <= N <= 10^9).\n  ;; Изход: Низ \"positive\" ако N > 0, \"zero\" ако N = 0, или \"negative\" ако N < 0.\n  ;; Пример:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "zh": "(defun judge-sign (n)\n  ;; 确定整数 N 是正数、负数还是零。\n  ;; 输入: 一个整数 'N' (-10^9 <= N <= 10^9)。\n  ;; 输出: 如果 N > 0，返回字符串 \"positive\"；如果 N = 0，返回 \"zero\"；如果 N < 0，返回 \"negative\"。\n  ;; 示例:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "fr": "(defun judge-sign (n)\n  ;; Détermine si un entier N est positif, négatif ou zéro.\n  ;; Entrée : Un entier 'N' (-10^9 <= N <= 10^9).\n  ;; Sortie : Une chaîne \"positive\" si N > 0, \"zero\" si N = 0, ou \"negative\" si N < 0.\n  ;; Exemple:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "de": "(defun judge-sign (n)\n  ;; Bestimmt, ob eine ganze Zahl N positiv, negativ oder null ist.\n  ;; Eingabe: Eine ganze Zahl 'N' (-10^9 <= N <= 10^9).\n  ;; Ausgabe: Ein String \"positive\", wenn N > 0, \"zero\", wenn N = 0, oder \"negative\", wenn N < 0.\n  ;; Beispiel:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "ha": "(defun judge-sign (n)\n  ;; Yana tantance idan lamba N tana da kyau, mara kyau, ko kuma sifili.\n  ;; Shigarwa: Lamba 'N' (-10^9 <= N <= 10^9).\n  ;; Fitarwa: Kirtani \"positive\" idan N > 0, \"zero\" idan N = 0, ko \"negative\" idan N < 0.\n  ;; Misali:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "hi": "(defun judge-sign (n)\n  ;; यह निर्धारित करता है कि एक पूर्णांक N धनात्मक, ऋणात्मक, या शून्य है।\n  ;; इनपुट: एक पूर्णांक 'N' (-10^9 <= N <= 10^9)।\n  ;; आउटपुट: एक स्ट्रिंग \"positive\" यदि N > 0 है, \"zero\" यदि N = 0 है, या \"negative\" यदि N < 0 है।\n  ;; उदाहरण:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "hu": "(defun judge-sign (n)\n  ;; Meghatározza, hogy egy egész szám N pozitív, negatív vagy nulla-e.\n  ;; Bemenet: Egy egész szám 'N' (-10^9 <= N <= 10^9).\n  ;; Kimenet: Egy \"positive\" sztring, ha N > 0, \"zero\" ha N = 0, vagy \"negative\" ha N < 0.\n  ;; Példa:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\""
    },
    "prompt_bertscore": {
      "sq": "0.9994108622898505",
      "hy": "0.9737952897212103",
      "bn": "0.9994108622898505",
      "bg": "0.9891504113271123",
      "zh": "0.9453180492530004",
      "fr": "1",
      "de": "0.9994108622898505",
      "ha": "0.9734995290838494",
      "hi": "0.9994108622898505",
      "hu": "0.9947104729530409"
    },
    "canonical_solution": "  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))",
    "instruction": {
      "en": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\n请为以下 Common Lisp 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nनिम्नलिखित Common Lisp कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Common Lisp kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8874754918829738",
      "bg": "0.8388862829106369",
      "zh": "0.8724534734260673",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9543551356989448",
      "hi": "0.9077727359994049",
      "hu": "0.9349640433807949"
    },
    "level": "",
    "test": "(defun check-judge-sign ()\n  (assert (string= (judge-sign 95) \"positive\"))\n  (assert (string= (judge-sign 0) \"zero\"))\n  (assert (string= (judge-sign -3) \"negative\"))\n  (assert (string= (judge-sign 1) \"positive\"))\n  (assert (string= (judge-sign -1000000) \"negative\")))\n\n(check-judge-sign)",
    "entry_point": "judge-sign",
    "signature": "(defun judge-sign (n)",
    "docstring": {
      "en": "Determines if an integer N is positive, negative, or zero.\n Input: An integer 'N' (-10^9 <= N <= 10^9).\n Output: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.\n Example:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "sq": "Përcakton nëse një numër i plotë N është pozitiv, negativ, apo zero.\nHyrja: Një numër i plotë 'N' (-10^9 <= N <= 10^9).\nDalja: Një varg \"positive\" nëse N > 0, \"zero\" nëse N = 0, ose \"negative\" nëse N < 0.\nShembull:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "hy": "Սահմանում է, արդյոք ամբողջ թիվ N-ը դրական է, բացասական, թե զրո։  \nՄուտք: Ամբողջ թիվ 'N' (-10^9 <= N <= 10^9)։  \nԵլք: \"positive\" տող, եթե N > 0, \"zero\" եթե N = 0, կամ \"negative\" եթե N < 0։  \nՕրինակ:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "bn": " নির্ধারণ করে একটি পূর্ণসংখ্যা N ধনাত্মক, ঋণাত্মক, বা শূন্য কিনা।\n ইনপুট: একটি পূর্ণসংখ্যা 'N' (-10^9 <= N <= 10^9)।\n আউটপুট: একটি স্ট্রিং \"positive\" যদি N > 0 হয়, \"zero\" যদি N = 0 হয়, অথবা \"negative\" যদি N < 0 হয়।\n উদাহরণ:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "bg": "Определя дали цяло число N е положително, отрицателно или нула.\nВход: Цяло число 'N' (-10^9 <= N <= 10^9).\nИзход: Низ \"positive\" ако N > 0, \"zero\" ако N = 0, или \"negative\" ако N < 0.\nПример:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "zh": "确定整数 N 是正数、负数还是零。  \n输入：一个整数 'N' (-10^9 <= N <= 10^9)。  \n输出：如果 N > 0，返回字符串 \"positive\"；如果 N = 0，返回 \"zero\"；如果 N < 0，返回 \"negative\"。  \n示例：  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "fr": "Détermine si un entier N est positif, négatif ou zéro.\nEntrée : Un entier 'N' (-10^9 <= N <= 10^9).\nSortie : Une chaîne de caractères \"positive\" si N > 0, \"zero\" si N = 0, ou \"negative\" si N < 0.\nExemple:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "de": "Bestimmt, ob eine ganze Zahl N positiv, negativ oder null ist.\nEingabe: Eine ganze Zahl 'N' (-10^9 <= N <= 10^9).\nAusgabe: Ein String \"positive\", wenn N > 0, \"zero\", wenn N = 0, oder \"negative\", wenn N < 0.\nBeispiel:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "ha": "Yana tantance ko lamba N mai cikakken adadi tana da kyau, mara kyau, ko kuma sifili.\n Shigarwa: Wani cikakken adadi 'N' (-10^9 <= N <= 10^9).\n Fitarwa: Wani rubutu \"positive\" idan N > 0, \"zero\" idan N = 0, ko \"negative\" idan N < 0.\n Misali:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "hi": "निर्धारित करता है कि कोई पूर्णांक N धनात्मक, ऋणात्मक, या शून्य है।\nइनपुट: एक पूर्णांक 'N' (-10^9 <= N <= 10^9)।\nआउटपुट: एक स्ट्रिंग \"positive\" यदि N > 0, \"zero\" यदि N = 0, या \"negative\" यदि N < 0।\nउदाहरण:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "hu": "Meghatározza, hogy egy egész szám N pozitív, negatív vagy nulla-e.\nBemenet: Egy egész szám 'N' (-10^9 <= N <= 10^9).\nKimenet: Egy \"positive\" sztring, ha N > 0, \"zero\", ha N = 0, vagy \"negative\", ha N < 0.\nPélda:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\""
    },
    "docstring_bertscore": {
      "sq": "0.9993768964946935",
      "hy": "0.9838598911282481",
      "bn": "0.9922996960184205",
      "bg": "0.9947784045433549",
      "zh": "0.9636017771968809",
      "fr": "0.992672922504385",
      "de": "0.9993768964946935",
      "ha": "0.9810206684617354",
      "hi": "0.9993768964946935",
      "hu": "0.9936879237514733"
    }
  },
  {
    "task_id": "Common Lisp/50",
    "prompt": {
      "en": "(defun abs-value (n)\n  ;; Outputs the absolute value of an integer n.\n  ;; Input: An integer 'n', where the absolute value of n does not exceed 10000.\n  ;; Output: The absolute value of 'n'.\n  ;; Example:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "sq": "(defun abs-value (n)\n  ;; Jep vlerën absolute të një numri të plotë n.\n  ;; Hyrja: Një numër i plotë 'n', ku vlera absolute e n nuk e kalon 10000.\n  ;; Dalja: Vlera absolute e 'n'.\n  ;; Shembull:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "hy": "(defun abs-value (n)\n  ;; Վերադարձնում է ամբողջ թիվ n-ի բացարձակ արժեքը։\n  ;; Մուտք: Ամբողջ թիվ 'n', որտեղ n-ի բացարձակ արժեքը չի գերազանցում 10000-ը։\n  ;; Ելք: 'n'-ի բացարձակ արժեքը։\n  ;; Օրինակ:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "bn": "(defun abs-value (n)\n  ;; একটি পূর্ণসংখ্যা n এর পরম মান আউটপুট করে।\n  ;; ইনপুট: একটি পূর্ণসংখ্যা 'n', যেখানে n এর পরম মান 10000 অতিক্রম করে না।\n  ;; আউটপুট: 'n' এর পরম মান।\n  ;; উদাহরণ:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "bg": "(defun abs-value (n)\n  ;; Извежда абсолютната стойност на цяло число n.\n  ;; Вход: Цяло число 'n', където абсолютната стойност на n не надвишава 10000.\n  ;; Изход: Абсолютната стойност на 'n'.\n  ;; Пример:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "zh": "(defun abs-value (n)\n  ;; 输出整数 n 的绝对值。\n  ;; 输入: 一个整数 'n'，其中 n 的绝对值不超过 10000。\n  ;; 输出: 'n' 的绝对值。\n  ;; 示例:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "fr": "(defun abs-value (n)\n  ;; Renvoie la valeur absolue d'un entier n.\n  ;; Entrée : Un entier 'n', où la valeur absolue de n ne dépasse pas 10000.\n  ;; Sortie : La valeur absolue de 'n'.\n  ;; Exemple:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "de": "(defun abs-value (n)\n  ;; Gibt den Absolutwert einer ganzen Zahl n aus.\n  ;; Eingabe: Eine ganze Zahl 'n', wobei der Absolutwert von n 10000 nicht überschreitet.\n  ;; Ausgabe: Der Absolutwert von 'n'.\n  ;; Beispiel:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "ha": "(defun abs-value (n)\n  ;; Fitar da darajar lamba mai kyau na cikakken lamba n.\n  ;; Shigarwa: Cikakken lamba 'n', inda darajar lamba mai kyau na n ba ta wuce 10000.\n  ;; Fitarwa: Darajar lamba mai kyau na 'n'.\n  ;; Misali:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "hi": "(defun abs-value (n)\n  ;; एक पूर्णांक n का परिमाण मान आउटपुट करता है।\n  ;; इनपुट: एक पूर्णांक 'n', जहाँ n का परिमाण मान 10000 से अधिक नहीं है।\n  ;; आउटपुट: 'n' का परिमाण मान।\n  ;; उदाहरण:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "hu": "(defun abs-value (n)\n  ;; Kimenetként az n egész szám abszolút értékét adja.\n  ;; Bemenet: Egy 'n' egész szám, ahol n abszolút értéke nem haladja meg a 10000-et.\n  ;; Kimenet: Az 'n' abszolút értéke.\n  ;; Példa:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0"
    },
    "prompt_bertscore": {
      "sq": "0.9882557800909312",
      "hy": "0.9837013840841823",
      "bn": "0.999999801369619",
      "bg": "0.999999801369619",
      "zh": "0.9876294984995282",
      "fr": "0.9875673271902643",
      "de": "0.9875673271902643",
      "ha": "0.9924879976196416",
      "hi": "0.9943966369510058",
      "hu": "0.9941606640583364"
    },
    "canonical_solution": "  (abs n))",
    "instruction": {
      "en": "(defun abs-value (n)\n  (abs n))\n\nProvide a concise natural language description (docstring) of the Common Lisp code in English using at most 500 characters.",
      "sq": "(defun abs-value (n)\n  (abs n))\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Common Lisp në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "(defun abs-value (n)\n  (abs n))\n\nՏվեք Common Lisp կոդի հակիրճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "(defun abs-value (n)\n  (abs n))\n\nনিচের Common Lisp কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "(defun abs-value (n)\n  (abs n))\n\nДайте кратко описание на кода на Common Lisp на български език, като използвате максимум 500 знака.",
      "zh": "(defun abs-value (n)\n  (abs n))\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述这段 Common Lisp 代码，字数不超过500个字符。",
      "fr": "(defun abs-value (n)\n  (abs n))\n\nFournissez une description concise en langage naturel (docstring) du code Common Lisp en français en utilisant au maximum 500 caractères.",
      "de": "(defun abs-value (n)\n  (abs n))\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Common Lisp-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "(defun abs-value (n)\n  (abs n))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Common Lisp a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "(defun abs-value (n)\n  (abs n))\n\nसामान्य लिस्प कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "(defun abs-value (n)\n  (abs n))\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Common Lisp kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9568495360239809",
      "hy": "0.9305089625645633",
      "bn": "0.8727891587700162",
      "bg": "0.8388862829106369",
      "zh": "0.8810039154384761",
      "fr": "0.9711523138711601",
      "de": "0.926846814229423",
      "ha": "0.9543551356989448",
      "hi": "0.8808811618629965",
      "hu": "0.9556313358970939"
    },
    "level": "",
    "test": "(defun check-abs-value ()\n  (assert (= (abs-value -3) 3))\n  (assert (= (abs-value 5) 5))\n  (assert (= (abs-value 0) 0))\n  (assert (= (abs-value -10000) 10000))\n  (assert (= (abs-value 9999) 9999)))\n\n(check-abs-value)",
    "entry_point": "abs-value",
    "signature": "(defun abs-value (n)",
    "docstring": {
      "en": "Outputs the absolute value of an integer n.\n Input: An integer 'n', where the absolute value of n does not exceed 10000.\n Output: The absolute value of 'n'.\n Example:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "sq": "Kthen vlerën absolute të një numri të plotë n.  \nHyrja: Një numër i plotë 'n', ku vlera absolute e n nuk e kalon 10000.  \nDalja: Vlera absolute e 'n'.  \nShembull:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "hy": "Արտածում է n ամբողջ թվի բացարձակ արժեքը։  \nՄուտք: Ամբողջ թիվ 'n', որտեղ n-ի բացարձակ արժեքը չի գերազանցում 10000-ը։  \nԵլք: 'n'-ի բացարձակ արժեքը։  \nՕրինակ:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "bn": "একটি পূর্ণসংখ্যা n এর পরম মান আউটপুট করে।\n Input: একটি পূর্ণসংখ্যা 'n', যেখানে n এর পরম মান 10000 অতিক্রম করে না।  \n Output: 'n' এর পরম মান।  \n Example:  \n >>> (abs-value -3)  \n 3  \n >>> (abs-value 5)  \n 5  \n >>> (abs-value 0)  \n 0  ",
      "bg": "Извежда абсолютната стойност на цяло число n.\nВход: Цяло число 'n', където абсолютната стойност на n не надвишава 10000.  \nИзход: Абсолютната стойност на 'n'.  \nПример:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "zh": "输出整数 n 的绝对值。\n 输入: 一个整数 'n'，其中 n 的绝对值不超过 10000。\n 输出: 'n' 的绝对值。\n 示例:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "fr": "Renvoie la valeur absolue d'un entier n.\n Entrée : Un entier 'n', où la valeur absolue de n ne dépasse pas 10000.\n Sortie : La valeur absolue de 'n'.\n Exemple :\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "de": "Gibt den absoluten Wert einer Ganzzahl n aus.\nEingabe: Eine Ganzzahl 'n', wobei der absolute Wert von n 10000 nicht überschreitet.  \nAusgabe: Der absolute Wert von 'n'.  \nBeispiel:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "ha": "Fitar da ƙimar lamba mai kyau na cikakken lamba n.\n Input: Wani cikakken lamba 'n', inda darajar da ba ta da alama ta n ba ta wuce 10000.\n Output: Darajar da ba ta da alama ta 'n'.\n Misali:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "hi": "एक पूर्णांक n का परिमाण मान आउटपुट करता है।\nInput: एक पूर्णांक 'n', जहाँ n का परिमाण मान 10000 से अधिक नहीं होता है।  \nOutput: 'n' का परिमाण मान।  \nExample:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "hu": "Kiírja egy egész szám n abszolút értékét.\n Bemenet: Egy egész szám 'n', ahol n abszolút értéke nem haladja meg a 10000-et.\n Kimenet: 'n' abszolút értéke.\n Példa:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0"
    },
    "docstring_bertscore": {
      "sq": "0.98154743623224",
      "hy": "0.9645230249041207",
      "bn": "1",
      "bg": "1",
      "zh": "0.9845407960744357",
      "fr": "0.985584201466012",
      "de": "1",
      "ha": "0.9515663651492149",
      "hi": "0.9729813024197294",
      "hu": "0.99222858634201"
    }
  }
]