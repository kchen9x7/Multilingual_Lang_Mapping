[
  {
    "task_id": "Python/1",
    "prompt": {
      "en": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "sq": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n    pragu i dhënë.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "hy": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ստուգել, արդյոք տրված թվերի ցուցակում կան երկու թվեր, որոնք ավելի մոտ են միմյանց, քան\n    տրված շեմը։\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "bn": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা পরস্পরের চেয়ে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "bg": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от\n    дадения праг.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "zh": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "fr": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Vérifie si, dans la liste donnée de nombres, il existe deux nombres plus proches l'un de l'autre que\n    le seuil donné.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "de": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n    der gegebene Schwellenwert.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "ha": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da ke kusa da juna fiye da\n    iyaka da aka bayar.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "hi": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" दिए गए संख्याओं की सूची में जाँच करें, क्या कोई दो संख्याएँ एक-दूसरे के जितना करीब हैं\n    दिए गए सीमा से।\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "hu": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9855113041161722",
      "hy": "0.9703311758759618",
      "bn": "0.978701261502391",
      "bg": "0.9714184785817468",
      "zh": "0.9610205753953325",
      "fr": "0.9756588399560796",
      "de": "0.9773527598455451",
      "ha": "0.9728190213984238",
      "hi": "0.9766384849953437",
      "hu": "0.9660800884610532"
    },
    "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False",
    "instruction": {
      "en": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nՏվեք Python կոդի կարճ բնութագրական նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9079183320687034",
      "bn": "0.8657447323066139",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.8902086459260138",
      "hi": "0.8964889413135749",
      "hu": "0.9412719483913198"
    },
    "level": "",
    "test": "def check(has_close_elements):\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck(has_close_elements)",
    "entry_point": "has_close_elements",
    "signature": "def has_close_elements(numbers: List[float], threshold: float) -> bool:",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Ստուգեք, արդյոք տրված թվերի ցուցակում կա՞ն երկու թիվ, որոնք ավելի մոտ են միմյանց, քան տրված շեմը։  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue",
      "bg": "Проверете дали в даден списък от числа има две числа, които са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "zh": "检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue",
      "fr": "Vérifiez si, dans une liste donnée de nombres, deux nombres sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "de": "Prüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Duba idan a cikin jerin lambobin da aka bayar, akwai kowanne lambobi biyu da suka fi kusa da juna fiye da ƙayyadadden tazara.  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue",
      "hi": "दिए गए संख्याओं की सूची में जांचें कि क्या कोई दो संख्याएं एक-दूसरे के करीब हैं दिए गए सीमा से अधिक नहीं।\n\nArgs:\n    numbers (List[float]): संख्याओं की सूची।\n    threshold (float): निकटता की सीमा।\n\nReturns:\n    bool: यदि कोई दो संख्याएं दी गई सीमा से अधिक निकट हैं तो True, अन्यथा False।\n\nExamples:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hu": "Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám közelebb egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "sq": "0.9793704472560976",
      "hy": "0.959087504527101",
      "bn": "0.9425918472732966",
      "bg": "0.957357036647525",
      "zh": "0.9439329996060442",
      "fr": "0.9699684768001922",
      "de": "0.9632567562250233",
      "ha": "0.9527241816402673",
      "hi": "0.8370460189635501",
      "hu": "0.9560595829986052"
    }
  },
  {
    "task_id": "Python/2",
    "prompt": {
      "en": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "sq": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Hyrja për këtë funksion është një varg që përmban grupe të shumta të kllapave të brendashkruara. Qëllimi juaj është të\n    ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre.\n    Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të brendashkruara brenda njëra-tjetrës.\n    Injoroni çdo hapësirë në vargun e hyrjes.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "hy": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի մի քանի խմբեր։ Ձեր նպատակը\n    այդ խմբերը առանձին տողերի բաժանելն է և վերադարձնել դրանց ցուցակը։\n    Առանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակված է) և միմյանց մեջ չեն ներդրված։\n    Անտեսեք մուտքային տողի ցանկացած բացատ։\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "bn": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" এই ফাংশনের ইনপুট একটি স্ট্রিং যা একাধিক গ্রুপের নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল\n    সেই গ্রুপগুলোকে আলাদা স্ট্রিংয়ে বিভক্ত করা এবং সেইগুলোর তালিকা ফেরত দেওয়া।\n    আলাদা গ্রুপগুলো সুষম (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়\n    ইনপুট স্ট্রিংয়ে কোনো স্পেস উপেক্ষা করুন।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "bg": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Входът за тази функция е низ, съдържащ множество групи от вложени скоби. Вашата цел е да\n    разделите тези групи на отделни низове и да върнете списък с тях.\n    Отделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\n    Игнорирайте всички интервали в низа на входа.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "zh": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" 此函数的输入是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成独立的字符串，并返回这些字符串的列表。\n    分离的组是平衡的（每个打开的括号都有正确的闭合）且不相互嵌套。\n    忽略输入字符串中的任何空格。\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "fr": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" L'entrée de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de\n    séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci.\n    Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres.\n    Ignorez les espaces dans la chaîne d'entrée.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "de": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Die Eingabe für diese Funktion ist ein String, der mehrere Gruppen von verschachtelten Klammern enthält. Ihr Ziel ist es,\n    diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben.\n    Separate Gruppen sind ausgeglichen (jede öffnende Klammer wird ordnungsgemäß geschlossen) und nicht ineinander verschachtelt.\n    Ignorieren Sie alle Leerzeichen im Eingabestring.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "ha": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Shigar da wannan aikin shi ne wani igiya mai dauke da kungiyoyi masu yawa na baka-baka masu cike da juna. Manufarka ita ce\n    raba waɗannan ƙungiyoyi zuwa igiyoyi daban-daban kuma dawo da jerin waɗannan.\n    Kungiyoyi daban-daban sun daidaita (kowace buɗaɗɗiyar baka an rufe ta daidai) kuma ba a cike da juna ba\n    Yi watsi da duk wani sarari a cikin igiyar shigarwa.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "hi": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों में नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य है कि\n    उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करें और उनकी सूची लौटाएं।\n    अलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।\n    इनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "hu": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ennek a függvénynek a bemenete egy olyan karakterlánc, amely több, egymásba ágyazott zárójelet tartalmazó csoportot tartalmaz. A cél az,\n    hogy ezeket a csoportokat külön karakterláncokká válasszuk szét, és visszaadjuk ezek listáját.\n    A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva.\n    Figyelmen kívül kell hagyni a bemeneti karakterláncban lévő szóközöket.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.945247138206971",
      "hy": "0.9369014841174091",
      "bn": "0.9392415486363812",
      "bg": "0.9398060561792823",
      "zh": "0.9203069089338494",
      "fr": "0.9469011333898485",
      "de": "0.9474213463577789",
      "ha": "0.939582398370237",
      "hi": "0.9417323736145586",
      "hu": "0.929396632430768"
    },
    "canonical_solution": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result",
    "instruction": {
      "en": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nПредоставете кратко описание на Python кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8653907729676097",
      "bn": "0.8827651710271124",
      "bg": "0.8415791615195284",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9174422615785642",
      "hi": "0.8964889413135749",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def check(separate_paren_groups):\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck(separate_paren_groups)",
    "entry_point": "separate_paren_groups",
    "signature": "def separate_paren_groups(paren_string: str) -> List[str]:",
    "docstring": {
      "en": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "sq": "Inputi për këtë funksion është një varg që përmban disa grupe të kllapave të folezuara. Qëllimi juaj është të ndani ato grupe në vargje të veçanta dhe të ktheni listën e tyre. Grupet e ndara janë të balancuara (çdo kllapë e hapur është mbyllur siç duhet) dhe nuk janë të folezuara brenda njëra-tjetrës. Injoroni çdo hapësirë në vargun e hyrjes.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "hy": "Այս ֆունկցիայի մուտքը տող է, որը պարունակում է փակագծերի մի քանի խմբեր: Ձեր նպատակն է\nայդ խմբերը առանձնացնել առանձին տողերի մեջ և վերադարձնել դրանց ցանկը:\nԱռանձին խմբերը հավասարակշռված են (յուրաքանչյուր բաց փակագիծ ճիշտ փակվում է) և չեն ներդրված միմյանց մեջ:\nԱնտեսեք մուտքային տողի ցանկացած բացատ:\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "bn": "এই ফাংশনের ইনপুট হল একটি স্ট্রিং যা একাধিক গোষ্ঠীর নেস্টেড বন্ধনী ধারণ করে। আপনার লক্ষ্য হল সেই গোষ্ঠীগুলিকে পৃথক স্ট্রিংয়ে বিভক্ত করা এবং সেগুলির তালিকা ফেরত দেওয়া। পৃথক গোষ্ঠীগুলি ভারসাম্যপূর্ণ (প্রতিটি খোলা বন্ধনী সঠিকভাবে বন্ধ করা হয়েছে) এবং একে অপরের মধ্যে নেস্টেড নয়। ইনপুট স্ট্রিংয়ে যেকোনো স্পেস উপেক্ষা করুন।\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "bg": "Входът за тази функция е низ, съдържащ множество групи вложени скоби. Вашата цел е да\nразделите тези групи на отделни низове и да върнете списък с тях.\nОтделните групи са балансирани (всяка отворена скоба е правилно затворена) и не са вложени една в друга.\nИгнорирайте всички интервали в низа на входа.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "zh": "输入此函数的是一个包含多个嵌套括号组的字符串。你的目标是将这些组分离成单独的字符串，并返回这些字符串的列表。  \n分离的组是平衡的（每个开括号都有正确的闭合）并且不相互嵌套。  \n忽略输入字符串中的任何空格。  \n>>> separate_paren_groups('( ) (( )) (( )( ))')  \n['()', '(())', '(()())']  ",
      "fr": "La saisie de cette fonction est une chaîne contenant plusieurs groupes de parenthèses imbriquées. Votre objectif est de séparer ces groupes en chaînes distinctes et de retourner la liste de celles-ci. Les groupes séparés sont équilibrés (chaque parenthèse ouvrante est correctement fermée) et ne sont pas imbriqués les uns dans les autres. Ignorez tous les espaces dans la chaîne d'entrée.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "de": "Eingabe für diese Funktion ist ein String, der mehrere Gruppen von geschachtelten Klammern enthält. Ihr Ziel ist es, diese Gruppen in separate Strings zu trennen und die Liste dieser zurückzugeben. \nSeparate Gruppen sind ausgeglichen (jede öffnende Klammer wird ordnungsgemäß geschlossen) und nicht ineinander verschachtelt. \nIgnorieren Sie alle Leerzeichen im Eingabestring.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "ha": "Shigar da wannan aikin shine wani igiyar rubutu da ke dauke da kungiyoyi da yawa na baka-baka masu hade. Manufarka ita ce raba wadannan kungiyoyin zuwa igiyoyi daban-daban kuma dawo da jerin wadannan.\nKungiyoyi daban-daban suna daidaita (kowace baka-baka mai bude tana da rufewa daidai) kuma ba a hade cikin juna ba.\nYi watsi da duk wani sarari a cikin igiyar shigarwa.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "hi": "इस फ़ंक्शन का इनपुट एक स्ट्रिंग है जिसमें कई समूहों के नेस्टेड कोष्ठक होते हैं। आपका लक्ष्य उन समूहों को अलग-अलग स्ट्रिंग्स में विभाजित करना और उनकी सूची लौटाना है।  \nअलग-अलग समूह संतुलित होते हैं (प्रत्येक खुला कोष्ठक सही ढंग से बंद होता है) और एक-दूसरे के भीतर नेस्टेड नहीं होते हैं।  \nइनपुट स्ट्रिंग में किसी भी स्पेस को अनदेखा करें।  \n>>> separate_paren_groups('( ) (( )) (( )( ))')  \n['()', '(())', '(()())']",
      "hu": "A függvény bemenete egy olyan karakterlánc, amely több csoportot tartalmaz egymásba ágyazott zárójelekből. A cél az, hogy ezeket a csoportokat külön karakterláncokra bontsuk, és visszaadjuk ezek listáját. A különálló csoportok kiegyensúlyozottak (minden nyitó zárójel megfelelően zárva van), és nincsenek egymásba ágyazva. Figyelmen kívül kell hagyni az esetleges szóközöket a bemeneti karakterláncban.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']"
    },
    "docstring_bertscore": {
      "sq": "0.9324128347667827",
      "hy": "0.9105009242829191",
      "bn": "0.9360088391850383",
      "bg": "0.9249371817461537",
      "zh": "0.9171880146908395",
      "fr": "0.9278890278387132",
      "de": "0.942343757927384",
      "ha": "0.8836139186452745",
      "hi": "0.918562139666839",
      "hu": "0.9143545523053769"
    }
  },
  {
    "task_id": "Python/3",
    "prompt": {
      "en": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "sq": "def truncate_number(number: float) -> float:\n    \"\"\" Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në\n    një pjesë të plotë (numri i plotë më i madh më i vogël se numri i dhënë) dhe dhjetore\n    (pjesa e mbetur gjithmonë më e vogël se 1).\n    \n    Kthen pjesën dhjetore të numrit.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "hy": "def truncate_number(number: float) -> float:\n    \"\"\" Տրված դրական տասնորդական կետով թիվը կարող է բաժանվել\n    ամբողջ թվային մասի (տրված թվից փոքրագույն ամբողջ թիվը) և տասնորդական մասի\n    (միշտ 1-ից փոքր մնացորդային մաս):\n    \n    Վերադարձնել թվի տասնորդական մասը:\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "bn": "def truncate_number(number: float) -> float:\n    \"\"\" একটি ধনাত্মক ভাসমান বিন্দু সংখ্যা দেওয়া হলে, এটি বিভক্ত করা যেতে পারে\n    একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে\n    (সবসময় 1 এর চেয়ে ছোট অবশিষ্ট অংশ)।\n\n    সংখ্যার দশমিক অংশ ফেরত দিন।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "bg": "def truncate_number(number: float) -> float:\n    \"\"\" Дадено е положително число с плаваща запетая, което може да бъде\n    разложено на цяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n    (оставаща част, винаги по-малка от 1).\n    \n    Връща десетичната част на числото.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "zh": "def truncate_number(number: float) -> float:\n    \"\"\" 给定一个正浮点数，它可以分解为整数部分（小于给定数字的最大整数）和小数部分（始终小于1的剩余部分）。\n    \n    返回数字的小数部分。\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "fr": "def truncate_number(number: float) -> float:\n    \"\"\" Étant donné un nombre flottant positif, il peut être décomposé en\n    une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales\n    (partie restante toujours inférieure à 1).\n    \n    Retourne la partie décimale du nombre.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "de": "def truncate_number(number: float) -> float:\n    \"\"\" Gegeben eine positive Gleitkommazahl, kann sie in einen\n    ganzzahligen Teil (größte ganze Zahl kleiner als die gegebene Zahl) und Dezimalstellen\n    (Restteil immer kleiner als 1) zerlegt werden.\n    \n    Gibt den Dezimalteil der Zahl zurück.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "ha": "def truncate_number(number: float) -> float:\n    \"\"\" Idan aka ba da lamba mai yuwuwa mai kyau, za a iya raba ta zuwa\n    wani ɓangare na lamba (mafi girman lamba ƙasa da lambar da aka bayar) da kuma ragowar\n    (ɓangaren da ya rage koyaushe ƙasa da 1).\n    \n    Mayar da ɓangaren ragowar na lambar.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "hi": "def truncate_number(number: float) -> float:\n    \"\"\" दिए गए एक सकारात्मक फ्लोटिंग पॉइंट संख्या को, इसे एक पूर्णांक भाग (दिए गए संख्या से छोटा सबसे बड़ा पूर्णांक) और दशमलवों में विभाजित किया जा सकता है\n    (हमेशा 1 से छोटा बचा हुआ भाग)।\n    \n    संख्या के दशमलव भाग को लौटाएं।\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "hu": "def truncate_number(number: float) -> float:\n    \"\"\" Adott egy pozitív lebegőpontos szám, amely felbontható egy\n    egész részre (a megadott számnál kisebb legnagyobb egész) és tizedesjegyekre\n    (mindig 1-nél kisebb maradék rész).\n    \n    Visszaadja a szám tizedesjegy részét.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9190428251889434",
      "hy": "0.899643589025171",
      "bn": "0.9306827641479689",
      "bg": "0.9452395902524917",
      "zh": "0.9228910901911133",
      "fr": "0.9640103598906696",
      "de": "0.9317593408131779",
      "ha": "0.879938859335367",
      "hi": "0.945053870846224",
      "hu": "0.9198168877838363"
    },
    "canonical_solution": "    return number % 1.0",
    "instruction": {
      "en": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nՏվեք Python կոդի համառոտ բնական լեզվով նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nনিচে প্রদত্ত পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9493152870409466",
      "bn": "0.8612707816041841",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9465106260607339",
      "de": "0.925758518371733",
      "ha": "0.9662707736268467",
      "hi": "0.91110952777041",
      "hu": "0.9315178062698395"
    },
    "level": "",
    "test": "def check(truncate_number):\n    assert truncate_number(3.5) == 0.5\n    assert abs(truncate_number(1.33) - 0.33) < 1e-6\n    assert abs(truncate_number(123.456) - 0.456) < 1e-6\n \ncheck(truncate_number)",
    "entry_point": "truncate_number",
    "signature": "def truncate_number(number: float) -> float:",
    "docstring": {
      "en": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncate_number(3.5)\n0.5",
      "sq": "Duke pasur një numër pozitiv me presje dhjetore, ai mund të dekompozohet në një pjesë të plotë (numri më i madh i plotë më i vogël se numri i dhënë) dhe dhjetore (pjesa e mbetur gjithmonë më e vogël se 1).\n\nKthen pjesën dhjetore të numrit.\n>>> truncate_number(3.5)\n0.5",
      "hy": "Դրված դրական լողացող կետով թիվը կարելի է բաժանել ամբողջ մասի (տրված թվից փոքրագույն ամբողջ թիվ) և տասնորդական մասի (մնացորդային մասը միշտ փոքր է 1-ից):\n\nՎերադարձնում է թվի տասնորդական մասը.\n>>> truncate_number(3.5)\n0.5",
      "bn": "প্রদত্ত একটি ধনাত্মক ফ্লোটিং পয়েন্ট সংখ্যা, এটি একটি পূর্ণসংখ্যা অংশে (প্রদত্ত সংখ্যার চেয়ে ছোট বৃহত্তম পূর্ণসংখ্যা) এবং দশমিক অংশে (অবশিষ্ট অংশ সর্বদা ১ এর চেয়ে ছোট) বিভক্ত করা যেতে পারে।\n\nসংখ্যার দশমিক অংশটি ফেরত দিন।\n>>> truncate_number(3.5)\n0.5",
      "bg": "Дадено е положително число с плаваща запетая, което може да бъде разложено на\nцяла част (най-голямото цяло число, по-малко от даденото число) и десетични\n(остатъчната част винаги е по-малка от 1).\n\nВръща десетичната част на числото.",
      "zh": "给定一个正浮点数，它可以被分解为一个整数部分（小于给定数字的最大整数）和小数部分（剩余部分总是小于1）。\n\n返回数字的小数部分。  \n>>> truncate_number(3.5)  \n0.5",
      "fr": "Étant donné un nombre flottant positif, il peut être décomposé en une partie entière (le plus grand entier plus petit que le nombre donné) et des décimales (la partie restante toujours plus petite que 1).\n\nRetourne la partie décimale du nombre.\n>>> truncate_number(3.5)\n0.5",
      "de": "Given eine positive Gleitkommazahl, kann sie in einen ganzzahligen Teil (größte ganze Zahl kleiner als die gegebene Zahl) und Dezimalstellen (übrig bleibender Teil immer kleiner als 1) zerlegt werden.\n\nGibt den Dezimalteil der Zahl zurück.\n>>> truncate_number(3.5)\n0.5",
      "ha": "An ba da lamba mai iyo mai kyau, za a iya rarraba ta zuwa\nsashi na cikakken lamba (babban cikakken lamba da ya fi ƙaramin lambar da aka bayar) da kuma ragowar\n(sashi mai saura koyaushe ƙasa da 1).\n\nMayar da sashin ragowar lambar.\n>>> truncate_number(3.5)\n0.5",
      "hi": "दिए गए एक धनात्मक फ्लोटिंग पॉइंट संख्या को इसके पूर्णांक भाग (दी गई संख्या से छोटी सबसे बड़ी पूर्णांक) और दशमलव में विभाजित किया जा सकता है (शेष भाग हमेशा 1 से छोटा होता है)।\n\nसंख्या के दशमलव भाग को लौटाएँ।\n>>> truncate_number(3.5)\n0.5",
      "hu": "Adott egy pozitív lebegőpontos szám, amely felbontható egy egész részre (a megadott számnál kisebb legnagyobb egész) és tizedesekre (a maradék rész mindig kisebb, mint 1).\n\nVisszaadja a szám tizedes részét."
    },
    "docstring_bertscore": {
      "sq": "0.9146429636186396",
      "hy": "0.8813809159016803",
      "bn": "0.9125396665138611",
      "bg": "0.8559073640554801",
      "zh": "0.9064671385048625",
      "fr": "0.9601116427717169",
      "de": "0.9105843490429537",
      "ha": "0.8674005151629207",
      "hi": "0.9085348807714357",
      "hu": "0.8517436740082267"
    }
  },
  {
    "task_id": "Python/4",
    "prompt": {
      "en": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "sq": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ju jepet një listë e operacioneve të depozitave dhe tërheqjeve në një llogari bankare që fillon me\n    bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe\n    në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "hy": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Ձեզ տրված է բանկային հաշվի վրա ավանդների և դուրսբերումների գործողությունների ցուցակ, որը սկսվում է\n    զրոյական մնացորդով։ Ձեր խնդիրն է հայտնաբերել, թե արդյոք որևէ պահի հաշվի մնացորդը ընկնում է զրոյից ցածր, և\n    այդ պահին ֆունկցիան պետք է վերադարձնի True։ Հակառակ դեպքում այն պետք է վերադարձնի False։\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "bn": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" আপনার কাছে একটি ব্যাংক অ্যাকাউন্টে জমা এবং উত্তোলনের কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়।\n    আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে পড়ে কিনা, এবং সেই সময়ে ফাংশনটি True রিটার্ন করবে।\n    অন্যথায় এটি False রিটার্ন করবে।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "bg": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Даден ви е списък с операции за депозити и тегления от банкова сметка, която започва с\n    нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и\n    в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "zh": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" 给定一个银行账户的存款和取款操作列表，该账户初始余额为零。你的任务是检测账户余额是否在任何时候低于零，\n    如果是，函数应返回True。否则应返回False。\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "fr": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" On vous donne une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec\n    un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et\n    à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "de": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sie erhalten eine Liste von Einzahlungs- und Abhebungsoperationen auf einem Bankkonto, das mit\n    einem Kontostand von null beginnt. Ihre Aufgabe ist es, zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und\n    in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "ha": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" An ba ku jerin ajiya da cire kudi a kan asusun banki wanda ya fara da\n    sifili a matsayin ma'auni. Aikin ku shine gano ko a kowane lokaci ma'aunin asusun ya fadi kasa da sifili, kuma\n    a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "hi": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" आपको जमा और निकासी संचालन की एक सूची दी गई है जो एक बैंक खाते पर होती है जो शून्य शेष के साथ शुरू होती है। \n    आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते का शेष शून्य से नीचे गिरता है, और उस बिंदु पर \n    फ़ंक्शन को True लौटाना चाहिए। अन्यथा इसे False लौटाना चाहिए।\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "hu": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Adott egy lista a banki számlán végzett befizetési és kifizetési műveletekről, amely nulla egyenleggel kezdődik.\n    Az a feladat, hogy észleljük, ha bármelyik ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia.\n    Egyébként False értéket kell visszaadnia.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9725709320525112",
      "hy": "0.9737114677004136",
      "bn": "0.9648007101768075",
      "bg": "0.9619451998190499",
      "zh": "0.9409978384654917",
      "fr": "0.9742165847593853",
      "de": "0.9569883786603243",
      "ha": "0.9618979257883636",
      "hi": "0.9650384707429063",
      "hu": "0.9537304431505901"
    },
    "canonical_solution": "    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False",
    "instruction": {
      "en": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nՏվեք Python կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nПредоставете кратко описание на Python кода на български език, използвайки максимум 500 знака.",
      "zh": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nGeben Sie eine prägnante Beschreibung (Docstring) des Python-Codes in deutscher Sprache mit maximal 500 Zeichen an.",
      "ha": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9269590403947078",
      "bn": "0.8657447323066139",
      "bg": "0.8431074236712108",
      "zh": "0.8839134532598751",
      "fr": "0.9690480236144765",
      "de": "0.9232869605405158",
      "ha": "0.9174422615785642",
      "hi": "0.9109764454151166",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def check(below_zero):\n    assert below_zero([]) == False\n    assert below_zero([1, 2, -3, 1, 2, -3]) == False\n    assert below_zero([1, 2, -4, 5, 6]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True\n \ncheck(below_zero)",
    "entry_point": "below_zero",
    "signature": "def below_zero(operations: List[int]) -> bool:",
    "docstring": {
      "en": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "sq": "Ju jepet një listë e operacioneve të depozitimit dhe tërheqjes në një llogari bankare që fillon me bilanc zero. Detyra juaj është të zbuloni nëse në ndonjë moment bilanci i llogarisë bie nën zero, dhe në atë pikë funksioni duhet të kthejë True. Përndryshe, duhet të kthejë False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "hy": "Ձեզ տրված է բանկային հաշվի վրա կատարված ավանդների և հանումների գործողությունների ցուցակը, որը սկսվում է զրոյական մնացորդով: Ձեր խնդիրն է հայտնաբերել, արդյոք որևէ պահի հաշվի մնացորդը ընկնում է զրոյից ցածր, և այդ պահին ֆունկցիան պետք է վերադարձնի True: Հակառակ դեպքում այն պետք է վերադարձնի False:\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "bn": "আপনাকে একটি ব্যাংক অ্যাকাউন্টের জমা এবং উত্তোলন কার্যক্রমের একটি তালিকা দেওয়া হয়েছে যা শূন্য ব্যালেন্স দিয়ে শুরু হয়। আপনার কাজ হল সনাক্ত করা যে কোনো সময় অ্যাকাউন্টের ব্যালেন্স শূন্যের নিচে নেমে যায় কিনা, এবং সেই সময়ে ফাংশনটি True ফেরত দেওয়া উচিত। অন্যথায় এটি False ফেরত দেওয়া উচিত।\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "bg": "Даден ви е списък с операции за депозити и тегления по банкова сметка, която започва с нулев баланс. Вашата задача е да откриете дали в някакъв момент балансът на сметката пада под нула, и в този момент функцията трябва да върне True. В противен случай трябва да върне False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "zh": "你有一个银行账户的存款和取款操作列表，该账户从零余额开始。你的任务是检测账户余额是否在任何时候低于零，并在那时函数应返回True。否则，它应返回False。\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "fr": "Vous avez une liste d'opérations de dépôt et de retrait sur un compte bancaire qui commence avec un solde nul. Votre tâche est de détecter si à un moment donné le solde du compte tombe en dessous de zéro, et à ce moment-là, la fonction doit retourner True. Sinon, elle doit retourner False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "de": "Du hast eine Liste von Einzahlungs- und Abhebungsvorgängen auf einem Bankkonto, das mit einem Kontostand von null beginnt. Deine Aufgabe ist es zu erkennen, ob der Kontostand zu irgendeinem Zeitpunkt unter null fällt, und in diesem Fall sollte die Funktion True zurückgeben. Andernfalls sollte sie False zurückgeben.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "ha": "An ba ku jerin ayyukan ajiya da cire kudi a kan asusun banki wanda ya fara da sifili. Aikinku shine gano ko a kowane lokaci ma'aunin asusun ya fadi kasa da sifili, kuma a wannan lokacin aikin ya kamata ya dawo da True. In ba haka ba ya kamata ya dawo da False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "hi": "आपको जमा और निकासी ऑपरेशनों की एक सूची दी गई है जो एक बैंक खाते पर की जाती हैं, जो शून्य शेष राशि से शुरू होता है। आपका कार्य यह पता लगाना है कि क्या किसी भी बिंदु पर खाते की शेष राशि शून्य से नीचे गिरती है, और उस बिंदु पर फ़ंक्शन को True लौटाना चाहिए। अन्यथा, इसे False लौटाना चाहिए।\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "hu": "Egy bankszámlán végrehajtott befizetési és kifizetési műveletek listáját kapod, amely kezdetben nulla egyenleggel rendelkezik. A feladatod az, hogy észleld, ha bármely ponton a számla egyenlege nulla alá csökken, és ebben az esetben a függvénynek True értéket kell visszaadnia. Ellenkező esetben False értéket kell visszaadnia.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue"
    },
    "docstring_bertscore": {
      "sq": "0.9683317624604647",
      "hy": "0.9613612264988073",
      "bn": "0.9602860402462655",
      "bg": "0.950849309473679",
      "zh": "0.9467605030800759",
      "fr": "0.9564606177379146",
      "de": "0.939924241255998",
      "ha": "0.957481577896434",
      "hi": "0.9581827431414871",
      "hu": "0.9371382515316027"
    }
  },
  {
    "task_id": "Python/5",
    "prompt": {
      "en": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "sq": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Për një listë të dhënë të numrave hyrës, llogaritni Devijimin Absolut Mesatar\n    rreth mesatares së këtij grupi të dhënash.\n    Devijimi Absolut Mesatar është diferenca mesatare absolute midis secilit\n    element dhe një pikë qendrore (mesatarja në këtë rast):\n    MAD = mesatarja | x - x_mesatarja |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "hy": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Տրված մուտքային թվերի ցուցակի համար հաշվարկել Միջին բացարձակ շեղումը\n    այս տվյալների հավաքածուի միջինի շուրջ:\n    Միջին բացարձակ շեղումը միջին բացարձակ տարբերությունն է յուրաքանչյուր\n    տարրի և կենտրոնական կետի (այս դեպքում միջինի) միջև:\n    MAD = միջին | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "bn": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি\n    হিসাব করুন।\n    গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য:\n    MAD = গড় | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "bg": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" За даден списък от входни числа, изчислете Средно Абсолютно Отклонение\n    около средната стойност на този набор от данни.\n    Средното Абсолютно Отклонение е средната абсолютна разлика между всеки\n    елемент и централната точка (в случая средната стойност):\n    MAD = средно | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "zh": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" 对于给定的输入数字列表，计算该数据集的平均绝对偏差。\n    平均绝对偏差是每个元素与中心点（在此情况下为平均值）之间的平均绝对差：\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "fr": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Pour une liste donnée de nombres en entrée, calculer la Déviation Moyenne Absolue\n    autour de la moyenne de cet ensemble de données.\n    La Déviation Moyenne Absolue est la différence absolue moyenne entre chaque\n    élément et un point central (la moyenne dans ce cas) :\n    MAD = moyenne | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "de": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Für eine gegebene Liste von Eingabezahlen die mittlere absolute Abweichung\n    um den Mittelwert dieses Datensatzes berechnen.\n    Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem\n    Element und einem Mittelpunkt (in diesem Fall der Mittelwert):\n    MAD = Durchschnitt | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "ha": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Don wani jerin lambobi na shigarwa, ƙididdige Matsakaicin Bambancin Gaskiya\n    a kusa da matsakaicin wannan bayanan.\n    Matsakaicin Bambancin Gaskiya shine matsakaicin bambancin gaskiya tsakanin kowanne\n    abu da wani wuri na tsakiya (matsakaici a wannan yanayin):\n    MAD = matsakaici | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "hi": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर\n    औसत निरपेक्ष विचलन की गणना करें।\n    औसत निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्र बिंदु (इस मामले में औसत)\n    के बीच औसत निरपेक्ष अंतर है:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "hu": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Adott számok listájára számítsa ki az átlagos abszolút eltérést\n    a dataset átlagához képest.\n    Az átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag)\n    közötti átlagos abszolút különbség:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9812087714325755",
      "hy": "0.9456807483287701",
      "bn": "0.9564375766137145",
      "bg": "0.9581167978549835",
      "zh": "0.9485515532258674",
      "fr": "0.9725909937209958",
      "de": "0.9645007783014448",
      "ha": "0.9560679254746086",
      "hi": "0.9541010874416012",
      "hu": "0.9383737325016397"
    },
    "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)",
    "instruction": {
      "en": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nՏվեք Python կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nBa da takaitaccen bayanin yanayi na halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9269590403947078",
      "bn": "0.8958006870432891",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9321097248053235",
      "hi": "0.91110952777041",
      "hu": "0.9317666901372762"
    },
    "level": "",
    "test": "def check(mean_absolute_deviation):\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n    \ncheck(mean_absolute_deviation)",
    "entry_point": "mean_absolute_deviation",
    "signature": "def mean_absolute_deviation(numbers: List[float]) -> float:",
    "docstring": {
      "en": "For a given list of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0",
      "sq": "Për një listë të dhënë të numrave të hyrjes, llogaritni Devijimin Absolut Mesatar rreth mesatares së këtij grupi të dhënash. Devijimi Absolut Mesatar është diferenca mesatare absolute midis secilit element dhe një pikë qendrore (mesatarja në këtë rast): DAM = mesatarja | x - x_mesatare |",
      "hy": "Տրված մուտքային թվերի ցուցակի համար հաշվարկեք միջին բացարձակ շեղումը տվյալների այս հավաքածուի միջինից։  \nՄիջին բացարձակ շեղումը յուրաքանչյուր տարրի և կենտրոնական կետի (այս դեպքում՝ միջինը) միջև միջին բացարձակ տարբերությունն է։  \nMAD = միջին | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0",
      "bn": "প্রদত্ত ইনপুট সংখ্যার তালিকার জন্য, এই ডেটাসেটের গড়ের চারপাশে গড় পরম বিচ্যুতি গণনা করুন। গড় পরম বিচ্যুতি হল প্রতিটি উপাদান এবং একটি কেন্দ্রবিন্দুর (এই ক্ষেত্রে গড়) মধ্যে গড় পরম পার্থক্য: MAD = গড় | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0",
      "bg": "За даден списък от входни числа, изчислете Средно Абсолютно Отклонение около средната стойност на този набор от данни. Средно Абсолютно Отклонение е средната абсолютна разлика между всеки елемент и централната точка (в този случай средната стойност): MAD = средно | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0",
      "zh": "对于给定的输入数字列表，计算该数据集均值的平均绝对偏差。  \n平均绝对偏差是每个元素与中心点（在此情况下为均值）之间的平均绝对差：  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0",
      "fr": "Pour une liste donnée de nombres d'entrée, calculez la Déviation Absolue Moyenne autour de la moyenne de cet ensemble de données.  \nLa Déviation Absolue Moyenne est la différence absolue moyenne entre chaque élément et un point central (la moyenne dans ce cas) :  \nMAD = moyenne | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0",
      "de": "Für eine gegebene Liste von Eingabezahlen berechnen Sie die mittlere absolute Abweichung um den Mittelwert dieses Datensatzes. Die mittlere absolute Abweichung ist der durchschnittliche absolute Unterschied zwischen jedem Element und einem Mittelpunkt (in diesem Fall der Mittelwert): MAD = durchschnittlich | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0",
      "ha": "Don jerin lambobin shigarwa da aka bayar, ƙididdige Matsakaicin Bambancin Gaskiya a kusa da matsakaicin wannan bayanan. Matsakaicin Bambancin Gaskiya shine matsakaicin bambancin gaskiya tsakanin kowane abu da wata cibiyar (matsakaici a wannan yanayin): MAD = matsakaici | x - x_mean | >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) 1.0",
      "hi": "दिए गए इनपुट संख्याओं की सूची के लिए, इस डेटा सेट के औसत के चारों ओर माध्य निरपेक्ष विचलन की गणना करें।  \nमाध्य निरपेक्ष विचलन प्रत्येक तत्व और एक केंद्र बिंदु (इस मामले में औसत) के बीच औसत निरपेक्ष अंतर है:  \nMAD = औसत | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0",
      "hu": "Egy adott bemeneti számok listájára számítsa ki az átlagos abszolút eltérést az adathalmaz átlagához képest.  \nAz átlagos abszolút eltérés az egyes elemek és egy középpont (jelen esetben az átlag) közötti átlagos abszolút különbség:  \nMAD = average | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0"
    },
    "docstring_bertscore": {
      "sq": "0.8551762056228907",
      "hy": "0.9199102440629228",
      "bn": "0.9434833004233812",
      "bg": "0.9647731005538436",
      "zh": "0.9403967829324801",
      "fr": "0.9605571707163781",
      "de": "0.9510987892322588",
      "ha": "0.9502657334141985",
      "hi": "0.9409164000092674",
      "hu": "0.8984351217869547"
    }
  },
  {
    "task_id": "Python/6",
    "prompt": {
      "en": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    \"\"\"",
      "sq": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Shton dy numra të plotë së bashku.\n\n    Parametrat:\n    a (int): Numri i parë që do të shtohet.\n    b (int): Numri i dytë që do të shtohet.\n\n    Kthen:\n    int: Shuma e dy numrave.\n    \"\"\"",
      "hy": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Գումարում է երկու ամբողջ թիվ իրար։\n\n    Պարամետրեր:\n    a (int): Առաջին թիվը, որը պետք է գումարվի։\n    b (int): Երկրորդ թիվը, որը պետք է գումարվի։\n\n    Վերադարձնում է:\n    int: Երկու թվերի գումարը։\n    \"\"\"",
      "bn": "def add(a: int, b: int) -> int:\n    \"\"\"\n    দুটি পূর্ণসংখ্যা একসাথে যোগ করে।\n\n    প্যারামিটারসমূহ:\n    a (int): যোগ করার জন্য প্রথম সংখ্যা।\n    b (int): যোগ করার জন্য দ্বিতীয় সংখ্যা।\n\n    রিটার্নস:\n    int: দুটি সংখ্যার যোগফল।\n    \"\"\"",
      "bg": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Събира две цели числа.\n\n    Параметри:\n    a (int): Първото число, което ще бъде събрано.\n    b (int): Второто число, което ще бъде събрано.\n\n    Връща:\n    int: Сумата на двете числа.\n    \"\"\"",
      "zh": "def add(a: int, b: int) -> int:\n    \"\"\"\n    将两个整数相加。\n\n    参数:\n    a (int): 要相加的第一个数字。\n    b (int): 要相加的第二个数字。\n\n    返回:\n    int: 两个数字的和。\n    \"\"\"",
      "fr": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Ajoute deux nombres entiers ensemble.\n\n    Paramètres:\n    a (int): Le premier nombre à ajouter.\n    b (int): Le deuxième nombre à ajouter.\n\n    Renvoie:\n    int: La somme des deux nombres.\n    \"\"\"",
      "de": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Addiert zwei ganze Zahlen miteinander.\n\n    Parameter:\n    a (int): Die erste Zahl, die addiert werden soll.\n    b (int): Die zweite Zahl, die addiert werden soll.\n\n    Rückgabe:\n    int: Die Summe der beiden Zahlen.\n    \"\"\"",
      "ha": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Ƙara lambobi guda biyu na integer tare.\n\n    Sigogi:\n    a (int): Lamba ta farko da za a ƙara.\n    b (int): Lamba ta biyu da za a ƙara.\n\n    Komawa:\n    int: Jimillar lambobin biyu.\n    \"\"\"",
      "hi": "def add(a: int, b: int) -> int:\n    \"\"\"\n    दो पूर्णांक संख्याओं को एक साथ जोड़ता है।\n\n    पैरामीटर्स:\n    a (int): पहली संख्या जो जोड़ी जाएगी।\n    b (int): दूसरी संख्या जो जोड़ी जाएगी।\n\n    रिटर्न्स:\n    int: दोनों संख्याओं का योग।\n    \"\"\"",
      "hu": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Két egész számot ad össze.\n\n    Paraméterek:\n    a (int): Az első szám, amelyet hozzáadunk.\n    b (int): A második szám, amelyet hozzáadunk.\n\n    Visszatérési érték:\n    int: A két szám összege.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9878527590478114",
      "hy": "0.9878527590478114",
      "bn": "0.9744187904872789",
      "bg": "0.9827362390627338",
      "zh": "0.9664239176506245",
      "fr": "0.9744187904872789",
      "de": "0.9878527590478114",
      "ha": "0.9836890690005581",
      "hi": "0.9955856384118806",
      "hu": "0.9671620281465502"
    },
    "canonical_solution": "    return a + b",
    "instruction": {
      "en": "def add(a: int, b: int) -> int:\n    return a + b\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def add(a: int, b: int) -> int:\n    return a + b\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def add(a: int, b: int) -> int:\n    return a + b\n\nՏվյալ Python կոդի համար տրամադրել կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def add(a: int, b: int) -> int:\n    return a + b\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def add(a: int, b: int) -> int:\n    return a + b\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def add(a: int, b: int) -> int:\n    return a + b\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "def add(a: int, b: int) -> int:\n    return a + b\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def add(a: int, b: int) -> int:\n    return a + b\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def add(a: int, b: int) -> int:\n    return a + b\n\nBa da wani takaitaccen bayani na yanayi (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def add(a: int, b: int) -> int:\n    return a + b\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में वर्णन (डॉकस्ट्रिंग) हिंदी में करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def add(a: int, b: int) -> int:\n    return a + b\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8697749427378118",
      "bn": "0.8842060358111395",
      "bg": "0.8983697723915943",
      "zh": "0.8839134532598751",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.8868555664637638",
      "hi": "0.9170904871737514",
      "hu": "0.9317666901372762"
    },
    "level": "",
    "test": "# Test cases:\n# The following lines are not part of the function's implementation but are provided\n# for testing purposes.\n\n# Test case 1: Positive integers\nassert add(2, 3) == 5\n\n# Test case 2: A positive and a negative integer\nassert add(-1, 1) == 0\n\n# Test case 3: Two negative integers\nassert add(-4, -5) == -9\n\n# Test case 4: Zeroes\nassert add(0, 0) == 0\n\n# Test case 5: Large integers\nassert add(123456, 654321) == 777777\n\nprint(\"All test cases passed.\")",
    "entry_point": "add",
    "signature": "def add(a: int, b: int) -> int:",
    "docstring": {
      "en": "Adds two integer numbers together.\n\nParameters:\na (int): The first number to be added.\nb (int): The second number to be added.\n\nReturns:\nint: The sum of the two numbers.",
      "sq": "Shton dy numra të plotë së bashku.\n\nParametrat:\na (int): Numri i parë që do të shtohet.\nb (int): Numri i dytë që do të shtohet.\n\nKthen:\nint: Shuma e dy numrave.",
      "hy": "Երկու ամբողջ թիվ գումարում է իրար։\n\nՊարամետրեր:\na (int): Առաջին թիվը, որը պետք է գումարվի։\nb (int): Երկրորդ թիվը, որը պետք է գումարվի։\n\nՎերադարձնում է:\nint: Երկու թվերի գումարը։",
      "bn": "দুটি পূর্ণসংখ্যা একসাথে যোগ করে।\n\nপ্যারামিটারসমূহ:\na (int): যোগ করার জন্য প্রথম সংখ্যা।\nb (int): যোগ করার জন্য দ্বিতীয় সংখ্যা।\n\nফেরত দেয়:\nint: দুটি সংখ্যার যোগফল।",
      "bg": "Събира две цели числа заедно.\n\nПараметри:\na (int): Първото число, което ще бъде събрано.\nb (int): Второто число, което ще бъде събрано.\n\nВръща:\nint: Сумата на двете числа.",
      "zh": "将两个整数相加。\n\n参数：\na (int): 要相加的第一个数字。\nb (int): 要相加的第二个数字。\n\n返回：\nint: 两个数字的和。",
      "fr": "Ajoute deux nombres entiers ensemble.\n\nParamètres :\na (int) : Le premier nombre à ajouter.\nb (int) : Le deuxième nombre à ajouter.\n\nRenvoie :\nint : La somme des deux nombres.",
      "de": "Addiert zwei ganze Zahlen miteinander.\n\nParameter:\na (int): Die erste Zahl, die addiert werden soll.\nb (int): Die zweite Zahl, die addiert werden soll.\n\nRückgabewert:\nint: Die Summe der beiden Zahlen.",
      "ha": "Ƙara lambobi guda biyu na integer tare.\n\nSigogi:\na (int): Lambar farko da za a kara.\nb (int): Lambar biyu da za a kara.\n\nDawowa:\nint: Jimillar lambobin biyu.",
      "hi": "दो पूर्णांक संख्याओं को जोड़ता है।\n\nपैरामीटर्स:\na (int): जोड़ने के लिए पहली संख्या।\nb (int): जोड़ने के लिए दूसरी संख्या।\n\nवापसी:\nint: दोनों संख्याओं का योग।",
      "hu": "Két egész számot ad össze.\n\nParaméterek:\na (int): Az első szám, amelyet hozzáadunk.\nb (int): A második szám, amelyet hozzáadunk.\n\nVisszatér:\nint: A két szám összege."
    },
    "docstring_bertscore": {
      "sq": "0.9933258205668467",
      "hy": "0.9883328486787727",
      "bn": "0.9744793727534945",
      "bg": "0.9933258205668467",
      "zh": "0.9769688073190047",
      "fr": "0.9609339725492013",
      "de": "0.9821149232308566",
      "ha": "0.9744793727534945",
      "hi": "0.9567007618685858",
      "hu": "0.9582536541875165"
    }
  },
  {
    "task_id": "Python/7",
    "prompt": {
      "en": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "sq": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Gjen qilimin më të sipërm që mbulon një pikë të dhënë në planin koordinativ.\n\n    Args:\n    n (int): Numri total i qilimave.\n    carpets (list of tuples): Një listë që përmban n tufa, secila përfaqëson informacionin e një qilimi.\n                              Çdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\n                              koordinatat e këndit të poshtëm të majtë të qilimit dhe (g, k) janë\n                              gjatësitë e qilimit përgjatë boshtit x dhe y përkatësisht.\n    point (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\n    Returns:\n    int: Numri i qilimit më të sipërm që mbulon pikën (x, y), ose -1 nëse asnjë qilim nuk e mbulon atë.\n\n    Shembuj:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "hy": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Գտնում է տրված կետը ծածկող ամենավերին գորգը կոորդինատային հարթության վրա:\n\n    Արգումենտներ:\n    n (int): Գորգերի ընդհանուր քանակը:\n    carpets (list of tuples): Ցանկ, որը պարունակում է n թյուպլ, յուրաքանչյուրը ներկայացնում է գորգի մասին տեղեկություն:\n                              Յուրաքանչյուր թյուպլ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) \n                              գորգի ներքևի ձախ անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարություններն են \n                              համապատասխանաբար x և y առանցքների երկայնքով:\n    point (tuple): Թյուպլ, որը պարունակում է երկու ամբողջ թիվ (x, y), կոորդինատները այն կետի, որը պետք է ստուգել:\n\n    Վերադարձնում է:\n    int: Ամենավերին գորգի համարը, որը ծածկում է կետը (x, y), կամ -1, եթե ոչ մի գորգ չի ծածկում այն:\n\n    Օրինակներ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "bn": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    প্রদত্ত বিন্দুতে সমন্বয় সমতলে কোন কার্পেটটি সর্বোচ্চ অবস্থানে রয়েছে তা খুঁজে বের করে।\n\n    Args:\n    n (int): মোট কার্পেটের সংখ্যা।\n    carpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\n                              প্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল\n                              কার্পেটের নিচের-বাম কোণের স্থানাঙ্ক এবং (g, k) হল\n                              x এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\n    point (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, চেক করার জন্য বিন্দুর স্থানাঙ্ক।\n\n    Returns:\n    int: বিন্দু (x, y) কে আচ্ছাদনকারী সর্বোচ্চ কার্পেটের সংখ্যা, অথবা যদি কোন কার্পেট এটিকে আচ্ছাদন না করে তবে -1।\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "bg": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Намира най-горния килим, покриващ дадена точка в координатната равнина.\n\n    Аргументи:\n    n (int): Общият брой на килимите.\n    carpets (list of tuples): Списък, съдържащ n кортежа, всеки представляващ информация за килим.\n                              Всеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\n                              координатите на долния ляв ъгъл на килима и (g, k) са\n                              дължините на килима по оста x и y съответно.\n    point (tuple): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\n    Връща:\n    int: Номерът на най-горния килим, покриващ точката (x, y), или -1, ако няма килим, който да я покрива.\n\n    Примери:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "zh": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    查找覆盖坐标平面上给定点的最上层地毯。\n\n    参数:\n    n (int): 地毯的总数量。\n    carpets (list of tuples): 包含 n 个元组的列表，每个元组表示一个地毯的信息。\n                              每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，\n                              (g, k) 是地毯在 x 和 y 轴上的长度。\n    point (tuple): 包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n    返回:\n    int: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n    示例:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "fr": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\n    Args:\n    n (int): Le nombre total de tapis.\n    carpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\n                              Chaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont les\n                              coordonnées du coin inférieur gauche du tapis et (g, k) sont\n                              les longueurs du tapis le long de l'axe x et y respectivement.\n    point (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\n    Returns:\n    int: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "de": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\n    Args:\n    n (int): Die Gesamtanzahl der Teppiche.\n    carpets (list of tuples): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\n                              Jedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\n                              Koordinaten der unteren linken Ecke des Teppichs sind und (g, k) die\n                              Längen des Teppichs entlang der x- und y-Achse sind.\n    point (tuple): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\n    Returns:\n    int: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\n    Beispiele:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "ha": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Nemi tabarma mafi sama da ke rufe wani maki a kan tsarin daidaitawa.\n\n    Args:\n    n (int): Jimillar adadin tabarmai.\n    carpets (list of tuples): Jerin da ke dauke da n tuples, kowanne yana wakiltar bayanin tabarma.\n                              Kowanne tuple yana dauke da lambobi hudu (a, b, g, k) inda (a, b) suke\n                              daidaitawar kusurwar kasa-hagu na tabarma kuma (g, k) su ne\n                              tsawon tabarma a kan x da y axis bi da bi.\n    point (tuple): Tuple da ke dauke da lambobi biyu (x, y), daidaitawar maki da za a duba.\n\n    Returns:\n    int: Lambar tabarma mafi sama da ke rufe maki (x, y), ko -1 idan babu tabarma da ta rufe shi.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "hi": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    दिए गए बिंदु पर समन्वय तल पर कवर करने वाले सबसे ऊपरी कालीन को खोजता है।\n\n    Args:\n    n (int): कुल कालीनों की संख्या।\n    carpets (list of tuples): एक सूची जिसमें n ट्यूपल होते हैं, प्रत्येक एक कालीन की जानकारी का प्रतिनिधित्व करता है।\n                              प्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b)\n                              कालीन के निचले-बाएँ कोने के समन्वय होते हैं और (g, k) क्रमशः x और y अक्ष पर\n                              कालीन की लंबाई होती है।\n    point (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जाँचने के लिए बिंदु के समन्वय।\n\n    Returns:\n    int: सबसे ऊपरी कालीन की संख्या जो बिंदु (x, y) को कवर करता है, या -1 यदि कोई कालीन इसे कवर नहीं करता।\n\n    उदाहरण:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "hu": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Megkeresi a koordináta síkon egy adott pontot lefedő legfelső szőnyeget.\n\n    Args:\n    n (int): A szőnyegek teljes száma.\n    carpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információit képviseli.\n                              Minden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a\n                              szőnyeg bal alsó sarkának koordinátái, és (g, k) a szőnyeg hossza az x és y tengely mentén.\n    point (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a vizsgálandó pont koordinátái.\n\n    Returns:\n    int: Annak a legfelső szőnyegnek a száma, amely lefedi az (x, y) pontot, vagy -1, ha egyetlen szőnyeg sem fedi le.\n\n    Példák:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9861937981054081",
      "hy": "0.9822211904847102",
      "bn": "0.9684487557548942",
      "bg": "0.9898895149749432",
      "zh": "0.974362776719827",
      "fr": "0.9946554523374943",
      "de": "0.9881934101512863",
      "ha": "0.9771982254091001",
      "hi": "0.9860615102716388",
      "hu": "0.9808742778709126"
    },
    "canonical_solution": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point",
    "instruction": {
      "en": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nԱպահովեք հակիրճ բնութագրություն (docstring) Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nBada takaitaccen bayanin harshen halitta (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9084617847912149",
      "bn": "0.8958006870432891",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9217489655001627",
      "hi": "0.8869427652010382",
      "hu": "0.9429881148834612"
    },
    "level": "",
    "test": "def check_find_topmost_carpet():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\n\n# Run the test cases to ensure the function works as expected\ncheck_find_topmost_carpet()",
    "entry_point": "find_topmost_carpet",
    "signature": "def find_topmost_carpet(n, carpets, point) -> int:",
    "docstring": {
      "en": "Finds the topmost carpet covering a given point on the coordinate plane.\n\nArgs:\nn (int): The total number of carpets.\ncarpets (list of tuples): A list containing n tuples, each representing a carpet's information.\nEach tuple contains four integers (a, b, g, k) where (a, b) is the\ncoordinates of the bottom-left corner of the carpet and (g, k) are\nthe lengths of the carpet along the x and y axis respectively.\npoint (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\nReturns:\nint: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "sq": "Gjen qilimin më të sipërm që mbulon një pikë të dhënë në planin e koordinatave.\n\nArgumentet:\nn (int): Numri total i qilimave.\ncarpets (list of tuples): Një listë që përmban n tufa, secila që përfaqëson informacionin e një qilimi.\nÇdo tufë përmban katër numra të plotë (a, b, g, k) ku (a, b) janë\nkoordinatat e këndit të poshtëm të majtë të qilimit dhe (g, k) janë\ngjatësitë e qilimit përgjatë boshtit x dhe y përkatësisht.\npoint (tuple): Një tufë që përmban dy numra të plotë (x, y), koordinatat e pikës për të kontrolluar.\n\nKthen:\nint: Numri i qilimit më të sipërm që mbulon pikën (x, y), ose -1 nëse asnjë qilim nuk e mbulon atë.\n\nShembuj:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "hy": "Գտնում է տրված կետի վրա գտնվող ամենավերին գորգը կոորդինատների հարթության վրա:\n\nԱրգումենտներ:\nn (int): Գորգերի ընդհանուր քանակը:\ncarpets (ցանկ տուփլերի): Ցանկ, որը պարունակում է n տուփլեր, որոնցից յուրաքանչյուրը ներկայացնում է գորգի մասին տեղեկատվությունը:\nՅուրաքանչյուր տուփլ պարունակում է չորս ամբողջ թիվ (a, b, g, k), որտեղ (a, b) գորգի ձախ-ստորին անկյունի կոորդինատներն են, իսկ (g, k) գորգի երկարություններն են x և y առանցքների երկայնքով:\npoint (տուփլ): Տուփլ, որը պարունակում է երկու ամբողջ թիվ (x, y), կոորդինատները կետի, որը պետք է ստուգել:\n\nՎերադարձնում է:\nint: Ամենավերին գորգի համարը, որը ծածկում է կետը (x, y), կամ -1, եթե ոչ մի գորգ չի ծածկում այն:\n\nՕրինակներ:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "bn": "একটি নির্দিষ্ট বিন্দুতে সমন্বয় সমতলে আবৃত শীর্ষস্থানীয় কার্পেট খুঁজে বের করে।\n\nআর্গস:\nn (int): মোট কার্পেটের সংখ্যা।\ncarpets (list of tuples): একটি তালিকা যা n টুপল ধারণ করে, প্রতিটি টুপল একটি কার্পেটের তথ্য উপস্থাপন করে।\nপ্রতিটি টুপলে চারটি পূর্ণসংখ্যা (a, b, g, k) থাকে যেখানে (a, b) হল\nকার্পেটের নিচের-বাম কোণের স্থানাঙ্ক এবং (g, k) হল\nx এবং y অক্ষ বরাবর কার্পেটের দৈর্ঘ্য।\npoint (tuple): একটি টুপল যা দুটি পূর্ণসংখ্যা (x, y) ধারণ করে, যাচাই করার বিন্দুর স্থানাঙ্ক।\n\nরিটার্নস:\nint: বিন্দু (x, y) আবৃত শীর্ষস্থানীয় কার্পেটের সংখ্যা, অথবা -1 যদি কোনো কার্পেট এটি আবৃত না করে।\n\nউদাহরণ:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "bg": "Намира най-горния килим, покриващ дадена точка на координатната равнина.\n\nАргументи:\nn (int): Общият брой на килимите.\ncarpets (списък от кортежи): Списък, съдържащ n кортежа, всеки представляващ информация за килим.\nВсеки кортеж съдържа четири цели числа (a, b, g, k), където (a, b) са\nкоординатите на долния ляв ъгъл на килима и (g, k) са\nдължините на килима по оста x и y съответно.\npoint (кортеж): Кортеж, съдържащ две цели числа (x, y), координатите на точката за проверка.\n\nВръща:\nint: Номера на най-горния килим, покриващ точката (x, y), или -1 ако няма килим, който да я покрива.\n\nПримери:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "zh": "在坐标平面上找到覆盖给定点的最上层地毯。\n\n参数：\nn (int): 地毯的总数量。\ncarpets (list of tuples): 包含 n 个元组的列表，每个元组代表一个地毯的信息。\n每个元组包含四个整数 (a, b, g, k)，其中 (a, b) 是地毯左下角的坐标，(g, k) 是地毯在 x 和 y 轴上的长度。\npoint (tuple): 一个包含两个整数 (x, y) 的元组，要检查的点的坐标。\n\n返回：\nint: 覆盖点 (x, y) 的最上层地毯的编号，如果没有地毯覆盖该点，则返回 -1。\n\n示例：\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "fr": "Trouve le tapis le plus haut couvrant un point donné sur le plan de coordonnées.\n\nArgs:\nn (int): Le nombre total de tapis.\ncarpets (list of tuples): Une liste contenant n tuples, chacun représentant les informations d'un tapis.\nChaque tuple contient quatre entiers (a, b, g, k) où (a, b) sont les\ncoordonnées du coin inférieur gauche du tapis et (g, k) sont\nles longueurs du tapis le long de l'axe x et y respectivement.\npoint (tuple): Un tuple contenant deux entiers (x, y), les coordonnées du point à vérifier.\n\nReturns:\nint: Le numéro du tapis le plus haut couvrant le point (x, y), ou -1 si aucun tapis ne le couvre.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "de": "Findet den obersten Teppich, der einen gegebenen Punkt auf der Koordinatenebene bedeckt.\n\nArgs:\nn (int): Die Gesamtanzahl der Teppiche.\ncarpets (list of tuples): Eine Liste, die n Tupel enthält, von denen jedes die Informationen eines Teppichs darstellt.\nJedes Tupel enthält vier ganze Zahlen (a, b, g, k), wobei (a, b) die\nKoordinaten der unteren linken Ecke des Teppichs sind und (g, k) die\nLängen des Teppichs entlang der x- und y-Achse sind.\npoint (tuple): Ein Tupel, das zwei ganze Zahlen (x, y) enthält, die Koordinaten des zu überprüfenden Punktes.\n\nReturns:\nint: Die Nummer des obersten Teppichs, der den Punkt (x, y) bedeckt, oder -1, wenn kein Teppich ihn bedeckt.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "ha": "Nemi tabarma mafi sama da ke rufe wani maki a kan tsarin daidaitawa.\n\nArgs:\nn (int): Jimillar adadin kafet.\ncarpets (list of tuples): Jerin da ke dauke da n tuples, kowanne yana wakiltar bayanin kafet.\nKowane tuple yana dauke da lambobi hudu (a, b, g, k) inda (a, b) suke\ndaidaitawar kusurwar kasa-hagu na kafet kuma (g, k) sune\ntsawon kafet a kan x da y axis bi da bi.\npoint (tuple): Tuple da ke dauke da lambobi biyu (x, y), daidaitawar wurin da za a duba.\n\nReturns:\nint: Lambar kafet mafi sama da ke rufe wurin (x, y), ko -1 idan babu kafet da ke rufe shi.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "hi": "दिए गए बिंदु पर निर्देशांक तल पर सबसे ऊपर की कालीन को ढूंढता है।\n\nआर्ग्स:\nn (int): कालीनों की कुल संख्या।\ncarpets (list of tuples): n ट्यूपल्स की एक सूची, जिसमें प्रत्येक ट्यूपल एक कालीन की जानकारी का प्रतिनिधित्व करता है।\nप्रत्येक ट्यूपल में चार पूर्णांक (a, b, g, k) होते हैं जहाँ (a, b)\nकालीन के निचले-बाएँ कोने के निर्देशांक हैं और (g, k) क्रमशः x और y अक्ष के साथ कालीन की लंबाई है।\npoint (tuple): एक ट्यूपल जिसमें दो पूर्णांक (x, y) होते हैं, जाँचने के लिए बिंदु के निर्देशांक।\n\nवापसी:\nint: सबसे ऊपर की कालीन की संख्या जो बिंदु (x, y) को ढकती है, या -1 यदि कोई कालीन इसे नहीं ढकती।\n\nउदाहरण:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "hu": "Megkeresi a legfelső szőnyeget, amely lefedi a megadott pontot a koordináta síkon.\n\nArgs:\nn (int): A szőnyegek teljes száma.\ncarpets (list of tuples): Egy lista, amely n darab tuple-t tartalmaz, mindegyik egy szőnyeg információit képviseli.\nMinden tuple négy egész számot tartalmaz (a, b, g, k), ahol (a, b) a szőnyeg bal alsó sarkának\nkoordinátái, és (g, k) a szőnyeg hosszai az x és y tengely mentén.\npoint (tuple): Egy tuple, amely két egész számot tartalmaz (x, y), a pont koordinátái, amelyet ellenőrizni kell.\n\nReturns:\nint: A legfelső szőnyeg száma, amely lefedi a pontot (x, y), vagy -1, ha egyetlen szőnyeg sem fedi le.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1"
    },
    "docstring_bertscore": {
      "sq": "0.9801903934690096",
      "hy": "0.9625454608305374",
      "bn": "0.9841548572440849",
      "bg": "0.9829606913933031",
      "zh": "0.9647154977433435",
      "fr": "0.9927462171149869",
      "de": "0.9807753599411573",
      "ha": "0.9831493902552862",
      "hi": "0.972176452115776",
      "hu": "0.9808951340609213"
    }
  },
  {
    "task_id": "Python/8",
    "prompt": {
      "en": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "sq": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Llogarit shumën maksimale të vlerave të mbledhura në dy shtigje në një rrjetë N x N.\n\n    Kjo funksion përdor programimin dinamik për të gjetur dy shtigje nga këndi i sipërm i majtë\n    deri në këndin e poshtëm të djathtë të rrjetës që maksimizojnë shumën e vlerave të mbledhura. \n    Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dy shtigjet kalojnë përmes saj.\n\n    Argumentet:\n    - N (int): Madhësia e rrjetës (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\n      koordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjetë në atë pozicion.\n      Lista përfundon me një tuple me të gjitha zerot.\n\n    Kthen:\n    - int: Shuma maksimale e vlerave të mbledhura në dy shtigjet.\n\n    Shembuj:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "hy": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Հաշվել արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիներով N x N ցանցում:\n\n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղիներ ցանցի վերին ձախ անկյունից\n    ցանցի ներքևի աջ անկյուն, որոնք առավելագույնացնում են հավաքված արժեքների գումարը: Յուրաքանչյուր\n    արժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն անցնում են դրա միջով:\n\n    Արգումենտներ:\n    - N (int): Ցանցի չափը (N x N):\n    - grid_values (List[Tuple[int, int, int]]): Կոորդինատների և արժեքների ցուցակ, որտեղ յուրաքանչյուր տուփ\n      պարունակում է x-կոորդինատը, y-կոորդինատը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում:\n      Ցուցակը ավարտվում է զրոներով տուփով:\n\n    Վերադարձնում է:\n    - int: Երկու ուղիներով հավաքված արժեքների առավելագույն գումարը:\n\n    Օրինակներ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "bn": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    একটি N x N গ্রিডে দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\n    এই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে\n    নীচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফল সর্বাধিক করে। প্রতিটি\n    মান সর্বাধিক একবার সংগৃহীত হতে পারে, এমনকি যদি উভয় পথ এর মধ্য দিয়ে যায়।\n\n    আর্গুমেন্টসমূহ:\n    - N (int): গ্রিডের আকার (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে\n      গ্রিডের নির্দিষ্ট স্থানে স্থাপন করার জন্য x-সমন্বয়, y-সমন্বয় এবং মান থাকে।\n      তালিকাটি সব শূন্য সহ একটি টুপল দ্বারা শেষ হয়।\n\n    রিটার্নস:\n    - int: দুটি পথে সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\n    উদাহরণসমূহ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "bg": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Изчислете максималната сума от стойности, събрани по два пътя в мрежа N x N.\n\n    Тази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл до\n    долния десен ъгъл на мрежата, които максимизират сумата на събраните стойности. Всяка\n    стойност може да бъде събрана най-много веднъж, дори ако и двата пътя минават през нея.\n\n    Аргументи:\n    - N (int): Размерът на мрежата (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\n      x-координата, y-координата и стойност, която да бъде поставена на мрежата на тази позиция.\n      Списъкът се завършва с кортеж с всички нули.\n\n    Връща:\n    - int: Максималната сума от стойности, събрани по двата пътя.\n\n    Примери:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "zh": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    计算在 N x N 网格上收集的两个路径的最大值总和。\n\n    此函数利用动态规划来找到从网格左上角到右下角的两条路径，\n    以最大化收集的值的总和。即使两条路径经过同一个位置，每个值最多只能被收集一次。\n\n    参数:\n    - N (int): 网格的大小 (N x N)。\n    - grid_values (List[Tuple[int, int, int]]): 一个元组的列表，每个元组包含\n      x 坐标、y 坐标，以及在该位置放置在网格上的值。\n      列表以一个全为零的元组结束。\n\n    返回:\n    - int: 在两条路径上收集的值的最大总和。\n\n    示例:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "fr": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\n    Cette fonction utilise la programmation dynamique pour trouver deux chemins du coin supérieur gauche\n    au coin inférieur droit de la grille qui maximisent la somme des valeurs collectées. Chaque\n    valeur peut être collectée au plus une fois, même si les deux chemins la traversent.\n\n    Arguments:\n    - N (int) : La taille de la grille (N x N).\n    - grid_values (List[Tuple[int, int, int]]) : Une liste de tuples où chaque tuple contient\n      la coordonnée x, la coordonnée y, et la valeur à placer sur la grille à cette position.\n      La liste est terminée par un tuple avec tous les zéros.\n\n    Retourne:\n    - int : La somme maximale des valeurs collectées sur les deux chemins.\n\n    Exemples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "de": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Berechne die maximale Summe der gesammelten Werte auf zwei Pfaden in einem N x N Raster.\n\n    Diese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken\n    Eckpunkt zum unteren rechten Eckpunkt des Rasters zu finden, die die Summe der gesammelten\n    Werte maximieren. Jeder Wert kann höchstens einmal gesammelt werden, selbst wenn beide\n    Pfade ihn durchqueren.\n\n    Argumente:\n    - N (int): Die Größe des Rasters (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die\n      x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position auf das Raster\n      gesetzt werden soll. Die Liste wird durch ein Tupel mit lauter Nullen beendet.\n\n    Rückgabewert:\n    - int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\n    Beispiele:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "ha": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Lissafi mafi girman jimlar ƙimomi da aka tattara a kan hanyoyi biyu a cikin grid ɗin N x N.\n\n    Wannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman-hagu zuwa\n    ƙasan-dama na grid ɗin wanda ke haɓaka jimlar ƙimomin da aka tattara. Kowace\n    ƙima za a iya tattarawa sau ɗaya kawai, ko da kuwa duk hanyoyin sun wuce ta cikinta.\n\n    Args:\n    - N (int): Girman grid ɗin (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple ke ɗauke da\n      x-coordinate, y-coordinate, da ƙima da za a sanya a kan grid a wannan matsayi.\n      Jerin yana ƙarewa da tuple tare da duk sifili.\n\n    Returns:\n    - int: Mafi girman jimlar ƙimomi da aka tattara a kan hanyoyi biyu.\n\n    Misalai:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "hi": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    एक N x N ग्रिड में दो पथों पर एकत्रित मूल्यों के अधिकतम योग की गणना करें।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके ग्रिड के शीर्ष-बाएँ कोने से\n    निचले-दाएँ कोने तक दो पथों को खोजता है जो एकत्रित मूल्यों के योग को अधिकतम करते हैं। प्रत्येक\n    मूल्य को अधिकतम एक बार एकत्रित किया जा सकता है, भले ही दोनों पथ इसके माध्यम से गुजरें।\n\n    तर्क:\n    - N (int): ग्रिड का आकार (N x N)।\n    - grid_values (List[Tuple[int, int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में\n      x-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखे जाने वाले मूल्य होते हैं।\n      सूची एक ट्यूपल के साथ समाप्त होती है जिसमें सभी शून्य होते हैं।\n\n    लौटाता है:\n    - int: दो पथों पर एकत्रित मूल्यों का अधिकतम योग।\n\n    उदाहरण:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "hu": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a maximális összegét az értékeknek, amelyeket két útvonalon gyűjtünk össze egy N x N-es rácson.\n\n    Ez a függvény dinamikus programozást használ annak érdekében, hogy megtalálja a rács bal felső sarkából\n    a jobb alsó sarokba vezető két útvonalat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden\n    érték legfeljebb egyszer gyűjthető össze, még akkor is, ha mindkét útvonal áthalad rajta.\n\n    Argumentumok:\n    - N (int): A rács mérete (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Egy listája a tuple-öknek, ahol minden tuple tartalmazza\n      az x-koordinátát, y-koordinátát, és az értéket, amelyet a rács adott pozíciójára kell helyezni.\n      A lista egy minden eleme nulla tuple-lel zárul.\n\n    Visszatér:\n    - int: A két útvonalon összegyűjtött értékek maximális összege.\n\n    Példák:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9802039003349199",
      "hy": "0.9769088209439322",
      "bn": "0.9781170895517673",
      "bg": "0.985840633287928",
      "zh": "0.9536420526310295",
      "fr": "0.981195065936284",
      "de": "0.9809586957828526",
      "ha": "0.9705917789358797",
      "hi": "0.985715496147876",
      "hu": "0.9791974401942162"
    },
    "canonical_solution": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]",
    "instruction": {
      "en": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nՏրամադրել կարճ բնութագիր (docstring) այս Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nBayar da taƙaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nदिए गए Python कोड का एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8830128631122629",
      "bn": "0.8713540542670392",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9404883515381371",
      "hi": "0.91110952777041",
      "hu": "0.9429881148834612"
    },
    "level": "",
    "test": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()",
    "entry_point": "max_value_on_paths",
    "signature": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:",
    "docstring": {
      "en": "Calculate the maximum sum of values collected on two paths in an N x N grid.\n\nThis function utilizes dynamic programming to find two paths from the top-left corner to\nthe bottom-right corner of the grid which maximize the sum of the values collected. Each\nvalue can be collected at most once, even if both paths pass through it.\n\nArgs:\n- N (int): The size of the grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\nthe x-coordinate, y-coordinate, and value to be placed on the grid at that position.\nThe list is terminated by a tuple with all zeros.\n\nReturns:\n- int: The maximum sum of values collected on the two paths.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "sq": "Llogarit shumën maksimale të vlerave të mbledhura në dy rrugë në një rrjetë N x N.\n\nKjo funksion përdor programimin dinamik për të gjetur dy rrugë nga këndi i sipërm i majtë deri në këndin e poshtëm të djathtë të rrjetës që maksimizojnë shumën e vlerave të mbledhura. Çdo vlerë mund të mblidhet maksimumi një herë, edhe nëse të dyja rrugët kalojnë nëpër të.\n\nArgumentet:\n- N (int): Madhësia e rrjetës (N x N).\n- grid_values (List[Tuple[int, int, int]]): Një listë tuples ku çdo tuple përmban\nkoordinatën x, koordinatën y, dhe vlerën që do të vendoset në rrjetë në atë pozicion.\nLista përfundon me një tuple me të gjitha zerot.\n\nKthen:\n- int: Shuma maksimale e vlerave të mbledhura në dy rrugët.\n\nShembuj:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "hy": "Հաշվարկել արժեքների առավելագույն գումարը, որը հավաքվում է երկու ուղիների վրա N x N ցանցում:\n\nԱյս ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ գտնելու համար երկու ուղի ցանցի վերին ձախ անկյունից դեպի\nցանցի ներքևի աջ անկյունը, որոնք առավելագույնի են հասցնում հավաքված արժեքների գումարը։ Յուրաքանչյուր\nարժեք կարող է հավաքվել առավելագույնը մեկ անգամ, նույնիսկ եթե երկու ուղիներն անցնում են դրա միջով։\n\nԱրգումենտներ:\n- N (int): Ցանցի չափը (N x N)։\n- grid_values (List[Tuple[int, int, int]]): Թվերի ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է\nx-կոորդինատը, y-կոորդինատը և արժեքը, որը պետք է տեղադրվի ցանցում այդ դիրքում։\nՑուցակը ավարտվում է զրոներով տուփով։\n\nՎերադարձնում է:\n- int: Երկու ուղիների վրա հավաքված արժեքների առավելագույն գումարը։\n\nՕրինակներ:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "bn": "N x N গ্রিডে দুটি পথের উপর সংগৃহীত মানগুলির সর্বাধিক যোগফল গণনা করুন।\n\nএই ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে গ্রিডের উপরের-বাম কোণ থেকে\nনিচের-ডান কোণে দুটি পথ খুঁজে বের করে যা সংগৃহীত মানগুলির যোগফল সর্বাধিক করে। প্রতিটি\nমান সর্বাধিক একবার সংগৃহীত হতে পারে, এমনকি যদি উভয় পথ এর মধ্য দিয়ে যায়।\n\nআর্গস:\n- N (int): গ্রিডের আকার (N x N)।\n- grid_values (List[Tuple[int, int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপলে\nগ্রিডের নির্দিষ্ট অবস্থানে স্থাপন করার জন্য x-সমন্বয়, y-সমন্বয়, এবং মান থাকে।\nতালিকাটি সব শূন্য সহ একটি টুপল দ্বারা শেষ হয়।\n\nরিটার্নস:\n- int: দুটি পথের উপর সংগৃহীত মানগুলির সর্বাধিক যোগফল।\n\nউদাহরণ:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "bg": "Изчисляване на максималната сума от стойности, събрани по два пътя в мрежа N x N.\n\nТази функция използва динамично програмиране, за да намери два пътя от горния ляв ъгъл до долния десен ъгъл на мрежата, които максимизират сумата от събраните стойности. Всяка стойност може да бъде събрана най-много веднъж, дори ако и двата пътя минават през нея.\n\nАргументи:\n- N (int): Размерът на мрежата (N x N).\n- grid_values (List[Tuple[int, int, int]]): Списък от кортежи, където всеки кортеж съдържа\nx-координата, y-координата и стойност, която да бъде поставена на мрежата на тази позиция.\nСписъкът е завършен с кортеж с всички нули.\n\nВръща:\n- int: Максималната сума от стойности, събрани по двата пътя.\n\nПримери:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "zh": "计算在一个 N x N 网格中两条路径上收集的最大值总和。\n\n此函数利用动态规划在网格中找到从左上角到右下角的两条路径，以最大化收集的值总和。即使两条路径经过同一个位置，每个值最多只能被收集一次。\n\n参数:\n- N (int): 网格的大小 (N x N)。\n- grid_values (List[Tuple[int, int, int]]): 一个元组列表，其中每个元组包含网格中某个位置的 x 坐标、y 坐标和要放置的值。列表以一个全为零的元组结束。\n\n返回:\n- int: 在两条路径上收集的最大值总和。\n\n示例:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "fr": "Calculer la somme maximale des valeurs collectées sur deux chemins dans une grille N x N.\n\nCette fonction utilise la programmation dynamique pour trouver deux chemins du coin supérieur gauche au coin inférieur droit de la grille qui maximisent la somme des valeurs collectées. Chaque valeur peut être collectée au plus une fois, même si les deux chemins la traversent.\n\nArgs:\n- N (int): La taille de la grille (N x N).\n- grid_values (List[Tuple[int, int, int]]): Une liste de tuples où chaque tuple contient\nles coordonnées x, y, et la valeur à placer sur la grille à cette position.\nLa liste est terminée par un tuple avec tous les zéros.\n\nReturns:\n- int: La somme maximale des valeurs collectées sur les deux chemins.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "de": "Berechne die maximale Summe der Werte, die auf zwei Pfaden in einem N x N Raster gesammelt werden.\n\nDiese Funktion verwendet dynamische Programmierung, um zwei Pfade vom oberen linken Eckpunkt zum unteren rechten Eckpunkt des Rasters zu finden, die die Summe der gesammelten Werte maximieren. Jeder Wert kann höchstens einmal gesammelt werden, selbst wenn beide Pfade ihn durchqueren.\n\nArgumente:\n- N (int): Die Größe des Rasters (N x N).\n- grid_values (List[Tuple[int, int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die x-Koordinate, y-Koordinate und den Wert enthält, der an dieser Position im Raster platziert werden soll. Die Liste endet mit einem Tupel, das nur Nullen enthält.\n\nRückgabewert:\n- int: Die maximale Summe der auf den beiden Pfaden gesammelten Werte.\n\nBeispiele:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "ha": "Lissafi mafi girman jimlar ƙimomi da aka tattara a kan hanyoyi biyu a cikin grid ɗin N x N.\n\nWannan aikin yana amfani da shirye-shiryen motsi don nemo hanyoyi biyu daga saman hagu zuwa\nƙasan dama na grid wanda ke ƙara yawan adadin ƙimomin da aka tattara. Kowace\nƙima za a iya tattara ta sau ɗaya kawai, ko da kuwa duka hanyoyin sun wuce ta.\n\nArgs:\n- N (int): Girman grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): Jerin tuples inda kowanne tuple yana dauke da\nx-coordinate, y-coordinate, da ƙima da za a sanya akan grid a wannan matsayi.\nJerin yana ƙarewa da tuple tare da duk sifili.\n\nReturns:\n- int: Mafi girman adadin ƙimomin da aka tattara akan hanyoyi biyu.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "hi": "एक N x N ग्रिड में दो पथों पर एकत्रित मूल्यों के अधिकतम योग की गणना करें।\n\nयह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करता है ताकि ग्रिड के शीर्ष-बाएँ कोने से\nग्रिड के निचले-दाएँ कोने तक दो रास्ते खोजे जा सकें जो एकत्रित मूल्यों के योग को अधिकतम करें। प्रत्येक\nमूल्य को अधिकतम एक बार एकत्र किया जा सकता है, भले ही दोनों रास्ते इसके माध्यम से गुजरें।\n\nआर्ग्स:\n- N (int): ग्रिड का आकार (N x N)।\n- grid_values (List[Tuple[int, int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में\nx-निर्देशांक, y-निर्देशांक, और उस स्थिति पर ग्रिड पर रखे जाने वाले मूल्य होते हैं।\nसूची को सभी शून्य वाले ट्यूपल द्वारा समाप्त किया जाता है।\n\nरिटर्न्स:\n- int: दो रास्तों पर एकत्रित मूल्यों का अधिकतम योग।\n\nउदाहरण:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "hu": "Számítsa ki az összegyűjtött értékek maximális összegét két útvonalon egy N x N rácsban.\n\nEz a függvény dinamikus programozást alkalmaz, hogy megtalálja a rács bal felső sarkából a jobb alsó sarkába vezető két útvonalat, amelyek maximalizálják az összegyűjtött értékek összegét. Minden érték legfeljebb egyszer gyűjthető össze, még akkor is, ha mindkét útvonal áthalad rajta.\n\nArgok:\n- N (int): A rács mérete (N x N).\n- grid_values (List[Tuple[int, int, int]]): Egy listája a hármasoknak, ahol minden hármas tartalmazza az x-koordinátát, y-koordinátát és az értéket, amelyet a rács adott pozíciójára kell helyezni. A listát egy minden nullát tartalmazó hármas zárja le.\n\nVisszatér:\n- int: Az összegyűjtött értékek maximális összege a két útvonalon.\n\nPéldák:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67"
    },
    "docstring_bertscore": {
      "sq": "0.9665734863275438",
      "hy": "0.9806837913355002",
      "bn": "0.9834246919634007",
      "bg": "0.9852574544892095",
      "zh": "0.9715491773724678",
      "fr": "0.9733618782297921",
      "de": "0.9794608240794684",
      "ha": "0.9634541948237719",
      "hi": "0.9896803571837134",
      "hu": "0.9821890123629826"
    }
  },
  {
    "task_id": "Python/9",
    "prompt": {
      "en": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "sq": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Gjenero të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\n    në mënyrë që numri i dytë të jetë dy herë i pari dhe i treti të jetë tre herë i pari.\n\n    Kthen:\n        list of tuples: Një listë e renditur e tupleve, ku secila tuple përmban tre numra të plotë që përfaqësojnë\n                        kombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\n    Shembull:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "hy": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Գեներացնել երեք թվերի բոլոր եզակի կոմբինացիաները, որոնցից յուրաքանչյուրը կազմված է 1-ից 9 թվանշաններից առանց կրկնության,\n    այնպես, որ երկրորդ թիվը լինի առաջինի կրկնապատիկը, իսկ երրորդը՝ առաջինի եռապատիկը:\n\n    Վերադարձնում է:\n        list of tuples: Կարգավորված tuples-ի ցուցակ, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թվեր,\n                        որոնք ներկայացնում են վավեր թվային կոմբինացիաները աճման կարգով՝ հիմնված առաջին թվի վրա:\n\n    Օրինակ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "bn": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    ১ থেকে ৯ পর্যন্ত অঙ্কগুলি থেকে পুনরাবৃত্তি ছাড়াই গঠিত তিনটি সংখ্যার সমস্ত অনন্য সংমিশ্রণ তৈরি করুন,\n    যাতে দ্বিতীয় সংখ্যা প্রথমটির দ্বিগুণ এবং তৃতীয়টি প্রথমটির তিনগুণ হয়।\n\n    রিটার্ন:\n        তালিকা টাপলসের: একটি সাজানো টাপলসের তালিকা, যেখানে প্রতিটি টাপল তিনটি পূর্ণসংখ্যা ধারণ করে যা \n                        প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যা সংমিশ্রণ উপস্থাপন করে।\n\n    উদাহরণ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "bg": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Генерира всички уникални комбинации от три числа, всяко от които е съставено от цифрите от 1 до 9 без повторение,\n    така че второто число да е два пъти първото, а третото да е три пъти първото.\n\n    Връща:\n        списък от кортежи: Сортиран списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи\n                           валидните числови комбинации във възходящ ред спрямо първото число.\n\n    Пример:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "zh": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    生成所有由1到9的数字组成的三个数字的唯一组合，每个数字不重复，\n    使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n    返回:\n        list of tuples: 一个排序的元组列表，其中每个元组包含三个整数，\n                        代表根据第一个数字升序排列的有效数字组合。\n\n    示例:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "fr": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres 1 à 9 sans répétition,\n    de telle sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\n    Retourne:\n        liste de tuples : Une liste triée de tuples, où chaque tuple contient trois entiers représentant les\n                          combinaisons de nombres valides dans l'ordre croissant basé sur le premier nombre.\n\n    Exemple:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "de": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Erzeuge alle eindeutigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden,\n    sodass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\n    Rückgabe:\n        Liste von Tupeln: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die\n                          gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\n    Beispiel:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "ha": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Samar da dukkan haɗe-haɗe na musamman na lambobi uku, kowanne an kafa shi daga lambobin 1 zuwa 9 ba tare da maimaitawa ba,\n    ta yadda lamba ta biyu sau biyu ce ta farko kuma ta uku sau uku ce ta farko.\n\n    Komawa:\n        jerin tuples: Jerin tuples da aka tsara, inda kowanne tuple ya ƙunshi lambobi uku da ke wakiltar\n                      ingantattun haɗe-haɗe na lambobi a cikin tsari mai tashi dangane da lamba ta farko.\n\n    Misali:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "hi": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    अंक 1 से 9 तक से बिना पुनरावृत्ति के बने तीन अंकों के सभी अद्वितीय संयोजनों को उत्पन्न करें,\n    ताकि दूसरा अंक पहले का दोगुना हो और तीसरा अंक पहले का तीन गुना हो।\n\n    वापसी:\n        list of tuples: एक क्रमबद्ध सूची जो tuples को शामिल करती है, जहाँ प्रत्येक tuple तीन पूर्णांकों को दर्शाता है\n                        जो पहले अंक के आधार पर आरोही क्रम में मान्य संख्या संयोजन हैं।\n\n    उदाहरण:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "hu": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generálja az összes egyedi kombinációját három számnak, amelyeket az 1-től 9-ig terjedő számjegyekből képeznek ismétlés nélkül,\n    úgy, hogy a második szám kétszerese az elsőnek, és a harmadik háromszorosa az elsőnek.\n\n    Visszatér:\n        list of tuples: Egy rendezett lista a tuple-ökről, ahol minden tuple három egész számot tartalmaz, amelyek\n                        érvényes számsorozatokat képviselnek növekvő sorrendben az első szám alapján.\n\n    Példa:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9909339135184246",
      "hy": "0.965549546713309",
      "bn": "0.9669282401880721",
      "bg": "0.9735321044663391",
      "zh": "0.9562081585236193",
      "fr": "0.9903070360358784",
      "de": "0.9890083906046724",
      "ha": "0.98122883310106",
      "hi": "0.9459584336014569",
      "hu": "0.9799397219281435"
    },
    "canonical_solution": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])",
    "instruction": {
      "en": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8653907729676097",
      "bn": "0.9232406796617347",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9404883515381371",
      "hi": "0.91110952777041",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_find_number_combinations():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")",
    "entry_point": "find_number_combinations",
    "signature": "def find_number_combinations():",
    "docstring": {
      "en": "Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\nsuch that the second number is twice the first and the third is three times the first.\n\nReturns:\nlist of tuples: A sorted list of tuples, where each tuple contains three integers representing the\nvalid number combinations in ascending order based on the first number.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "sq": "Gjeneroni të gjitha kombinimet unike të tre numrave, secili i formuar nga shifrat 1 deri në 9 pa përsëritje,\ntë tilla që numri i dytë është dy herë i pari dhe i treti është tre herë i pari.\n\nKthen:\nlist of tuples: Një listë e renditur tuples, ku secili tuple përmban tre numra të plotë që përfaqësojnë\nkombinimet e vlefshme të numrave në rend rritës bazuar në numrin e parë.\n\nShembull:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "hy": "Գեներացնել երեք թվերի բոլոր եզակի համակցությունները, որոնցից յուրաքանչյուրը կազմված է 1-ից 9 թվանշաններից առանց կրկնության, այնպես, որ երկրորդ թիվը առաջինի կրկնապատիկն է, իսկ երրորդը՝ առաջինի եռապատիկը:\n\nՎերադարձնում է:\nցանկ(tuple-ների): Դասավորված ցանկ tuple-ների, որտեղ յուրաքանչյուր tuple պարունակում է երեք ամբողջ թիվ, որոնք ներկայացնում են վավեր թվային համակցությունները աճման կարգով՝ հիմնված առաջին թվի վրա:\n\nՕրինակ:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "bn": "তিনটি সংখ্যার সমস্ত অনন্য সংমিশ্রণ তৈরি করুন, প্রতিটি 1 থেকে 9 পর্যন্ত অঙ্ক থেকে পুনরাবৃত্তি ছাড়া গঠিত,\nযাতে দ্বিতীয় সংখ্যা প্রথম সংখ্যার দ্বিগুণ এবং তৃতীয়টি প্রথম সংখ্যার তিনগুণ হয়।\n\nপ্রত্যাবর্তন:\nlist of tuples: একটি সাজানো টুপলের তালিকা, যেখানে প্রতিটি টুপলে তিনটি পূর্ণসংখ্যা থাকে যা প্রথম সংখ্যার উপর ভিত্তি করে ক্রমবর্ধমান ক্রমে বৈধ সংখ্যা সংমিশ্রণগুলি উপস্থাপন করে।\n\nউদাহরণ:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "bg": "Генерира всички уникални комбинации от три числа, всяко образувано от цифрите от 1 до 9 без повторение, така че второто число да е два пъти първото, а третото да е три пъти първото.\n\nВръща:\nсписък от кортежи: Сортиран списък от кортежи, където всеки кортеж съдържа три цели числа, представляващи валидните комбинации от числа във възходящ ред на базата на първото число.\n\nПример:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "zh": "生成所有由数字1到9组成的三个数字的唯一组合，且不重复，\n使得第二个数字是第一个数字的两倍，第三个数字是第一个数字的三倍。\n\n返回：\nlist of tuples: 一个排序后的元组列表，其中每个元组包含三个整数，表示基于第一个数字按升序排列的有效数字组合。\n\n示例：\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "fr": "Générer toutes les combinaisons uniques de trois nombres, chacun formé à partir des chiffres de 1 à 9 sans répétition, de telle sorte que le deuxième nombre soit le double du premier et le troisième soit le triple du premier.\n\nRenvoie :\nliste de tuples : Une liste triée de tuples, où chaque tuple contient trois entiers représentant les combinaisons de nombres valides dans l'ordre croissant basé sur le premier nombre.\n\nExemple :\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "de": "Erzeuge alle einzigartigen Kombinationen von drei Zahlen, die jeweils aus den Ziffern 1 bis 9 ohne Wiederholung gebildet werden, sodass die zweite Zahl das Doppelte der ersten und die dritte das Dreifache der ersten ist.\n\nRückgabe:\nListe von Tupeln: Eine sortierte Liste von Tupeln, wobei jedes Tupel drei ganze Zahlen enthält, die die gültigen Zahlenkombinationen in aufsteigender Reihenfolge basierend auf der ersten Zahl darstellen.\n\nBeispiel:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "ha": "Generate dukkan haɗuwa na musamman na lambobi uku, kowanne an kafa shi daga lambobi 1 zuwa 9 ba tare da maimaitawa ba, \nta yadda lamba ta biyu tana ninki biyu na ta farko kuma ta uku tana ninki uku na ta farko.\n\nReturns:\njerin tuples: Jerin tuples da aka tsara, inda kowanne tuple ya ƙunshi lambobi uku da ke wakiltar\nsahihan haɗuwa na lambobi a cikin tsari mai hawa bisa ga lamba ta farko.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "hi": "तीन संख्याओं के सभी अद्वितीय संयोजनों को उत्पन्न करें, प्रत्येक को 1 से 9 तक के अंकों से बिना पुनरावृत्ति के बनाया गया है, इस प्रकार कि दूसरी संख्या पहली का दोगुना है और तीसरी संख्या पहली का तीन गुना है।\n\nवापसी:\nlist of tuples: ट्यूपल्स की एक क्रमबद्ध सूची, जहाँ प्रत्येक ट्यूपल में तीन पूर्णांक होते हैं जो पहले नंबर के आधार पर आरोही क्रम में मान्य संख्या संयोजनों का प्रतिनिधित्व करते हैं।\n\nउदाहरण:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "hu": "Generáljon minden egyedi kombinációt három számból, amelyek az 1-től 9-ig terjedő számjegyekből állnak ismétlés nélkül, úgy, hogy a második szám kétszerese az elsőnek, és a harmadik háromszorosa az elsőnek.\n\nVisszatérési érték:\nlist of tuples: Egy rendezett lista tuple-ökkel, ahol minden tuple három egész számot tartalmaz, amelyek a\nérvényes számkombinációkat ábrázolják növekvő sorrendben az első szám alapján.\n\nPélda:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]"
    },
    "docstring_bertscore": {
      "sq": "0.9891458428283485",
      "hy": "0.9719923217525567",
      "bn": "0.9637882911246727",
      "bg": "0.9893945280654042",
      "zh": "0.9659499855614754",
      "fr": "0.9898960697775173",
      "de": "0.9867936618561334",
      "ha": "0.9611951715002621",
      "hi": "0.9804247773186308",
      "hu": "0.9600752934119875"
    }
  },
  {
    "task_id": "Python/10",
    "prompt": {
      "en": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "sq": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Llogarit shumën kumulative të vlerave faktoriel nga 1 deri te një numër i specifikuar n.\n\n    Kjo funksion përdor një metodë më efikase për të llogaritur faktorielët duke shumëzuar\n    në mënyrë iterative numrin aktual me rezultatin e mëparshëm të faktorielit, duke shmangur\n    kështu llogaritjet e panevojshme. Më pas akumulon faktorielin e secilit numër nga 1 deri te n përfshirë.\n\n    Argumentet:\n    n (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma e faktorielit.\n             Vlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\n    Kthen:\n    int: Shuma e të gjitha vlerave faktoriel nga 1! deri te n!.\n\n    Shembuj:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "hy": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Հաշվել ֆակտորիալ արժեքների կումուլյատիվ գումարը 1-ից մինչև նշված ամբողջ n թվի համար:\n\n    Այս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալները հաշվելու համար՝\n    հերթական թվին բազմապատկելով նախորդ ֆակտորիալի արդյունքին, այսպիսով խուսափելով ավելորդ\n    հաշվարկներից: Այնուհետև այն կումուլացնում է յուրաքանչյուր թվի ֆակտորիալը 1-ից մինչև n ներառյալ:\n\n    Արգումենտներ:\n    n (int): Շարքի վերին սահմանը, որի համար ֆակտորիալ գումարը պետք է հաշվարկվի:\n             n-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\n    Վերադարձնում է:\n    int: Բոլոր ֆակտորիալ արժեքների գումարը 1!-ից մինչև n!:\n\n    Օրինակներ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "bn": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    ১ থেকে শুরু করে একটি নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত ফ্যাক্টোরিয়াল মানগুলির সমষ্টি গণনা করুন।\n\n    এই ফাংশনটি ফ্যাক্টোরিয়াল গণনার জন্য একটি আরও দক্ষ পদ্ধতি ব্যবহার করে, যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে\n    অতিরিক্ত গণনা এড়ায়। এটি ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়ালকে জমা করে।\n\n    Args:\n    n (int): ফ্যাক্টোরিয়াল সমষ্টি গণনার জন্য পরিসরের উপরের সীমা।\n             n এর মান ১ থেকে ৫০ এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\n    Returns:\n    int: ১! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের সমষ্টি।\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "bg": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Изчислява кумулативната сума на факториелните стойности от 1 до дадено цяло число n.\n\n    Тази функция използва по-ефективен метод за изчисляване на факториели чрез итеративно\n    умножение на текущото число с предишния резултат от факториела, като по този начин се избягват\n    излишни изчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\n    Аргументи:\n    n (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\n             Стойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\n    Връща:\n    int: Сумата на всички факториелни стойности от 1! до n!.\n\n    Примери:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "zh": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    计算从1到指定整数n的阶乘值的累积和。\n\n    此函数采用更高效的方法计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。\n    然后累加从1到n（包括n）的每个数字的阶乘。\n\n    参数:\n    n (int): 要计算阶乘和的范围上限。\n             n的值应在1到50之间，包括1和50。\n\n    返回:\n    int: 从1!到n!的所有阶乘值的和。\n\n    示例:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "fr": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\n    Cette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\n    itérativement le nombre actuel par le résultat factoriel précédent, évitant ainsi des calculs\n    redondants. Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\n    Args:\n    n (int): La limite supérieure de la plage pour laquelle la somme factorielle doit être calculée.\n             La valeur de n doit être comprise entre 1 et 50, inclusivement.\n\n    Returns:\n    int: La somme de toutes les valeurs factorielles de 1! à n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "de": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Berechne die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen ganzen Zahl n.\n\n    Diese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie\n    die aktuelle Zahl iterativ mit dem vorherigen Fakultätsergebnis multipliziert, um so redundante\n    Berechnungen zu vermeiden. Anschließend wird die Fakultät jeder Zahl von 1 bis n inklusive akkumuliert.\n\n    Args:\n    n (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\n             Der Wert von n sollte im Bereich von 1 bis 50 liegen, inklusive.\n\n    Returns:\n    int: Die Summe aller Fakultätswerte von 1! bis n!.\n\n    Beispiele:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "ha": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Lissafa jimillar darajar factorial daga 1 har zuwa wani adadi n da aka kayyade.\n\n    Wannan aikin yana amfani da wata hanya mai inganci don lissafin factorial ta hanyar\n    ninka adadin yanzu da sakamakon factorial na baya, don haka gujewa lissafi mara amfani.\n    Sannan yana tara factorial na kowanne adadi daga 1 zuwa n har da shi.\n\n    Args:\n    n (int): Iyakar kewayon da za a lissafa jimillar factorial.\n             Darajar n ya kamata ta kasance a cikin kewayon 1 zuwa 50, har da su.\n\n    Returns:\n    int: Jimillar dukkan darajar factorial daga 1! zuwa n!.\n\n    Misalai:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "hi": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1 से एक निर्दिष्ट पूर्णांक n तक के फैक्टोरियल मानों का संचयी योग गणना करें।\n\n    यह फ़ंक्शन फैक्टोरियल की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है,\n    जो वर्तमान संख्या को पिछले फैक्टोरियल परिणाम से गुणा करता है, इस प्रकार\n    अनावश्यक गणनाओं से बचता है। फिर यह 1 से n तक प्रत्येक संख्या के फैक्टोरियल\n    को शामिल करते हुए जोड़ता है।\n\n    Args:\n    n (int): उस सीमा का ऊपरी मान जिसके लिए फैक्टोरियल योग की गणना की जानी है।\n             n का मान 1 से 50 की सीमा में होना चाहिए, समावेशी।\n\n    Returns:\n    int: 1! से n! तक के सभी फैक्टोरियल मानों का योग।\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "hu": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Számítsa ki a faktoriális értékek kumulatív összegét 1-től egy megadott n egész számig.\n\n    Ez a függvény egy hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy\n    iteratívan megszorozza az aktuális számot az előző faktoriális eredménnyel, így elkerülve\n    a felesleges számításokat. Ezután felhalmozza az 1-től n-ig terjedő számok faktoriálisát, beleértve n-t is.\n\n    Args:\n    n (int): A tartomány felső határa, amelyre a faktoriális összeg kiszámítandó.\n             Az n értékének 1 és 50 között kell lennie, beleértve.\n\n    Returns:\n    int: Az összes faktoriális érték összege 1! és n! között.\n\n    Példák:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.970525237758233",
      "hy": "0.9589248262450334",
      "bn": "0.9499773221009359",
      "bg": "0.9667391440653269",
      "zh": "0.9581448047387094",
      "fr": "0.9802758045328546",
      "de": "0.9790047687246123",
      "ha": "0.9543348754000792",
      "hi": "0.9685866052393325",
      "hu": "0.9673392064464333"
    },
    "canonical_solution": "    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials",
    "instruction": {
      "en": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nBa da takaitaccen bayanin harshen dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548376088944786",
      "hy": "0.8653907729676097",
      "bn": "0.8842060358111395",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9530483464221162",
      "hi": "0.9109764454151166",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_sum_of_factorials_optimized():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ntest_sum_of_factorials_optimized()",
    "entry_point": "sum_of_factorials_optimized",
    "signature": "def sum_of_factorials_optimized(n: int) -> int:",
    "docstring": {
      "en": "Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\nThis function employs a more efficient method to calculate factorials by iteratively\nmultiplying the current number to the previous factorial result, thus avoiding redundant\ncalculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\nArgs:\nn (int): The upper limit of the range for which the factorial sum is to be calculated.\nThe value of n should be in the range of 1 to 50, inclusive.\n\nReturns:\nint: The sum of all factorial values from 1! to n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "sq": "Llogarit shumën kumulative të vlerave faktoriel nga 1 deri te një numër i specifikuar n.\n\nKjo funksion përdor një metodë më efikase për të llogaritur faktorielët duke shumëzuar në mënyrë iterative numrin aktual me rezultatin e mëparshëm të faktorielit, duke shmangur kështu llogaritjet e panevojshme. Pastaj akumulon faktorielin e secilit numër nga 1 deri te n përfshirë.\n\nArgumentet:\nn (int): Kufiri i sipërm i intervalit për të cilin do të llogaritet shuma e faktorielit.\nVlera e n duhet të jetë në intervalin nga 1 deri në 50, përfshirë.\n\nKthen:\nint: Shuma e të gjitha vlerave faktoriel nga 1! deri te n!.\n\nShembuj:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "hy": "Հաշվել ֆակտորիալ արժեքների կումուլյատիվ գումարը 1-ից մինչև նշված ամբողջ թիվ n:\n\nԱյս ֆունկցիան օգտագործում է ավելի արդյունավետ մեթոդ ֆակտորիալները հաշվարկելու համար՝ իտերատիվ կերպով բազմապատկելով ընթացիկ թիվը նախորդ ֆակտորիալ արդյունքի հետ, այդպիսով խուսափելով ավելորդ հաշվարկներից: Այնուհետև այն կուտակում է 1-ից մինչև n ներառյալ յուրաքանչյուր թվի ֆակտորիալը:\n\nԱրգումենտներ:\nn (int): Շարքի վերին սահմանը, որի համար պետք է հաշվարկվի ֆակտորիալների գումարը:\nn-ի արժեքը պետք է լինի 1-ից 50 միջակայքում, ներառյալ:\n\nՎերադարձնում է:\nint: Բոլոր ֆակտորիալ արժեքների գումարը 1!-ից մինչև n!:\n\nՕրինակներ:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "bn": "ফ্যাক্টোরিয়াল মানগুলির ক্রমবর্ধমান যোগফল 1 থেকে একটি নির্দিষ্ট পূর্ণসংখ্যা n পর্যন্ত গণনা করুন।\n\nএই ফাংশনটি ফ্যাক্টোরিয়াল গণনা করার জন্য একটি আরও দক্ষ পদ্ধতি ব্যবহার করে যা পূর্ববর্তী ফ্যাক্টোরিয়াল ফলাফলের সাথে বর্তমান সংখ্যাকে গুণ করে, ফলে অপ্রয়োজনীয় গণনা এড়ানো যায়। এটি তারপর 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার ফ্যাক্টোরিয়ালকে অন্তর্ভুক্তভাবে যোগ করে।\n\nArgs:\nn (int): সেই পরিসরের উপরের সীমা যার জন্য ফ্যাক্টোরিয়াল যোগফল গণনা করা হবে।\nn এর মান 1 থেকে 50 এর মধ্যে হওয়া উচিত, অন্তর্ভুক্ত।\n\nReturns:\nint: 1! থেকে n! পর্যন্ত সমস্ত ফ্যাক্টোরিয়াল মানের যোগফল।\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "bg": "Изчислява кумулативната сума на факториелните стойности от 1 до зададено цяло число n.\n\nТази функция използва по-ефективен метод за изчисляване на факториели чрез итеративно\nумножаване на текущото число с предишния резултат от факториела, като по този начин се избягват излишни\nизчисления. След това натрупва факториела на всяко число от 1 до n включително.\n\nАргументи:\nn (int): Горната граница на диапазона, за който трябва да се изчисли сумата на факториелите.\nСтойността на n трябва да бъде в диапазона от 1 до 50, включително.\n\nВръща:\nint: Сумата на всички факториелни стойности от 1! до n!.\n\nПримери:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "zh": "计算从 1 到指定整数 n 的阶乘值的累积和。\n\n此函数采用更高效的方法来计算阶乘，通过迭代地将当前数字乘以前一个阶乘结果，从而避免冗余计算。然后累加从 1 到 n 的每个数字的阶乘值。\n\n参数：\nn (int): 要计算阶乘和的范围上限。n 的值应在 1 到 50 之间（包括 1 和 50）。\n\n返回：\nint: 从 1! 到 n! 的所有阶乘值的和。\n\n示例：\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "fr": "Calculer la somme cumulative des valeurs factorielles de 1 jusqu'à un entier spécifié n.\n\nCette fonction utilise une méthode plus efficace pour calculer les factorielles en multipliant\nitérativement le nombre actuel par le résultat factoriel précédent, évitant ainsi les calculs\nredondants. Elle accumule ensuite la factorielle de chaque nombre de 1 à n inclusivement.\n\nArgs:\nn (int): La limite supérieure de la plage pour laquelle la somme factorielle doit être calculée.\nLa valeur de n doit être comprise entre 1 et 50, inclusivement.\n\nReturns:\nint: La somme de toutes les valeurs factorielles de 1! à n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "de": "Berechne die kumulative Summe der Fakultätswerte von 1 bis zu einer angegebenen Ganzzahl n.\n\nDiese Funktion verwendet eine effizientere Methode zur Berechnung von Fakultäten, indem sie iterativ die aktuelle Zahl mit dem vorherigen Fakultätsergebnis multipliziert, um so redundante Berechnungen zu vermeiden. Anschließend akkumuliert sie die Fakultät jeder Zahl von 1 bis n einschließlich.\n\nArgs:\nn (int): Die obere Grenze des Bereichs, für den die Fakultätssumme berechnet werden soll.\nDer Wert von n sollte im Bereich von 1 bis 50 liegen, einschließlich.\n\nReturns:\nint: Die Summe aller Fakultätswerte von 1! bis n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "ha": "Lissafa jimillar darajar factorial daga 1 har zuwa wani adadi n da aka kayyade.\n\nWannan aikin yana amfani da wata hanya mai inganci don lissafin factorials ta hanyar\nnuna lamba ta yanzu zuwa sakamakon factorial na baya, don haka yana guje wa lissafi\nna maimaitawa. Sannan yana tara factorial na kowace lamba daga 1 zuwa n cikin haɗin kai.\n\nArgs:\nn (int): Iyakar sama na zangon wanda za a lissafa jimlar factorial.\nDarajar n ya kamata ta kasance a cikin zangon 1 zuwa 50, ciki har da.\n\nReturns:\nint: Jimlar dukkan darajar factorial daga 1! zuwa n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "hi": "गणना करें 1 से एक निर्दिष्ट पूर्णांक n तक फैक्टरियल मानों का संचयी योग।\n\nयह फ़ंक्शन फैक्टरियल की गणना के लिए एक अधिक कुशल विधि का उपयोग करता है, जो वर्तमान संख्या को पिछले फैक्टरियल परिणाम से गुणा करके, इस प्रकार अनावश्यक गणनाओं से बचता है। यह तब 1 से n तक प्रत्येक संख्या के फैक्टरियल को संचय करता है।\n\nआर्ग्स:\nn (int): उस श्रेणी की ऊपरी सीमा जिसके लिए फैक्टरियल योग की गणना की जानी है।\nn का मान 1 से 50 की सीमा में होना चाहिए, समावेशी।\n\nरिटर्न्स:\nint: 1! से n! तक के सभी फैक्टरियल मानों का योग।\n\nउदाहरण:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "hu": "Számítsa ki a faktoriális értékek kumulatív összegét 1-től egy megadott n egész számig.\n\nEz a függvény egy hatékonyabb módszert alkalmaz a faktoriálisok kiszámítására azáltal, hogy iteratívan\nszorozza a jelenlegi számot az előző faktoriális eredménnyel, így elkerülve a felesleges\nszámításokat. Ezután felhalmozza az 1-től n-ig terjedő számok faktoriálisát, beleértve n-t is.\n\nArgs:\nn (int): Az a felső határ, amelynek tartományára a faktoriális összeg kiszámítandó.\nAz n értékének 1 és 50 között kell lennie, beleértve.\n\nReturns:\nint: Az összes faktoriális érték összege 1!-től n!-ig.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873"
    },
    "docstring_bertscore": {
      "sq": "0.9669401580109342",
      "hy": "0.9624064195638129",
      "bn": "0.9577546946703569",
      "bg": "0.9613284524859366",
      "zh": "0.9537095869605814",
      "fr": "0.9721234178040397",
      "de": "0.9739782283021434",
      "ha": "0.9649878199957423",
      "hi": "0.9674305764217094",
      "hu": "0.9574797902230046"
    }
  },
  {
    "task_id": "Python/11",
    "prompt": {
      "en": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    \"\"\"",
      "sq": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\n    Argumentet:\n    - N (int): Pozicioni në tabelën e Cantor-it për të gjetur thyesën përkatëse.\n\n    Kthen:\n    - str: Një përfaqësim me varg i thyesës në pozicionin e N-të në tabelën e Cantor-it.\n    \"\"\"",
      "hy": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Սահմանում է Կանտորի աղյուսակի N-րդ անդամի համարիչն ու հայտարարը։\n\n    Արգումենտներ:\n    - N (int): Կանտորի աղյուսակում գտնվելու դիրքը, որի համար անհրաժեշտ է գտնել համապատասխան կոտորակը։\n\n    Վերադարձնում է:\n    - str: Կանտորի աղյուսակի N-րդ դիրքում գտնվող կոտորակի տողային ներկայացումը։\n    \"\"\"",
      "bn": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    ক্যান্টর টেবিলের N-তম পদের লব ও হর নির্ধারণ করে।\n\n    আর্গুমেন্টসমূহ:\n    - N (int): ক্যান্টর টেবিলে যে অবস্থানে ভগ্নাংশ খুঁজতে হবে তার অবস্থান।\n\n    রিটার্নস:\n    - str: ক্যান্টর টেবিলের N-তম অবস্থানে থাকা ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।\n    \"\"\"",
      "bg": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\n    Аргументи:\n    - N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\n    Връща:\n    - str: Стринг представяне на дробта на N-тата позиция в таблицата на Кантор.\n    \"\"\"",
      "zh": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    确定康托表中第 N 项的分子和分母。\n\n    参数:\n    - N (int): 康托表中要查找对应分数的位置。\n\n    返回:\n    - str: 康托表中第 N 个位置的分数的字符串表示。\n    \"\"\"",
      "fr": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Détermine le numérateur et le dénominateur du N-ième terme dans le tableau de Cantor.\n\n    Args:\n    - N (int): La position dans le tableau de Cantor pour laquelle trouver la fraction correspondante.\n\n    Returns:\n    - str: Une représentation sous forme de chaîne de la fraction à la position N dans le tableau de Cantor.\n    \"\"\"",
      "de": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\n    Argumente:\n    - N (int): Die Position in der Cantor-Tabelle, für die der entsprechende Bruch gefunden werden soll.\n\n    Rückgabewert:\n    - str: Eine Zeichenketten-Darstellung des Bruchs an der N-ten Position in der Cantor-Tabelle.\n    \"\"\"",
      "ha": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Yana tantance maki da maki na N-awa a cikin teburin Cantor.\n\n    Args:\n    - N (int): Matsayi a cikin teburin Cantor don nemo rabon da ya dace da shi.\n\n    Returns:\n    - str: Wakilcin kirtani na rabon a matsayi na N a cikin teburin Cantor.\n    \"\"\"",
      "hi": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    कैन्टर तालिका में N-वें पद के अंश और हर के मान को निर्धारित करता है।\n\n    तर्क:\n    - N (int): कैन्टर तालिका में वह स्थिति जिसके लिए संबंधित भिन्न को खोजना है।\n\n    वापसी:\n    - str: कैन्टर तालिका में N-वें स्थान पर भिन्न का स्ट्रिंग प्रतिनिधित्व।\n    \"\"\"",
      "hu": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Meghatározza az N-edik elem számlálóját és nevezőjét a Cantor táblázatban.\n\n    Args:\n    - N (int): A Cantor táblázatban elfoglalt pozíció, amelyhez a megfelelő törtet meg kell találni.\n\n    Returns:\n    - str: A tört sztring reprezentációja az N-edik pozícióban a Cantor táblázatban.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9810329835453596",
      "hy": "0.927552150712478",
      "bn": "0.9466723111908963",
      "bg": "0.9625542005673029",
      "zh": "0.9206578888171381",
      "fr": "0.9753795656403446",
      "de": "0.9622415563475539",
      "ha": "0.9425364293969879",
      "hi": "0.9611949728698811",
      "hu": "0.9577368179360637"
    },
    "canonical_solution": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"",
    "instruction": {
      "en": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\n请用中文为以下Python代码提供一个简洁的自然语言描述（文档字符串），最多使用500个字符。",
      "fr": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nBada takaitaccen bayanin yanayi (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.9122435086157381",
      "bg": "0.8983697723915943",
      "zh": "0.8977577921876257",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.8749305929079534",
      "hi": "0.9109764454151166",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_cantor_numbering():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ntest_cantor_numbering()",
    "entry_point": "cantor_numbering",
    "signature": "def cantor_numbering(N: int) -> str:",
    "docstring": {
      "en": "Determines the numerator and denominator of the N-th term in the Cantor table.\n\nArgs:\n- N (int): The position in the Cantor table to find the corresponding fraction for.\n\nReturns:\n- str: A string representation of the fraction at the N-th position in the Cantor table.",
      "sq": "Përcakton numëruesin dhe emëruesin e termit të N-të në tabelën e Cantor-it.\n\nArgumentet:\n- N (int): Pozicioni në tabelën e Cantor-it për të gjetur thyesën përkatëse.\n\nKthen:\n- str: Një përfaqësim si varg i thyesës në pozicionin e N-të në tabelën e Cantor-it.",
      "hy": "N-երորդ անդամի համար որոշում է համարիչը և հայտարարը Կանտորի աղյուսակում:\n\nԱրգումենտներ:\n- N (int): Կանտորի աղյուսակում գտնվելու դիրքը, որի համար պետք է գտնել համապատասխան կոտորակը:\n\nՎերադարձնում է:\n- str: Կանտորի աղյուսակում N-երորդ դիրքում գտնվող կոտորակի տողի ներկայացումը:",
      "bn": "N-তম পদে ক্যান্টর টেবিলের লব ও হর নির্ধারণ করে।\n\nআর্গস:\n- N (int): ক্যান্টর টেবিলের অবস্থান যা থেকে সংশ্লিষ্ট ভগ্নাংশ খুঁজে বের করতে হবে।\n\nরিটার্নস:\n- str: ক্যান্টর টেবিলের N-তম অবস্থানে ভগ্নাংশের একটি স্ট্রিং উপস্থাপনা।",
      "bg": "Определя числителя и знаменателя на N-тия член в таблицата на Кантор.\n\nАргументи:\n- N (int): Позицията в таблицата на Кантор, за която да се намери съответната дроб.\n\nВръща:\n- str: Стринг представяне на дробта на N-тата позиция в таблицата на Кантор.",
      "zh": "确定康托表中第 N 项的分子和分母。\n\n参数:\n- N (int): 康托表中要查找对应分数的位置。\n\n返回:\n- str: 康托表中第 N 个位置的分数的字符串表示形式。",
      "fr": "Détermine le numérateur et le dénominateur du N-ième terme dans la table de Cantor.\n\nArgs:\n- N (int): La position dans la table de Cantor pour laquelle trouver la fraction correspondante.\n\nReturns:\n- str: Une représentation sous forme de chaîne de la fraction à la position N dans la table de Cantor.",
      "de": "Bestimmt den Zähler und Nenner des N-ten Terms in der Cantor-Tabelle.\n\nArgumente:\n- N (int): Die Position in der Cantor-Tabelle, für die der entsprechende Bruch gefunden werden soll.\n\nRückgabewert:\n- str: Eine Zeichenketten-Darstellung des Bruchs an der N-ten Position in der Cantor-Tabelle.",
      "ha": "Yana tantance mai rarrabawa da mai kasa na kalma ta N a cikin teburin Cantor.\n\nArgs:\n- N (int): Matsayin a cikin teburin Cantor don nemo rabon da ya dace.\n\nReturns:\n- str: Wakilcin kirtani na rabon a matsayi na N a cikin teburin Cantor.",
      "hi": "N-th पद में कैन्टर तालिका के अंश और हर के मान निर्धारित करता है।\n\nआर्ग्स:\n- N (int): कैन्टर तालिका में वह स्थिति जिसके लिए संबंधित भिन्न को खोजना है।\n\nवापसी:\n- str: कैन्टर तालिका में N-th स्थिति पर भिन्न का स्ट्रिंग प्रतिनिधित्व।",
      "hu": "Meghatározza az N-edik tétel számlálóját és nevezőjét a Cantor-táblázatban.\n\nArgs:\n- N (int): A Cantor-táblázatban lévő pozíció, amelyhez a megfelelő törtet meg kell találni.\n\nReturns:\n- str: A Cantor-táblázat N-edik pozíciójában lévő tört karakterlánc ábrázolása."
    },
    "docstring_bertscore": {
      "sq": "0.9547956978840801",
      "hy": "0.9290909402743552",
      "bn": "0.9317682791803246",
      "bg": "0.9660804857218153",
      "zh": "0.9159668351082371",
      "fr": "0.9348116938785411",
      "de": "0.9496172052201196",
      "ha": "0.9579914620845504",
      "hi": "0.9227200694330423",
      "hu": "0.9580713114977265"
    }
  },
  {
    "task_id": "Python/12",
    "prompt": {
      "en": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    \"\"\"",
      "sq": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për t'u futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja të shumëzimit në vargun e numrave.)\n    \"\"\"",
      "hy": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Ֆունկցիայի անունը: max_product\n    Արգումենտներ:\n    num_str (str): Տող, որը ներկայացնում է թիվը որպես տող։\n    N (int): Ամբողջ թիվ, որը ներկայացնում է թվի տողի երկարությունը։\n    K (int): Ամբողջ թիվ, որը ներկայացնում է բազմապատկման նշանների քանակը, որոնք պետք է տեղադրել։\n    Վերադարձի տիպը: int (Ֆունկցիան վերադարձնում է առավելագույն արտադրյալը, որը հնարավոր է ստանալ տեղադրելով K բազմապատկման նշաններ թվի տողի մեջ։)\n    \"\"\"",
      "bn": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    ফাংশনের নাম: max_product\n    আর্গুমেন্টসমূহ:\n    num_str (str): একটি স্ট্রিং যা সংখ্যার স্ট্রিংকে উপস্থাপন করে।\n    N (int): একটি পূর্ণসংখ্যা যা সংখ্যার স্ট্রিংয়ের দৈর্ঘ্যকে উপস্থাপন করে।\n    K (int): একটি পূর্ণসংখ্যা যা প্রবেশ করাতে হবে এমন গুণফল চিহ্নের সংখ্যা উপস্থাপন করে।\n    রিটার্ন টাইপ: int (ফাংশনটি সর্বাধিক গুণফল প্রদান করে যা সংখ্যার স্ট্রিংয়ে K গুণফল চিহ্ন প্রবেশ করিয়ে প্রাপ্ত হতে পারে।)\n    \"\"\"",
      "bg": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Име на функцията: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния продукт, който може да се получи чрез вмъкване на K знаци за умножение в числовия низ.)\n    \"\"\"",
      "zh": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (函数返回通过在数字字符串中插入K个乘号可以获得的最大乘积。)\n    \"\"\"",
      "fr": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nom de la fonction : max_product\n    Arguments :\n    num_str (str) : Une chaîne représentant la chaîne de chiffres.\n    N (int) : Un entier représentant la longueur de la chaîne de chiffres.\n    K (int) : Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour : int (La fonction renvoie le produit maximum qui peut être obtenu en insérant K signes de multiplication dans la chaîne de chiffres.)\n    \"\"\"",
      "de": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Eine ganze Zahl, die die Länge der Zahlenfolge darstellt.\n    K (int): Eine ganze Zahl, die die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch das Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)\n    \"\"\"",
      "ha": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Sunan aiki: max_product\n    Huɗɗa:\n    num_str (str): Wani kirtani da ke wakiltar kirtanin lambobi.\n    N (int): Wani cikakken lamba da ke wakiltar tsawon kirtanin lambobi.\n    K (int): Wani cikakken lamba da ke wakiltar adadin alamar ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa mafi girman samfurin da za a iya samu ta hanyar saka alamar ninkawa K a cikin kirtanin lambobi.)\n    \"\"\"",
      "hi": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): संख्या स्ट्रिंग का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    N (int): संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    K (int): डालने के लिए गुणा चिह्नों की संख्या का प्रतिनिधित्व करने वाला एक पूर्णांक।\n    रिटर्न प्रकार: int (यह फ़ंक्शन अधिकतम उत्पाद लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)\n    \"\"\"",
      "hu": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Funkció neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a szám karakterláncot reprezentálja.\n    N (int): Egy egész szám, amely a szám karakterlánc hosszát jelenti.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelenti.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amelyet elérhetünk K szorzásjel beszúrásával a szám karakterláncba.)\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9587458602717209",
      "hy": "0.9589017851208333",
      "bn": "0.9810603945379424",
      "bg": "0.9547104854506162",
      "zh": "0.9596494298750486",
      "fr": "0.9605710748430506",
      "de": "0.9581714212097681",
      "ha": "0.9468560442933536",
      "hi": "0.9866103260144382",
      "hu": "0.9732504465860317"
    },
    "canonical_solution": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]",
    "instruction": {
      "en": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nՏվեք Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9310565865250765",
      "bn": "0.9053846029282224",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9404883515381371",
      "hi": "0.8964889413135749",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_max_product():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ntest_max_product()",
    "entry_point": "max_product",
    "signature": "def max_product(num_str: str, N: int, K: int) -> int:",
    "docstring": {
      "en": "Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)",
      "sq": "Emri i funksionit: max_product\n    Argumentet:\n    num_str (str): Një varg që përfaqëson vargun e numrave.\n    N (int): Një numër i plotë që përfaqëson gjatësinë e vargut të numrave.\n    K (int): Një numër i plotë që përfaqëson numrin e shenjave të shumëzimit për t'u futur.\n    Lloji i kthimit: int (Funksioni kthen produktin maksimal që mund të merret duke futur K shenja shumëzimi në vargun e numrave.)",
      "hy": "Գործառույթի անունը: max_product\n    Փոփոխականներ:\n    num_str (str): Թել, որը ներկայացնում է թվային տողը։\n    N (int): Ամբողջ թիվ, որը ներկայացնում է թվային տողի երկարությունը։\n    K (int): Ամբողջ թիվ, որը ներկայացնում է բազմապատկման նշանների քանակը, որոնք պետք է տեղադրվեն։\n    Վերադարձի տեսակը: int (Ֆունկցիան վերադարձնում է առավելագույն արտադրյալը, որը կարելի է ստանալ՝ տեղադրելով K բազմապատկման նշանները թվային տողի մեջ։)",
      "bn": "ফাংশনের নাম: max_product\n    আর্গুমেন্টসমূহ:\n    num_str (str): সংখ্যা স্ট্রিং উপস্থাপনকারী একটি স্ট্রিং।\n    N (int): সংখ্যা স্ট্রিংয়ের দৈর্ঘ্য উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n    K (int): সন্নিবেশ করার জন্য গুণচিহ্নের সংখ্যা উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n    রিটার্ন টাইপ: int (ফাংশনটি সংখ্যার স্ট্রিংয়ে Kটি গুণচিহ্ন সন্নিবেশ করে প্রাপ্ত সর্বাধিক গুণফল প্রদান করে।)",
      "bg": "Име на функция: max_product\n    Аргументи:\n    num_str (str): Низ, представляващ числовия низ.\n    N (int): Цяло число, представляващо дължината на числовия низ.\n    K (int): Цяло число, представляващо броя на знаците за умножение, които да се вмъкнат.\n    Тип на връщане: int (Функцията връща максималния произведение, което може да се получи чрез вмъкване на K знаци за умножение в числовия низ.)",
      "zh": "函数名称: max_product\n    参数:\n    num_str (str): 表示数字字符串的字符串。\n    N (int): 表示数字字符串长度的整数。\n    K (int): 表示要插入的乘号数量的整数。\n    返回类型: int (函数返回通过在数字字符串中插入K个乘号可以获得的最大乘积。)",
      "fr": "Nom de la fonction: max_product\n    Arguments:\n    num_str (str): Une chaîne représentant la chaîne de chiffres.\n    N (int): Un entier représentant la longueur de la chaîne de chiffres.\n    K (int): Un entier représentant le nombre de signes de multiplication à insérer.\n    Type de retour: int (La fonction renvoie le produit maximum qui peut être obtenu en insérant K signes de multiplication dans la chaîne de chiffres.)",
      "de": "Funktionsname: max_product\n    Argumente:\n    num_str (str): Ein String, der die Zahlenfolge darstellt.\n    N (int): Eine ganze Zahl, die die Länge der Zahlenfolge darstellt.\n    K (int): Eine ganze Zahl, die die Anzahl der einzufügenden Multiplikationszeichen darstellt.\n    Rückgabetyp: int (Die Funktion gibt das maximale Produkt zurück, das durch das Einfügen von K Multiplikationszeichen in die Zahlenfolge erzielt werden kann.)",
      "ha": "Sunan aiki: max_product\n    Huɗa:\n    num_str (str): Wani kirtani da ke wakiltar lambar kirtani.\n    N (int): Wani cikakken lamba da ke wakiltar tsawon lambar kirtani.\n    K (int): Wani cikakken lamba da ke wakiltar adadin alamomin ninkawa da za a saka.\n    Nau'in dawowa: int (Aikin yana dawowa da mafi girman samfurin da za a iya samu ta hanyar saka alamomin ninkawa K cikin lambar kirtani.)",
      "hi": "फ़ंक्शन का नाम: max_product\n    तर्क:\n    num_str (str): एक स्ट्रिंग जो संख्या स्ट्रिंग का प्रतिनिधित्व करती है।\n    N (int): एक पूर्णांक जो संख्या स्ट्रिंग की लंबाई का प्रतिनिधित्व करता है।\n    K (int): एक पूर्णांक जो डालने के लिए गुणा चिह्नों की संख्या का प्रतिनिधित्व करता है।\n    लौटाने का प्रकार: int (यह फ़ंक्शन अधिकतम गुणनफल लौटाता है जो संख्या स्ट्रिंग में K गुणा चिह्न डालकर प्राप्त किया जा सकता है।)",
      "hu": "A függvény neve: max_product\n    Argumentumok:\n    num_str (str): Egy karakterlánc, amely a szám karakterláncot jelöli.\n    N (int): Egy egész szám, amely a szám karakterlánc hosszát jelöli.\n    K (int): Egy egész szám, amely a beszúrandó szorzásjelek számát jelöli.\n    Visszatérési típus: int (A függvény visszaadja a maximális szorzatot, amelyet elérhetünk K szorzásjel beszúrásával a szám karakterláncba.)"
    },
    "docstring_bertscore": {
      "sq": "0.9472719763112406",
      "hy": "0.958204791113782",
      "bn": "0.9725900005690906",
      "bg": "0.9446738909273044",
      "zh": "0.9614490211272247",
      "fr": "0.9498470205709769",
      "de": "0.9439794791152063",
      "ha": "0.9845717824138771",
      "hi": "0.975792120941754",
      "hu": "0.9613636100633798"
    }
  },
  {
    "task_id": "Python/13",
    "prompt": {
      "en": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\n    The function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\n    Scholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    The first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\n    who is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\n    would receive a total of 4850 units of currency.\n\n    In the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\n    is from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.\n    \"\"\"",
      "sq": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Llogarit shumën totale të bursës për një student bazuar në arritjet akademike dhe jashtëshkollore.\n\n    Funksioni përdor një grup kushtesh për të përcaktuar shumën totale të parave të bursës për të cilën studenti ka të drejtë.\n    Bursat jepen bazuar në notat akademike, rolet drejtuese, prejardhjen rajonale dhe kontributet kërkimore.\n\n    Parametrat:\n    grades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja e fundvitit, vlerësimi i klasës].\n    leader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është drejtues klase.\n    west (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\n    papers (int): Një numër i plotë që përfaqëson numrin e artikujve kërkimorë të publikuar nga studenti.\n\n    Kthen:\n    int: Shuma totale e bursës për të cilën studenti ka të drejtë.\n\n    Shembuj:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Shembulli i parë llogarit një bursë për një student me një notë mesatare prej 87, një notë vlerësimi prej 82,\n    i cili është drejtues klase ('Y'), jo nga provinca perëndimore ('N'), dhe pa artikuj të publikuar (0). Ky student\n    do të merrte një total prej 4850 njësive monetare.\n\n    Në shembullin e dytë, studenti ka një notë mesatare prej 88, një notë vlerësimi prej 78, nuk është drejtues klase ('N'),\n    është nga provinca perëndimore ('Y'), dhe ka publikuar 1 artikull. Ky student do të merrte një total prej 9000 njësive monetare.\n    \"\"\"",
      "hy": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Հաշվել ուսանողի ընդհանուր կրթաթոշակի չափը՝ հիմնված ակադեմիական և արտադասարանային նվաճումների վրա:\n\n    Ֆունկցիան օգտագործում է պայմանների մի շարք՝ որոշելու ուսանողի համար նախատեսված ընդհանուր կրթաթոշակի գումարը:\n    Կրթաթոշակները շնորհվում են՝ հիմնված ակադեմիական գնահատականների, առաջնորդության դերերի, տարածաշրջանային ծագման և հետազոտական ներդրումների վրա:\n\n    Պարամետրեր:\n    grades (list of int): Երկու տարրերից բաղկացած ցուցակ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [տարեվերջի միջին, դասի գնահատում]:\n    leader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս՝ արդյոք ուսանողը դասի առաջնորդ է:\n    west (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս՝ արդյոք ուսանողը արևմտյան մարզից է:\n    papers (int): Ամբողջ թիվ, որը ներկայացնում է ուսանողի կողմից հրատարակված հետազոտական հոդվածների քանակը:\n\n    Վերադարձնում է:\n    int: Ընդհանուր կրթաթոշակի գումարը, որին ուսանողը իրավունք ունի:\n\n    Օրինակներ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Առաջին օրինակում հաշվարկվում է կրթաթոշակ ուսանողի համար, որի միջին գնահատականը 87 է, գնահատման գնահատականը՝ 82,\n    ով դասի առաջնորդ է ('Y'), արևմտյան մարզից չէ ('N') և չունի հրատարակված հոդվածներ (0): Այս ուսանողը\n    կստանա ընդհանուր 4850 արժույթի միավոր:\n\n    Երկրորդ օրինակում ուսանողը ունի միջին գնահատական՝ 88, գնահատման գնահատական՝ 78, դասի առաջնորդ չէ ('N'),\n    արևմտյան մարզից է ('Y') և ունի 1 հրատարակված հոդված: Այս ուսանողը կստանա ընդհանուր 9000 արժույթի միավոր:\n    \"\"\"",
      "bn": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    শিক্ষার্থীকে একাডেমিক এবং অতিরিক্ত পাঠক্রমিক কৃতিত্বের উপর ভিত্তি করে মোট বৃত্তির পরিমাণ গণনা করুন।\n\n    ফাংশনটি শিক্ষার্থী কত টাকা বৃত্তি পাওয়ার যোগ্য তা নির্ধারণ করতে বিভিন্ন শর্তাবলী ব্যবহার করে।\n    একাডেমিক গ্রেড, নেতৃত্বের ভূমিকা, আঞ্চলিক পটভূমি এবং গবেষণা অবদানের উপর ভিত্তি করে বৃত্তি প্রদান করা হয়।\n\n    প্যারামিটারসমূহ:\n    grades (list of int): শিক্ষার্থীর একাডেমিক গ্রেডের একটি দুই-উপাদান বিশিষ্ট তালিকা [টার্মের শেষের গড়, শ্রেণির মূল্যায়ন]।\n    leader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী শ্রেণির নেতা কিনা।\n    west (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী পশ্চিম প্রদেশ থেকে কিনা।\n    papers (int): একটি পূর্ণসংখ্যা যা শিক্ষার্থীর প্রকাশিত গবেষণা পত্রের সংখ্যা নির্দেশ করে।\n\n    রিটার্নস:\n    int: শিক্ষার্থী যে মোট বৃত্তির পরিমাণের জন্য যোগ্য তা।\n\n    উদাহরণ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    প্রথম উদাহরণটি এমন একজন শিক্ষার্থীর জন্য বৃত্তি গণনা করে যার গড় গ্রেড 87, মূল্যায়ন গ্রেড 82,\n    যিনি শ্রেণির নেতা ('Y'), পশ্চিম প্রদেশ থেকে নয় ('N'), এবং কোনো প্রকাশিত পত্র নেই (0)। এই শিক্ষার্থী\n    মোট 4850 মুদ্রা একক পাবে।\n\n    দ্বিতীয় উদাহরণে, শিক্ষার্থীর গড় গ্রেড 88, মূল্যায়ন গ্রেড 78, শ্রেণির নেতা নয় ('N'),\n    পশ্চিম প্রদেশ থেকে ('Y'), এবং 1টি পত্র প্রকাশিত হয়েছে। এই শিক্ষার্থী মোট 9000 মুদ্রা একক পাবে।\n    \"\"\"",
      "bg": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Изчислява общата сума на стипендията за студент въз основа на академични и извънкласни постижения.\n\n    Функцията използва набор от условия, за да определи общата сума на стипендията, на която студентът има право.\n    Стипендиите се отпускат въз основа на академични оценки, лидерски роли, регионален произход и научни приноси.\n\n    Параметри:\n    grades (list of int): Двуелементен списък, съдържащ академичните оценки на студента [среден успех в края на срока, класова оценка].\n    leader (str): Низ ('Y' или 'N'), указващ дали студентът е класен лидер.\n    west (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\n    papers (int): Цяло число, представляващо броя на научните публикации на студента.\n\n    Връща:\n    int: Общата сума на стипендията, за която студентът има право.\n\n    Примери:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Първият пример изчислява стипендия за студент със средна оценка 87, оценка от класова оценка 82,\n    който е класен лидер ('Y'), не е от западна провинция ('N') и няма публикувани статии (0). Този студент\n    ще получи общо 4850 единици валута.\n\n    Във втория пример студентът има средна оценка 88, оценка от класова оценка 78, не е класен лидер ('N'),\n    е от западна провинция ('Y') и има публикувана 1 статия. Този студент ще получи общо 9000 единици валута.\n    \"\"\"",
      "zh": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    根据学术和课外成就计算学生的总奖学金金额。\n\n    该函数使用一组条件来确定学生有权获得的奖学金总金额。\n    奖学金根据学术成绩、领导角色、地区背景和研究贡献来颁发。\n\n    参数:\n    grades (list of int): 一个包含学生学术成绩的两元素列表 [期末平均分, 班级评估]。\n    leader (str): 一个字符串 ('Y' 或 'N')，指示学生是否是班级领导。\n    west (str): 一个字符串 ('Y' 或 'N')，指示学生是否来自西部省份。\n    papers (int): 一个整数，表示学生发表的研究论文数量。\n\n    返回:\n    int: 学生有资格获得的总奖学金金额。\n\n    示例:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    第一个示例计算了一个平均成绩为87，评估成绩为82的学生的奖学金，\n    该学生是班级领导 ('Y')，不来自西部省份 ('N')，且没有发表论文 (0)。该学生\n    将获得总计4850单位的货币。\n\n    在第二个示例中，学生的平均成绩为88，评估成绩为78，不是班级领导 ('N')，\n    来自西部省份 ('Y')，并且发表了1篇论文。该学生将获得总计9000单位的货币。\n    \"\"\"",
      "fr": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calculer le montant total de la bourse pour un étudiant basé sur les réalisations académiques et extrascolaires.\n\n    La fonction utilise un ensemble de conditions pour déterminer le montant total de la bourse auquel un étudiant a droit.\n    Les bourses sont attribuées en fonction des notes académiques, des rôles de leadership, de l'origine régionale et des contributions à la recherche.\n\n    Paramètres:\n    grades (list of int): Une liste de deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de classe].\n    leader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un leader de classe.\n    west (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant vient d'une province de l'ouest.\n    papers (int): Un entier représentant le nombre de publications de recherche de l'étudiant.\n\n    Renvoie:\n    int: Le montant total de la bourse auquel l'étudiant est éligible.\n\n    Exemples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Le premier exemple calcule une bourse pour un étudiant avec une moyenne de 87, une note d'évaluation de 82,\n    qui est un leader de classe ('Y'), ne venant pas de la province de l'ouest ('N'), et sans publications (0). Cet étudiant\n    recevrait un total de 4850 unités de monnaie.\n\n    Dans le deuxième exemple, l'étudiant a une moyenne de 88, une note d'évaluation de 78, n'est pas un leader de classe ('N'),\n    vient de la province de l'ouest ('Y'), et a publié 1 article. Cet étudiant recevrait un total de 9000 unités de monnaie.\n    \"\"\"",
      "de": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Berechne den gesamten Stipendienbetrag für einen Studenten basierend auf akademischen und außerschulischen Leistungen.\n\n    Die Funktion verwendet eine Reihe von Bedingungen, um den gesamten Betrag an Stipendiengeld zu bestimmen, auf den ein Student Anspruch hat.\n    Stipendien werden basierend auf akademischen Noten, Führungsrollen, regionalem Hintergrund und Forschungsbeiträgen vergeben.\n\n    Parameter:\n    grades (list von int): Eine Liste mit zwei Elementen, die die akademischen Noten des Studenten enthält [Endjahresdurchschnitt, Klassenbewertung].\n    leader (str): Ein String ('Y' oder 'N'), der angibt, ob der Student ein Klassensprecher ist.\n    west (str): Ein String ('Y' oder 'N'), der angibt, ob der Student aus einer westlichen Provinz stammt.\n    papers (int): Eine ganze Zahl, die die Anzahl der vom Studenten veröffentlichten Forschungsarbeiten darstellt.\n\n    Rückgabewert:\n    int: Der gesamte Stipendienbetrag, für den der Student berechtigt ist.\n\n    Beispiele:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Im ersten Beispiel wird ein Stipendium für einen Studenten berechnet, der einen Durchschnitt von 87, eine Bewertungsnote von 82 hat,\n    Klassensprecher ist ('Y'), nicht aus der westlichen Provinz stammt ('N') und keine veröffentlichten Arbeiten hat (0). Dieser Student\n    würde insgesamt 4850 Währungseinheiten erhalten.\n\n    Im zweiten Beispiel hat der Student einen Durchschnitt von 88, eine Bewertungsnote von 78, ist kein Klassensprecher ('N'),\n    stammt aus der westlichen Provinz ('Y') und hat 1 Arbeit veröffentlicht. Dieser Student würde insgesamt 9000 Währungseinheiten erhalten.\n    \"\"\"",
      "ha": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Lissafi jimillar adadin tallafin karatu ga ɗalibi bisa la'akari da nasarorin ilimi da na ƙarin karatu.\n\n    Aikin yana amfani da saitin yanayi don tantance jimillar adadin kuɗin tallafin karatu da ɗalibi zai samu.\n    Ana bayar da tallafin karatu bisa la'akari da maki na ilimi, rawar jagoranci, asalin yanki, da gudunmawar bincike.\n\n    Sigogi:\n    grades (jerin int): Jerin abubuwa biyu da ke ƙunshe da maki na ilimi na ɗalibi [matsakaicin ƙarshen zangon, kimantawa aji].\n    leader (str): Wani rubutu ('Y' ko 'N') da ke nuna idan ɗalibi jagoran aji ne.\n    west (str): Wani rubutu ('Y' ko 'N') da ke nuna idan ɗalibi daga lardin yamma ne.\n    papers (int): Wani lamba da ke wakiltar adadin takardun bincike da ɗalibi ya wallafa.\n\n    Abin da ake dawowa da shi:\n    int: Jimillar adadin tallafin karatu da ɗalibi ya cancanci samu.\n\n    Misalai:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Misali na farko yana lissafin tallafin karatu ga ɗalibi da ke da matsakaicin maki na 87, maki na kimantawa na 82,\n    wanda jagoran aji ne ('Y'), ba daga lardin yamma ba ('N'), kuma ba tare da takardun da aka wallafa ba (0). Wannan ɗalibin\n    zai samu jimillar 4850 na kuɗi.\n\n    A misali na biyu, ɗalibin yana da matsakaicin maki na 88, maki na kimantawa na 78, ba jagoran aji ba ne ('N'),\n    daga lardin yamma ne ('Y'), kuma yana da takarda 1 da aka wallafa. Wannan ɗalibin zai samu jimillar 9000 na kuɗi.\n    \"\"\"",
      "hi": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    एक छात्र के लिए शैक्षणिक और अतिरिक्त पाठ्यचर्या उपलब्धियों के आधार पर कुल छात्रवृत्ति राशि की गणना करें।\n\n    यह फ़ंक्शन कुछ शर्तों का उपयोग करके यह निर्धारित करता है कि छात्र को कुल कितनी छात्रवृत्ति राशि मिलनी चाहिए।\n    छात्रवृत्तियां शैक्षणिक ग्रेड, नेतृत्व भूमिकाओं, क्षेत्रीय पृष्ठभूमि, और शोध योगदानों के आधार पर प्रदान की जाती हैं।\n\n    पैरामीटर्स:\n    grades (int की सूची): छात्र के शैक्षणिक ग्रेड्स की दो-तत्वों वाली सूची [अवधि के अंत का औसत, कक्षा मूल्यांकन]।\n    leader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा का नेता है या नहीं।\n    west (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\n    papers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या को दर्शाता है।\n\n    रिटर्न्स:\n    int: कुल छात्रवृत्ति राशि जो छात्र के लिए पात्र है।\n\n    उदाहरण:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    पहले उदाहरण में, एक छात्र के लिए छात्रवृत्ति की गणना की जाती है जिसका औसत ग्रेड 87 है, मूल्यांकन ग्रेड 82 है,\n    जो कक्षा का नेता है ('Y'), पश्चिमी प्रांत से नहीं है ('N'), और कोई प्रकाशित पत्र नहीं है (0)। इस छात्र को\n    कुल 4850 मुद्रा इकाइयाँ प्राप्त होंगी।\n\n    दूसरे उदाहरण में, छात्र का औसत ग्रेड 88 है, मूल्यांकन ग्रेड 78 है, कक्षा का नेता नहीं है ('N'),\n    पश्चिमी प्रांत से है ('Y'), और 1 पेपर प्रकाशित किया है। इस छात्र को कुल 9000 मुद्रा इकाइयाँ प्राप्त होंगी।\n    \"\"\"",
      "hu": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Számítsa ki a hallgató ösztöndíjának teljes összegét a tanulmányi és tanórán kívüli eredmények alapján.\n\n    A függvény egy sor feltételt használ annak meghatározására, hogy a hallgató mennyi ösztöndíjra jogosult.\n    Az ösztöndíjak tanulmányi jegyek, vezetői szerepek, regionális háttér és kutatási hozzájárulások alapján kerülnek odaítélésre.\n\n    Paraméterek:\n    grades (list of int): Egy két elemből álló lista, amely a hallgató tanulmányi jegyeit tartalmazza [félév végi átlag, osztályértékelés].\n    leader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a hallgató osztályvezető-e.\n    west (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a hallgató nyugati tartományból származik-e.\n    papers (int): Egy egész szám, amely a hallgató által publikált kutatási cikkek számát jelzi.\n\n    Visszatérési érték:\n    int: Az összes ösztöndíj összege, amelyre a hallgató jogosult.\n\n    Példák:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Az első példa egy olyan hallgató ösztöndíját számítja ki, akinek az átlagjegye 87, az értékelési jegye 82,\n    osztályvezető ('Y'), nem nyugati tartományból származik ('N'), és nincs publikált cikke (0). Ez a hallgató\n    összesen 4850 pénzegység ösztöndíjat kapna.\n\n    A második példában a hallgató átlagjegye 88, az értékelési jegye 78, nem osztályvezető ('N'),\n    nyugati tartományból származik ('Y'), és 1 publikált cikke van. Ez a hallgató összesen 9000 pénzegység ösztöndíjat kapna.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9861953871484563",
      "hy": "0.9632539753996888",
      "bn": "0.9760602719561511",
      "bg": "0.9558716786581462",
      "zh": "0.9777337329163701",
      "fr": "0.980648435127676",
      "de": "0.9724694319278024",
      "ha": "0.9680101798735692",
      "hi": "0.9610448083018187",
      "hu": "0.9577334412195861"
    },
    "canonical_solution": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship",
    "instruction": {
      "en": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nՏվեք Python կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nBa da takaitaccen bayanin harshen dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9136972843745325",
      "bn": "0.8827651710271124",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9404883515381371",
      "hi": "0.9109764454151166",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_calculate_scholarship():\n    # Test case 1: Student meets multiple scholarship criteria\n    grades1 = [90, 85]  # Both grades are high\n    leader1 = 'Y'  # Is a leader\n    west1 = 'Y'  # Is from the West\n    papers1 = 2  # Has published papers\n    expected_scholarship1 = 13850  # Should receive multiple scholarships\n    assert calculate_scholarship(grades1, leader1, west1,\n                                 papers1) == expected_scholarship1, f\"Test case 1 failed. Expected {expected_scholarship1}, got {calculate_scholarship(grades1, leader1, west1, papers1)}\"\n\n    # Test case 2: Student meets one scholarship criteria\n    grades2 = [82, 70]  # Only the first grade is high enough\n    leader2 = 'N'  # Is not a leader\n    west2 = 'N'  # Is not from the West\n    papers2 = 1  # Has published papers\n    expected_scholarship2 = 8000  # Should receive scholarship for first grade and papers\n    assert calculate_scholarship(grades2, leader2, west2,\n                                 papers2) == expected_scholarship2, f\"Test case 2 failed. Expected {expected_scholarship2}, got {calculate_scholarship(grades2, leader2, west2, papers2)}\"\n\n    # Test case 3: Student does not meet any scholarship criteria\n    grades3 = [75, 75]  # Both grades are below the threshold\n    leader3 = 'N'  # Is not a leader\n    west3 = 'N'  # Is not from the West\n    papers3 = 0  # Has no published papers\n    expected_scholarship3 = 0  # Should not receive any scholarships\n    assert calculate_scholarship(grades3, leader3, west3,\n                                 papers3) == expected_scholarship3, f\"Test case 3 failed. Expected {expected_scholarship3}, got {calculate_scholarship(grades3, leader3, west3, papers3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\n\n\ntest_calculate_scholarship()",
    "entry_point": "calculate_scholarship",
    "signature": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:",
    "docstring": {
      "en": "Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\nThe function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\nScholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\nParameters:\ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\nleader (str): A string ('Y' or 'N') indicating if the student is a class leader.\nwest (str): A string ('Y' or 'N') indicating if the student is from a western province.\npapers (int): An integer representing the number of research papers published by the student.\n\nReturns:\nint: The total scholarship amount the student is eligible for.\n\nExamples:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nThe first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\nwho is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\nwould receive a total of 4850 units of currency.\n\nIn the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\nis from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.",
      "sq": "Llogarit shumën totale të bursës për një student bazuar në arritjet akademike dhe jashtëshkollore.\n\nFunksioni përdor një grup kushtesh për të përcaktuar shumën totale të parave të bursës që një student ka të drejtë të marrë.\nBursat jepen bazuar në notat akademike, rolet drejtuese, prejardhjen rajonale dhe kontributet në kërkime.\n\nParametrat:\ngrades (list of int): Një listë me dy elemente që përmban notat akademike të studentit [mesatarja në fund të periudhës, vlerësimi i klasës].\nleader (str): Një varg ('Y' ose 'N') që tregon nëse studenti është drejtues i klasës.\nwest (str): Një varg ('Y' ose 'N') që tregon nëse studenti është nga një provincë perëndimore.\npapers (int): Një numër i plotë që përfaqëson numrin e punimeve kërkimore të publikuara nga studenti.\n\nKthen:\nint: Shuma totale e bursës për të cilën studenti ka të drejtë.\n\nShembuj:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nShembulli i parë llogarit një bursë për një student me një notë mesatare prej 87, një notë vlerësimi prej 82,\ni cili është drejtues i klasës ('Y'), nuk është nga provinca perëndimore ('N'), dhe pa punime të publikuara (0). Ky student\ndo të merrte një total prej 4850 njësi monetare.\n\nNë shembullin e dytë, studenti ka një notë mesatare prej 88, një notë vlerësimi prej 78, nuk është drejtues i klasës ('N'),\nështë nga provinca perëndimore ('Y'), dhe ka publikuar 1 punim. Ky student do të merrte një total prej 9000 njësi monetare.",
      "hy": "Հաշվարկել ուսանողի ընդհանուր կրթաթոշակի գումարը՝ հիմնված ակադեմիական և արտադասարանական նվաճումների վրա։\n\nՖունկցիան օգտագործում է պայմանների մի շարք՝ որոշելու համար ուսանողի իրավունք ունեցող կրթաթոշակի ընդհանուր գումարը։ Կրթաթոշակները շնորհվում են՝ հիմնված ակադեմիական գնահատականների, առաջնորդական դերերի, տարածաշրջանային ծագման և հետազոտական ներդրումների վրա։\n\nՊարամետրեր:\ngrades (ցանկ int): Երկու տարրից բաղկացած ցանկ, որը պարունակում է ուսանողի ակադեմիական գնահատականները [կիսամյակի վերջի միջին, դասի գնահատում]։\nleader (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, արդյոք ուսանողը դասի առաջնորդ է։\nwest (str): Տող ('Y' կամ 'N'), որը ցույց է տալիս, արդյոք ուսանողը արևմտյան մարզից է։\npapers (int): Ամբողջ թիվ, որը ներկայացնում է ուսանողի կողմից հրապարակված հետազոտական հոդվածների քանակը։\n\nՎերադարձնում է:\nint: Կրթաթոշակի ընդհանուր գումարը, որի համար ուսանողը իրավունք ունի։\n\nՕրինակներ:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nԱռաջին օրինակում հաշվարկվում է կրթաթոշակ այն ուսանողի համար, որի միջին գնահատականը 87 է, գնահատման գնահատականը՝ 82,\nով դասի առաջնորդ է ('Y'), արևմտյան մարզից չէ ('N') և չունի հրապարակված հոդվածներ (0)։ Այս ուսանողը\nկստանա ընդհանուր 4850 արժույթի միավոր։\n\nԵրկրորդ օրինակում ուսանողը ունի միջին գնահատական 88, գնահատման գնահատական 78, դասի առաջնորդ չէ ('N'),\nարևմտյան մարզից է ('Y') և ունի 1 հրապարակված հոդված։ Այս ուսանողը կստանա ընդհանուր 9000 արժույթի միավոր։",
      "bn": "একজন শিক্ষার্থীর জন্য একাডেমিক এবং অতিরিক্ত পাঠক্রমিক অর্জনের ভিত্তিতে মোট বৃত্তির পরিমাণ গণনা করুন।\n\nফাংশনটি শিক্ষার্থী কতটা বৃত্তির অর্থ পাওয়ার যোগ্য তা নির্ধারণ করতে একটি শর্তের সেট ব্যবহার করে।\nএকাডেমিক গ্রেড, নেতৃত্বের ভূমিকা, আঞ্চলিক পটভূমি এবং গবেষণা অবদানের ভিত্তিতে বৃত্তি প্রদান করা হয়।\n\nপ্যারামিটারসমূহ:\ngrades (list of int): শিক্ষার্থীর একাডেমিক গ্রেডের একটি দুই-উপাদান তালিকা [টার্মের শেষের গড়, শ্রেণীর মূল্যায়ন]।\nleader (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী শ্রেণীর নেতা কিনা।\nwest (str): একটি স্ট্রিং ('Y' বা 'N') যা নির্দেশ করে শিক্ষার্থী পশ্চিম প্রদেশের কিনা।\npapers (int): শিক্ষার্থীর দ্বারা প্রকাশিত গবেষণাপত্রের সংখ্যা নির্দেশকারী একটি পূর্ণসংখ্যা।\n\nরিটার্নস:\nint: শিক্ষার্থী যে মোট বৃত্তির পরিমাণের জন্য যোগ্য তা।\n\nউদাহরণসমূহ:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nপ্রথম উদাহরণটি এমন একজন শিক্ষার্থীর জন্য বৃত্তি গণনা করে যার গড় গ্রেড 87, মূল্যায়ন গ্রেড 82,\nযিনি শ্রেণীর নেতা ('Y'), পশ্চিম প্রদেশের নন ('N'), এবং কোন প্রকাশিত পত্র নেই (0)। এই শিক্ষার্থী\nমোট 4850 মুদ্রার ইউনিট পাবেন।\n\nদ্বিতীয় উদাহরণে, শিক্ষার্থীর গড় গ্রেড 88, মূল্যায়ন গ্রেড 78, শ্রেণীর নেতা নন ('N'),\nপশ্চিম প্রদেশের ('Y'), এবং 1টি পত্র প্রকাশ করেছেন। এই শিক্ষার্থী মোট 9000 মুদ্রার ইউনিট পাবেন।",
      "bg": "Изчисляване на общата сума на стипендията за студент въз основа на академични и извънкласни постижения.\n\nФункцията използва набор от условия, за да определи общата сума на стипендията, на която студентът има право.\nСтипендиите се отпускат въз основа на академични оценки, лидерски роли, регионален произход и научни приноси.\n\nПараметри:\ngrades (list of int): Двуелементен списък, съдържащ академичните оценки на студента [среден успех в края на срока, оценка от клас].\nleader (str): Низ ('Y' или 'N'), указващ дали студентът е класен лидер.\nwest (str): Низ ('Y' или 'N'), указващ дали студентът е от западна провинция.\npapers (int): Цяло число, представляващо броя на публикуваните научни статии от студента.\n\nВръща:\nint: Общата сума на стипендията, за която студентът има право.\n\nПримери:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nПървият пример изчислява стипендия за студент със средна оценка 87, оценка от оценяване 82,\nкойто е класен лидер ('Y'), не е от западна провинция ('N') и няма публикувани статии (0). Този студент\nще получи общо 4850 единици валута.\n\nВъв втория пример студентът има средна оценка 88, оценка от оценяване 78, не е класен лидер ('N'),\nе от западна провинция ('Y') и има публикувана 1 статия. Този студент ще получи общо 9000 единици валута.",
      "zh": "计算学生基于学术和课外成就的总奖学金金额。\n\n该函数使用一组条件来确定学生有权获得的奖学金总金额。奖学金根据学术成绩、领导角色、地区背景和研究贡献授予。\n\n参数：\ngrades (list of int): 一个包含学生学术成绩的两元素列表 [学期末平均分, 班级评估分]。\nleader (str): 一个字符串 ('Y' 或 'N')，表示学生是否是班级领导。\nwest (str): 一个字符串 ('Y' 或 'N')，表示学生是否来自西部省份。\npapers (int): 一个整数，表示学生发表的研究论文数量。\n\n返回：\nint: 学生有资格获得的奖学金总金额。\n\n例子：\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\n第一个例子计算了一个平均成绩为87，评估成绩为82的学生的奖学金，该学生是班级领导 ('Y')，不来自西部省份 ('N')，且没有发表论文 (0)。该学生将获得总计4850单位的货币。\n\n在第二个例子中，学生的平均成绩为88，评估成绩为78，不是班级领导 ('N')，来自西部省份 ('Y')，并发表了1篇论文。该学生将获得总计9000单位的货币。",
      "fr": "Calculer le montant total de la bourse pour un étudiant en fonction des réalisations académiques et extrascolaires.\n\nLa fonction utilise un ensemble de conditions pour déterminer le montant total de la bourse auquel un étudiant a droit. Les bourses sont attribuées en fonction des notes académiques, des rôles de leadership, de l'origine régionale et des contributions à la recherche.\n\nParamètres :\ngrades (list of int): Une liste de deux éléments contenant les notes académiques de l'étudiant [moyenne de fin de trimestre, évaluation de classe].\nleader (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est un leader de classe.\nwest (str): Une chaîne ('Y' ou 'N') indiquant si l'étudiant est originaire d'une province de l'ouest.\npapers (int): Un entier représentant le nombre de publications de recherche de l'étudiant.\n\nRetourne :\nint: Le montant total de la bourse auquel l'étudiant est éligible.\n\nExemples :\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nLe premier exemple calcule une bourse pour un étudiant avec une moyenne de 87, une note d'évaluation de 82,\nqui est un leader de classe ('Y'), n'est pas originaire de la province de l'ouest ('N'), et n'a pas de publications (0). Cet étudiant\nrecevrait un total de 4850 unités de monnaie.\n\nDans le deuxième exemple, l'étudiant a une moyenne de 88, une note d'évaluation de 78, n'est pas un leader de classe ('N'),\nest originaire de la province de l'ouest ('Y'), et a publié 1 article. Cet étudiant recevrait un total de 9000 unités de monnaie.",
      "de": "Berechnen Sie den gesamten Stipendienbetrag für einen Studenten basierend auf akademischen und außerschulischen Leistungen.\n\nDie Funktion verwendet eine Reihe von Bedingungen, um den Gesamtbetrag des Stipendiengeldes zu bestimmen, auf den ein Student Anspruch hat. Stipendien werden basierend auf akademischen Noten, Führungsrollen, regionalem Hintergrund und Forschungsbeiträgen vergeben.\n\nParameter:\ngrades (list von int): Eine Liste mit zwei Elementen, die die akademischen Noten des Studenten enthält [Endjahresdurchschnitt, Klassenbewertung].\nleader (str): Ein String ('Y' oder 'N'), der angibt, ob der Student ein Klassenleiter ist.\nwest (str): Ein String ('Y' oder 'N'), der angibt, ob der Student aus einer westlichen Provinz stammt.\npapers (int): Eine ganze Zahl, die die Anzahl der vom Studenten veröffentlichten Forschungsarbeiten darstellt.\n\nRückgabewert:\nint: Der gesamte Stipendienbetrag, für den der Student berechtigt ist.\n\nBeispiele:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nIm ersten Beispiel wird ein Stipendium für einen Studenten mit einem Durchschnitt von 87, einer Bewertungsnote von 82,\nder ein Klassenleiter ist ('Y'), nicht aus der westlichen Provinz stammt ('N') und keine veröffentlichten Arbeiten hat (0), berechnet. Dieser Student\nwürde insgesamt 4850 Währungseinheiten erhalten.\n\nIm zweiten Beispiel hat der Student einen Durchschnitt von 88, eine Bewertungsnote von 78, ist kein Klassenleiter ('N'),\nstammt aus der westlichen Provinz ('Y') und hat 1 Arbeit veröffentlicht. Dieser Student würde insgesamt 9000 Währungseinheiten erhalten.",
      "ha": "Ƙididdige jimillar adadin tallafin karatu ga ɗalibi bisa nasarorin karatu da na ƙarin ayyuka.\n\nAikin yana amfani da saitin yanayi don tantance jimillar adadin kuɗin tallafin karatu da ɗalibi zai cancanci samu. Ana bayar da tallafin karatu bisa ga maki na karatu, rawar jagoranci, asalin yanki, da gudummawar bincike.\n\nSigogi:\ngrades (jerin int): Jerin abubuwa guda biyu da ke ƙunshe da maki na karatun ɗalibi [matsakaicin ƙarshen zangon, kimantawar aji].\nleader (str): Wani kirtani ('Y' ko 'N') da ke nuna ko ɗalibin jagoran aji ne.\nwest (str): Wani kirtani ('Y' ko 'N') da ke nuna ko ɗalibin daga yanki na yamma ne.\npapers (int): Wani lamba da ke wakiltar adadin takardun bincike da ɗalibin ya wallafa.\n\nDawowa:\nint: Jimillar adadin tallafin karatu da ɗalibin ya cancanci samu.\n\nMisalai:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nMisalin farko yana ƙididdige tallafin karatu ga ɗalibi da ke da matsakaicin maki na 87, maki na kimantawa na 82,\nwanda jagoran aji ne ('Y'), ba daga yanki na yamma ba ('N'), kuma ba tare da takardun da aka wallafa ba (0). Wannan ɗalibin\nzai sami jimillar 4850 raka'a na kuɗi.\n\nA cikin misali na biyu, ɗalibin yana da matsakaicin maki na 88, maki na kimantawa na 78, ba jagoran aji ba ne ('N'),\ndaga yanki na yamma ('Y'), kuma ya wallafa takarda 1. Wannan ɗalibin zai sami jimillar 9000 raka'a na kuɗi.",
      "hi": "छात्र के अकादमिक और अतिरिक्त पाठ्यचर्या उपलब्धियों के आधार पर कुल छात्रवृत्ति राशि की गणना करें।\n\nयह फ़ंक्शन यह निर्धारित करने के लिए कुछ शर्तों का उपयोग करता है कि छात्र को कुल कितनी छात्रवृत्ति राशि मिलनी चाहिए। छात्रवृत्तियां अकादमिक ग्रेड, नेतृत्व भूमिकाओं, क्षेत्रीय पृष्ठभूमि, और अनुसंधान योगदान के आधार पर प्रदान की जाती हैं।\n\nपैरामीटर्स:\ngrades (list of int): छात्र के अकादमिक ग्रेड की एक दो-तत्वों वाली सूची [अंतिम अवधि का औसत, कक्षा मूल्यांकन]।\nleader (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र कक्षा नेता है या नहीं।\nwest (str): एक स्ट्रिंग ('Y' या 'N') जो यह दर्शाती है कि छात्र पश्चिमी प्रांत से है या नहीं।\npapers (int): एक पूर्णांक जो छात्र द्वारा प्रकाशित शोध पत्रों की संख्या का प्रतिनिधित्व करता है।\n\nवापसी:\nint: कुल छात्रवृत्ति राशि जो छात्र के लिए पात्र है।\n\nउदाहरण:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nपहले उदाहरण में, एक छात्र के लिए छात्रवृत्ति की गणना की जाती है जिसका औसत ग्रेड 87 है, मूल्यांकन ग्रेड 82 है, जो कक्षा नेता है ('Y'), जो पश्चिमी प्रांत से नहीं है ('N'), और जिसके कोई प्रकाशित पत्र नहीं हैं (0)। इस छात्र को कुल 4850 मुद्रा इकाइयां प्राप्त होंगी।\n\nदूसरे उदाहरण में, छात्र का औसत ग्रेड 88 है, मूल्यांकन ग्रेड 78 है, वह कक्षा नेता नहीं है ('N'), वह पश्चिमी प्रांत से है ('Y'), और उसने 1 पत्र प्रकाशित किया है। इस छात्र को कुल 9000 मुद्रा इकाइयां प्राप्त होंगी।",
      "hu": "Számítsa ki a hallgató összes ösztöndíj összegét tanulmányi és tanórán kívüli eredmények alapján.\n\nA függvény egy sor feltételt használ annak meghatározására, hogy a hallgató mennyi ösztöndíjra jogosult.\nAz ösztöndíjakat tanulmányi eredmények, vezetői szerepek, regionális háttér és kutatási hozzájárulások alapján ítélik oda.\n\nParaméterek:\ngrades (list of int): Egy kételemű lista, amely tartalmazza a hallgató tanulmányi eredményeit [félév végi átlag, osztályértékelés].\nleader (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a hallgató osztályvezető-e.\nwest (str): Egy karakterlánc ('Y' vagy 'N'), amely jelzi, hogy a hallgató nyugati tartományból származik-e.\npapers (int): Egy egész szám, amely a hallgató által publikált kutatási cikkek számát jelöli.\n\nVisszatérési érték:\nint: Az összes ösztöndíj összeg, amelyre a hallgató jogosult.\n\nPéldák:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nAz első példa egy olyan hallgató ösztöndíját számítja ki, akinek az átlaga 87, az értékelési jegye 82,\nosztályvezető ('Y'), nem nyugati tartományból származik ('N'), és nincs publikált cikke (0). Ez a hallgató\nösszesen 4850 pénzegységet kapna.\n\nA második példában a hallgató átlaga 88, az értékelési jegye 78, nem osztályvezető ('N'),\nnyugati tartományból származik ('Y'), és 1 publikált cikke van. Ez a hallgató összesen 9000 pénzegységet kapna."
    },
    "docstring_bertscore": {
      "sq": "0.982617855355637",
      "hy": "0.9627081391126049",
      "bn": "0.9781443019139692",
      "bg": "0.962896639344207",
      "zh": "0.9710059232803374",
      "fr": "0.9796240982526792",
      "de": "0.9755257576007863",
      "ha": "0.9636500443794723",
      "hi": "0.9541163819809408",
      "hu": "0.9532497576284856"
    }
  },
  {
    "task_id": "Python/14",
    "prompt": {
      "en": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    The second example shows the correction of the ISBN number where the checksum digit is calculated\n    to be '4' instead of the provided '0', thus the corrected ISBN is returned.\n    \"\"\"\n    # Function implementation goes here.",
      "sq": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verifikon saktësinë e një numri të dhënë ISBN dhe e korrigjon atë nëse është e nevojshme.\n\n    Funksioni kontrollon numrin e dhënë ISBN kundrejt llogaritjes standarde të kontrollit të ISBN.\n    Nëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\n    funksioni kthen numrin e korrigjuar ISBN.\n\n    Argumentet:\n    isbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\n          ku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\n    Kthen:\n    Një varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\n    në të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\n    Shembuj:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Shembulli i dytë tregon korrigjimin e numrit ISBN ku shifra e kontrollit llogaritet\n    të jetë '4' në vend të '0' të dhënë, kështu që kthehet ISBN i korrigjuar.\n    \"\"\"\n    # Zbatimi i funksionit shkon këtu.",
      "hy": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Ստուգել տրված ISBN համարի ճշգրտությունը և անհրաժեշտության դեպքում ուղղել այն:\n\n    Ֆունկցիան ստուգում է տրամադրված ISBN համարը ըստ ISBN ստանդարտի ստուգման գումարի հաշվարկի:\n    Եթե ստուգման գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\": Եթե ստուգման գումարը սխալ է,\n    ֆունկցիան վերադարձնում է ուղղված ISBN համարը:\n\n    Արգումենտներ:\n    isbn: Տող, որը ներկայացնում է ստուգվող ISBN համարը: Ֆորմատը պետք է լինի 'x-xxx-xxxxx-x',\n          որտեղ 'x'-ը թիվ է, իսկ վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգման գումարի թիվը:\n\n    Վերադարձնում է:\n    Տող, որը կամ \"Right\" է, եթե ISBN ստուգման գումարը ճիշտ է, կամ ուղղված ISBN համարը\n    նույն ֆորմատով, ինչպես մուտքայինը, եթե ստուգման գումարը սխալ է:\n\n    Օրինակներ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Երկրորդ օրինակը ցույց է տալիս ISBN համարի ուղղումը, որտեղ ստուգման գումարի թիվը հաշվարկվում է\n    որպես '4' փոխարեն տրված '0'-ի, հետևաբար վերադարձվում է ուղղված ISBN համարը:\n    \"\"\"\n    # Ֆունկցիայի իրականացումը այստեղ է:",
      "bn": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    প্রদত্ত একটি ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজন হলে এটি সংশোধন করুন।\n\n    ফাংশনটি প্রদত্ত ISBN নম্বরটি ISBN মানক চেকসাম গণনার সাথে যাচাই করে।\n    যদি চেকসাম সঠিক হয়, তাহলে ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসাম ভুল হয়,\n    তাহলে ফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\n    Args:\n    isbn: একটি স্ট্রিং যা যাচাই করার জন্য ISBN নম্বর উপস্থাপন করে। ফরম্যাটটি হওয়া উচিত 'x-xxx-xxxxx-x',\n          যেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' ও 'X' হতে পারে যা চেকসাম ডিজিট উপস্থাপন করে।\n\n    Returns:\n    একটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসাম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\n    ইনপুটের মতো একই ফরম্যাটে যদি চেকসাম ভুল হয়।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    দ্বিতীয় উদাহরণটি দেখায় যে ISBN নম্বরের সংশোধন যেখানে চেকসাম ডিজিট '4' হিসেবে গণনা করা হয়\n    প্রদত্ত '0' এর পরিবর্তে, ফলে সংশোধিত ISBN ফেরত দেওয়া হয়।\n    \"\"\"\n    # Function implementation goes here.",
      "bg": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\n    Функцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролна сума на ISBN.\n    Ако контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\n    функцията връща коригирания ISBN номер.\n\n    Аргументи:\n    isbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\n          където 'x' е цифра, а последното 'x' може също да бъде 'X', представляващо контролна цифра.\n\n    Връща:\n    Низ, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\n    в същия формат като входния, ако контролната сума е неправилна.\n\n    Примери:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Вторият пример показва корекцията на ISBN номера, където контролната цифра се изчислява\n    да бъде '4' вместо предоставената '0', следователно се връща коригираният ISBN.\n    \"\"\"\n    # Function implementation goes here.",
      "zh": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    验证给定的ISBN号码的正确性，并在必要时进行更正。\n\n    该函数根据ISBN标准校验和计算检查提供的ISBN号码。\n    如果校验和正确，函数返回\"Right\"。如果校验和不正确，\n    函数返回更正后的ISBN号码。\n\n    参数:\n    isbn: 一个表示要验证的ISBN号码的字符串。格式应为'x-xxx-xxxxx-x'，\n          其中'x'是一个数字，最后一个'x'也可以是代表校验和数字的'X'。\n\n    返回:\n    一个字符串，如果ISBN校验和正确则为\"Right\"，如果校验和不正确则为更正后的ISBN号码，\n    格式与输入相同。\n\n    示例:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    第二个示例显示了ISBN号码的更正，其中校验和数字被计算为'4'而不是提供的'0'，因此返回更正后的ISBN。\n    \"\"\"\n    # Function implementation goes here.",
      "fr": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Vérifiez la validité d'un numéro ISBN donné et corrigez-le si nécessaire.\n\n    La fonction vérifie le numéro ISBN fourni selon le calcul de la somme de contrôle standard ISBN.\n    Si la somme de contrôle est correcte, la fonction renvoie \"Right\". Si la somme de contrôle est incorrecte,\n    la fonction renvoie le numéro ISBN corrigé.\n\n    Args:\n    isbn: Une chaîne représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\n          où 'x' est un chiffre, et le dernier 'x' pourrait également être 'X' représentant le chiffre de contrôle.\n\n    Returns:\n    Une chaîne qui est soit \"Right\" si la somme de contrôle de l'ISBN est correcte, soit le numéro ISBN corrigé\n    dans le même format que l'entrée si la somme de contrôle est incorrecte.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Le deuxième exemple montre la correction du numéro ISBN où le chiffre de contrôle est calculé\n    pour être '4' au lieu du '0' fourni, ainsi le numéro ISBN corrigé est renvoyé.\n    \"\"\"\n    # L'implémentation de la fonction va ici.",
      "de": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\n    Die Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfsummenberechnung.\n    Wenn die Prüfsumme korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfsumme falsch ist,\n    gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\n    Argumente:\n    isbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein,\n          wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, das die Prüfziffer darstellt.\n\n    Rückgabewerte:\n    Ein String, der entweder \"Right\" ist, wenn die ISBN-Prüfsumme korrekt ist, oder die korrigierte ISBN-Nummer\n    im gleichen Format wie die Eingabe, wenn die Prüfsumme falsch ist.\n\n    Beispiele:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Das zweite Beispiel zeigt die Korrektur der ISBN-Nummer, wobei die Prüfziffer als '4' berechnet wird\n    anstelle der angegebenen '0', daher wird die korrigierte ISBN zurückgegeben.\n    \"\"\"\n    # Function implementation goes here.",
      "ha": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara idan ya cancanta.\n\n    Aikin yana duba lambar ISBN da aka bayar daidai da lissafin daidaitaccen lissafin ISBN.\n    Idan lissafin daidaito ya yi daidai, aikin yana mayar da \"Right\". Idan lissafin daidaito bai yi daidai ba,\n    aikin yana mayar da lambar ISBN da aka gyara.\n\n    Args:\n    isbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya kamata ya zama 'x-xxx-xxxxx-x',\n          inda 'x' yake wakiltar lamba, kuma 'x' na ƙarshe na iya zama 'X' wanda ke wakiltar lambar daidaito.\n\n    Returns:\n    Wani kirtani wanda ko dai \"Right\" idan lissafin daidaito na ISBN ya yi daidai, ko lambar ISBN da aka gyara\n    a cikin tsarin daidai da wanda aka shigar idan lissafin daidaito bai yi daidai ba.\n\n    Misalai:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Misali na biyu yana nuna gyaran lambar ISBN inda aka lissafa lambar daidaito\n    don zama '4' maimakon '0' da aka bayar, don haka an mayar da lambar ISBN da aka gyara.\n    \"\"\"\n    # Function implementation goes here.",
      "hi": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    दिए गए ISBN नंबर की शुद्धता की जाँच करें और यदि आवश्यक हो तो इसे सही करें।\n\n    यह फ़ंक्शन प्रदान किए गए ISBN नंबर की ISBN मानक चेकसम गणना के खिलाफ जाँच करता है।\n    यदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\n    तो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\n    Args:\n    isbn: एक स्ट्रिंग जो सत्यापित किए जाने वाले ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\n          जहाँ 'x' एक अंक है, और अंतिम 'x' भी 'X' हो सकता है जो चेकसम अंक का प्रतिनिधित्व करता है।\n\n    Returns:\n    एक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या सही किया गया ISBN नंबर\n    उसी प्रारूप में जैसा कि इनपुट में है, यदि चेकसम गलत है।\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    दूसरा उदाहरण ISBN नंबर के सुधार को दिखाता है जहाँ चेकसम अंक '4' के रूप में गणना की जाती है\n    बजाय प्रदान किए गए '0' के, इस प्रकार सही किया गया ISBN लौटाया जाता है।\n    \"\"\"\n    # Function implementation goes here.",
      "hu": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Ellenőrzi a megadott ISBN szám helyességét, és szükség esetén kijavítja azt.\n\n    A függvény ellenőrzi a megadott ISBN számot az ISBN szabvány ellenőrzőösszeg számításának megfelelően.\n    Ha az ellenőrzőösszeg helyes, a függvény \"Right\"-ot ad vissza. Ha az ellenőrzőösszeg helytelen,\n    a függvény a javított ISBN számot adja vissza.\n\n    Args:\n    isbn: Egy string, amely az ellenőrizendő ISBN számot képviseli. A formátumnak 'x-xxx-xxxxx-x' kell lennie,\n          ahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet jelenti.\n\n    Returns:\n    Egy string, amely vagy \"Right\", ha az ISBN ellenőrzőösszeg helyes, vagy a javított ISBN szám\n    ugyanabban a formátumban, mint a bemenet, ha az ellenőrzőösszeg helytelen.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    A második példa az ISBN szám javítását mutatja, ahol az ellenőrző számjegy '4'-re van számítva a megadott '0' helyett, így a javított ISBN kerül visszaadásra.\n    \"\"\"\n    # Function implementation goes here."
    },
    "prompt_bertscore": {
      "sq": "0.9552501641958879",
      "hy": "0.9767290604490956",
      "bn": "0.9867491686507815",
      "bg": "0.9799359479509039",
      "zh": "0.9719960957297963",
      "fr": "0.9781671444077882",
      "de": "0.9726543568125459",
      "ha": "0.9661863557149069",
      "hi": "0.9924458879788621",
      "hu": "0.9724197743325437"
    },
    "canonical_solution": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit",
    "instruction": {
      "en": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nՏվեք Python կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nДайте кратко описание на Python кода на български език, използвайки максимум 500 знака.",
      "zh": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\n请用中文为以下Python代码提供一个简洁的自然语言描述（文档字符串），最多使用500个字符。",
      "fr": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9443791234418485",
      "hy": "0.9136972843745325",
      "bn": "0.8827651710271124",
      "bg": "0.8431074236712108",
      "zh": "0.8977577921876257",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.9174422615785642",
      "hi": "0.9109764454151166",
      "hu": "0.9412719483913198"
    },
    "level": "",
    "test": "def test_verify_isbn():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_verify_isbn()",
    "entry_point": "verify_isbn",
    "signature": "def verify_isbn(isbn: str) -> str:",
    "docstring": {
      "en": "Verify the correctness of a given ISBN number and correct it if necessary.\n\nThe function checks the provided ISBN number against the ISBN standard checksum calculation.\nIf the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\nthe function returns the corrected ISBN number.\n\nArgs:\nisbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\nwhere 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\nReturns:\nA string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\nin the same format as the input if the checksum is incorrect.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nThe second example shows the correction of the ISBN number where the checksum digit is calculated\nto be '4' instead of the provided '0', thus the corrected ISBN is returned.",
      "sq": "Verifikoni saktësinë e një numri të dhënë ISBN dhe korrigjojeni atë nëse është e nevojshme.\n\nFunksioni kontrollon numrin e dhënë ISBN kundrejt llogaritjes standarde të kontrollit të ISBN.\nNëse kontrolli është i saktë, funksioni kthen \"Right\". Nëse kontrolli është i pasaktë,\nfunksioni kthen numrin e korrigjuar ISBN.\n\nArgs:\nisbn: Një varg që përfaqëson numrin ISBN që do të verifikohet. Formati duhet të jetë 'x-xxx-xxxxx-x',\nku 'x' është një shifër, dhe 'x' i fundit mund të jetë gjithashtu 'X' që përfaqëson shifrën e kontrollit.\n\nReturns:\nNjë varg që është ose \"Right\" nëse kontrolli i ISBN është i saktë, ose numri i korrigjuar ISBN\nnë të njëjtin format si hyrja nëse kontrolli është i pasaktë.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nShembulli i dytë tregon korrigjimin e numrit ISBN ku shifra e kontrollit llogaritet\ntë jetë '4' në vend të '0' të dhënë, kështu që kthehet ISBN i korrigjuar.",
      "hy": "Ստուգել տրված ISBN համարի ճշտությունը և անհրաժեշտության դեպքում ուղղել այն։\n\nՖունկցիան ստուգում է տրված ISBN համարը ISBN ստանդարտի ստուգման գումարի հաշվարկի դեմ։\nԵթե ստուգման գումարը ճիշտ է, ֆունկցիան վերադարձնում է \"Right\"։ Եթե ստուգման գումարը սխալ է,\nֆունկցիան վերադարձնում է ուղղված ISBN համարը։\n\nԱրձանագրություններ:\nisbn: Տող, որը ներկայացնում է ստուգման ենթակա ISBN համարը։ Ֆորմատը պետք է լինի 'x-xxx-xxxxx-x',\nորտեղ 'x'-ը թիվ է, և վերջին 'x'-ը կարող է լինել նաև 'X', որը ներկայացնում է ստուգման գումարի թիվը։\n\nՎերադարձնում է:\nՏող, որը կամ \"Right\" է, եթե ISBN ստուգման գումարը ճիշտ է, կամ ուղղված ISBN համարը\nնույն ֆորմատով, ինչ մուտքագրումը, եթե ստուգման գումարը սխալ է։\n\nՕրինակներ:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nԵրկրորդ օրինակը ցույց է տալիս ISBN համարի ուղղումը, որտեղ ստուգման գումարի թիվը հաշվարկվել է\nորպես '4'՝ փոխարենը տրված '0'-ի, ուստի վերադարձվում է ուղղված ISBN-ը։",
      "bn": "একটি প্রদত্ত ISBN নম্বরের সঠিকতা যাচাই করুন এবং প্রয়োজন হলে এটি সংশোধন করুন।\n\nফাংশনটি প্রদত্ত ISBN নম্বরটি ISBN মানদণ্ডের চেকসাম গণনার সাথে মিলিয়ে পরীক্ষা করে।\nযদি চেকসাম সঠিক হয়, ফাংশনটি \"Right\" ফেরত দেয়। যদি চেকসাম ভুল হয়,\nফাংশনটি সংশোধিত ISBN নম্বর ফেরত দেয়।\n\nArgs:\nisbn: একটি স্ট্রিং যা যাচাই করার জন্য ISBN নম্বর উপস্থাপন করে। ফরম্যাটটি 'x-xxx-xxxxx-x' হওয়া উচিত,\nযেখানে 'x' একটি সংখ্যা, এবং শেষের 'x' চেকসাম সংখ্যাকে উপস্থাপন করতে 'X'ও হতে পারে।\n\nReturns:\nএকটি স্ট্রিং যা হয় \"Right\" যদি ISBN চেকসাম সঠিক হয়, অথবা সংশোধিত ISBN নম্বর\nইনপুটের মতো একই ফরম্যাটে যদি চেকসাম ভুল হয়।\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nদ্বিতীয় উদাহরণটি ISBN নম্বরের সংশোধন দেখায় যেখানে চেকসাম সংখ্যা '0' এর পরিবর্তে '4' হিসাবে গণনা করা হয়,\nফলে সংশোধিত ISBN ফেরত দেওয়া হয়।",
      "bg": "Проверете коректността на даден ISBN номер и го коригирайте, ако е необходимо.\n\nФункцията проверява предоставения ISBN номер спрямо стандартното изчисление на контролна сума на ISBN.\nАко контролната сума е правилна, функцията връща \"Right\". Ако контролната сума е неправилна,\nфункцията връща коригирания ISBN номер.\n\nАргументи:\nisbn: Низ, представляващ ISBN номера, който трябва да бъде проверен. Форматът трябва да бъде 'x-xxx-xxxxx-x',\nкъдето 'x' е цифра, а последното 'x' може също да бъде 'X', представляващо контролна цифра.\n\nВръща:\nНиз, който е или \"Right\", ако контролната сума на ISBN е правилна, или коригирания ISBN номер\nв същия формат като входа, ако контролната сума е неправилна.\n\nПримери:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nВторият пример показва корекцията на ISBN номера, където контролната цифра е изчислена\nда бъде '4' вместо предоставената '0', следователно се връща коригираният ISBN.",
      "zh": "验证给定的 ISBN 号码的正确性，并在必要时进行更正。\n\n该函数根据 ISBN 标准校验和计算检查提供的 ISBN 号码。\n如果校验和正确，函数返回 \"Right\"。如果校验和不正确，\n函数返回更正后的 ISBN 号码。\n\n参数：\nisbn: 一个表示要验证的 ISBN 号码的字符串。格式应为 'x-xxx-xxxxx-x'，\n其中 'x' 是一个数字，最后一个 'x' 也可以是代表校验和数字的 'X'。\n\n返回：\n一个字符串，如果 ISBN 校验和正确，则为 \"Right\"；如果校验和不正确，\n则为与输入格式相同的更正后的 ISBN 号码。\n\n示例：\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\n第二个示例显示了 ISBN 号码的更正，其中校验和数字计算为 '4' 而不是提供的 '0'，因此返回更正后的 ISBN。",
      "fr": "Vérifiez la validité d'un numéro ISBN donné et corrigez-le si nécessaire.\n\nLa fonction vérifie le numéro ISBN fourni par rapport au calcul standard de la somme de contrôle ISBN.\nSi la somme de contrôle est correcte, la fonction retourne \"Right\". Si la somme de contrôle est incorrecte,\nla fonction retourne le numéro ISBN corrigé.\n\nArgs:\nisbn: Une chaîne de caractères représentant le numéro ISBN à vérifier. Le format doit être 'x-xxx-xxxxx-x',\noù 'x' est un chiffre, et le dernier 'x' pourrait aussi être 'X' représentant le chiffre de la somme de contrôle.\n\nReturns:\nUne chaîne de caractères qui est soit \"Right\" si la somme de contrôle ISBN est correcte, soit le numéro ISBN corrigé\ndans le même format que l'entrée si la somme de contrôle est incorrecte.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nLe deuxième exemple montre la correction du numéro ISBN où le chiffre de la somme de contrôle est calculé\npour être '4' au lieu de '0' fourni, ainsi le numéro ISBN corrigé est retourné.",
      "de": "Überprüfen Sie die Korrektheit einer gegebenen ISBN-Nummer und korrigieren Sie sie bei Bedarf.\n\nDie Funktion überprüft die angegebene ISBN-Nummer anhand der ISBN-Standard-Prüfziffernberechnung. Wenn die Prüfziffer korrekt ist, gibt die Funktion \"Right\" zurück. Wenn die Prüfziffer falsch ist, gibt die Funktion die korrigierte ISBN-Nummer zurück.\n\nArgs:\nisbn: Ein String, der die zu überprüfende ISBN-Nummer darstellt. Das Format sollte 'x-xxx-xxxxx-x' sein, wobei 'x' eine Ziffer ist und das letzte 'x' auch 'X' sein könnte, was die Prüfziffer darstellt.\n\nReturns:\nEin String, der entweder \"Right\" ist, wenn die ISBN-Prüfziffer korrekt ist, oder die korrigierte ISBN-Nummer im gleichen Format wie die Eingabe, wenn die Prüfziffer falsch ist.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nDas zweite Beispiel zeigt die Korrektur der ISBN-Nummer, bei der die Prüfziffer als '4' berechnet wird, anstatt der angegebenen '0', sodass die korrigierte ISBN zurückgegeben wird.",
      "ha": "Tabbatar da daidaiton lambar ISBN da aka bayar kuma gyara idan ya cancanta.\n\nAikin yana duba lambar ISBN da aka bayar daidai da lissafin duba daidaito na ma'aunin ISBN.\nIdan duba daidaito ya yi daidai, aikin yana mayar da \"Right\". Idan duba daidaito bai yi daidai ba,\naikin yana mayar da lambar ISBN da aka gyara.\n\nArgs:\nisbn: Wani kirtani da ke wakiltar lambar ISBN da za a tabbatar. Tsarin ya kamata ya zama 'x-xxx-xxxxx-x',\ninda 'x' yake wakiltar lamba, kuma 'x' na ƙarshe na iya zama 'X' wanda ke wakiltar lambar duba daidaito.\n\nReturns:\nWani kirtani wanda ko dai \"Right\" idan duba daidaito na ISBN ya yi daidai, ko kuma lambar ISBN da aka gyara\na cikin tsarin daidai da shigarwar idan duba daidaito bai yi daidai ba.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nMisalin na biyu yana nuna gyaran lambar ISBN inda aka lissafa lambar duba daidaito\nya zama '4' maimakon '0' da aka bayar, don haka an mayar da lambar ISBN da aka gyara.",
      "hi": "एक दिए गए ISBN नंबर की शुद्धता की जाँच करें और यदि आवश्यक हो तो इसे सही करें।\n\nयह फ़ंक्शन दिए गए ISBN नंबर को ISBN मानक चेकसम गणना के विरुद्ध जाँचता है।\nयदि चेकसम सही है, तो फ़ंक्शन \"Right\" लौटाता है। यदि चेकसम गलत है,\nतो फ़ंक्शन सही किया गया ISBN नंबर लौटाता है।\n\nआर्ग्स:\nisbn: एक स्ट्रिंग जो सत्यापित किए जाने वाले ISBN नंबर का प्रतिनिधित्व करती है। प्रारूप 'x-xxx-xxxxx-x' होना चाहिए,\nजहाँ 'x' एक अंक है, और अंतिम 'x' चेकसम अंक का प्रतिनिधित्व करने वाला 'X' भी हो सकता है।\n\nरिटर्न्स:\nएक स्ट्रिंग जो या तो \"Right\" है यदि ISBN चेकसम सही है, या सही किया गया ISBN नंबर\nउसी प्रारूप में जैसा इनपुट है यदि चेकसम गलत है।\n\nउदाहरण:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nदूसरा उदाहरण दिखाता है कि ISBN नंबर का सुधार किया गया है जहाँ चेकसम अंक '0' के बजाय '4' गणना किया गया है, इस प्रकार सही किया गया ISBN लौटाया जाता है।",
      "hu": "Ellenőrizze egy adott ISBN szám helyességét, és szükség esetén javítsa ki.\n\nA függvény ellenőrzi a megadott ISBN számot az ISBN szabvány ellenőrzőösszeg számításával szemben.\nHa az ellenőrzőösszeg helyes, a függvény \"Right\"-ot ad vissza. Ha az ellenőrzőösszeg helytelen,\na függvény a javított ISBN számot adja vissza.\n\nArgok:\nisbn: Egy karakterlánc, amely az ellenőrizendő ISBN számot képviseli. A formátum 'x-xxx-xxxxx-x' legyen,\nahol 'x' egy számjegy, és az utolsó 'x' lehet 'X' is, amely az ellenőrző számjegyet képviseli.\n\nVisszatér:\nEgy karakterlánc, amely vagy \"Right\", ha az ISBN ellenőrzőösszeg helyes, vagy a javított ISBN szám\nugyanabban a formátumban, mint a bemenet, ha az ellenőrzőösszeg helytelen.\n\nPéldák:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nA második példa bemutatja az ISBN szám javítását, ahol az ellenőrző számjegy '4'-nek van kiszámítva a megadott '0' helyett, így a javított ISBN kerül visszaadásra."
    },
    "docstring_bertscore": {
      "sq": "0.9611339933429034",
      "hy": "0.9545603208825538",
      "bn": "0.9756089837304399",
      "bg": "0.9799691192245367",
      "zh": "0.9678077755152946",
      "fr": "0.9880680743808532",
      "de": "0.9751431954869131",
      "ha": "0.9494233419682295",
      "hi": "0.9797130846633827",
      "hu": "0.9822448275000534"
    }
  },
  {
    "task_id": "Python/15",
    "prompt": {
      "en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.\n    \"\"\"",
      "sq": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis nxënësve.\n\n    Args:\n    M (int): Numri i rreshtave në klasë.\n    N (int): Numri i kolonave në klasë.\n    K (int): Numri i korridoreve horizontale për t'u shtuar.\n    L (int): Numri i korridoreve vertikale për t'u shtuar.\n    D (int): Numri i çifteve që bisedojnë në klasë.\n    chatting_pairs (list of tuples): Një listë tuples, secila që përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\n    Returns:\n    (str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indekset optimale të rreshtave dhe kolonave për korridoret.\n\n    Funksioni punon duke numëruar numrin e çifteve që bisedojnë që mund të ndahen duke shtuar një korridor në secilën pozicion të mundshëm.\n    Pastaj zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë të jetë e mundur.\n\n    Shembuj:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Kthen: ('2', '2 4'), duke treguar se vendosja e një korridori pas rreshtit 2 dhe kolonave 2 dhe 4 do të ishte optimale.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Kthen: ('2', '2'), duke treguar se vendosja e një korridori pas rreshtit 2 dhe kolonës 2 do të ishte optimale.\n    \"\"\"",
      "hy": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Օպտիմալացնել միջանցքների տեղադրումը դասարանում՝ նվազեցնելու համար ուսանողների միջև զրուցելու քանակը:\n\n    Արգումենտներ:\n    M (int): Դասարանի շարքերի քանակը:\n    N (int): Դասարանի սյուների քանակը:\n    K (int): Ավելացվող հորիզոնական միջանցքների քանակը:\n    L (int): Ավելացվող ուղղահայաց միջանցքների քանակը:\n    D (int): Դասարանում զրուցող զույգերի քանակը:\n    chatting_pairs (ցուցակ տուփերով): Տուփերի ցուցակ, որոնցից յուրաքանչյուրը պարունակում է զրուցող զույգի դիրքերը (Xi, Yi) և (Pi, Qi):\n\n    Վերադարձնում է:\n    (str, str): Երկու տարածքով բաժանված տողեր, որոնք ներկայացնում են միջանցքների օպտիմալ շարքի և սյունակի ինդեքսները:\n\n    Ֆունկցիան աշխատում է հաշվելով զրուցող զույգերի քանակը, որոնք կարող են բաժանվել՝ ավելացնելով միջանցք յուրաքանչյուր հնարավոր դիրքում:\n    Այնուհետև ընտրում է միջանցքների ամենաարդյունավետ դիրքերը՝ նպատակ ունենալով բաժանել որքան հնարավոր է շատ զրուցող զույգեր:\n\n    Օրինակներ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Վերադարձնում է: ('2', '2 4'), ցույց տալով, որ միջանցք տեղադրելը 2-րդ շարքի և 2-րդ ու 4-րդ սյունակների հետևում օպտիմալ կլինի:\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Վերադարձնում է: ('2', '2'), ցույց տալով, որ միջանցք տեղադրելը 2-րդ շարքի և 2-րդ սյունակի հետևում օպտիմալ կլինի:\n    \"\"\"",
      "bn": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    শ্রেণীকক্ষে শিক্ষার্থীদের মধ্যে আলাপচারিতা কমানোর জন্য আসন বিন্যাসের পথগুলির অবস্থান অপ্টিমাইজ করুন।\n\n    Args:\n    M (int): শ্রেণীকক্ষে সারির সংখ্যা।\n    N (int): শ্রেণীকক্ষে কলামের সংখ্যা।\n    K (int): যোগ করার জন্য অনুভূমিক পথের সংখ্যা।\n    L (int): যোগ করার জন্য উল্লম্ব পথের সংখ্যা।\n    D (int): শ্রেণীকক্ষে আলাপচারিতার জোড়ার সংখ্যা।\n    chatting_pairs (list of tuples): একটি তালিকা যা প্রতিটি জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) ধারণ করে।\n\n    Returns:\n    (str, str): দুটি স্থান-বিচ্ছিন্ন স্ট্রিং যা পথগুলির জন্য সর্বোত্তম সারি এবং কলামের সূচকগুলি উপস্থাপন করে।\n\n    ফাংশনটি প্রতিটি সম্ভাব্য অবস্থানে একটি পথ যোগ করার মাধ্যমে আলাপচারিতার জোড়াগুলিকে আলাদা করার সংখ্যা গণনা করে কাজ করে।\n    এটি তারপর পথগুলির জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব আলাপচারিতার জোড়াগুলিকে আলাদা করার লক্ষ্যে।\n\n    উদাহরণ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), যা নির্দেশ করে যে সারি 2 এবং কলাম 2 এবং 4 এর পরে একটি পথ স্থাপন করা সর্বোত্তম হবে।\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), যা নির্দেশ করে যে সারি 2 এবং কলাম 2 এর পরে একটি পথ স্থাপন করা সর্বোত্তম হবে।\n    \"\"\"",
      "bg": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството на разговорите между учениците.\n\n    Args:\n    M (int): Броят на редовете в класната стая.\n    N (int): Броят на колоните в класната стая.\n    K (int): Броят на хоризонталните пътеки, които да се добавят.\n    L (int): Броят на вертикалните пътеки, които да се добавят.\n    D (int): Броят на двойките, които разговарят в класната стая.\n    chatting_pairs (list of tuples): Списък от кортежи, всеки съдържащ позициите (Xi, Yi) и (Pi, Qi) на двойка, която разговаря.\n\n    Returns:\n    (str, str): Два низа, разделени с интервал, представляващи оптималните индекси на редовете и колоните за пътеките.\n\n    Функцията работи, като брои броя на двойките, които могат да бъдат разделени чрез добавяне на пътека във всяка възможна позиция.\n    След това избира най-ефективните позиции за пътеки, с цел да се разделят възможно най-много двойки, които разговарят.\n\n    Примери:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Връща: ('2', '2 4'), което показва, че поставянето на пътека след ред 2 и колони 2 и 4 би било оптимално.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Връща: ('2', '2'), което показва, че поставянето на пътека след ред 2 и колона 2 би било оптимално.\n    \"\"\"",
      "zh": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    优化教室中过道的布置，以尽量减少学生之间的聊天。\n\n    参数:\n    M (int): 教室中的行数。\n    N (int): 教室中的列数。\n    K (int): 要添加的水平过道数。\n    L (int): 要添加的垂直过道数。\n    D (int): 教室中聊天对的数量。\n    chatting_pairs (list of tuples): 一个包含元组的列表，每个元组包含一个聊天对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n    返回:\n    (str, str): 两个用空格分隔的字符串，表示过道的最佳行和列索引。\n\n    该函数通过计算可以通过在每个可能的位置添加过道来分隔的聊天对的数量来工作。\n    然后选择最有效的过道位置，目标是尽可能多地分隔聊天对。\n\n    例子:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    返回: ('2', '2 4')，表示在第2行和第2列及第4列后放置过道是最佳的。\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    返回: ('2', '2')，表示在第2行和第2列后放置过道是最佳的。\n    \"\"\"",
      "fr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardage entre les élèves.\n\n    Args:\n    M (int): Le nombre de rangées dans la salle de classe.\n    N (int): Le nombre de colonnes dans la salle de classe.\n    K (int): Le nombre d'allées horizontales à ajouter.\n    L (int): Le nombre d'allées verticales à ajouter.\n    D (int): Le nombre de paires bavardantes dans la salle de classe.\n    chatting_pairs (list of tuples): Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavardante.\n\n    Returns:\n    (str, str): Deux chaînes séparées par des espaces représentant les indices optimaux des rangées et colonnes pour les allées.\n\n    La fonction fonctionne en comptant le nombre de paires bavardantes qui peuvent être séparées en ajoutant une allée à chaque position possible.\n    Elle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer autant de paires bavardantes que possible.\n\n    Exemples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), indiquant que placer une allée après la rangée 2 et les colonnes 2 et 4 serait optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), indiquant que placer une allée après la rangée 2 et la colonne 2 serait optimal.\n    \"\"\"",
      "de": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimieren Sie die Platzierung von Gängen in einem Klassenzimmer, um die Menge an Gesprächen zwischen Schülern zu minimieren.\n\n    Argumente:\n    M (int): Die Anzahl der Reihen im Klassenzimmer.\n    N (int): Die Anzahl der Spalten im Klassenzimmer.\n    K (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\n    L (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\n    D (int): Die Anzahl der Gesprächspaare im Klassenzimmer.\n    chatting_pairs (Liste von Tupeln): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines Gesprächspaares enthalten.\n\n    Rückgabewerte:\n    (str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\n    Die Funktion arbeitet, indem sie die Anzahl der Gesprächspaare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\n    Anschließend wählt sie die effektivsten Positionen für Gänge aus, um möglichst viele Gesprächspaare zu trennen.\n\n    Beispiele:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Gibt zurück: ('2', '2 4'), was anzeigt, dass das Platzieren eines Gangs nach Reihe 2 und den Spalten 2 und 4 optimal wäre.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Gibt zurück: ('2', '2'), was anzeigt, dass das Platzieren eines Gangs nach Reihe 2 und Spalte 2 optimal wäre.\n    \"\"\"",
      "ha": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Inganta sanya hanyoyi a cikin aji don rage yawan hira tsakanin ɗalibai.\n\n    Args:\n    M (int): Yawan layuka a cikin aji.\n    N (int): Yawan ginshiƙai a cikin aji.\n    K (int): Yawan hanyoyi a kwance da za a ƙara.\n    L (int): Yawan hanyoyi a tsaye da za a ƙara.\n    D (int): Yawan ma'aurata masu hira a cikin aji.\n    chatting_pairs (list of tuples): Jerin tuples, kowanne yana ɗauke da wurare (Xi, Yi) da (Pi, Qi) na ma'aurata masu hira.\n\n    Returns:\n    (str, str): Haruffa guda biyu masu sarari suna wakiltar mafi kyawun layi da ginshiƙai don hanyoyin.\n\n    Aikin yana aiki ta hanyar ƙididdige yawan ma'aurata masu hira da za a iya raba ta hanyar ƙara hanya a kowane yuwuwar wuri.\n    Sannan yana zaɓar mafi kyawun wurare don hanyoyi, yana nufin raba ma'aurata masu hira da yawa gwargwadon iko.\n\n    Misalai:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), yana nuna cewa sanya hanya bayan layi na 2 da ginshiƙai na 2 da 4 zai zama mafi kyau.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), yana nuna cewa sanya hanya bayan layi na 2 da ginshiƙi na 2 zai zama mafi kyau.\n    \"\"\"",
      "hi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    कक्षा में छात्रों के बीच बातचीत की मात्रा को कम करने के लिए गलियारों की व्यवस्था को अनुकूलित करें।\n\n    Args:\n    M (int): कक्षा में पंक्तियों की संख्या।\n    N (int): कक्षा में स्तंभों की संख्या।\n    K (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\n    L (int): जोड़ने के लिए लंबवत गलियारों की संख्या।\n    D (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\n    chatting_pairs (list of tuples): एक सूची जिसमें प्रत्येक तत्व एक युग्म है, जिसमें बातचीत करने वाले जोड़े की स्थिति (Xi, Yi) और (Pi, Qi) होती है।\n\n    Returns:\n    (str, str): दो स्पेस सेपरेटेड स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक का प्रतिनिधित्व करती हैं।\n\n    यह फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करके काम करता है।\n    फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जिसका उद्देश्य जितना संभव हो सके उतने बातचीत करने वाले जोड़ों को अलग करना है।\n\n    उदाहरण:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), यह इंगित करता है कि पंक्ति 2 और स्तंभ 2 और 4 के बाद गलियारा रखना अनुकूल होगा।\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), यह इंगित करता है कि पंक्ति 2 और स्तंभ 2 के बाद गलियारा रखना अनुकूल होगा।\n    \"\"\"",
      "hu": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimalizálja a folyosók elhelyezését egy osztályteremben annak érdekében, hogy minimalizálja a diákok közötti beszélgetések mennyiségét.\n\n    Args:\n    M (int): Az osztályterem sorainak száma.\n    N (int): Az osztályterem oszlopainak száma.\n    K (int): A hozzáadandó vízszintes folyosók száma.\n    L (int): A hozzáadandó függőleges folyosók száma.\n    D (int): A beszélgető párok száma az osztályteremben.\n    chatting_pairs (list of tuples): Egy lista, amely minden egyes beszélgető pár pozícióját (Xi, Yi) és (Pi, Qi) tartalmazza.\n\n    Returns:\n    (str, str): Két szóközzel elválasztott karakterlánc, amelyek a folyosók optimális sor- és oszlopindexeit képviselik.\n\n    A függvény úgy működik, hogy megszámolja a beszélgető párokat, amelyeket el lehet választani egy folyosó hozzáadásával minden lehetséges pozícióban.\n    Ezután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy a lehető legtöbb beszélgető párt elválassza.\n\n    Példák:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Visszatér: ('2', '2 4'), ami azt jelzi, hogy a 2. sor és a 2. és 4. oszlop után elhelyezett folyosó lenne optimális.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Visszatér: ('2', '2'), ami azt jelzi, hogy a 2. sor és a 2. oszlop után elhelyezett folyosó lenne optimális.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9488582385341853",
      "hy": "0.9492767527470258",
      "bn": "0.926362354730079",
      "bg": "0.9689864481963557",
      "zh": "0.9555830687145025",
      "fr": "0.988995280999524",
      "de": "0.9840624941169037",
      "ha": "0.947291243458201",
      "hi": "0.9672017542227572",
      "hu": "0.9746507907723275"
    },
    "canonical_solution": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)",
    "instruction": {
      "en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.8825850132715138",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9174422615785642",
      "hi": "0.91110952777041",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_optimize_seating():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ntest_optimize_seating()",
    "entry_point": "optimize_seating",
    "signature": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):",
    "docstring": {
      "en": "Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\nArgs:\nM (int): The number of rows in the classroom.\nN (int): The number of columns in the classroom.\nK (int): The number of horizontal aisles to add.\nL (int): The number of vertical aisles to add.\nD (int): The number of chatting pairs in the classroom.\nchatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\nReturns:\n(str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\nThe function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\nIt then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.",
      "sq": "Optimizoni vendosjen e korridoreve në një klasë për të minimizuar sasinë e bisedave midis studentëve.\n\nArgumentet:\nM (int): Numri i rreshtave në klasë.\nN (int): Numri i kolonave në klasë.\nK (int): Numri i korridoreve horizontale për të shtuar.\nL (int): Numri i korridoreve vertikale për të shtuar.\nD (int): Numri i çifteve që bisedojnë në klasë.\nchatting_pairs (list of tuples): Një listë tuples, secila që përmban pozicionet (Xi, Yi) dhe (Pi, Qi) të një çifti që bisedon.\n\nKthen:\n(str, str): Dy vargje të ndara me hapësirë që përfaqësojnë indeksat optimalë të rreshtave dhe kolonave për korridoret.\n\nFunksioni punon duke numëruar numrin e çifteve që bisedojnë që mund të ndahen duke shtuar një korridor në secilën pozicion të mundshëm.\nPastaj zgjedh pozicionet më efektive për korridoret, duke synuar të ndajë sa më shumë çifte që bisedojnë të jetë e mundur.\n\nShembuj:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nKthen: ('2', '2 4'), duke treguar se vendosja e një korridori pas rreshtit 2 dhe kolonave 2 dhe 4 do të ishte optimale.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nKthen: ('2', '2'), duke treguar se vendosja e një korridori pas rreshtit 2 dhe kolonës 2 do të ishte optimale.",
      "hy": "Դասարանում անցուղիների տեղադրումը օպտիմալացնել՝ նվազեցնելու ուսանողների միջև զրույցների քանակը:\n\nԱրգումենտներ:\nM (int): Դասարանի շարքերի քանակը:\nN (int): Դասարանի սյուների քանակը:\nK (int): Ավելացվող հորիզոնական անցուղիների քանակը:\nL (int): Ավելացվող ուղղահայաց անցուղիների քանակը:\nD (int): Դասարանում զրուցող զույգերի քանակը:\nchatting_pairs (ցանկ տուփլերի): Տուփլերի ցանկ, որոնցից յուրաքանչյուրը պարունակում է զրուցող զույգի դիրքերը (Xi, Yi) և (Pi, Qi):\n\nՎերադարձնում է:\n(str, str): Երկու բացատով բաժանված տողեր, որոնք ներկայացնում են անցուղիների օպտիմալ շարքի և սյունակի ինդեքսները:\n\nՖունկցիան աշխատում է՝ հաշվելով զրուցող զույգերի քանակը, որոնք կարող են բաժանվել՝ յուրաքանչյուր հնարավոր դիրքում անցուղի ավելացնելով:\nԱյնուհետև ընտրում է անցուղիների ամենաարդյունավետ դիրքերը՝ նպատակ ունենալով բաժանել որքան հնարավոր է շատ զրուցող զույգեր:\n\nՕրինակներ:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nՎերադարձնում է: ('2', '2 4'), որը ցույց է տալիս, որ 2-րդ շարքից և 2 և 4 սյուներից հետո անցուղի տեղադրելը օպտիմալ կլինի:\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nՎերադարձնում է: ('2', '2'), որը ցույց է տալիս, որ 2-րդ շարքից և 2-րդ սյունից հետո անցուղի տեղադրելը օպտիմալ կլինի:",
      "bn": "শ্রেণীকক্ষে আইলগুলির অবস্থান অপ্টিমাইজ করুন যাতে শিক্ষার্থীদের মধ্যে আলাপচারিতা কমানো যায়।\n\nআর্গস:\nM (int): শ্রেণীকক্ষে সারির সংখ্যা।\nN (int): শ্রেণীকক্ষে কলামের সংখ্যা।\nK (int): যোগ করার জন্য অনুভূমিক আইলের সংখ্যা।\nL (int): যোগ করার জন্য উল্লম্ব আইলের সংখ্যা।\nD (int): শ্রেণীকক্ষে আলাপচারিতার জোড়ার সংখ্যা।\nchatting_pairs (list of tuples): একটি তালিকা যার প্রতিটি টুপলে একটি আলাপচারিতার জোড়ার অবস্থান (Xi, Yi) এবং (Pi, Qi) অন্তর্ভুক্ত।\n\nরিটার্নস:\n(str, str): দুটি স্পেস-আলাদা স্ট্রিং যা আইলগুলির জন্য সর্বোত্তম সারি এবং কলামের সূচকগুলি উপস্থাপন করে।\n\nএই ফাংশনটি প্রতিটি সম্ভাব্য অবস্থানে একটি আইল যোগ করার মাধ্যমে কতগুলি আলাপচারিতার জোড়া আলাদা করা যেতে পারে তা গণনা করে কাজ করে।\nএরপর এটি আইলগুলির জন্য সবচেয়ে কার্যকর অবস্থানগুলি নির্বাচন করে, যতটা সম্ভব আলাপচারিতার জোড়া আলাদা করার লক্ষ্য নিয়ে।\n\nউদাহরণ:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nরিটার্নস: ('2', '2 4'), যা নির্দেশ করে যে সারি 2 এবং কলাম 2 এবং 4 এর পরে একটি আইল স্থাপন করা সর্বোত্তম হবে।\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nরিটার্নস: ('2', '2'), যা নির্দেশ করে যে সারি 2 এবং কলাম 2 এর পরে একটি আইল স্থাপন করা সর্বোত্তম হবে।",
      "bg": "Оптимизирайте разположението на пътеките в класната стая, за да минимизирате количеството разговори между учениците.\n\nАргументи:\nM (int): Броят на редовете в класната стая.\nN (int): Броят на колоните в класната стая.\nK (int): Броят на хоризонталните пътеки за добавяне.\nL (int): Броят на вертикалните пътеки за добавяне.\nD (int): Броят на двойките, които разговарят в класната стая.\nchatting_pairs (списък от кортежи): Списък от кортежи, всеки от които съдържа позициите (Xi, Yi) и (Pi, Qi) на двойка, която разговаря.\n\nВръща:\n(str, str): Два разделени с интервал низа, представляващи оптималните индекси на редовете и колоните за пътеките.\n\nФункцията работи, като брои броя на двойките, които разговарят и които могат да бъдат разделени чрез добавяне на пътека на всяка възможна позиция.\nСлед това избира най-ефективните позиции за пътеки, с цел да раздели възможно най-много двойки, които разговарят.\n\nПримери:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nВръща: ('2', '2 4'), което означава, че поставянето на пътека след ред 2 и колони 2 и 4 би било оптимално.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nВръща: ('2', '2'), което означава, че поставянето на пътека след ред 2 и колона 2 би било оптимално.",
      "zh": "优化教室中走道的布局，以最小化学生之间的聊天量。\n\n参数：\nM (int): 教室中的行数。\nN (int): 教室中的列数。\nK (int): 要添加的水平走道数量。\nL (int): 要添加的垂直走道数量。\nD (int): 教室中聊天对的数量。\nchatting_pairs (list of tuples): 一个元组列表，每个元组包含一个聊天对的位置 (Xi, Yi) 和 (Pi, Qi)。\n\n返回：\n(str, str): 两个以空格分隔的字符串，表示走道的最佳行和列索引。\n\n该函数通过计算可以通过在每个可能位置添加走道来分隔的聊天对数量来工作。\n然后选择最有效的走道位置，旨在尽可能多地分隔聊天对。\n\n示例：\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n返回: ('2', '2 4')，表示在第2行之后和第2列及第4列之后放置走道是最佳选择。\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n返回: ('2', '2')，表示在第2行之后和第2列之后放置走道是最佳选择。",
      "fr": "Optimiser le placement des allées dans une salle de classe pour minimiser la quantité de bavardage entre les étudiants.\n\nArgs:\nM (int): Le nombre de rangées dans la salle de classe.\nN (int): Le nombre de colonnes dans la salle de classe.\nK (int): Le nombre d'allées horizontales à ajouter.\nL (int): Le nombre d'allées verticales à ajouter.\nD (int): Le nombre de paires bavardes dans la salle de classe.\nchatting_pairs (list of tuples): Une liste de tuples, chacun contenant les positions (Xi, Yi) et (Pi, Qi) d'une paire bavarde.\n\nReturns:\n(str, str): Deux chaînes séparées par des espaces représentant les indices optimaux des rangées et colonnes pour les allées.\n\nLa fonction fonctionne en comptant le nombre de paires bavardes qui peuvent être séparées en ajoutant une allée à chaque position possible.\nElle sélectionne ensuite les positions les plus efficaces pour les allées, visant à séparer autant de paires bavardes que possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indiquant que placer une allée après la rangée 2 et les colonnes 2 et 4 serait optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indiquant que placer une allée après la rangée 2 et la colonne 2 serait optimal.",
      "de": "Optimieren Sie die Platzierung von Gängen in einem Klassenzimmer, um die Menge an Gesprächen zwischen Schülern zu minimieren.\n\nArgs:\nM (int): Die Anzahl der Reihen im Klassenzimmer.\nN (int): Die Anzahl der Spalten im Klassenzimmer.\nK (int): Die Anzahl der hinzuzufügenden horizontalen Gänge.\nL (int): Die Anzahl der hinzuzufügenden vertikalen Gänge.\nD (int): Die Anzahl der plaudernden Paare im Klassenzimmer.\nchatting_pairs (list of tuples): Eine Liste von Tupeln, die jeweils die Positionen (Xi, Yi) und (Pi, Qi) eines plaudernden Paares enthalten.\n\nReturns:\n(str, str): Zwei durch Leerzeichen getrennte Zeichenfolgen, die die optimalen Reihen- und Spaltenindizes für die Gänge darstellen.\n\nDie Funktion arbeitet, indem sie die Anzahl der plaudernden Paare zählt, die durch das Hinzufügen eines Gangs an jeder möglichen Position getrennt werden können.\nAnschließend wählt sie die effektivsten Positionen für Gänge aus, um möglichst viele plaudernde Paare zu trennen.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), was anzeigt, dass das Platzieren eines Gangs nach Reihe 2 und den Spalten 2 und 4 optimal wäre.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), was anzeigt, dass das Platzieren eines Gangs nach Reihe 2 und Spalte 2 optimal wäre.",
      "ha": "Inganta wuraren da aka sanya hanyoyin a cikin aji don rage yawan hira tsakanin ɗalibai.\n\nArgs:\nM (int): Yawan layuka a cikin aji.\nN (int): Yawan ginshiƙai a cikin aji.\nK (int): Yawan hanyoyin kwance da za a ƙara.\nL (int): Yawan hanyoyin tsaye da za a ƙara.\nD (int): Yawan ma'auratan hira a cikin aji.\nchatting_pairs (jerin tuples): Jerin tuples, kowanne yana ɗauke da wuraren (Xi, Yi) da (Pi, Qi) na ma'auratan hira.\n\nReturns:\n(str, str): Kalmomi biyu da aka raba da sarari suna wakiltar mafi kyawun layi da ginshiƙai don hanyoyin.\n\nAikin yana aiki ta hanyar ƙidaya yawan ma'auratan hira da za a iya raba ta hanyar ƙara hanya a kowane matsayi mai yiwuwa.\nSannan yana zaɓar mafi ingantattun wurare don hanyoyin, yana nufin raba yawan ma'auratan hira kamar yadda zai yiwu.\n\nMisalai:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), yana nuna cewa sanya hanya bayan layi na 2 da ginshiƙai na 2 da 4 zai zama mafi kyau.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), yana nuna cewa sanya hanya bayan layi na 2 da ginshiƙi na 2 zai zama mafi kyau.",
      "hi": "कक्षा में गलियारों के स्थान को इस प्रकार अनुकूलित करें कि छात्रों के बीच बातचीत की मात्रा न्यूनतम हो सके।\n\nआर्ग्स:\nM (int): कक्षा में पंक्तियों की संख्या।\nN (int): कक्षा में स्तंभों की संख्या।\nK (int): जोड़ने के लिए क्षैतिज गलियारों की संख्या।\nL (int): जोड़ने के लिए लंबवत गलियारों की संख्या।\nD (int): कक्षा में बातचीत करने वाले जोड़ों की संख्या।\nchatting_pairs (list of tuples): ट्यूपल्स की एक सूची, जिसमें प्रत्येक में बातचीत करने वाले जोड़े की स्थिति (Xi, Yi) और (Pi, Qi) होती है।\n\nरिटर्न्स:\n(str, str): दो स्पेस से अलग किए गए स्ट्रिंग्स जो गलियारों के लिए अनुकूलतम पंक्ति और स्तंभ सूचकांक का प्रतिनिधित्व करते हैं।\n\nयह फ़ंक्शन प्रत्येक संभावित स्थिति में गलियारा जोड़कर अलग किए जा सकने वाले बातचीत करने वाले जोड़ों की संख्या की गणना करता है। फिर यह गलियारों के लिए सबसे प्रभावी स्थानों का चयन करता है, जिसका उद्देश्य जितना संभव हो उतने बातचीत करने वाले जोड़ों को अलग करना है।\n\nउदाहरण:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nरिटर्न करता है: ('2', '2 4'), जो इंगित करता है कि पंक्ति 2 के बाद और स्तंभ 2 और 4 के बाद गलियारा रखना अनुकूलतम होगा।\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nरिटर्न करता है: ('2', '2'), जो इंगित करता है कि पंक्ति 2 के बाद और स्तंभ 2 के बाद गलियारा रखना अनुकूलतम होगा।",
      "hu": "Optimalizálja a folyosók elhelyezését egy tanteremben, hogy minimalizálja a diákok közötti beszélgetések mennyiségét.\n\nArgs:\nM (int): A tanterem sorainak száma.\nN (int): A tanterem oszlopainak száma.\nK (int): A hozzáadandó vízszintes folyosók száma.\nL (int): A hozzáadandó függőleges folyosók száma.\nD (int): A tanteremben lévő beszélgető párok száma.\nchatting_pairs (list of tuples): Egy listája a tuple-öknek, amelyek mindegyike tartalmazza egy beszélgető pár pozícióit (Xi, Yi) és (Pi, Qi).\n\nReturns:\n(str, str): Két szóközzel elválasztott karakterlánc, amelyek a folyosók optimális sor- és oszlopindexeit képviselik.\n\nA függvény úgy működik, hogy megszámolja a beszélgető párok számát, amelyeket el lehet választani egy folyosó hozzáadásával minden lehetséges pozícióban.\nEzután kiválasztja a leghatékonyabb pozíciókat a folyosók számára, azzal a céllal, hogy a lehető legtöbb beszélgető párt elválassza.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), ami azt jelzi, hogy a 2. sor és a 2. és 4. oszlop után elhelyezett folyosó optimális lenne.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), ami azt jelzi, hogy a 2. sor és a 2. oszlop után elhelyezett folyosó optimális lenne."
    },
    "docstring_bertscore": {
      "sq": "0.9654067314693449",
      "hy": "0.9181958652442106",
      "bn": "0.9494579036545296",
      "bg": "0.9367942237116503",
      "zh": "0.9487962658553024",
      "fr": "0.9716536569528922",
      "de": "0.9917409487565694",
      "ha": "0.9326690679583177",
      "hi": "0.9512086318329711",
      "hu": "0.9654778411457554"
    }
  },
  {
    "task_id": "Python/16",
    "prompt": {
      "en": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    Case 1:\n    For n = 3 students and m = 3 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\n    Case 2:\n    For n = 4 students and m = 2 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\n    Case 3:\n    For n = 5 students and m = 4 passes, the function should return 6.\n    The sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    and 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # The code implementation would go here.",
      "sq": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Numëron numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve të rregulluar në një rreth\n    në mënyrë që pas 'm' kalimesh, topi të kthehet te studenti fillestar.\n\n    Funksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të kalimit. Çdo student\n    mund ta kalojë topin ose te fqinji i majtë ose te fqinji i djathtë.\n\n    Argumentet:\n    n: Numri i studentëve që qëndrojnë në një rreth.\n    m: Numri i herëve që topi kalohet.\n\n    Kthen:\n    Një numër i plotë që përfaqëson numrin e mënyrave të dallueshme të kalimit që rezultojnë në kthimin e topit\n    te studenti fillestar pas 'm' kalimesh.\n\n    Rastet:\n    Rasti 1:\n    Për n = 3 studentë dhe m = 3 kalime, funksioni duhet të kthejë 2.\n    Ka dy sekuenca: 1 -> 2 -> 3 -> 1 dhe 1 -> 3 -> 2 -> 1.\n\n    Rasti 2:\n    Për n = 4 studentë dhe m = 2 kalime, funksioni duhet të kthejë 2.\n    Ka dy sekuenca: 1 -> 2 -> 1 dhe 1 -> 4 -> 1.\n\n    Rasti 3:\n    Për n = 5 studentë dhe m = 4 kalime, funksioni duhet të kthejë 6.\n    Sekuencat përfshijnë: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    dhe 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Implementimi i kodit do të shkojë këtu.",
      "hy": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Հաշվում է գնդակը 'n' ուսանողների միջև շրջանաձև դասավորված փոխանցելու տարբեր եղանակների քանակը,\n    այնպես, որ 'm' փոխանցումից հետո գնդակը վերադառնա մեկնարկային ուսանողին։\n\n    Ֆունկցիան օգտագործում է դինամիկ ծրագրավորում՝ փոխանցման հաջորդականությունների քանակը որոշելու համար։ \n    Յուրաքանչյուր ուսանող կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին։\n\n    Պարամետրեր:\n    n: Ուսանողների քանակը, որոնք կանգնած են շրջանաձև։\n    m: Գնդակի փոխանցումների քանակը։\n\n    Վերադարձնում է:\n    Թվային արժեք, որը ներկայացնում է փոխանցման տարբեր եղանակների քանակը, \n    որոնք հանգեցնում են նրան, որ գնդակը 'm' փոխանցումից հետո վերադառնա մեկնարկային ուսանողին։\n\n    Դեպքեր:\n    Դեպք 1:\n    n = 3 ուսանողների և m = 3 փոխանցումների դեպքում ֆունկցիան պետք է վերադարձնի 2։\n    Կան երկու հաջորդականություններ՝ 1 -> 2 -> 3 -> 1 և 1 -> 3 -> 2 -> 1։\n\n    Դեպք 2:\n    n = 4 ուսանողների և m = 2 փոխանցումների դեպքում ֆունկցիան պետք է վերադարձնի 2։\n    Կան երկու հաջորդականություններ՝ 1 -> 2 -> 1 և 1 -> 4 -> 1։\n\n    Դեպք 3:\n    n = 5 ուսանողների և m = 4 փոխանցումների դեպքում ֆունկցիան պետք է վերադարձնի 6։\n    Հաջորդականությունները ներառում են՝ 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    և 1 -> 4 -> 5 -> 2 -> 1։\n    \"\"\"\n    # Այստեղ կգրվի կոդի իրականացումը։",
      "bn": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' জন ছাত্রদের একটি বৃত্তে সাজানো অবস্থায় বলটি পাস করার বিভিন্ন উপায়ের সংখ্যা গণনা করে \n    যাতে 'm' বার পাস করার পর, বলটি শুরু ছাত্রের কাছে ফিরে আসে।\n\n    ফাংশনটি বল পাস করার ক্রমগুলির সংখ্যা নির্ধারণ করতে ডাইনামিক প্রোগ্রামিং ব্যবহার করে। প্রতিটি ছাত্র\n    বলটি হয় বাম পাশের প্রতিবেশীকে বা ডান পাশের প্রতিবেশীকে পাস করতে পারে।\n\n    Args:\n    n: বৃত্তে দাঁড়িয়ে থাকা ছাত্রদের সংখ্যা।\n    m: বলটি পাস করার সংখ্যা।\n\n    Returns:\n    একটি পূর্ণসংখ্যা যা বলের শুরু ছাত্রের কাছে 'm' বার পাস করার পর ফিরে আসার জন্য \n    বিভিন্ন পাসিং উপায়ের সংখ্যা উপস্থাপন করে।\n\n    কেসসমূহ:\n    কেস 1:\n    n = 3 ছাত্র এবং m = 3 পাসের জন্য, ফাংশনটি 2 ফেরত দেবে।\n    দুটি ক্রম রয়েছে: 1 -> 2 -> 3 -> 1 এবং 1 -> 3 -> 2 -> 1।\n\n    কেস 2:\n    n = 4 ছাত্র এবং m = 2 পাসের জন্য, ফাংশনটি 2 ফেরত দেবে।\n    দুটি ক্রম রয়েছে: 1 -> 2 -> 1 এবং 1 -> 4 -> 1।\n\n    কেস 3:\n    n = 5 ছাত্র এবং m = 4 পাসের জন্য, ফাংশনটি 6 ফেরত দেবে।\n    ক্রমগুলির মধ্যে রয়েছে: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    এবং 1 -> 4 -> 5 -> 2 -> 1।\n    \"\"\"\n    # কোড বাস্তবায়ন এখানে যাবে।",
      "bg": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Брои броя на различните начини за подаване на топка между 'n' ученици, подредени в кръг,\n    така че след 'm' подавания топката да се върне при началния ученик.\n\n    Функцията използва динамично програмиране, за да определи броя на последователностите на подаване. Всеки ученик\n    може да подаде топката или на левия съсед, или на десния съсед.\n\n    Аргументи:\n    n: Броят на учениците, стоящи в кръг.\n    m: Броят на пъти, когато топката се подава.\n\n    Връща:\n    Цяло число, представляващо броя на различните начини на подаване, които водят до това\n    топката да се върне при началния ученик след 'm' подавания.\n\n    Случаи:\n    Случай 1:\n    За n = 3 ученици и m = 3 подавания, функцията трябва да върне 2.\n    Има две последователности: 1 -> 2 -> 3 -> 1 и 1 -> 3 -> 2 -> 1.\n\n    Случай 2:\n    За n = 4 ученици и m = 2 подавания, функцията трябва да върне 2.\n    Има две последователности: 1 -> 2 -> 1 и 1 -> 4 -> 1.\n\n    Случай 3:\n    За n = 5 ученици и m = 4 подавания, функцията трябва да върне 6.\n    Последователностите включват: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    и 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # The code implementation would go here.",
      "zh": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    计算在'n'个学生围成的圈中传球的不同方式数量，使得经过'm'次传球后，球返回到起始学生。\n\n    该函数使用动态规划来确定传球序列的数量。每个学生可以将球传给左边的邻居或右边的邻居。\n\n    参数:\n    n: 围成一圈的学生数量。\n    m: 球被传递的次数。\n\n    返回:\n    一个整数，表示在'm'次传球后球返回到起始学生的不同传球方式的数量。\n\n    情况:\n    情况 1:\n    对于 n = 3 个学生和 m = 3 次传球，函数应返回 2。\n    有两种序列：1 -> 2 -> 3 -> 1 和 1 -> 3 -> 2 -> 1。\n\n    情况 2:\n    对于 n = 4 个学生和 m = 2 次传球，函数应返回 2。\n    有两种序列：1 -> 2 -> 1 和 1 -> 4 -> 1。\n\n    情况 3:\n    对于 n = 5 个学生和 m = 4 次传球，函数应返回 6。\n    序列包括：1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    和 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # 代码实现将在这里编写。",
      "fr": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Compte le nombre de façons différentes de faire passer un ballon parmi 'n' étudiants disposés en cercle\n    de telle sorte qu'après 'm' passes, le ballon retourne à l'étudiant de départ.\n\n    La fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\n    peut passer le ballon soit au voisin de gauche, soit au voisin de droite.\n\n    Args:\n    n: Le nombre d'étudiants se tenant en cercle.\n    m: Le nombre de fois que le ballon est passé.\n\n    Returns:\n    Un entier représentant le nombre de façons distinctes de passer le ballon qui aboutissent à ce que le ballon\n    retourne à l'étudiant de départ après 'm' passes.\n\n    Cas:\n    Cas 1:\n    Pour n = 3 étudiants et m = 3 passes, la fonction doit retourner 2.\n    Il y a deux séquences : 1 -> 2 -> 3 -> 1 et 1 -> 3 -> 2 -> 1.\n\n    Cas 2:\n    Pour n = 4 étudiants et m = 2 passes, la fonction doit retourner 2.\n    Il y a deux séquences : 1 -> 2 -> 1 et 1 -> 4 -> 1.\n\n    Cas 3:\n    Pour n = 5 étudiants et m = 4 passes, la fonction doit retourner 6.\n    Les séquences incluent : 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    et 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # L'implémentation du code irait ici.",
      "de": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern, die im Kreis stehen, \n    so zu passen, dass nach 'm' Pässen der Ball zum startenden Schüler zurückkehrt.\n\n    Die Funktion verwendet dynamische Programmierung, um die Anzahl der Passsequenzen zu bestimmen. Jeder Schüler\n    kann den Ball entweder an den linken oder den rechten Nachbarn weitergeben.\n\n    Argumente:\n    n: Die Anzahl der Schüler, die im Kreis stehen.\n    m: Die Anzahl der Male, die der Ball gepasst wird.\n\n    Rückgabe:\n    Eine ganze Zahl, die die Anzahl der unterschiedlichen Passmöglichkeiten darstellt, bei denen der Ball\n    nach 'm' Pässen zum startenden Schüler zurückkehrt.\n\n    Fälle:\n    Fall 1:\n    Für n = 3 Schüler und m = 3 Pässe sollte die Funktion 2 zurückgeben.\n    Es gibt zwei Sequenzen: 1 -> 2 -> 3 -> 1 und 1 -> 3 -> 2 -> 1.\n\n    Fall 2:\n    Für n = 4 Schüler und m = 2 Pässe sollte die Funktion 2 zurückgeben.\n    Es gibt zwei Sequenzen: 1 -> 2 -> 1 und 1 -> 4 -> 1.\n\n    Fall 3:\n    Für n = 5 Schüler und m = 4 Pässe sollte die Funktion 6 zurückgeben.\n    Die Sequenzen umfassen: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    und 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Die Code-Implementierung würde hier erfolgen.",
      "ha": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Yana ƙidaya adadin hanyoyin daban-daban na wuce ƙwallo tsakanin 'n' ɗalibai da aka tsara a cikin \n    da'ira ta yadda bayan 'm' wucewa, ƙwallon zai koma ga ɗalibin da ya fara.\n\n    Aikin yana amfani da shirye-shiryen motsi don tantance adadin jerin wucewa. Kowane ɗalibi\n    na iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\n    Args:\n    n: Adadin ɗalibai da ke tsaye a cikin da'ira.\n    m: Adadin lokutan da aka wuce ƙwallon.\n\n    Returns:\n    Lamba mai nuna adadin hanyoyin wucewa daban-daban da ke haifar da ƙwallon\n    dawowa ga ɗalibin da ya fara bayan 'm' wucewa.\n\n    Lokuta:\n    Lokaci 1:\n    Ga n = 3 ɗalibai da m = 3 wucewa, aikin ya kamata ya dawo da 2.\n    Akwai jerin guda biyu: 1 -> 2 -> 3 -> 1 da 1 -> 3 -> 2 -> 1.\n\n    Lokaci 2:\n    Ga n = 4 ɗalibai da m = 2 wucewa, aikin ya kamata ya dawo da 2.\n    Akwai jerin guda biyu: 1 -> 2 -> 1 da 1 -> 4 -> 1.\n\n    Lokaci 3:\n    Ga n = 5 ɗalibai da m = 4 wucewa, aikin ya kamata ya dawo da 6.\n    Jerin sun haɗa da: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    da 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Anan za a sanya aiwatar da lambar.",
      "hi": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' छात्रों के बीच एक गोला पास करने के विभिन्न तरीकों की संख्या गिनता है \n    ताकि 'm' पास के बाद, गोला प्रारंभिक छात्र के पास वापस आ जाए।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके पासिंग अनुक्रमों की संख्या निर्धारित करता है। प्रत्येक छात्र\n    गोला या तो बाएँ पड़ोसी को या दाएँ पड़ोसी को पास कर सकता है।\n\n    तर्क:\n    n: एक वृत्त में खड़े छात्रों की संख्या।\n    m: गोला पास करने की संख्या।\n\n    लौटाता है:\n    एक पूर्णांक जो गोला पास करने के विशिष्ट तरीकों की संख्या का प्रतिनिधित्व करता है\n    जो 'm' पास के बाद प्रारंभिक छात्र के पास वापस आता है।\n\n    मामले:\n    मामला 1:\n    n = 3 छात्रों और m = 3 पास के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\n    दो अनुक्रम हैं: 1 -> 2 -> 3 -> 1 और 1 -> 3 -> 2 -> 1।\n\n    मामला 2:\n    n = 4 छात्रों और m = 2 पास के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\n    दो अनुक्रम हैं: 1 -> 2 -> 1 और 1 -> 4 -> 1।\n\n    मामला 3:\n    n = 5 छात्रों और m = 4 पास के लिए, फ़ंक्शन को 6 लौटाना चाहिए।\n    अनुक्रमों में शामिल हैं: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    और 1 -> 4 -> 5 -> 2 -> 1।\n    \"\"\"\n    # यहाँ कोड कार्यान्वयन होगा।",
      "hu": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Megszámolja, hány különböző módon lehet egy labdát passzolni 'n' diák között, akik körben állnak úgy,\n    hogy 'm' passz után a labda visszatér a kiindulási diákhoz.\n\n    A függvény dinamikus programozást használ a passzolási sorozatok számának meghatározásához. Minden diák\n    vagy a bal szomszédjának, vagy a jobb szomszédjának adhatja tovább a labdát.\n\n    Args:\n    n: A körben álló diákok száma.\n    m: A labda passzolásának száma.\n\n    Returns:\n    Egy egész szám, amely a különböző passzolási módok számát jelenti, amelyek eredményeként a labda\n    'm' passz után visszatér a kiindulási diákhoz.\n\n    Esetek:\n    1. eset:\n    Ha n = 3 diák és m = 3 passz, a függvénynek 2-t kell visszaadnia.\n    Két sorozat van: 1 -> 2 -> 3 -> 1 és 1 -> 3 -> 2 -> 1.\n\n    2. eset:\n    Ha n = 4 diák és m = 2 passz, a függvénynek 2-t kell visszaadnia.\n    Két sorozat van: 1 -> 2 -> 1 és 1 -> 4 -> 1.\n\n    3. eset:\n    Ha n = 5 diák és m = 4 passz, a függvénynek 6-ot kell visszaadnia.\n    A sorozatok közé tartozik: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    és 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # A kód megvalósítása itt lenne."
    },
    "prompt_bertscore": {
      "sq": "0.99512104195064",
      "hy": "0.9645347440966018",
      "bn": "0.9802428318896028",
      "bg": "0.9919087914285438",
      "zh": "0.95570542502922",
      "fr": "0.9892777334013557",
      "de": "0.9687447150226361",
      "ha": "0.9892453566492471",
      "hi": "0.9612803839337262",
      "hu": "0.9656605810963075"
    },
    "canonical_solution": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]",
    "instruction": {
      "en": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nBada takaitaccen bayanin harshen halitta (docstring) na lambar Python cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9353182013501801",
      "hy": "0.8856909965397564",
      "bn": "0.8825850132715138",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9322515468973824",
      "hi": "0.9109764454151166",
      "hu": "0.9412719483913198"
    },
    "level": "",
    "test": "def test_count_passing_ways():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_count_passing_ways()",
    "entry_point": "count_passing_ways",
    "signature": "def count_passing_ways(n: int, m: int) -> int:",
    "docstring": {
      "en": "Counts the number of different ways to pass a ball among 'n' students arranged in a circle\nsuch that after 'm' passes, the ball returns to the starting student.\n\nThe function uses dynamic programming to determine the number of passing sequences. Each student\ncan pass the ball either to the left neighbor or to the right neighbor.\n\nArgs:\nn: The number of students standing in a circle.\nm: The number of times the ball is passed.\n\nReturns:\nAn integer representing the number of distinct passing ways that result in the ball\nreturning to the starting student after 'm' passes.\n\nCases:\nCase 1:\nFor n = 3 students and m = 3 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\nCase 2:\nFor n = 4 students and m = 2 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\nCase 3:\nFor n = 5 students and m = 4 passes, the function should return 6.\nThe sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nand 1 -> 4 -> 5 -> 2 -> 1.",
      "sq": "Numëron numrin e mënyrave të ndryshme për të kaluar një top midis 'n' studentëve të rregulluar në një rreth\ntë tillë që pas 'm' kalimesh, topi të kthehet te studenti fillestar.\n\nFunksioni përdor programimin dinamik për të përcaktuar numrin e sekuencave të kalimit. Çdo student\nmund ta kalojë topin ose te fqinji në të majtë ose te fqinji në të djathtë.\n\nArgs:\nn: Numri i studentëve që qëndrojnë në një rreth.\nm: Numri i herëve që topi kalohet.\n\nReturns:\nNjë numër i plotë që përfaqëson numrin e mënyrave të veçanta të kalimit që rezultojnë në\nkthimin e topit te studenti fillestar pas 'm' kalimesh.\n\nCases:\nRasti 1:\nPër n = 3 studentë dhe m = 3 kalime, funksioni duhet të kthejë 2.\nKa dy sekuenca: 1 -> 2 -> 3 -> 1 dhe 1 -> 3 -> 2 -> 1.\n\nRasti 2:\nPër n = 4 studentë dhe m = 2 kalime, funksioni duhet të kthejë 2.\nKa dy sekuenca: 1 -> 2 -> 1 dhe 1 -> 4 -> 1.\n\nRasti 3:\nPër n = 5 studentë dhe m = 4 kalime, funksioni duhet të kthejë 6.\nSekuencat përfshijnë: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\ndhe 1 -> 4 -> 5 -> 2 -> 1.",
      "hy": "Հաշվում է գնդակը 'n' ուսանողների միջև շրջանաձև դասավորված փոխանցելու տարբեր եղանակների քանակը այնպես, որ 'm' փոխանցումներից հետո գնդակը վերադառնա մեկնարկային ուսանողին:\n\nՖունկցիան օգտագործում է դինամիկ ծրագրավորում՝ փոխանցման հաջորդականությունների քանակը որոշելու համար։ Յուրաքանչյուր ուսանող կարող է գնդակը փոխանցել կամ ձախ հարևանին, կամ աջ հարևանին։\n\nԱրգումենտներ:\nn: Շրջանաձև կանգնած ուսանողների քանակը։\nm: Գնդակի փոխանցման քանակը։\n\nՎերադարձնում է:\nԱմբողջ թիվ, որը ներկայացնում է փոխանցման տարբեր եղանակների քանակը, որոնց արդյունքում գնդակը 'm' փոխանցումներից հետո վերադառնում է մեկնարկային ուսանողին։\n\nԴեպքեր:\nԴեպք 1:\nԵրբ n = 3 ուսանող և m = 3 փոխանցում, ֆունկցիան պետք է վերադարձնի 2։\nԿան երկու հաջորդականություններ՝ 1 -> 2 -> 3 -> 1 և 1 -> 3 -> 2 -> 1։\n\nԴեպք 2:\nԵրբ n = 4 ուսանող և m = 2 փոխանցում, ֆունկցիան պետք է վերադարձնի 2։\nԿան երկու հաջորդականություններ՝ 1 -> 2 -> 1 և 1 -> 4 -> 1։\n\nԴեպք 3:\nԵրբ n = 5 ուսանող և m = 4 փոխանցում, ֆունկցիան պետք է վերադարձնի 6։\nՀաջորդականությունները ներառում են՝ 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nև 1 -> 4 -> 5 -> 2 -> 1։",
      "bn": "'ন' জন ছাত্র একটি বৃত্তে সাজানো অবস্থায় বলটি পাস করার বিভিন্ন উপায়ের সংখ্যা গণনা করে যাতে 'ম' বার পাস করার পর, বলটি শুরুর ছাত্রের কাছে ফিরে আসে।\n\nফাংশনটি বল পাস করার ক্রমগুলির সংখ্যা নির্ধারণ করতে গতিশীল প্রোগ্রামিং ব্যবহার করে। প্রতিটি ছাত্র বলটি বাম প্রতিবেশী বা ডান প্রতিবেশীর কাছে পাস করতে পারে।\n\nArgs:\nn: একটি বৃত্তে দাঁড়িয়ে থাকা ছাত্রদের সংখ্যা।\nm: বলটি পাস করার সংখ্যা।\n\nReturns:\nএকটি পূর্ণসংখ্যা যা বলটি 'ম' বার পাস করার পর শুরুর ছাত্রের কাছে ফিরে আসার ফলাফল হিসাবে পৃথক পাসিং উপায়ের সংখ্যা উপস্থাপন করে।\n\nCases:\nCase 1:\nn = 3 জন ছাত্র এবং m = 3 পাসের জন্য, ফাংশনটি 2 ফেরত দেবে।\nদুটি ক্রম আছে: 1 -> 2 -> 3 -> 1 এবং 1 -> 3 -> 2 -> 1।\n\nCase 2:\nn = 4 জন ছাত্র এবং m = 2 পাসের জন্য, ফাংশনটি 2 ফেরত দেবে।\nদুটি ক্রম আছে: 1 -> 2 -> 1 এবং 1 -> 4 -> 1।\n\nCase 3:\nn = 5 জন ছাত্র এবং m = 4 পাসের জন্য, ফাংশনটি 6 ফেরত দেবে।\nক্রমগুলির মধ্যে রয়েছে: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nএবং 1 -> 4 -> 5 -> 2 -> 1।",
      "bg": "Брои броя на различните начини за предаване на топка между 'n' ученици, подредени в кръг,\nтака че след 'm' предавания топката да се върне при началния ученик.\n\nФункцията използва динамично програмиране, за да определи броя на последователностите на предаване. Всеки ученик\nможе да предаде топката или на левия съсед, или на десния съсед.\n\nArgs:\nn: Броят на учениците, стоящи в кръг.\nm: Броят на пъти, когато топката се предава.\n\nReturns:\nЦяло число, представляващо броя на различните начини на предаване, които водят до това, че топката\nсе връща при началния ученик след 'm' предавания.\n\nCases:\nCase 1:\nЗа n = 3 ученици и m = 3 предавания, функцията трябва да върне 2.\nИма две последователности: 1 -> 2 -> 3 -> 1 и 1 -> 3 -> 2 -> 1.\n\nCase 2:\nЗа n = 4 ученици и m = 2 предавания, функцията трябва да върне 2.\nИма две последователности: 1 -> 2 -> 1 и 1 -> 4 -> 1.\n\nCase 3:\nЗа n = 5 ученици и m = 4 предавания, функцията трябва да върне 6.\nПоследователностите включват: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nи 1 -> 4 -> 5 -> 2 -> 1.",
      "zh": "计算在'n'个学生围成的圆圈中传球的不同方式数量，使得经过'm'次传球后，球返回到起始学生。\n\n该函数使用动态规划来确定传球序列的数量。每个学生可以将球传给左边的邻居或右边的邻居。\n\n参数:\nn: 站成圆圈的学生数量。\nm: 球被传递的次数。\n\n返回:\n一个整数，表示在'm'次传球后，球返回到起始学生的不同传球方式的数量。\n\n案例:\n案例 1:\n对于n = 3个学生和m = 3次传球，函数应返回2。\n有两种序列：1 -> 2 -> 3 -> 1 和 1 -> 3 -> 2 -> 1。\n\n案例 2:\n对于n = 4个学生和m = 2次传球，函数应返回2。\n有两种序列：1 -> 2 -> 1 和 1 -> 4 -> 1。\n\n案例 3:\n对于n = 5个学生和m = 4次传球，函数应返回6。\n序列包括：1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n和 1 -> 4 -> 5 -> 2 -> 1。",
      "fr": "Compte le nombre de façons différentes de faire passer une balle entre 'n' étudiants disposés en cercle\nde telle sorte qu'après 'm' passes, la balle revienne à l'étudiant de départ.\n\nLa fonction utilise la programmation dynamique pour déterminer le nombre de séquences de passes. Chaque étudiant\npeut passer la balle soit à son voisin de gauche, soit à son voisin de droite.\n\nArgs:\nn: Le nombre d'étudiants disposés en cercle.\nm: Le nombre de fois que la balle est passée.\n\nReturns:\nUn entier représentant le nombre de façons distinctes de passer la balle qui aboutissent à ce que la balle\nrevienne à l'étudiant de départ après 'm' passes.\n\nCas:\nCas 1:\nPour n = 3 étudiants et m = 3 passes, la fonction doit retourner 2.\nIl y a deux séquences : 1 -> 2 -> 3 -> 1 et 1 -> 3 -> 2 -> 1.\n\nCas 2:\nPour n = 4 étudiants et m = 2 passes, la fonction doit retourner 2.\nIl y a deux séquences : 1 -> 2 -> 1 et 1 -> 4 -> 1.\n\nCas 3:\nPour n = 5 étudiants et m = 4 passes, la fonction doit retourner 6.\nLes séquences incluent : 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\net 1 -> 4 -> 5 -> 2 -> 1.",
      "de": "Zählt die Anzahl der verschiedenen Möglichkeiten, einen Ball unter 'n' Schülern anzuwerfen, die in einem Kreis angeordnet sind, sodass nach 'm' Würfen der Ball zum startenden Schüler zurückkehrt.\n\nDie Funktion verwendet dynamische Programmierung, um die Anzahl der Wurfsequenzen zu bestimmen. Jeder Schüler kann den Ball entweder an den linken oder den rechten Nachbarn weitergeben.\n\nArgs:\nn: Die Anzahl der Schüler, die im Kreis stehen.\nm: Die Anzahl der Male, die der Ball geworfen wird.\n\nReturns:\nEine ganze Zahl, die die Anzahl der unterschiedlichen Wurfmöglichkeiten darstellt, bei denen der Ball nach 'm' Würfen zum startenden Schüler zurückkehrt.\n\nFälle:\nFall 1:\nFür n = 3 Schüler und m = 3 Würfe sollte die Funktion 2 zurückgeben.\nEs gibt zwei Sequenzen: 1 -> 2 -> 3 -> 1 und 1 -> 3 -> 2 -> 1.\n\nFall 2:\nFür n = 4 Schüler und m = 2 Würfe sollte die Funktion 2 zurückgeben.\nEs gibt zwei Sequenzen: 1 -> 2 -> 1 und 1 -> 4 -> 1.\n\nFall 3:\nFür n = 5 Schüler und m = 4 Würfe sollte die Funktion 6 zurückgeben.\nDie Sequenzen umfassen: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nund 1 -> 4 -> 5 -> 2 -> 1.",
      "ha": "Yana ƙidaya adadin hanyoyin daban-daban na wuce ƙwallo tsakanin 'n' ɗalibai da aka tsara a cikin \nda'ira ta yadda bayan 'm' wucewa, ƙwallon zai koma ga ɗalibin da ya fara.\n\nAikin yana amfani da shirye-shiryen motsi don tantance adadin hanyoyin wucewa. Kowanne ɗalibi\nna iya wuce ƙwallon ko dai ga makwabcin hagu ko ga makwabcin dama.\n\nArgs:\nn: Adadin ɗalibai da ke tsaye a cikin da'ira.\nm: Adadin lokutan da aka wuce ƙwallon.\n\nReturns:\nWani cikakken lamba da ke wakiltar adadin hanyoyin wucewa daban-daban da ke haifar da ƙwallon\nkomawa ga ɗalibin da ya fara bayan 'm' wucewa.\n\nCases:\nCase 1:\nGa n = 3 ɗalibai da m = 3 wucewa, aikin ya kamata ya dawo da 2.\nAkwai hanyoyi guda biyu: 1 -> 2 -> 3 -> 1 da 1 -> 3 -> 2 -> 1.\n\nCase 2:\nGa n = 4 ɗalibai da m = 2 wucewa, aikin ya kamata ya dawo da 2.\nAkwai hanyoyi guda biyu: 1 -> 2 -> 1 da 1 -> 4 -> 1.\n\nCase 3:\nGa n = 5 ɗalibai da m = 4 wucewa, aikin ya kamata ya dawo da 6.\nHanyoyin sun haɗa da: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nda 1 -> 4 -> 5 -> 2 -> 1.",
      "hi": "गेंद को 'n' छात्रों के बीच एक वृत्त में पास करने के विभिन्न तरीकों की संख्या की गणना करता है\nताकि 'm' पास के बाद, गेंद प्रारंभिक छात्र के पास वापस आ जाए।\n\nयह फ़ंक्शन पासिंग अनुक्रमों की संख्या निर्धारित करने के लिए डायनेमिक प्रोग्रामिंग का उपयोग करता है। प्रत्येक छात्र\nगेंद को या तो बाएं पड़ोसी को या दाएं पड़ोसी को पास कर सकता है।\n\nआर्ग्स:\nn: एक वृत्त में खड़े छात्रों की संख्या।\nm: गेंद पास करने की संख्या।\n\nवापसी:\nएक पूर्णांक जो गेंद को प्रारंभिक छात्र के पास 'm' पास के बाद वापस लाने वाले\nविभिन्न पासिंग तरीकों की संख्या का प्रतिनिधित्व करता है।\n\nमामले:\nमामला 1:\nn = 3 छात्रों और m = 3 पास के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\nदो अनुक्रम हैं: 1 -> 2 -> 3 -> 1 और 1 -> 3 -> 2 -> 1।\n\nमामला 2:\nn = 4 छात्रों और m = 2 पास के लिए, फ़ंक्शन को 2 लौटाना चाहिए।\nदो अनुक्रम हैं: 1 -> 2 -> 1 और 1 -> 4 -> 1।\n\nमामला 3:\nn = 5 छात्रों और m = 4 पास के लिए, फ़ंक्शन को 6 लौटाना चाहिए।\nअनुक्रमों में शामिल हैं: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nऔर 1 -> 4 -> 5 -> 2 -> 1।",
      "hu": "Számolja meg, hány különböző módon lehet egy labdát átadni 'n' diák között, akik körben állnak úgy, hogy 'm' passz után a labda visszatér a kiinduló diákhoz.\n\nA függvény dinamikus programozást használ a passzolási sorozatok számának meghatározásához. Minden diák vagy a bal szomszédjának, vagy a jobb szomszédjának adhatja át a labdát.\n\nArgs:\nn: A körben álló diákok száma.\nm: Az átadások száma.\n\nReturns:\nEgy egész szám, amely a különböző passzolási módok számát jelenti, amelyek eredményeként a labda 'm' passz után visszatér a kiinduló diákhoz.\n\nEsetek:\n1. eset:\nHa n = 3 diák és m = 3 passz, a függvénynek 2-t kell visszaadnia.\nKét sorozat van: 1 -> 2 -> 3 -> 1 és 1 -> 3 -> 2 -> 1.\n\n2. eset:\nHa n = 4 diák és m = 2 passz, a függvénynek 2-t kell visszaadnia.\nKét sorozat van: 1 -> 2 -> 1 és 1 -> 4 -> 1.\n\n3. eset:\nHa n = 5 diák és m = 4 passz, a függvénynek 6-ot kell visszaadnia.\nA sorozatok közé tartozik: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nés 1 -> 4 -> 5 -> 2 -> 1."
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9629709271067141",
      "bn": "0.9584141475353927",
      "bg": "0.9952314804424954",
      "zh": "0.9626447760210548",
      "fr": "0.9835440688224026",
      "de": "0.9570392280378692",
      "ha": "0.985060413151223",
      "hi": "0.9589933537264904",
      "hu": "0.9631490985585024"
    }
  },
  {
    "task_id": "Python/17",
    "prompt": {
      "en": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "sq": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Hiq numrat e përsëritur nga lista e dhënë dhe kthe numrat unik të renditur.\n\n    Funksioni fillimisht konverton listën e numrave të dhënë në një set për të hequr çdo përsëritje,\n    pastaj rendit setin rezultues të numrave unik. Ai kthen një tuple që përmban numrin\n    e numrave unik dhe një listë të këtyre numrave unik të renditur në rend rritës.\n\n    Args:\n    numbers (List[int]): Një listë e numrave të plotë, e cila mund të përmbajë përsëritje.\n\n    Returns:\n    Tuple[int, List[int]]: Një tuple me dy elemente:\n        - Një numër i plotë që përfaqëson numrin e numrave unik.\n        - Një listë e numrave unik të renditur në rend rritës.\n\n    Shembuj:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "hy": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Հեռացնել կրկնվող ամբողջ թվերը մուտքային ցուցակից և վերադարձնել դասավորված եզակի թվերը:\n\n    Ֆունկցիան նախ փոխակերպում է մուտքային ցուցակը ամբողջ թվերի մեջ հավաքածուի՝ հեռացնելու համար կրկնօրինակները,\n    այնուհետև դասավորում է ստացված եզակի թվերի հավաքածուն։ Այն վերադարձնում է տուփ, որը պարունակում է\n    եզակի թվերի քանակը և այս եզակի թվերի ցուցակը աճման կարգով։\n\n    Արձանագրություններ:\n    numbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնօրինակներ:\n\n    Վերադարձնում է:\n    Tuple[int, List[int]]: Տուփ երկու տարրերով:\n        - Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը:\n        - Եզակի թվերի ցուցակ, դասավորված աճման կարգով:\n\n    Օրինակներ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "bn": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যা সরান এবং বাছাইকৃত অনন্য সংখ্যাগুলি ফেরত দিন।\n\n    ফাংশনটি প্রথমে ইনপুট তালিকার সংখ্যাগুলিকে একটি সেটে রূপান্তর করে যাতে কোনো সদৃশ সংখ্যা না থাকে,\n    তারপর অনন্য সংখ্যাগুলির সেটটি সাজানো হয়। এটি একটি টিউপল ফেরত দেয় যা অন্তর্ভুক্ত করে\n    অনন্য সংখ্যাগুলির সংখ্যা এবং এই অনন্য সংখ্যাগুলির একটি তালিকা ক্রমবর্ধমান ক্রমে।\n\n    Args:\n    numbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ থাকতে পারে।\n\n    Returns:\n    Tuple[int, List[int]]: একটি টিউপল যার দুটি উপাদান রয়েছে:\n        - একটি পূর্ণসংখ্যা যা অনন্য সংখ্যাগুলির সংখ্যা নির্দেশ করে।\n        - অনন্য সংখ্যাগুলির একটি তালিকা যা ক্রমবর্ধমান ক্রমে সাজানো।\n\n    উদাহরণ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "bg": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Премахване на дублиращи се цели числа от входния списък и връщане на сортираните уникални числа.\n\n    Функцията първо преобразува входния списък от числа в множество, за да премахне дубликатите,\n    след това сортира полученото множество от уникални числа. Връща кортеж, съдържащ броя\n    на уникалните числа и списък с тези уникални числа в нарастващ ред.\n\n    Аргументи:\n    numbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\n    Връща:\n    Tuple[int, List[int]]: Кортеж с два елемента:\n        - Цяло число, представляващо броя на уникалните числа.\n        - Списък с уникалните числа, сортирани в нарастващ ред.\n\n    Примери:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "zh": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    从输入列表中移除重复的整数，并返回排序后的唯一数字。\n\n    该函数首先将输入的数字列表转换为集合以去除任何重复项，\n    然后对结果中的唯一数字集合进行排序。它返回一个包含两个元素的元组，\n    其中包括唯一数字的数量和按升序排列的唯一数字列表。\n\n    参数:\n    numbers (List[int]): 一个可能包含重复项的整数列表。\n\n    返回:\n    Tuple[int, List[int]]: 一个包含两个元素的元组：\n        - 一个整数，表示唯一数字的数量。\n        - 一个按升序排列的唯一数字列表。\n\n    示例:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "fr": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Supprime les entiers dupliqués de la liste d'entrée et retourne les nombres uniques triés.\n\n    La fonction convertit d'abord la liste d'entrée de nombres en un ensemble pour supprimer les doublons,\n    puis trie l'ensemble résultant de nombres uniques. Elle retourne un tuple contenant le nombre\n    de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\n    Args:\n    numbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\n    Returns:\n    Tuple[int, List[int]]: Un tuple avec deux éléments :\n        - Un entier représentant le nombre de nombres uniques.\n        - Une liste des nombres uniques triés dans l'ordre croissant.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "de": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Entferne doppelte Ganzzahlen aus der Eingabeliste und gib die sortierten einzigartigen Zahlen zurück.\n\n    Die Funktion konvertiert zuerst die Eingabeliste von Zahlen in eine Menge, um Duplikate zu entfernen,\n    und sortiert dann die resultierende Menge von einzigartigen Zahlen. Sie gibt ein Tupel zurück, das die Anzahl\n    der einzigartigen Zahlen und eine Liste dieser einzigartigen Zahlen in aufsteigender Reihenfolge enthält.\n\n    Argumente:\n    numbers (List[int]): Eine Liste von Ganzzahlen, die Duplikate enthalten kann.\n\n    Rückgabewerte:\n    Tuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n        - Eine Ganzzahl, die die Anzahl der einzigartigen Zahlen darstellt.\n        - Eine Liste der einzigartigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\n    Beispiele:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "ha": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Cire lambobin maimaitawa daga jerin shigarwa kuma dawo da lambobin da ba su maimaita ba a tsare su.\n\n    Aiki na farko yana canza jerin lambobin shigarwa zuwa saitin don cire duk wani maimaitawa,\n    sannan yana tsara saitin lambobin da ba su maimaita ba. Yana dawowa da tuple wanda ke dauke da adadin\n    lambobin da ba su maimaita ba da kuma jerin wadannan lambobin da ba su maimaita ba a tsare su.\n\n    Args:\n    numbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\n    Returns:\n    Tuple[int, List[int]]: Tuple mai dauke da abubuwa biyu:\n        - Lamba daya da ke nuna adadin lambobin da ba su maimaita ba.\n        - Jerin lambobin da ba su maimaita ba a tsare su.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "hi": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    इनपुट सूची से डुप्लिकेट पूर्णांकों को हटाएं और क्रमबद्ध अद्वितीय संख्याएँ लौटाएं।\n\n    यह फ़ंक्शन पहले संख्याओं की इनपुट सूची को एक सेट में परिवर्तित करता है ताकि कोई भी डुप्लिकेट हट जाए,\n    फिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें अद्वितीय संख्याओं की गिनती\n    और इन अद्वितीय संख्याओं की एक सूची आरोही क्रम में होती है।\n\n    Args:\n    numbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\n    Returns:\n    Tuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n        - एक पूर्णांक जो अद्वितीय संख्याओं की गिनती का प्रतिनिधित्व करता है।\n        - अद्वितीय संख्याओं की एक सूची जो आरोही क्रम में क्रमबद्ध होती है।\n\n    उदाहरण:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "hu": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett, egyedi számokat.\n\n    A függvény először a bemeneti számok listáját halmazzá alakítja, hogy eltávolítsa a duplikátumokat,\n    majd rendezi az így kapott egyedi számok halmazát. Egy olyan tuple-t ad vissza, amely tartalmazza\n    az egyedi számok számát és az egyedi számok listáját növekvő sorrendben.\n\n    Args:\n    numbers (List[int]): Egy egész számokat tartalmazó lista, amely tartalmazhat duplikátumokat.\n\n    Returns:\n    Tuple[int, List[int]]: Egy tuple két elemmel:\n        - Egy egész szám, amely az egyedi számok számát jelöli.\n        - Egy lista az egyedi számokról növekvő sorrendben.\n\n    Példák:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9515329952452011",
      "hy": "0.9692977020034373",
      "bn": "0.9691270785061283",
      "bg": "0.9736802827305912",
      "zh": "0.9640910038253698",
      "fr": "0.9926733197651472",
      "de": "0.9888963630697687",
      "ha": "0.9379101291923043",
      "hi": "0.989484904888775",
      "hu": "0.9746094756530723"
    },
    "canonical_solution": "# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers",
    "instruction": {
      "en": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nՏրամադրել կարճ բնութագրություն (docstring) Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8889781307155027",
      "bn": "0.9053846029282224",
      "bg": "0.8983697723915943",
      "zh": "0.8839134532598751",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9404883515381371",
      "hi": "0.91110952777041",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_process_random_numbers():\n    # Test case 1: Basic example with duplicates\n    assert process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15]) == (8, [15, 20, 32, 40, 67, 89, 300, 400]), \"Test case 1 failed\"\n\n    # Test case 2: All elements are the same\n    assert process_random_numbers([1, 1, 1, 1]) == (1, [1]), \"Test case 2 failed\"\n\n    # Test case 3: No duplicates\n    assert process_random_numbers([3, 1, 4, 2]) == (4, [1, 2, 3, 4]), \"Test case 3 failed\"\n\n    # Test case 4: Random numbers with single element\n    assert process_random_numbers([42]) == (1, [42]), \"Test case 4 failed\"\n\n    # Test case 5: Empty list\n    assert process_random_numbers([]) == (0, []), \"Test case 5 failed\"\n\n    # Test case 6: Random numbers with negatives and zero\n    assert process_random_numbers([0, -1, -2, -1, 0, 3]) == (4, [-2, -1, 0, 3]), \"Test case 6 failed\"\n\n    # Test case 7: Large range of numbers\n    assert process_random_numbers(list(range(1000, 0, -1))) == (1000, list(range(1, 1001))), \"Test case 7 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_process_random_numbers()",
    "entry_point": "process_random_numbers",
    "signature": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:",
    "docstring": {
      "en": "Remove duplicate integers from the input list and return the sorted unique numbers.\n\nThe function first converts the input list of numbers into a set to remove any duplicates,\nthen sorts the resulting set of unique numbers. It returns a tuple containing the count\nof unique numbers and a list of these unique numbers in ascending order.\n\nArgs:\nnumbers (List[int]): A list of integers, which may contain duplicates.\n\nReturns:\nTuple[int, List[int]]: A tuple with two elements:\n- An integer representing the count of unique numbers.\n- A list of the unique numbers sorted in ascending order.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "sq": "Hiqni numrat e përsëritur nga lista hyrëse dhe ktheni numrat unik të renditur.\n\nFunksioni fillimisht konverton listën hyrëse të numrave në një set për të hequr çdo përsëritje,\npastaj rendit setin e rezultuar të numrave unik. Ai kthen një tuple që përmban numrin\ne numrave unik dhe një listë të këtyre numrave unik në rend rritës.\n\nArgumentet:\nnumbers (List[int]): Një listë e numrave të plotë, e cila mund të përmbajë përsëritje.\n\nKthen:\nTuple[int, List[int]]: Një tuple me dy elemente:\n- Një numër i plotë që përfaqëson numrin e numrave unik.\n- Një listë e numrave unik të renditur në rend rritës.\n\nShembuj:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "hy": "Հեռացնել կրկնվող ամբողջ թվերը մուտքային ցուցակից և վերադարձնել դասավորված եզակի թվերը:\n\nՖունկցիան նախ փոխակերպում է մուտքային ցուցակը ամբողջ թվերի հավաքածուի՝ հեռացնելու համար ցանկացած կրկնօրինակ, այնուհետև դասավորում է ստացված եզակի թվերի հավաքածուն: Այն վերադարձնում է տապլիկ, որը պարունակում է եզակի թվերի քանակը և այս եզակի թվերի ցուցակը աճման կարգով:\n\nԱրձագանքներ:\nnumbers (List[int]): Ամբողջ թվերի ցուցակ, որը կարող է պարունակել կրկնօրինակներ:\n\nՎերադարձնում է:\nTuple[int, List[int]]: Տապլիկ երկու տարրերով:\n- Ամբողջ թիվ, որը ներկայացնում է եզակի թվերի քանակը:\n- Եզակի թվերի ցուցակ, դասավորված աճման կարգով:\n\nՕրինակներ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "bn": "ইনপুট তালিকা থেকে সদৃশ পূর্ণসংখ্যাগুলি সরিয়ে ফেলুন এবং বাছাইকৃত অনন্য সংখ্যাগুলি ফেরত দিন।\n\nফাংশনটি প্রথমে ইনপুট তালিকার সংখ্যাগুলিকে একটি সেটে রূপান্তর করে যাতে কোনো সদৃশ সংখ্যা না থাকে, তারপর অনন্য সংখ্যাগুলির সেটটিকে সাজায়। এটি একটি টিউপল ফেরত দেয় যা অনন্য সংখ্যাগুলির গণনা এবং এই অনন্য সংখ্যাগুলির একটি তালিকা উর্ধ্বক্রমে সাজানো অবস্থায় ধারণ করে।\n\nআর্গস:\nnumbers (List[int]): পূর্ণসংখ্যার একটি তালিকা, যা সদৃশ সংখ্যা ধারণ করতে পারে।\n\nরিটার্নস:\nTuple[int, List[int]]: একটি টিউপল যার দুটি উপাদান রয়েছে:\n- একটি পূর্ণসংখ্যা যা অনন্য সংখ্যাগুলির গণনা উপস্থাপন করে।\n- উর্ধ্বক্রমে সাজানো অনন্য সংখ্যাগুলির একটি তালিকা।\n\nউদাহরণ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "bg": "Премахнете дублиращите се цели числа от входния списък и върнете сортираните уникални числа.\n\nФункцията първо преобразува входния списък от числа в множество, за да премахне всички дубликати, след което сортира полученото множество от уникални числа. Тя връща кортеж, съдържащ броя на уникалните числа и списък с тези уникални числа в нарастващ ред.\n\nАргументи:\nnumbers (List[int]): Списък от цели числа, който може да съдържа дубликати.\n\nВръща:\nTuple[int, List[int]]: Кортеж с два елемента:\n- Цяло число, представляващо броя на уникалните числа.\n- Списък с уникалните числа, сортирани в нарастващ ред.\n\nПримери:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "zh": "从输入列表中移除重复的整数，并返回排序后的唯一数字。\n\n该函数首先将输入的数字列表转换为集合以去除任何重复项，\n然后对所得的唯一数字集合进行排序。它返回一个包含唯一数字计数的元组\n和一个按升序排列的唯一数字列表。\n\n参数:\nnumbers (List[int]): 一个整数列表，可能包含重复项。\n\n返回:\nTuple[int, List[int]]: 一个包含两个元素的元组：\n- 一个整数，表示唯一数字的数量。\n- 一个按升序排序的唯一数字列表。\n\n示例:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "fr": "Supprimer les entiers dupliqués de la liste d'entrée et retourner les nombres uniques triés.\n\nLa fonction convertit d'abord la liste d'entiers en un ensemble pour supprimer les doublons, puis trie l'ensemble résultant de nombres uniques. Elle retourne un tuple contenant le nombre de nombres uniques et une liste de ces nombres uniques dans l'ordre croissant.\n\nArgs:\nnumbers (List[int]): Une liste d'entiers, qui peut contenir des doublons.\n\nReturns:\nTuple[int, List[int]]: Un tuple avec deux éléments :\n- Un entier représentant le nombre de nombres uniques.\n- Une liste des nombres uniques triés dans l'ordre croissant.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "de": "Entfernen Sie doppelte Ganzzahlen aus der Eingabeliste und geben Sie die sortierten eindeutigen Zahlen zurück.\n\nDie Funktion konvertiert zuerst die Eingabeliste von Zahlen in eine Menge, um Duplikate zu entfernen, und sortiert dann die resultierende Menge eindeutiger Zahlen. Sie gibt ein Tupel zurück, das die Anzahl der eindeutigen Zahlen und eine Liste dieser eindeutigen Zahlen in aufsteigender Reihenfolge enthält.\n\nArgumente:\nnumbers (List[int]): Eine Liste von Ganzzahlen, die Duplikate enthalten kann.\n\nRückgabewerte:\nTuple[int, List[int]]: Ein Tupel mit zwei Elementen:\n- Eine Ganzzahl, die die Anzahl der eindeutigen Zahlen darstellt.\n- Eine Liste der eindeutigen Zahlen, sortiert in aufsteigender Reihenfolge.\n\nBeispiele:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "ha": "Cire lambobin maimaitawa daga jerin shigarwa kuma dawo da lambobin da ba su maimaita ba a tsararru.\n\nAikin yana fara canza jerin lambobin shigarwa zuwa saitin don cire duk wani maimaitawa, sannan yana tsara saitin lambobin da ba su maimaita ba. Yana dawowa da tubalan da ke dauke da adadin lambobin da ba su maimaita ba da kuma jerin wadannan lambobin da ba su maimaita ba a tsari mai hawa.\n\nArgs:\nnumbers (List[int]): Jerin lambobi, wanda zai iya dauke da maimaitawa.\n\nReturns:\nTuple[int, List[int]]: Tubalan da ke da abubuwa biyu:\n- Lamba mai nuna adadin lambobin da ba su maimaita ba.\n- Jerin lambobin da ba su maimaita ba a tsari mai hawa.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "hi": "इनपुट सूची से डुप्लिकेट पूर्णांकों को हटाएं और क्रमबद्ध अद्वितीय संख्याएँ लौटाएं।\n\nयह फ़ंक्शन पहले संख्याओं की इनपुट सूची को एक सेट में परिवर्तित करता है ताकि कोई भी डुप्लिकेट हट जाए,\nफिर अद्वितीय संख्याओं के परिणामी सेट को क्रमबद्ध करता है। यह एक ट्यूपल लौटाता है जिसमें अद्वितीय संख्याओं की गिनती\nऔर इन अद्वितीय संख्याओं की एक सूची आरोही क्रम में होती है।\n\nआर्ग्स:\nnumbers (List[int]): पूर्णांकों की एक सूची, जिसमें डुप्लिकेट हो सकते हैं।\n\nरिटर्न्स:\nTuple[int, List[int]]: एक ट्यूपल जिसमें दो तत्व होते हैं:\n- एक पूर्णांक जो अद्वितीय संख्याओं की गिनती का प्रतिनिधित्व करता है।\n- अद्वितीय संख्याओं की एक सूची जो आरोही क्रम में होती है।\n\nउदाहरण:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "hu": "Távolítsa el a duplikált egész számokat a bemeneti listából, és adja vissza a rendezett egyedi számokat.\n\nA függvény először a bemeneti számok listáját halmazzá alakítja, hogy eltávolítsa az esetleges duplikátumokat,\nmajd rendezi az így kapott egyedi számok halmazát. Visszaad egy tuple-t, amely tartalmazza az egyedi számok számát\nés az egyedi számok listáját növekvő sorrendben.\n\nArgs:\nnumbers (List[int]): Egy egész számokat tartalmazó lista, amely tartalmazhat duplikátumokat.\n\nReturns:\nTuple[int, List[int]]: Egy tuple két elemmel:\n- Egy egész szám, amely az egyedi számok számát jelöli.\n- Egy lista az egyedi számokról növekvő sorrendben.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])"
    },
    "docstring_bertscore": {
      "sq": "0.9855097150731239",
      "hy": "0.9684537215144201",
      "bn": "0.9729264804345638",
      "bg": "0.9929923201570892",
      "zh": "0.9830766915358276",
      "fr": "0.9829976366441756",
      "de": "0.9890602331341225",
      "ha": "0.9210835537236958",
      "hi": "0.988596431194406",
      "hu": "0.9788645356756017"
    }
  },
  {
    "task_id": "Python/18",
    "prompt": {
      "en": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    The first example represents a budget of 1000 units with 5 items to choose from. The function \n    returns 3900, which is the maximum importance value sum achievable within the budget.\n    \n    The second example has a smaller budget of 50 units and 3 items. The function returns 80, \n    which is the maximum sum of importance values for the chosen items within the budget.\n    \"\"\"",
      "sq": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n    \n    Kjo funksion zgjidh një variant të problemit të çantës 0-1 ku secili artikull ka një çmim dhe një \n    vlerë rëndësie të lidhur. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një \n    përzgjedhjeje të artikujve pa e tejkaluar çmimin total buxhetin.\n    \n    Argumentet:\n    n (int): Buxheti total i disponueshëm për blerjen e artikujve.\n    m (int): Numri i artikujve të ndryshëm për të zgjedhur.\n    items (List[Tuple[int, int]]): Një listë tuplesh, ku secili tuple përmban dy numra të plotë:\n        - Numri i parë përfaqëson çmimin e artikullit.\n        - Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n    \n    Kthen:\n    int: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n    \n    Shembuj:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Shembulli i parë përfaqëson një buxhet prej 1000 njësive me 5 artikuj për të zgjedhur. Funksioni \n    kthen 3900, që është shuma maksimale e vlerës së rëndësisë që arrihet brenda buxhetit.\n    \n    Shembulli i dytë ka një buxhet më të vogël prej 50 njësive dhe 3 artikuj. Funksioni kthen 80, \n    që është shuma maksimale e vlerave të rëndësisë për artikujt e zgjedhur brenda buxhetit.\n    \"\"\"",
      "hy": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվում է իրերի առավելագույն ընդհանուր կարևորության արժեքը, որոնք կարելի է գնել տրված բյուջեի սահմաններում:\n    \n    Այս ֆունկցիան լուծում է 0-1 պայուսակի խնդրի տարբերակը, որտեղ յուրաքանչյուր իր ունի գին և \n    կապված կարևորության արժեք: Նպատակն է առավելագույնացնել իրերի ընտրության կարևորության արժեքների \n    գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն:\n    \n    Արգումենտներ:\n    n (int): Ընդհանուր բյուջեն, որը հասանելի է իրեր գնելու համար:\n    m (int): Ընտրելու տարբեր իրերի քանակը:\n    items (List[Tuple[int, int]]): Կրկնապակետների ցուցակ, որտեղ յուրաքանչյուր կրկնապակետ պարունակում է երկու ամբողջ թիվ.\n        - Առաջին ամբողջ թիվը ներկայացնում է իրի գինը:\n        - Երկրորդ ամբողջ թիվը ներկայացնում է իրի կարևորության արժեքը:\n    \n    Վերադարձնում է:\n    int: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է հասնել առանց բյուջեն գերազանցելու:\n    \n    Օրինակներ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Առաջին օրինակը ներկայացնում է 1000 միավոր բյուջե 5 ընտրելու իրերով: Ֆունկցիան \n    վերադարձնում է 3900, որը առավելագույն կարևորության արժեքների գումարն է, որը կարելի է հասնել բյուջեի սահմաններում:\n    \n    Երկրորդ օրինակը ունի ավելի փոքր բյուջե՝ 50 միավոր և 3 իր: Ֆունկցիան վերադարձնում է 80, \n    որը առավելագույն կարևորության արժեքների գումարն է ընտրած իրերի համար բյուջեի սահմաններում:\n    \"\"\"",
      "bn": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    প্রদত্ত বাজেটের মধ্যে ক্রয় করা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n    \n    এই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি প্রকরণ সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি \n    সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল এমন আইটেমগুলির একটি নির্বাচন থেকে গুরুত্ব মানগুলির যোগফল সর্বাধিক করা \n    যাতে মোট মূল্য বাজেট অতিক্রম না করে।\n    \n    Args:\n    n (int): আইটেম ক্রয়ের জন্য উপলব্ধ মোট বাজেট।\n    m (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\n    items (List[Tuple[int, int]]): একটি টাপল তালিকা, যেখানে প্রতিটি টাপলে দুটি পূর্ণসংখ্যা থাকে:\n        - প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য উপস্থাপন করে।\n        - দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান উপস্থাপন করে।\n    \n    Returns:\n    int: বাজেট অতিক্রম না করে অর্জনযোগ্য সর্বাধিক মোট গুরুত্ব মান।\n    \n    উদাহরণ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    প্রথম উদাহরণটি 1000 ইউনিটের বাজেট এবং 5টি আইটেম নির্বাচন করার জন্য উপস্থাপন করে। ফাংশনটি \n    3900 ফেরত দেয়, যা বাজেটের মধ্যে অর্জনযোগ্য সর্বাধিক গুরুত্ব মানের যোগফল।\n    \n    দ্বিতীয় উদাহরণে 50 ইউনিটের একটি ছোট বাজেট এবং 3টি আইটেম রয়েছে। ফাংশনটি 80 ফেরত দেয়, \n    যা বাজেটের মধ্যে নির্বাচিত আইটেমগুলির জন্য সর্বাধিক গুরুত্ব মানের যোগফল।\n    \"\"\"",
      "bg": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната обща стойност на важност на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n    \n    Тази функция решава вариант на проблема с раницата 0-1, където всеки предмет има цена и \n    свързана стойност на важност. Целта е да се максимизира сумата от стойностите на важност на \n    избраните предмети, без общата цена да надвишава бюджета.\n    \n    Аргументи:\n    n (int): Общият бюджет, наличен за закупуване на предмети.\n    m (int): Броят на различните предмети, от които може да се избира.\n    items (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа:\n        - Първото число представлява цената на предмета.\n        - Второто число представлява стойността на важност на предмета.\n    \n    Връща:\n    int: Максималната обща стойност на важност, която може да бъде постигната без да се надвишава бюджета.\n    \n    Примери:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Първият пример представлява бюджет от 1000 единици с 5 предмета за избор. Функцията \n    връща 3900, което е максималната сума на стойностите на важност, постижима в рамките на бюджета.\n    \n    Вторият пример има по-малък бюджет от 50 единици и 3 предмета. Функцията връща 80, \n    което е максималната сума на стойностите на важност за избраните предмети в рамките на бюджета.\n    \"\"\"",
      "zh": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在给定预算内可以购买的物品的最大总重要性值。\n    \n    这个函数解决了0-1背包问题的一个变体，其中每个物品都有一个价格和一个相关的重要性值。目标是最大化所选物品的重要性值之和，同时总价格不超过预算。\n    \n    参数：\n    n (int): 可用于购买物品的总预算。\n    m (int): 可选择的不同物品的数量。\n    items (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数：\n        - 第一个整数表示物品的价格。\n        - 第二个整数表示物品的重要性值。\n    \n    返回：\n    int: 在不超过预算的情况下可以达到的最大总重要性值。\n    \n    示例：\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    第一个示例表示预算为1000单位，有5个物品可供选择。函数返回3900，这是在预算内可以实现的最大重要性值总和。\n    \n    第二个示例的预算较小，为50单位，有3个物品。函数返回80，这是在预算内选择的物品的重要性值的最大总和。\n    \"\"\"",
      "fr": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcule la valeur totale maximale d'importance des articles qui peuvent être achetés dans un budget donné.\n    \n    Cette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une \n    valeur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une \n    sélection d'articles sans que le prix total ne dépasse le budget.\n    \n    Args:\n    n (int): Le budget total disponible pour l'achat d'articles.\n    m (int): Le nombre d'articles différents parmi lesquels choisir.\n    items (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n        - Le premier entier représente le prix de l'article.\n        - Le deuxième entier représente la valeur d'importance de l'article.\n    \n    Returns:\n    int: La valeur totale maximale d'importance qui peut être atteinte sans dépasser le budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Le premier exemple représente un budget de 1000 unités avec 5 articles parmi lesquels choisir. La fonction \n    renvoie 3900, ce qui est la somme maximale de valeurs d'importance réalisable dans le budget.\n    \n    Le deuxième exemple a un budget plus petit de 50 unités et 3 articles. La fonction renvoie 80, \n    ce qui est la somme maximale des valeurs d'importance pour les articles choisis dans le budget.\n    \"\"\"",
      "de": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n    \n    Diese Funktion löst eine Variante des 0-1 Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen \n    zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer Auswahl von Gegenständen \n    zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n    \n    Args:\n    n (int): Das verfügbare Gesamtbudget für den Kauf von Gegenständen.\n    m (int): Die Anzahl der verschiedenen zur Auswahl stehenden Gegenstände.\n    items (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n        - Die erste ganze Zahl repräsentiert den Preis des Gegenstands.\n        - Die zweite ganze Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n    \n    Returns:\n    int: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n    \n    Beispiele:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Das erste Beispiel repräsentiert ein Budget von 1000 Einheiten mit 5 zur Auswahl stehenden Gegenständen. Die Funktion \n    gibt 3900 zurück, was die maximal erreichbare Summe der Wichtigkeitswerte innerhalb des Budgets ist.\n    \n    Das zweite Beispiel hat ein kleineres Budget von 50 Einheiten und 3 Gegenstände. Die Funktion gibt 80 zurück, \n    was die maximale Summe der Wichtigkeitswerte für die gewählten Gegenstände innerhalb des Budgets ist.\n    \"\"\"",
      "ha": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa mafi girman jimillar darajar muhimmanci na abubuwan da za a iya saya cikin kasafin kudi da aka bayar.\n    \n    Wannan aikin yana warware wani bambanci na matsalar 0-1 knapsack inda kowane abu yana da farashi da \n    darajar muhimmanci da aka danganta. Manufar ita ce a kara yawan jimillar darajar muhimmanci na \n    zaɓin abubuwa ba tare da jimillar farashi ta wuce kasafin kudin ba.\n    \n    Args:\n    n (int): Jimillar kasafin kudi da ake da shi don siyan abubuwa.\n    m (int): Yawan abubuwa daban-daban da za a zaɓa daga.\n    items (List[Tuple[int, int]]): Jerin tuples, inda kowane tuple ya ƙunshi lambobi biyu:\n        - Na farko yana wakiltar farashin abu.\n        - Na biyu yana wakiltar darajar muhimmancin abu.\n    \n    Returns:\n    int: Mafi girman jimillar darajar muhimmanci da za a iya samu ba tare da wuce kasafin kudin ba.\n    \n    Misalai:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Misali na farko yana wakiltar kasafin kudi na raka'a 1000 tare da abubuwa 5 da za a zaɓa daga. Aikin \n    yana dawowa da 3900, wanda shine mafi girman jimillar darajar muhimmanci da za a iya samu cikin kasafin kudin.\n    \n    Misali na biyu yana da ƙaramin kasafin kudi na raka'a 50 da abubuwa 3. Aikin yana dawowa da 80, \n    wanda shine mafi girman jimillar darajar muhimmanci na abubuwan da aka zaɓa cikin kasafin kudin.\n    \"\"\"",
      "hi": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    उन वस्तुओं के अधिकतम कुल महत्व मान की गणना करता है जिन्हें दिए गए बजट के भीतर खरीदा जा सकता है।\n    \n    यह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और एक \n    संबंधित महत्व मान होता है। लक्ष्य वस्तुओं के चयन के महत्व मानों के योग को अधिकतम करना है \n    बिना कुल कीमत बजट से अधिक हुए।\n    \n    Args:\n    n (int): वस्तुओं की खरीदारी के लिए उपलब्ध कुल बजट।\n    m (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\n    items (List[Tuple[int, int]]): टपल की एक सूची, जहाँ प्रत्येक टपल में दो पूर्णांक होते हैं:\n        - पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n        - दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n    \n    Returns:\n    int: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n    \n    उदाहरण:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    पहला उदाहरण 1000 इकाइयों के बजट का प्रतिनिधित्व करता है जिसमें 5 वस्तुओं को चुनने के लिए है। \n    फ़ंक्शन 3900 लौटाता है, जो बजट के भीतर प्राप्त करने योग्य अधिकतम महत्व मान योग है।\n    \n    दूसरा उदाहरण 50 इकाइयों के छोटे बजट और 3 वस्तुओं का है। फ़ंक्शन 80 लौटाता है, \n    जो बजट के भीतर चुनी गई वस्तुओं के महत्व मानों का अधिकतम योग है।\n    \"\"\"",
      "hu": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kiszámítja a tárgyak maximális összesített fontossági értékét, amelyeket meg lehet vásárolni egy adott költségvetésen belül.\n    \n    Ez a függvény a 0-1 hátizsák probléma egy változatát oldja meg, ahol minden tárgynak van egy ára és egy \n    hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a kiválasztott tárgyak fontossági értékeinek \n    összegét úgy, hogy a teljes ár ne haladja meg a költségvetést.\n    \n    Args:\n    n (int): A tárgyak vásárlására rendelkezésre álló teljes költségvetés.\n    m (int): A választható különböző tárgyak száma.\n    items (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy kételemű tuple:\n        - Az első egész szám a tárgy árát jelöli.\n        - A második egész szám a tárgy fontossági értékét jelöli.\n    \n    Returns:\n    int: A maximális összesített fontossági érték, amely elérhető anélkül, hogy túllépnénk a költségvetést.\n    \n    Példák:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Az első példa egy 1000 egységnyi költségvetést képvisel, 5 választható tárggyal. A függvény \n    3900-at ad vissza, ami a költségvetésen belül elérhető maximális fontossági érték összeg.\n    \n    A második példa egy kisebb, 50 egységnyi költségvetéssel és 3 tárggyal rendelkezik. A függvény 80-at ad vissza, \n    ami a költségvetésen belül a kiválasztott tárgyak fontossági értékeinek maximális összege.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9808732847190075",
      "hy": "0.9753805587922497",
      "bn": "0.9751108187348043",
      "bg": "0.9837349526185771",
      "zh": "0.9717583351636975",
      "fr": "0.9928939981184769",
      "de": "0.9766960878058438",
      "ha": "0.958455661285029",
      "hi": "0.9754347848862722",
      "hu": "0.9723450893092745"
    },
    "canonical_solution": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]",
    "instruction": {
      "en": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nՏվեք Python կոդի կարճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত স্বাভাবিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nПредоставете кратко описание на Python кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9136972843745325",
      "bn": "0.8827651710271124",
      "bg": "0.8415791615195284",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.9662707736268467",
      "hi": "0.8964889413135749",
      "hu": "0.9412719483913198"
    },
    "level": "",
    "test": "def test_max_happiness():\n    # Test case 1: Sample provided in the problem\n    assert max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)]) == 3900, \"Test case 1 failed\"\n\n    # Test case 2: Small budget with one item\n    assert max_happiness(50, 1, [(60, 3)]) == 0, \"Test case 2 failed\"\n\n    # Test case 4: Exact budget\n    assert max_happiness(100, 2, [(50, 2), (50, 3)]) == 250, \"Test case 4 failed\"\n\n    # Test case 5: No items\n    assert max_happiness(100, 0, []) == 0, \"Test case 5 failed\"\n\n    # Test case 6: All items exceed the budget\n    assert max_happiness(10, 3, [(20, 1), (30, 2), (40, 3)]) == 0, \"Test case 6 failed\"\n\n    # Test case 7: Multiple items with the same price and importance\n    assert max_happiness(100, 4, [(25, 2), (25, 2), (25, 2), (25, 2)]) == 200, \"Test case 7 failed\"\n\n    # Test case 8: Large number of items\n    assert max_happiness(1000, 10, [(100, i) for i in range(1, 11)]) == 5500, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_happiness()",
    "entry_point": "max_happiness",
    "signature": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "Calculates the maximum total importance value of items that can be bought within a given budget.\n\nThis function solves a variant of the 0-1 knapsack problem where each item has a price and an\nassociated importance value. The goal is to maximize the sum of the importance values of a\nselection of items without the total price exceeding the budget.\n\nArgs:\nn (int): The total budget available for purchasing items.\nm (int): The number of different items to choose from.\nitems (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n- The first integer represents the price of the item.\n- The second integer represents the importance value of the item.\n\nReturns:\nint: The maximum total importance value that can be achieved without exceeding the budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nThe first example represents a budget of 1000 units with 5 items to choose from. The function\nreturns 3900, which is the maximum importance value sum achievable within the budget.\n\nThe second example has a smaller budget of 50 units and 3 items. The function returns 80,\nwhich is the maximum sum of importance values for the chosen items within the budget.",
      "sq": "Llogarit vlerën maksimale totale të rëndësisë së artikujve që mund të blihen brenda një buxheti të caktuar.\n\nKjo funksion zgjidh një variant të problemit të çantës 0-1 ku secili artikull ka një çmim dhe një vlerë të lidhur rëndësie. Qëllimi është të maksimizohet shuma e vlerave të rëndësisë së një përzgjedhjeje të artikujve pa e tejkaluar çmimin total të buxhetit.\n\nArgs:\nn (int): Buxheti total i disponueshëm për blerjen e artikujve.\nm (int): Numri i artikujve të ndryshëm për të zgjedhur.\nitems (List[Tuple[int, int]]): Një listë tuplesh, ku secili tuple përmban dy numra të plotë:\n- Numri i parë përfaqëson çmimin e artikullit.\n- Numri i dytë përfaqëson vlerën e rëndësisë së artikullit.\n\nReturns:\nint: Vlera maksimale totale e rëndësisë që mund të arrihet pa e tejkaluar buxhetin.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nShembulli i parë përfaqëson një buxhet prej 1000 njësish me 5 artikuj për të zgjedhur. Funksioni kthen 3900, që është shuma maksimale e vlerës së rëndësisë që mund të arrihet brenda buxhetit.\n\nShembulli i dytë ka një buxhet më të vogël prej 50 njësish dhe 3 artikuj. Funksioni kthen 80, që është shuma maksimale e vlerave të rëndësisë për artikujt e zgjedhur brenda buxhetit.",
      "hy": "Հաշվում է առարկաների առավելագույն ընդհանուր կարևորության արժեքը, որոնք կարելի է գնել տրված բյուջեի սահմաններում:\n\nԱյս ֆունկցիան լուծում է 0-1 դարակաշարային խնդրի տարբերակը, որտեղ յուրաքանչյուր առարկա ունի գին և\nկապակցված կարևորության արժեք: Նպատակն է առավելագույնացնել առարկաների ընտրության կարևորության արժեքների գումարը՝ առանց ընդհանուր գինը գերազանցելու բյուջեն:\n\nԱրձագանքներ:\nn (int): Ընդհանուր բյուջեն, որը հասանելի է առարկաներ գնելու համար:\nm (int): Ընտրելու համար տարբեր առարկաների քանակը:\nitems (List[Tuple[int, int]]): Ցանկ, որը պարունակում է զույգերի ցանկ, որտեղ յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ:\n- Առաջին ամբողջ թիվը ներկայացնում է առարկայի գինը:\n- Երկրորդ ամբողջ թիվը ներկայացնում է առարկայի կարևորության արժեքը:\n\nՎերադարձնում է:\nint: Առավելագույն ընդհանուր կարևորության արժեքը, որը կարելի է հասնել առանց բյուջեն գերազանցելու:\n\nՕրինակներ:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nԱռաջին օրինակը ներկայացնում է 1000 միավոր բյուջե 5 ընտրելու առարկաներով: Ֆունկցիան վերադարձնում է 3900, որը առավելագույն կարևորության արժեքի գումարն է, որը կարելի է հասնել բյուջեի սահմաններում:\n\nԵրկրորդ օրինակը ունի 50 միավոր փոքր բյուջե և 3 առարկա: Ֆունկցիան վերադարձնում է 80, որը առավելագույն կարևորության արժեքների գումարն է ընտրված առարկաների համար բյուջեի սահմաններում:",
      "bn": "দেওয়া বাজেটের মধ্যে কেনাকাটা করা যেতে পারে এমন আইটেমগুলির সর্বাধিক মোট গুরুত্ব মান গণনা করে।\n\nএই ফাংশনটি 0-1 ন্যাপকস্যাক সমস্যার একটি বৈকল্পিক সমাধান করে যেখানে প্রতিটি আইটেমের একটি মূল্য এবং একটি সংশ্লিষ্ট গুরুত্ব মান থাকে। লক্ষ্য হল, বাজেট অতিক্রম না করে আইটেমগুলির একটি নির্বাচনের গুরুত্ব মানগুলির যোগফল সর্বাধিক করা।\n\nআর্গস:\nn (int): আইটেম কেনার জন্য উপলব্ধ মোট বাজেট।\nm (int): নির্বাচন করার জন্য বিভিন্ন আইটেমের সংখ্যা।\nitems (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে:\n- প্রথম পূর্ণসংখ্যাটি আইটেমের মূল্য উপস্থাপন করে।\n- দ্বিতীয় পূর্ণসংখ্যাটি আইটেমের গুরুত্ব মান উপস্থাপন করে।\n\nরিটার্নস:\nint: সর্বাধিক মোট গুরুত্ব মান যা বাজেট অতিক্রম না করেই অর্জন করা যেতে পারে।\n\nউদাহরণ:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nপ্রথম উদাহরণটি 1000 ইউনিটের বাজেট এবং 5টি আইটেমের নির্বাচনকে উপস্থাপন করে। ফাংশনটি 3900 ফেরত দেয়, যা বাজেটের মধ্যে অর্জনযোগ্য সর্বাধিক গুরুত্ব মানের যোগফল।\n\nদ্বিতীয় উদাহরণে 50 ইউনিটের একটি ছোট বাজেট এবং 3টি আইটেম রয়েছে। ফাংশনটি 80 ফেরত দেয়, যা বাজেটের মধ্যে নির্বাচিত আইটেমগুলির জন্য সর্বাধিক গুরুত্ব মানের যোগফল।",
      "bg": "Изчислява максималната обща стойност на важността на предметите, които могат да бъдат закупени в рамките на даден бюджет.\n\nТази функция решава вариант на проблема с раницата 0-1, където всеки предмет има цена и свързана стойност на важността. Целта е да се максимизира сумата на стойностите на важността на избраните предмети, без общата цена да надвишава бюджета.\n\nArgs:\nn (int): Общият бюджет, наличен за закупуване на предмети.\nm (int): Броят на различните предмети, от които може да се избира.\nitems (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа два цели числа:\n- Първото цяло число представлява цената на предмета.\n- Второто цяло число представлява стойността на важността на предмета.\n\nReturns:\nint: Максималната обща стойност на важността, която може да бъде постигната, без да се надвишава бюджетът.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nПървият пример представлява бюджет от 1000 единици с 5 предмета, от които може да се избира. Функцията връща 3900, което е максималната сума на стойностите на важността, постижима в рамките на бюджета.\n\nВторият пример има по-малък бюджет от 50 единици и 3 предмета. Функцията връща 80, което е максималната сума на стойностите на важността за избраните предмети в рамките на бюджета.",
      "zh": "计算在给定预算内可以购买的物品的最大总重要性值。\n\n此函数解决了一种0-1背包问题的变体，其中每个物品都有一个价格和一个相关的重要性值。目标是在不超过预算的情况下，最大化所选物品的重要性值之和。\n\n参数：\nn (int): 可用于购买物品的总预算。\nm (int): 可选择的不同物品数量。\nitems (List[Tuple[int, int]]): 一个元组列表，每个元组包含两个整数：\n- 第一个整数表示物品的价格。\n- 第二个整数表示物品的重要性值。\n\n返回：\nint: 在不超过预算的情况下可以达到的最大总重要性值。\n\n示例：\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\n第一个示例表示预算为1000单位，有5个物品可供选择。函数返回3900，这是在预算内可以实现的最大重要性值之和。\n\n第二个示例预算较小，为50单位，有3个物品。函数返回80，这是在预算内所选物品的重要性值的最大和。",
      "fr": "Calcule la valeur d'importance totale maximale des articles pouvant être achetés dans un budget donné.\n\nCette fonction résout une variante du problème du sac à dos 0-1 où chaque article a un prix et une\nvaleur d'importance associée. L'objectif est de maximiser la somme des valeurs d'importance d'une\nsélection d'articles sans que le prix total ne dépasse le budget.\n\nArgs:\nn (int): Le budget total disponible pour l'achat d'articles.\nm (int): Le nombre d'articles différents parmi lesquels choisir.\nitems (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers :\n- Le premier entier représente le prix de l'article.\n- Le deuxième entier représente la valeur d'importance de l'article.\n\nReturns:\nint: La valeur d'importance totale maximale pouvant être atteinte sans dépasser le budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nLe premier exemple représente un budget de 1000 unités avec 5 articles parmi lesquels choisir. La fonction\nrenvoie 3900, qui est la somme maximale des valeurs d'importance atteignable dans le budget.\n\nLe deuxième exemple a un budget plus petit de 50 unités et 3 articles. La fonction renvoie 80,\nqui est la somme maximale des valeurs d'importance pour les articles choisis dans le budget.",
      "de": "Berechnet den maximalen Gesamtwert der Wichtigkeit von Gegenständen, die innerhalb eines gegebenen Budgets gekauft werden können.\n\nDiese Funktion löst eine Variante des 0-1-Rucksackproblems, bei dem jeder Gegenstand einen Preis und einen zugehörigen Wichtigkeitswert hat. Das Ziel ist es, die Summe der Wichtigkeitswerte einer Auswahl von Gegenständen zu maximieren, ohne dass der Gesamtpreis das Budget überschreitet.\n\nArgs:\nn (int): Das insgesamt verfügbare Budget für den Kauf von Gegenständen.\nm (int): Die Anzahl der verschiedenen zur Auswahl stehenden Gegenstände.\nitems (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält:\n- Die erste ganze Zahl repräsentiert den Preis des Gegenstands.\n- Die zweite ganze Zahl repräsentiert den Wichtigkeitswert des Gegenstands.\n\nReturns:\nint: Der maximale Gesamtwert der Wichtigkeit, der erreicht werden kann, ohne das Budget zu überschreiten.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nDas erste Beispiel repräsentiert ein Budget von 1000 Einheiten mit 5 zur Auswahl stehenden Gegenständen. Die Funktion gibt 3900 zurück, was die maximale Summe der Wichtigkeitswerte ist, die innerhalb des Budgets erreicht werden kann.\n\nDas zweite Beispiel hat ein kleineres Budget von 50 Einheiten und 3 Gegenstände. Die Funktion gibt 80 zurück, was die maximale Summe der Wichtigkeitswerte für die innerhalb des Budgets ausgewählten Gegenstände ist.",
      "ha": "Yana ƙididdige matsakaicin jimillar ƙimar muhimmanci na abubuwan da za a iya saya a cikin kasafin kuɗi da aka bayar.\n\nWannan aikin yana warware bambancin matsalar jakar 0-1 inda kowanne abu yana da farashi da kuma\nƙimar muhimmanci da aka haɗa. Manufar ita ce a ƙara yawan jimillar ƙimar muhimmancin zaɓi na abubuwa ba tare da farashin jimlar ya wuce kasafin kuɗi ba.\n\nArgs:\nn (int): Jimillar kasafin kuɗi da ake da shi don siyan abubuwa.\nm (int): Yawan abubuwa daban-daban da za a zaɓa daga.\nitems (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple yana ɗauke da lambobi guda biyu:\n- Lamba ta farko tana wakiltar farashin abu.\n- Lamba ta biyu tana wakiltar ƙimar muhimmancin abu.\n\nReturns:\nint: Matsakaicin jimillar ƙimar muhimmanci da za a iya samu ba tare da wuce kasafin kuɗi ba.\n\nMisalai:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nMisali na farko yana wakiltar kasafin kuɗi na raka'a 1000 tare da abubuwa 5 da za a zaɓa daga. Aikin yana dawowa 3900, wanda shine matsakaicin jimillar ƙimar muhimmanci da za a iya samu a cikin kasafin kuɗi.\n\nMisali na biyu yana da ƙaramin kasafin kuɗi na raka'a 50 da abubuwa 3. Aikin yana dawowa 80, wanda shine matsakaicin jimillar ƙimar muhimmanci na abubuwan da aka zaɓa a cikin kasafin kuɗi.",
      "hi": "दी गई बजट के भीतर खरीदे जा सकने वाले वस्तुओं के अधिकतम कुल महत्व मान की गणना करता है।\n\nयह फ़ंक्शन 0-1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ प्रत्येक वस्तु की एक कीमत और एक संबंधित महत्व मान होता है। लक्ष्य यह है कि वस्तुओं के चयन के महत्व मानों के योग को अधिकतम किया जाए बिना कुल कीमत बजट से अधिक हुए।\n\nआर्ग्स:\nn (int): वस्तुओं की खरीदारी के लिए उपलब्ध कुल बजट।\nm (int): चुनने के लिए विभिन्न वस्तुओं की संख्या।\nitems (List[Tuple[int, int]]): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं:\n- पहला पूर्णांक वस्तु की कीमत को दर्शाता है।\n- दूसरा पूर्णांक वस्तु के महत्व मान को दर्शाता है।\n\nरिटर्न्स:\nint: अधिकतम कुल महत्व मान जो बजट से अधिक हुए बिना प्राप्त किया जा सकता है।\n\nउदाहरण:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nपहला उदाहरण 1000 इकाइयों के बजट का प्रतिनिधित्व करता है जिसमें 5 वस्तुओं को चुनने के लिए है। फ़ंक्शन 3900 लौटाता है, जो बजट के भीतर प्राप्त किया जा सकने वाला अधिकतम महत्व मान योग है।\n\nदूसरे उदाहरण में 50 इकाइयों का छोटा बजट और 3 वस्तुएं हैं। फ़ंक्शन 80 लौटाता है, जो बजट के भीतर चुनी गई वस्तुओं के महत्व मानों का अधिकतम योग है।",
      "hu": "Kiszámítja a megvásárolható tárgyak maximális összesített fontossági értékét egy adott költségvetésen belül.\n\nEz a függvény a 0-1 hátizsák probléma egy változatát oldja meg, ahol minden tárgynak van egy ára és egy hozzá tartozó fontossági értéke. A cél az, hogy maximalizáljuk a kiválasztott tárgyak fontossági értékeinek összegét anélkül, hogy a teljes ár meghaladná a költségvetést.\n\nArgs:\nn (int): Az összes rendelkezésre álló költségvetés a tárgyak megvásárlására.\nm (int): A választható különböző tárgyak száma.\nitems (List[Tuple[int, int]]): Egy listája a tuple-öknek, ahol minden tuple két egész számot tartalmaz:\n- Az első egész szám a tárgy árát jelenti.\n- A második egész szám a tárgy fontossági értékét jelenti.\n\nReturns:\nint: A maximális összesített fontossági érték, amely elérhető anélkül, hogy meghaladná a költségvetést.\n\nPéldák:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nAz első példa egy 1000 egységnyi költségvetést képvisel 5 választható tárggyal. A függvény 3900-at ad vissza, ami a költségvetésen belül elérhető maximális fontossági érték összeg.\n\nA második példa egy kisebb, 50 egységnyi költségvetéssel és 3 tárggyal rendelkezik. A függvény 80-at ad vissza, ami a költségvetésen belül a kiválasztott tárgyak maximális fontossági értékének összege."
    },
    "docstring_bertscore": {
      "sq": "0.9793134403367405",
      "hy": "0.9620341862297536",
      "bn": "0.9715825472764816",
      "bg": "0.9867720111446006",
      "zh": "0.9574976669572978",
      "fr": "0.9946502879475874",
      "de": "0.9693888733483323",
      "ha": "0.9577540987792138",
      "hi": "0.9699716548862887",
      "hu": "0.988978000156374"
    }
  },
  {
    "task_id": "Python/19",
    "prompt": {
      "en": "\ndef max_energy(beads):\n    \"\"\"\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        This sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\n        released by merging them in the optimal order is 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        This sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\n        released by merging them in the optimal order is 48.\n    \"\"\"",
      "sq": "def max_energy(beads):\n    \"\"\"\n    Llogarit energjinë maksimale që mund të lirohet duke bashkuar rruazat në një gjerdan.\n\n    Funksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një gjerdan, ku\n    secila rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së secilës rruazë duhet të përputhet\n    me vlerën e bishtit të rruazës së ardhshme në sekuencë. Gjerdani është rrethor, dhe bashkimi i dy rruazave\n    ngjitur liron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës së përputhshme,\n    dhe vlerës së bishtit të rruazës së dytë.\n\n    Për të gjetur lirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit\n    të rruazave dhe përdor programimin dinamik për të llogaritur energjinë maksimale të arritshme.\n\n    Args:\n        beads: Një listë e numrave të plotë ku secili numër përfaqëson vlerën e kokës së një rruaze dhe\n               vlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\n               të përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të gjerdanit.\n\n    Returns:\n        Një numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar në mënyrë optimale të gjitha rruazat.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Kjo sekuencë përfaqëson rruaza me vlera (2,3), (3,5), (5,10), (10,2). Energjia maksimale\n        e liruar duke i bashkuar ato në rendin optimal është 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Kjo sekuencë përfaqëson rruaza me vlera (1,2), (2,3), (3,4), (4,1). Energjia maksimale\n        e liruar duke i bashkuar ato në rendin optimal është 48.\n    \"\"\"",
      "hy": "def max_energy(beads):\n    \"\"\"\n    Հաշվել առավելագույն էներգիան, որը կարող է ազատվել մարգարիտների միաձուլմամբ վզնոցում:\n\n    Ֆունկցիան ընդունում է ամբողջ թվերի ցանկ, որը ներկայացնում է վզնոցի վրա էներգիայի մարգարիտները, որտեղ\n    յուրաքանչյուր մարգարիտ ունի գլուխ և պոչ արժեք: Յուրաքանչյուր մարգարիտի գլուխ արժեքը պետք է համընկնի հաջորդ մարգարիտի պոչ\n    արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից\n    մարգարիտների միաձուլումը ազատում է էներգիա, որը հավասար է առաջին մարգարիտի գլուխ արժեքի, համընկնող\n    արժեքի և երկրորդ մարգարիտի պոչ արժեքի արտադրյալին:\n\n    Առավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում մարգարիտների միաձուլման բոլոր հնարավոր կարգերը\n    և օգտագործում է դինամիկ ծրագրավորում առավելագույն էներգիան հաշվարկելու համար:\n\n    Արգումենտներ:\n        beads: Ամբողջ թվերի ցանկ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է մարգարիտի գլուխ արժեքը և\n               նախորդ մարգարիտի պոչ արժեքը: Վերջին մարգարիտի պոչ արժեքը ենթադրվում է\n               համընկնել առաջին մարգարիտի գլուխ արժեքի հետ վզնոցի շրջանաձև բնույթի պատճառով:\n\n    Վերադարձնում է:\n        Ամբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարող է ստացվել բոլոր մարգարիտների օպտիմալ միաձուլմամբ:\n\n    Օրինակներ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Այս հաջորդականությունը ներկայացնում է մարգարիտներ արժեքներով (2,3), (3,5), (5,10), (10,2): Առավելագույն էներգիան,\n        որը ազատվում է նրանց օպտիմալ կարգով միաձուլմամբ, 710 է:\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Այս հաջորդականությունը ներկայացնում է մարգարիտներ արժեքներով (1,2), (2,3), (3,4), (4,1): Առավելագույն էներգիան,\n        որը ազատվում է նրանց օպտիմալ կարգով միաձուլմամբ, 48 է.\n    \"\"\"",
      "bn": "def max_energy(beads):\n    \"\"\"\n    একটি নেকলেসের মুক্তোগুলিকে একত্রিত করে যে সর্বাধিক শক্তি মুক্তি পেতে পারে তা গণনা করুন।\n\n    ফাংশনটি একটি পূর্ণসংখ্যার তালিকা নেয় যা নেকলেসের মুক্তোগুলির শক্তি উপস্থাপন করে, যেখানে\n    প্রতিটি মুক্তোর একটি মাথা এবং একটি লেজ মান থাকে। প্রতিটি মুক্তোর মাথা মান অবশ্যই পরবর্তী মুক্তোর\n    লেজ মানের সাথে মেলে। নেকলেসটি বৃত্তাকার, এবং দুটি সংলগ্ন মুক্তো একত্রিত করলে যে শক্তি মুক্তি পায়\n    তা প্রথম মুক্তোর মাথা মান, মিলিত মান, এবং দ্বিতীয় মুক্তোর লেজ মানের গুণফলের সমান।\n\n    সর্বাধিক শক্তি মুক্তি পেতে, ফাংশনটি মুক্তোগুলিকে একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে\n    এবং সর্বাধিক শক্তি প্রাপ্তির জন্য গতিশীল প্রোগ্রামিং ব্যবহার করে।\n\n    Args:\n        beads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি মুক্তোর মাথা মান এবং\n               পূর্ববর্তী মুক্তোর লেজ মান উপস্থাপন করে। নেকলেসের বৃত্তাকার প্রকৃতির কারণে\n               শেষ মুক্তোর লেজ মান প্রথম মুক্তোর মাথা মানের সাথে মেলে বলে ধরা হয়।\n\n    Returns:\n        একটি পূর্ণসংখ্যা যা সমস্ত মুক্তোকে সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তি উপস্থাপন করে।\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        এই ক্রমটি (2,3), (3,5), (5,10), (10,2) মানের মুক্তো উপস্থাপন করে। সর্বোত্তম ক্রমে\n        তাদের একত্রিত করে মুক্তি পাওয়া সর্বাধিক শক্তি 710।\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        এই ক্রমটি (1,2), (2,3), (3,4), (4,1) মানের মুক্তো উপস্থাপন করে। সর্বোত্তম ক্রমে\n        তাদের একত্রিত করে মুক্তি পাওয়া সর্বাধিক শক্তি 48।\n    \"\"\"",
      "bg": "def max_energy(beads):\n    \"\"\"\n    Изчислява максималната енергия, която може да бъде освободена чрез сливане на мъниста на огърлица.\n\n    Функцията приема списък от цели числа, представляващи енергийните мъниста на огърлица, където\n    всяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада\n    със стойността на опашката на следващото мънисто в последователността. Огърлицата е кръгова, и сливането\n    на две съседни мъниста освобождава енергия, равна на произведението от стойността на главата на първото мънисто,\n    съвпадащата стойност и стойността на опашката на второто мънисто.\n\n    За да се намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на сливане на мънистата\n    и използва динамично програмиране, за да изчисли максималната енергия, която може да бъде получена.\n\n    Аргументи:\n        beads: Списък от цели числа, където всяко цяло число представлява стойността на главата на мънисто и\n               стойността на опашката на предишното мънисто. Стойността на опашката на последното мънисто се приема,\n               че съвпада със стойността на главата на първото мънисто поради кръговата природа на огърлицата.\n\n    Връща:\n        Цяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално сливане на всички мъниста.\n\n    Примери:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Тази последователност представлява мъниста със стойности (2,3), (3,5), (5,10), (10,2). Максималната енергия,\n        освободена чрез сливането им в оптимален ред, е 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Тази последователност представлява мъниста със стойности (1,2), (2,3), (3,4), (4,1). Максималната енергия,\n        освободена чрез сливането им в оптимален ред, е 48.\n    \"\"\"",
      "zh": "def max_energy(beads):\n    \"\"\"\n    计算通过合并项链上的珠子可以释放的最大能量。\n\n    该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子有一个头部和尾部值。\n    每个珠子的头部值必须与序列中下一个珠子的尾部值匹配。项链是环形的，合并两个相邻\n    的珠子释放的能量等于第一个珠子的头部值、匹配值和第二个珠子的尾部值的乘积。\n\n    为了找到最大能量释放，函数考虑所有可能的珠子合并顺序，并使用动态规划计算可获得的最大能量。\n\n    参数:\n        beads: 一个整数列表，其中每个整数表示一个珠子的头部值和前一个珠子的尾部值。\n               由于项链的环形特性，假设最后一个珠子的尾部值与第一个珠子的头部值匹配。\n\n    返回:\n        一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n    示例:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        该序列表示值为 (2,3), (3,5), (5,10), (10,2) 的珠子。通过以最佳顺序合并它们释放的最大能量是 710。\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        该序列表示值为 (1,2), (2,3), (3,4), (4,1) 的珠子。通过以最佳顺序合并它们释放的最大能量是 48。\n    \"\"\"",
      "fr": "def max_energy(beads):\n    \"\"\"\n    Calculer l'énergie maximale qui peut être libérée en fusionnant des perles sur un collier.\n\n    La fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\n    chaque perle a une valeur de tête et une valeur de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\n    de la perle suivante dans la séquence. Le collier est circulaire, et fusionner deux perles adjacentes\n    libère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\n    et de la valeur de queue de la seconde perle.\n\n    Pour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\n    et utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\n    Args:\n        beads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\n               la valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\n               correspondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\n    Returns:\n        Un entier représentant l'énergie maximale qui peut être obtenue en fusionnant de manière optimale toutes les perles.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Cette séquence représente des perles avec des valeurs (2,3), (3,5), (5,10), (10,2). L'énergie maximale\n        libérée en les fusionnant dans l'ordre optimal est 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Cette séquence représente des perles avec des valeurs (1,2), (2,3), (3,4), (4,1). L'énergie maximale\n        libérée en les fusionnant dans l'ordre optimal est 48.\n    \"\"\"",
      "de": "def max_energy(beads):\n    \"\"\"\n    Berechne die maximale Energie, die durch das Verschmelzen von Perlen auf einer Halskette freigesetzt werden kann.\n\n    Die Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei\n    jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert\n    der nächsten Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Verschmelzen zweier\n    benachbarter Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem übereinstimmenden\n    Wert und dem Schwanzwert der zweiten Perle entspricht.\n\n    Um die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des Verschmelzens\n    von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\n    Argumente:\n        beads: Eine Liste von ganzen Zahlen, wobei jede ganze Zahl den Kopfwert einer Perle und\n               den Schwanzwert der vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird\n               aufgrund der kreisförmigen Natur der Halskette als übereinstimmend mit dem Kopfwert der ersten Perle angenommen.\n\n    Rückgabewert:\n        Eine ganze Zahl, die die maximale Energie darstellt, die durch optimales Verschmelzen aller Perlen erreicht werden kann.\n\n    Beispiele:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Diese Sequenz repräsentiert Perlen mit Werten (2,3), (3,5), (5,10), (10,2). Die maximale Energie,\n        die durch das Verschmelzen in optimaler Reihenfolge freigesetzt wird, beträgt 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Diese Sequenz repräsentiert Perlen mit Werten (1,2), (2,3), (3,4), (4,1). Die maximale Energie,\n        die durch das Verschmelzen in optimaler Reihenfolge freigesetzt wird, beträgt 48.\n    \"\"\"",
      "ha": "def max_energy(beads):\n    \"\"\"\n    Lissafi mafi yawan kuzari da za a iya saki ta hanyar hade beads a kan abin wuya.\n\n    Aikin yana daukar jerin lambobi masu wakiltar beads na kuzari a kan abin wuya, inda\n    kowane bead yana da kima ta gaba da kuma kima ta baya. Kima ta gaba na kowane bead dole ne ya dace da kima ta baya\n    na bead na gaba a jerin. Abin wuya yana zagaye, kuma hade beads biyu masu makwabtaka\n    yana sakin kuzari daidai da samfurin kima ta gaba na bead na farko, kimar da ta dace,\n    da kima ta baya na bead na biyu.\n\n    Don samun mafi yawan sakin kuzari, aikin yana la'akari da dukkan yiwuwar jere na hade beads\n    kuma yana amfani da shirye-shiryen motsi don lissafi mafi yawan kuzari da za a iya samu.\n\n    Args:\n        beads: Jerin lambobi inda kowane lamba yana wakiltar kima ta gaba na bead da\n               kima ta baya na bead na baya. Ana daukar kima ta baya na bead na karshe\n               ya dace da kima ta gaba na bead na farko saboda yanayin zagaye na abin wuya.\n\n    Returns:\n        Lamba mai wakiltar mafi yawan kuzari da za a iya samu ta hanyar hade duk beads din cikin hikima.\n\n    Misalai:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Wannan jerin yana wakiltar beads da kimomi (2,3), (3,5), (5,10), (10,2). Mafi yawan kuzari\n        da aka saki ta hanyar hade su a cikin jere mafi kyau shine 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Wannan jerin yana wakiltar beads da kimomi (1,2), (2,3), (3,4), (4,1). Mafi yawan kuzari\n        da aka saki ta hanyar hade su a cikin jere mafi kyau shine 48.\n    \"\"\"",
      "hi": "def max_energy(beads):\n    \"\"\"\n    मोतियों को एक हार पर मिलाकर जारी की जा सकने वाली अधिकतम ऊर्जा की गणना करें।\n\n    यह फ़ंक्शन एक पूर्णांकों की सूची लेता है जो हार पर ऊर्जा मोतियों का प्रतिनिधित्व करता है, जहाँ\n    प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। प्रत्येक मोती का सिर मान अनुक्रम में अगले मोती के\n    पूंछ मान से मेल खाना चाहिए। हार वृत्ताकार है, और दो आसन्न मोतियों को मिलाने से ऊर्जा जारी होती है जो\n    पहले मोती के सिर मान, मिलान मान, और दूसरे मोती के पूंछ मान के गुणनफल के बराबर होती है।\n\n    अधिकतम ऊर्जा रिलीज़ खोजने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार करता है\n    और अधिकतम प्राप्त की जा सकने वाली ऊर्जा की गणना करने के लिए गतिशील प्रोग्रामिंग का उपयोग करता है।\n\n    Args:\n        beads: पूर्णांकों की एक सूची जहाँ प्रत्येक पूर्णांक एक मोती के सिर मान का प्रतिनिधित्व करता है और\n               पिछले मोती का पूंछ मान। हार की वृत्ताकार प्रकृति के कारण अंतिम मोती का पूंछ मान पहले मोती के\n               सिर मान से मेल खाने की कल्पना की जाती है।\n\n    Returns:\n        एक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा का प्रतिनिधित्व करता है।\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        यह अनुक्रम (2,3), (3,5), (5,10), (10,2) मानों के साथ मोतियों का प्रतिनिधित्व करता है। उन्हें अनुकूल क्रम में\n        मिलाकर जारी की गई अधिकतम ऊर्जा 710 है।\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        यह अनुक्रम (1,2), (2,3), (3,4), (4,1) मानों के साथ मोतियों का प्रतिनिधित्व करता है। उन्हें अनुकूल क्रम में\n        मिलाकर जारी की गई अधिकतम ऊर्जा 48 है।\n    \"\"\"",
      "hu": "def max_energy(beads):\n    \"\"\"\n    Számítsa ki a maximális energiát, amely felszabadulhat a gyöngyök összeolvasztásával egy nyakláncon.\n\n    A függvény egy egész számok listáját veszi, amely a nyaklánc gyöngyeinek energiáját képviseli, ahol\n    minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a\n    következő gyöngy farokértékével a sorozatban. A nyaklánc kör alakú, és két szomszédos gyöngy összeolvasztása\n    olyan energiát szabadít fel, amely egyenlő az első gyöngy fejértékének, a megfelelő értéknek és a második\n    gyöngy farokértékének szorzatával.\n\n    A maximális energia felszabadításának megtalálásához a függvény figyelembe veszi a gyöngyök összeolvasztásának\n    összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\n    Args:\n        beads: Egy egész számok listája, ahol minden egész szám egy gyöngy fejértékét és az előző gyöngy\n               farokértékét képviseli. Az utolsó gyöngy farokértéke a nyaklánc körkörös jellege miatt\n               feltételezhetően megegyezik az első gyöngy fejértékével.\n\n    Returns:\n        Egy egész szám, amely a gyöngyök optimális összeolvasztásával elérhető maximális energiát képviseli.\n\n    Példák:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Ez a sorozat a (2,3), (3,5), (5,10), (10,2) értékű gyöngyöket képviseli. Az optimális sorrendben\n        történő összeolvasztásuk által felszabadított maximális energia 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Ez a sorozat a (1,2), (2,3), (3,4), (4,1) értékű gyöngyöket képviseli. Az optimális sorrendben\n        történő összeolvasztásuk által felszabadított maximális energia 48.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9792826526276801",
      "hy": "0.9535336004429845",
      "bn": "0.9518275641002758",
      "bg": "0.981280477000129",
      "zh": "0.9675817341416769",
      "fr": "0.9877544370091992",
      "de": "0.9648384499492041",
      "ha": "0.9384386846362381",
      "hi": "0.9726126444325286",
      "hu": "0.9560977200317639"
    },
    "canonical_solution": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))",
    "instruction": {
      "en": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\n请用中文为以下Python代码提供一个简洁的自然语言描述（文档字符串），最多使用500个字符。",
      "fr": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nGeben Sie eine prägnante Beschreibung (Docstring) des Python-Codes in deutscher Sprache mit maximal 500 Zeichen.",
      "ha": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9353182013501801",
      "hy": "0.8856909965397564",
      "bn": "0.9053846029282224",
      "bg": "0.8983697723915943",
      "zh": "0.8977577921876257",
      "fr": "0.9690480236144765",
      "de": "0.9232869605405158",
      "ha": "0.9404883515381371",
      "hi": "0.9109764454151166",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_max_energy():\n    assert max_energy([2, 3, 5, 10]) == 710, \"Testcase 1 failed\"\n    assert max_energy([1, 2, 3, 4]) == 80, \"Testcase 2 failed\"\n    assert max_energy([4, 4, 4, 4]) == 192, \"Testcase 3 failed\"\n    assert max_energy([30, 40, 50, 60]) == 372000, \"Testcase 4 failed\"\n    print(\"All testcases passed\")\n\n# Call the test function\ntest_max_energy()",
    "entry_point": "max_energy",
    "signature": "def max_energy(beads):",
    "docstring": {
      "en": "Calculate the maximum energy that can be released by merging beads on a necklace.\n\nThe function takes a list of integers representing the energy beads on a necklace, where\neach bead has a head and a tail value. The head value of each bead must match the tail\nvalue of the next bead in the sequence. The necklace is circular, and merging two adjacent\nbeads releases energy equal to the product of the head value of the first bead, the matching\nvalue, and the tail value of the second bead.\n\nTo find the maximum energy release, the function considers all possible orders of merging beads\nand uses dynamic programming to compute the maximum energy obtainable.\n\nArgs:\nbeads: A list of integers where each integer represents the head value of a bead and\nthe tail value of the previous bead. The tail value of the last bead is assumed\nto match the head value of the first bead due to the circular nature of the necklace.\n\nReturns:\nAn integer representing the maximum energy that can be obtained by optimally merging all beads.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nThis sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\nreleased by merging them in the optimal order is 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nThis sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\nreleased by merging them in the optimal order is 48.",
      "sq": "Llogarit energjinë maksimale që mund të lirohet duke bashkuar rruazat në një varëse.\n\nFunksioni merr një listë të numrave të plotë që përfaqësojnë rruazat e energjisë në një varëse, ku\nçdo rruazë ka një vlerë koke dhe një vlerë bishti. Vlera e kokës së çdo rruaze duhet të përputhet me vlerën e bishtit\ntë rruazës tjetër në sekuencë. Varësja është rrethore, dhe bashkimi i dy rruazave ngjitur liron energji të barabartë me produktin e vlerës së kokës së rruazës së parë, vlerës përputhëse, dhe vlerës së bishtit të rruazës së dytë.\n\nPër të gjetur lirimin maksimal të energjisë, funksioni konsideron të gjitha renditjet e mundshme të bashkimit të rruazave\ndhe përdor programimin dinamik për të llogaritur energjinë maksimale të arritshme.\n\nArgumentet:\nbeads: Një listë e numrave të plotë ku çdo numër përfaqëson vlerën e kokës së një rruaze dhe\nvlerën e bishtit të rruazës së mëparshme. Vlera e bishtit të rruazës së fundit supozohet\ntë përputhet me vlerën e kokës së rruazës së parë për shkak të natyrës rrethore të varëses.\n\nKthen:\nNjë numër i plotë që përfaqëson energjinë maksimale që mund të merret duke bashkuar në mënyrë optimale të gjitha rruazat.\n\nShembuj:\n>>> max_energy([2, 3, 5, 10])\n710\nKjo sekuencë përfaqëson rruaza me vlera (2,3), (3,5), (5,10), (10,2). Energjia maksimale\ne liruar duke i bashkuar ato në rendin optimal është 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nKjo sekuencë përfaqëson rruaza me vlera (1,2), (2,3), (3,4), (4,1). Energjia maksimale\ne liruar duke i bashkuar ato në rendin optimal është 48.",
      "hy": "Հաշվարկել առավելագույն էներգիան, որը կարող է ազատվել մարգարիտներ միացնելիս վզնոցի վրա:\n\nՖունկցիան ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է վզնոցի վրա գտնվող էներգիայի մարգարիտները, որտեղ\nյուրաքանչյուր մարգարիտ ունի գլուխ և պոչ արժեք: Յուրաքանչյուր մարգարիտի գլուխ արժեքը պետք է համընկնի հաջորդ մարգարիտի\nպոչ արժեքի հետ հաջորդականության մեջ: Վզնոցը շրջանաձև է, և երկու հարակից մարգարիտների միացումը ազատում է էներգիա,\nորը հավասար է առաջին մարգարիտի գլուխ արժեքի, համընկնող արժեքի և երկրորդ մարգարիտի պոչ արժեքի արտադրյալին:\n\nԱռավելագույն էներգիայի ազատումը գտնելու համար ֆունկցիան հաշվի է առնում մարգարիտների միացման բոլոր հնարավոր կարգերը\nև օգտագործում է դինամիկ ծրագրավորում առավելագույն էներգիան հաշվելու համար:\n\nԱրձանագրություններ:\nbeads: Ամբողջ թվերի ցուցակ, որտեղ յուրաքանչյուր ամբողջ թիվ ներկայացնում է մարգարիտի գլուխ արժեքը և\nնախորդ մարգարիտի պոչ արժեքը: Վերջին մարգարիտի պոչ արժեքը ենթադրվում է, որ համընկնում է առաջին մարգարիտի գլուխ արժեքի հետ\nվզնոցի շրջանաձև բնույթի պատճառով:\n\nՎերադարձնում է:\nԱմբողջ թիվ, որը ներկայացնում է առավելագույն էներգիան, որը կարող է ստացվել բոլոր մարգարիտները օպտիմալ միացնելով:\n\nՕրինակներ:\n>>> max_energy([2, 3, 5, 10])\n710\nԱյս հաջորդականությունը ներկայացնում է մարգարիտներ արժեքներով (2,3), (3,5), (5,10), (10,2): Առավելագույն էներգիան,\nորն ազատվում է նրանց օպտիմալ կարգով միացնելիս, 710 է:\n\n>>> max_energy([1, 2, 3, 4])\n48\nԱյս հաջորդականությունը ներկայացնում է մարգարիտներ արժեքներով (1,2), (2,3), (3,4), (4,1): Առավելագույն էներգիան,\nորն ազատվում է նրանց օպտիմալ կարգով միացնելիս, 48 է:",
      "bn": "নেকলেসের মুক্তো একত্রিত করে যে সর্বাধিক শক্তি মুক্তি পেতে পারে তা গণনা করুন।\n\nফাংশনটি একটি পূর্ণসংখ্যার তালিকা গ্রহণ করে যা নেকলেসের মুক্তোগুলির শক্তি উপস্থাপন করে, যেখানে প্রতিটি মুক্তোর একটি মাথা এবং একটি লেজের মান থাকে। প্রতিটি মুক্তোর মাথার মান অবশ্যই পরবর্তী মুক্তোর লেজের মানের সাথে মিলে যেতে হবে। নেকলেসটি বৃত্তাকার, এবং দুটি সংলগ্ন মুক্তো একত্রিত করলে যে শক্তি মুক্তি পায় তা প্রথম মুক্তোর মাথার মান, মিলের মান এবং দ্বিতীয় মুক্তোর লেজের মানের গুণফলের সমান।\n\nসর্বাধিক শক্তি মুক্তি পেতে, ফাংশনটি মুক্তো একত্রিত করার সমস্ত সম্ভাব্য ক্রম বিবেচনা করে এবং গতিশীল প্রোগ্রামিং ব্যবহার করে সর্বাধিক শক্তি অর্জনযোগ্যতা গণনা করে।\n\nআর্গস:\nbeads: পূর্ণসংখ্যার একটি তালিকা যেখানে প্রতিটি পূর্ণসংখ্যা একটি মুক্তোর মাথার মান এবং পূর্ববর্তী মুক্তোর লেজের মান উপস্থাপন করে। নেকলেসের বৃত্তাকার প্রকৃতির কারণে শেষ মুক্তোর লেজের মান প্রথম মুক্তোর মাথার মানের সাথে মিলে যাওয়া অনুমান করা হয়।\n\nরিটার্নস:\nএকটি পূর্ণসংখ্যা যা সমস্ত মুক্তোকে সর্বোত্তমভাবে একত্রিত করে প্রাপ্ত সর্বাধিক শক্তি উপস্থাপন করে।\n\nউদাহরণ:\n>>> max_energy([2, 3, 5, 10])\n710\nএই ক্রমটি (2,3), (3,5), (5,10), (10,2) মানের মুক্তো উপস্থাপন করে। তাদের সর্বোত্তম ক্রমে একত্রিত করে মুক্তি পাওয়া সর্বাধিক শক্তি 710।\n\n>>> max_energy([1, 2, 3, 4])\n48\nএই ক্রমটি (1,2), (2,3), (3,4), (4,1) মানের মুক্তো উপস্থাপন করে। তাদের সর্বোত্তম ক্রমে একত্রিত করে মুক্তি পাওয়া সর্বাধিক শক্তি 48।",
      "bg": "Изчислете максималната енергия, която може да бъде освободена чрез сливане на мъниста на огърлица.\n\nФункцията приема списък от цели числа, представляващи енергийните мъниста на огърлица, където\nвсяко мънисто има стойност на глава и опашка. Стойността на главата на всяко мънисто трябва да съвпада със стойността на опашката\nна следващото мънисто в последователността. Огърлицата е кръгова, и сливането на две съседни\nмъниста освобождава енергия, равна на произведението от стойността на главата на първото мънисто, съвпадащата\nстойност и стойността на опашката на второто мънисто.\n\nЗа да се намери максималното освобождаване на енергия, функцията разглежда всички възможни редове на сливане на мънистата\nи използва динамично програмиране за изчисляване на максималната енергия, която може да бъде получена.\n\nАргументи:\nbeads: Списък от цели числа, където всяко цяло число представлява стойността на главата на мънисто и\nстойността на опашката на предишното мънисто. Стойността на опашката на последното мънисто се предполага,\nче съвпада със стойността на главата на първото мънисто поради кръговата природа на огърлицата.\n\nВръща:\nЦяло число, представляващо максималната енергия, която може да бъде получена чрез оптимално сливане на всички мъниста.\n\nПримери:\n>>> max_energy([2, 3, 5, 10])\n710\nТази последователност представлява мъниста със стойности (2,3), (3,5), (5,10), (10,2). Максималната енергия,\nосвободена чрез сливането им в оптимален ред, е 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nТази последователност представлява мъниста със стойности (1,2), (2,3), (3,4), (4,1). Максималната енергия,\nосвободена чрез сливането им в оптимален ред, е 48.",
      "zh": "计算通过合并项链上的珠子可以释放的最大能量。\n\n该函数接受一个整数列表，表示项链上的能量珠子，其中每个珠子都有一个头部和尾部值。每个珠子的头部值必须与序列中下一个珠子的尾部值匹配。项链是环形的，合并两个相邻的珠子释放的能量等于第一个珠子的头部值、匹配值和第二个珠子的尾部值的乘积。\n\n为了找到最大能量释放，函数考虑合并珠子的所有可能顺序，并使用动态规划计算可获得的最大能量。\n\n参数：\nbeads: 一个整数列表，其中每个整数表示一个珠子的头部值和前一个珠子的尾部值。由于项链的环形特性，假定最后一个珠子的尾部值与第一个珠子的头部值匹配。\n\n返回：\n一个整数，表示通过最佳合并所有珠子可以获得的最大能量。\n\n示例：\n>>> max_energy([2, 3, 5, 10])\n710\n这个序列表示值为 (2,3), (3,5), (5,10), (10,2) 的珠子。通过以最佳顺序合并它们释放的最大能量是 710。\n\n>>> max_energy([1, 2, 3, 4])\n48\n这个序列表示值为 (1,2), (2,3), (3,4), (4,1) 的珠子。通过以最佳顺序合并它们释放的最大能量是 48。",
      "fr": "Calculer l'énergie maximale pouvant être libérée en fusionnant des perles sur un collier.\n\nLa fonction prend une liste d'entiers représentant les perles d'énergie sur un collier, où\nchaque perle a une valeur de tête et de queue. La valeur de tête de chaque perle doit correspondre à la valeur de queue\nde la perle suivante dans la séquence. Le collier est circulaire, et la fusion de deux perles adjacentes\nlibère une énergie égale au produit de la valeur de tête de la première perle, de la valeur correspondante,\net de la valeur de queue de la seconde perle.\n\nPour trouver la libération d'énergie maximale, la fonction considère tous les ordres possibles de fusion des perles\net utilise la programmation dynamique pour calculer l'énergie maximale obtenable.\n\nArgs:\nbeads: Une liste d'entiers où chaque entier représente la valeur de tête d'une perle et\nla valeur de queue de la perle précédente. La valeur de queue de la dernière perle est supposée\ncorrespondre à la valeur de tête de la première perle en raison de la nature circulaire du collier.\n\nReturns:\nUn entier représentant l'énergie maximale pouvant être obtenue en fusionnant de manière optimale toutes les perles.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nCette séquence représente des perles avec des valeurs (2,3), (3,5), (5,10), (10,2). L'énergie maximale\nlibérée en les fusionnant dans l'ordre optimal est 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nCette séquence représente des perles avec des valeurs (1,2), (2,3), (3,4), (4,1). L'énergie maximale\nlibérée en les fusionnant dans l'ordre optimal est 48.",
      "de": "Berechne die maximale Energie, die durch das Zusammenführen von Perlen auf einer Halskette freigesetzt werden kann.\n\nDie Funktion nimmt eine Liste von ganzen Zahlen, die die Energieperlen auf einer Halskette darstellen, wobei jede Perle einen Kopf- und einen Schwanzwert hat. Der Kopfwert jeder Perle muss mit dem Schwanzwert der nächsten Perle in der Sequenz übereinstimmen. Die Halskette ist kreisförmig, und das Zusammenführen von zwei benachbarten Perlen setzt Energie frei, die dem Produkt des Kopfwerts der ersten Perle, dem passenden Wert und dem Schwanzwert der zweiten Perle entspricht.\n\nUm die maximale Energiefreisetzung zu finden, berücksichtigt die Funktion alle möglichen Reihenfolgen des Zusammenführens von Perlen und verwendet dynamische Programmierung, um die maximal erreichbare Energie zu berechnen.\n\nArgs:\nbeads: Eine Liste von ganzen Zahlen, wobei jede ganze Zahl den Kopfwert einer Perle und den Schwanzwert der vorherigen Perle darstellt. Der Schwanzwert der letzten Perle wird aufgrund der kreisförmigen Natur der Halskette als passend zum Kopfwert der ersten Perle angenommen.\n\nReturns:\nEine ganze Zahl, die die maximale Energie darstellt, die durch optimales Zusammenführen aller Perlen gewonnen werden kann.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nDiese Sequenz repräsentiert Perlen mit Werten (2,3), (3,5), (5,10), (10,2). Die maximale Energie, die durch das Zusammenführen in optimaler Reihenfolge freigesetzt wird, beträgt 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nDiese Sequenz repräsentiert Perlen mit Werten (1,2), (2,3), (3,4), (4,1). Die maximale Energie, die durch das Zusammenführen in optimaler Reihenfolge freigesetzt wird, beträgt 48.",
      "ha": "Ƙididdige mafi ƙarancin kuzari da za a iya saki ta hanyar haɗa beads a kan abin wuya.\n\nAikin yana ɗaukar jerin lambobi masu wakiltar beads na kuzari a kan abin wuya, inda\nkowanne bead yana da ƙimar kai da ƙimar wutsiya. Dole ne ƙimar kai ta kowanne bead ta dace da ƙimar wutsiya\nna bead na gaba a jerin. Abin wuya yana da zagaye, kuma haɗa beads guda biyu masu makwabtaka\nyana sakin kuzari daidai da samfurin ƙimar kai na bead na farko, ƙimar da ta dace, da ƙimar wutsiya na bead na biyu.\n\nDon nemo mafi ƙarancin sakin kuzari, aikin yana la'akari da dukkan yiwuwar jeri na haɗa beads\nkuma yana amfani da shirye-shiryen motsi don ƙididdige mafi ƙarancin kuzari da za a iya samu.\n\nArgs:\nbeads: Jerin lambobi inda kowanne lamba yana wakiltar ƙimar kai na bead da\nƙimar wutsiya na bead na baya. Ana ɗauka cewa ƙimar wutsiya na bead na ƙarshe tana dacewa\nda ƙimar kai na bead na farko saboda yanayin zagaye na abin wuya.\n\nReturns:\nWani lamba wanda ke wakiltar mafi ƙarancin kuzari da za a iya samu ta hanyar haɗa duk beads cikin hikima.\n\nMisalai:\n>>> max_energy([2, 3, 5, 10])\n710\nWannan jerin yana wakiltar beads tare da ƙimar (2,3), (3,5), (5,10), (10,2). Mafi ƙarancin kuzari\nda aka saki ta hanyar haɗa su cikin jeri mafi kyau shine 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nWannan jerin yana wakiltar beads tare da ƙimar (1,2), (2,3), (3,4), (4,1). Mafi ƙarancin kuzari\nda aka saki ta hanyar haɗa su cikin jeri mafi kyau shine 48.",
      "hi": "माला पर मोतियों को मिलाने से जारी की जा सकने वाली अधिकतम ऊर्जा की गणना करें।\n\nयह फ़ंक्शन एक पूर्णांकों की सूची लेता है जो माला पर ऊर्जा मोतियों का प्रतिनिधित्व करती है, जहाँ प्रत्येक मोती का एक सिर और एक पूंछ मान होता है। प्रत्येक मोती का सिर मान अनुक्रम में अगले मोती के पूंछ मान से मेल खाना चाहिए। माला वृत्ताकार है, और दो आसन्न मोतियों को मिलाने से जारी ऊर्जा पहले मोती के सिर मान, मिलान मान, और दूसरे मोती के पूंछ मान के गुणनफल के बराबर होती है।\n\nअधिकतम ऊर्जा जारी करने के लिए, फ़ंक्शन मोतियों को मिलाने के सभी संभावित क्रमों पर विचार करता है और गतिशील प्रोग्रामिंग का उपयोग करके प्राप्त की जा सकने वाली अधिकतम ऊर्जा की गणना करता है।\n\nआर्ग्स:\nbeads: पूर्णांकों की एक सूची जहाँ प्रत्येक पूर्णांक एक मोती के सिर मान और पिछले मोती के पूंछ मान का प्रतिनिधित्व करता है। माला की वृत्ताकार प्रकृति के कारण अंतिम मोती का पूंछ मान पहले मोती के सिर मान से मेल खाने वाला माना जाता है।\n\nवापसी:\nएक पूर्णांक जो सभी मोतियों को अनुकूल रूप से मिलाकर प्राप्त की जा सकने वाली अधिकतम ऊर्जा का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> max_energy([2, 3, 5, 10])\n710\nयह अनुक्रम (2,3), (3,5), (5,10), (10,2) मानों वाले मोतियों का प्रतिनिधित्व करता है। उन्हें अनुकूल क्रम में मिलाने से जारी अधिकतम ऊर्जा 710 है।\n\n>>> max_energy([1, 2, 3, 4])\n48\nयह अनुक्रम (1,2), (2,3), (3,4), (4,1) मानों वाले मोतियों का प्रतिनिधित्व करता है। उन्हें अनुकूल क्रम में मिलाने से जारी अधिकतम ऊर्जा 48 है।",
      "hu": "Számítsa ki a maximális energiát, amely a gyöngyök összeolvasztásával szabadulhat fel egy nyakláncon.\n\nA függvény egy egész számokból álló listát vesz át, amely a nyaklánc gyöngyeinek energiáját képviseli, ahol minden gyöngynek van egy fej- és egy farokértéke. Minden gyöngy fejértékének meg kell egyeznie a következő gyöngy farokértékével a sorozatban. A nyaklánc körkörös, és két szomszédos gyöngy összeolvasztása energiát szabadít fel, amely megegyezik az első gyöngy fejértékének, az egyező értéknek és a második gyöngy farokértékének szorzatával.\n\nA maximális energiafelszabadulás megtalálásához a függvény figyelembe veszi a gyöngyök összeolvasztásának összes lehetséges sorrendjét, és dinamikus programozást használ a maximálisan elérhető energia kiszámításához.\n\nArgs:\nbeads: Egy egész számokból álló lista, ahol minden egész szám egy gyöngy fejértékét és az előző gyöngy farokértékét képviseli. Az utolsó gyöngy farokértéke feltételezhetően megegyezik az első gyöngy fejértékével a nyaklánc körkörös jellege miatt.\n\nReturns:\nEgy egész szám, amely az összes gyöngy optimális összeolvasztásával elérhető maximális energiát képviseli.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nEz a sorozat a (2,3), (3,5), (5,10), (10,2) értékű gyöngyöket képviseli. Az optimális sorrendben történő összeolvasztásuk által felszabadított maximális energia 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nEz a sorozat a (1,2), (2,3), (3,4), (4,1) értékű gyöngyöket képviseli. Az optimális sorrendben történő összeolvasztásuk által felszabadított maximális energia 48."
    },
    "docstring_bertscore": {
      "sq": "0.9772570200018863",
      "hy": "0.9390208702830514",
      "bn": "0.922349027881269",
      "bg": "0.9805697774967862",
      "zh": "0.970411621180281",
      "fr": "0.988875308249379",
      "de": "0.9907716324971191",
      "ha": "0.9461044269315175",
      "hi": "0.962110857556833",
      "hu": "0.9641571477422545"
    }
  },
  {
    "task_id": "Python/20",
    "prompt": {
      "en": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "sq": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Konverton një listë të koeficientëve të polinomit në një përfaqësim të formatuar si varg.\n\n    Funksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\n    të cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg që\n    përfaqëson polinomin me rregullat e mëposhtme:\n    - Termat me një koeficient zero janë të lënë jashtë.\n    - Shenja e secilit term përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n    - Vlera absolute e koeficientit tregohet përveç nëse është 1 dhe termi përfshin variablën `x`.\n    - Pjesa e variablës formatohet bazuar në shkallën e saj; `x^degree` për shkallë > 1, `x` për shkallë 1, dhe\n      asgjë për shkallë 0 (termi konstant).\n    - Termat janë të bashkuar pa hapësira shtesë, duke filluar me termi me shkallën më të lartë.\n\n    Args:\n        n (int): Shkalla më e lartë e polinomit.\n        coeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\n    Returns:\n        str: Përfaqësimi si varg i polinomit.\n\n    Shembuj:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "hy": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Փոխակերպում է բազմանդամի գործակիցների ցուցակը ձևաչափված տողային ներկայացման:\n\n    Ֆունկցիան ընդունում է բազմանդամի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\n    որոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ: Այն վերադարձնում է տող, որը\n    ներկայացնում է բազմանդամը հետևյալ կանոններով.\n    - Գործակիցը զրո ունեցող անդամները բաց են թողնվում:\n    - Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), առաջին անդամի համար առանց առաջատար '+' նշանի:\n    - Գործակցի բացարձակ արժեքը ցուցադրվում է, եթե այն 1 չէ և անդամը ներառում է փոփոխական `x`:\n    - Փոփոխականի մասը ձևաչափվում է ըստ նրա աստիճանի; `x^աստիճան` աստիճան > 1-ի համար, `x` 1-ի համար, և\n      ոչինչ 0 աստիճանի համար (հաստատուն անդամ):\n    - Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից:\n\n    Արգումենտներ:\n        n (int): Բազմանդամի ամենաբարձր աստիճանը:\n        coeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից:\n\n    Վերադարձնում է.\n        str: Բազմանդամի տողային ներկայացումը:\n\n    Օրինակներ.\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "bn": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    পলিনোমিয়াল সহগের একটি তালিকাকে একটি বিন্যাসিত স্ট্রিং প্রতিনিধিত্বে রূপান্তর করে।\n\n    ফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং একটি সহগের তালিকা `coeffs` গ্রহণ করে,\n    যা সর্বোচ্চ ডিগ্রি টার্ম থেকে ধ্রুবক টার্ম পর্যন্ত সাজানো থাকে। এটি একটি স্ট্রিং ফেরত দেয় যা\n    নিম্নলিখিত নিয়মগুলির সাথে পলিনোমিয়ালকে উপস্থাপন করে:\n    - সহগ শূন্য হলে টার্মগুলি বাদ দেওয়া হয়।\n    - প্রতিটি টার্মের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক জন্য, - ঋণাত্মক জন্য), প্রথম টার্মের জন্য কোন নেতৃস্থানীয় '+' নেই।\n    - সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং টার্মটিতে ভেরিয়েবল `x` অন্তর্ভুক্ত থাকে।\n    - ভেরিয়েবল অংশটি তার ডিগ্রির উপর ভিত্তি করে বিন্যাসিত হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\n      ডিগ্রি 0 (ধ্রুবক টার্ম) এর জন্য কিছুই নয়।\n    - টার্মগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি টার্ম দিয়ে শুরু হয়।\n\n    Args:\n        n (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\n        coeffs (List[int]): সহগের একটি তালিকা, সর্বোচ্চ ডিগ্রি টার্মের সহগ দিয়ে শুরু হয়।\n\n    Returns:\n        str: পলিনোমিয়ালের স্ট্রিং প্রতিনিধিত্ব।\n\n    উদাহরণ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "bg": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\n    Функцията приема най-високата степен `n` на полинома и списък с коефициенти `coeffs`,\n    които са подредени от термина с най-висока степен до константния термин. Връща низ, който\n    представлява полинома със следните правила:\n    - Термини с коефициент нула се пропускат.\n    - Знакът на всеки термин се определя (+ за положителен, - за отрицателен), без водещ '+' за първия термин.\n    - Показва се абсолютната стойност на коефициента, освен ако не е 1 и терминът включва променливата `x`.\n    - Частта с променливата се форматира според степента; `x^степен` за степен > 1, `x` за степен 1 и\n      нищо за степен 0 (константен термин).\n    - Термините се съединяват без допълнителни интервали, започвайки с термина с най-висока степен.\n\n    Args:\n        n (int): Най-високата степен на полинома.\n        coeffs (List[int]): Списък с коефициенти, започващ с коефициента на термина с най-висока степен.\n\n    Returns:\n        str: Текстовото представяне на полинома.\n\n    Примери:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "zh": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    将多项式系数列表转换为格式化的字符串表示。\n\n    该函数接收多项式的最高次数 `n` 和一个系数列表 `coeffs`，\n    系数按从最高次数项到常数项的顺序排列。它返回一个表示多项式的字符串，规则如下：\n    - 系数为零的项被省略。\n    - 每项的符号由其正负决定（正为+，负为-），首项不带前导'+'。\n    - 除非系数为1且该项包含变量`x`，否则显示系数的绝对值。\n    - 变量部分根据其次数进行格式化；对于次数大于1的项为`x^degree`，次数为1的项为`x`，\n      常数项不显示变量。\n    - 项之间没有额外的空格，按从最高次数项开始连接。\n\n    参数：\n        n (int): 多项式的最高次数。\n        coeffs (List[int]): 系数列表，从最高次数项的系数开始。\n\n    返回：\n        str: 多项式的字符串表示。\n\n    示例：\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "fr": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\n    La fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\n    qui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\n    représente le polynôme avec les règles suivantes :\n    - Les termes avec un coefficient de zéro sont omis.\n    - Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n    - La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n    - La partie variable est formatée en fonction de son degré ; `x^degree` pour degree > 1, `x` pour degree 1, et\n      rien pour degree 0 (terme constant).\n    - Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\n    Args:\n        n (int): Le degré le plus élevé du polynôme.\n        coeffs (List[int]): Une liste de coefficients, en commençant par le coefficient du terme de degré le plus élevé.\n\n    Returns:\n        str: La représentation sous forme de chaîne du polynôme.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "de": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Konvertiert eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation.\n\n    Die Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen,\n    die von dem höchsten Grad-Term bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück, die\n    das Polynom mit den folgenden Regeln darstellt:\n    - Terme mit einem Koeffizienten von Null werden weggelassen.\n    - Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n    - Der Absolutwert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n    - Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und\n      nichts für Grad 0 (konstanter Term).\n    - Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem höchsten Grad-Term.\n\n    Args:\n        n (int): Der höchste Grad des Polynoms.\n        coeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des höchsten Grad-Terms.\n\n    Returns:\n        str: Die Zeichenfolgenrepräsentation des Polynoms.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "ha": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Canza jerin ƙididdigar polynomial zuwa tsarin rubutu mai tsari.\n\n    Aikin yana karɓar mafi girman darajar `n` na polynomial da jerin ƙididdiga `coeffs`,\n    waɗanda aka tsara daga mafi girman darajar zuwa ƙimar dindindin. Yana mayar da rubutu wanda\n    ke wakiltar polynomial tare da waɗannan ƙa'idojin:\n    - Ana cire sharuɗɗan da ke da ƙididdiga na sifili.\n    - Ana tantance alamar kowanne sharadi (+ don tabbatacce, - don korau), ba tare da '+' na farko ba don sharadi na farko.\n    - Ana nuna ƙimar cikakkiyar ƙididdiga sai dai idan yana da 1 kuma sharadin ya haɗa da canji `x`.\n    - Ana tsara ɓangaren canji bisa ga darajarsa; `x^degree` don degree > 1, `x` don degree 1, kuma\n      babu komai don degree 0 (sharadi na dindindin).\n    - Ana haɗa sharuɗɗan ba tare da ƙarin sarari ba, farawa da sharadi mafi girman daraja.\n\n    Args:\n        n (int): Mafi girman darajar polynomial.\n        coeffs (List[int]): Jerin ƙididdiga, farawa da ƙididdigar sharadi mafi girman daraja.\n\n    Returns:\n        str: Wakilcin rubutu na polynomial.\n\n    Misalai:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "hi": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    बहुपद गुणांक की एक सूची को स्वरूपित स्ट्रिंग प्रतिनिधित्व में परिवर्तित करता है।\n\n    फ़ंक्शन बहुपद की उच्चतम डिग्री `n` और गुणांक `coeffs` की एक सूची लेता है,\n    जो उच्चतम डिग्री पद से स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो\n    निम्नलिखित नियमों के साथ बहुपद का प्रतिनिधित्व करता है:\n    - शून्य गुणांक वाले पद छोड़ दिए जाते हैं।\n    - प्रत्येक पद का चिह्न निर्धारित होता है (+ सकारात्मक के लिए, - नकारात्मक के लिए), पहले पद के लिए कोई अग्रणी '+' नहीं होता।\n    - गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 न हो और पद में चर `x` शामिल हो।\n    - चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; `x^degree` डिग्री > 1 के लिए, `x` डिग्री 1 के लिए, और\n      कुछ नहीं डिग्री 0 (स्थिरांक पद) के लिए।\n    - पद बिना अतिरिक्त रिक्तियों के जोड़े जाते हैं, उच्चतम डिग्री पद से शुरू होते हैं।\n\n    Args:\n        n (int): बहुपद की उच्चतम डिग्री।\n        coeffs (List[int]): गुणांकों की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\n    Returns:\n        str: बहुपद का स्ट्रिंग प्रतिनिधित्व।\n\n    उदाहरण:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "hu": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Egy polinomiális együtthatók listáját formázott sztring reprezentációvá alakítja.\n\n    A függvény a polinom legmagasabb fokszámát `n` és egy együtthatók listáját `coeffs` veszi be,\n    amelyeket a legmagasabb fokszámú tagtól a konstans tagig rendez. Visszaad egy sztringet, amely\n    a polinomot a következő szabályok szerint ábrázolja:\n    - A nulla együtthatójú tagok elhagyásra kerülnek.\n    - Minden tag előjele meghatározásra kerül (+ a pozitív, - a negatív esetén), az első tagnál nincs vezető '+'.\n    - Az együttható abszolút értéke megjelenik, kivéve ha 1 és a tag tartalmazza az `x` változót.\n    - A változó rész a fokszám alapján formázott; `x^degree` ha a fokszám > 1, `x` ha a fokszám 1, és\n      semmi ha a fokszám 0 (konstans tag).\n    - A tagok további szóközök nélkül kapcsolódnak össze, a legmagasabb fokszámú taggal kezdve.\n\n    Paraméterek:\n        n (int): A polinom legmagasabb fokszáma.\n        coeffs (List[int]): Egy együtthatók listája, a legmagasabb fokszámú tag együtthatójával kezdve.\n\n    Visszatér:\n        str: A polinom sztring reprezentációja.\n\n    Példák:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9911589617401372",
      "hy": "0.9708905190289561",
      "bn": "0.9848550293372329",
      "bg": "0.9853106874313269",
      "zh": "0.9202218951307665",
      "fr": "0.9901650153134386",
      "de": "0.9870971690783547",
      "ha": "0.9658327936366647",
      "hi": "0.9795986735639066",
      "hu": "0.9615536993380301"
    },
    "canonical_solution": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)",
    "instruction": {
      "en": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nՏվեք Python կոդի հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nBa da takaitaccen bayanin yanayi na dabi'a (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9353182013501801",
      "hy": "0.9269590403947078",
      "bn": "0.9096507862520897",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9530483464221162",
      "hi": "0.91110952777041",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_polynomial_to_string():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ntest_polynomial_to_string()",
    "entry_point": "polynomial_to_string",
    "signature": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:",
    "docstring": {
      "en": "Converts a list of polynomial coefficients into a formatted string representation.\n\nThe function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\nwhich are ordered from the highest degree term to the constant term. It returns a string that\nrepresents the polynomial with the following rules:\n- Terms with a coefficient of zero are omitted.\n- The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n- The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n- The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\nnothing for degree 0 (constant term).\n- Terms are joined without additional spaces, starting with the highest degree term.\n\nArgs:\nn (int): The highest degree of the polynomial.\ncoeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\nReturns:\nstr: The string representation of the polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "sq": "Konverton një listë të koeficientëve të polinomit në një paraqitje të formatuar si varg.\n\nFunksioni merr shkallën më të lartë `n` të polinomit dhe një listë të koeficientëve `coeffs`,\ntë cilët janë të renditur nga termi me shkallën më të lartë deri te termi konstant. Ai kthen një varg që\npërfaqëson polinomin me rregullat e mëposhtme:\n- Termat me një koeficient zero janë të lënë jashtë.\n- Shenja e çdo termi përcaktohet (+ për pozitiv, - për negativ), pa '+' në fillim për termi i parë.\n- Vlera absolute e koeficientit tregohet përveç nëse është 1 dhe termi përfshin variablin `x`.\n- Pjesa e variablit formatohet bazuar në shkallën e tij; `x^shkalla` për shkallë > 1, `x` për shkallë 1, dhe\nasgjë për shkallë 0 (termi konstant).\n- Termat bashkohen pa hapësira shtesë, duke filluar me termin me shkallën më të lartë.\n\nArgumentet:\nn (int): Shkalla më e lartë e polinomit.\ncoeffs (List[int]): Një listë e koeficientëve, duke filluar me koeficientin e termit me shkallën më të lartë.\n\nKthen:\nstr: Paraqitja si varg e polinomit.\n\nShembuj:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "hy": "Փոխակերպում է բազմանդամի գործակիցների ցուցակը ձևաչափված տողային ներկայացման:\n\nՖունկցիան ընդունում է բազմանդամի ամենաբարձր աստիճանը `n` և գործակիցների ցուցակը `coeffs`,\nորոնք դասավորված են ամենաբարձր աստիճանի անդամից մինչև հաստատուն անդամ: Այն վերադարձնում է տող, որը\nներկայացնում է բազմանդամը հետևյալ կանոններով.\n- Զրոյական գործակցով անդամները բաց են թողնվում:\n- Յուրաքանչյուր անդամի նշանը որոշվում է (+ դրականների համար, - բացասականների համար), առանց առաջին անդամի համար '+' նշանի:\n- Գործակցի բացարձակ արժեքը ցուցադրվում է, եթե այն 1 չէ և անդամը պարունակում է փոփոխական `x`:\n- Փոփոխականի մասը ձևաչափվում է ըստ նրա աստիճանի; `x^աստիճան` աստիճան > 1-ի համար, `x` 1-ի համար, և\nոչինչ 0-ի համար (հաստատուն անդամ):\n- Անդամները միացվում են առանց լրացուցիչ բացատների, սկսելով ամենաբարձր աստիճանի անդամից:\n\nԱրգումենտներ:\nn (int): Բազմանդամի ամենաբարձր աստիճանը:\ncoeffs (List[int]): Գործակիցների ցուցակ, սկսած ամենաբարձր աստիճանի անդամի գործակցից:\n\nՎերադարձնում է:\nstr: Բազմանդամի տողային ներկայացումը:\n\nՕրինակներ:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "bn": "পলিনোমিয়াল সহগের একটি তালিকাকে একটি বিন্যাসিত স্ট্রিং উপস্থাপনায় রূপান্তর করে।\n\nফাংশনটি পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি `n` এবং একটি সহগের তালিকা `coeffs` গ্রহণ করে,\nযা সর্বোচ্চ ডিগ্রি টার্ম থেকে ধ্রুবক টার্ম পর্যন্ত ক্রমানুসারে সাজানো থাকে। এটি একটি স্ট্রিং প্রদান করে যা\nনিম্নলিখিত নিয়মগুলির সাথে পলিনোমিয়ালকে উপস্থাপন করে:\n- শূন্য সহগযুক্ত টার্মগুলি বাদ দেওয়া হয়।\n- প্রতিটি টার্মের চিহ্ন নির্ধারিত হয় (+ ধনাত্মক, - ঋণাত্মক), প্রথম টার্মের জন্য কোনো প্রাথমিক '+' নেই।\n- সহগের পরম মান দেখানো হয় যদি না এটি 1 হয় এবং টার্মে ভেরিয়েবল `x` অন্তর্ভুক্ত থাকে।\n- ভেরিয়েবল অংশটি তার ডিগ্রির উপর ভিত্তি করে বিন্যাসিত হয়; ডিগ্রি > 1 এর জন্য `x^degree`, ডিগ্রি 1 এর জন্য `x`, এবং\nডিগ্রি 0 (ধ্রুবক টার্ম) এর জন্য কিছুই নয়।\n- টার্মগুলি অতিরিক্ত স্পেস ছাড়াই যোগ করা হয়, সর্বোচ্চ ডিগ্রি টার্ম দিয়ে শুরু হয়।\n\nআর্গস:\nn (int): পলিনোমিয়ালের সর্বোচ্চ ডিগ্রি।\ncoeffs (List[int]): সহগের একটি তালিকা, সর্বোচ্চ ডিগ্রি টার্মের সহগ দিয়ে শুরু।\n\nরিটার্নস:\nstr: পলিনোমিয়ালের স্ট্রিং উপস্থাপনা।\n\nউদাহরণ:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "bg": "Преобразува списък от коефициенти на полином в форматирано текстово представяне.\n\nФункцията приема най-високата степен `n` на полинома и списък от коефициенти `coeffs`, които са подредени от термина с най-висока степен до константния термин. Тя връща низ, който представя полинома със следните правила:\n- Термини с коефициент нула се пропускат.\n- Знакът на всеки термин се определя (+ за положителен, - за отрицателен), без водещ '+' за първия термин.\n- Абсолютната стойност на коефициента се показва, освен ако не е 1 и терминът включва променливата `x`.\n- Частта с променливата се форматира в зависимост от степента й; `x^степен` за степен > 1, `x` за степен 1 и нищо за степен 0 (константен термин).\n- Термините се свързват без допълнителни интервали, започвайки с термина с най-висока степен.\n\nАргументи:\nn (int): Най-високата степен на полинома.\ncoeffs (List[int]): Списък от коефициенти, започващ с коефициента на термина с най-висока степен.\n\nВръща:\nstr: Текстовото представяне на полинома.\n\nПримери:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "zh": "将多项式系数列表转换为格式化的字符串表示。\n\n该函数接收多项式的最高次数 `n` 和一个系数列表 `coeffs`，这些系数按从最高次项到常数项的顺序排列。它返回一个表示多项式的字符串，遵循以下规则：\n- 系数为零的项被省略。\n- 每项的符号由其正负决定（正数为 +，负数为 -），首项不带前导 '+'。\n- 系数的绝对值显示，除非系数为 1 且该项包含变量 `x`。\n- 变量部分根据其次数进行格式化；次数大于 1 时为 `x^degree`，次数为 1 时为 `x`，次数为 0（常数项）时不显示。\n- 各项之间没有额外的空格，从最高次项开始连接。\n\n参数：\nn (int): 多项式的最高次数。\ncoeffs (List[int]): 系数列表，从最高次项的系数开始。\n\n返回：\nstr: 多项式的字符串表示。\n\n示例：\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "fr": "Convertit une liste de coefficients de polynôme en une représentation sous forme de chaîne formatée.\n\nLa fonction prend en entrée le degré le plus élevé `n` du polynôme et une liste de coefficients `coeffs`,\nqui sont ordonnés du terme de degré le plus élevé au terme constant. Elle renvoie une chaîne qui\nreprésente le polynôme avec les règles suivantes :\n- Les termes avec un coefficient de zéro sont omis.\n- Le signe de chaque terme est déterminé (+ pour positif, - pour négatif), sans '+' initial pour le premier terme.\n- La valeur absolue du coefficient est affichée sauf si elle est 1 et que le terme inclut la variable `x`.\n- La partie variable est formatée en fonction de son degré ; `x^degree` pour un degré > 1, `x` pour un degré 1, et\nrien pour un degré 0 (terme constant).\n- Les termes sont joints sans espaces supplémentaires, en commençant par le terme de degré le plus élevé.\n\nArgs:\nn (int): Le degré le plus élevé du polynôme.\ncoeffs (List[int]): Une liste de coefficients, en commençant par le coefficient du terme de degré le plus élevé.\n\nReturns:\nstr: La représentation sous forme de chaîne du polynôme.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "de": "Konvertiert eine Liste von Polynomkoeffizienten in eine formatierte Zeichenfolgenrepräsentation.\n\nDie Funktion nimmt den höchsten Grad `n` des Polynoms und eine Liste von Koeffizienten `coeffs` entgegen, die vom höchsten Grad-Term bis zum konstanten Term geordnet sind. Sie gibt eine Zeichenfolge zurück, die das Polynom mit den folgenden Regeln darstellt:\n- Terme mit einem Koeffizienten von Null werden weggelassen.\n- Das Vorzeichen jedes Terms wird bestimmt (+ für positiv, - für negativ), ohne führendes '+' für den ersten Term.\n- Der absolute Wert des Koeffizienten wird angezeigt, es sei denn, er ist 1 und der Term enthält die Variable `x`.\n- Der Variablenteil wird basierend auf seinem Grad formatiert; `x^degree` für Grad > 1, `x` für Grad 1 und nichts für Grad 0 (konstanter Term).\n- Terme werden ohne zusätzliche Leerzeichen verbunden, beginnend mit dem höchsten Grad-Term.\n\nArgs:\nn (int): Der höchste Grad des Polynoms.\ncoeffs (List[int]): Eine Liste von Koeffizienten, beginnend mit dem Koeffizienten des höchsten Grad-Terms.\n\nReturns:\nstr: Die Zeichenfolgenrepräsentation des Polynoms.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "ha": "Canza jerin ƙididdigar polynomial zuwa tsarin rubutu mai tsari.\n\nAikin yana karɓar mafi girman digiri `n` na polynomial da jerin abubuwan `coeffs`, waɗanda aka tsara daga mafi girman digiri zuwa kalmar akai-akai. Yana dawo da kirtani wanda ke wakiltar polynomial tare da waɗannan ƙa'idodin:\n- Ana barin kalmomi tare da ƙimar coefficient na sifili.\n- Ana ƙayyade alamar kowace kalma (+ don tabbatacce, - don korau), ba tare da jagorar '+' don kalma ta farko ba.\n- Ana nuna ƙimar coefficient sai dai idan yana da 1 kuma kalmar tana haɗa da canji `x`.\n- Ana tsara ɓangaren canji bisa ga digirinsa; `x^degree` don digiri > 1, `x` don digiri 1, kuma babu komai don digiri 0 (kalmar akai-akai).\n- Ana haɗa kalmomi ba tare da ƙarin sarari ba, farawa da mafi girman digiri.\n\nArgs:\nn (int): Mafi girman digiri na polynomial.\ncoeffs (List[int]): Jerin coefficients, farawa da coefficient na mafi girman digiri.\n\nReturns:\nstr: Wakilcin kirtani na polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "hi": "पॉलीनोमियल गुणांक की सूची को एक स्वरूपित स्ट्रिंग प्रतिनिधित्व में परिवर्तित करता है।\n\nयह फ़ंक्शन पॉलीनोमियल की उच्चतम डिग्री `n` और गुणांक `coeffs` की एक सूची लेता है, जो उच्चतम डिग्री पद से लेकर स्थिरांक पद तक क्रमबद्ध होते हैं। यह एक स्ट्रिंग लौटाता है जो निम्नलिखित नियमों के साथ पॉलीनोमियल का प्रतिनिधित्व करता है:\n- शून्य गुणांक वाले पदों को छोड़ दिया जाता है।\n- प्रत्येक पद का चिह्न निर्धारित होता है (+ सकारात्मक के लिए, - नकारात्मक के लिए), पहले पद के लिए कोई अग्रणी '+' नहीं होता।\n- गुणांक का परिमाण दिखाया जाता है जब तक कि यह 1 न हो और पद में चर `x` शामिल हो।\n- चर भाग को उसकी डिग्री के आधार पर स्वरूपित किया जाता है; `x^degree` डिग्री > 1 के लिए, `x` डिग्री 1 के लिए, और कुछ नहीं डिग्री 0 (स्थिरांक पद) के लिए।\n- पदों को बिना अतिरिक्त स्थान के जोड़ा जाता है, उच्चतम डिग्री पद से शुरू होकर।\n\nआर्ग्स:\nn (int): पॉलीनोमियल की उच्चतम डिग्री।\ncoeffs (List[int]): गुणांक की एक सूची, उच्चतम डिग्री पद के गुणांक से शुरू होती है।\n\nरिटर्न्स:\nstr: पॉलीनोमियल का स्ट्रिंग प्रतिनिधित्व।\n\nउदाहरण:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "hu": "Konvertál egy polinomiális együtthatólistát egy formázott karakterlánc reprezentációvá.\n\nA függvény a polinom legmagasabb fokszámát, `n`-t és egy `coeffs` együtthatólistát vesz be, amely a legmagasabb fokú tagtól a konstans tagig van rendezve. Egy karakterláncot ad vissza, amely a polinomot az alábbi szabályok szerint ábrázolja:\n- A nulla együtthatójú tagok elhagyásra kerülnek.\n- Minden tag előjele meghatározott (+ a pozitív, - a negatív esetén), az első tagnál nincs vezető '+' jel.\n- Az együttható abszolút értéke megjelenik, kivéve ha 1 és a tag tartalmazza az `x` változót.\n- A változó rész a fokszám alapján van formázva; `x^degree` ha a fokszám > 1, `x` ha a fokszám 1, és semmi ha a fokszám 0 (konstans tag).\n- A tagok további szóközök nélkül vannak összekapcsolva, a legmagasabb fokú taggal kezdve.\n\nArgs:\nn (int): A polinom legmagasabb fokszáma.\ncoeffs (List[int]): Egy együtthatólista, a legmagasabb fokú tag együtthatójával kezdve.\n\nReturns:\nstr: A polinom karakterlánc reprezentációja.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'"
    },
    "docstring_bertscore": {
      "sq": "0.9851638995797422",
      "hy": "0.9715803623422903",
      "bn": "0.9687325985693931",
      "bg": "0.976423368292683",
      "zh": "0.9151790670170528",
      "fr": "0.9746762154611001",
      "de": "0.9825534991121816",
      "ha": "0.9586427711039639",
      "hi": "0.9711656221066894",
      "hu": "0.9579008866307985"
    }
  },
  {
    "task_id": "Python/21",
    "prompt": {
      "en": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    This means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n    90, 88, and 88, and their respective registration numbers are listed alongside their scores.\n    \"\"\"",
      "sq": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Zgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n    \n    Funksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtat pikë,\n    ata pastaj renditen sipas numrit të tyre të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\n    të numrit të planifikuar të rekrutimeve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\n    të kualifikuar për intervistën.\n    \n    Argumentet:\n    - n (int): Numri total i aplikantëve.\n    - m (int): Numri i planifikuar i vullnetarëve për t'u rekrutuar.\n    - applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n    \n    Kthen:\n    - Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secila prej të cilave përfshin\n      numrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n    \n    Shembuj:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Kjo do të thotë se pragu i pikëve të intervistës është 88, dhe ka 5 aplikantë që kualifikohen për intervistë, me pikë 95, 95,\n    90, 88, dhe 88, dhe numrat e tyre përkatës të regjistrimit janë listuar së bashku me pikët e tyre.\n    \"\"\"",
      "hy": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Ընտրում է և որոշում հարցազրույցի միավորների շեմը և դիմորդների ցուցակը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար։\n    \n    Ֆունկցիան դասավորում է դիմորդներին նրանց թեստային միավորների հիման վրա նվազման կարգով։ Եթե մի քանի դիմորդներ ունեն նույն միավորը,\n    ապա նրանք դասավորվում են ըստ իրենց գրանցման համարի աճման կարգով։ Հարցազրույցի միավորների շեմը հաշվարկվում է ըստ նախատեսված\n    հավաքագրման 150%-ի, կլորացված ներքև։ Բոլոր դիմորդները, ովքեր ունեն միավորներ, որոնք հավասար են կամ բարձր են շեմից, համարվում են\n    որակավորված հարցազրույցի համար։\n    \n    Արգումենտներ:\n    - n (int): Դիմորդների ընդհանուր քանակը։\n    - m (int): Նախատեսված հավաքագրվող կամավորների քանակը։\n    - applicants (List[Tuple[int, int]]): Ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային միավորը։\n    \n    Վերադարձնում է:\n    - Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի միավորների շեմը և տուփերի ցուցակ, որոնցից յուրաքանչյուրը ներառում է\n      որակավորված դիմորդների գրանցման համարը և թեստային միավորը։\n    \n    Օրինակներ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Սա նշանակում է, որ հարցազրույցի միավորների շեմը 88 է, և կա 5 դիմորդ, ովքեր որակավորվում են հարցազրույցի համար, միավորներով՝ 95, 95,\n    90, 88 և 88, և նրանց համապատասխան գրանցման համարները նշված են իրենց միավորների կողքին։\n    \"\"\"",
      "bn": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    সাক্ষাৎকারের জন্য প্রার্থী নির্বাচন করে এবং সাক্ষাৎকারের স্কোরের কাটঅফ নির্ধারণ করে এবং যে প্রার্থীরা সাক্ষাৎকার প্রক্রিয়ার জন্য যোগ্য তাদের তালিকা প্রদান করে।\n\n    ফাংশনটি প্রার্থীদের তাদের পরীক্ষার স্কোর অনুযায়ী অবতরণ ক্রমে সাজায়। যদি একাধিক প্রার্থীর একই স্কোর থাকে, তবে তাদের রেজিস্ট্রেশন নম্বর অনুযায়ী আরোহী ক্রমে সাজানো হয়। সাক্ষাৎকারের স্কোর কাটঅফ পরিকল্পিত নিয়োগের সংখ্যার 150% এর ভিত্তিতে গণনা করা হয়, যা নিচের দিকে পূর্ণসংখ্যায় পরিণত করা হয়। সমস্ত প্রার্থী যারা কাটঅফের সমান বা তার বেশি স্কোর পায় তাদের সাক্ষাৎকারের জন্য যোগ্য বিবেচনা করা হয়।\n\n    Args:\n    - n (int): মোট প্রার্থীর সংখ্যা।\n    - m (int): পরিকল্পিত স্বেচ্ছাসেবকদের সংখ্যা যারা নিয়োগ করা হবে।\n    - applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টুপলে একটি প্রার্থীর রেজিস্ট্রেশন নম্বর এবং পরীক্ষার স্কোর থাকে।\n\n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: একটি টুপল যা সাক্ষাৎকারের স্কোর কাটঅফ এবং একটি টুপলের তালিকা ধারণ করে, প্রতিটি টুপলে যোগ্য প্রার্থীদের রেজিস্ট্রেশন নম্বর এবং পরীক্ষার স্কোর অন্তর্ভুক্ত থাকে।\n\n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    এর অর্থ হল সাক্ষাৎকারের স্কোর কাটঅফ 88, এবং 5 জন প্রার্থী সাক্ষাৎকারের জন্য যোগ্য, যাদের স্কোর 95, 95, 90, 88, এবং 88, এবং তাদের সংশ্লিষ্ট রেজিস্ট্রেশন নম্বরগুলি তাদের স্কোরের সাথে তালিকাভুক্ত করা হয়েছে।\n    \"\"\"",
      "bg": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Избира и определя прага на оценките за интервю и списъка с кандидати, които се класират за интервюто.\n    \n    Функцията сортира кандидатите въз основа на техните тестови оценки в низходящ ред. Ако няколко кандидати имат една и съща оценка,\n    те се сортират по регистрационния си номер във възходящ ред. Прагът на оценките за интервю се изчислява въз основа на 150%\n    от планирания брой на набиране, закръглен надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат за\n    класирани за интервюто.\n    \n    Args:\n    - n (int): Общият брой на кандидатите.\n    - m (int): Планираният брой доброволци за набиране.\n    - applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага на оценките за интервю и списък от кортежи, всеки от които включва\n      регистрационния номер и тестовата оценка на класираните кандидати.\n    \n    Примери:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Това означава, че прагът на оценките за интервю е 88, и има 5 кандидати, които се класират за интервюто, с оценки 95, 95,\n    90, 88 и 88, и съответните им регистрационни номера са изброени заедно с техните оценки.\n    \"\"\"",
      "zh": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    选择并确定面试分数线以及符合面试流程的申请人名单。\n    \n    该函数根据申请人的测试成绩按降序排序。如果多个申请人的成绩相同，则按注册号升序排序。面试分数线是基于计划招募人数的150%计算的，并向下取整。所有成绩等于或高于分数线的申请人被认为符合面试资格。\n    \n    参数:\n    - n (int): 申请人的总人数。\n    - m (int): 计划招募的志愿者人数。\n    - applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请人的注册号和测试成绩。\n    \n    返回:\n    - Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数线和一个元组列表的元组，每个元组包括符合资格的申请人的注册号和测试成绩。\n    \n    示例:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    这意味着面试分数线是88，有5名申请人符合面试资格，他们的成绩分别是95, 95, 90, 88和88，他们的注册号与成绩一起列出。\n    \"\"\"",
      "fr": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n    \n    La fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\n    ils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\n    du nombre prévu de recrues, arrondi à l'inférieur. Tous les candidats avec des scores égaux ou supérieurs au seuil sont considérés\n    comme qualifiés pour l'entretien.\n    \n    Args:\n    - n (int): Le nombre total de candidats.\n    - m (int): Le nombre prévu de volontaires à recruter.\n    - applicants (List[Tuple[int, int]]): Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\n      le numéro d'inscription et le score de test des candidats qualifiés.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Cela signifie que le seuil de score d'entretien est de 88, et il y a 5 candidats qui se qualifient pour l'entretien, avec des scores de 95, 95,\n    90, 88 et 88, et leurs numéros d'inscription respectifs sont listés à côté de leurs scores.\n    \"\"\"",
      "de": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Wählt aus und bestimmt die Interview-Punktzahlgrenze und die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n    \n    Die Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben,\n    werden sie dann nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Interview-Punktzahlgrenze wird basierend auf 150%\n    der geplanten Anzahl von Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Grenze sind, werden als\n    qualifiziert für das Interview betrachtet.\n    \n    Argumente:\n    - n (int): Die Gesamtzahl der Bewerber.\n    - m (int): Die geplante Anzahl der zu rekrutierenden Freiwilligen.\n    - applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n    \n    Rückgabewerte:\n    - Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Interview-Punktzahlgrenze und eine Liste von Tupeln enthält, von denen jedes die\n      Registrierungsnummer und die Testergebnisse der qualifizierten Bewerber umfasst.\n    \n    Beispiele:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Dies bedeutet, dass die Interview-Punktzahlgrenze 88 beträgt und es 5 Bewerber gibt, die sich für das Interview qualifizieren, mit Punktzahlen von 95, 95,\n    90, 88 und 88, und ihre jeweiligen Registrierungsnummern sind zusammen mit ihren Punktzahlen aufgeführt.\n    \"\"\"",
      "ha": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Zaɓi kuma kayyade yawan maki na hira da jerin masu nema waɗanda suka cancanci shiga tsarin hira.\n    \n    Aikin yana tsara masu nema bisa ga maki na gwaji daga mafi girma zuwa ƙasa. Idan masu nema da yawa suna da maki iri ɗaya,\n    to za a tsara su bisa ga lambar rajista daga ƙasa zuwa sama. Ana ƙididdige yawan maki na hira bisa ga kashi 150%\n    na yawan masu son daukar aiki da aka shirya, an zagaye ƙasa. Duk masu nema da maki daidai ko mafi girma fiye da yawan maki na hira ana ɗaukar su\n    sun cancanci shiga hirar.\n    \n    Args:\n    - n (int): Jimillar yawan masu nema.\n    - m (int): Yawan masu son daukar aiki da aka shirya.\n    - applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi lambar rajista da maki na gwaji na mai nema.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Tuple mai ɗauke da yawan maki na hira da jerin tuples, kowannensu ya haɗa da\n      lambar rajista da maki na gwaji na masu nema da suka cancanta.\n    \n    Misalai:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Wannan yana nufin cewa yawan maki na hira shine 88, kuma akwai masu nema 5 waɗanda suka cancanci shiga hirar, tare da maki na 95, 95,\n    90, 88, da 88, kuma lambobin rajistarsu suna tare da makinsu.\n    \"\"\"",
      "hi": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    साक्षात्कार स्कोर कटऑफ और उन आवेदकों की सूची का चयन करता है जो साक्षात्कार प्रक्रिया के लिए योग्य हैं।\n\n    यह फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में छांटता है। यदि कई आवेदकों के पास समान स्कोर है,\n    तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में छांटा जाता है। साक्षात्कार स्कोर कटऑफ नियोजित भर्ती संख्या के\n    150% के आधार पर गणना की जाती है, जिसे नीचे की ओर गोल किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के बराबर या उससे अधिक हैं,\n    उन्हें साक्षात्कार के लिए योग्य माना जाता है।\n\n    तर्क:\n    - n (int): कुल आवेदकों की संख्या।\n    - m (int): नियोजित स्वयंसेवकों की संख्या जिन्हें भर्ती किया जाना है।\n    - applicants (List[Tuple[int, int]]): ट्यूपल की एक सूची जहां प्रत्येक ट्यूपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n\n    लौटाता है:\n    - Tuple[int, List[Tuple[int, int]]]: एक ट्यूपल जिसमें साक्षात्कार स्कोर कटऑफ और ट्यूपल की एक सूची शामिल होती है, जिनमें से प्रत्येक में\n      योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल होता है।\n\n    उदाहरण:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    इसका अर्थ है कि साक्षात्कार स्कोर कटऑफ 88 है, और 5 आवेदक हैं जो साक्षात्कार के लिए योग्य हैं, जिनके स्कोर 95, 95,\n    90, 88, और 88 हैं, और उनके संबंधित पंजीकरण संख्या उनके स्कोर के साथ सूचीबद्ध हैं।\n    \"\"\"",
      "hu": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Kiválasztja és meghatározza az interjú ponthatárt és azon jelentkezők listáját, akik megfelelnek az interjú folyamatára.\n\n    A függvény csökkenő sorrendbe rendezi a jelentkezőket a tesztpontszámaik alapján. Ha több jelentkezőnek azonos a pontszáma,\n    akkor regisztrációs számuk alapján növekvő sorrendbe kerülnek. Az interjú ponthatárt a tervezett toborzási létszám 150%-a\n    alapján számítják ki, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a ponthatárt, alkalmasnak\n    minősül az interjúra.\n\n    Args:\n    - n (int): A jelentkezők teljes száma.\n    - m (int): A tervezett önkéntesek száma, akiket toborozni kívánnak.\n    - applicants (List[Tuple[int, int]]): Egy lista, amelyben minden egyes elem egy tuple, amely tartalmazza a jelentkező\n      regisztrációs számát és tesztpontszámát.\n\n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú ponthatárt és egy listát a tuple-ökkel,\n      amelyek mindegyike tartalmazza a regisztrációs számot és a megfelelő jelentkezők tesztpontszámát.\n\n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Ez azt jelenti, hogy az interjú ponthatár 88, és 5 jelentkező van, aki megfelel az interjúra, 95, 95, 90, 88 és 88 pontszámmal,\n    és a megfelelő regisztrációs számuk a pontszámok mellett van feltüntetve.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9774111571775694",
      "hy": "0.962907564015164",
      "bn": "0.9504226514152161",
      "bg": "0.9688499891245846",
      "zh": "0.9449837543217188",
      "fr": "0.9797210298786241",
      "de": "0.9795754338093255",
      "ha": "0.931025202924873",
      "hi": "0.967417466816561",
      "hu": "0.9624501182476406"
    },
    "canonical_solution": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants",
    "instruction": {
      "en": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nՏվեք Python կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\n请用不超过500个字符的中文，为以下Python代码提供一个简洁的自然语言描述（文档字符串）。",
      "fr": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nBada takaitaccen bayani a cikin harshen Hausa (docstring) na lambar Python da bai wuce haruffa 500 ba.",
      "hi": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 अक्षर हों।",
      "hu": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9269590403947078",
      "bn": "0.8657447323066139",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.8674283234162656",
      "hi": "0.8964889413135749",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_select_volunteers():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ntest_select_volunteers()",
    "entry_point": "select_volunteers",
    "signature": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:",
    "docstring": {
      "en": "Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n\nThe function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\nthey are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\nof the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\nqualified for the interview.\n\nArgs:\n- n (int): The total number of applicants.\n- m (int): The planned number of volunteers to be recruited.\n- applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\nthe registration number and test score of qualified applicants.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nThis means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n90, 88, and 88, and their respective registration numbers are listed alongside their scores.",
      "sq": "Përzgjedh dhe përcakton pragun e pikëve të intervistës dhe listën e aplikantëve që kualifikohen për procesin e intervistës.\n\nFunksioni rendit aplikantët bazuar në pikët e tyre të testit në rend zbritës. Nëse disa aplikantë kanë të njëjtën pikë,\nata pastaj renditen sipas numrit të tyre të regjistrimit në rend rritës. Pragu i pikëve të intervistës llogaritet bazuar në 150%\ntë numrit të planifikuar të rekrutimeve, i rrumbullakosur poshtë. Të gjithë aplikantët me pikë të barabarta ose më të larta se pragu konsiderohen\ntë kualifikuar për intervistë.\n\nArgs:\n- n (int): Numri total i aplikantëve.\n- m (int): Numri i planifikuar i vullnetarëve që do të rekrutohen.\n- applicants (List[Tuple[int, int]]): Një listë tuples ku çdo tuple përmban numrin e regjistrimit dhe pikët e testit të një aplikanti.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Një tuple që përmban pragun e pikëve të intervistës dhe një listë tuples, secila prej të cilave përfshin\nnumrin e regjistrimit dhe pikët e testit të aplikantëve të kualifikuar.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nKjo do të thotë që pragu i pikëve të intervistës është 88, dhe ka 5 aplikantë që kualifikohen për intervistë, me pikë 95, 95,\n90, 88, dhe 88, dhe numrat e tyre përkatës të regjistrimit janë të listuar së bashku me pikët e tyre.",
      "hy": "Ընտրում և որոշում է հարցազրույցի միավորների շեմը և դիմորդների ցուցակը, ովքեր որակավորվում են հարցազրույցի գործընթացի համար։\n\nՖունկցիան դասավորում է դիմորդներին ըստ իրենց թեստային միավորների նվազման կարգով։ Եթե մի քանի դիմորդներ ունեն նույն միավորը, ապա նրանք դասավորվում են ըստ իրենց գրանցման համարի աճման կարգով։ Հարցազրույցի միավորների շեմը հաշվարկվում է ըստ նախատեսված հավաքագրվող կամավորների 150%-ի, կլորացված ներքև։ Բոլոր դիմորդները, որոնց միավորները հավասար են կամ բարձր են շեմից, համարվում են որակավորված հարցազրույցի համար։\n\nԱրգումենտներ:\n- n (int): Դիմորդների ընդհանուր քանակը։\n- m (int): Նախատեսված հավաքագրվող կամավորների քանակը։\n- applicants (List[Tuple[int, int]]): Ցուցակ, որը պարունակում է տուփեր, որտեղ յուրաքանչյուր տուփ պարունակում է դիմորդի գրանցման համարը և թեստային միավորը։\n\nՎերադարձնում է:\n- Tuple[int, List[Tuple[int, int]]]: Տուփ, որը պարունակում է հարցազրույցի միավորների շեմը և տուփերի ցուցակ, որոնցից յուրաքանչյուրը ներառում է որակավորված դիմորդների գրանցման համարը և թեստային միավորը։\n\nՕրինակներ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nՍա նշանակում է, որ հարցազրույցի միավորների շեմը 88 է, և կա 5 դիմորդ, ովքեր որակավորվում են հարցազրույցի համար՝ ունենալով 95, 95, 90, 88 և 88 միավորներ, և նրանց համապատասխան գրանցման համարները նշված են իրենց միավորների կողքին։",
      "bn": "সাক্ষাৎকারের স্কোরের কাটঅফ এবং সাক্ষাৎকার প্রক্রিয়ার জন্য যোগ্য আবেদনকারীদের তালিকা নির্বাচন এবং নির্ধারণ করে।\n\nফাংশনটি আবেদনকারীদের তাদের পরীক্ষার স্কোরের উপর ভিত্তি করে অবতরণী ক্রমে সাজায়। যদি একাধিক আবেদনকারীর একই স্কোর থাকে, তবে তাদেরকে তাদের নিবন্ধন নম্বরের উপর ভিত্তি করে আরোহী ক্রমে সাজানো হয়। সাক্ষাৎকারের স্কোরের কাটঅফ পরিকল্পিত নিয়োগের সংখ্যার 150% ভিত্তিতে গণনা করা হয়, যা নিচের দিকে পূর্ণসংখ্যায় গোল করা হয়। সকল আবেদনকারী যাদের স্কোর কাটঅফের সমান বা তার চেয়ে বেশি, তাদের সাক্ষাৎকারের জন্য যোগ্য বলে বিবেচনা করা হয়।\n\nআর্গস:\n- n (int): মোট আবেদনকারীর সংখ্যা।\n- m (int): পরিকল্পিত স্বেচ্ছাসেবকদের সংখ্যা যাদের নিয়োগ করা হবে।\n- applicants (List[Tuple[int, int]]): একটি তালিকা যেখানে প্রতিটি টুপলে একটি আবেদনকারীর নিবন্ধন নম্বর এবং পরীক্ষার স্কোর থাকে।\n\nরিটার্নস:\n- Tuple[int, List[Tuple[int, int]]]: একটি টুপল যা সাক্ষাৎকারের স্কোরের কাটঅফ এবং একটি টুপল তালিকা ধারণ করে, যেখানে প্রতিটি টুপলে যোগ্য আবেদনকারীদের নিবন্ধন নম্বর এবং পরীক্ষার স্কোর অন্তর্ভুক্ত থাকে।\n\nউদাহরণ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nএর অর্থ হল সাক্ষাৎকারের স্কোরের কাটঅফ 88, এবং 5 জন আবেদনকারী সাক্ষাৎকারের জন্য যোগ্য, যাদের স্কোর 95, 95, 90, 88, এবং 88, এবং তাদের সংশ্লিষ্ট নিবন্ধন নম্বর তাদের স্কোরের সাথে তালিকাভুক্ত।",
      "bg": "Избира и определя прага на оценката за интервю и списъка с кандидати, които се квалифицират за процеса на интервю.\n\nФункцията сортира кандидатите въз основа на техните тестови оценки в низходящ ред. Ако няколко кандидати имат еднаква оценка,\nте се сортират по регистрационния си номер във възходящ ред. Прагът на оценката за интервю се изчислява въз основа на 150%\nот планирания брой наемания, закръглено надолу. Всички кандидати с оценки, равни или по-високи от прага, се считат за\nквалифицирани за интервюто.\n\nАргументи:\n- n (int): Общият брой на кандидатите.\n- m (int): Планираният брой доброволци, които ще бъдат наети.\n- applicants (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа регистрационния номер и тестовата оценка на кандидат.\n\nВръща:\n- Tuple[int, List[Tuple[int, int]]]: Кортеж, съдържащ прага на оценката за интервю и списък от кортежи, всеки от които включва\nрегистрационния номер и тестовата оценка на квалифицираните кандидати.\n\nПримери:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nТова означава, че прагът на оценката за интервю е 88, и има 5 кандидати, които се квалифицират за интервюто, с оценки 95, 95,\n90, 88 и 88, и техните съответни регистрационни номера са изброени заедно с техните оценки.",
      "zh": "选择并确定面试分数线以及符合面试流程的申请人名单。\n\n该函数根据申请人的测试分数按降序排序。如果多个申请人的分数相同，则按注册号升序排序。面试分数线是基于计划招募人数的150%计算的，向下取整。所有分数等于或高于分数线的申请人都被认为符合面试资格。\n\n参数:\n- n (int): 申请人的总数。\n- m (int): 计划招募的志愿者人数。\n- applicants (List[Tuple[int, int]]): 一个包含元组的列表，每个元组包含申请人的注册号和测试分数。\n\n返回:\n- Tuple[int, List[Tuple[int, int]]]: 一个包含面试分数线和符合资格的申请人元组列表的元组，每个元组包括注册号和测试分数。\n\n示例:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\n这意味着面试分数线是88，有5名申请人符合面试资格，他们的分数分别是95, 95, 90, 88和88，他们的注册号与分数一起列出。",
      "fr": "Sélectionne et détermine le seuil de score d'entretien et la liste des candidats qui se qualifient pour le processus d'entretien.\n\nLa fonction trie les candidats en fonction de leurs scores de test par ordre décroissant. Si plusieurs candidats ont le même score,\nils sont ensuite triés par leur numéro d'inscription par ordre croissant. Le seuil de score d'entretien est calculé sur la base de 150%\ndu nombre prévu de recrues, arrondi à l'inférieur. Tous les candidats avec des scores égaux ou supérieurs au seuil sont considérés\ncomme qualifiés pour l'entretien.\n\nArgs:\n- n (int): Le nombre total de candidats.\n- m (int): Le nombre prévu de volontaires à recruter.\n- applicants (List[Tuple[int, int]]): Une liste de tuples où chaque tuple contient le numéro d'inscription et le score de test d'un candidat.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Un tuple contenant le seuil de score d'entretien et une liste de tuples, chacun incluant\nle numéro d'inscription et le score de test des candidats qualifiés.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nCela signifie que le seuil de score d'entretien est de 88, et il y a 5 candidats qui se qualifient pour l'entretien, avec des scores de 95, 95,\n90, 88, et 88, et leurs numéros d'inscription respectifs sont listés à côté de leurs scores.",
      "de": "Wählt aus und bestimmt die Interview-Punktzahlgrenze und die Liste der Bewerber, die sich für den Interviewprozess qualifizieren.\n\nDie Funktion sortiert die Bewerber basierend auf ihren Testergebnissen in absteigender Reihenfolge. Wenn mehrere Bewerber die gleiche Punktzahl haben, werden sie anschließend nach ihrer Registrierungsnummer in aufsteigender Reihenfolge sortiert. Die Interview-Punktzahlgrenze wird basierend auf 150% der geplanten Anzahl von Rekruten berechnet, abgerundet. Alle Bewerber mit Punktzahlen, die gleich oder höher als die Grenze sind, gelten als qualifiziert für das Interview.\n\nArgs:\n- n (int): Die Gesamtzahl der Bewerber.\n- m (int): Die geplante Anzahl der Freiwilligen, die rekrutiert werden sollen.\n- applicants (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel die Registrierungsnummer und die Testergebnisse eines Bewerbers enthält.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Ein Tupel, das die Interview-Punktzahlgrenze und eine Liste von Tupeln enthält, von denen jedes die Registrierungsnummer und die Testergebnisse der qualifizierten Bewerber umfasst.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nDies bedeutet, dass die Interview-Punktzahlgrenze 88 ist und es 5 Bewerber gibt, die sich für das Interview qualifizieren, mit Punktzahlen von 95, 95, 90, 88 und 88, und ihre jeweiligen Registrierungsnummern sind zusammen mit ihren Punktzahlen aufgeführt.",
      "ha": "Zabi da ƙayyade ƙimar yanke maki na hira da jerin masu nema waɗanda suka cancanci shiga tsarin hira.\n\nAikin yana jera masu nema bisa ga maki na gwaji a cikin tsari mai sauka. Idan masu nema da yawa suna da irin wannan maki, za a jera su bisa ga lambar rajista a cikin tsari mai hawa. Ana ƙididdige ƙimar yanke maki na hira bisa ga kashi 150% na adadin masu son shiga aikin, an zagaye ƙasa. Duk masu nema da maki daidai ko mafi girma fiye da yanke maki ana ɗaukar su cancanta don hira.\n\nArgs:\n- n (int): Jimillar adadin masu nema.\n- m (int): Adadin masu son shiga aikin da aka tsara.\n- applicants (List[Tuple[int, int]]): Jerin tuples inda kowanne tuple ya ƙunshi lambar rajista da maki na gwajin mai nema.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Tuple wanda ya ƙunshi ƙimar yanke maki na hira da jerin tuples, kowanne daga cikinsu ya haɗa da lambar rajista da maki na gwajin masu nema da suka cancanta.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nWannan yana nufin cewa ƙimar yanke maki na hira shine 88, kuma akwai masu nema 5 waɗanda suka cancanci shiga hirar, tare da maki na 95, 95, 90, 88, da 88, kuma lambobin rajistarsu suna tare da makinsu.",
      "hi": "साक्षात्कार स्कोर कटऑफ और उन आवेदकों की सूची का चयन और निर्धारण करता है जो साक्षात्कार प्रक्रिया के लिए योग्य हैं।\n\nयह फ़ंक्शन आवेदकों को उनके टेस्ट स्कोर के आधार पर अवरोही क्रम में क्रमबद्ध करता है। यदि कई आवेदकों के स्कोर समान हैं, तो उन्हें उनके पंजीकरण संख्या के आधार पर आरोही क्रम में क्रमबद्ध किया जाता है। साक्षात्कार स्कोर कटऑफ नियोजित भर्ती संख्या के 150% के आधार पर गणना की जाती है, जिसे नीचे की ओर पूर्णांकित किया जाता है। सभी आवेदक जिनके स्कोर कटऑफ के बराबर या उससे अधिक हैं, उन्हें साक्षात्कार के लिए योग्य माना जाता है।\n\nआर्ग्स:\n- n (int): कुल आवेदकों की संख्या।\n- m (int): भर्ती किए जाने वाले स्वयंसेवकों की नियोजित संख्या।\n- applicants (List[Tuple[int, int]]): ट्यूपल की एक सूची जहाँ प्रत्येक ट्यूपल में एक आवेदक की पंजीकरण संख्या और टेस्ट स्कोर होता है।\n\nरिटर्न्स:\n- Tuple[int, List[Tuple[int, int]]]: एक ट्यूपल जिसमें साक्षात्कार स्कोर कटऑफ और ट्यूपल की एक सूची शामिल होती है, जिनमें से प्रत्येक में योग्य आवेदकों की पंजीकरण संख्या और टेस्ट स्कोर शामिल होते हैं।\n\nउदाहरण:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nइसका अर्थ है कि साक्षात्कार स्कोर कटऑफ 88 है, और 5 आवेदक साक्षात्कार के लिए योग्य हैं, जिनके स्कोर 95, 95, 90, 88, और 88 हैं, और उनके संबंधित पंजीकरण संख्या उनके स्कोर के साथ सूचीबद्ध हैं।",
      "hu": "Kiválasztja és meghatározza az interjú pontszám küszöböt és azon jelentkezők listáját, akik megfelelnek az interjú folyamatára.\n\nA függvény a jelentkezőket a tesztpontszámaik alapján csökkenő sorrendbe rendezi. Ha több jelentkezőnek azonos a pontszáma, akkor a regisztrációs számuk alapján növekvő sorrendbe kerülnek. Az interjú pontszám küszöb a tervezett toborzandó önkéntesek számának 150%-a alapján kerül kiszámításra, lefelé kerekítve. Minden jelentkező, akinek a pontszáma eléri vagy meghaladja a küszöböt, alkalmasnak tekintendő az interjúra.\n\nArgs:\n- n (int): A jelentkezők teljes száma.\n- m (int): A tervezett toborzandó önkéntesek száma.\n- applicants (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy tuple, amely tartalmazza a jelentkező regisztrációs számát és tesztpontszámát.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: Egy tuple, amely tartalmazza az interjú pontszám küszöböt és egy listát a tuple-ökkel, amelyek mindegyike tartalmazza a regisztrációs számot és a tesztpontszámot az alkalmas jelentkezőknél.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nEz azt jelenti, hogy az interjú pontszám küszöb 88, és 5 jelentkező van, aki megfelel az interjúra, pontszámaik 95, 95, 90, 88 és 88, és a megfelelő regisztrációs számuk a pontszámaik mellett van feltüntetve."
    },
    "docstring_bertscore": {
      "sq": "0.9829287119019565",
      "hy": "0.9491259922878204",
      "bn": "0.9530217299510576",
      "bg": "0.969870552022342",
      "zh": "0.9423002578739375",
      "fr": "0.9669341990995032",
      "de": "0.9796544887009775",
      "ha": "0.9436422047282091",
      "hi": "0.9594869502233622",
      "hu": "0.9676365561268425"
    }
  },
  {
    "task_id": "Python/22",
    "prompt": {
      "en": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "sq": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Dekodon një mesazh të koduar duke përdorur një kod të nxjerrë nga një palë e njohur e koduar-origjinale.\n    \n    Funksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\n    hartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\n    ose nëse jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Failed\".\n    \n    Argumentet:\n    encoded (str): Një varg që përfaqëson informacionin e koduar.\n    original (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\n    message (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n    \n    Kthen:\n    str: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Failed\" nëse dekodimi nuk është i mundur.\n    \n    Shembuj:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "hy": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Վերծանում է կոդավորված հաղորդագրությունը, օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված ծածկագիրը:\n    \n    Ֆունկցիան կառուցում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\n    համապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե համապատասխանության կառուցման ընթացքում հակասություն է հայտնաբերվում,\n    կամ բոլոր տառերը ներկայացված չեն համապատասխանության մեջ, ֆունկցիան վերադարձնում է \"Failed\":\n    \n    Արգումենտներ:\n    encoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\n    original (str): Տող, որը ներկայացնում է բնօրինակ տեղեկատվությունը, որը համապատասխանում է կոդավորված տողին:\n    message (str): Տող, որը ներկայացնում է կոդավորված հաղորդագրությունը, որը պետք է վերծանել:\n    \n    Վերադարձնում է:\n    str: Վերծանված հաղորդագրությունը, եթե հաջող է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n    \n    Օրինակներ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "bn": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    একটি সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে যা একটি পরিচিত এনকোডেড-অরিজিনাল জোড়া থেকে উদ্ভূত হয়।\n\n    ফাংশনটি এনকোডেড অক্ষরগুলি থেকে তাদের মূল অক্ষরগুলিতে একটি ম্যাপিং তৈরি করে এবং এই\n    ম্যাপিংটি ব্যবহার করে একটি প্রদত্ত এনক্রিপ্টেড বার্তাকে ডিকোড করে। যদি ম্যাপিং নির্মাণের সময় কোনও বিরোধ পাওয়া যায়,\n    অথবা ম্যাপিংয়ে সমস্ত অক্ষর উপস্থাপিত না হয়, তাহলে ফাংশনটি \"Failed\" রিটার্ন করে।\n\n    Args:\n    encoded (str): এনকোডেড তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    original (str): এনকোডেড স্ট্রিংয়ের সাথে সম্পর্কিত মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\n    message (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n\n    Returns:\n    str: সফল হলে ডিকোড করা বার্তা, অথবা ডিকোড করা সম্ভব না হলে \"Failed\"।\n\n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "bg": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Декодира криптирано съобщение, използвайки шифър, получен от известна двойка кодирано-оригинално.\n\n    Функцията изгражда съответствие от кодирани букви към техните оригинални букви и използва това\n    съответствие за декодиране на дадено криптирано съобщение. Ако се намери противоречие по време на изграждането\n    на съответствието или не всички букви са представени в съответствието, функцията връща \"Failed\".\n\n    Аргументи:\n    encoded (str): Низ, представляващ кодираната информация.\n    original (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\n    message (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n\n    Връща:\n    str: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n\n    Примери:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "zh": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    使用从已知的编码-原始对派生的密码解码加密消息。\n    \n    该函数构建一个从编码字母到其原始字母的映射，并使用此映射解码给定的加密消息。\n    如果在构建映射过程中发现矛盾，或者映射中未表示所有字母，函数返回“Failed”。\n    \n    参数:\n    encoded (str): 表示编码信息的字符串。\n    original (str): 表示与编码字符串对应的原始信息的字符串。\n    message (str): 表示要解码的加密消息的字符串。\n    \n    返回:\n    str: 如果解码成功则返回解码后的消息，如果解码不可能则返回“Failed”。\n    \n    示例:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "fr": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Décode un message chiffré en utilisant un chiffrement dérivé d'une paire codée-originale connue.\n    \n    La fonction construit une correspondance des lettres codées vers leurs lettres originales et utilise cette\n    correspondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction de la correspondance,\n    ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction renvoie \"Failed\".\n    \n    Args:\n    encoded (str): Une chaîne représentant l'information codée.\n    original (str): Une chaîne représentant l'information originale correspondant à la chaîne codée.\n    message (str): Une chaîne représentant le message chiffré à décoder.\n    \n    Returns:\n    str: Le message décodé si réussi, ou \"Failed\" si le décodage n'est pas possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "de": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Entschlüsselt eine verschlüsselte Nachricht mit Hilfe eines Chiffres, der aus einem bekannten Paar von kodierten und originalen Zeichenfolgen abgeleitet wird.\n    \n    Die Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren originalen Buchstaben und verwendet diese\n    Zuordnung, um eine gegebene verschlüsselte Nachricht zu entschlüsseln. Wenn während der Erstellung der Zuordnung ein Widerspruch gefunden wird oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n    \n    Argumente:\n    encoded (str): Ein String, der die kodierte Information darstellt.\n    original (str): Ein String, der die originale Information darstellt, die der kodierten Zeichenfolge entspricht.\n    message (str): Ein String, der die verschlüsselte Nachricht darstellt, die entschlüsselt werden soll.\n    \n    Rückgabewert:\n    str: Die entschlüsselte Nachricht, wenn erfolgreich, oder \"Failed\", wenn die Entschlüsselung nicht möglich ist.\n    \n    Beispiele:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "ha": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Yana fassara saƙon da aka ɓoye ta amfani da wata hanyar ɓoye wa da aka samo daga sanannen haɗin encoded-original.\n\n    Aikin yana gina taswira daga haruffan da aka ɓoye zuwa ga haruffan asali kuma yana amfani da wannan\n    taswira don fassara saƙon da aka ɓoye. Idan aka samu sabani yayin gina taswira,\n    ko kuma ba dukkan haruffa suna cikin taswirar ba, aikin yana dawowa da \"Failed\".\n\n    Args:\n    encoded (str): Wani kirtani da ke wakiltar bayanin da aka ɓoye.\n    original (str): Wani kirtani da ke wakiltar bayanin asali da ya dace da kirtanin da aka ɓoye.\n    message (str): Wani kirtani da ke wakiltar saƙon da aka ɓoye da za a fassara.\n\n    Returns:\n    str: Saƙon da aka fassara idan an yi nasara, ko \"Failed\" idan ba zai yiwu a fassara ba.\n\n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "hi": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    एक ज्ञात एन्कोडेड-ओरिजिनल जोड़ी से व्युत्पन्न सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n\n    यह फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस\n    मैपिंग का उपयोग एक दिए गए एन्क्रिप्टेड संदेश को डिकोड करने के लिए करता है। यदि मैपिंग\n    निर्माण के दौरान कोई विरोधाभास पाया जाता है, या मैपिंग में सभी अक्षर प्रतिनिधित्व नहीं करते हैं,\n    तो फ़ंक्शन \"Failed\" लौटाता है।\n\n    तर्क:\n    encoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    original (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n    message (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n\n    लौटाता है:\n    str: डिकोड किया गया संदेश यदि सफल होता है, या \"Failed\" यदि डिकोडिंग संभव नहीं है।\n\n    उदाहरण:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "hu": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származtatott rejtjel segítségével.\n    \n    A függvény egy leképezést épít a kódolt betűk és az eredeti betűk között, és ezt a leképezést\n    használja egy adott titkosított üzenet dekódolására. Ha ellentmondás található a leképezés\n    építése során, vagy nem minden betű van képviselve a leképezésben, a függvény \"Failed\" értéket ad vissza.\n    \n    Args:\n    encoded (str): Egy string, amely a kódolt információt képviseli.\n    original (str): Egy string, amely az eredeti információt képviseli, amely megfelel a kódolt stringnek.\n    message (str): Egy string, amely a dekódolandó titkosított üzenetet képviseli.\n    \n    Returns:\n    str: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n    \n    Példák:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9783071788264178",
      "hy": "0.9634190372463288",
      "bn": "0.976076162386634",
      "bg": "0.9803324141914496",
      "zh": "0.9864347367576033",
      "fr": "0.9888133355704961",
      "de": "0.9709048204163906",
      "ha": "0.9623283578240662",
      "hi": "0.9785838709471993",
      "hu": "0.9733217548928231"
    },
    "canonical_solution": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message",
    "instruction": {
      "en": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nՏվեք Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত স্বাভাবিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9352562286712972",
      "hy": "0.9269590403947078",
      "bn": "0.8825850132715138",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.9530483464221162",
      "hi": "0.91110952777041",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_decode():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ntest_decode()",
    "entry_point": "decode",
    "signature": "def decode(encoded: str, original: str, message: str) -> str:",
    "docstring": {
      "en": "Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n\nThe function builds a mapping from encoded letters to their original letters and uses this\nmapping to decode a given encrypted message. If a contradiction is found during mapping\nconstruction, or not all letters are represented in the mapping, the function returns \"Failed\".\n\nArgs:\nencoded (str): A string representing the encoded information.\noriginal (str): A string representing the original information corresponding to the encoded string.\nmessage (str): A string representing the encrypted message to be decoded.\n\nReturns:\nstr: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "sq": "Dekodon një mesazh të koduar duke përdorur një çelës të nxjerrë nga një çift i njohur i koduar-original.\n\nFunksioni ndërton një hartë nga shkronjat e koduara te shkronjat e tyre origjinale dhe përdor këtë\nhartë për të dekoduar një mesazh të dhënë të koduar. Nëse gjendet një kontradiktë gjatë ndërtimit të hartës,\nose nëse jo të gjitha shkronjat janë të përfaqësuara në hartë, funksioni kthen \"Dështoi\".\n\nArgumentet:\nencoded (str): Një varg që përfaqëson informacionin e koduar.\noriginal (str): Një varg që përfaqëson informacionin origjinal që korrespondon me vargun e koduar.\nmessage (str): Një varg që përfaqëson mesazhin e koduar që do të dekodohet.\n\nKthen:\nstr: Mesazhi i dekoduar nëse është i suksesshëm, ose \"Dështoi\" nëse dekodimi nuk është i mundur.\n\nShembuj:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "hy": "Վերծանում է կոդավորված հաղորդագրությունը՝ օգտագործելով հայտնի կոդավորված-բնօրինակ զույգից ստացված գաղտնագիրը:\n\nՖունկցիան ստեղծում է համապատասխանություն կոդավորված տառերից դեպի իրենց բնօրինակ տառերը և օգտագործում է այս\nհամապատասխանությունը՝ տրված կոդավորված հաղորդագրությունը վերծանելու համար: Եթե հակասություն է հայտնաբերվում համապատասխանության\nստեղծման ընթացքում, կամ բոլոր տառերը չեն ներկայացված համապատասխանության մեջ, ֆունկցիան վերադարձնում է \"Failed\":\n\nԱրձագանքներ:\nencoded (str): Տող, որը ներկայացնում է կոդավորված տեղեկատվությունը:\noriginal (str): Տող, որը ներկայացնում է կոդավորված տողին համապատասխանող բնօրինակ տեղեկատվությունը:\nmessage (str): Տող, որը ներկայացնում է վերծանման ենթակա կոդավորված հաղորդագրությունը:\n\nՎերադարձնում է:\nstr: Վերծանված հաղորդագրությունը, եթե հաջող է, կամ \"Failed\", եթե վերծանումը հնարավոր չէ:\n\nՕրինակներ:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "bn": "একটি পরিচিত এনকোডেড-মূল জোড়া থেকে প্রাপ্ত সাইফার ব্যবহার করে একটি এনক্রিপ্টেড বার্তা ডিকোড করে।\n\nফাংশনটি এনকোডেড অক্ষর থেকে তাদের মূল অক্ষরে একটি ম্যাপিং তৈরি করে এবং এই ম্যাপিং ব্যবহার করে প্রদত্ত এনক্রিপ্টেড বার্তাটি ডিকোড করে। যদি ম্যাপিং নির্মাণের সময় কোনো বিরোধ পাওয়া যায়, বা ম্যাপিংয়ে সমস্ত অক্ষর উপস্থাপিত না হয়, তাহলে ফাংশনটি \"Failed\" রিটার্ন করে।\n\nArgs:\nencoded (str): এনকোডেড তথ্য উপস্থাপনকারী একটি স্ট্রিং।\noriginal (str): এনকোডেড স্ট্রিংয়ের সাথে সম্পর্কিত মূল তথ্য উপস্থাপনকারী একটি স্ট্রিং।\nmessage (str): ডিকোড করার জন্য এনক্রিপ্টেড বার্তা উপস্থাপনকারী একটি স্ট্রিং।\n\nReturns:\nstr: সফল হলে ডিকোড করা বার্তা, অথবা ডিকোড করা সম্ভব না হলে \"Failed\"।\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "bg": "Декодира криптирано съобщение, използвайки шифър, получен от известна двойка кодирано-оригинално.\n\nФункцията изгражда съответствие от кодирани букви към техните оригинални букви и използва това\nсъответствие, за да декодира дадено криптирано съобщение. Ако се намери противоречие по време на изграждането на съответствието или не всички букви са представени в съответствието, функцията връща \"Failed\".\n\nАргументи:\nencoded (str): Низ, представляващ кодираната информация.\noriginal (str): Низ, представляващ оригиналната информация, съответстваща на кодирания низ.\nmessage (str): Низ, представляващ криптираното съобщение, което трябва да бъде декодирано.\n\nВръща:\nstr: Декодираното съобщение, ако е успешно, или \"Failed\", ако декодирането не е възможно.\n\nПримери:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "zh": "解码使用已知编码-原始对派生的密码加密的消息。\n\n该函数从编码字母到其原始字母构建映射，并使用此映射解码给定的加密消息。如果在构建映射过程中发现矛盾，或者映射中并未代表所有字母，则函数返回“Failed”。\n\n参数：\nencoded (str): 表示编码信息的字符串。\noriginal (str): 表示与编码字符串对应的原始信息的字符串。\nmessage (str): 表示要解码的加密消息的字符串。\n\n返回：\nstr: 如果成功则返回解码后的消息，如果解码不可能则返回“Failed”。\n\n示例：\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "fr": "Décode un message chiffré en utilisant un chiffrement dérivé d'une paire encodée-originale connue.\n\nLa fonction construit une correspondance des lettres encodées vers leurs lettres originales et utilise cette\ncorrespondance pour décoder un message chiffré donné. Si une contradiction est trouvée lors de la construction de la correspondance, ou si toutes les lettres ne sont pas représentées dans la correspondance, la fonction retourne \"Échec\".\n\nArgs:\nencoded (str): Une chaîne représentant l'information encodée.\noriginal (str): Une chaîne représentant l'information originale correspondant à la chaîne encodée.\nmessage (str): Une chaîne représentant le message chiffré à décoder.\n\nReturns:\nstr: Le message décodé si réussi, ou \"Échec\" si le décodage n'est pas possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "de": "Decodiert eine verschlüsselte Nachricht mithilfe eines Chiffres, der aus einem bekannten kodierten-originalen Paar abgeleitet wird.\n\nDie Funktion erstellt eine Zuordnung von kodierten Buchstaben zu ihren ursprünglichen Buchstaben und verwendet diese Zuordnung, um eine gegebene verschlüsselte Nachricht zu dekodieren. Wenn während der Erstellung der Zuordnung ein Widerspruch gefunden wird oder nicht alle Buchstaben in der Zuordnung vertreten sind, gibt die Funktion \"Failed\" zurück.\n\nArgs:\nencoded (str): Ein String, der die kodierte Information darstellt.\noriginal (str): Ein String, der die ursprüngliche Information darstellt, die dem kodierten String entspricht.\nmessage (str): Ein String, der die zu dekodierende verschlüsselte Nachricht darstellt.\n\nReturns:\nstr: Die dekodierte Nachricht, falls erfolgreich, oder \"Failed\", wenn die Dekodierung nicht möglich ist.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "ha": "Yana fassara saƙon da aka ɓoye ta amfani da wata hanyar ɓoye wa da aka samo daga sanannen haɗin encoded-original.\n\nAikin yana gina taswira daga haruffan da aka koda zuwa ga asalin haruffan kuma yana amfani da wannan taswira don warware saƙon da aka koda. Idan an sami sabani yayin gina taswira, ko kuma ba dukkan haruffa ba a wakilta a cikin taswira, aikin yana dawowa da \"Failed\".\n\nArgs:\nencoded (str): Wani kirtani da ke wakiltar bayanan da aka koda.\noriginal (str): Wani kirtani da ke wakiltar bayanan asali da suka dace da kirtanin da aka koda.\nmessage (str): Wani kirtani da ke wakiltar saƙon da aka koda da za a warware.\n\nReturns:\nstr: Saƙon da aka warware idan an yi nasara, ko \"Failed\" idan ba zai yiwu a warware ba.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "hi": "एक ज्ञात एन्कोडेड-ओरिजिनल जोड़ी से व्युत्पन्न सिफर का उपयोग करके एक एन्क्रिप्टेड संदेश को डिकोड करता है।\n\nयह फ़ंक्शन एन्कोडेड अक्षरों से उनके मूल अक्षरों तक एक मैपिंग बनाता है और इस मैपिंग का उपयोग करके दिए गए एन्क्रिप्टेड संदेश को डिकोड करता है। यदि मैपिंग निर्माण के दौरान कोई विरोधाभास पाया जाता है, या मैपिंग में सभी अक्षर प्रतिनिधित्व नहीं करते हैं, तो फ़ंक्शन \"Failed\" लौटाता है।\n\nआर्ग्स:\nencoded (str): एन्कोडेड जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\noriginal (str): एन्कोडेड स्ट्रिंग के अनुरूप मूल जानकारी का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\nmessage (str): डिकोड किए जाने वाले एन्क्रिप्टेड संदेश का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n\nरिटर्न्स:\nstr: यदि सफल हो तो डिकोड किया गया संदेश, या यदि डिकोडिंग संभव नहीं है तो \"Failed\"।\n\nउदाहरण:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "hu": "Dekódol egy titkosított üzenetet egy ismert kódolt-eredeti párból származó rejtjel segítségével.\n\nA függvény egy leképezést épít a kódolt betűk és az eredeti betűk között, és ezt a leképezést használja egy adott titkosított üzenet dekódolására. Ha ellentmondás található a leképezés készítése során, vagy nem minden betű van képviselve a leképezésben, a függvény \"Failed\" értéket ad vissza.\n\nArgs:\nencoded (str): Egy karakterlánc, amely a kódolt információt képviseli.\noriginal (str): Egy karakterlánc, amely az eredeti információt képviseli, amely megfelel a kódolt karakterláncnak.\nmessage (str): Egy karakterlánc, amely a dekódolandó titkosított üzenetet képviseli.\n\nReturns:\nstr: A dekódolt üzenet, ha sikeres, vagy \"Failed\", ha a dekódolás nem lehetséges.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'"
    },
    "docstring_bertscore": {
      "sq": "0.9661219994714515",
      "hy": "0.978518918812601",
      "bn": "0.9613928087293919",
      "bg": "0.9790512482337744",
      "zh": "0.9762390392990825",
      "fr": "0.9864861820262913",
      "de": "0.9912000782290113",
      "ha": "0.9681035361526555",
      "hi": "0.9849034951502054",
      "hu": "0.9893859869590197"
    }
  },
  {
    "task_id": "Python/23",
    "prompt": {
      "en": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "sq": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Gjej faktorin më të madh prim të një numri të dhënë pozitiv.\n    \n    Numri supozohet të jetë prodhimi i saktësisht dy numrave të ndryshëm prim. \n    Funksioni iteron përmes faktorëve të mundshëm duke filluar nga primi më i vogël (2) \n    dhe kontrollon nëse ata janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen \n    pjesëtimin e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden \n    faktorë deri në rrënjën katrore të 'n', atëherë 'n' vetë është një numër prim dhe kthehet \n    si faktori më i madh prim.\n    \n    Args:\n    n (int): Numri pozitiv për të faktorizuar, i cili është prodhimi i dy numrave të ndryshëm prim.\n    \n    Returns:\n    int: Më i madhi nga dy faktorët prim të 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "hy": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ բաժանարարը։\n    \n    Ենթադրվում է, որ ամբողջ թիվը երկու տարբեր պարզ թվերի արտադրյալն է։ \n    Ֆունկցիան սկսում է հնարավոր բաժանարարների ստուգումը ամենափոքր պարզ թվից (2) \n    և ստուգում է, արդյոք դրանք 'n'-ի բաժանարար են։ Եթե բաժանարար է գտնվում, \n    ֆունկցիան վերադարձնում է 'n'-ի բաժանումը այդ բաժանարարով, որը ամենամեծ պարզ \n    բաժանարարն է։ Եթե մինչև 'n'-ի քառակուսի արմատը ոչ մի բաժանարար չի գտնվում, \n    ապա 'n'-ը ինքնին պարզ թիվ է և վերադարձվում է որպես ամենամեծ պարզ բաժանարար։\n    \n    Արգումենտներ:\n    n (int): Դրական ամբողջ թիվը, որը պետք է բաժանել, որը երկու տարբեր պարզ թվերի արտադրյալն է։\n    \n    Վերադարձնում է:\n    int: 'n'-ի երկու պարզ բաժանարարներից ամենամեծը։\n    \n    Օրինակներ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "bn": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    প্রদত্ত একটি ধনাত্মক পূর্ণসংখ্যার বৃহত্তম মৌলিক গুণক খুঁজে বের করুন।\n    \n    পূর্ণসংখ্যাটি ঠিক দুটি ভিন্ন মৌলিক সংখ্যার গুণফল বলে ধারণা করা হয়।\n    ফাংশনটি সম্ভাব্য গুণকগুলির মধ্য দিয়ে ক্ষুদ্রতম মৌলিক সংখ্যা (2) থেকে শুরু করে \n    এবং পরীক্ষা করে যে তারা 'n'-এর গুণক কিনা। যদি একটি গুণক পাওয়া যায়, \n    ফাংশনটি এই গুণক দ্বারা 'n'-এর ভাগফল প্রদান করে, যা বৃহত্তম মৌলিক গুণক। \n    যদি 'n'-এর বর্গমূল পর্যন্ত কোনো গুণক পাওয়া না যায়, তাহলে 'n' নিজেই একটি মৌলিক সংখ্যা \n    এবং বৃহত্তম মৌলিক গুণক হিসেবে ফেরত দেওয়া হয়।\n    \n    Args:\n    n (int): ধনাত্মক পূর্ণসংখ্যা যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল।\n    \n    Returns:\n    int: 'n'-এর দুটি মৌলিক গুণকের মধ্যে বৃহত্তম।\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "bg": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Намерете най-големия прост делител на дадено положително цяло число.\n    \n    Предполага се, че цялото число е произведение на точно две различни прости числа. \n    Функцията обхожда потенциалните делители, започвайки от най-малкото просто число (2), \n    и проверява дали са делители на 'n'. Ако се намери делител, функцията връща \n    резултата от делението на 'n' с този делител, което е по-големият прост делител. \n    Ако не се намерят делители до квадратния корен на 'n', тогава 'n' самото е просто число \n    и се връща като най-големия прост делител.\n    \n    Аргументи:\n    n (int): Положителното цяло число за факторизиране, което е произведение на две различни прости числа.\n    \n    Връща:\n    int: По-големият от двата прости делителя на 'n'.\n    \n    Примери:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "zh": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    找到给定正整数的最大质因数。\n    \n    假设该整数是恰好由两个不同质数的乘积构成的。\n    该函数从最小的质数（2）开始遍历潜在因数，并检查它们是否是'n'的因数。\n    如果找到一个因数，函数返回'n'除以这个因数的结果，即较大的质因数。\n    如果在'n'的平方根范围内没有找到因数，那么'n'本身就是一个质数，并作为最大的质因数返回。\n    \n    参数:\n    n (int): 要分解的正整数，是两个不同质数的乘积。\n    \n    返回:\n    int: 'n'的两个质因数中较大的一个。\n    \n    示例:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "fr": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Trouver le plus grand facteur premier d'un entier positif donné.\n    \n    L'entier est supposé être le produit de exactement deux nombres premiers distincts. \n    La fonction parcourt les facteurs potentiels en commençant par le plus petit nombre premier (2) \n    et vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne \n    la division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur \n    n'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est \n    retourné comme le plus grand facteur premier.\n    \n    Args:\n    n (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n    \n    Returns:\n    int: Le plus grand des deux facteurs premiers de 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "de": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Finde den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n    \n    Es wird angenommen, dass die ganze Zahl das Produkt von genau zwei verschiedenen Primzahlen ist. \n    Die Funktion iteriert durch potenzielle Faktoren, beginnend mit dem kleinsten Primfaktor (2), \n    und überprüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion \n    die Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur \n    Quadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und wird \n    als größter Primfaktor zurückgegeben.\n    \n    Args:\n    n (int): Die zu faktorisierende positive ganze Zahl, die das Produkt von zwei verschiedenen Primzahlen ist.\n    \n    Returns:\n    int: Der größere der beiden Primfaktoren von 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "ha": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Nemo mafi girman abin da ya fi girma na lamba mai kyau da aka bayar.\n    \n    Ana tsammanin lambobin suna daidai da samfurin lambobi masu firam guda biyu daban-daban. \n    Aiki yana yawo ta cikin abubuwan da za su iya zama masu yawa farawa daga mafi ƙarancin firam (2) \n    kuma yana duba idan suna da alaka da 'n'. Idan an sami abin da ya dace, aikin yana dawo da \n    rabon 'n' da wannan abin, wanda shine mafi girman abin da ya fi girma. Idan ba a sami \n    abubuwan da suka dace ba har zuwa tushen murabba'in 'n', to 'n' kanta lamba ce mai firam \n    kuma ana mayar da ita a matsayin mafi girman abin da ya fi girma.\n    \n    Args:\n    n (int): Lamba mai kyau don yin factorize, wanda shine samfurin lambobi masu firam guda biyu daban-daban.\n    \n    Returns:\n    int: Mafi girman daga cikin abubuwan da suka fi girma guda biyu na 'n'.\n    \n    Misalai:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "hi": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n    \n    पूर्णांक को ठीक दो भिन्न अभाज्य संख्याओं के गुणनफल के रूप में माना जाता है। \n    यह फ़ंक्शन संभावित गुणनखंडों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू होकर \n    जाँच करता है कि क्या वे 'n' के गुणनखंड हैं। यदि कोई गुणनखंड पाया जाता है, तो \n    फ़ंक्शन 'n' को इस गुणनखंड से विभाजित कर लौटाता है, जो बड़ा अभाज्य गुणनखंड होता है। \n    यदि 'n' के वर्गमूल तक कोई गुणनखंड नहीं पाया जाता है, तो 'n' स्वयं एक अभाज्य संख्या \n    है और इसे सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n    \n    तर्क:\n    n (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n    \n    लौटाता है:\n    int: 'n' के दो अभाज्य गुणनखंडों में से बड़ा।\n    \n    उदाहरण:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "hu": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Keresse meg egy adott pozitív egész szám legnagyobb prímtényezőjét.\n    \n    Az egész szám feltételezhetően pontosan két különböző prímszám szorzata. \n    A függvény a legkisebb prímtől (2) kezdve iterál a lehetséges tényezőkön, \n    és ellenőrzi, hogy ezek tényezői-e 'n'-nek. Ha talál tényezőt, a függvény \n    visszaadja 'n' osztását ezzel a tényezővel, amely a nagyobb prímtényező. \n    Ha nem talál tényezőket 'n' négyzetgyökéig, akkor 'n' maga egy prímszám, \n    és visszatér a legnagyobb prímtényezőként.\n    \n    Args:\n    n (int): A pozitív egész szám, amelyet faktorizálni kell, és amely két különböző prím szorzata.\n    \n    Returns:\n    int: 'n' két prímtényezője közül a nagyobb.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   "
    },
    "prompt_bertscore": {
      "sq": "0.981917683262489",
      "hy": "0.9097761220225228",
      "bn": "0.9574940916104391",
      "bg": "0.9418819422914779",
      "zh": "0.9468876265239381",
      "fr": "0.9878656700225786",
      "de": "0.9745598180578136",
      "ha": "0.9589641550604783",
      "hi": "0.9484442928201086",
      "hu": "0.9754739150713362"
    },
    "canonical_solution": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor",
    "instruction": {
      "en": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nՏվեք Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nДайте кратко описание на Python кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nBa da taƙaitaccen bayanin yaren ɗan adam (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9269590403947078",
      "bn": "0.8739292971571565",
      "bg": "0.8415791615195284",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.907010591227374",
      "hi": "0.8964889413135749",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_largest_prime_factor():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_largest_prime_factor()",
    "entry_point": "largest_prime_factor",
    "signature": "def largest_prime_factor(n: int) -> int:",
    "docstring": {
      "en": "Find the largest prime factor of a given positive integer.\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\nThe function iterates through potential factors starting from the smallest prime (2)\nand checks if they are a factor of 'n'. If a factor is found, the function returns\nthe division of 'n' by this factor, which is the larger prime factor. If no factors\nare found up to the square root of 'n', then 'n' itself is a prime number and is\nreturned as the largest prime factor.\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "sq": "Gjeni faktorin më të madh prim të një numri të plotë pozitiv të dhënë.\n\nNumri i plotë supozohet të jetë produkt i saktësisht dy numrave të ndryshëm prim.\nFunksioni iteron nëpër faktorët e mundshëm duke filluar nga primi më i vogël (2)\ndhe kontrollon nëse janë faktorë të 'n'. Nëse gjendet një faktor, funksioni kthen\nndarjen e 'n' me këtë faktor, i cili është faktori më i madh prim. Nëse nuk gjenden faktorë\nderi në rrënjën katrore të 'n', atëherë vetë 'n' është një numër prim dhe kthehet si\nfaktori më i madh prim.\n\nArgumentet:\nn (int): Numri i plotë pozitiv për të faktorizuar, i cili është produkt i dy primeve të ndryshëm.\n\nKthen:\nint: Më i madhi nga dy faktorët prim të 'n'.\n\nShembuj:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "hy": "Գտնել տրված դրական ամբողջ թվի ամենամեծ պարզ բաժանարարը։\n\nԸնդունվում է, որ ամբողջ թիվը երկու տարբեր պարզ թվերի արտադրյալն է։\nՖունկցիան սկսում է հնարավոր բաժանարարների ստուգումը ամենափոքր պարզ թվից (2)\nև ստուգում է՝ արդյոք դրանք 'n'-ի բաժանարար են։ Եթե բաժանարար է գտնվում, ֆունկցիան վերադարձնում է\n'n'-ի բաժանումը այդ բաժանարարով, որը ամենամեծ պարզ բաժանարարն է։ Եթե բաժանարարներ չեն գտնվում մինչև 'n'-ի քառակուսի արմատը, ապա 'n'-ն ինքնին պարզ թիվ է և վերադարձվում է որպես ամենամեծ պարզ բաժանարար։\n\nԱրգումենտներ:\nn (int): Դրական ամբողջ թիվը, որը պետք է բաժանել, և որը երկու տարբեր պարզ թվերի արտադրյալն է։\n\nՎերադարձնում է:\nint: 'n'-ի երկու պարզ բաժանարարներից մեծը։\n\nՕրինակներ:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "bn": "একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যার বৃহত্তম মৌলিক গুণক খুঁজুন।\n\nপূর্ণসংখ্যাটি দুটি পৃথক মৌলিক সংখ্যার গুণফল বলে ধরা হয়। ফাংশনটি সম্ভাব্য গুণকগুলির মধ্য দিয়ে ক্ষুদ্রতম মৌলিক সংখ্যা (2) থেকে শুরু করে পুনরাবৃত্তি করে এবং পরীক্ষা করে যে তারা 'n'-এর গুণক কিনা। যদি একটি গুণক পাওয়া যায়, ফাংশনটি 'n' কে এই গুণক দ্বারা ভাগ করে, যা বৃহত্তম মৌলিক গুণক। যদি 'n'-এর বর্গমূল পর্যন্ত কোনো গুণক পাওয়া না যায়, তাহলে 'n' নিজেই একটি মৌলিক সংখ্যা এবং বৃহত্তম মৌলিক গুণক হিসেবে ফেরত দেওয়া হয়।\n\nArgs:\nn (int): যে ধনাত্মক পূর্ণসংখ্যাটিকে গুণফল করতে হবে, যা দুটি পৃথক মৌলিক সংখ্যার গুণফল।\n\nReturns:\nint: 'n'-এর দুটি মৌলিক গুণকের মধ্যে বৃহত্তম।\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "bg": "Намерете най-големия прост делител на дадено положително цяло число.\n\nПредполага се, че цялото число е произведение на точно два различни прости числа.\nФункцията обхожда потенциалните делители, започвайки от най-малкото просто число (2),\nи проверява дали те са делител на 'n'. Ако се намери делител, функцията връща\nрезултата от делението на 'n' с този делител, което е по-големият прост делител. Ако не се намерят делители до квадратния корен на 'n', тогава самото 'n' е просто число и се връща като най-големият прост делител.\n\nАргументи:\nn (int): Положителното цяло число за факторизиране, което е произведение на два различни прости числа.\n\nВръща:\nint: По-големият от двата прости делителя на 'n'.\n\nПримери:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "zh": "找到给定正整数的最大质因数。\n\n该整数被假定为恰好是两个不同质数的乘积。函数从最小的质数（2）开始迭代潜在因数，并检查它们是否为“n”的因数。如果找到一个因数，函数返回“n”除以该因数的结果，即较大的质因数。如果在“n”的平方根范围内未找到因数，则“n”本身是一个质数，并作为最大质因数返回。\n\n参数：\nn (int): 要分解的正整数，它是两个不同质数的乘积。\n\n返回：\nint: “n”的两个质因数中较大的一个。\n\n示例：\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "fr": "Trouver le plus grand facteur premier d'un entier positif donné.\n\nL'entier est supposé être le produit de deux nombres premiers distincts exactement.\nLa fonction parcourt les facteurs potentiels en commençant par le plus petit nombre premier (2)\net vérifie s'ils sont un facteur de 'n'. Si un facteur est trouvé, la fonction retourne\nla division de 'n' par ce facteur, qui est le plus grand facteur premier. Si aucun facteur\nn'est trouvé jusqu'à la racine carrée de 'n', alors 'n' lui-même est un nombre premier et est\nretourné comme le plus grand facteur premier.\n\nArgs:\nn (int): L'entier positif à factoriser, qui est le produit de deux nombres premiers distincts.\n\nReturns:\nint: Le plus grand des deux facteurs premiers de 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "de": "Finde den größten Primfaktor einer gegebenen positiven ganzen Zahl.\n\nDie ganze Zahl wird angenommen als das Produkt von genau zwei verschiedenen Primzahlen.\nDie Funktion iteriert durch potenzielle Faktoren, beginnend mit dem kleinsten Primfaktor (2),\nund prüft, ob sie ein Faktor von 'n' sind. Wenn ein Faktor gefunden wird, gibt die Funktion\ndie Division von 'n' durch diesen Faktor zurück, was der größere Primfaktor ist. Wenn bis zur\nQuadratwurzel von 'n' keine Faktoren gefunden werden, dann ist 'n' selbst eine Primzahl und\nwird als der größte Primfaktor zurückgegeben.\n\nArgumente:\nn (int): Die zu faktorisierende positive ganze Zahl, die das Produkt von zwei verschiedenen Primzahlen ist.\n\nRückgabewert:\nint: Der größere der beiden Primfaktoren von 'n'.\n\nBeispiele:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "ha": "Nemo mafi girman abin da ya fi girma na lamba mai kyau da aka bayar.\n\nAn yi tsammanin cewa lambar cikakke ita ce samfurin lambobi masu lamba guda biyu daban-daban.\nAikin yana zagayawa ta hanyar abubuwan da za su iya zama masu rarrabewa farawa daga mafi ƙarancin lamba mai lamba (2)\nkuma yana duba idan suna da alaƙa da 'n'. Idan aka sami wani abu mai rarrabewa, aikin yana dawowa\nrarraba 'n' da wannan abu, wanda shine mafi girman lamba mai lamba. Idan ba a sami abubuwan da za su iya zama masu rarrabewa ba har zuwa tushen murabba'in 'n', to 'n' kanta lamba ce mai lamba kuma ana dawowa da ita a matsayin mafi girman lamba mai lamba.\n\nArgs:\nn (int): Lambar cikakke mai kyau don rarrabewa, wanda shine samfurin lambobi masu lamba guda biyu daban-daban.\n\nReturns:\nint: Mafi girman lambobi masu lamba guda biyu na 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "hi": "दिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n\nदिए गए धनात्मक पूर्णांक का सबसे बड़ा अभाज्य गुणनखंड खोजें।\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\n\nपूर्णांक को ठीक दो भिन्न अभाज्य संख्याओं के गुणनफल के रूप में माना जाता है।\n\nThe function iterates through potential factors starting from the smallest prime (2) and checks if they are a factor of 'n'. If a factor is found, the function returns the division of 'n' by this factor, which is the larger prime factor. If no factors are found up to the square root of 'n', then 'n' itself is a prime number and is returned as the largest prime factor.\n\nयह फ़ंक्शन संभावित गुणनखंडों के माध्यम से सबसे छोटे अभाज्य (2) से शुरू होकर पुनरावृत्ति करता है और जांचता है कि क्या वे 'n' का गुणनखंड हैं। यदि कोई गुणनखंड पाया जाता है, तो फ़ंक्शन 'n' को इस गुणनखंड से विभाजित करके लौटाता है, जो कि बड़ा अभाज्य गुणनखंड होता है। यदि 'n' के वर्गमूल तक कोई गुणनखंड नहीं मिलता है, तो 'n' स्वयं एक अभाज्य संख्या है और इसे सबसे बड़े अभाज्य गुणनखंड के रूप में लौटाया जाता है।\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nn (int): वह धनात्मक पूर्णांक जिसे गुणनखंडित करना है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nReturns:\nint: 'n' के दो अभाज्य गुणनखंडों में से बड़ा।\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "hu": "Keresse meg egy adott pozitív egész szám legnagyobb prímtényezőjét.\n\nFeltételezzük, hogy az egész szám pontosan két különböző prímszám szorzata.\nA függvény a legkisebb prímtől (2) kezdve iterál a lehetséges tényezőkön, és ellenőrzi, hogy tényezője-e 'n'-nek. Ha talál tényezőt, a függvény visszaadja 'n' osztását ezzel a tényezővel, amely a nagyobb prímtényező. Ha nem talál tényezőket 'n' négyzetgyökéig, akkor maga 'n' egy prímszám, és visszaadja, mint a legnagyobb prímtényezőt.\n\nArgs:\nn (int): A pozitív egész szám, amelyet faktorizálni kell, és amely két különböző prím szorzata.\n\nReturns:\nint: 'n' két prímtényezője közül a nagyobb.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29"
    },
    "docstring_bertscore": {
      "sq": "0.9856422015372741",
      "hy": "0.928292446142595",
      "bn": "0.9672825967878383",
      "bg": "0.9105116503234949",
      "zh": "0.9561855146601813",
      "fr": "0.9892558840594419",
      "de": "0.9696913874186485",
      "ha": "0.9287053987047665",
      "hi": "1",
      "hu": "0.9689489070543401"
    }
  },
  {
    "task_id": "Python/24",
    "prompt": {
      "en": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    - count_partitions(7, 3, 1) will return 4, because there are four ways to partition \n      the number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) will return 3, because there are three ways to partition \n      the number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "sq": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\n    ku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\n    Parametrat:\n    n (int): Numri i plotë që do të ndahet.\n    k (int): Numri i pjesëve për të ndarë n.\n    x (int): Vlera minimale për secilën pjesë.\n\n    Kthen:\n    int: Numri i mënyrave të ndarjes së dallueshme.\n\n    Shembuj:\n    - count_partitions(7, 3, 1) do të kthejë 4, sepse ka katër mënyra për të ndarë \n      numrin 7 në 3 pjesë me secilën pjesë të paktën 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) do të kthejë 3, sepse ka tre mënyra për të ndarë \n      numrin 6 në 2 pjesë me secilën pjesë të paktën 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "hy": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Հաշվել, թե քանի եղանակով կարելի է n ամբողջ թիվը բաժանել k մասերի,\n    որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի կարգը նշանակություն չունի։\n\n    Պարամետրեր:\n    n (int): Բաժանվող ամբողջ թիվը։\n    k (int): Մասերի քանակը, որոնց n-ը պետք է բաժանել։\n    x (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\n    Վերադարձնում է:\n    int: Տարբեր բաժանումների եղանակների քանակը։\n\n    Օրինակներ:\n    - count_partitions(7, 3, 1) կվերադարձնի 4, քանի որ կա չորս եղանակ 7 թիվը բաժանելու \n      3 մասերի, որտեղ յուրաքանչյուր մասը առնվազն 1 է՝ [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3]։\n    - count_partitions(6, 2, 1) կվերադարձնի 3, քանի որ կա երեք եղանակ 6 թիվը բաժանելու \n      2 մասերի, որտեղ յուրաքանչյուր մասը առնվազն 1 է՝ [1,5], [2,4], [3,3]։\n    \"\"\"",
      "bn": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়গুলির সংখ্যা গণনা করুন,\n    যেখানে প্রতিটি অংশ কমপক্ষে x এবং অংশগুলির ক্রম গুরুত্বপূর্ণ নয়।\n\n    প্যারামিটারসমূহ:\n    n (int): পূর্ণসংখ্যাটি যা ভাগ করা হবে।\n    k (int): অংশের সংখ্যা যার মধ্যে n ভাগ করা হবে।\n    x (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\n    রিটার্নস:\n    int: পৃথক ভাগ করার উপায়গুলির সংখ্যা।\n\n    উদাহরণ:\n    - count_partitions(7, 3, 1) 4 ফেরত দেবে, কারণ 7 সংখ্যাটিকে 3 অংশে ভাগ করার চারটি উপায় আছে \n      যেখানে প্রতিটি অংশ কমপক্ষে 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3]।\n    - count_partitions(6, 2, 1) 3 ফেরত দেবে, কারণ 6 সংখ্যাটিকে 2 অংশে ভাগ করার তিনটি উপায় আছে \n      যেখানে প্রতিটি অংশ কমপক্ষে 1: [1,5], [2,4], [3,3]।\n    \"\"\"",
      "bg": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Брой на начините за разделяне на цяло число n на k части,\n    където всяка част е поне x и редът на частите няма значение.\n\n    Параметри:\n    n (int): Цялото число, което ще бъде разделено.\n    k (int): Броят на частите, на които да се раздели n.\n    x (int): Минималната стойност за всяка част.\n\n    Връща:\n    int: Броят на различните начини за разделяне.\n\n    Примери:\n    - count_partitions(7, 3, 1) ще върне 4, защото има четири начина да се раздели \n      числото 7 на 3 части, като всяка част е поне 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) ще върне 3, защото има три начина да се раздели \n      числото 6 на 2 части, като всяка част е поне 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "zh": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    计算将整数 n 分成 k 部分的方法数，\n    其中每部分至少为 x，且部分的顺序不重要。\n\n    参数:\n    n (int): 要分割的整数。\n    k (int): 将 n 分成的部分数。\n    x (int): 每部分的最小值。\n\n    返回:\n    int: 不同分割方式的数量。\n\n    示例:\n    - count_partitions(7, 3, 1) 将返回 4，因为有四种方法可以将数字 7 分成 3 部分，\n      每部分至少为 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3]。\n    - count_partitions(6, 2, 1) 将返回 3，因为有三种方法可以将数字 6 分成 2 部分，\n      每部分至少为 1: [1,5], [2,4], [3,3]。\n    \"\"\"",
      "fr": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Compter le nombre de façons de partitionner un entier n en k parties,\n    où chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\n    Paramètres:\n    n (int): L'entier à partitionner.\n    k (int): Le nombre de parties pour diviser n.\n    x (int): La valeur minimale pour chaque partie.\n\n    Renvoie:\n    int: Le nombre de façons distinctes de partitionnement.\n\n    Exemples:\n    - count_partitions(7, 3, 1) renverra 4, car il y a quatre façons de partitionner \n      le nombre 7 en 3 parties avec chaque partie étant au moins 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) renverra 3, car il y a trois façons de partitionner \n      le nombre 6 en 2 parties avec chaque partie étant au moins 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "de": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu partitionieren,\n    wobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\n    Parameter:\n    n (int): Die zu partitionierende ganze Zahl.\n    k (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\n    x (int): Der Mindestwert für jeden Teil.\n\n    Rückgabewert:\n    int: Die Anzahl der unterschiedlichen Partitionierungsmöglichkeiten.\n\n    Beispiele:\n    - count_partitions(7, 3, 1) wird 4 zurückgeben, da es vier Möglichkeiten gibt, \n      die Zahl 7 in 3 Teile zu partitionieren, wobei jeder Teil mindestens 1 ist: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) wird 3 zurückgeben, da es drei Möglichkeiten gibt, \n      die Zahl 6 in 2 Teile zu partitionieren, wobei jeder Teil mindestens 1 ist: [1,5], [2,4], [3,3].\n    \"\"\"",
      "ha": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Ƙirga adadin hanyoyin da za a iya raba lamba n zuwa k ɓangarori,\n    inda kowanne ɓangare ya kasance aƙalla x kuma tsarin ɓangarorin bai damu ba.\n\n    Sigogi:\n    n (int): Lambar da za a raba.\n    k (int): Yawan ɓangarorin da za a raba n.\n    x (int): Ƙimar mafi ƙaranci ga kowanne ɓangare.\n\n    Komawa:\n    int: Yawan hanyoyin rarrabawa daban-daban.\n\n    Misalai:\n    - count_partitions(7, 3, 1) zai dawo da 4, domin akwai hanyoyi guda huɗu da za a raba \n      lamba 7 zuwa ɓangarori 3 tare da kowanne ɓangare ya kasance aƙalla 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) zai dawo da 3, domin akwai hanyoyi guda uku da za a raba \n      lamba 6 zuwa ɓangarori 2 tare da kowanne ɓangare ya kasance aƙalla 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "hi": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    किसी पूर्णांक n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\n    जहाँ प्रत्येक भाग कम से कम x हो और भागों के क्रम का कोई महत्व न हो।\n\n    पैरामीटर्स:\n    n (int): विभाजित करने के लिए पूर्णांक।\n    k (int): भागों की संख्या जिसमें n को विभाजित करना है।\n    x (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\n    रिटर्न्स:\n    int: विभिन्न विभाजन तरीकों की संख्या।\n\n    उदाहरण:\n    - count_partitions(7, 3, 1) 4 लौटाएगा, क्योंकि 7 को 3 भागों में विभाजित करने के \n      चार तरीके हैं जहाँ प्रत्येक भाग कम से कम 1 है: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3]।\n    - count_partitions(6, 2, 1) 3 लौटाएगा, क्योंकि 6 को 2 भागों में विभाजित करने के \n      तीन तरीके हैं जहाँ प्रत्येक भाग कम से कम 1 है: [1,5], [2,4], [3,3]।\n    \"\"\"",
      "hu": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Számolja meg, hányféleképpen lehet egy n egész számot k részre osztani,\n    ahol minden rész legalább x, és a részek sorrendje nem számít.\n\n    Paraméterek:\n    n (int): Az egész szám, amelyet fel kell osztani.\n    k (int): A részek száma, amelyre n-t fel kell osztani.\n    x (int): A minimális érték minden rész esetében.\n\n    Visszatér:\n    int: Az eltérő felosztási módok száma.\n\n    Példák:\n    - count_partitions(7, 3, 1) visszaadja a 4-et, mert négyféleképpen lehet \n      a 7-es számot 3 részre osztani úgy, hogy minden rész legalább 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) visszaadja a 3-at, mert háromféleképpen lehet \n      a 6-os számot 2 részre osztani úgy, hogy minden rész legalább 1: [1,5], [2,4], [3,3].\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9867694289496471",
      "hy": "0.9717754173764666",
      "bn": "0.9748760376244211",
      "bg": "0.9856706056817621",
      "zh": "0.9738769268078157",
      "fr": "0.9899483095677295",
      "de": "0.9661831776288103",
      "ha": "0.9825018552131125",
      "hi": "0.9725004182672439",
      "hu": "0.98258964984153"
    },
    "canonical_solution": "    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count",
    "instruction": {
      "en": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nՏվյալ Python կոդի համար տրամադրեք կարճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nपायथन कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8697749427378118",
      "bn": "0.8827651710271124",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9530483464221162",
      "hi": "0.9526550582676672",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_count_partitions():\n    # Test case 1: Simple case\n    result = count_partitions(7, 3, 1)\n    assert result == 4, f\"Expected 4, got {result}\"\n\n    # Test case 2: Another simple case\n    result = count_partitions(6, 2, 1)\n    assert result == 3, f\"Expected 3, got {result}\"\n\n    # Test case 3: Partitioning into a larger number of parts\n    result = count_partitions(8, 4, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n\n    print(\"All test cases passed successfully!\")\n\n\n# Call the test function to run the test cases\ntest_count_partitions()",
    "entry_point": "count_partitions",
    "signature": "def count_partitions(n: int, k: int, x: int) -> int:",
    "docstring": {
      "en": "Count the number of ways to partition an integer n into k parts,\nwhere each part is at least x and order of parts does not matter.\n\nParameters:\nn (int): The integer to be partitioned.\nk (int): The number of parts to divide n into.\nx (int): The minimum value for each part.\n\nReturns:\nint: The number of distinct partitioning ways.\n\nExamples:\n- count_partitions(7, 3, 1) will return 4, because there are four ways to partition\nthe number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) will return 3, because there are three ways to partition\nthe number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].",
      "sq": "Numëroni numrin e mënyrave për të ndarë një numër të plotë n në k pjesë,\nku secila pjesë është të paktën x dhe rendi i pjesëve nuk ka rëndësi.\n\nParametrat:\nn (int): Numri i plotë që do të ndahet.\nk (int): Numri i pjesëve për të ndarë n.\nx (int): Vlera minimale për secilën pjesë.\n\nKthen:\nint: Numri i mënyrave të ndarjes të dallueshme.\n\nShembuj:\n- count_partitions(7, 3, 1) do të kthejë 4, sepse ka katër mënyra për të ndarë\nnumrin 7 në 3 pjesë me secilën pjesë të paktën 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) do të kthejë 3, sepse ka tre mënyra për të ndarë\nnumrin 6 në 2 pjesë me secilën pjesë të paktën 1: [1,5], [2,4], [3,3].",
      "hy": "Հաշվել, թե քանի եղանակով կարելի է բաժանել n ամբողջ թիվը k մասերի, որտեղ յուրաքանչյուր մասը առնվազն x է, և մասերի կարգը նշանակություն չունի։\n\nՊարամետրեր:\nn (int): Բաժանվող ամբողջ թիվը։\nk (int): Մասերի քանակը, որոնց պետք է բաժանել n-ը։\nx (int): Յուրաքանչյուր մասի նվազագույն արժեքը։\n\nՎերադարձնում է:\nint: Տարբեր բաժանումների եղանակների քանակը։\n\nՕրինակներ:\n- count_partitions(7, 3, 1) կվերադարձնի 4, որովհետև կան չորս եղանակներ 7 թիվը բաժանելու 3 մասերի, որտեղ յուրաքանչյուր մասը առնվազն 1 է՝ [1,1,5], [1,2,4], [1,3,3], [2,2,3]։\n- count_partitions(6, 2, 1) կվերադարձնի 3, որովհետև կան երեք եղանակներ 6 թիվը բաժանելու 2 մասերի, որտեղ յուրաքանչյուր մասը առնվազն 1 է՝ [1,5], [2,4], [3,3]։",
      "bn": "একটি পূর্ণসংখ্যা n কে k অংশে ভাগ করার উপায়ের সংখ্যা গণনা করুন,\nযেখানে প্রতিটি অংশ অন্তত x এবং অংশগুলির ক্রম বিবেচ্য নয়।\n\nপ্যারামিটার:\nn (int): যে পূর্ণসংখ্যাটি ভাগ করা হবে।\nk (int): n কে যে অংশগুলিতে ভাগ করতে হবে তার সংখ্যা।\nx (int): প্রতিটি অংশের জন্য ন্যূনতম মান।\n\nরিটার্নস:\nint: পৃথক বিভাজনের উপায়ের সংখ্যা।\n\nউদাহরণ:\n- count_partitions(7, 3, 1) 4 ফেরত দেবে, কারণ চারটি উপায় আছে\nসংখ্যা 7 কে 3 অংশে ভাগ করার, যেখানে প্রতিটি অংশ অন্তত 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3]।\n- count_partitions(6, 2, 1) 3 ফেরত দেবে, কারণ তিনটি উপায় আছে\nসংখ্যা 6 কে 2 অংশে ভাগ করার, যেখানে প্রতিটি অংশ অন্তত 1: [1,5], [2,4], [3,3]।",
      "bg": "Бройте броя на начините за разделяне на цяло число n на k части, където всяка част е поне x и редът на частите няма значение.\n\nПараметри:\nn (int): Цялото число, което ще бъде разделено.\nk (int): Броят на частите, на които да се раздели n.\nx (int): Минималната стойност за всяка част.\n\nВръща:\nint: Броят на различните начини за разделяне.\n\nПримери:\n- count_partitions(7, 3, 1) ще върне 4, защото има четири начина да се раздели числото 7 на 3 части, като всяка част е поне 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) ще върне 3, защото има три начина да се раздели числото 6 на 2 части, като всяка част е поне 1: [1,5], [2,4], [3,3].",
      "zh": "计算将整数 n 分成 k 个部分的方法数，其中每个部分至少为 x，并且部分的顺序无关紧要。\n\n参数：\nn (int): 要分割的整数。\nk (int): 将 n 分成的部分数。\nx (int): 每个部分的最小值。\n\n返回：\nint: 不同分割方法的数量。\n\n示例：\n- count_partitions(7, 3, 1) 将返回 4，因为有四种方法可以将数字 7 分成 3 个部分，每个部分至少为 1：[1,1,5], [1,2,4], [1,3,3], [2,2,3]。\n- count_partitions(6, 2, 1) 将返回 3，因为有三种方法可以将数字 6 分成 2 个部分，每个部分至少为 1：[1,5], [2,4], [3,3]。",
      "fr": "Compter le nombre de façons de partitionner un entier n en k parties,\noù chaque partie est au moins x et l'ordre des parties n'a pas d'importance.\n\nParamètres :\nn (int) : L'entier à partitionner.\nk (int) : Le nombre de parties pour diviser n.\nx (int) : La valeur minimale pour chaque partie.\n\nRenvoie :\nint : Le nombre de façons de partition distinctes.\n\nExemples :\n- count_partitions(7, 3, 1) renverra 4, car il y a quatre façons de partitionner\nle nombre 7 en 3 parties avec chaque partie étant au moins 1 : [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) renverra 3, car il y a trois façons de partitionner\nle nombre 6 en 2 parties avec chaque partie étant au moins 1 : [1,5], [2,4], [3,3].",
      "de": "Zähle die Anzahl der Möglichkeiten, eine ganze Zahl n in k Teile zu partitionieren,\nwobei jeder Teil mindestens x ist und die Reihenfolge der Teile keine Rolle spielt.\n\nParameter:\nn (int): Die zu partitionierende ganze Zahl.\nk (int): Die Anzahl der Teile, in die n aufgeteilt werden soll.\nx (int): Der Mindestwert für jeden Teil.\n\nRückgabewert:\nint: Die Anzahl der unterschiedlichen Partitionierungsmöglichkeiten.\n\nBeispiele:\n- count_partitions(7, 3, 1) wird 4 zurückgeben, da es vier Möglichkeiten gibt, die Zahl 7 in 3 Teile zu partitionieren, wobei jeder Teil mindestens 1 ist: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) wird 3 zurückgeben, da es drei Möglichkeiten gibt, die Zahl 6 in 2 Teile zu partitionieren, wobei jeder Teil mindestens 1 ist: [1,5], [2,4], [3,3].",
      "ha": "Ƙirga adadin hanyoyin da za a iya raba lamba n zuwa k ɓangarori,\ninda kowanne sashi ya kasance a kalla x kuma tsarin sassan bai da mahimmanci.\n\nSigogi:\nn (int): Lambar da za a raba.\nk (int): Yawan sassan da za a raba n.\nx (int): Mafi karancin darajar kowane sashi.\n\nDawowa:\nint: Yawan hanyoyin rarrabuwa na musamman.\n\nMisalai:\n- count_partitions(7, 3, 1) zai dawo da 4, saboda akwai hanyoyi hudu don raba\nlamba 7 zuwa sassa 3 tare da kowanne sashi ya kasance a kalla 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) zai dawo da 3, saboda akwai hanyoyi uku don raba\nlamba 6 zuwa sassa 2 tare da kowanne sashi ya kasance a kalla 1: [1,5], [2,4], [3,3].",
      "hi": "किसी पूर्णांक n को k भागों में विभाजित करने के तरीकों की संख्या गिनें,\nजहाँ प्रत्येक भाग कम से कम x हो और भागों के क्रम का कोई महत्व न हो।\n\nमापदंड:\nn (int): वह पूर्णांक जिसे विभाजित करना है।\nk (int): भागों की संख्या जिसमें n को विभाजित करना है।\nx (int): प्रत्येक भाग के लिए न्यूनतम मान।\n\nवापसी:\nint: विभाजन के विभिन्न तरीकों की संख्या।\n\nउदाहरण:\n- count_partitions(7, 3, 1) 4 लौटाएगा, क्योंकि 7 को 3 भागों में विभाजित करने के चार तरीके हैं, जहाँ प्रत्येक भाग कम से कम 1 है: [1,1,5], [1,2,4], [1,3,3], [2,2,3]।\n- count_partitions(6, 2, 1) 3 लौटाएगा, क्योंकि 6 को 2 भागों में विभाजित करने के तीन तरीके हैं, जहाँ प्रत्येक भाग कम से कम 1 है: [1,5], [2,4], [3,3]।",
      "hu": "Számolja meg, hányféleképpen lehet egy n egész számot k részre felosztani,\nahol minden rész legalább x, és a részek sorrendje nem számít.\n\nParaméterek:\nn (int): Az egész szám, amelyet fel kell osztani.\nk (int): A részek száma, amire n-t fel kell osztani.\nx (int): Minden rész minimum értéke.\n\nVisszatérési érték:\nint: A különböző felosztási módok száma.\n\nPéldák:\n- count_partitions(7, 3, 1) visszaadja a 4-et, mert négyféleképpen lehet\na 7-es számot 3 részre felosztani, ahol minden rész legalább 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) visszaadja a 3-at, mert háromféleképpen lehet\na 6-os számot 2 részre felosztani, ahol minden rész legalább 1: [1,5], [2,4], [3,3]."
    },
    "docstring_bertscore": {
      "sq": "0.9852119681319526",
      "hy": "0.9729181379585602",
      "bn": "0.9799466739914797",
      "bg": "0.9788635425236966",
      "zh": "0.9695533393038293",
      "fr": "0.9853561737885839",
      "de": "0.9678514741991223",
      "ha": "0.9733674398804611",
      "hi": "0.9686386463991635",
      "hu": "0.965805779904844"
    }
  },
  {
    "task_id": "Python/25",
    "prompt": {
      "en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        # Only one sequence can be formed starting with 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Six sequences can be formed starting with 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # More complex example with memoization dictionary passed\n        # You would typically not pass this dictionary manually,\n        # it's used internally by the function for optimization.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # This is an assumed value for the example; the actual result may differ.\n    \"\"\"\n    # Function implementation is here...",
      "sq": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Llogarit numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n    \n    Çdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund të shtohet në sekuencë\n    nëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. Kjo\n    funksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n    \n    Argumentet:\n        n (int): Numri fillestar i sekuencës.\n        last (int): Numri i fundit në sekuencën aktuale.\n        memo (dict): Një fjalor i përdorur për memoizim, që ruan numrin e sekuencave të vlefshme\n                     për çdo vlerë 'last' të hasur.\n    \n    Kthen:\n        int: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n    \n    Shembuj:\n        # Vetëm një sekuencë mund të formohet duke filluar me 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Gjashtë sekuenca mund të formohen duke filluar me 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Shembull më kompleks me fjalorin e memoizimit të kaluar\n        # Normalisht nuk do ta kalonit këtë fjalor manualisht,\n        # ai përdoret brenda funksionit për optimizim.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Kjo është një vlerë e supozuar për shembullin; rezultati aktual mund të ndryshojë.\n    \"\"\"\n    # Zbatimi i funksionit është këtu...",
      "hy": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Հաշվել վավեր հաջորդականությունների քանակը, որոնք կարող են ձևավորվել ըստ որոշակի կանոնների:\n    \n    Յուրաքանչյուր հաջորդականություն սկսվում է տրված 'n' թվից, և նոր թիվ կարելի է ավելացնել հաջորդականությանը,\n    եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը: Այս\n    ֆունկցիան օգտագործում է հիշողություն (memoization)՝ պահպանելու համար նախապես հաշվարկված արդյունքները՝\n    օպտիմալացնելու կատարողականությունը:\n    \n    Արգումենտներ:\n        n (int): Հաջորդականության մեկնարկային թիվը:\n        last (int): Ընթացիկ հաջորդականության վերջին թիվը:\n        memo (dict): Բառարան, որը օգտագործվում է հիշողության համար, պահելով վավեր հաջորդականությունների քանակը\n                     յուրաքանչյուր 'last' արժեքի համար:\n    \n    Վերադարձնում է:\n        int: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ձևավորվել սկսելով 'n'-ից:\n    \n    Օրինակներ:\n        # Միայն մեկ հաջորդականություն կարող է ձևավորվել սկսելով 1-ից: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Վեց հաջորդականություն կարող է ձևավորվել սկսելով 6-ից:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Ավելի բարդ օրինակ հիշողության բառարանով\n        # Դուք սովորաբար չեք փոխանցում այս բառարանը ձեռքով,\n        # այն օգտագործվում է ֆունկցիայի ներսում օպտիմալացման համար:\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Սա օրինակ է ենթադրյալ արժեքով; իրական արդյունքը կարող է տարբերվել:\n    \"\"\"\n    # Ֆունկցիայի իրականացումը այստեղ է...",
      "bn": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    নির্দিষ্ট নিয়ম অনুযায়ী গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের সংখ্যা গণনা করুন।\n    \n    প্রতিটি সিকোয়েন্স একটি নির্দিষ্ট সংখ্যা 'n' দিয়ে শুরু হয়, এবং সিকোয়েন্সে একটি নতুন সংখ্যা যোগ করা যেতে পারে\n    যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং সিকোয়েন্সের শেষ সংখ্যার অর্ধেকের বেশি না হয়। এই\n    ফাংশনটি মেমোইজেশন ব্যবহার করে পূর্বে গণনা করা ফলাফল সংরক্ষণ করে কর্মক্ষমতা উন্নত করতে।\n    \n    Args:\n        n (int): সিকোয়েন্সের শুরুর সংখ্যা।\n        last (int): বর্তমান সিকোয়েন্সের শেষ সংখ্যা।\n        memo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি ডিকশনারি, প্রতিটি 'last' মানের জন্য বৈধ সিকোয়েন্সের সংখ্যা\n                     সংরক্ষণ করে।\n    \n    Returns:\n        int: 'n' দিয়ে শুরু করে গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের মোট সংখ্যা।\n    \n    Examples:\n        # শুধুমাত্র একটি সিকোয়েন্স 1 দিয়ে শুরু করে গঠন করা যেতে পারে: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # ছয়টি সিকোয়েন্স 6 দিয়ে শুরু করে গঠন করা যেতে পারে:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # মেমোইজেশন ডিকশনারি সহ আরও জটিল উদাহরণ\n        # সাধারণত আপনি এই ডিকশনারি ম্যানুয়ালি পাস করবেন না,\n        # এটি ফাংশন দ্বারা অভ্যন্তরীণভাবে অপ্টিমাইজেশনের জন্য ব্যবহৃত হয়।\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # এটি উদাহরণের জন্য একটি অনুমানকৃত মান; প্রকৃত ফলাফল ভিন্ন হতে পারে।\n    \"\"\"\n    # Function implementation is here...",
      "bg": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Изчислява броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n    \n    Всяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността,\n    ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази\n    функция използва мемоизация, за да съхранява предварително изчислени резултати за оптимизиране на производителността.\n    \n    Аргументи:\n        n (int): Началното число на последователността.\n        last (int): Последното число в текущата последователност.\n        memo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности\n                     за всяка срещната стойност на 'last'.\n    \n    Връща:\n        int: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n    \n    Примери:\n        # Може да бъде формирана само една последователност, започваща с 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Шест последователности могат да бъдат формирани, започвайки с 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # По-сложен пример с предаден речник за мемоизация\n        # Обикновено не бихте предавали този речник ръчно,\n        # той се използва вътрешно от функцията за оптимизация.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Това е предположена стойност за примера; действителният резултат може да се различава.\n    \"\"\"\n    # Function implementation is here...",
      "zh": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    根据特定规则计算可以形成的有效序列的数量。\n    \n    每个序列以给定数字'n'开始，如果一个新数字是正整数且不大于序列中最后一个数字的一半，\n    则可以将其附加到序列中。此函数使用记忆化存储先前计算的结果以优化性能。\n    \n    参数:\n        n (int): 序列的起始数字。\n        last (int): 当前序列的最后一个数字。\n        memo (dict): 用于记忆化的字典，存储每个遇到的'last'值的有效序列数量。\n    \n    返回:\n        int: 可以从'n'开始形成的有效序列的总数。\n    \n    示例:\n        # 只有一个序列可以从1开始形成: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # 可以从6开始形成六个序列:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # 使用传递的记忆化字典的更复杂示例\n        # 通常不会手动传递此字典，\n        # 它由函数内部用于优化。\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # 这是示例的假定值；实际结果可能不同。\n    \"\"\"\n    # Function implementation is here...",
      "fr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n    \n    Chaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\n    s'il est un entier positif et pas plus grand que la moitié du dernier nombre de la séquence. Cette\n    fonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n    \n    Args:\n        n (int): Le nombre de départ de la séquence.\n        last (int): Le dernier nombre dans la séquence actuelle.\n        memo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\n                     pour chaque valeur 'last' rencontrée.\n    \n    Returns:\n        int: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n    \n    Examples:\n        # Une seule séquence peut être formée en commençant par 1 : [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Six séquences peuvent être formées en commençant par 6 :\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Exemple plus complexe avec dictionnaire de mémoïsation passé\n        # Vous ne passeriez généralement pas ce dictionnaire manuellement,\n        # il est utilisé en interne par la fonction pour l'optimisation.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Ceci est une valeur supposée pour l'exemple ; le résultat réel peut différer.\n    \"\"\"\n    # L'implémentation de la fonction est ici...",
      "de": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Berechne die Anzahl der gültigen Sequenzen, die gemäß spezifischer Regeln gebildet werden können.\n    \n    Jede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden,\n    wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz.\n    Diese Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n    \n    Argumente:\n        n (int): Die Startzahl der Sequenz.\n        last (int): Die letzte Zahl in der aktuellen Sequenz.\n        memo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen\n                     für jeden 'last'-Wert speichert, der aufgetreten ist.\n    \n    Rückgabewert:\n        int: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' beginnen können.\n    \n    Beispiele:\n        # Es kann nur eine Sequenz gebildet werden, die mit 1 beginnt: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Sechs Sequenzen können gebildet werden, die mit 6 beginnen:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Komplexeres Beispiel mit übergebenem Memoisierungs-Wörterbuch\n        # Normalerweise würde man dieses Wörterbuch nicht manuell übergeben,\n        # es wird intern von der Funktion zur Optimierung verwendet.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Dies ist ein angenommener Wert für das Beispiel; das tatsächliche Ergebnis kann abweichen.\n    \"\"\"\n    # Function implementation is here...",
      "ha": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Lissafi adadin jerin sahihai da za a iya samarwa bisa ga wasu ƙa'idoji.\n\n    Kowace jeri tana farawa da wani adadi 'n', kuma za a iya ƙara sabon adadi zuwa jerin\n    idan yana da adadi mai kyau kuma ba ya fi rabin adadin ƙarshe a cikin jerin ba. Wannan\n    aikin yana amfani da memoization don adana sakamakon da aka lissafa a baya don inganta aiki.\n\n    Args:\n        n (int): Adadin farawa na jerin.\n        last (int): Adadin ƙarshe a cikin jerin yanzu.\n        memo (dict): Wani kamus da ake amfani da shi don memoization, yana adana adadin jerin sahihai\n                     don kowane ƙimar 'last' da aka ci karo da shi.\n\n    Returns:\n        int: Jimillar adadin jerin sahihai da za a iya samarwa farawa da 'n'.\n\n    Misalai:\n        # Jerin guda ɗaya kawai za a iya samarwa farawa da 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Jerin shida za a iya samarwa farawa da 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Misali mafi rikitarwa tare da kamus na memoization da aka wuce\n        # Da alama ba za ka wuce wannan kamus ɗin da hannu ba,\n        # ana amfani da shi a ciki ta aikin don ingantawa.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Wannan wata ƙima ce da aka ɗauka don misali; sakamakon ainihi na iya bambanta.\n    \"\"\"\n    # Function implementation is here...",
      "hi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    विशिष्ट नियमों के अनुसार बनाए जा सकने वाले वैध अनुक्रमों की संख्या की गणना करें।\n    \n    प्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और एक नई संख्या अनुक्रम में जोड़ी जा सकती है\n    यदि यह एक सकारात्मक पूर्णांक है और अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं है। यह\n    फ़ंक्शन प्रदर्शन को अनुकूलित करने के लिए पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए स्मृति-भंडारण का उपयोग करता है।\n    \n    तर्क:\n        n (int): अनुक्रम की प्रारंभिक संख्या।\n        last (int): वर्तमान अनुक्रम में अंतिम संख्या।\n        memo (dict): स्मृति-भंडारण के लिए उपयोग किया जाने वाला एक शब्दकोश, प्रत्येक 'last' मान के लिए\n                     मिले वैध अनुक्रमों की संख्या संग्रहीत करता है।\n    \n    लौटाता है:\n        int: 'n' से शुरू होने वाले बनाए जा सकने वाले वैध अनुक्रमों की कुल संख्या।\n    \n    उदाहरण:\n        # केवल एक अनुक्रम 1 से शुरू होकर बनाया जा सकता है: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # छह अनुक्रम 6 से शुरू होकर बनाए जा सकते हैं:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # स्मृति-भंडारण शब्दकोश के साथ अधिक जटिल उदाहरण\n        # आप आमतौर पर इस शब्दकोश को मैन्युअल रूप से पास नहीं करेंगे,\n        # यह अनुकूलन के लिए फ़ंक्शन द्वारा आंतरिक रूप से उपयोग किया जाता है।\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # यह उदाहरण के लिए एक अनुमानित मान है; वास्तविक परिणाम भिन्न हो सकता है।\n    \"\"\"\n    # Function implementation is here...",
      "hu": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Számolja ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint képezhetők.\n    \n    Minden sorozat egy adott 'n' számmal kezdődik, és egy új szám fűzhető a sorozathoz,\n    ha pozitív egész szám és nem nagyobb, mint a sorozat utolsó számának fele. Ez a\n    függvény memoizációt használ a korábban kiszámított eredmények tárolására a teljesítmény optimalizálása érdekében.\n    \n    Argok:\n        n (int): A sorozat kezdő száma.\n        last (int): Az aktuális sorozat utolsó száma.\n        memo (dict): Egy szótár a memoizációhoz, amely az érvényes sorozatok számát tárolja\n                     minden előforduló 'last' értékhez.\n    \n    Visszatér:\n        int: Az érvényes sorozatok teljes száma, amelyek 'n'-nel kezdődhetnek.\n    \n    Példák:\n        # Csak egy sorozat képezhető, amely 1-gyel kezdődik: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Hat sorozat képezhető, amely 6-tal kezdődik:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Bonyolultabb példa memoizációs szótárral\n        # Általában nem adod meg ezt a szótárt manuálisan,\n        # a függvény belsőleg használja az optimalizáláshoz.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Ez egy feltételezett érték a példában; a tényleges eredmény eltérhet.\n    \"\"\"\n    # Function implementation is here..."
    },
    "prompt_bertscore": {
      "sq": "0.9830878148371655",
      "hy": "0.9731600697626608",
      "bn": "0.9788347411184465",
      "bg": "0.9765361903491108",
      "zh": "0.9818886832268579",
      "fr": "0.9899119602080001",
      "de": "0.9724755894696145",
      "ha": "0.9764174093812519",
      "hi": "0.9755911069961467",
      "hu": "0.9717489995357889"
    },
    "canonical_solution": "    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count",
    "instruction": {
      "en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nПредоставете кратко описание на Python кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nBada takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548376088944786",
      "hy": "0.8856909965397564",
      "bn": "0.8842060358111395",
      "bg": "0.8415791615195284",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.9104673557485241",
      "hi": "0.9109764454151166",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_count_sequences():\n    test_cases = [\n        (6, 6),\n        (1, 1),\n        (10, 14)\n    ]\n\n    for i, (n, expected) in enumerate(test_cases):\n        memo = {}\n        result = count_sequences(n, n, memo)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: n = {n}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_sequences()",
    "entry_point": "count_sequences",
    "signature": "def count_sequences(n: int, last: int, memo: dict) -> int:",
    "docstring": {
      "en": "Calculate the number of valid sequences that can be formed according to specific rules.\n\nEach sequence starts with a given number 'n', and a new number can be appended to the sequence\nif it is a positive integer and not greater than half the last number in the sequence. This\nfunction uses memoization to store previously calculated results to optimize performance.\n\nArgs:\nn (int): The starting number of the sequence.\nlast (int): The last number in the current sequence.\nmemo (dict): A dictionary used for memoization, storing the number of valid sequences\nfor each 'last' value encountered.\n\nReturns:\nint: The total number of valid sequences that can be formed starting with 'n'.\n\nExamples:\nOnly one sequence can be formed starting with 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix sequences can be formed starting with 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMore complex example with memoization dictionary passed\nYou would typically not pass this dictionary manually,\nit's used internally by the function for optimization.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # This is an assumed value for the example; the actual result may differ.",
      "sq": "Llogarit numrin e sekuencave të vlefshme që mund të formohen sipas rregullave specifike.\n\nÇdo sekuencë fillon me një numër të dhënë 'n', dhe një numër i ri mund të shtohet në sekuencë\nnëse është një numër i plotë pozitiv dhe jo më i madh se gjysma e numrit të fundit në sekuencë. Kjo\nfunksion përdor memoizimin për të ruajtur rezultatet e llogaritura më parë për të optimizuar performancën.\n\nArgumentet:\nn (int): Numri fillestar i sekuencës.\nlast (int): Numri i fundit në sekuencën aktuale.\nmemo (dict): Një fjalor i përdorur për memoizim, që ruan numrin e sekuencave të vlefshme\npër çdo vlerë 'last' të hasur.\n\nKthen:\nint: Numri total i sekuencave të vlefshme që mund të formohen duke filluar me 'n'.\n\nShembuj:\nVetëm një sekuencë mund të formohet duke filluar me 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nGjashtë sekuenca mund të formohen duke filluar me 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nShembull më kompleks me fjalorin e memoizimit të kaluar\nZakonisht nuk do ta kalonit këtë fjalor manualisht,\nai përdoret brenda funksionit për optimizim.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Ky është një vlerë e supozuar për shembullin; rezultati aktual mund të ndryshojë.",
      "hy": "Հաշվել այն վավեր հաջորդականությունների քանակը, որոնք կարող են կազմվել ըստ որոշակի կանոնների։\n\nՅուրաքանչյուր հաջորդականություն սկսվում է տրված 'n' թվից, և նոր թիվը կարող է ավելացվել հաջորդականությանը, եթե այն դրական ամբողջ թիվ է և չի գերազանցում հաջորդականության վերջին թվի կեսը։ Այս ֆունկցիան օգտագործում է հիշողության օպտիմալացում՝ պահելու համար նախկինում հաշվարկված արդյունքները՝ կատարողականությունը բարելավելու համար։\n\nԱրձանագրություններ:\nn (int): Հաջորդականության մեկնարկային թիվը։\nlast (int): Ընթացիկ հաջորդականության վերջին թիվը։\nmemo (dict): Բառարան, որը օգտագործվում է հիշողության օպտիմալացման համար՝ պահելու վավեր հաջորդականությունների քանակը\nյուրաքանչյուր հանդիպած 'last' արժեքի համար։\n\nՎերադարձնում է:\nint: Վավեր հաջորդականությունների ընդհանուր քանակը, որոնք կարող են կազմվել 'n'-ով սկսած։\n\nՕրինակներ:\nՄիայն մեկ հաջորդականություն կարող է կազմվել 1-ից սկսած՝ [1]\n>>> count_sequences(1, 1, {})\n1\n\nՎեց հաջորդականություն կարող է կազմվել 6-ից սկսած՝\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nԱվելի բարդ օրինակ՝ հիշողության օպտիմալացման բառարանով\nԴուք սովորաբար չեք փոխանցում այս բառարանը ձեռքով,\nայն օգտագործվում է ֆունկցիայի կողմից ներքին օպտիմալացման համար։\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Սա օրինակային արժեք է; իրական արդյունքը կարող է տարբերվել։",
      "bn": "নির্দিষ্ট নিয়ম অনুযায়ী গঠন করা যেতে পারে এমন বৈধ সিকোয়েন্সের সংখ্যা গণনা করুন।\n\nপ্রতিটি ক্রম একটি প্রদত্ত সংখ্যা 'n' দিয়ে শুরু হয়, এবং একটি নতুন সংখ্যা ক্রমে যোগ করা যেতে পারে যদি এটি একটি ধনাত্মক পূর্ণসংখ্যা হয় এবং ক্রমের শেষ সংখ্যার অর্ধেকের বেশি না হয়। এই ফাংশনটি কর্মদক্ষতা বাড়ানোর জন্য পূর্বে গণনা করা ফলাফল সংরক্ষণ করতে মেমোইজেশন ব্যবহার করে।\n\nArgs:\nn (int): ক্রমের শুরু সংখ্যা।\nlast (int): বর্তমান ক্রমের শেষ সংখ্যা।\nmemo (dict): মেমোইজেশনের জন্য ব্যবহৃত একটি অভিধান, প্রতিটি 'last' মানের জন্য সম্মুখীন বৈধ ক্রমের সংখ্যা সংরক্ষণ করে।\n\nReturns:\nint: মোট বৈধ ক্রমের সংখ্যা যা 'n' দিয়ে শুরু হতে পারে।\n\nExamples:\nশুধুমাত্র একটি ক্রম গঠন করা যেতে পারে 1 দিয়ে শুরু করে: [1]\n>>> count_sequences(1, 1, {})\n1\n\nছয়টি ক্রম গঠন করা যেতে পারে 6 দিয়ে শুরু করে:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nমেমোইজেশন অভিধান সহ আরও জটিল উদাহরণ\nআপনি সাধারণত এই অভিধানটি ম্যানুয়ালি পাস করবেন না,\nএটি ফাংশন দ্বারা অভ্যন্তরীণভাবে অপ্টিমাইজেশনের জন্য ব্যবহৃত হয়।\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # এটি উদাহরণের জন্য একটি অনুমিত মান; প্রকৃত ফলাফল ভিন্ন হতে পারে।",
      "bg": "Изчислете броя на валидните последователности, които могат да бъдат формирани според специфични правила.\n\nВсяка последователност започва с дадено число 'n', и ново число може да бъде добавено към последователността, ако е положително цяло число и не е по-голямо от половината на последното число в последователността. Тази функция използва мемоизация, за да съхранява предварително изчислени резултати за оптимизиране на производителността.\n\nАргументи:\nn (int): Началното число на последователността.\nlast (int): Последното число в текущата последователност.\nmemo (dict): Речник, използван за мемоизация, съхраняващ броя на валидните последователности за всяка срещната стойност на 'last'.\n\nВръща:\nint: Общият брой на валидните последователности, които могат да бъдат формирани, започвайки с 'n'.\n\nПримери:\nСамо една последователност може да бъде формирана, започвайки с 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nШест последователности могат да бъдат формирани, започвайки с 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nПо-сложен пример с речник за мемоизация, предаден като аргумент\nОбикновено не бихте предавали този речник ръчно,\nтой се използва вътрешно от функцията за оптимизация.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Това е предполагаема стойност за примера; действителният резултат може да се различава.",
      "zh": "计算可以根据特定规则形成的有效序列的数量。\n\n每个序列以给定数字'n'开始，如果新数字是正整数且不大于序列中最后一个数字的一半，则可以将其附加到序列中。此函数使用记忆化技术存储先前计算的结果以优化性能。\n\n参数：\nn (int): 序列的起始数字。\nlast (int): 当前序列中的最后一个数字。\nmemo (dict): 用于记忆化的字典，存储每个遇到的'last'值的有效序列数量。\n\n返回：\nint: 可以从'n'开始形成的有效序列的总数。\n\n示例：\n只有一个序列可以从1开始形成：[1]\n>>> count_sequences(1, 1, {})\n1\n\n可以从6开始形成六个序列：\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\n更复杂的示例，传递记忆化字典\n通常不会手动传递此字典，它由函数内部用于优化。\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # 这是示例中的假定值；实际结果可能不同。",
      "fr": "Calculer le nombre de séquences valides qui peuvent être formées selon des règles spécifiques.\n\nChaque séquence commence par un nombre donné 'n', et un nouveau nombre peut être ajouté à la séquence\ns'il est un entier positif et ne dépasse pas la moitié du dernier nombre de la séquence. Cette\nfonction utilise la mémoïsation pour stocker les résultats précédemment calculés afin d'optimiser les performances.\n\nArgs:\nn (int): Le nombre de départ de la séquence.\nlast (int): Le dernier nombre dans la séquence actuelle.\nmemo (dict): Un dictionnaire utilisé pour la mémoïsation, stockant le nombre de séquences valides\npour chaque valeur 'last' rencontrée.\n\nReturns:\nint: Le nombre total de séquences valides qui peuvent être formées en commençant par 'n'.\n\nExamples:\nUne seule séquence peut être formée en commençant par 1 : [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix séquences peuvent être formées en commençant par 6 :\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nExemple plus complexe avec dictionnaire de mémoïsation passé\nVous ne passeriez généralement pas ce dictionnaire manuellement,\nil est utilisé en interne par la fonction pour l'optimisation.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Ceci est une valeur supposée pour l'exemple ; le résultat réel peut différer.",
      "de": "Berechne die Anzahl der gültigen Sequenzen, die gemäß spezifischer Regeln gebildet werden können.\n\nJede Sequenz beginnt mit einer gegebenen Zahl 'n', und eine neue Zahl kann an die Sequenz angehängt werden, wenn sie eine positive ganze Zahl ist und nicht größer als die Hälfte der letzten Zahl in der Sequenz. Diese Funktion verwendet Memoisierung, um zuvor berechnete Ergebnisse zu speichern und die Leistung zu optimieren.\n\nArgs:\nn (int): Die Startzahl der Sequenz.\nlast (int): Die letzte Zahl in der aktuellen Sequenz.\nmemo (dict): Ein Wörterbuch, das für die Memoisierung verwendet wird und die Anzahl der gültigen Sequenzen für jeden aufgetretenen 'last'-Wert speichert.\n\nReturns:\nint: Die Gesamtanzahl der gültigen Sequenzen, die mit 'n' beginnen können.\n\nExamples:\nEs kann nur eine Sequenz gebildet werden, die mit 1 beginnt: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSechs Sequenzen können gebildet werden, die mit 6 beginnen:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nKomplexeres Beispiel mit übergebenem Memoisierungs-Wörterbuch\nNormalerweise würde man dieses Wörterbuch nicht manuell übergeben,\nes wird intern von der Funktion zur Optimierung verwendet.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Dies ist ein angenommener Wert für das Beispiel; das tatsächliche Ergebnis kann abweichen.",
      "ha": "Ƙididdige adadin jerin sahihai da za a iya samarwa bisa ga wasu ka'idoji.\n\nKowane jeri yana farawa da wani lamba 'n', kuma za a iya ƙara sabon lamba zuwa jerin idan yana da lamba mai kyau kuma ba ya fi rabin lamba ta ƙarshe a cikin jerin ba. Wannan aikin yana amfani da memoization don adana sakamakon da aka riga aka lissafa don inganta aiki.\n\nArgs:\nn (int): Lambar farawa na jerin.\nlast (int): Lambar ƙarshe a cikin jerin yanzu.\nmemo (dict): Kamus da aka yi amfani da shi don memoization, yana adana adadin jerin sahihai don kowane ƙimar 'last' da aka haɗu da shi.\n\nReturns:\nint: Jimlar adadin jerin sahihai da za a iya samarwa farawa da 'n'.\n\nMisalai:\nJerin guda ɗaya kawai za a iya samarwa farawa da 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nJerin guda shida za a iya samarwa farawa da 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMisali mai rikitarwa tare da kamus na memoization da aka wuce\nYawanci ba za ku wuce wannan kamus ɗin da hannu ba,\nana amfani da shi a cikin aikin don ingantawa.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Wannan wata ƙima ce da aka ɗauka don misali; sakamakon ainihi na iya bambanta.",
      "hi": "विशिष्ट नियमों के अनुसार बनने वाले मान्य अनुक्रमों की संख्या की गणना करें।\n\nप्रत्येक अनुक्रम एक दिए गए संख्या 'n' से शुरू होता है, और एक नई संख्या अनुक्रम में जोड़ी जा सकती है\nयदि यह एक धनात्मक पूर्णांक है और अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं है। यह\nकार्य प्रदर्शन को अनुकूलित करने के लिए पहले से गणना किए गए परिणामों को संग्रहीत करने के लिए स्मृति-संवर्धन का उपयोग करता है।\n\nआर्ग्स:\nn (int): अनुक्रम की प्रारंभिक संख्या।\nlast (int): वर्तमान अनुक्रम में अंतिम संख्या।\nmemo (dict): स्मृति-संवर्धन के लिए उपयोग किया जाने वाला एक शब्दकोश, प्रत्येक 'last' मान के लिए मान्य अनुक्रमों की संख्या संग्रहीत करता है।\n\nरिटर्न्स:\nint: कुल मान्य अनुक्रमों की संख्या जो 'n' से शुरू होकर बनाई जा सकती है।\n\nउदाहरण:\nकेवल एक अनुक्रम 1 से शुरू होकर बनाया जा सकता है: [1]\n>>> count_sequences(1, 1, {})\n1\n\nछह अनुक्रम 6 से शुरू होकर बनाए जा सकते हैं:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nस्मृति-संवर्धन शब्दकोश के साथ अधिक जटिल उदाहरण\nआप आमतौर पर इस शब्दकोश को मैन्युअल रूप से पास नहीं करेंगे,\nयह कार्य द्वारा आंतरिक रूप से अनुकूलन के लिए उपयोग किया जाता है।\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # यह उदाहरण के लिए एक अनुमानित मान है; वास्तविक परिणाम भिन्न हो सकता है।",
      "hu": "Számolja ki az érvényes sorozatok számát, amelyek meghatározott szabályok szerint képezhetők.\n\nMinden sorozat egy adott 'n' számmal kezdődik, és egy új szám fűzhető a sorozathoz, ha pozitív egész szám, és nem nagyobb, mint a sorozat utolsó számának a fele. Ez a függvény memoizációt használ a korábban kiszámított eredmények tárolására a teljesítmény optimalizálása érdekében.\n\nArgs:\nn (int): A sorozat kezdő száma.\nlast (int): Az aktuális sorozat utolsó száma.\nmemo (dict): Egy szótár, amelyet memoizációra használnak, tárolva az érvényes sorozatok számát minden előforduló 'last' értékre.\n\nReturns:\nint: Az összes érvényes sorozat száma, amely 'n'-nel kezdődik.\n\nPéldák:\nCsak egy sorozat képezhető, amely 1-gyel kezdődik: [1]\n>>> count_sequences(1, 1, {})\n1\n\nHat sorozat képezhető, amely 6-tal kezdődik:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nÖsszetettebb példa memoizációs szótárral\nÁltalában nem adja meg ezt a szótárt manuálisan, a függvény belsőleg használja az optimalizáláshoz.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Ez egy feltételezett érték a példához; a tényleges eredmény eltérhet."
    },
    "docstring_bertscore": {
      "sq": "0.9810284150465958",
      "hy": "0.9689119618034676",
      "bn": "0.9754606068358068",
      "bg": "0.9645067372128758",
      "zh": "0.9756967783588573",
      "fr": "0.99119789329482",
      "de": "0.9847223442427016",
      "ha": "0.9591949635632409",
      "hi": "0.959184038892284",
      "hu": "0.9639021063330057"
    }
  },
  {
    "task_id": "Python/26",
    "prompt": {
      "en": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    Case 1: count_coprime_pairs(3, 60)\n    Explanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\n    Case 2: count_coprime_pairs(2, 50)\n    Explanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\n    Case 3: count_coprime_pairs(6, 180)\n    Explanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\n    Note:\n    For the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0, \n    indicating no valid pairs exist under the given constraints.\n    \"\"\"",
      "sq": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si përbashkuesin më të madh (GCD)\n    dhe y0 si shumëfishin më të vogël të përbashkët (LCM).\n\n    Argumentet:\n    x0 (int): GCD që çdo çift (P, Q) duhet të ketë.\n    y0 (int): LCM që çdo çift (P, Q) duhet të ketë.\n\n    Kthen:\n    int: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\n    Funksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\n    llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Pastaj kontrollon nëse 'a' dhe 'b'\n    janë bashkë-kryesorë (GCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfishë të 'x0' nga faktorë bashkë-kryesorë për të ruajtur\n    GCD si 'x0'. Nëse 'a' dhe 'b' janë bashkë-kryesorë, numri rritet me 1 nëse 'a' është i njëjtë me 'b',\n    përndryshe me 2 për të llogaritur të dy çiftet (P, Q) dhe (Q, P).\n\n    Shembuj Rastesh:\n\n    Rasti 1: count_coprime_pairs(3, 60)\n    Shpjegim: Funksioni do të kthejë 4, pasi çiftet e vlefshme janë (3, 60), (15, 12), (12, 15), dhe (60, 3).\n\n    Rasti 2: count_coprime_pairs(2, 50)\n    Shpjegim: Funksioni do të kthejë 0, pasi 50 nuk është shumëfish i 2, kështu që nuk ka çifte të vlefshme (P, Q).\n\n    Rasti 3: count_coprime_pairs(6, 180)\n    Shpjegim: Funksioni do të kthejë 8, çiftet e vlefshme janë (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), dhe numërimet për rregullimet e tjera të këtyre numrave.\n\n    Shënim:\n    Për që funksioni të punojë saktë, hyrja y0 duhet të jetë shumëfish i x0. Nëse jo, funksioni kthen 0,\n    duke treguar se nuk ekzistojnë çifte të vlefshme nën kufizimet e dhëna.\n    \"\"\"",
      "hy": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Հաշվում է դրական ամբողջ թվերի (P, Q) զույգերի քանակը, այնպես որ P և Q թվերի ամենամեծ ընդհանուր բաժանարարը (GCD) լինի x0,\n    իսկ ամենափոքր ընդհանուր բազմապատիկը (LCM) լինի y0:\n\n    Արձանագրություններ:\n    x0 (int): GCD, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q):\n    y0 (int): LCM, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q):\n\n    Վերադարձնում է:\n    int: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին:\n\n    Ֆունկցիան անցնում է 'y0 / x0' բաժանարարի բոլոր հնարավոր գործոններով 'a':ի միջոցով: Յուրաքանչյուր գործոնի համար 'a',\n    հաշվարկում է համապատասխան գործոնը 'b', այնպես որ 'a * b = y0 / x0':ի: Այնուհետև ստուգում է՝ արդյոք 'a' և 'b'\n    փոխադարձաբար պարզ են (նրանց GCD-ն 1 է), քանի որ P և Q կարող են լինել միայն 'x0'-ի բազմապատիկներ՝ փոխադարձաբար պարզ գործոններով,\n    որպեսզի պահպանվի GCD-ն որպես 'x0':ի: Եթե 'a' և 'b' փոխադարձաբար պարզ են, հաշվարկը մեծանում է 1-ով, եթե 'a' նույնն է 'b'-ի հետ,\n    այլապես 2-ով՝ հաշվի առնելով (P, Q) և (Q, P) զույգերը:\n\n    Օրինակային դեպքեր:\n\n    Դեպք 1: count_coprime_pairs(3, 60)\n    Բացատրություն: Ֆունկցիան կվերադարձնի 4, քանի որ վավեր զույգերն են (3, 60), (15, 12), (12, 15) և (60, 3):\n\n    Դեպք 2: count_coprime_pairs(2, 50)\n    Բացատրություն: Ֆունկցիան կվերադարձնի 0, քանի որ 50-ը 2-ի բազմապատիկ չէ, ուստի վավեր զույգեր (P, Q) չկան:\n\n    Դեպք 3: count_coprime_pairs(6, 180)\n    Բացատրություն: Ֆունկցիան կվերադարձնի 8, վավեր զույգերն են (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), և այս թվերի այլ դասավորությունների հաշվարկները:\n\n    Նշում:\n    Որպեսզի ֆունկցիան ճիշտ աշխատի, մուտքային y0-ը պետք է լինի x0-ի բազմապատիկ: Եթե ոչ, ֆունկցիան վերադարձնում է 0,\n    ցույց տալով, որ վավեր զույգեր չկան տրված սահմանափակումների ներքո:\n    \"\"\"",
      "bn": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    কতগুলি যুগল ধনাত্মক পূর্ণসংখ্যা (P, Q) আছে তা গণনা করে যেখানে P এবং Q এর x0 তাদের গরিষ্ঠ সাধারণ বিভাজক (GCD)\n    এবং y0 তাদের লঘিষ্ঠ সাধারণ গুণিতক (LCM)।\n\n    Args:\n    x0 (int): GCD যা প্রতিটি যুগল (P, Q) এর থাকতে হবে।\n    y0 (int): LCM যা প্রতিটি যুগল (P, Q) এর থাকতে হবে।\n\n    Returns:\n    int: সমস্ত সম্ভাব্য যুগল (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\n    ফাংশনটি 'y0 / x0' এর সমস্ত সম্ভাব্য গুণক 'a' এর মধ্য দিয়ে পুনরাবৃত্তি করে। প্রতিটি গুণক 'a' এর জন্য,\n    এটি সংশ্লিষ্ট গুণক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে 'a' এবং 'b'\n    সহমৌলিক কিনা (তাদের GCD হল 1) কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমৌলিক গুণক দ্বারা\n    GCD কে 'x0' হিসাবে বজায় রাখতে। যদি 'a' এবং 'b' সহমৌলিক হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি পায় যদি 'a' এবং 'b' একই হয়,\n    অন্যথায় 2 দ্বারা বৃদ্ধি পায় যাতে উভয় (P, Q) এবং (Q, P) যুগলগুলি অন্তর্ভুক্ত হয়।\n\n    উদাহরণ কেসসমূহ:\n\n    কেস 1: count_coprime_pairs(3, 60)\n    ব্যাখ্যা: ফাংশনটি 4 ফেরত দেবে, কারণ বৈধ যুগলগুলি হল (3, 60), (15, 12), (12, 15), এবং (60, 3)।\n\n    কেস 2: count_coprime_pairs(2, 50)\n    ব্যাখ্যা: ফাংশনটি 0 ফেরত দেবে, কারণ 50 হল 2 এর গুণিতক নয়, তাই কোন বৈধ যুগল (P, Q) নেই।\n\n    কেস 3: count_coprime_pairs(6, 180)\n    ব্যাখ্যা: ফাংশনটি 8 ফেরত দেবে, বৈধ যুগলগুলি হল (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), এবং এই সংখ্যাগুলির অন্যান্য বিন্যাসের জন্য গণনা।\n\n    নোট:\n    ফাংশনটি সঠিকভাবে কাজ করার জন্য, ইনপুট y0 অবশ্যই x0 এর গুণিতক হতে হবে। যদি না হয়, ফাংশনটি 0 ফেরত দেয়,\n    যা নির্দেশ করে যে প্রদত্ত সীমাবদ্ধতার অধীনে কোন বৈধ যুগল নেই।\n    \"\"\"",
      "bg": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\n    и y0 като тяхно най-малко общо кратно (НОК).\n\n    Args:\n    x0 (int): НОД, който всяка двойка (P, Q) трябва да има.\n    y0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\n    Returns:\n    int: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\n    Функцията преминава през всички възможни делители 'a' на частното 'y0 / x0'. За всеки делител 'a',\n    тя изчислява съответния делител 'b', такъв че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\n    са взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости делители,\n    за да се запази НОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\n    иначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\n    Примерни случаи:\n\n    Случай 1: count_coprime_pairs(3, 60)\n    Обяснение: Функцията ще върне 4, тъй като валидните двойки са (3, 60), (15, 12), (12, 15) и (60, 3).\n\n    Случай 2: count_coprime_pairs(2, 50)\n    Обяснение: Функцията ще върне 0, тъй като 50 не е кратно на 2, така че няма валидни двойки (P, Q).\n\n    Случай 3: count_coprime_pairs(6, 180)\n    Обяснение: Функцията ще върне 8, валидните двойки са (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6) и броят на другите подреждания на тези числа.\n\n    Забележка:\n    За да работи функцията правилно, входът y0 трябва да бъде кратен на x0. Ако не е, функцията връща 0,\n    което показва, че няма валидни двойки при дадените ограничения.\n    \"\"\"",
      "zh": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n    参数:\n    x0 (int): 每对 (P, Q) 必须具有的 GCD。\n    y0 (int): 每对 (P, Q) 必须具有的 LCM。\n\n    返回:\n    int: 满足指定条件的所有可能对 (P, Q) 的数量。\n\n    该函数遍历商 'y0 / x0' 的所有可能因子 'a'。对于每个因子 'a'，计算对应的因子 'b' 使得 'a * b = y0 / x0'。\n    然后检查 'a' 和 'b' 是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的倍数，通过互质因子来保持\n    GCD 为 'x0'。如果 'a' 和 'b' 互质，则如果 'a' 等于 'b'，计数增加 1，否则增加 2，以考虑 (P, Q) 和 (Q, P) 对。\n\n    示例案例:\n\n    案例 1: count_coprime_pairs(3, 60)\n    解释: 函数将返回 4，因为有效的对是 (3, 60), (15, 12), (12, 15), 和 (60, 3)。\n\n    案例 2: count_coprime_pairs(2, 50)\n    解释: 函数将返回 0，因为 50 不是 2 的倍数，因此没有有效的对 (P, Q)。\n\n    案例 3: count_coprime_pairs(6, 180)\n    解释: 函数将返回 8，有效的对是 (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6)，以及这些数字的其他排列的计数。\n\n    注意:\n    为了函数正确工作，输入 y0 必须是 x0 的倍数。如果不是，函数返回 0，表示在给定约束下不存在有效对。\n    \"\"\"",
      "fr": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Compte le nombre de paires d'entiers positifs (P, Q) tels que P et Q ont x0 comme leur plus grand commun diviseur (PGCD)\n    et y0 comme leur plus petit commun multiple (PPCM).\n\n    Args:\n    x0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\n    y0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\n    Returns:\n    int: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\n    La fonction parcourt tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\n    elle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\n    sont copremiers (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs copremiers pour maintenir\n    le PGCD comme 'x0'. Si 'a' et 'b' sont copremiers, le compte est incrémenté de 1 si 'a' est le même que 'b',\n    sinon de 2 pour tenir compte des paires (P, Q) et (Q, P).\n\n    Cas d'exemple:\n\n    Cas 1: count_coprime_pairs(3, 60)\n    Explication: La fonction retournerait 4, puisque les paires valides sont (3, 60), (15, 12), (12, 15), et (60, 3).\n\n    Cas 2: count_coprime_pairs(2, 50)\n    Explication: La fonction retournerait 0, car 50 n'est pas un multiple de 2, donc il n'y a pas de paires valides (P, Q).\n\n    Cas 3: count_coprime_pairs(6, 180)\n    Explication: La fonction retournerait 8, les paires valides sont (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), et les comptes pour d'autres arrangements de ces nombres.\n\n    Remarque:\n    Pour que la fonction fonctionne correctement, l'entrée y0 doit être un multiple de x0. Sinon, la fonction retourne 0,\n    indiquant qu'aucune paire valide n'existe sous les contraintes données.\n    \"\"\"",
      "de": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Zählt die Anzahl der Paare positiver ganzer Zahlen (P, Q), sodass P und Q x0 als ihren größten gemeinsamen Teiler (GCD)\n    und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\n    Args:\n    x0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\n    y0 (int): Der LCM, den jedes Paar (P, Q) haben muss.\n\n    Returns:\n    int: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\n    Die Funktion iteriert durch alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a'\n    berechnet sie den entsprechenden Faktor 'b', sodass 'a * b = y0 / x0'. Sie prüft dann, ob 'a' und 'b'\n    teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können, um\n    den GCD als 'x0' beizubehalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a' gleich 'b' ist,\n    andernfalls um 2, um sowohl (P, Q) als auch (Q, P) Paare zu berücksichtigen.\n\n    Beispiel Fälle:\n\n    Fall 1: count_coprime_pairs(3, 60)\n    Erklärung: Die Funktion würde 4 zurückgeben, da die gültigen Paare (3, 60), (15, 12), (12, 15) und (60, 3) sind.\n\n    Fall 2: count_coprime_pairs(2, 50)\n    Erklärung: Die Funktion würde 0 zurückgeben, da 50 kein Vielfaches von 2 ist, also gibt es keine gültigen Paare (P, Q).\n\n    Fall 3: count_coprime_pairs(6, 180)\n    Erklärung: Die Funktion würde 8 zurückgeben, die gültigen Paare sind (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), und die Zählungen für andere Anordnungen dieser Zahlen.\n\n    Hinweis:\n    Damit die Funktion korrekt funktioniert, muss die Eingabe y0 ein Vielfaches von x0 sein. Wenn nicht, gibt die Funktion 0 zurück,\n    was anzeigt, dass unter den gegebenen Bedingungen keine gültigen Paare existieren.\n    \"\"\"",
      "ha": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Yana ƙididdige yawan ma'aurata na lambobi masu kyau (P, Q) ta yadda P da Q suna da x0 a matsayin mafi girman abin da za a iya raba su (GCD)\n    kuma y0 a matsayin mafi ƙarancin abin da za su iya raba su (LCM).\n\n    Args:\n    x0 (int): GCD wanda kowanne ma'aurata (P, Q) dole ne ya kasance da shi.\n    y0 (int): LCM wanda kowanne ma'aurata (P, Q) dole ne ya kasance da shi.\n\n    Returns:\n    int: Yawan duk ma'aurata masu yiwuwa (P, Q) waɗanda suka cika ƙa'idodin da aka fayyace.\n\n    Aikin yana zagayawa ta dukkan abubuwan da za su iya zama 'a' na rabo 'y0 / x0'. Ga kowane abu 'a',\n    yana ƙididdige abin da ya dace 'b' ta yadda 'a * b = y0 / x0'. Sannan yana duba idan 'a' da 'b'\n    suna da juna (GCD ɗin su 1 ne) domin P da Q za su iya zama sau na 'x0' ta abubuwan da ba su da juna don kiyaye\n    GCD a matsayin 'x0'. Idan 'a' da 'b' suna da juna, ana ƙara yawan da 1 idan 'a' daidai yake da 'b',\n    in ba haka ba da 2 don lissafin duka ma'aurata (P, Q) da (Q, P).\n\n    Misalan Hali:\n\n    Hali 1: count_coprime_pairs(3, 60)\n    Bayani: Aikin zai dawo da 4, tunda ma'auratan da suka dace sune (3, 60), (15, 12), (12, 15), da (60, 3).\n\n    Hali 2: count_coprime_pairs(2, 50)\n    Bayani: Aikin zai dawo da 0, domin 50 ba sau na 2 bane, don haka babu ma'aurata masu dacewa (P, Q).\n\n    Hali 3: count_coprime_pairs(6, 180)\n    Bayani: Aikin zai dawo da 8, ma'auratan da suka dace sune (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), da ƙididdigar sauran tsarukan waɗannan lambobin.\n\n    Lura:\n    Domin aikin ya yi aiki daidai, shigar y0 dole ne ya zama sau na x0. Idan ba haka ba, aikin yana dawo da 0,\n    yana nuna babu ma'aurata masu dacewa a ƙarƙashin ƙa'idodin da aka bayar.\n    \"\"\"",
      "hi": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    उन युग्मों (P, Q) की संख्या गिनता है जिनके लिए P और Q का x0 उनका महत्तम समापवर्तक (GCD) है\n    और y0 उनका लघुत्तम समापवर्त्य (LCM) है।\n\n    तर्क:\n    x0 (int): वह GCD जो प्रत्येक युग्म (P, Q) का होना चाहिए।\n    y0 (int): वह LCM जो प्रत्येक युग्म (P, Q) का होना चाहिए।\n\n    लौटाता है:\n    int: सभी संभावित युग्मों (P, Q) की गिनती जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\n    यह फ़ंक्शन 'y0 / x0' के भाजक 'a' के सभी संभावित कारकों के माध्यम से पुनरावृत्ति करता है। प्रत्येक कारक 'a' के लिए,\n    यह संबंधित कारक 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\n    सह-प्राइम हैं (उनका GCD 1 है) क्योंकि P और Q केवल 'x0' के गुणज सह-प्राइम कारकों द्वारा हो सकते हैं ताकि\n    GCD 'x0' बना रहे। यदि 'a' और 'b' सह-प्राइम हैं, तो गिनती को 1 से बढ़ाया जाता है यदि 'a' 'b' के समान है,\n    अन्यथा 2 से बढ़ाया जाता है ताकि (P, Q) और (Q, P) दोनों युग्मों को शामिल किया जा सके।\n\n    उदाहरण मामले:\n\n    मामला 1: count_coprime_pairs(3, 60)\n    व्याख्या: फ़ंक्शन 4 लौटाएगा, क्योंकि मान्य युग्म हैं (3, 60), (15, 12), (12, 15), और (60, 3)।\n\n    मामला 2: count_coprime_pairs(2, 50)\n    व्याख्या: फ़ंक्शन 0 लौटाएगा, क्योंकि 50, 2 का गुणज नहीं है, इसलिए कोई मान्य युग्म (P, Q) नहीं हैं।\n\n    मामला 3: count_coprime_pairs(6, 180)\n    व्याख्या: फ़ंक्शन 8 लौटाएगा, मान्य युग्म हैं (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), और इन संख्याओं के अन्य व्यवस्थाओं के लिए गिनती।\n\n    नोट:\n    फ़ंक्शन के सही ढंग से काम करने के लिए, इनपुट y0 को x0 का गुणज होना चाहिए। यदि नहीं, तो फ़ंक्शन 0 लौटाता है,\n    यह दर्शाता है कि दिए गए प्रतिबंधों के तहत कोई मान्य युग्म मौजूद नहीं है।\n    \"\"\"",
      "hu": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Megszámolja azon pozitív egész számokból álló (P, Q) párok számát, amelyekre P és Q legnagyobb közös osztója (GCD) x0,\n    és legkisebb közös többszöröse (LCM) y0.\n\n    Args:\n    x0 (int): Az a GCD, amelyet minden (P, Q) párnak tartalmaznia kell.\n    y0 (int): Az az LCM, amelyet minden (P, Q) párnak tartalmaznia kell.\n\n    Returns:\n    int: Az összes lehetséges (P, Q) pár száma, amelyek megfelelnek a megadott kritériumoknak.\n\n    A függvény végigmegy az összes lehetséges 'a' tényezőn, amely a 'y0 / x0' hányados tényezője. Minden 'a' tényezőhöz\n    kiszámítja a megfelelő 'b' tényezőt úgy, hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b' relatív prímek-e\n    (GCD-jük 1), mert P és Q csak akkor lehetnek 'x0' többszörösei relatív prím tényezők által, hogy a GCD 'x0' maradjon.\n    Ha 'a' és 'b' relatív prímek, a számláló 1-gyel növekszik, ha 'a' megegyezik 'b'-vel, különben 2-vel, hogy figyelembe\n    vegye mind a (P, Q), mind a (Q, P) párokat.\n\n    Példa esetek:\n\n    Eset 1: count_coprime_pairs(3, 60)\n    Magyarázat: A függvény 4-et ad vissza, mivel az érvényes párok: (3, 60), (15, 12), (12, 15) és (60, 3).\n\n    Eset 2: count_coprime_pairs(2, 50)\n    Magyarázat: A függvény 0-t ad vissza, mivel 50 nem többszöröse 2-nek, így nincsenek érvényes (P, Q) párok.\n\n    Eset 3: count_coprime_pairs(6, 180)\n    Magyarázat: A függvény 8-at ad vissza, az érvényes párok: (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), és a számok más elrendezéseinek száma.\n\n    Megjegyzés:\n    Ahhoz, hogy a függvény helyesen működjön, a bemeneti y0-nak x0 többszörösének kell lennie. Ha nem, a függvény 0-t ad vissza,\n    jelezve, hogy a megadott feltételek mellett nincsenek érvényes párok.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9746360921241309",
      "hy": "0.9549138829607959",
      "bn": "0.9654549986519364",
      "bg": "0.9598283958483611",
      "zh": "0.9538249912119626",
      "fr": "0.9840980489551089",
      "de": "0.9773319036555365",
      "ha": "0.9512702072510919",
      "hi": "0.9598567999928491",
      "hu": "0.9429328956375336"
    },
    "canonical_solution": "    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count",
    "instruction": {
      "en": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\n请用不超过500个字符的中文，为以下Python代码提供简明的自然语言描述（文档字符串）。",
      "fr": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nBada takaitaccen bayanin docstring na lambar Python a cikin harshen Hausa ba tare da wucewa haruffa 500 ba.",
      "hi": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8653907729676097",
      "bn": "0.8827651710271124",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.8478117856156411",
      "hi": "0.9109764454151166",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_count_coprime_pairs():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_coprime_pairs()",
    "entry_point": "count_coprime_pairs",
    "signature": "def count_coprime_pairs(x0: int, y0: int) -> int:",
    "docstring": {
      "en": "Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\nand y0 as their least common multiple (LCM).\n\nArgs:\nx0 (int): The GCD that each pair (P, Q) must have.\ny0 (int): The LCM that each pair (P, Q) must have.\n\nReturns:\nint: The count of all possible pairs (P, Q) that meet the specified criteria.\n\nThe function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\nit calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\nare co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\nthe GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\nelse by 2 to account for both (P, Q) and (Q, P) pairs.\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\nNote:\nFor the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0,\nindicating no valid pairs exist under the given constraints.",
      "sq": "Numëron numrin e çifteve të numrave të plotë pozitivë (P, Q) të tillë që P dhe Q kanë x0 si përbashkësin më të madh (GCD)\ndhe y0 si shumëfishin më të vogël të përbashkët (LCM).\n\nArgs:\nx0 (int): GCD që çdo çift (P, Q) duhet të ketë.\ny0 (int): LCM që çdo çift (P, Q) duhet të ketë.\n\nReturns:\nint: Numri i të gjitha çifteve të mundshme (P, Q) që plotësojnë kriteret e specifikuara.\n\nFunksioni iteron nëpër të gjithë faktorët e mundshëm 'a' të kuotientit 'y0 / x0'. Për çdo faktor 'a',\nai llogarit faktorin përkatës 'b' të tillë që 'a * b = y0 / x0'. Më pas kontrollon nëse 'a' dhe 'b'\njanë të bashkëkryqëzuar (GCD i tyre është 1) sepse P dhe Q mund të jenë vetëm shumëfishë të 'x0' nga faktorë të bashkëkryqëzuar për të ruajtur\nGCD si 'x0'. Nëse 'a' dhe 'b' janë të bashkëkryqëzuar, numërimi rritet me 1 nëse 'a' është i njëjtë me 'b',\npërndryshe me 2 për të llogaritur të dyja çiftet (P, Q) dhe (Q, P).\n\nRaste Shembuj:\n\nRasti 1: count_coprime_pairs(3, 60)\nShpjegim: Funksioni do të kthejë 4, pasi çiftet e vlefshme janë (3, 60), (15, 12), (12, 15), dhe (60, 3).\n\nRasti 2: count_coprime_pairs(2, 50)\nShpjegim: Funksioni do të kthejë 0, pasi 50 nuk është një shumëfish i 2, kështu që nuk ka çifte të vlefshme (P, Q).\n\nRasti 3: count_coprime_pairs(6, 180)\nShpjegim: Funksioni do të kthejë 8, çiftet e vlefshme janë (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), dhe numërimet për rregullimet e tjera të këtyre numrave.\n\nShënim:\nQë funksioni të funksionojë saktë, hyrja y0 duhet të jetë një shumëfish i x0. Nëse jo, funksioni kthen 0,\nduke treguar se nuk ka çifte të vlefshme nën kufizimet e dhëna.",
      "hy": "Հաշվում է դրական ամբողջ թվերի զույգերի (P, Q) քանակը, այնպես որ P և Q թվերի ամենամեծ ընդհանուր բաժանարարը (GCD) լինի x0,\nիսկ ամենափոքր ընդհանուր բազմապատիկը (LCM) լինի y0։\n\nԱրգումենտներ:\nx0 (int): GCD, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q)։\ny0 (int): LCM, որը պետք է ունենա յուրաքանչյուր զույգ (P, Q)։\n\nՎերադարձնում է:\nint: Բոլոր հնարավոր զույգերի (P, Q) քանակը, որոնք համապատասխանում են նշված չափանիշներին։\n\nՖունկցիան անցնում է 'y0 / x0' բաժանորդի բոլոր հնարավոր գործոնների 'a' միջով։ Յուրաքանչյուր գործոնի 'a' համար\nհաշվում է համապատասխան գործոնը 'b', այնպես որ 'a * b = y0 / x0'։ Այնուհետև ստուգվում է՝ արդյոք 'a' և 'b'\nփոխադարձաբար պարզ են (նրանց GCD-ն 1 է), քանի որ P և Q կարող են միայն լինել 'x0'-ի բազմապատիկներ՝ փոխադարձաբար պարզ գործոններով՝\nպահպանելու համար GCD-ն որպես 'x0'։ Եթե 'a' և 'b' փոխադարձաբար պարզ են, հաշվումը ավելանում է 1-ով, եթե 'a' նույնն է 'b'-ի հետ,\nհակառակ դեպքում՝ 2-ով՝ հաշվի առնելով ինչպես (P, Q), այնպես էլ (Q, P) զույգերը։\n\nՕրինակային դեպքեր:\n\nԴեպք 1: count_coprime_pairs(3, 60)\nԲացատրություն: Ֆունկցիան կվերադարձնի 4, քանի որ վավեր զույգերն են (3, 60), (15, 12), (12, 15) և (60, 3)։\n\nԴեպք 2: count_coprime_pairs(2, 50)\nԲացատրություն: Ֆունկցիան կվերադարձնի 0, քանի որ 50-ը 2-ի բազմապատիկ չէ, ուստի վավեր զույգեր (P, Q) չկան։\n\nԴեպք 3: count_coprime_pairs(6, 180)\nԲացատրություն: Ֆունկցիան կվերադարձնի 8, վավեր զույգերն են (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), և այս թվերի այլ դասավորությունների հաշիվները։\n\nՆշում:\nՖունկցիան ճիշտ աշխատելու համար, մուտքային y0-ն պետք է լինի x0-ի բազմապատիկ։ Եթե ոչ, ֆունկցիան վերադարձնում է 0,\nնշելով, որ վավեր զույգեր չկան տրված սահմանափակումների ներքո։",
      "bn": "কতগুলি যুগল ধনাত্মক পূর্ণসংখ্যা (P, Q) আছে তা গণনা করে যেখানে P এবং Q এর x0 তাদের গরিষ্ঠ সাধারণ বিভাজক (GCD)\nএবং y0 তাদের লঘিষ্ঠ সাধারণ গুণিতক (LCM)।\n\nArgs:\nx0 (int): প্রতিটি জোড়া (P, Q) এর GCD যা থাকতে হবে।\ny0 (int): প্রতিটি জোড়া (P, Q) এর LCM যা থাকতে হবে।\n\nReturns:\nint: সমস্ত সম্ভাব্য জোড়া (P, Q) এর সংখ্যা যা নির্দিষ্ট মানদণ্ড পূরণ করে।\n\nফাংশনটি 'y0 / x0' এর ভাগফল এর সমস্ত সম্ভাব্য গুণক 'a' এর মধ্য দিয়ে পুনরাবৃত্তি করে। প্রতিটি গুণকের জন্য 'a', এটি সংশ্লিষ্ট গুণক 'b' গণনা করে যাতে 'a * b = y0 / x0' হয়। তারপর এটি পরীক্ষা করে যে 'a' এবং 'b' পরস্পর সহমর্মী কিনা (তাদের GCD হল 1) কারণ P এবং Q শুধুমাত্র 'x0' এর গুণিতক হতে পারে সহমর্মী গুণক দ্বারা GCD 'x0' বজায় রাখতে। যদি 'a' এবং 'b' পরস্পর সহমর্মী হয়, তাহলে গণনা 1 দ্বারা বৃদ্ধি পায় যদি 'a' এবং 'b' একই হয়, অন্যথায় 2 দ্বারা বৃদ্ধি পায় উভয় (P, Q) এবং (Q, P) জোড়ার জন্য।\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: ফাংশনটি 4 ফেরত দেবে, কারণ বৈধ জোড়াগুলি হল (3, 60), (15, 12), (12, 15), এবং (60, 3)।\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: ফাংশনটি 0 ফেরত দেবে, কারণ 50 হল 2 এর গুণিতক নয়, তাই কোন বৈধ জোড়া (P, Q) নেই।\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: ফাংশনটি 8 ফেরত দেবে, বৈধ জোড়াগুলি হল (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), এবং এই সংখ্যাগুলির অন্যান্য বিন্যাসের গণনা।\n\nNote:\nফাংশনটি সঠিকভাবে কাজ করার জন্য, ইনপুট y0 অবশ্যই x0 এর গুণিতক হতে হবে। যদি না হয়, ফাংশনটি 0 ফেরত দেয়, যা নির্দেশ করে যে প্রদত্ত সীমাবদ্ধতার অধীনে কোন বৈধ জোড়া নেই।",
      "bg": "Брои броя на двойките положителни цели числа (P, Q), такива че P и Q имат x0 като техен най-голям общ делител (НОД)\nи y0 като тяхно най-малко общо кратно (НОК).\n\nАргументи:\nx0 (int): НОД, който всяка двойка (P, Q) трябва да има.\ny0 (int): НОК, който всяка двойка (P, Q) трябва да има.\n\nВръща:\nint: Броят на всички възможни двойки (P, Q), които отговарят на зададените критерии.\n\nФункцията преминава през всички възможни делители 'a' на частното 'y0 / x0'. За всеки делител 'a',\nтя изчислява съответния делител 'b', така че 'a * b = y0 / x0'. След това проверява дали 'a' и 'b'\nса взаимно прости (техният НОД е 1), защото P и Q могат да бъдат само кратни на 'x0' чрез взаимно прости фактори, за да се запази\nНОД като 'x0'. Ако 'a' и 'b' са взаимно прости, броят се увеличава с 1, ако 'a' е същото като 'b',\nиначе с 2, за да се отчетат и двете двойки (P, Q) и (Q, P).\n\nПримерни случаи:\n\nСлучай 1: count_coprime_pairs(3, 60)\nОбяснение: Функцията ще върне 4, тъй като валидните двойки са (3, 60), (15, 12), (12, 15) и (60, 3).\n\nСлучай 2: count_coprime_pairs(2, 50)\nОбяснение: Функцията ще върне 0, тъй като 50 не е кратно на 2, така че няма валидни двойки (P, Q).\n\nСлучай 3: count_coprime_pairs(6, 180)\nОбяснение: Функцията ще върне 8, валидните двойки са (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), и броят за други подреждания на тези числа.\n\nЗабележка:\nЗа да работи функцията правилно, входът y0 трябва да бъде кратно на x0. Ако не е, функцията връща 0,\nкоето означава, че няма валидни двойки при дадените ограничения.",
      "zh": "计算正整数对 (P, Q) 的数量，使得 P 和 Q 的最大公约数 (GCD) 为 x0，最小公倍数 (LCM) 为 y0。\n\n参数：\nx0 (int): 每对 (P, Q) 必须具有的最大公约数。\ny0 (int): 每对 (P, Q) 必须具有的最小公倍数。\n\n返回：\nint: 满足指定条件的所有可能对 (P, Q) 的数量。\n\n该函数遍历商 'y0 / x0' 的所有可能因子 'a'。对于每个因子 'a'，计算相应的因子 'b'，使得 'a * b = y0 / x0'。然后检查 'a' 和 'b' 是否互质（它们的 GCD 为 1），因为 P 和 Q 只能是 'x0' 的倍数，通过互质因子来保持 GCD 为 'x0'。如果 'a' 和 'b' 互质，计数器增加 1 如果 'a' 和 'b' 相同，否则增加 2 以计入 (P, Q) 和 (Q, P) 对。\n\n示例案例：\n\n案例 1: count_coprime_pairs(3, 60)\n解释：函数将返回 4，因为有效的对是 (3, 60), (15, 12), (12, 15), 和 (60, 3)。\n\n案例 2: count_coprime_pairs(2, 50)\n解释：函数将返回 0，因为 50 不是 2 的倍数，因此没有有效的对 (P, Q)。\n\n案例 3: count_coprime_pairs(6, 180)\n解释：函数将返回 8，有效的对是 (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6)，以及这些数字的其他排列的计数。\n\n注意：\n为了函数正确工作，输入 y0 必须是 x0 的倍数。如果不是，函数返回 0，表示在给定约束条件下不存在有效对。",
      "fr": "Compte le nombre de paires d'entiers positifs (P, Q) tels que P et Q ont x0 comme leur plus grand commun diviseur (PGCD)\net y0 comme leur plus petit commun multiple (PPCM).\n\nArgs:\nx0 (int): Le PGCD que chaque paire (P, Q) doit avoir.\ny0 (int): Le PPCM que chaque paire (P, Q) doit avoir.\n\nReturns:\nint: Le nombre de toutes les paires possibles (P, Q) qui répondent aux critères spécifiés.\n\nLa fonction parcourt tous les facteurs possibles 'a' du quotient 'y0 / x0'. Pour chaque facteur 'a',\nelle calcule le facteur correspondant 'b' tel que 'a * b = y0 / x0'. Elle vérifie ensuite si 'a' et 'b'\nsont copremiers (leur PGCD est 1) car P et Q ne peuvent être que des multiples de 'x0' par des facteurs copremiers pour maintenir\nle PGCD comme 'x0'. Si 'a' et 'b' sont copremiers, le compteur est incrémenté de 1 si 'a' est le même que 'b',\nsinon de 2 pour tenir compte à la fois des paires (P, Q) et (Q, P).\n\nExemples de cas :\n\nCas 1: count_coprime_pairs(3, 60)\nExplication : La fonction renverrait 4, puisque les paires valides sont (3, 60), (15, 12), (12, 15) et (60, 3).\n\nCas 2: count_coprime_pairs(2, 50)\nExplication : La fonction renverrait 0, car 50 n'est pas un multiple de 2, donc il n'y a pas de paires valides (P, Q).\n\nCas 3: count_coprime_pairs(6, 180)\nExplication : La fonction renverrait 8, les paires valides sont (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), et les comptes pour d'autres arrangements de ces nombres.\n\nNote :\nPour que la fonction fonctionne correctement, l'entrée y0 doit être un multiple de x0. Sinon, la fonction renvoie 0,\nindiquant qu'aucune paire valide n'existe sous les contraintes données.",
      "de": "Zählt die Anzahl der Paare positiver ganzer Zahlen (P, Q), so dass P und Q x0 als ihren größten gemeinsamen Teiler (GCD) und y0 als ihr kleinstes gemeinsames Vielfaches (LCM) haben.\n\nArgs:\nx0 (int): Der GCD, den jedes Paar (P, Q) haben muss.\ny0 (int): Der LCM, den jedes Paar (P, Q) haben muss.\n\nReturns:\nint: Die Anzahl aller möglichen Paare (P, Q), die die angegebenen Kriterien erfüllen.\n\nDie Funktion iteriert über alle möglichen Faktoren 'a' des Quotienten 'y0 / x0'. Für jeden Faktor 'a' berechnet sie den entsprechenden Faktor 'b', so dass 'a * b = y0 / x0'. Sie überprüft dann, ob 'a' und 'b' teilerfremd sind (ihr GCD ist 1), da P und Q nur Vielfache von 'x0' durch teilerfremde Faktoren sein können, um den GCD als 'x0' beizubehalten. Wenn 'a' und 'b' teilerfremd sind, wird der Zähler um 1 erhöht, wenn 'a' gleich 'b' ist, andernfalls um 2, um sowohl die Paare (P, Q) als auch (Q, P) zu berücksichtigen.\n\nBeispiel Fälle:\n\nFall 1: count_coprime_pairs(3, 60)\nErklärung: Die Funktion würde 4 zurückgeben, da die gültigen Paare (3, 60), (15, 12), (12, 15) und (60, 3) sind.\n\nFall 2: count_coprime_pairs(2, 50)\nErklärung: Die Funktion würde 0 zurückgeben, da 50 kein Vielfaches von 2 ist, also gibt es keine gültigen Paare (P, Q).\n\nFall 3: count_coprime_pairs(6, 180)\nErklärung: Die Funktion würde 8 zurückgeben, die gültigen Paare sind (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6) und die Zählungen für andere Anordnungen dieser Zahlen.\n\nHinweis:\nDamit die Funktion korrekt funktioniert, muss die Eingabe y0 ein Vielfaches von x0 sein. Wenn nicht, gibt die Funktion 0 zurück, was anzeigt, dass unter den gegebenen Bedingungen keine gültigen Paare existieren.",
      "ha": "Yana ƙididdige yawan ma'aurata na lambobi masu kyau (P, Q) ta yadda P da Q suna da x0 a matsayin mafi girman abin da za a iya raba su (GCD)\nkuma y0 a matsayin mafi ƙarancin abin da za su iya raba su (LCM).\n\nArgs:\nx0 (int): GCD da kowanne ma'aurata (P, Q) dole su kasance da shi.\ny0 (int): LCM da kowanne ma'aurata (P, Q) dole su kasance da shi.\n\nReturns:\nint: Adadin dukkan ma'aurata masu yiwuwa (P, Q) da suka cika ka'idodin da aka bayyana.\n\nAikin yana zagayawa ta dukkan yiwuwar abubuwan da 'a' na rabo 'y0 / x0'. Ga kowane abu 'a', yana lissafin abu mai dacewa 'b' wanda 'a * b = y0 / x0'. Sannan yana duba idan 'a' da 'b' suna da alaƙa (GCD ɗinsu shine 1) saboda P da Q na iya zama sau biyu na 'x0' ta hanyar abubuwan da suke da alaƙa don kiyaye GCD a matsayin 'x0'. Idan 'a' da 'b' suna da alaƙa, ana ƙara ƙidaya da 1 idan 'a' daidai yake da 'b', in ba haka ba da 2 don lissafin duka ma'aurata (P, Q) da (Q, P).\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60) \nExplanation: Aikin zai dawo da 4, saboda ma'aurata masu inganci sune (3, 60), (15, 12), (12, 15), da (60, 3).\n\nCase 2: count_coprime_pairs(2, 50) \nExplanation: Aikin zai dawo da 0, saboda 50 ba sau biyu na 2 bane, don haka babu ma'aurata masu inganci (P, Q).\n\nCase 3: count_coprime_pairs(6, 180) \nExplanation: Aikin zai dawo da 8, ma'aurata masu inganci sune (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), da ƙidaya don sauran shirye-shiryen waɗannan lambobin.\n\nNote:\nDon aikin ya yi aiki daidai, shigar y0 dole ne ya zama sau biyu na x0. Idan ba haka ba, aikin yana dawowa da 0, yana nuna babu ma'aurata masu inganci da ke akwai ƙarƙashin ƙuntatawar da aka bayar.",
      "hi": "सकारात्मक पूर्णांकों के युग्मों (P, Q) की संख्या गिनता है ताकि P और Q का x0 उनके महत्तम समापवर्तक (GCD) के रूप में हो\nऔर y0 उनके लघुत्तम समापवर्त्य (LCM) के रूप में हो।\n\nआर्ग्स:\nx0 (int): वह GCD जो प्रत्येक युग्म (P, Q) का होना चाहिए।\ny0 (int): वह LCM जो प्रत्येक युग्म (P, Q) का होना चाहिए।\n\nवापसी:\nint: सभी संभावित युग्मों (P, Q) की गणना जो निर्दिष्ट मानदंडों को पूरा करते हैं।\n\nयह फ़ंक्शन 'y0 / x0' के भाजक 'a' के सभी संभावित कारकों के माध्यम से पुनरावृत्ति करता है। प्रत्येक कारक 'a' के लिए,\nयह संबंधित कारक 'b' की गणना करता है ताकि 'a * b = y0 / x0' हो। फिर यह जांचता है कि 'a' और 'b'\nपरस्पर अभाज्य हैं (उनका GCD 1 है) क्योंकि P और Q केवल 'x0' के गुणज हो सकते हैं परस्पर अभाज्य कारकों द्वारा ताकि\nGCD 'x0' बना रहे। यदि 'a' और 'b' परस्पर अभाज्य हैं, तो गणना को 1 से बढ़ाया जाता है यदि 'a' 'b' के समान है,\nअन्यथा 2 से बढ़ाया जाता है ताकि (P, Q) और (Q, P) दोनों युग्मों के लिए खाता हो।\n\nउदाहरण मामले:\n\nमामला 1: count_coprime_pairs(3, 60)\nव्याख्या: फ़ंक्शन 4 लौटाएगा, क्योंकि मान्य युग्म हैं (3, 60), (15, 12), (12, 15), और (60, 3)।\n\nमामला 2: count_coprime_pairs(2, 50)\nव्याख्या: फ़ंक्शन 0 लौटाएगा, क्योंकि 50, 2 का गुणज नहीं है, इसलिए कोई मान्य युग्म (P, Q) नहीं हैं।\n\nमामला 3: count_coprime_pairs(6, 180)\nव्याख्या: फ़ंक्शन 8 लौटाएगा, मान्य युग्म हैं (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), और इन संख्याओं के अन्य व्यवस्थाओं की गणना।\n\nनोट:\nफ़ंक्शन के सही ढंग से काम करने के लिए, इनपुट y0 का x0 का गुणज होना आवश्यक है। यदि नहीं, तो फ़ंक्शन 0 लौटाता है,\nयह दर्शाता है कि दिए गए प्रतिबंधों के तहत कोई मान्य युग्म मौजूद नहीं हैं।",
      "hu": "Számolja meg a pozitív egész számok (P, Q) párosainak számát úgy, hogy P és Q legnagyobb közös osztója (GCD) x0, és legkisebb közös többszöröse (LCM) y0.\n\nArgs:\nx0 (int): A GCD, amelyet minden (P, Q) párnak tartalmaznia kell.\ny0 (int): Az LCM, amelyet minden (P, Q) párnak tartalmaznia kell.\n\nReturns:\nint: Az összes lehetséges (P, Q) pár száma, amely megfelel a megadott feltételeknek.\n\nA függvény végigmegy az összes lehetséges 'a' tényezőn a 'y0 / x0' hányadosban. Minden 'a' tényezőhöz kiszámítja a megfelelő 'b' tényezőt úgy, hogy 'a * b = y0 / x0'. Ezután ellenőrzi, hogy 'a' és 'b' relatív prímek-e (GCD-jük 1), mert P és Q csak akkor lehetnek 'x0' többszörösei relatív prím tényezők által, hogy a GCD 'x0' maradjon. Ha 'a' és 'b' relatív prímek, a számlálót 1-gyel növeli, ha 'a' megegyezik 'b'-vel, különben 2-vel, hogy figyelembe vegye mind a (P, Q), mind a (Q, P) párokat.\n\nPélda esetek:\n\nEset 1: count_coprime_pairs(3, 60)\nMagyarázat: A függvény 4-et adna vissza, mivel az érvényes párok: (3, 60), (15, 12), (12, 15) és (60, 3).\n\nEset 2: count_coprime_pairs(2, 50)\nMagyarázat: A függvény 0-t adna vissza, mivel 50 nem többszöröse 2-nek, így nincsenek érvényes (P, Q) párok.\n\nEset 3: count_coprime_pairs(6, 180)\nMagyarázat: A függvény 8-at adna vissza, az érvényes párok: (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), és a számítások más elrendezései ezekkel a számokkal.\n\nMegjegyzés:\nAhhoz, hogy a függvény helyesen működjön, a bemeneti y0-nak többszöröse kell lennie x0-nak. Ha nem, a függvény 0-t ad vissza, jelezve, hogy a megadott feltételek mellett nincsenek érvényes párok."
    },
    "docstring_bertscore": {
      "sq": "0.9686144134926773",
      "hy": "0.9559270965344548",
      "bn": "0.9625240087493856",
      "bg": "0.9620186930600328",
      "zh": "0.9457087552124961",
      "fr": "0.978165952625502",
      "de": "0.9730728710253864",
      "ha": "0.9657082523877558",
      "hi": "0.9675437957388993",
      "hu": "0.9436435951408764"
    }
  },
  {
    "task_id": "Python/27",
    "prompt": {
      "en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Cases:\n    - If both inorder and postorder traversals are empty, returns an empty string.\n    - If the tree consists of a single node, returns a string with that single node.\n    - For a larger tree, recursively finds the root from the postorder traversal,\n      splits the inorder traversal into left and right subtrees, and constructs\n      the preorder traversal by visiting the root followed by the left and right\n      subtrees.\n\n    Example:\n    - Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\n      will return the preorder traversal 'ABCD'.\n    - Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\n      will return the preorder traversal 'ABDEGCF'.\n    - Given a tree with a single node represented by the inorder and postorder traversal 'A',\n      the function will return 'A'.\n    \"\"\"",
      "sq": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Rikonstrukton pemën binare nga kalimet e saj inorder dhe postorder dhe\n    kthen kalimin preorder si një varg.\n\n    Args:\n    inorder (str): Kalimi inorder i pemës binare.\n    postorder (str): Kalimi postorder i pemës binare.\n\n    Returns:\n    str: Kalimi preorder i pemës binare.\n\n    Raste:\n    - Nëse të dy kalimet inorder dhe postorder janë bosh, kthen një varg bosh.\n    - Nëse pema përbëhet nga një nyje e vetme, kthen një varg me atë nyje të vetme.\n    - Për një pemë më të madhe, gjen në mënyrë rekursive rrënjën nga kalimi postorder,\n      ndan kalimin inorder në nënpema të majta dhe të djathta, dhe ndërton\n      kalimin preorder duke vizituar rrënjën ndjekur nga nënpema e majtë dhe e djathtë.\n\n    Shembull:\n    - Duke pasur kalimin inorder 'BADC' dhe kalimin postorder 'BDCA', funksioni\n      do të kthejë kalimin preorder 'ABCD'.\n    - Duke pasur kalimin inorder 'DBGEACF' dhe kalimin postorder 'DGEBFCA', funksioni\n      do të kthejë kalimin preorder 'ABDEGCF'.\n    - Duke pasur një pemë me një nyje të vetme të përfaqësuar nga kalimet inorder dhe postorder 'A',\n      funksioni do të kthejë 'A'.\n    \"\"\"",
      "hy": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Վերակառուցում է բինար ծառը նրա inorder և postorder անցումներից և\n    վերադարձնում է preorder անցումը որպես տող։\n\n    Արգումենտներ:\n    inorder (str): Բինար ծառի inorder անցումը։\n    postorder (str): Բինար ծառի postorder անցումը։\n\n    Վերադարձնում է:\n    str: Բինար ծառի preorder անցումը։\n\n    Դեպքեր:\n    - Եթե թե՛ inorder և թե՛ postorder անցումները դատարկ են, վերադարձնում է դատարկ տող։\n    - Եթե ծառը բաղկացած է մեկ հանգույցից, վերադարձնում է այդ մեկ հանգույցով տող։\n    - Ավելի մեծ ծառի համար, ռեկուրսիվ կերպով գտնում է արմատը postorder անցումից,\n      բաժանում է inorder անցումը ձախ և աջ ենթածառերի, և կառուցում է\n      preorder անցումը այցելելով արմատը, այնուհետև ձախ և աջ ենթածառերը։\n\n    Օրինակ:\n    - Տրված է inorder անցումը 'BADC' և postorder անցումը 'BDCA', ֆունկցիան\n      կվերադարձնի preorder անցումը 'ABCD'։\n    - Տրված է inorder անցումը 'DBGEACF' և postorder անցումը 'DGEBFCA', ֆունկցիան\n      կվերադարձնի preorder անցումը 'ABDEGCF'։\n    - Տրված է մեկ հանգույցով ծառ, որը ներկայացված է inorder և postorder անցումներով 'A',\n      ֆունկցիան կվերադարձնի 'A'։\n    \"\"\"",
      "bn": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে বাইনারি ট্রি পুনর্গঠন করে এবং\n    প্রিঅর্ডার ট্রাভার্সালকে একটি স্ট্রিং হিসেবে ফেরত দেয়।\n\n    Args:\n    inorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\n    postorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\n    Returns:\n    str: বাইনারি ট্রির প্রিঅর্ডার ট্রাভার্সাল।\n\n    কেসসমূহ:\n    - যদি ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল উভয়ই খালি হয়, তবে একটি খালি স্ট্রিং ফেরত দেয়।\n    - যদি ট্রি একটি একক নোড নিয়ে গঠিত হয়, তবে সেই একক নোড সহ একটি স্ট্রিং ফেরত দেয়।\n    - একটি বড় ট্রির জন্য, পোস্টঅর্ডার ট্রাভার্সাল থেকে রুট খুঁজে বের করে, ইনঅর্ডার ট্রাভার্সালকে বাম এবং ডান সাবট্রিতে ভাগ করে এবং\n      রুটের পর বাম এবং ডান সাবট্রি ভিজিট করে প্রিঅর্ডার ট্রাভার্সাল তৈরি করে।\n\n    উদাহরণ:\n    - ইনঅর্ডার ট্রাভার্সাল 'BADC' এবং পোস্টঅর্ডার ট্রাভার্সাল 'BDCA' দেওয়া হলে, ফাংশনটি\n      প্রিঅর্ডার ট্রাভার্সাল 'ABCD' ফেরত দেবে।\n    - ইনঅর্ডার ট্রাভার্সাল 'DBGEACF' এবং পোস্টঅর্ডার ট্রাভার্সাল 'DGEBFCA' দেওয়া হলে, ফাংশনটি\n      প্রিঅর্ডার ট্রাভার্সাল 'ABDEGCF' ফেরত দেবে।\n    - একটি একক নোডের ট্রি, যা ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল 'A' দ্বারা প্রতিনিধিত্ব করে,\n      ফাংশনটি 'A' ফেরত দেবে।\n    \"\"\"",
      "bg": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Възстановява бинарното дърво от неговите inorder и postorder обхождания и\n    връща preorder обхождането като низ.\n\n    Args:\n    inorder (str): Inorder обхождането на бинарното дърво.\n    postorder (str): Postorder обхождането на бинарното дърво.\n\n    Returns:\n    str: Preorder обхождането на бинарното дърво.\n\n    Случаи:\n    - Ако и двете inorder и postorder обхождания са празни, връща празен низ.\n    - Ако дървото се състои от един възел, връща низ с този единствен възел.\n    - За по-голямо дърво, рекурсивно намира корена от postorder обхождането,\n      разделя inorder обхождането на ляво и дясно поддърво и конструира\n      preorder обхождането, като посещава корена, последван от лявото и дясното\n      поддърво.\n\n    Пример:\n    - Дадено inorder обхождане 'BADC' и postorder обхождане 'BDCA', функцията\n      ще върне preorder обхождане 'ABCD'.\n    - Дадено inorder обхождане 'DBGEACF' и postorder обхождане 'DGEBFCA', функцията\n      ще върне preorder обхождане 'ABDEGCF'.\n    - Дадено дърво с един възел, представено от inorder и postorder обхождане 'A',\n      функцията ще върне 'A'.\n    \"\"\"",
      "zh": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    从中序遍历和后序遍历重建二叉树，并返回前序遍历作为字符串。\n\n    参数:\n    inorder (str): 二叉树的中序遍历。\n    postorder (str): 二叉树的后序遍历。\n\n    返回:\n    str: 二叉树的前序遍历。\n\n    情况:\n    - 如果中序和后序遍历都为空，返回一个空字符串。\n    - 如果树由单个节点组成，返回一个包含该单个节点的字符串。\n    - 对于较大的树，递归地从后序遍历中找到根节点，将中序遍历分成左子树和右子树，\n      并通过访问根节点然后访问左子树和右子树来构建前序遍历。\n\n    示例:\n    - 给定中序遍历 'BADC' 和后序遍历 'BDCA'，函数将返回前序遍历 'ABCD'。\n    - 给定中序遍历 'DBGEACF' 和后序遍历 'DGEBFCA'，函数将返回前序遍历 'ABDEGCF'。\n    - 给定一个由中序和后序遍历 'A' 表示的单节点树，函数将返回 'A'。\n    \"\"\"",
      "fr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstruit l'arbre binaire à partir de ses parcours inorder et postorder et\n    renvoie le parcours preorder sous forme de chaîne.\n\n    Args:\n    inorder (str): Le parcours inorder de l'arbre binaire.\n    postorder (str): Le parcours postorder de l'arbre binaire.\n\n    Returns:\n    str: Le parcours preorder de l'arbre binaire.\n\n    Cas:\n    - Si les parcours inorder et postorder sont vides, renvoie une chaîne vide.\n    - Si l'arbre consiste en un seul nœud, renvoie une chaîne avec ce seul nœud.\n    - Pour un arbre plus grand, trouve récursivement la racine à partir du parcours postorder,\n      divise le parcours inorder en sous-arbres gauche et droit, et construit\n      le parcours preorder en visitant la racine suivie des sous-arbres gauche et droit.\n\n    Exemple:\n    - Étant donné le parcours inorder 'BADC' et le parcours postorder 'BDCA', la fonction\n      renverra le parcours preorder 'ABCD'.\n    - Étant donné le parcours inorder 'DBGEACF' et le parcours postorder 'DGEBFCA', la fonction\n      renverra le parcours preorder 'ABDEGCF'.\n    - Étant donné un arbre avec un seul nœud représenté par le parcours inorder et postorder 'A',\n      la fonction renverra 'A'.\n    \"\"\"",
      "de": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Rekonstruiert den binären Baum aus seinen Inorder- und Postorder-Traversierungen und\n    gibt die Preorder-Traversierung als Zeichenkette zurück.\n\n    Argumente:\n    inorder (str): Die Inorder-Traversierung des binären Baums.\n    postorder (str): Die Postorder-Traversierung des binären Baums.\n\n    Rückgabewert:\n    str: Die Preorder-Traversierung des binären Baums.\n\n    Fälle:\n    - Wenn sowohl die Inorder- als auch die Postorder-Traversierungen leer sind, wird eine leere Zeichenkette zurückgegeben.\n    - Wenn der Baum aus einem einzelnen Knoten besteht, wird eine Zeichenkette mit diesem einzelnen Knoten zurückgegeben.\n    - Für einen größeren Baum wird rekursiv die Wurzel aus der Postorder-Traversierung gefunden,\n      die Inorder-Traversierung in linke und rechte Teilbäume aufgeteilt und die Preorder-Traversierung\n      durch Besuch der Wurzel gefolgt von den linken und rechten Teilbäumen konstruiert.\n\n    Beispiel:\n    - Gegeben die Inorder-Traversierung 'BADC' und die Postorder-Traversierung 'BDCA', wird die Funktion\n      die Preorder-Traversierung 'ABCD' zurückgeben.\n    - Gegeben die Inorder-Traversierung 'DBGEACF' und die Postorder-Traversierung 'DGEBFCA', wird die Funktion\n      die Preorder-Traversierung 'ABDEGCF' zurückgeben.\n    - Gegeben ein Baum mit einem einzelnen Knoten, dargestellt durch die Inorder- und Postorder-Traversierung 'A',\n      wird die Funktion 'A' zurückgeben.\n    \"\"\"",
      "ha": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Sake gina itacen binary daga jerin inorder da postorder kuma\n    ya dawo da jerin preorder a matsayin kirtani.\n\n    Args:\n    inorder (str): Jerin inorder na itacen binary.\n    postorder (str): Jerin postorder na itacen binary.\n\n    Returns:\n    str: Jerin preorder na itacen binary.\n\n    Lokuta:\n    - Idan duka jerin inorder da postorder babu komai, yana dawowa da kirtani mara komai.\n    - Idan itacen ya ƙunshi ƙwaya guda, yana dawowa da kirtani tare da wannan ƙwaya guda.\n    - Don babban itace, yana gano tushen daga jerin postorder,\n      ya raba jerin inorder zuwa rassan hagu da dama, kuma yana gina\n      jerin preorder ta hanyar ziyartar tushen sannan rassan hagu da dama.\n\n    Misali:\n    - An ba da jerin inorder 'BADC' da jerin postorder 'BDCA', aikin\n      zai dawo da jerin preorder 'ABCD'.\n    - An ba da jerin inorder 'DBGEACF' da jerin postorder 'DGEBFCA', aikin\n      zai dawo da jerin preorder 'ABDEGCF'.\n    - An ba da itace tare da ƙwaya guda da aka wakilta ta jerin inorder da postorder 'A',\n      aikin zai dawo da 'A'.\n    \"\"\"",
      "hi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    बाइनरी वृक्ष को उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से पुनर्निर्मित करता है और\n    प्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\n    तर्क:\n    inorder (str): बाइनरी वृक्ष का इनऑर्डर ट्रैवर्सल।\n    postorder (str): बाइनरी वृक्ष का पोस्टऑर्डर ट्रैवर्सल।\n\n    रिटर्न्स:\n    str: बाइनरी वृक्ष का प्रीऑर्डर ट्रैवर्सल।\n\n    मामले:\n    - यदि इनऑर्डर और पोस्टऑर्डर दोनों ट्रैवर्सल खाली हैं, तो एक खाली स्ट्रिंग लौटाता है।\n    - यदि वृक्ष एकल नोड से बना है, तो उस एकल नोड के साथ एक स्ट्रिंग लौटाता है।\n    - एक बड़े वृक्ष के लिए, पोस्टऑर्डर ट्रैवर्सल से जड़ को पुनरावृत्तिपूर्वक खोजता है,\n      इनऑर्डर ट्रैवर्सल को बाएं और दाएं उपवृक्षों में विभाजित करता है, और\n      जड़ के बाद बाएं और दाएं उपवृक्षों को विजिट करके प्रीऑर्डर ट्रैवर्सल का निर्माण करता है।\n\n    उदाहरण:\n    - दिए गए इनऑर्डर ट्रैवर्सल 'BADC' और पोस्टऑर्डर ट्रैवर्सल 'BDCA' के लिए, फंक्शन\n      प्रीऑर्डर ट्रैवर्सल 'ABCD' लौटाएगा।\n    - दिए गए इनऑर्डर ट्रैवर्सल 'DBGEACF' और पोस्टऑर्डर ट्रैवर्सल 'DGEBFCA' के लिए, फंक्शन\n      प्रीऑर्डर ट्रैवर्सल 'ABDEGCF' लौटाएगा।\n    - एकल नोड वाले वृक्ष के लिए, जो इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल 'A' द्वारा दर्शाया गया है,\n      फंक्शन 'A' लौटाएगा।\n    \"\"\"",
      "hu": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Újraépíti a bináris fát az inorder és postorder bejárásokból, és\n    visszaadja a preorder bejárást sztringként.\n\n    Args:\n    inorder (str): A bináris fa inorder bejárása.\n    postorder (str): A bináris fa postorder bejárása.\n\n    Returns:\n    str: A bináris fa preorder bejárása.\n\n    Esetek:\n    - Ha mind az inorder, mind a postorder bejárás üres, üres sztringet ad vissza.\n    - Ha a fa egyetlen csomópontból áll, visszaad egy sztringet azzal az egyetlen csomóponttal.\n    - Nagyobb fa esetén rekurzívan megtalálja a gyökeret a postorder bejárásból,\n      felosztja az inorder bejárást bal és jobb részfákra, és megalkotja\n      a preorder bejárást úgy, hogy a gyökeret követi a bal és jobb részfák.\n\n    Példa:\n    - Adott az 'BADC' inorder bejárás és a 'BDCA' postorder bejárás, a függvény\n      visszaadja az 'ABCD' preorder bejárást.\n    - Adott a 'DBGEACF' inorder bejárás és a 'DGEBFCA' postorder bejárás, a függvény\n      visszaadja az 'ABDEGCF' preorder bejárást.\n    - Adott egy fa egyetlen csomóponttal, amelyet az 'A' inorder és postorder bejárás képvisel,\n      a függvény visszaadja az 'A' értéket.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9907577283704466",
      "hy": "0.9826929376396681",
      "bn": "0.9624872621288941",
      "bg": "0.9760843062322564",
      "zh": "0.9552211641602569",
      "fr": "0.9898340970986345",
      "de": "0.9688762083348813",
      "ha": "0.8930135055366075",
      "hi": "0.9716298213071679",
      "hu": "0.9525019142438893"
    },
    "canonical_solution": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder",
    "instruction": {
      "en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nՏրամադրել Python կոդի հակիրճ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9443791234418485",
      "hy": "0.9069653035004981",
      "bn": "0.8657447323066139",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.847230791751114",
      "hi": "0.8964889413135749",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_preorder_traversal():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ntest_preorder_traversal()",
    "entry_point": "preorder_traversal",
    "signature": "def preorder_traversal(inorder: str, postorder: str) -> str:",
    "docstring": {
      "en": "Reconstructs the binary tree from its inorder and postorder traversals and\nreturns the preorder traversal as a string.\n\nArgs:\ninorder (str): The inorder traversal of the binary tree.\npostorder (str): The postorder traversal of the binary tree.\n\nReturns:\nstr: The preorder traversal of the binary tree.\n\nCases:\n- If both inorder and postorder traversals are empty, returns an empty string.\n- If the tree consists of a single node, returns a string with that single node.\n- For a larger tree, recursively finds the root from the postorder traversal,\nsplits the inorder traversal into left and right subtrees, and constructs\nthe preorder traversal by visiting the root followed by the left and right\nsubtrees.\n\nExample:\n- Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\nwill return the preorder traversal 'ABCD'.\n- Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\nwill return the preorder traversal 'ABDEGCF'.\n- Given a tree with a single node represented by the inorder and postorder traversal 'A',\nthe function will return 'A'.",
      "sq": "Rikonstrukton pemën binare nga kalimet e saj inorder dhe postorder dhe\nkthen kalimin preorder si një varg.\n\nArgumentet:\ninorder (str): Kalimi inorder i pemës binare.\npostorder (str): Kalimi postorder i pemës binare.\n\nKthen:\nstr: Kalimi preorder i pemës binare.\n\nRastet:\n- Nëse të dy kalimet inorder dhe postorder janë bosh, kthen një varg bosh.\n- Nëse pema përbëhet nga një nyje e vetme, kthen një varg me atë nyje të vetme.\n- Për një pemë më të madhe, gjen në mënyrë rekursive rrënjën nga kalimi postorder,\nndar kalimin inorder në nënpemë të majta dhe të djathta, dhe ndërton\nkalimin preorder duke vizituar rrënjën e ndjekur nga nënpemët e majta dhe të djathta.\n\nShembull:\n- Duke pasur kalimin inorder 'BADC' dhe kalimin postorder 'BDCA', funksioni\ndo të kthejë kalimin preorder 'ABCD'.\n- Duke pasur kalimin inorder 'DBGEACF' dhe kalimin postorder 'DGEBFCA', funksioni\ndo të kthejë kalimin preorder 'ABDEGCF'.\n- Duke pasur një pemë me një nyje të vetme të përfaqësuar nga kalimi inorder dhe postorder 'A',\nfunksioni do të kthejë 'A'.",
      "hy": "Վերակառուցում է բինար ծառը իր inorder և postorder անցումներից և վերադարձնում է preorder անցումը որպես տող:\n\nԱրձանագրություններ:\ninorder (str): Բինար ծառի inorder անցումը:\npostorder (str): Բինար ծառի postorder անցումը:\n\nՎերադարձնում է:\nstr: Բինար ծառի preorder անցումը:\n\nԴեպքեր:\n- Եթե թե՛ inorder և թե՛ postorder անցումները դատարկ են, վերադարձնում է դատարկ տող:\n- Եթե ծառը բաղկացած է մեկ հանգույցից, վերադարձնում է այդ մեկ հանգույցով տող:\n- Ավելի մեծ ծառի համար, ռեկուրսիվ կերպով գտնում է արմատը postorder անցումից,\nբաժանում է inorder անցումը ձախ և աջ ենթածառերի, և կառուցում է\npreorder անցումը՝ այցելելով արմատը, այնուհետև ձախ և աջ ենթածառերը:\n\nՕրինակ:\n- Տրված է inorder անցումը 'BADC' և postorder անցումը 'BDCA', ֆունկցիան\nկվերադարձնի preorder անցումը 'ABCD':\n- Տրված է inorder անցումը 'DBGEACF' և postorder անցումը 'DGEBFCA', ֆունկցիան\nկվերադարձնի preorder անցումը 'ABDEGCF':\n- Տրված է մեկ հանգույցով ծառ, որը ներկայացված է inorder և postorder անցումներով 'A',\nֆունկցիան կվերադարձնի 'A':",
      "bn": "বাইনারি ট্রি তার ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল থেকে পুনর্গঠন করে এবং প্রিপ্রর্ডার ট্রাভার্সাল একটি স্ট্রিং হিসেবে প্রদান করে।\n\nআর্গুমেন্টসমূহ:\ninorder (str): বাইনারি ট্রির ইনঅর্ডার ট্রাভার্সাল।\npostorder (str): বাইনারি ট্রির পোস্টঅর্ডার ট্রাভার্সাল।\n\nরিটার্নস:\nstr: বাইনারি ট্রির প্রিপ্রর্ডার ট্রাভার্সাল।\n\nক্ষেত্রসমূহ:\n- যদি ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল উভয়ই খালি হয়, তাহলে একটি খালি স্ট্রিং প্রদান করে।\n- যদি ট্রি একটি একক নোড নিয়ে গঠিত হয়, তাহলে সেই একক নোড সহ একটি স্ট্রিং প্রদান করে।\n- একটি বড় ট্রির জন্য, পোস্টঅর্ডার ট্রাভার্সাল থেকে রুট খুঁজে পেতে পুনরাবৃত্তি করে, ইনঅর্ডার ট্রাভার্সালকে বাম এবং ডান সাবট্রিতে বিভক্ত করে, এবং রুট পরিদর্শন করে প্রিপ্রর্ডার ট্রাভার্সাল তৈরি করে, তারপর বাম এবং ডান সাবট্রি।\n\nউদাহরণ:\n- প্রদত্ত ইনঅর্ডার ট্রাভার্সাল 'BADC' এবং পোস্টঅর্ডার ট্রাভার্সাল 'BDCA', ফাংশনটি প্রিপ্রর্ডার ট্রাভার্সাল 'ABCD' প্রদান করবে।\n- প্রদত্ত ইনঅর্ডার ট্রাভার্সাল 'DBGEACF' এবং পোস্টঅর্ডার ট্রাভার্সাল 'DGEBFCA', ফাংশনটি প্রিপ্রর্ডার ট্রাভার্সাল 'ABDEGCF' প্রদান করবে।\n- একটি একক নোড বিশিষ্ট ট্রি, যা ইনঅর্ডার এবং পোস্টঅর্ডার ট্রাভার্সাল 'A' দ্বারা উপস্থাপিত, ফাংশনটি 'A' প্রদান করবে।",
      "bg": "Реконструира бинарното дърво от неговите inorder и postorder обхождания и\nвръща preorder обхождането като низ.\n\nАргументи:\ninorder (str): Inorder обхождането на бинарното дърво.\npostorder (str): Postorder обхождането на бинарното дърво.\n\nВръща:\nstr: Preorder обхождането на бинарното дърво.\n\nСлучаи:\n- Ако и двете inorder и postorder обхождания са празни, връща празен низ.\n- Ако дървото се състои от един единствен възел, връща низ с този единствен възел.\n- За по-голямо дърво, рекурсивно намира корена от postorder обхождането,\nразделя inorder обхождането на ляво и дясно поддърво и конструира\npreorder обхождането, като посещава корена, последван от лявото и дясното\nподдърво.\n\nПример:\n- Дадено inorder обхождане 'BADC' и postorder обхождане 'BDCA', функцията\nще върне preorder обхождане 'ABCD'.\n- Дадено inorder обхождане 'DBGEACF' и postorder обхождане 'DGEBFCA', функцията\nще върне preorder обхождане 'ABDEGCF'.\n- Дадено дърво с един единствен възел, представено чрез inorder и postorder обхождане 'A',\nфункцията ще върне 'A'.",
      "zh": "重建二叉树的中序遍历和后序遍历，并返回前序遍历作为字符串。\n\n参数：\ninorder (str): 二叉树的中序遍历。\npostorder (str): 二叉树的后序遍历。\n\n返回：\nstr: 二叉树的前序遍历。\n\n情况：\n- 如果中序遍历和后序遍历都为空，返回一个空字符串。\n- 如果树由单个节点组成，返回包含该单个节点的字符串。\n- 对于较大的树，从后序遍历中递归地找到根节点，将中序遍历分成左子树和右子树，并通过访问根节点，然后访问左子树和右子树来构建前序遍历。\n\n示例：\n- 给定中序遍历 'BADC' 和后序遍历 'BDCA'，函数将返回前序遍历 'ABCD'。\n- 给定中序遍历 'DBGEACF' 和后序遍历 'DGEBFCA'，函数将返回前序遍历 'ABDEGCF'。\n- 给定一个由中序遍历和后序遍历 'A' 表示的单节点树，函数将返回 'A'。",
      "fr": "Reconstruit l'arbre binaire à partir de ses parcours en ordre et en postordre et\nrenvoie le parcours en préordre sous forme de chaîne de caractères.\n\nArgs:\ninorder (str): Le parcours en ordre de l'arbre binaire.\npostorder (str): Le parcours en postordre de l'arbre binaire.\n\nReturns:\nstr: Le parcours en préordre de l'arbre binaire.\n\nCas:\n- Si les parcours en ordre et en postordre sont tous deux vides, renvoie une chaîne vide.\n- Si l'arbre est constitué d'un seul nœud, renvoie une chaîne avec ce seul nœud.\n- Pour un arbre plus grand, trouve récursivement la racine à partir du parcours en postordre,\ndivise le parcours en ordre en sous-arbres gauche et droit, et construit\nle parcours en préordre en visitant la racine suivie des sous-arbres gauche et droit.\n\nExemple:\n- Étant donné le parcours en ordre 'BADC' et le parcours en postordre 'BDCA', la fonction\nrenverra le parcours en préordre 'ABCD'.\n- Étant donné le parcours en ordre 'DBGEACF' et le parcours en postordre 'DGEBFCA', la fonction\nrenverra le parcours en préordre 'ABDEGCF'.\n- Étant donné un arbre avec un seul nœud représenté par le parcours en ordre et en postordre 'A',\nla fonction renverra 'A'.",
      "de": "Rekonstruiert den Binärbaum aus seinen Inorder- und Postorder-Traversierungen und gibt die Preorder-Traversierung als Zeichenkette zurück.\n\nArgs:\ninorder (str): Die Inorder-Traversierung des Binärbaums.\npostorder (str): Die Postorder-Traversierung des Binärbaums.\n\nReturns:\nstr: Die Preorder-Traversierung des Binärbaums.\n\nFälle:\n- Wenn sowohl die Inorder- als auch die Postorder-Traversierungen leer sind, wird eine leere Zeichenkette zurückgegeben.\n- Wenn der Baum aus einem einzelnen Knoten besteht, wird eine Zeichenkette mit diesem einzelnen Knoten zurückgegeben.\n- Für einen größeren Baum wird rekursiv die Wurzel aus der Postorder-Traversierung gefunden, die Inorder-Traversierung in linke und rechte Teilbäume aufgeteilt und die Preorder-Traversierung durch Besuch der Wurzel gefolgt von den linken und rechten Teilbäumen konstruiert.\n\nBeispiel:\n- Gegeben die Inorder-Traversierung 'BADC' und die Postorder-Traversierung 'BDCA', wird die Funktion die Preorder-Traversierung 'ABCD' zurückgeben.\n- Gegeben die Inorder-Traversierung 'DBGEACF' und die Postorder-Traversierung 'DGEBFCA', wird die Funktion die Preorder-Traversierung 'ABDEGCF' zurückgeben.\n- Gegeben einen Baum mit einem einzelnen Knoten, dargestellt durch die Inorder- und Postorder-Traversierung 'A', wird die Funktion 'A' zurückgeben.",
      "ha": "Sake gina itacen binary daga jerin inorder da postorder kuma\nya dawo da jerin preorder a matsayin kirtani.\n\nArgs:\ninorder (str): Inorder traversal na itacen binary.\npostorder (str): Postorder traversal na itacen binary.\n\nReturns:\nstr: Preorder traversal na itacen binary.\n\nCases:\n- Idan duk inorder da postorder traversals suna fanko, yana dawowa da kirtani fanko.\n- Idan itacen yana da tsawo guda ɗaya, yana dawowa da kirtani tare da wannan tsawo guda ɗaya.\n- Don itace mafi girma, yana gano tushen daga postorder traversal,\nyana raba inorder traversal zuwa subtrees na hagu da dama, kuma yana gina\npreorder traversal ta ziyartar tushen sannan ta bi subtrees na hagu da dama.\n\nExample:\n- An ba da inorder traversal 'BADC' da postorder traversal 'BDCA', aikin\nzai dawo da preorder traversal 'ABCD'.\n- An ba da inorder traversal 'DBGEACF' da postorder traversal 'DGEBFCA', aikin\nzai dawo da preorder traversal 'ABDEGCF'.\n- An ba da itace tare da tsawo guda ɗaya wanda aka wakilta ta hanyar inorder da postorder traversal 'A',\naikin zai dawo da 'A'.",
      "hi": "बाइनरी ट्री को उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से पुनर्निर्मित करता है और\nप्रीऑर्डर ट्रैवर्सल को एक स्ट्रिंग के रूप में लौटाता है।\n\nआर्ग्स:\ninorder (str): बाइनरी ट्री का इनऑर्डर ट्रैवर्सल।\npostorder (str): बाइनरी ट्री का पोस्टऑर्डर ट्रैवर्सल।\n\nरिटर्न्स:\nstr: बाइनरी ट्री का प्रीऑर्डर ट्रैवर्सल।\n\nमामले:\n- यदि इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल दोनों खाली हैं, तो एक खाली स्ट्रिंग लौटाता है।\n- यदि ट्री एक ही नोड से बना है, तो उस एकल नोड के साथ एक स्ट्रिंग लौटाता है।\n- एक बड़े ट्री के लिए, पोस्टऑर्डर ट्रैवर्सल से रूट को पुनरावृत्तिपूर्वक खोजता है,\nइनऑर्डर ट्रैवर्सल को बाएं और दाएं सबट्री में विभाजित करता है, और\nरूट का अनुसरण करते हुए बाएं और दाएं सबट्री का दौरा करके प्रीऑर्डर ट्रैवर्सल का निर्माण करता है।\n\nउदाहरण:\n- दिए गए इनऑर्डर ट्रैवर्सल 'BADC' और पोस्टऑर्डर ट्रैवर्सल 'BDCA' के लिए, फ़ंक्शन\nप्रीऑर्डर ट्रैवर्सल 'ABCD' लौटाएगा।\n- दिए गए इनऑर्डर ट्रैवर्सल 'DBGEACF' और पोस्टऑर्डर ट्रैवर्सल 'DGEBFCA' के लिए, फ़ंक्शन\nप्रीऑर्डर ट्रैवर्सल 'ABDEGCF' लौटाएगा।\n- एकल नोड वाले ट्री के लिए, जिसे इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल 'A' द्वारा दर्शाया गया है,\nफ़ंक्शन 'A' लौटाएगा।",
      "hu": "Rekonstruálja a bináris fát az inorder és postorder bejárásokból, és\nvisszaadja a preorder bejárást egy karakterláncként.\n\nArgs:\ninorder (str): A bináris fa inorder bejárása.\npostorder (str): A bináris fa postorder bejárása.\n\nReturns:\nstr: A bináris fa preorder bejárása.\n\nEsetek:\n- Ha mind az inorder, mind a postorder bejárások üresek, üres karakterláncot ad vissza.\n- Ha a fa egyetlen csomópontból áll, egyetlen csomópontot tartalmazó karakterláncot ad vissza.\n- Nagyobb fa esetén rekurzívan megtalálja a gyökeret a postorder bejárásból,\nfelosztja az inorder bejárást bal és jobb részfákra, és megkonstruálja\na preorder bejárást a gyökér, majd a bal és jobb részfák bejárásával.\n\nPélda:\n- Az 'BADC' inorder és 'BDCA' postorder bejárások esetén a függvény\nvisszaadja az 'ABCD' preorder bejárást.\n- Az 'DBGEACF' inorder és 'DGEBFCA' postorder bejárások esetén a függvény\nvisszaadja az 'ABDEGCF' preorder bejárást.\n- Egyetlen csomópontot tartalmazó fa esetén, amelyet az 'A' inorder és postorder bejárás képvisel,\na függvény 'A'-t ad vissza."
    },
    "docstring_bertscore": {
      "sq": "0.9889287398218775",
      "hy": "0.9846583852600084",
      "bn": "0.9673727749808282",
      "bg": "0.9705742994623485",
      "zh": "0.94879964257178",
      "fr": "0.9873273816899741",
      "de": "0.972609664976813",
      "ha": "0.9679664811897415",
      "hi": "0.976783087912737",
      "hu": "0.9441379861592721"
    }
  },
  {
    "task_id": "Python/28",
    "prompt": {
      "en": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    Case 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) should return 3.\n\n    Case 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\n    is not possible within 10 steps.\n\n    Case 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) should return 3, as each character is replaced\n    individually.\n    \"\"\"",
      "sq": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Kryen transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\n    Kjo funksion merr një varg fillestar A dhe një varg të synuar B, së bashku me një listë\n    të rregullave të transformimit, dhe përpiqet të transformojë A në B duke përdorur rregullat.\n    Një algoritëm Kërkimi i Gjerë (BFS) përdoret për të eksploruar transformimet e mundshme\n    deri në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\n    kthen numrin minimal të hapave të kërkuar. Nëse nuk është e mundur, funksioni kthen\n    \"NO ANSWER!\".\n\n    Parametrat:\n    A (str): Vargu fillestar që do të transformohet.\n    B (str): Vargu i synuar që do të arrihet.\n    rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një dyshe\n                            që përmban nënvargun burim (që do të zëvendësohet) dhe\n                            nënvargun e synuar (me të cilin do të zëvendësohet).\n\n    Kthen:\n    Union[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NO ANSWER!\".\n\n    Shembuj:\n    Rasti 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) duhet të kthejë 3.\n\n    Rasti 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) duhet të kthejë \"NO ANSWER!\" sepse transformimi\n    nuk është i mundur brenda 10 hapash.\n\n    Rasti 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) duhet të kthejë 3, pasi çdo karakter zëvendësohet\n    individualisht.\n    \"\"\"",
      "hy": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Իրականացնել տողերի փոխակերպում A-ից B օգտագործելով փոխակերպման կանոնների հավաքածու։\n\n    Այս ֆունկցիան վերցնում է սկզբնական տող A և նպատակային տող B, ինչպես նաև փոխակերպման\n    կանոնների ցուցակ, և փորձում է փոխակերպել A-ն B-ի օգտագործելով կանոնները։\n    Օգտագործվում է լայնության առաջին որոնման (BFS) ալգորիթմ՝ հնարավոր փոխակերպումները\n    ուսումնասիրելու համար առավելագույնը 10 քայլով։ Եթե A-ն հնարավոր է փոխակերպել B-ի\n    10 քայլի ընթացքում, ֆունկցիան վերադարձնում է պահանջվող նվազագույն քայլերի քանակը։\n    Եթե դա հնարավոր չէ, ֆունկցիան վերադարձնում է \"NO ANSWER!\"։\n\n    Պարամետրեր:\n    A (str): Սկզբնական տողը, որը պետք է փոխակերպվի։\n    B (str): Նպատակային տողը, որը պետք է ստացվի։\n    rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն\n                            զույգ է, որը պարունակում է աղբյուր ենթատողը (որը պետք է փոխարինվի)\n                            և նպատակային ենթատողը (որով պետք է փոխարինվի)։\n\n    Վերադարձնում է:\n    Union[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում՝ \"NO ANSWER!\"։\n\n    Օրինակներ:\n    Դեպք 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) պետք է վերադարձնի 3։\n\n    Դեպք 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) պետք է վերադարձնի \"NO ANSWER!\", քանի որ փոխակերպումը\n    հնարավոր չէ 10 քայլի ընթացքում։\n\n    Դեպք 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) պետք է վերադարձնի 3, քանի որ յուրաքանչյուր նիշ\n    փոխարինվում է առանձին։\n    \"\"\"",
      "bn": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    একটি সেট রূপান্তর নিয়ম ব্যবহার করে A থেকে B তে স্ট্রিং রূপান্তর সম্পাদন করুন।\n\n    এই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, সাথে একটি রূপান্তর নিয়মের তালিকা,\n    এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে। একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম\n    ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে সর্বাধিক 10 ধাপ পর্যন্ত। যদি A কে 10 ধাপের মধ্যে B তে\n    রূপান্তর করা যায়, তাহলে ফাংশনটি প্রয়োজনীয় ন্যূনতম ধাপের সংখ্যা প্রদান করে। যদি এটি সম্ভব না হয়, তাহলে\n    ফাংশনটি \"NO ANSWER!\" প্রদান করে।\n\n    প্যারামিটারসমূহ:\n    A (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\n    B (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\n    rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল\n                            হিসেবে থাকে যা উৎস সাবস্ট্রিং (যা প্রতিস্থাপন করা হবে) এবং\n                            লক্ষ্য সাবস্ট্রিং (যা দিয়ে প্রতিস্থাপন করা হবে) ধারণ করে।\n\n    রিটার্ন:\n    Union[int, str]: যদি সম্ভব হয় তাহলে ন্যূনতম রূপান্তর ধাপের সংখ্যা, অন্যথায় \"NO ANSWER!\".\n\n    উদাহরণ:\n    কেস 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) 3 প্রদান করা উচিত।\n\n    কেস 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) \"NO ANSWER!\" প্রদান করা উচিত কারণ রূপান্তর\n    10 ধাপের মধ্যে সম্ভব নয়।\n\n    কেস 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) 3 প্রদান করা উচিত, কারণ প্রতিটি অক্ষর\n    পৃথকভাবে প্রতিস্থাপিত হয়।\n    \"\"\"",
      "bg": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Извършване на трансформация на низ от A до B, използвайки набор от правила за трансформация.\n\n    Тази функция приема начален низ A и целеви низ B, заедно със списък от правила за трансформация,\n    и се опитва да трансформира A в B, използвайки правилата. Използва се алгоритъм за търсене в ширина (BFS),\n    за да се изследват възможните трансформации до максимум 10 стъпки. Ако A може да бъде трансформиран в B в рамките\n    на 10 стъпки, функцията връща минималния брой необходими стъпки. Ако това не е възможно, функцията връща\n    \"NO ANSWER!\".\n\n    Параметри:\n    A (str): Началният низ, който трябва да бъде трансформиран.\n    B (str): Целевият низ, който трябва да бъде постигнат.\n    rules (list of tuples): Списък от правила за трансформация, където всяко правило е кортеж,\n                            съдържащ изходния подниз (който да бъде заменен) и целевия подниз\n                            (с който да се замени).\n\n    Връща:\n    Union[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\n    Примери:\n    Случай 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) трябва да върне 3.\n\n    Случай 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) трябва да върне \"NO ANSWER!\" защото трансформацията\n    не е възможна в рамките на 10 стъпки.\n\n    Случай 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) трябва да върне 3, тъй като всеки символ се заменя\n    индивидуално.\n    \"\"\"",
      "zh": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    使用一组转换规则执行从 A 到 B 的字符串转换。\n\n    此函数接受一个初始字符串 A 和一个目标字符串 B，以及一个转换规则列表，\n    并尝试使用这些规则将 A 转换为 B。使用广度优先搜索 (BFS) 算法来探索可能的转换，\n    最多进行 10 步。如果 A 可以在 10 步内转换为 B，函数返回所需的最小步骤数。\n    如果不可能，函数返回 \"NO ANSWER!\"。\n\n    参数:\n    A (str): 要转换的初始字符串。\n    B (str): 要实现的目标字符串。\n    rules (list of tuples): 转换规则列表，其中每个规则是一个包含源子字符串（要替换）\n                            和目标子字符串（用于替换）的元组。\n\n    返回:\n    Union[int, str]: 如果可能，返回最小的转换步骤数，否则返回 \"NO ANSWER!\"。\n\n    示例:\n    案例 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) 应返回 3。\n\n    案例 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) 应返回 \"NO ANSWER!\" 因为在 10 步内无法转换。\n\n    案例 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) 应返回 3，因为每个字符都是单独替换的。\n    \"\"\"",
      "fr": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Effectuer une transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\n    Cette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\n    de règles de transformation, et tente de transformer A en B en utilisant les règles.\n    Un algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\n    jusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\n    retourne le nombre minimum d'étapes requises. Si ce n'est pas possible, la fonction retourne\n    \"NO ANSWER!\".\n\n    Paramètres:\n    A (str): La chaîne initiale à transformer.\n    B (str): La chaîne cible à atteindre.\n    rules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\n                            contenant la sous-chaîne source (à remplacer) et la\n                            sous-chaîne cible (pour remplacer).\n\n    Retours:\n    Union[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"NO ANSWER!\".\n\n    Exemples:\n    Cas 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) devrait retourner 3.\n\n    Cas 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) devrait retourner \"NO ANSWER!\" car la transformation\n    n'est pas possible en 10 étapes.\n\n    Cas 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) devrait retourner 3, car chaque caractère est remplacé\n    individuellement.\n    \"\"\"",
      "de": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Führe eine Zeichenketten-Transformation von A nach B unter Verwendung eines Satzes von Transformationsregeln durch.\n\n    Diese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B sowie eine Liste\n    von Transformationsregeln und versucht, A unter Verwendung der Regeln in B zu transformieren.\n    Ein Breadth-First Search (BFS)-Algorithmus wird verwendet, um die möglichen Transformationen\n    bis zu maximal 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B transformiert werden kann, gibt die Funktion\n    die minimale Anzahl der erforderlichen Schritte zurück. Wenn es nicht möglich ist, gibt die Funktion\n    \"NO ANSWER!\" zurück.\n\n    Parameter:\n    A (str): Die anfängliche Zeichenkette, die transformiert werden soll.\n    B (str): Die Zielzeichenkette, die erreicht werden soll.\n    rules (list of tuples): Eine Liste von Transformationsregeln, wobei jede Regel ein Tupel ist,\n                            das die Quellzeichenfolge (die ersetzt werden soll) und die\n                            Zielzeichenfolge (mit der ersetzt werden soll) enthält.\n\n    Rückgabewerte:\n    Union[int, str]: Die minimale Anzahl der Transformationsschritte, falls möglich, andernfalls \"NO ANSWER!\".\n\n    Beispiele:\n    Fall 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) sollte 3 zurückgeben.\n\n    Fall 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) sollte \"NO ANSWER!\" zurückgeben, da die Transformation\n    innerhalb von 10 Schritten nicht möglich ist.\n\n    Fall 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) sollte 3 zurückgeben, da jedes Zeichen\n    einzeln ersetzt wird.\n    \"\"\"",
      "ha": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Yi sauyin kirtani daga A zuwa B ta amfani da saitin dokokin sauyi.\n\n    Wannan aikin yana daukar kirtani na farko A da kirtani na manufa B, tare da jerin\n    dokokin sauyi, kuma yana ƙoƙarin sauya A zuwa B ta amfani da dokokin.\n    Ana amfani da algorithm na Breadth-First Search (BFS) don bincika yiwuwar sauye-sauye\n    har zuwa matakai 10 mafi yawa. Idan za a iya sauya A zuwa B cikin matakai 10, aikin\n    yana dawo da mafi ƙarancin adadin matakan da ake buƙata. Idan ba zai yiwu ba, aikin yana dawo\n    da \"NO ANSWER!\".\n\n    Sigogi:\n    A (str): Kirtani na farko da za a sauya.\n    B (str): Kirtani na manufa da za a cimma.\n    rules (list of tuples): Jerin dokokin sauyi, inda kowace doka take da tuple\n                            mai dauke da kirtani na asali (da za a maye gurbin) da\n                            kirtani na manufa (da za a maye gurbinsa da shi).\n\n    Komawa:\n    Union[int, str]: Mafi ƙarancin adadin matakan sauyi idan zai yiwu, in ba haka ba \"NO ANSWER!\".\n\n    Misalai:\n    Case 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) ya kamata ya dawo da 3.\n\n    Case 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) ya kamata ya dawo da \"NO ANSWER!\" saboda sauyi\n    ba zai yiwu ba cikin matakai 10.\n\n    Case 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) ya kamata ya dawo da 3, yayin da kowanne hali\n    aka maye gurbinsa da kansa.\n    \"\"\"",
      "hi": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    आरंभिक स्ट्रिंग A से B में परिवर्तन करने के लिए परिवर्तन नियमों का उपयोग करें।\n\n    यह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्षित स्ट्रिंग B लेता है, साथ ही\n    परिवर्तन नियमों की एक सूची, और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\n    संभावित परिवर्तनों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिदम का उपयोग किया जाता है\n    अधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन\n    आवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन\n    \"NO ANSWER!\" लौटाता है।\n\n    पैरामीटर्स:\n    A (str): वह प्रारंभिक स्ट्रिंग जिसे परिवर्तित किया जाना है।\n    B (str): वह लक्षित स्ट्रिंग जिसे प्राप्त किया जाना है।\n    rules (list of tuples): परिवर्तन नियमों की एक सूची, जहाँ प्रत्येक नियम एक ट्यूपल होता है\n                            जिसमें स्रोत उपस्ट्रिंग (जिसे बदला जाना है) और\n                            लक्षित उपस्ट्रिंग (जिससे बदलना है) शामिल होते हैं।\n\n    रिटर्न्स:\n    Union[int, str]: यदि संभव हो तो न्यूनतम परिवर्तन चरणों की संख्या, अन्यथा \"NO ANSWER!\".\n\n    उदाहरण:\n    केस 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) को 3 लौटाना चाहिए।\n\n    केस 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) को \"NO ANSWER!\" लौटाना चाहिए क्योंकि परिवर्तन\n    10 चरणों के भीतर संभव नहीं है।\n\n    केस 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) को 3 लौटाना चाहिए, क्योंकि प्रत्येक वर्ण को\n    व्यक्तिगत रूप से बदला जाता है।\n    \"\"\"",
      "hu": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    String transzformáció végrehajtása A-ból B-be egy sor transzformációs szabály segítségével.\n\n    Ez a függvény egy kezdeti A stringet és egy cél B stringet vesz, valamint egy listát\n    transzformációs szabályokkal, és megpróbálja A-t B-vé alakítani a szabályok segítségével.\n    Egy Szélességi Első Keresés (BFS) algoritmus kerül alkalmazásra a lehetséges transzformációk\n    felfedezésére legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé, a függvény\n    visszaadja a szükséges minimális lépések számát. Ha nem lehetséges, a függvény\n    \"NO ANSWER!\"-t ad vissza.\n\n    Paraméterek:\n    A (str): A kezdeti string, amelyet át kell alakítani.\n    B (str): A cél string, amelyet el kell érni.\n    rules (list of tuples): Egy lista transzformációs szabályokkal, ahol minden szabály egy\n                            forrás részstringet (amit ki kell cserélni) és egy\n                            cél részstringet (amire ki kell cserélni) tartalmaz.\n\n    Visszatérési érték:\n    Union[int, str]: A minimális transzformációs lépések száma, ha lehetséges, ellenkező esetben \"NO ANSWER!\".\n\n    Példák:\n    1. eset:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) vissza kell adja 3.\n\n    2. eset:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) vissza kell adja \"NO ANSWER!\" mert a transzformáció\n    nem lehetséges 10 lépésen belül.\n\n    3. eset:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) vissza kell adja 3, mivel minden karakter\n    egyenként kerül kicserélésre.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9764992450982383",
      "hy": "0.9747209072968329",
      "bn": "0.9886562189390975",
      "bg": "0.9920953053563356",
      "zh": "0.9795686803763703",
      "fr": "0.9815353197789968",
      "de": "0.9854207286624203",
      "ha": "0.9791247414747574",
      "hi": "0.9753660587744342",
      "hu": "0.9783530624444369"
    },
    "canonical_solution": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"",
    "instruction": {
      "en": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nনিচের পাইথন কোডের একটি সংক্ষিপ্ত ন্যাচারাল ল্যাঙ্গুয়েজ বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, সর্বাধিক ৫০০ অক্ষর ব্যবহার করে।",
      "bg": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nBa da taƙaitaccen bayani a cikin yaren halitta (docstring) na lambar Python a Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.8954501044207624",
      "bg": "0.8983697723915943",
      "zh": "0.8886474111310796",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9215501364887467",
      "hi": "0.91110952777041",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_string_transformation():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_string_transformation()",
    "entry_point": "string_transformation",
    "signature": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:",
    "docstring": {
      "en": "Perform string transformation from A to B using a set of transformation rules.\n\nThis function takes an initial string A and a target string B, along with a list\nof transformation rules, and attempts to transform A into B using the rules.\nA Breadth-First Search (BFS) algorithm is used to explore the possible transformations\nup to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\nreturns the minimum number of steps required. If it's not possible, the function returns\n\"NO ANSWER!\".\n\nParameters:\nA (str): The initial string to be transformed.\nB (str): The target string to be achieved.\nrules (list of tuples): A list of transformation rules, where each rule is a tuple\ncontaining the source substring (to be replaced) and the\ntarget substring (to replace with).\n\nReturns:\nUnion[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) should return 3.\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\nis not possible within 10 steps.\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) should return 3, as each character is replaced\nindividually.",
      "sq": "Kryeni transformimin e vargut nga A në B duke përdorur një grup rregullash transformimi.\n\nKjo funksion merr një varg fillestar A dhe një varg synim B, së bashku me një listë\nrregullash transformimi, dhe përpiqet të transformojë A në B duke përdorur rregullat.\nNjë algoritëm Kërkimi në Gjerësi (BFS) përdoret për të eksploruar transformimet e mundshme\nderi në një maksimum prej 10 hapash. Nëse A mund të transformohet në B brenda 10 hapash, funksioni\nkthehet numrin minimal të hapave të kërkuar. Nëse nuk është e mundur, funksioni kthen\n\"NUK KA PËRGJIGJE!\".\n\nParametrat:\nA (str): Vargu fillestar që do të transformohet.\nB (str): Vargu synim që do të arrihet.\nrules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull është një tuple\nqë përmban nënvargun burim (që do të zëvendësohet) dhe\nnënvargun synim (me të cilin do të zëvendësohet).\n\nKthen:\nUnion[int, str]: Numri minimal i hapave të transformimit nëse është e mundur, përndryshe \"NUK KA PËRGJIGJE!\".\n\nShembuj:\nRasti 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) duhet të kthejë 3.\n\nRasti 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) duhet të kthejë \"NUK KA PËRGJIGJE!\" sepse transformimi\nnuk është i mundur brenda 10 hapash.\n\nRasti 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) duhet të kthejë 3, pasi çdo karakter zëvendësohet\nindividualisht.",
      "hy": "Տարածել տողերի փոխակերպում A-ից B օգտագործելով փոխակերպման կանոնների հավաքածու:\n\nԱյս ֆունկցիան ընդունում է սկզբնական տող A և նպատակային տող B, ինչպես նաև փոխակերպման կանոնների ցուցակ, և փորձում է փոխակերպել A-ն B-ի օգտագործելով կանոնները: Լայնության-առաջին որոնման (BFS) ալգորիթմը օգտագործվում է հնարավոր փոխակերպումները ուսումնասիրելու համար առավելագույնը 10 քայլով: Եթե A-ն կարող է փոխակերպվել B-ի 10 քայլի ընթացքում, ֆունկցիան վերադարձնում է պահանջվող նվազագույն քայլերի քանակը: Եթե դա հնարավոր չէ, ֆունկցիան վերադարձնում է \"NO ANSWER!\":\n\nՊարամետրեր:\nA (str): Սկզբնական տողը, որը պետք է փոխակերպվի:\nB (str): Նպատակային տողը, որը պետք է ստացվի:\nrules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն տողակազմ է, որը պարունակում է աղբյուր ենթատողը (որը պետք է փոխարինվի) և նպատակային ենթատողը (որով պետք է փոխարինվի):\n\nՎերադարձնում է:\nUnion[int, str]: Փոխակերպման նվազագույն քայլերի քանակը, եթե հնարավոր է, հակառակ դեպքում \"NO ANSWER!\":\n\nՕրինակներ:\nԴեպք 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) պետք է վերադարձնի 3:\n\nԴեպք 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) պետք է վերադարձնի \"NO ANSWER!\" քանի որ փոխակերպումը հնարավոր չէ 10 քայլի ընթացքում:\n\nԴեպք 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) պետք է վերադարձնի 3, քանի որ յուրաքանչյուր նիշ փոխարինվում է առանձին:",
      "bn": "স্ট্রিং রূপান্তর A থেকে B তে একটি সেট রূপান্তর নিয়ম ব্যবহার করে সম্পাদন করুন।\n\nএই ফাংশনটি একটি প্রাথমিক স্ট্রিং A এবং একটি লক্ষ্য স্ট্রিং B গ্রহণ করে, একটি রূপান্তর নিয়মের তালিকার সাথে, এবং নিয়মগুলি ব্যবহার করে A কে B তে রূপান্তর করার চেষ্টা করে। একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) অ্যালগরিদম ব্যবহার করা হয় সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে সর্বাধিক ১০ ধাপ পর্যন্ত। যদি A কে ১০ ধাপের মধ্যে B তে রূপান্তর করা যায়, তাহলে ফাংশনটি প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা প্রদান করে। যদি এটি সম্ভব না হয়, তাহলে ফাংশনটি \"NO ANSWER!\" প্রদান করে।\n\nপ্যারামিটারসমূহ:\nA (str): প্রাথমিক স্ট্রিং যা রূপান্তরিত হবে।\nB (str): লক্ষ্য স্ট্রিং যা অর্জন করতে হবে।\nrules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টিউপল\nযা উৎস সাবস্ট্রিং (প্রতিস্থাপন করার জন্য) এবং লক্ষ্য সাবস্ট্রিং (যা দিয়ে প্রতিস্থাপন করা হবে) ধারণ করে।\n\nরিটার্নস:\nUnion[int, str]: রূপান্তর ধাপের সর্বনিম্ন সংখ্যা যদি সম্ভব হয়, অন্যথায় \"NO ANSWER!\".\n\nউদাহরণসমূহ:\nকেস ১:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) ৩ প্রদান করা উচিত।\n\nকেস ২:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) \"NO ANSWER!\" প্রদান করা উচিত কারণ রূপান্তর\n১০ ধাপের মধ্যে সম্ভব নয়।\n\nকেস ৩:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) ৩ প্রদান করা উচিত, কারণ প্রতিটি অক্ষর পৃথকভাবে প্রতিস্থাপিত হয়।",
      "bg": "Извършете трансформация на низ от A до B, използвайки набор от правила за трансформация.\n\nТази функция приема начален низ A и целеви низ B, заедно със списък от правила за трансформация, и се опитва да трансформира A в B, използвайки правилата. Използва се алгоритъм за търсене в ширина (BFS), за да се изследват възможните трансформации до максимум 10 стъпки. Ако A може да бъде трансформиран в B в рамките на 10 стъпки, функцията връща минималния брой необходими стъпки. Ако не е възможно, функцията връща \"NO ANSWER!\".\n\nПараметри:\nA (str): Началният низ, който ще бъде трансформиран.\nB (str): Целевият низ, който трябва да бъде постигнат.\nrules (list of tuples): Списък от правила за трансформация, където всяко правило е кортеж, съдържащ изходния подниз (който ще бъде заменен) и целевия подниз (с който ще се замени).\n\nВръща:\nUnion[int, str]: Минималният брой стъпки за трансформация, ако е възможно, в противен случай \"NO ANSWER!\".\n\nПримери:\nСлучай 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) трябва да върне 3.\n\nСлучай 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) трябва да върне \"NO ANSWER!\", защото трансформацията\nне е възможна в рамките на 10 стъпки.\n\nСлучай 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) трябва да върне 3, тъй като всеки символ се заменя\nиндивидуално.",
      "zh": "执行字符串从 A 到 B 的转换，使用一组转换规则。\n\n此函数接收一个初始字符串 A 和一个目标字符串 B，以及一个转换规则列表，并尝试使用这些规则将 A 转换为 B。使用广度优先搜索（BFS）算法来探索可能的转换，最多进行 10 步。如果 A 可以在 10 步内转换为 B，函数返回所需的最小步骤数。如果不可能，函数返回 \"NO ANSWER!\"。\n\n参数：\nA (str): 要转换的初始字符串。\nB (str): 要达到的目标字符串。\nrules (list of tuples): 转换规则列表，其中每个规则是一个包含源子字符串（要替换的）和目标子字符串（用于替换）的元组。\n\n返回：\nUnion[int, str]: 如果可能，返回最小的转换步骤数，否则返回 \"NO ANSWER!\"。\n\n示例：\n案例 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) 应返回 3。\n\n案例 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) 应返回 \"NO ANSWER!\" 因为在 10 步内无法完成转换。\n\n案例 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) 应返回 3，因为每个字符被单独替换。",
      "fr": "Effectuer une transformation de chaîne de A à B en utilisant un ensemble de règles de transformation.\n\nCette fonction prend une chaîne initiale A et une chaîne cible B, ainsi qu'une liste\nde règles de transformation, et tente de transformer A en B en utilisant les règles.\nUn algorithme de recherche en largeur (BFS) est utilisé pour explorer les transformations possibles\njusqu'à un maximum de 10 étapes. Si A peut être transformé en B en 10 étapes, la fonction\nrenvoie le nombre minimum d'étapes nécessaires. Si ce n'est pas possible, la fonction renvoie\n\"PAS DE RÉPONSE!\".\n\nParamètres:\nA (str): La chaîne initiale à transformer.\nB (str): La chaîne cible à atteindre.\nrules (list of tuples): Une liste de règles de transformation, où chaque règle est un tuple\ncontenant la sous-chaîne source (à remplacer) et la\nsous-chaîne cible (par laquelle remplacer).\n\nRenvoie:\nUnion[int, str]: Le nombre minimum d'étapes de transformation si possible, sinon \"PAS DE RÉPONSE!\".\n\nExemples:\nCas 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) devrait renvoyer 3.\n\nCas 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) devrait renvoyer \"PAS DE RÉPONSE!\" car la transformation\nn'est pas possible en 10 étapes.\n\nCas 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) devrait renvoyer 3, car chaque caractère est remplacé\nindividuellement.",
      "de": "Führe eine Zeichenketten-Transformation von A nach B unter Verwendung eines Satzes von Transformationsregeln durch.\n\nDiese Funktion nimmt eine Anfangszeichenkette A und eine Zielzeichenkette B, zusammen mit einer Liste von Transformationsregeln, und versucht, A mithilfe der Regeln in B zu transformieren. Ein Breitensuche-Algorithmus (BFS) wird verwendet, um die möglichen Transformationen bis zu einem Maximum von 10 Schritten zu erkunden. Wenn A innerhalb von 10 Schritten in B transformiert werden kann, gibt die Funktion die minimale Anzahl der erforderlichen Schritte zurück. Wenn es nicht möglich ist, gibt die Funktion \"KEINE ANTWORT!\" zurück.\n\nParameter:\nA (str): Die anfängliche Zeichenkette, die transformiert werden soll.\nB (str): Die Zielzeichenkette, die erreicht werden soll.\nrules (list of tuples): Eine Liste von Transformationsregeln, wobei jede Regel ein Tupel ist, das das Quell-Substring (das ersetzt werden soll) und das Ziel-Substring (mit dem ersetzt werden soll) enthält.\n\nRückgabewerte:\nUnion[int, str]: Die minimale Anzahl der Transformationsschritte, wenn möglich, andernfalls \"KEINE ANTWORT!\".\n\nBeispiele:\nFall 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) sollte 3 zurückgeben.\n\nFall 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) sollte \"KEINE ANTWORT!\" zurückgeben, da die Transformation innerhalb von 10 Schritten nicht möglich ist.\n\nFall 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) sollte 3 zurückgeben, da jedes Zeichen einzeln ersetzt wird.",
      "ha": "Ai aikata sauyin kirtani daga A zuwa B ta amfani da saitin dokokin sauyi.\n\nWannan aikin yana ɗaukar kirtani na farko A da kirtani na manufa B, tare da jerin\ndokokin sauyi, kuma yana ƙoƙarin sauya A zuwa B ta amfani da dokokin.\nAna amfani da dabarar Binciken Fadada (BFS) don bincika yiwuwar sauye-sauye\nhar zuwa matakai 10 na iyaka. Idan za a iya sauya A zuwa B a cikin matakai 10, aikin\nyana mayar da mafi ƙarancin adadin matakan da ake bukata. Idan ba zai yiwu ba, aikin yana mayar da\n\"BA AMSA!\".\n\nSigogi:\nA (str): Kirtani na farko da za a sauya.\nB (str): Kirtani na manufa da za a cimma.\nrules (list of tuples): Jerin dokokin sauyi, inda kowanne doka yake da tuple\nmai ɗauke da kirtani na asali (da za a maye gurbinsa) da\nkirtani na manufa (da za a maye gurbi da shi).\n\nMayarwa:\nUnion[int, str]: Mafi ƙarancin adadin matakan sauyi idan zai yiwu, in ba haka ba \"BA AMSA!\".\n\nMisalai:\nMisali 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) ya kamata ya mayar da 3.\n\nMisali 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) ya kamata ya mayar da \"BA AMSA!\" saboda sauyi\nba zai yiwu ba a cikin matakai 10.\n\nMisali 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) ya kamata ya mayar da 3, domin kowane harafi an maye\ngurbinsa daya bayan daya.",
      "hi": "आरंभिक स्ट्रिंग A से B में परिवर्तन करने के लिए परिवर्तन नियमों का उपयोग करें।\n\nयह फ़ंक्शन एक प्रारंभिक स्ट्रिंग A और एक लक्ष्य स्ट्रिंग B लेता है, साथ ही एक सूची\nरूपांतरण नियमों की, और नियमों का उपयोग करके A को B में बदलने का प्रयास करता है।\nसंभावित रूपांतरणों का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) एल्गोरिदम का उपयोग किया जाता है\nअधिकतम 10 चरणों तक। यदि A को 10 चरणों के भीतर B में बदला जा सकता है, तो फ़ंक्शन\nआवश्यक न्यूनतम चरणों की संख्या लौटाता है। यदि यह संभव नहीं है, तो फ़ंक्शन\n\"NO ANSWER!\" लौटाता है।\n\nParameters:\nA (str): प्रारंभिक स्ट्रिंग जिसे रूपांतरित किया जाना है।\nB (str): लक्ष्य स्ट्रिंग जिसे प्राप्त करना है।\nrules (list of tuples): रूपांतरण नियमों की एक सूची, जहाँ प्रत्येक नियम एक टपल है\nजिसमें स्रोत सबस्ट्रिंग (जिसे बदला जाना है) और\nलक्ष्य सबस्ट्रिंग (जिससे बदलना है) शामिल है।\n\nReturns:\nUnion[int, str]: न्यूनतम रूपांतरण चरणों की संख्या यदि संभव हो, अन्यथा \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) को 3 लौटाना चाहिए।\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) को \"NO ANSWER!\" लौटाना चाहिए क्योंकि रूपांतरण\n10 चरणों के भीतर संभव नहीं है।\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) को 3 लौटाना चाहिए, क्योंकि प्रत्येक अक्षर को\nव्यक्तिगत रूप से बदला जाता है।",
      "hu": "Végezzen karakterlánc átalakítást A-ból B-be egy halmaz transzformációs szabály segítségével.\n\nEz a függvény egy kezdeti A karakterláncot és egy cél B karakterláncot, valamint egy lista\ntranszformációs szabályt vesz át, és megpróbálja A-t B-vé alakítani a szabályok használatával.\nEgy Szélességi Első Keresés (BFS) algoritmust használunk a lehetséges átalakítások\nfeltárására legfeljebb 10 lépésig. Ha A 10 lépésen belül átalakítható B-vé, a függvény\nvisszaadja a szükséges minimális lépések számát. Ha nem lehetséges, a függvény\n\"NO ANSWER!\"-t ad vissza.\n\nParaméterek:\nA (str): Az átalakítandó kezdeti karakterlánc.\nB (str): Az elérendő cél karakterlánc.\nrules (list of tuples): Egy lista transzformációs szabályokkal, ahol minden szabály egy\nforrás részkarakterláncot tartalmaz (amit ki kell cserélni) és a\ncél részkarakterláncot (amire ki kell cserélni).\n\nVisszatérési érték:\nUnion[int, str]: A minimális átalakítási lépések száma, ha lehetséges, különben \"NO ANSWER!\".\n\nPéldák:\n1. eset:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) vissza kell adnia 3.\n\n2. eset:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) vissza kell adnia \"NO ANSWER!\", mert az átalakítás\nnem lehetséges 10 lépésen belül.\n\n3. eset:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) vissza kell adnia 3, mivel minden karakter egyenként van kicserélve."
    },
    "docstring_bertscore": {
      "sq": "0.9799949411740713",
      "hy": "0.9740552968899849",
      "bn": "0.9860154280232387",
      "bg": "0.9883443692408728",
      "zh": "0.975416113630455",
      "fr": "0.9768373140067597",
      "de": "0.986290332470591",
      "ha": "0.9597697998859558",
      "hi": "0.9866864014503746",
      "hu": "0.9729731585741069"
    }
  },
  {
    "task_id": "Python/29",
    "prompt": {
      "en": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    The sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    The sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.\n    \"\"\"",
      "sq": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Llogarit numrin më të vogël pozitiv n të tillë që shuma e serisë harmonike\n    deri në 1/n është më e madhe se një numër i dhënë pozitiv k.\n\n    Seria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentet:\n    - k (int): Një numër i plotë pozitiv që përfaqëson vlerën prag që shuma e serisë harmonike duhet të tejkalojë.\n\n    Kthen:\n    - int: Numri më i vogël n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\n    Shembuj:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Shuma S_2 = 1 + 1/2 = 1.5, e cila është më e madhe se 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Shuma S_10 = 1 + 1/2 + 1/3 + ... + 1/10 është më e vogël ose e barabartë me 3, por shuma S_11 tejkalon 3.\n    \"\"\"",
      "hy": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Հաշվել ամենափոքր դրական ամբողջ թիվը n, այնպես, որ հարմոնիկ շարքի \n    1/n-ով սահմանափակված գումարը մեծ լինի տրված դրական ամբողջ թիվ k-ից։\n\n    Հարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n։\n\n    Արգումենտներ:\n    - k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմի արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի։\n\n    Վերադարձնում է:\n    - int: Ամենափոքր թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k։\n\n    Օրինակներ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Գումարը S_2 = 1 + 1/2 = 1.5, որը մեծ է 1-ից։\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Գումարը S_10 = 1 + 1/2 + 1/3 + ... + 1/10 փոքր կամ հավասար է 3-ին, բայց գումարը S_11 գերազանցում է 3-ը։\n    \"\"\"",
      "bn": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    হরমোনিক সিরিজের যোগফল 1/n পর্যন্ত একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বড় এমন ক্ষুদ্রতম ধনাত্মক পূর্ণসংখ্যা n গণনা করুন।\n\n    হরমোনিক সিরিজ সংজ্ঞায়িত করা হয় S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে।\n\n    আর্গুমেন্টসমূহ:\n    - k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হরমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন সীমা মান উপস্থাপন করে।\n\n    রিটার্নস:\n    - int: ক্ষুদ্রতম পূর্ণসংখ্যা n যার জন্য হরমোনিক সিরিজের যোগফল S_n সীমা k অতিক্রম করে।\n\n    উদাহরণ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    যোগফল S_2 = 1 + 1/2 = 1.5, যা 1 এর চেয়ে বড়।\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    যোগফল S_10 = 1 + 1/2 + 1/3 + ... + 1/10 3 এর চেয়ে কম বা সমান, কিন্তু যোগফল S_11 3 অতিক্রম করে।\n    \"\"\"",
      "bg": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Изчислява най-малкото положително цяло число n, такова че сумата на хармоничната редица\n    до 1/n е по-голяма от дадено положително цяло число k.\n\n    Хармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Аргументи:\n    - k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\n    Връща:\n    - int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\n    Примери:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Сумата S_2 = 1 + 1/2 = 1.5, което е по-голямо от 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Сумата S_10 = 1 + 1/2 + 1/3 + ... + 1/10 е по-малка или равна на 3, но сумата S_11 надвишава 3.\n    \"\"\"",
      "zh": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    计算最小的正整数 n，使得调和级数的和\n    达到 1/n 时大于给定的正整数 k。\n\n    调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n    参数:\n    - k (int): 表示调和级数和必须超过的阈值的正整数。\n\n    返回:\n    - int: 调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n    示例:\n    >>> find_min_n_greater_than_k(1)\n    2\n    和 S_2 = 1 + 1/2 = 1.5，大于 1。\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    和 S_10 = 1 + 1/2 + 1/3 + ... + 1/10 小于或等于 3，但和 S_11 超过 3。\n    \"\"\"",
      "fr": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculer le plus petit entier positif n tel que la somme de la série harmonique\n    jusqu'à 1/n soit supérieure à un entier positif donné k.\n\n    La série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\n    Returns:\n    - int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\n    Exemples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    La somme S_2 = 1 + 1/2 = 1.5, qui est supérieure à 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    La somme S_10 = 1 + 1/2 + 1/3 + ... + 1/10 est inférieure ou égale à 3, mais la somme S_11 dépasse 3.\n    \"\"\"",
      "de": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Berechne die kleinste positive ganze Zahl n, sodass die Summe der harmonischen Reihe\n    bis 1/n größer ist als eine gegebene positive ganze Zahl k.\n\n    Die harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumente:\n    - k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\n    Rückgabewerte:\n    - int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\n    Beispiele:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Die Summe S_2 = 1 + 1/2 = 1.5, die größer als 1 ist.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Die Summe S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ist kleiner oder gleich 3, aber die Summe S_11 überschreitet 3.\n    \"\"\"",
      "ha": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Lissafi mafi ƙarancin lamba mai kyau n wanda hakan jimillar jerin harmonic\n    har zuwa 1/n ya fi wani lamba mai kyau k.\n\n    Jerin harmonic ana bayyana shi kamar haka S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): Lamba mai kyau da ke wakiltar ƙimar iyaka da jimillar jerin harmonic dole ne ta wuce.\n\n    Returns:\n    - int: Mafi ƙarancin lamba n wanda jimillar jerin harmonic S_n ta wuce iyaka k.\n\n    Misalai:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Jimillar S_2 = 1 + 1/2 = 1.5, wanda ya fi 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Jimillar S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ya yi ƙasa ko daidai da 3, amma jimillar S_11 ta wuce 3.\n    \"\"\"",
      "hi": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    सबसे छोटा धनात्मक पूर्णांक n गणना करें ताकि हार्मोनिक श्रेणी का योग\n    1/n तक दिए गए धनात्मक पूर्णांक k से अधिक हो।\n\n    हार्मोनिक श्रेणी को S_n = 1 + 1/2 + 1/3 + ... + 1/n के रूप में परिभाषित किया गया है।\n\n    तर्क:\n    - k (int): एक धनात्मक पूर्णांक जो उस सीमा मान का प्रतिनिधित्व करता है जिसे हार्मोनिक श्रेणी का योग पार करना चाहिए।\n\n    वापसी:\n    - int: सबसे छोटा पूर्णांक n जिसके लिए हार्मोनिक श्रेणी का योग S_n सीमा k से अधिक हो जाता है।\n\n    उदाहरण:\n    >>> find_min_n_greater_than_k(1)\n    2\n    योग S_2 = 1 + 1/2 = 1.5 है, जो 1 से अधिक है।\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    योग S_10 = 1 + 1/2 + 1/3 + ... + 1/10 3 से कम या बराबर है, लेकिन योग S_11 3 से अधिक हो जाता है।\n    \"\"\"",
      "hu": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Számítsa ki a legkisebb pozitív egész számot n, amelyre a harmonikus sorozat\n    1/n-ig terjedő összege nagyobb, mint egy adott pozitív egész szám k.\n\n    A harmonikus sorozat definíciója: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentumok:\n    - k (int): Egy pozitív egész szám, amely a küszöbértéket jelöli, amelyet a harmonikus sorozat összegének meg kell haladnia.\n\n    Visszatér:\n    - int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\n    Példák:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Az összeg S_2 = 1 + 1/2 = 1.5, amely nagyobb, mint 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Az összeg S_10 = 1 + 1/2 + 1/3 + ... + 1/10 kisebb vagy egyenlő, mint 3, de az összeg S_11 meghaladja a 3-at.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9741456737133558",
      "hy": "0.9699778124281008",
      "bn": "0.9762553269903274",
      "bg": "0.9776201163384182",
      "zh": "0.9558033498070702",
      "fr": "0.982709423961294",
      "de": "0.975786360660704",
      "ha": "0.9784305282930404",
      "hi": "0.973395049503425",
      "hu": "0.968333550133894"
    },
    "canonical_solution": "# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1",
    "instruction": {
      "en": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nনিচের পাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nGeben Sie eine prägnante Beschreibung des Python-Codes in natürlicher Sprache auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.8693935724062248",
      "bg": "0.8983697723915943",
      "zh": "0.8780469049560097",
      "fr": "0.9690480236144765",
      "de": "0.873055323480603",
      "ha": "0.8871127928072041",
      "hi": "0.91110952777041",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_find_min_n_greater_than_k():\n    # Test case 1: k = 1, expected result is 2\n\n    assert find_min_n_greater_than_k(1) == 2, \"Test case 1 failed.\"\n\n    # Test case 2: k = 3, expected result is 11\n    assert find_min_n_greater_than_k(3) == 11, \"Test case 2 failed.\"\n    # Test case 3: k = 5, expected result is 83\n    assert find_min_n_greater_than_k(5) == 83, \"Test case 3 failed.\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_find_min_n_greater_than_k()",
    "entry_point": "find_min_n_greater_than_k",
    "signature": "def find_min_n_greater_than_k(k: int) -> int:",
    "docstring": {
      "en": "Calculate the smallest positive integer n such that the sum of the harmonic series\nup to 1/n is greater than a given positive integer k.\n\nThe harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\nReturns:\n- int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nThe sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nThe sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.",
      "sq": "Llogarit numrin më të vogël pozitiv n të tillë që shuma e serisë harmonike\nderi në 1/n është më e madhe se një numër i dhënë pozitiv k.\n\nSeria harmonike është e përcaktuar si S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgumentet:\n- k (int): Një numër i plotë pozitiv që përfaqëson vlerën prag që shuma e serisë harmonike duhet të tejkalojë.\n\nKthen:\n- int: Numri më i vogël n për të cilin shuma e serisë harmonike S_n tejkalon pragun k.\n\nShembuj:\n>>> find_min_n_greater_than_k(1)\n2\nShuma S_2 = 1 + 1/2 = 1.5, e cila është më e madhe se 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nShuma S_10 = 1 + 1/2 + 1/3 + ... + 1/10 është më e vogël ose e barabartë me 3, por shuma S_11 tejkalon 3.",
      "hy": "Հաշվել ամենափոքր դրական ամբողջ թիվը n, այնպես որ հարմոնիկ շարքի գումարը\nմինչև 1/n մեծ լինի տրված դրական ամբողջ թիվ k-ից։\n\nՀարմոնիկ շարքը սահմանվում է որպես S_n = 1 + 1/2 + 1/3 + ... + 1/n։\n\nԱրգումենտներ:\n- k (int): Դրական ամբողջ թիվ, որը ներկայացնում է շեմի արժեքը, որը հարմոնիկ շարքի գումարը պետք է գերազանցի։\n\nՎերադարձնում է:\n- int: Ամենափոքր ամբողջ թիվը n, որի համար հարմոնիկ շարքի գումարը S_n գերազանցում է շեմը k։\n\nՕրինակներ:\n>>> find_min_n_greater_than_k(1)\n2\nԳումարը S_2 = 1 + 1/2 = 1.5, որը մեծ է 1-ից։\n\n>>> find_min_n_greater_than_k(3)\n11\nԳումարը S_10 = 1 + 1/2 + 1/3 + ... + 1/10 փոքր կամ հավասար է 3, բայց գումարը S_11 գերազանցում է 3։",
      "bn": "হরমোনিক সিরিজের যোগফল 1/n পর্যন্ত একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা k এর চেয়ে বড় এমন ক্ষুদ্রতম ধনাত্মক পূর্ণসংখ্যা n গণনা করুন।\n\nহারমোনিক সিরিজটি সংজ্ঞায়িত করা হয় S_n = 1 + 1/2 + 1/3 + ... + 1/n হিসাবে।\n\nআর্গস:\n- k (int): একটি ধনাত্মক পূর্ণসংখ্যা যা হারমোনিক সিরিজের যোগফলকে অতিক্রম করতে হবে এমন থ্রেশহোল্ড মানকে উপস্থাপন করে।\n\nরিটার্নস:\n- int: ক্ষুদ্রতম পূর্ণসংখ্যা n যার জন্য হারমোনিক সিরিজের যোগফল S_n থ্রেশহোল্ড k অতিক্রম করে।\n\nউদাহরণ:\n>>> find_min_n_greater_than_k(1)\n2\nযোগফল S_2 = 1 + 1/2 = 1.5, যা 1 এর চেয়ে বড়।\n\n>>> find_min_n_greater_than_k(3)\n11\nযোগফল S_10 = 1 + 1/2 + 1/3 + ... + 1/10 3 এর চেয়ে ছোট বা সমান, কিন্তু যোগফল S_11 3 অতিক্রম করে।",
      "bg": "Изчислете най-малкото положително цяло число n, такова че сумата на хармоничната редица\nдо 1/n да е по-голяма от дадено положително цяло число k.\n\nХармоничната редица е дефинирана като S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nАргументи:\n- k (int): Положително цяло число, представляващо праговата стойност, която сумата на хармоничната редица трябва да надвиши.\n\nВръща:\n- int: Най-малкото цяло число n, за което сумата на хармоничната редица S_n надвишава прага k.\n\nПримери:\n>>> find_min_n_greater_than_k(1)\n2\nСумата S_2 = 1 + 1/2 = 1.5, която е по-голяма от 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nСумата S_10 = 1 + 1/2 + 1/3 + ... + 1/10 е по-малка или равна на 3, но сумата S_11 надвишава 3.",
      "zh": "计算最小的正整数 n，使得调和级数从 1 到 1/n 的和大于给定的正整数 k。\n\n调和级数定义为 S_n = 1 + 1/2 + 1/3 + ... + 1/n。\n\n参数：\n- k (int): 一个正整数，表示调和级数和必须超过的阈值。\n\n返回：\n- int: 使调和级数和 S_n 超过阈值 k 的最小整数 n。\n\n示例：\n>>> find_min_n_greater_than_k(1)\n2\n和 S_2 = 1 + 1/2 = 1.5，大于 1。\n\n>>> find_min_n_greater_than_k(3)\n11\n和 S_10 = 1 + 1/2 + 1/3 + ... + 1/10 小于或等于 3，但和 S_11 超过 3。",
      "fr": "Calculer le plus petit entier positif n tel que la somme de la série harmonique\njusqu'à 1/n soit supérieure à un entier positif donné k.\n\nLa série harmonique est définie comme S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Un entier positif représentant la valeur seuil que la somme de la série harmonique doit dépasser.\n\nReturns:\n- int: Le plus petit entier n pour lequel la somme de la série harmonique S_n dépasse le seuil k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nLa somme S_2 = 1 + 1/2 = 1.5, qui est supérieure à 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nLa somme S_10 = 1 + 1/2 + 1/3 + ... + 1/10 est inférieure ou égale à 3, mais la somme S_11 dépasse 3.",
      "de": "Berechne die kleinste positive ganze Zahl n, so dass die Summe der harmonischen Reihe\nbis 1/n größer als eine gegebene positive ganze Zahl k ist.\n\nDie harmonische Reihe ist definiert als S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Eine positive ganze Zahl, die den Schwellenwert darstellt, den die Summe der harmonischen Reihe überschreiten muss.\n\nReturns:\n- int: Die kleinste ganze Zahl n, für die die Summe der harmonischen Reihe S_n den Schwellenwert k überschreitet.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nDie Summe S_2 = 1 + 1/2 = 1.5, die größer als 1 ist.\n\n>>> find_min_n_greater_than_k(3)\n11\nDie Summe S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ist kleiner oder gleich 3, aber die Summe S_11 überschreitet 3.",
      "ha": "Lissafi mafi ƙarancin lamba mai kyau n wanda hakan jimillar jerin harmonic\nhar zuwa 1/n ya fi wani lamba mai kyau k.\n\nHarmonic series ana ayyana shi azaman S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Wani cikakken lamba mai kyau wanda ke wakiltar ƙimar ƙofa da jumlar jerin harmonic dole ne ta wuce.\n\nReturns:\n- int: Mafi ƙarancin lamba n wanda jumlar jerin harmonic S_n ta wuce ƙimar ƙofa k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nJumlar S_2 = 1 + 1/2 = 1.5, wanda ya fi 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nJumlar S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ya yi ƙasa ko daidai da 3, amma jumlar S_11 ta wuce 3.",
      "hi": "सबसे छोटा धनात्मक पूर्णांक n गणना करें ताकि हार्मोनिक श्रेणी का योग\n1/n तक दिए गए धनात्मक पूर्णांक k से अधिक हो।\n\nहरमोनिक श्रेणी को S_n = 1 + 1/2 + 1/3 + ... + 1/n के रूप में परिभाषित किया गया है।\n\nArgs:\n- k (int): एक धनात्मक पूर्णांक जो उस सीमा मान का प्रतिनिधित्व करता है जिसे हरमोनिक श्रेणी का योग पार करना चाहिए।\n\nReturns:\n- int: सबसे छोटा पूर्णांक n जिसके लिए हरमोनिक श्रेणी का योग S_n सीमा k को पार कर जाता है।\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nयोग S_2 = 1 + 1/2 = 1.5 है, जो 1 से अधिक है।\n\n>>> find_min_n_greater_than_k(3)\n11\nयोग S_10 = 1 + 1/2 + 1/3 + ... + 1/10, 3 से कम या बराबर है, लेकिन योग S_11, 3 को पार कर जाता है।",
      "hu": "Számítsd ki a legkisebb pozitív egész számot n, amelyre a harmonikus sorozat\n1/n-ig terjedő összege nagyobb, mint egy adott pozitív egész szám k.\n\nA harmonikus sorozatot így definiáljuk: S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): Egy pozitív egész szám, amely a küszöbértéket jelenti, amelyet a harmonikus sorozat összegének meg kell haladnia.\n\nReturns:\n- int: A legkisebb egész szám n, amelyre a harmonikus sorozat összege S_n meghaladja a k küszöbértéket.\n\nPéldák:\n>>> find_min_n_greater_than_k(1)\n2\nAz összeg S_2 = 1 + 1/2 = 1.5, amely nagyobb, mint 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nAz összeg S_10 = 1 + 1/2 + 1/3 + ... + 1/10 kisebb vagy egyenlő, mint 3, de az összeg S_11 meghaladja a 3-at."
    },
    "docstring_bertscore": {
      "sq": "0.9719059175368064",
      "hy": "0.9775561573557249",
      "bn": "0.981513669067464",
      "bg": "0.9775561573557249",
      "zh": "0.9786857683326703",
      "fr": "0.9822102658137534",
      "de": "0.9814628196899191",
      "ha": "0.9771892870419534",
      "hi": "0.9822102658137534",
      "hu": "0.9803004347001029"
    }
  },
  {
    "task_id": "Python/30",
    "prompt": {
      "en": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    - For num = 2 or num = 3, the function should return True, since both are prime numbers.\n    - For num = 1 or num = 0, the function should return False, as neither is considered prime.\n    - For num = 15, which is divisible by 3 and 5, the function should return False.\n    - For num = 29, which has no divisors other than 1 and itself, the function should return True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "sq": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Përcakton nëse një numër i dhënë është numër i thjeshtë.\n\n    Një numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka pjesëtues pozitivë përveç 1 dhe vetvetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) të cilët janë të thjeshtë. Më pas kontrollon për pjesëtueshmëri me 2 dhe 3. Për numrat më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar për faktorë deri te rrënja katrore e numrit.\n\n    Args:\n    num (int): Numri i plotë për të kontrolluar për thjeshtësi.\n\n    Returns:\n    bool: True nëse `num` është numër i thjeshtë, False përndryshe.\n\n    Rastet:\n    - Për num = 2 ose num = 3, funksioni duhet të kthejë True, pasi të dy janë numra të thjeshtë.\n    - Për num = 1 ose num = 0, funksioni duhet të kthejë False, pasi asnjëri nuk konsiderohet i thjeshtë.\n    - Për num = 15, i cili është i pjesëtueshëm me 3 dhe 5, funksioni duhet të kthejë False.\n    - Për num = 29, i cili nuk ka pjesëtues përveç 1 dhe vetvetes, funksioni duhet të kthejë True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "hy": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Սահմանել՝ արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\n    Պարզ թիվը 1-ից մեծ բնական թիվ է, որը չունի դրական բաժանարարներ 1-ից և իրենից բացի: Ֆունկցիան ստուգում է պարզությունը՝ ոչ պարզ թվերը բացառելով մի քանի թեստերի միջոցով: Նախ, այն մշակում է եզակի դեպքերը 1-ից փոքր կամ հավասար թվերի համար, որոնք պարզ չեն, և փոքր թվերի (2 և 3) համար, որոնք պարզ են: Այնուհետև ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ գործոնները ստուգելու համար մինչև թվի քառակուսի արմատը:\n\n    Արգումենտներ:\n    num (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\n    Վերադարձնում է:\n    bool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\n    Դեպքեր:\n    - num = 2 կամ num = 3 դեպքում, ֆունկցիան պետք է վերադարձնի True, քանի որ երկուսն էլ պարզ թվեր են:\n    - num = 1 կամ num = 0 դեպքում, ֆունկցիան պետք է վերադարձնի False, քանի որ ոչ մեկը պարզ չի համարվում:\n    - num = 15 դեպքում, որը բաժանվում է 3-ի և 5-ի վրա, ֆունկցիան պետք է վերադարձնի False:\n    - num = 29 դեպքում, որը չունի բաժանարարներ 1-ից և իրենից բացի, ֆունկցիան պետք է վերադարձնի True:\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "bn": "def is_prime(num: int) -> bool:\n    \"\"\"\n    প্রদত্ত পূর্ণসংখ্যাটি একটি মৌলিক সংখ্যা কিনা তা নির্ধারণ করুন।\n\n    একটি মৌলিক সংখ্যা হল ১ এর চেয়ে বড় একটি স্বাভাবিক সংখ্যা যার ১ এবং নিজে ছাড়া অন্য কোনো ধনাত্মক গুণনীয়ক নেই। ফাংশনটি বিভিন্ন পরীক্ষা ব্যবহার করে অমৌলিক সংখ্যা বাদ দিয়ে মৌলিকতা পরীক্ষা করে। প্রথমে, এটি ১ বা তার চেয়ে কম সংখ্যার জন্য প্রান্তিক কেসগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (২ এবং ৩) যা মৌলিক। তারপর এটি ২ এবং ৩ দ্বারা বিভাজ্যতা পরীক্ষা করে। বড় সংখ্যার জন্য, এটি সংখ্যার বর্গমূল পর্যন্ত গুণনীয়ক পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\n    Args:\n    num (int): মৌলিকতা পরীক্ষা করার জন্য পূর্ণসংখ্যা।\n\n    Returns:\n    bool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\n    কেসসমূহ:\n    - num = 2 বা num = 3 এর জন্য, ফাংশনটি True ফেরত দেবে, যেহেতু উভয়ই মৌলিক সংখ্যা।\n    - num = 1 বা num = 0 এর জন্য, ফাংশনটি False ফেরত দেবে, যেহেতু এদের কোনোটিই মৌলিক নয়।\n    - num = 15 এর জন্য, যা ৩ এবং ৫ দ্বারা বিভাজ্য, ফাংশনটি False ফেরত দেবে।\n    - num = 29 এর জন্য, যার ১ এবং নিজে ছাড়া অন্য কোনো গুণনীয়ক নেই, ফাংশনটি True ফেরত দেবে।\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "bg": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Определя дали дадено цяло число е просто число.\n\n    Просто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото себе си. Функцията проверява за простота, като елиминира непростите числа чрез няколко теста. Първо, тя обработва гранични случаи за числа, по-малки или равни на 1, които не са прости, и малки числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за фактори до квадратния корен на числото.\n\n    Args:\n    num (int): Цялото число, което да се провери за простота.\n\n    Returns:\n    bool: True, ако `num` е просто число, False в противен случай.\n\n    Случаи:\n    - За num = 2 или num = 3, функцията трябва да върне True, тъй като и двете са прости числа.\n    - За num = 1 или num = 0, функцията трябва да върне False, тъй като нито едно от тях не се счита за просто.\n    - За num = 15, което е делимо на 3 и 5, функцията трябва да върне False.\n    - За num = 29, което няма делители, различни от 1 и самото себе си, функцията трябва да върне True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "zh": "def is_prime(num: int) -> bool:\n    \"\"\"\n    确定给定的整数是否为质数。\n\n    质数是大于1的自然数，除了1和它本身外没有其他正除数。该函数通过使用几个测试来消除非质数来检查质数性。首先，它处理小于或等于1的数字的边缘情况，这些数字不是质数，而小数字（2和3）是质数。然后它检查是否能被2和3整除。对于较大的数字，它使用6k +/- 1优化来测试因数，直到数字的平方根。\n\n    参数:\n    num (int): 要检查是否为质数的整数。\n\n    返回:\n    bool: 如果`num`是质数则返回True，否则返回False。\n\n    情况:\n    - 对于num = 2或num = 3，函数应返回True，因为它们都是质数。\n    - 对于num = 1或num = 0，函数应返回False，因为它们都不被认为是质数。\n    - 对于num = 15，它能被3和5整除，函数应返回False。\n    - 对于num = 29，它除了1和它本身外没有其他除数，函数应返回True。\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "fr": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Déterminer si un entier donné est un nombre premier.\n\n    Un nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle gère les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\n    Args:\n    num (int): L'entier à vérifier pour la primalité.\n\n    Returns:\n    bool: True si `num` est un nombre premier, False sinon.\n\n    Cas :\n    - Pour num = 2 ou num = 3, la fonction doit retourner True, car les deux sont des nombres premiers.\n    - Pour num = 1 ou num = 0, la fonction doit retourner False, car aucun n'est considéré comme premier.\n    - Pour num = 15, qui est divisible par 3 et 5, la fonction doit retourner False.\n    - Pour num = 29, qui n'a pas de diviseurs autres que 1 et lui-même, la fonction doit retourner True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "de": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Bestimmen, ob eine gegebene ganze Zahl eine Primzahl ist.\n\n    Eine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion prüft die Primalität, indem sie nicht-primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Sonderfälle für Zahlen kleiner oder gleich 1, die nicht prim sind, und kleine Zahlen (2 und 3), die prim sind. Dann prüft sie die Teilbarkeit durch 2 und 3. Für größere Zahlen verwendet sie eine 6k +/- 1 Optimierung, um nach Faktoren bis zur Quadratwurzel der Zahl zu testen.\n\n    Args:\n    num (int): Die ganze Zahl, die auf Primalität überprüft werden soll.\n\n    Returns:\n    bool: True, wenn `num` eine Primzahl ist, False andernfalls.\n\n    Fälle:\n    - Für num = 2 oder num = 3 sollte die Funktion True zurückgeben, da beide Primzahlen sind.\n    - Für num = 1 oder num = 0 sollte die Funktion False zurückgeben, da keine als prim betrachtet wird.\n    - Für num = 15, das durch 3 und 5 teilbar ist, sollte die Funktion False zurückgeben.\n    - Für num = 29, das keine Teiler außer 1 und sich selbst hat, sollte die Funktion True zurückgeben.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "ha": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Tantance ko wani lamba cikakken lamba ne.\n\n    Lamba cikakke ita ce lamba ta halitta wadda ta fi 1 girma kuma ba ta da masu rarrabewa masu kyau sai dai 1 da kanta. Aikin yana duba cikakken lamba ta hanyar kawar da lambobi marasa cikakke ta amfani da gwaje-gwaje da dama. Da farko, yana magance yanayi na musamman ga lambobi ƙasa ko daidai da 1, waɗanda ba cikakke ba ne, da ƙananan lambobi (2 da 3) waɗanda cikakke ne. Sannan yana duba rarrabuwa da 2 da 3. Ga manyan lambobi, yana amfani da ingantaccen 6k +/- 1 don gwada abubuwan har zuwa tushen murabba'in lambar.\n\n    Args:\n    num (int): Lambar da za a duba cikakken lamba.\n\n    Returns:\n    bool: Gaskiya idan `num` cikakken lamba ne, Karya idan ba haka ba.\n\n    Yanayi:\n    - Ga num = 2 ko num = 3, aikin ya kamata ya dawo da Gaskiya, tunda dukansu lambobi ne cikakke.\n    - Ga num = 1 ko num = 0, aikin ya kamata ya dawo da Karya, saboda babu ɗayansu da ake ɗauka cikakke.\n    - Ga num = 15, wanda za a iya rarrabashi da 3 da 5, aikin ya kamata ya dawo da Karya.\n    - Ga num = 29, wanda ba shi da masu rarrabewa sai dai 1 da kanta, aikin ya kamata ya dawo da Gaskiya.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "hi": "def is_prime(num: int) -> bool:\n    \"\"\"\n    यह निर्धारित करें कि दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं।\n\n    एक अभाज्य संख्या एक प्राकृतिक संख्या है जो 1 से बड़ी होती है और जिसका कोई भी धनात्मक भाजक 1 और स्वयं के अलावा नहीं होता। यह फ़ंक्शन अभाज्यता की जाँच कई परीक्षणों का उपयोग करके गैर-अभाज्य संख्याओं को समाप्त करके करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं हैं, और छोटी संख्याएँ (2 और 3) जो अभाज्य हैं। फिर यह 2 और 3 से विभाज्यता की जाँच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक कारकों के परीक्षण के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\n    Args:\n    num (int): अभाज्यता की जाँच के लिए पूर्णांक।\n\n    Returns:\n    bool: यदि `num` एक अभाज्य संख्या है तो True, अन्यथा False।\n\n    मामले:\n    - num = 2 या num = 3 के लिए, फ़ंक्शन को True लौटाना चाहिए, क्योंकि दोनों अभाज्य संख्याएँ हैं।\n    - num = 1 या num = 0 के लिए, फ़ंक्शन को False लौटाना चाहिए, क्योंकि इनमें से कोई भी अभाज्य नहीं माना जाता है।\n    - num = 15 के लिए, जो 3 और 5 से विभाज्य है, फ़ंक्शन को False लौटाना चाहिए।\n    - num = 29 के लिए, जिसका कोई भी भाजक 1 और स्वयं के अलावा नहीं है, फ़ंक्शन को True लौटाना चाहिए।\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "hu": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Határozza meg, hogy egy adott egész szám prím szám-e.\n\n    A prím szám olyan 1-nél nagyobb természetes szám, amelynek nincsenek pozitív osztói 1-en és önmagán kívül. A függvény a nem prím számok kizárásával ellenőrzi a prím tulajdonságot több teszt segítségével. Először kezeli azokat a szélsőséges eseteket, amikor a szám kisebb vagy egyenlő 1-gyel, amelyek nem prímek, és a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén 6k +/- 1 optimalizálást használ, hogy tesztelje az osztókat a szám négyzetgyökéig.\n\n    Args:\n    num (int): Az egész szám, amelynek prím tulajdonságát ellenőrizzük.\n\n    Returns:\n    bool: True, ha `num` prím szám, különben False.\n\n    Esetek:\n    - Ha num = 2 vagy num = 3, a függvénynek True-t kell visszaadnia, mivel mindkettő prím szám.\n    - Ha num = 1 vagy num = 0, a függvénynek False-t kell visszaadnia, mivel egyik sem tekinthető prímnek.\n    - Ha num = 15, amely osztható 3-mal és 5-tel, a függvénynek False-t kell visszaadnia.\n    - Ha num = 29, amelynek nincsenek osztói 1-en és önmagán kívül, a függvénynek True-t kell visszaadnia.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True"
    },
    "prompt_bertscore": {
      "sq": "0.9912612563863701",
      "hy": "0.9860464143626801",
      "bn": "0.982402341392214",
      "bg": "0.9889201987154929",
      "zh": "0.9725333909104956",
      "fr": "0.990771036605976",
      "de": "0.9908057969226571",
      "ha": "0.9756876413613297",
      "hi": "0.988145937490219",
      "hu": "0.9592803746270858"
    },
    "canonical_solution": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
    "instruction": {
      "en": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nBa da takaitaccen bayanin yanayi na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में वर्णन (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8803615447862092",
      "bn": "0.8958006870432891",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.8317199439264806",
      "hi": "0.8964889413135749",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_is_prime():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_is_prime()",
    "entry_point": "is_prime",
    "signature": "def is_prime(num: int) -> bool:",
    "docstring": {
      "en": "Determine whether a given integer is a prime number.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\nArgs:\nnum (int): The integer to check for primality.\n\nReturns:\nbool: True if `num` is a prime number, False otherwise.\n\nCases:\n- For num = 2 or num = 3, the function should return True, since both are prime numbers.\n- For num = 1 or num = 0, the function should return False, as neither is considered prime.\n- For num = 15, which is divisible by 3 and 5, the function should return False.\n- For num = 29, which has no divisors other than 1 and itself, the function should return True.",
      "sq": "Përcaktoni nëse një numër i dhënë i plotë është një numër i thjeshtë.\n\nNjë numër i thjeshtë është një numër natyror më i madh se 1 që nuk ka ndarës pozitivë përveç 1 dhe vetes. Funksioni kontrollon për thjeshtësinë duke eliminuar numrat jo të thjeshtë duke përdorur disa teste. Së pari, trajton rastet e veçanta për numrat më të vegjël ose të barabartë me 1, të cilët nuk janë të thjeshtë, dhe numrat e vegjël (2 dhe 3) të cilët janë të thjeshtë. Më pas kontrollon për pjesëtueshmëri nga 2 dhe 3. Për numra më të mëdhenj, përdor një optimizim 6k +/- 1 për të testuar për faktorë deri në rrënjën katrore të numrit.\n\nArgumentet:\nnum (int): Numri i plotë për të kontrolluar për thjeshtësi.\n\nKthen:\nbool: True nëse `num` është një numër i thjeshtë, False përndryshe.\n\nRastet:\n- Për num = 2 ose num = 3, funksioni duhet të kthejë True, pasi të dy janë numra të thjeshtë.\n- Për num = 1 ose num = 0, funksioni duhet të kthejë False, pasi asnjëri nuk konsiderohet i thjeshtë.\n- Për num = 15, i cili është i pjesëtueshëm nga 3 dhe 5, funksioni duhet të kthejë False.\n- Për num = 29, i cili nuk ka ndarës përveç 1 dhe vetes, funksioni duhet të kthejë True.",
      "hy": "Սահմանել, արդյոք տրված ամբողջ թիվը պարզ թիվ է:\n\nՊարզ թիվը բնական թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ 1-ից և իրենից բացի: Ֆունկցիան ստուգում է պարզությունը՝ ոչ պարզ թվերը բացառելով մի քանի թեստերի միջոցով: Նախ, այն մշակում է եզակի դեպքերը 1-ից փոքր կամ հավասար թվերի համար, որոնք պարզ չեն, և փոքր թվերի (2 և 3) համար, որոնք պարզ են: Այնուհետև ստուգում է բաժանելիությունը 2-ով և 3-ով: Ավելի մեծ թվերի համար այն օգտագործում է 6k +/- 1 օպտիմալացում՝ մինչև թվի քառակուսի արմատը գործոններ ստուգելու համար:\n\nԱրձագանքներ:\nnum (int): Ամբողջ թիվը, որը պետք է ստուգել պարզության համար:\n\nՎերադարձնում է:\nbool: True, եթե `num`-ը պարզ թիվ է, False՝ հակառակ դեպքում:\n\nԴեպքեր:\n- num = 2 կամ num = 3-ի համար ֆունկցիան պետք է վերադարձնի True, քանի որ երկուսն էլ պարզ թվեր են:\n- num = 1 կամ num = 0-ի համար ֆունկցիան պետք է վերադարձնի False, քանի որ ոչ մեկը չի համարվում պարզ:\n- num = 15-ի համար, որը բաժանվում է 3-ի և 5-ի վրա, ֆունկցիան պետք է վերադարձնի False:\n- num = 29-ի համար, որը չունի բաժանարարներ 1-ից և իրենից բացի, ֆունկցիան պետք է վերադարձնի True:",
      "bn": "একটি প্রদত্ত পূর্ণসংখ্যা একটি মৌলিক সংখ্যা কিনা তা নির্ধারণ করুন।\n\nএকটি মৌলিক সংখ্যা হল ১ এর চেয়ে বড় একটি প্রাকৃতিক সংখ্যা যার ১ এবং তার নিজের বাইরে অন্য কোনো ধনাত্মক গুণনীয়ক নেই। ফাংশনটি বিভিন্ন পরীক্ষার মাধ্যমে অমৌলিক সংখ্যা বাদ দিয়ে মৌলিকতা যাচাই করে। প্রথমে, এটি ১ বা তার চেয়ে কম সংখ্যার জন্য প্রান্তিক কেসগুলি পরিচালনা করে, যা মৌলিক নয়, এবং ছোট সংখ্যা (২ এবং ৩) যা মৌলিক। তারপর এটি ২ এবং ৩ দ্বারা বিভাজ্যতা পরীক্ষা করে। বড় সংখ্যার জন্য, এটি সংখ্যাটির বর্গমূল পর্যন্ত গুণনীয়ক পরীক্ষা করার জন্য 6k +/- 1 অপ্টিমাইজেশন ব্যবহার করে।\n\nআর্গস:\nnum (int): যে পূর্ণসংখ্যাটি মৌলিকতা যাচাই করতে হবে।\n\nরিটার্নস:\nbool: যদি `num` একটি মৌলিক সংখ্যা হয় তবে True, অন্যথায় False।\n\nকেসসমূহ:\n- num = 2 বা num = 3 এর জন্য, ফাংশনটি True রিটার্ন করবে, যেহেতু উভয়ই মৌলিক সংখ্যা।\n- num = 1 বা num = 0 এর জন্য, ফাংশনটি False রিটার্ন করবে, যেহেতু কোনোটিই মৌলিক বলে বিবেচিত নয়।\n- num = 15 এর জন্য, যা ৩ এবং ৫ দ্বারা বিভাজ্য, ফাংশনটি False রিটার্ন করবে।\n- num = 29 এর জন্য, যার ১ এবং তার নিজের বাইরে অন্য কোনো গুণনীয়ক নেই, ফাংশনটি True রিটার্ন করবে।",
      "bg": "Определя дали дадено цяло число е просто число.\n\nПросто число е естествено число, по-голямо от 1, което няма положителни делители, различни от 1 и самото себе си. Функцията проверява за простота, като елиминира непростите числа чрез няколко теста. Първо, тя обработва гранични случаи за числа, по-малки или равни на 1, които не са прости, и малки числа (2 и 3), които са прости. След това проверява за делимост на 2 и 3. За по-големи числа използва оптимизация 6k +/- 1, за да тества за фактори до квадратния корен на числото.\n\nАргументи:\nnum (int): Цялото число, което да се провери за простота.\n\nВръща:\nbool: True, ако `num` е просто число, False в противен случай.\n\nСлучаи:\n- За num = 2 или num = 3, функцията трябва да върне True, тъй като и двете са прости числа.\n- За num = 1 или num = 0, функцията трябва да върне False, тъй като нито едно от тях не се счита за просто.\n- За num = 15, което е делимо на 3 и 5, функцията трябва да върне False.\n- За num = 29, което няма делители, различни от 1 и самото себе си, функцията трябва да върне True.",
      "zh": "确定给定的整数是否是质数。\n\n质数是大于1的自然数，除了1和它本身之外没有其他正除数。该函数通过使用多个测试来消除非质数，从而检查质数性。首先，它处理小于或等于1的数字的边界情况，这些数字不是质数，以及小数字（2和3），它们是质数。然后，它检查是否能被2和3整除。对于较大的数字，它使用6k +/- 1优化来测试因子，直到数字的平方根。\n\n参数：\nnum (int): 要检查是否为质数的整数。\n\n返回：\nbool: 如果 `num` 是质数则返回 True，否则返回 False。\n\n情况：\n- 对于 num = 2 或 num = 3，函数应返回 True，因为它们都是质数。\n- 对于 num = 1 或 num = 0，函数应返回 False，因为它们都不被认为是质数。\n- 对于 num = 15，它能被3和5整除，函数应返回 False。\n- 对于 num = 29，它除了1和它本身之外没有其他除数，函数应返回 True。",
      "fr": "Déterminer si un entier donné est un nombre premier.\n\nUn nombre premier est un nombre naturel supérieur à 1 qui n'a pas de diviseurs positifs autres que 1 et lui-même. La fonction vérifie la primalité en éliminant les nombres non premiers à l'aide de plusieurs tests. Tout d'abord, elle gère les cas particuliers pour les nombres inférieurs ou égaux à 1, qui ne sont pas premiers, et les petits nombres (2 et 3) qui sont premiers. Elle vérifie ensuite la divisibilité par 2 et 3. Pour les nombres plus grands, elle utilise une optimisation 6k +/- 1 pour tester les facteurs jusqu'à la racine carrée du nombre.\n\nArgs:\nnum (int): L'entier à vérifier pour la primalité.\n\nReturns:\nbool: True si `num` est un nombre premier, False sinon.\n\nCas:\n- Pour num = 2 ou num = 3, la fonction doit retourner True, car les deux sont des nombres premiers.\n- Pour num = 1 ou num = 0, la fonction doit retourner False, car aucun n'est considéré comme premier.\n- Pour num = 15, qui est divisible par 3 et 5, la fonction doit retourner False.\n- Pour num = 29, qui n'a pas de diviseurs autres que 1 et lui-même, la fonction doit retourner True.",
      "de": "Bestimmen, ob eine gegebene ganze Zahl eine Primzahl ist.\n\nEine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Die Funktion überprüft die Primalität, indem sie nicht-primzahlen durch mehrere Tests eliminiert. Zuerst behandelt sie Randfälle für Zahlen kleiner oder gleich 1, die nicht prim sind, und kleine Zahlen (2 und 3), die prim sind. Dann überprüft sie die Teilbarkeit durch 2 und 3. Für größere Zahlen verwendet sie eine 6k +/- 1 Optimierung, um Faktoren bis zur Quadratwurzel der Zahl zu testen.\n\nArgs:\nnum (int): Die ganze Zahl, die auf Primalität überprüft werden soll.\n\nReturns:\nbool: True, wenn `num` eine Primzahl ist, False andernfalls.\n\nFälle:\n- Für num = 2 oder num = 3 sollte die Funktion True zurückgeben, da beide Primzahlen sind.\n- Für num = 1 oder num = 0 sollte die Funktion False zurückgeben, da keine von beiden als prim betrachtet wird.\n- Für num = 15, das durch 3 und 5 teilbar ist, sollte die Funktion False zurückgeben.\n- Für num = 29, das keine Teiler außer 1 und sich selbst hat, sollte die Funktion True zurückgeben.",
      "ha": "Tantance ko wani lamba cikakken lamba ne.\n\nLambar farko lamba ce ta halitta wadda ta fi 1 girma kuma ba ta da masu raba lamba masu kyau sai dai 1 da kanta. Aikin yana duba ko lamba ce ta farko ta hanyar kawar da lambobi marasa farko ta amfani da gwaje-gwaje da dama. Da farko, yana magance lokuta na musamman ga lambobi ƙasa da ko daidai da 1, waɗanda ba su da farko, da ƙananan lambobi (2 da 3) waɗanda suke da farko. Sannan yana duba rarrabuwa da 2 da 3. Ga manyan lambobi, yana amfani da ingantaccen 6k +/- 1 don gwada abubuwan har zuwa tushen murabba'in lambar.\n\nArgs:\nnum (int): Lambar da za a duba ko tana da farko.\n\nReturns:\nbool: True idan `num` lamba ce ta farko, False in ba haka ba.\n\nCases:\n- Ga num = 2 ko num = 3, aikin ya kamata ya dawo da True, domin dukansu lambobi ne na farko.\n- Ga num = 1 ko num = 0, aikin ya kamata ya dawo da False, domin babu ɗayansu da ake ɗauka a matsayin farko.\n- Ga num = 15, wanda za a iya raba shi da 3 da 5, aikin ya kamata ya dawo da False.\n- Ga num = 29, wanda ba shi da masu raba lamba sai dai 1 da kanta, aikin ya kamata ya dawo da True.",
      "hi": "दिया गया पूर्णांक एक अभाज्य संख्या है या नहीं, यह निर्धारित करें।\n\nएक अभाज्य संख्या 1 से बड़ी प्राकृतिक संख्या है जिसका कोई अन्य सकारात्मक भाजक नहीं होता सिवाय 1 और स्वयं के। यह फ़ंक्शन अभाज्यता की जाँच कई परीक्षणों का उपयोग करके गैर-अभाज्य संख्याओं को समाप्त करके करता है। सबसे पहले, यह 1 से कम या बराबर संख्याओं के लिए किनारे के मामलों को संभालता है, जो अभाज्य नहीं हैं, और छोटी संख्याएँ (2 और 3) जो अभाज्य हैं। फिर यह 2 और 3 से विभाज्यता की जाँच करता है। बड़ी संख्याओं के लिए, यह संख्या के वर्गमूल तक के गुणकों की जाँच के लिए 6k +/- 1 अनुकूलन का उपयोग करता है।\n\nआर्ग्स:\nnum (int): अभाज्यता की जाँच के लिए पूर्णांक।\n\nवापसी:\nbool: यदि `num` एक अभाज्य संख्या है तो True, अन्यथा False।\n\nमामले:\n- यदि num = 2 या num = 3 है, तो फ़ंक्शन को True लौटाना चाहिए, क्योंकि दोनों अभाज्य संख्याएँ हैं।\n- यदि num = 1 या num = 0 है, तो फ़ंक्शन को False लौटाना चाहिए, क्योंकि इनमें से कोई भी अभाज्य नहीं माना जाता।\n- यदि num = 15 है, जो 3 और 5 से विभाज्य है, तो फ़ंक्शन को False लौटाना चाहिए।\n- यदि num = 29 है, जिसका कोई अन्य भाजक नहीं है सिवाय 1 और स्वयं के, तो फ़ंक्शन को True लौटाना चाहिए।",
      "hu": "Határozza meg, hogy egy adott egész szám prímszám-e.\n\nA prímszám olyan 1-nél nagyobb természetes szám, amelynek nincsenek pozitív osztói 1-en és önmagán kívül. A függvény több teszt segítségével szűri ki a nem prím számokat. Először kezeli azokat a szélsőséges eseteket, amikor a szám kisebb vagy egyenlő 1-gyel, amelyek nem prímek, valamint a kis számokat (2 és 3), amelyek prímek. Ezután ellenőrzi az oszthatóságot 2-vel és 3-mal. Nagyobb számok esetén egy 6k +/- 1 optimalizálást használ, hogy tesztelje az osztókat a szám négyzetgyökéig.\n\nArgs:\nnum (int): Az egész szám, amelyet ellenőrizni kell, hogy prím-e.\n\nReturns:\nbool: True, ha `num` prímszám, különben False.\n\nEsetek:\n- Ha num = 2 vagy num = 3, a függvénynek True-t kell visszaadnia, mivel mindkettő prímszám.\n- Ha num = 1 vagy num = 0, a függvénynek False-t kell visszaadnia, mivel egyik sem tekinthető prímszámnak.\n- Ha num = 15, amely osztható 3-mal és 5-tel, a függvénynek False-t kell visszaadnia.\n- Ha num = 29, amelynek nincsenek osztói 1-en és önmagán kívül, a függvénynek True-t kell visszaadnia."
    },
    "docstring_bertscore": {
      "sq": "0.9911992837074872",
      "hy": "0.9759089156058025",
      "bn": "0.9823934030250675",
      "bg": "0.9830226640721861",
      "zh": "0.9685524408137944",
      "fr": "0.9897252476498273",
      "de": "0.9855234205694153",
      "ha": "0.9753360655868979",
      "hi": "0.9720952122899327",
      "hu": "0.9584212982291099"
    }
  },
  {
    "task_id": "Python/31",
    "prompt": {
      "en": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    - Case 1: n = 234, rules = [(2, 5), (3, 6)]\n              This case should return 4 because the following unique numbers can be generated:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n    - Case 2: n = 100, rules = [(1, 9)]\n              This case should return 2 because the following unique numbers can be generated:\n              100 (original) and 900 (1 -> 9).\n\n    - Case 3: n = 8, rules = [(8, 3), (8, 5)]\n              This case should return 3 because the following unique numbers can be generated:\n              8 (original), 3 (8 -> 3), and 5 (8 -> 5).\n    \"\"\"",
      "sq": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Gjenero të gjitha numrat unikë nga numri i dhënë duke aplikuar rregullat e transformimit.\n\n    Çdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim në gjerësi\n    (BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\n    e numrave unikë që mund të gjenerohen nga numri origjinal, duke përfshirë vetë numrin.\n\n    Argumentet:\n    - n (int): Numri origjinal i plotë për t'u transformuar.\n    - rules (list of tuples): Një listë e rregullave të transformimit, ku çdo rregull përfaqësohet\n                              si një tuple (x, y) që tregon se shifra x mund të transformohet në y.\n\n    Kthen:\n    - int: Numri total i numrave unikë që mund të gjenerohen.\n\n    Rastet:\n    - Rasti 1: n = 234, rules = [(2, 5), (3, 6)]\n              Ky rast duhet të kthejë 4 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n              234 (origjinal), 534 (2 -> 5), 264 (3 -> 6), dhe 564 (2 -> 5, 3 -> 6).\n\n    - Rasti 2: n = 100, rules = [(1, 9)]\n              Ky rast duhet të kthejë 2 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n              100 (origjinal) dhe 900 (1 -> 9).\n\n    - Rasti 3: n = 8, rules = [(8, 3), (8, 5)]\n              Ky rast duhet të kthejë 3 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n              8 (origjinal), 3 (8 -> 3), dhe 5 (8 -> 5).\n    \"\"\"",
      "hy": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Տրված թվից գեներացնել բոլոր եզակի թվերը՝ կիրառելով փոխակերպման կանոնները:\n\n    Յուրաքանչյուր կանոն թույլ է տալիս մեկ թվանշանը փոխակերպել մեկ այլ թվանշանի: Լայնությամբ առաջին որոնում\n    (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար: Ֆունկցիան վերադարձնում է\n    եզակի թվերի քանակը, որոնք կարող են գեներացվել սկզբնական թվից, ներառյալ ինքը՝ թիվը:\n\n    Արգումենտներ:\n    - n (int): Սկզբնական ամբողջ թիվը, որը պետք է փոխակերպել:\n    - rules (list of tuples): Փոխակերպման կանոնների ցուցակ, որտեղ յուրաքանչյուր կանոն ներկայացված է\n                              որպես զույգ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի:\n\n    Վերադարձնում է:\n    - int: Եզակի թվերի ընդհանուր քանակը, որոնք կարող են գեներացվել:\n\n    Դեպքեր:\n    - Դեպք 1: n = 234, rules = [(2, 5), (3, 6)]\n              Այս դեպքը պետք է վերադարձնի 4, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը:\n              234 (սկզբնական), 534 (2 -> 5), 264 (3 -> 6), և 564 (2 -> 5, 3 -> 6):\n\n    - Դեպք 2: n = 100, rules = [(1, 9)]\n              Այս դեպքը պետք է վերադարձնի 2, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը:\n              100 (սկզբնական) և 900 (1 -> 9):\n\n    - Դեպք 3: n = 8, rules = [(8, 3), (8, 5)]\n              Այս դեպքը պետք է վերադարձնի 3, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը:\n              8 (սկզբնական), 3 (8 -> 3), և 5 (8 -> 5):\n    \"\"\"",
      "bn": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    প্রদত্ত সংখ্যাটি থেকে রূপান্তর নিয়ম প্রয়োগ করে সমস্ত অনন্য সংখ্যা তৈরি করুন।\n\n    প্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। সমস্ত সম্ভাব্য রূপান্তরগুলি অন্বেষণ করতে একটি ব্রেডথ-ফার্স্ট সার্চ\n    (BFS) ব্যবহার করা হয়। ফাংশনটি মূল সংখ্যাটি সহ মূল সংখ্যাটি থেকে তৈরি করা যেতে পারে এমন অনন্য সংখ্যার গণনা প্রদান করে।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): রূপান্তর করার জন্য মূল পূর্ণসংখ্যা সংখ্যা।\n    - rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) হিসাবে উপস্থাপিত\n                              হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তরিত করা যেতে পারে।\n\n    রিটার্নস:\n    - int: তৈরি করা যেতে পারে এমন অনন্য সংখ্যার মোট গণনা।\n\n    কেসসমূহ:\n    - কেস 1: n = 234, rules = [(2, 5), (3, 6)]\n              এই ক্ষেত্রে 4 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n              234 (মূল), 534 (2 -> 5), 264 (3 -> 6), এবং 564 (2 -> 5, 3 -> 6)।\n\n    - কেস 2: n = 100, rules = [(1, 9)]\n              এই ক্ষেত্রে 2 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n              100 (মূল) এবং 900 (1 -> 9)।\n\n    - কেস 3: n = 8, rules = [(8, 3), (8, 5)]\n              এই ক্ষেত্রে 3 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n              8 (মূল), 3 (8 -> 3), এবং 5 (8 -> 5)।\n    \"\"\"",
      "bg": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Генерира всички уникални числа от даденото число чрез прилагане на правила за трансформация.\n\n    Всяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина\n    (BFS), за да се изследват всички възможни трансформации. Функцията връща броя на уникалните числа,\n    които могат да бъдат генерирани от оригиналното число, включително самото число.\n\n    Аргументи:\n    - n (int): Оригиналното цяло число за трансформиране.\n    - rules (list of tuples): Списък с правила за трансформация, където всяко правило е представено\n                              като кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\n    Връща:\n    - int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\n    Примери:\n    - Пример 1: n = 234, rules = [(2, 5), (3, 6)]\n              Този пример трябва да върне 4, защото могат да бъдат генерирани следните уникални числа:\n              234 (оригинално), 534 (2 -> 5), 264 (3 -> 6) и 564 (2 -> 5, 3 -> 6).\n\n    - Пример 2: n = 100, rules = [(1, 9)]\n              Този пример трябва да върне 2, защото могат да бъдат генерирани следните уникални числа:\n              100 (оригинално) и 900 (1 -> 9).\n\n    - Пример 3: n = 8, rules = [(8, 3), (8, 5)]\n              Този пример трябва да върне 3, защото могат да бъдат генерирани следните уникални числа:\n              8 (оригинално), 3 (8 -> 3) и 5 (8 -> 5).\n    \"\"\"",
      "zh": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    通过应用转换规则从给定数字生成所有唯一数字。\n\n    每个规则允许将一个数字转换为另一个数字。使用广度优先搜索（BFS）来探索所有可能的转换。\n    该函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n    参数:\n    - n (int): 要转换的原始整数。\n    - rules (list of tuples): 转换规则的列表，其中每个规则表示为一个元组 (x, y)，\n                              表示数字 x 可以转换为 y。\n\n    返回:\n    - int: 可以生成的唯一数字的总数。\n\n    情况:\n    - 情况 1: n = 234, rules = [(2, 5), (3, 6)]\n              这种情况下应该返回 4，因为可以生成以下唯一数字：\n              234 (原始), 534 (2 -> 5), 264 (3 -> 6), 和 564 (2 -> 5, 3 -> 6)。\n\n    - 情况 2: n = 100, rules = [(1, 9)]\n              这种情况下应该返回 2，因为可以生成以下唯一数字：\n              100 (原始) 和 900 (1 -> 9)。\n\n    - 情况 3: n = 8, rules = [(8, 3), (8, 5)]\n              这种情况下应该返回 3，因为可以生成以下唯一数字：\n              8 (原始), 3 (8 -> 3), 和 5 (8 -> 5)。\n    \"\"\"",
      "fr": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\n    Chaque règle permet de transformer un chiffre en un autre. Une recherche en largeur\n    (BFS) est utilisée pour explorer toutes les transformations possibles. La fonction retourne le nombre\n    de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\n    Args:\n    - n (int): Le nombre entier original à transformer.\n    - rules (list of tuples): Une liste de règles de transformation, où chaque règle est représentée\n                              comme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\n    Returns:\n    - int: Le nombre total de nombres uniques qui peuvent être générés.\n\n    Cas:\n    - Cas 1: n = 234, rules = [(2, 5), (3, 6)]\n              Ce cas devrait retourner 4 car les nombres uniques suivants peuvent être générés :\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), et 564 (2 -> 5, 3 -> 6).\n\n    - Cas 2: n = 100, rules = [(1, 9)]\n              Ce cas devrait retourner 2 car les nombres uniques suivants peuvent être générés :\n              100 (original) et 900 (1 -> 9).\n\n    - Cas 3: n = 8, rules = [(8, 3), (8, 5)]\n              Ce cas devrait retourner 3 car les nombres uniques suivants peuvent être générés :\n              8 (original), 3 (8 -> 3), et 5 (8 -> 5).\n    \"\"\"",
      "de": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generiere alle einzigartigen Zahlen aus der gegebenen Zahl durch Anwendung von Transformationsregeln.\n\n    Jede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n    (BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\n    der einzigartigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich der Zahl selbst.\n\n    Argumente:\n    - n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n    - rules (list von Tupeln): Eine Liste von Transformationsregeln, wobei jede Regel als\n                               Tupel (x, y) dargestellt wird, das angibt, dass die Ziffer x in y transformiert werden kann.\n\n    Rückgaben:\n    - int: Die Gesamtanzahl der einzigartigen Zahlen, die generiert werden können.\n\n    Fälle:\n    - Fall 1: n = 234, rules = [(2, 5), (3, 6)]\n              Dieser Fall sollte 4 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), und 564 (2 -> 5, 3 -> 6).\n\n    - Fall 2: n = 100, rules = [(1, 9)]\n              Dieser Fall sollte 2 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n              100 (original) und 900 (1 -> 9).\n\n    - Fall 3: n = 8, rules = [(8, 3), (8, 5)]\n              Dieser Fall sollte 3 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n              8 (original), 3 (8 -> 3), und 5 (8 -> 5).\n    \"\"\"",
      "ha": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyi.\n\n    Kowace doka tana ba da damar a sauya wata lamba guda ɗaya zuwa wata. Ana amfani da binciken farko\n    (BFS) don bincika dukkan yiwuwar sauye-sauye. Aikin yana mayar da adadin\n    lambobin musamman da za a iya samarwa daga lambar asali, ciki har da lambar kanta.\n\n    Args:\n    - n (int): Lambar asali ta integer don sauya.\n    - rules (list of tuples): Jerin dokokin sauyi, inda kowace doka aka wakilta\n                              a matsayin tuple (x, y) wanda ke nuna cewa za a iya sauya lamba x zuwa y.\n\n    Returns:\n    - int: Jimillar adadin lambobin musamman da za a iya samarwa.\n\n    Cases:\n    - Case 1: n = 234, rules = [(2, 5), (3, 6)]\n              Wannan yanayin ya kamata ya dawo da 4 saboda ana iya samar da lambobin musamman masu zuwa:\n              234 (asali), 534 (2 -> 5), 264 (3 -> 6), da 564 (2 -> 5, 3 -> 6).\n\n    - Case 2: n = 100, rules = [(1, 9)]\n              Wannan yanayin ya kamata ya dawo da 2 saboda ana iya samar da lambobin musamman masu zuwa:\n              100 (asali) da 900 (1 -> 9).\n\n    - Case 3: n = 8, rules = [(8, 3), (8, 5)]\n              Wannan yanayin ya kamata ya dawo da 3 saboda ana iya samar da lambobin musamman masu zuwa:\n              8 (asali), 3 (8 -> 3), da 5 (8 -> 5).\n    \"\"\"",
      "hi": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    दिए गए संख्या से सभी अद्वितीय संख्याएँ उत्पन्न करें, परिवर्तन नियमों को लागू करके।\n\n    प्रत्येक नियम एकल अंक को दूसरे में परिवर्तित करने की अनुमति देता है। सभी संभावित परिवर्तनों\n    का पता लगाने के लिए एक ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। यह फ़ंक्शन उन अद्वितीय संख्याओं की\n    गणना लौटाता है जो मूल संख्या से उत्पन्न की जा सकती हैं, जिसमें संख्या स्वयं भी शामिल है।\n\n    तर्क:\n    - n (int): मूल पूर्णांक संख्या जिसे परिवर्तित करना है।\n    - rules (list of tuples): परिवर्तन नियमों की सूची, जहाँ प्रत्येक नियम को एक टपल (x, y) के रूप में दर्शाया गया है\n                              जो दर्शाता है कि अंक x को y में परिवर्तित किया जा सकता है।\n\n    लौटाता है:\n    - int: अद्वितीय संख्याओं की कुल गणना जो उत्पन्न की जा सकती हैं।\n\n    मामले:\n    - मामला 1: n = 234, rules = [(2, 5), (3, 6)]\n              यह मामला 4 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n              234 (मूल), 534 (2 -> 5), 264 (3 -> 6), और 564 (2 -> 5, 3 -> 6)।\n\n    - मामला 2: n = 100, rules = [(1, 9)]\n              यह मामला 2 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n              100 (मूल) और 900 (1 -> 9)।\n\n    - मामला 3: n = 8, rules = [(8, 3), (8, 5)]\n              यह मामला 3 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n              8 (मूल), 3 (8 -> 3), और 5 (8 -> 5)।\n    \"\"\"",
      "hu": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generáljon minden egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\n    Minden szabály lehetővé teszi, hogy egyetlen számjegy átalakuljon egy másikra. \n    Szélességi keresést (BFS) használunk az összes lehetséges átalakítás feltárására. \n    A függvény visszaadja az eredeti számból generálható egyedi számok számát, beleértve magát a számot is.\n\n    Argumentumok:\n    - n (int): Az eredeti egész szám, amelyet át kell alakítani.\n    - rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy\n                              (x, y) tuple-ként van megadva, jelezve, hogy az x számjegy átalakulhat y-ra.\n\n    Visszatérési érték:\n    - int: Az összes egyedi szám száma, amely generálható.\n\n    Esetek:\n    - Eset 1: n = 234, rules = [(2, 5), (3, 6)]\n              Ez az eset 4-et kell visszaadjon, mert a következő egyedi számok generálhatók:\n              234 (eredeti), 534 (2 -> 5), 264 (3 -> 6), és 564 (2 -> 5, 3 -> 6).\n\n    - Eset 2: n = 100, rules = [(1, 9)]\n              Ez az eset 2-t kell visszaadjon, mert a következő egyedi számok generálhatók:\n              100 (eredeti) és 900 (1 -> 9).\n\n    - Eset 3: n = 8, rules = [(8, 3), (8, 5)]\n              Ez az eset 3-at kell visszaadjon, mert a következő egyedi számok generálhatók:\n              8 (eredeti), 3 (8 -> 3), és 5 (8 -> 5).\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9918007365012609",
      "hy": "0.9585188257461981",
      "bn": "0.9762489708181343",
      "bg": "0.9663071229865761",
      "zh": "0.9602929923096017",
      "fr": "0.9834417741761696",
      "de": "0.9871651006686686",
      "ha": "0.9930910394564635",
      "hi": "0.9904665362318495",
      "hu": "0.969734092950571"
    },
    "canonical_solution": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)",
    "instruction": {
      "en": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nনিচের পাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nदिए गए Python कोड के लिए अधिकतम 500 वर्णों का उपयोग करते हुए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें।",
      "hu": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8653907729676097",
      "bn": "0.8713540542670392",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9215501364887467",
      "hi": "0.9199563263113228",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_generate_numbers():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ntest_generate_numbers()",
    "entry_point": "generate_numbers",
    "signature": "def generate_numbers(n, rules) -> int:",
    "docstring": {
      "en": "Generate all unique numbers from the given number by applying transformation rules.\n\nEach rule allows a single digit to be transformed into another. A breadth-first search\n(BFS) is used to explore all possible transformations. The function returns the count\nof unique numbers that can be generated from the original number, including the number itself.\n\nArgs:\n- n (int): The original integer number to transform.\n- rules (list of tuples): A list of transformation rules, where each rule is represented\nas a tuple (x, y) indicating that digit x can be transformed into y.\n\nReturns:\n- int: The total count of unique numbers that can be generated.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nThis case should return 4 because the following unique numbers can be generated:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nThis case should return 2 because the following unique numbers can be generated:\n100 (original) and 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nThis case should return 3 because the following unique numbers can be generated:\n8 (original), 3 (8 -> 3), and 5 (8 -> 5).",
      "sq": "Gjenero të gjitha numrat unikë nga numri i dhënë duke aplikuar rregullat e transformimit.\n\nÇdo rregull lejon që një shifër e vetme të transformohet në një tjetër. Një kërkim në gjerësi\n(BFS) përdoret për të eksploruar të gjitha transformimet e mundshme. Funksioni kthen numrin\ne numrave unikë që mund të gjenerohen nga numri origjinal, duke përfshirë vetë numrin.\n\nArgumentet:\n- n (int): Numri origjinal i plotë për të transformuar.\n- rules (listë e treshave): Një listë e rregullave të transformimit, ku çdo rregull përfaqësohet\nsi një treshe (x, y) që tregon se shifra x mund të transformohet në y.\n\nKthen:\n- int: Numri total i numrave unikë që mund të gjenerohen.\n\nRastet:\n- Rasti 1: n = 234, rules = [(2, 5), (3, 6)]\nKy rast duhet të kthejë 4 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n234 (origjinal), 534 (2 -> 5), 264 (3 -> 6), dhe 564 (2 -> 5, 3 -> 6).\n\n- Rasti 2: n = 100, rules = [(1, 9)]\nKy rast duhet të kthejë 2 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n100 (origjinal) dhe 900 (1 -> 9).\n\n- Rasti 3: n = 8, rules = [(8, 3), (8, 5)]\nKy rast duhet të kthejë 3 sepse numrat unikë të mëposhtëm mund të gjenerohen:\n8 (origjinal), 3 (8 -> 3), dhe 5 (8 -> 5).",
      "hy": "Տրված թվից գեներացնել բոլոր եզակի թվերը՝ կիրառելով փոխակերպման կանոններ։\n\nՅուրաքանչյուր կանոն թույլ է տալիս միանիշ թվանշանը փոխակերպել մեկ այլ թվանշանի։ Լայնությամբ նախնական որոնում (BFS) օգտագործվում է բոլոր հնարավոր փոխակերպումները ուսումնասիրելու համար։ Ֆունկցիան վերադարձնում է եզակի թվերի քանակը, որոնք կարող են գեներացվել սկզբնական թվից, ներառյալ ինքը՝ թիվը։\n\nԱրձագանքներ:\n- n (int): Սկզբնական ամբողջ թիվը, որը պետք է փոխակերպել։\n- rules (ցանկ, որը բաղկացած է զույգերից): Փոխակերպման կանոնների ցանկ, որտեղ յուրաքանչյուր կանոն ներկայացված է որպես զույգ (x, y), որը ցույց է տալիս, որ թվանշան x-ը կարող է փոխակերպվել y-ի։\n\nՎերադարձնում է:\n- int: Գեներացվող եզակի թվերի ընդհանուր քանակը։\n\nԴեպքեր:\n- Դեպք 1: n = 234, rules = [(2, 5), (3, 6)]\nԱյս դեպքը պետք է վերադարձնի 4, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը՝ 234 (սկզբնական), 534 (2 -> 5), 264 (3 -> 6) և 564 (2 -> 5, 3 -> 6)։\n\n- Դեպք 2: n = 100, rules = [(1, 9)]\nԱյս դեպքը պետք է վերադարձնի 2, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը՝ 100 (սկզբնական) և 900 (1 -> 9)։\n\n- Դեպք 3: n = 8, rules = [(8, 3), (8, 5)]\nԱյս դեպքը պետք է վերադարձնի 3, քանի որ կարող են գեներացվել հետևյալ եզակի թվերը՝ 8 (սկզբնական), 3 (8 -> 3) և 5 (8 -> 5)։",
      "bn": "প্রদত্ত সংখ্যাটি থেকে সমস্ত অনন্য সংখ্যা তৈরি করুন রূপান্তর নিয়ম প্রয়োগ করে।\n\nপ্রতিটি নিয়ম একটি একক অঙ্ককে অন্যটিতে রূপান্তর করার অনুমতি দেয়। সমস্ত সম্ভাব্য রূপান্তর অন্বেষণ করতে একটি ব্রেডথ-ফার্স্ট সার্চ (BFS) ব্যবহার করা হয়। ফাংশনটি মূল সংখ্যাটি সহ যে সমস্ত অনন্য সংখ্যা তৈরি করা যেতে পারে তার গণনা প্রদান করে।\n\nআর্গস:\n- n (int): রূপান্তর করার জন্য মূল পূর্ণসংখ্যা।\n- rules (list of tuples): রূপান্তর নিয়মের একটি তালিকা, যেখানে প্রতিটি নিয়ম একটি টুপল (x, y) দ্বারা উপস্থাপিত হয় যা নির্দেশ করে যে অঙ্ক x কে y তে রূপান্তর করা যেতে পারে।\n\nরিটার্নস:\n- int: যে সমস্ত অনন্য সংখ্যা তৈরি করা যেতে পারে তার মোট গণনা।\n\nকেস:\n- কেস 1: n = 234, rules = [(2, 5), (3, 6)]\nএই ক্ষেত্রে 4 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n234 (মূল), 534 (2 -> 5), 264 (3 -> 6), এবং 564 (2 -> 5, 3 -> 6)।\n\n- কেস 2: n = 100, rules = [(1, 9)]\nএই ক্ষেত্রে 2 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n100 (মূল) এবং 900 (1 -> 9)।\n\n- কেস 3: n = 8, rules = [(8, 3), (8, 5)]\nএই ক্ষেত্রে 3 ফেরত দেওয়া উচিত কারণ নিম্নলিখিত অনন্য সংখ্যা তৈরি করা যেতে পারে:\n8 (মূল), 3 (8 -> 3), এবং 5 (8 -> 5)।",
      "bg": "Генерирайте всички уникални числа от даденото число чрез прилагане на правила за трансформация.\n\nВсяко правило позволява една цифра да бъде трансформирана в друга. Използва се търсене в ширина (BFS), за да се изследват всички възможни трансформации. Функцията връща броя на уникалните числа, които могат да бъдат генерирани от оригиналното число, включително самото число.\n\nАргументи:\n- n (int): Оригиналното цяло число за трансформация.\n- rules (списък от кортежи): Списък с правила за трансформация, където всяко правило е представено\nкато кортеж (x, y), указващ, че цифрата x може да бъде трансформирана в y.\n\nВръща:\n- int: Общият брой на уникалните числа, които могат да бъдат генерирани.\n\nСлучаи:\n- Случай 1: n = 234, rules = [(2, 5), (3, 6)]\nТози случай трябва да върне 4, защото могат да бъдат генерирани следните уникални числа:\n234 (оригинал), 534 (2 -> 5), 264 (3 -> 6) и 564 (2 -> 5, 3 -> 6).\n\n- Случай 2: n = 100, rules = [(1, 9)]\nТози случай трябва да върне 2, защото могат да бъдат генерирани следните уникални числа:\n100 (оригинал) и 900 (1 -> 9).\n\n- Случай 3: n = 8, rules = [(8, 3), (8, 5)]\nТози случай трябва да върне 3, защото могат да бъдат генерирани следните уникални числа:\n8 (оригинал), 3 (8 -> 3) и 5 (8 -> 5).",
      "zh": "生成所有从给定数字通过应用转换规则得到的唯一数字。\n\n每个规则允许将一个数字转换为另一个数字。使用广度优先搜索（BFS）来探索所有可能的转换。该函数返回可以从原始数字生成的唯一数字的数量，包括数字本身。\n\n参数：\n- n (int): 要转换的原始整数。\n- rules (list of tuples): 转换规则的列表，其中每个规则表示为一个元组 (x, y)，表示数字 x 可以转换为 y。\n\n返回：\n- int: 可以生成的唯一数字的总数。\n\n案例：\n- 案例 1: n = 234, rules = [(2, 5), (3, 6)]\n这个案例应该返回 4，因为可以生成以下唯一数字：234（原始），534（2 -> 5），264（3 -> 6），和 564（2 -> 5, 3 -> 6）。\n\n- 案例 2: n = 100, rules = [(1, 9)]\n这个案例应该返回 2，因为可以生成以下唯一数字：100（原始）和 900（1 -> 9）。\n\n- 案例 3: n = 8, rules = [(8, 3), (8, 5)]\n这个案例应该返回 3，因为可以生成以下唯一数字：8（原始），3（8 -> 3），和 5（8 -> 5）。",
      "fr": "Générer tous les nombres uniques à partir du nombre donné en appliquant des règles de transformation.\n\nChaque règle permet de transformer un seul chiffre en un autre. Une recherche en largeur (BFS) est utilisée pour explorer toutes les transformations possibles. La fonction renvoie le nombre de nombres uniques qui peuvent être générés à partir du nombre original, y compris le nombre lui-même.\n\nArgs:\n- n (int): Le nombre entier original à transformer.\n- rules (liste de tuples): Une liste de règles de transformation, où chaque règle est représentée\ncomme un tuple (x, y) indiquant que le chiffre x peut être transformé en y.\n\nReturns:\n- int: Le nombre total de nombres uniques qui peuvent être générés.\n\nCas:\n- Cas 1: n = 234, rules = [(2, 5), (3, 6)]\nCe cas devrait retourner 4 car les nombres uniques suivants peuvent être générés :\n234 (original), 534 (2 -> 5), 264 (3 -> 6), et 564 (2 -> 5, 3 -> 6).\n\n- Cas 2: n = 100, rules = [(1, 9)]\nCe cas devrait retourner 2 car les nombres uniques suivants peuvent être générés :\n100 (original) et 900 (1 -> 9).\n\n- Cas 3: n = 8, rules = [(8, 3), (8, 5)]\nCe cas devrait retourner 3 car les nombres uniques suivants peuvent être générés :\n8 (original), 3 (8 -> 3), et 5 (8 -> 5).",
      "de": "Erzeuge alle einzigartigen Zahlen aus der gegebenen Zahl, indem Transformationsregeln angewendet werden.\n\nJede Regel erlaubt es, eine einzelne Ziffer in eine andere zu transformieren. Eine Breitensuche\n(BFS) wird verwendet, um alle möglichen Transformationen zu erkunden. Die Funktion gibt die Anzahl\nder einzigartigen Zahlen zurück, die aus der ursprünglichen Zahl generiert werden können, einschließlich der Zahl selbst.\n\nArgs:\n- n (int): Die ursprüngliche ganze Zahl, die transformiert werden soll.\n- rules (list von Tupeln): Eine Liste von Transformationsregeln, wobei jede Regel als\nein Tupel (x, y) dargestellt wird, das angibt, dass die Ziffer x in y transformiert werden kann.\n\nReturns:\n- int: Die Gesamtanzahl der einzigartigen Zahlen, die generiert werden können.\n\nFälle:\n- Fall 1: n = 234, rules = [(2, 5), (3, 6)]\nDieser Fall sollte 4 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n234 (original), 534 (2 -> 5), 264 (3 -> 6) und 564 (2 -> 5, 3 -> 6).\n\n- Fall 2: n = 100, rules = [(1, 9)]\nDieser Fall sollte 2 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n100 (original) und 900 (1 -> 9).\n\n- Fall 3: n = 8, rules = [(8, 3), (8, 5)]\nDieser Fall sollte 3 zurückgeben, da die folgenden einzigartigen Zahlen generiert werden können:\n8 (original), 3 (8 -> 3) und 5 (8 -> 5).",
      "ha": "Samar da duk lambobin musamman daga lambar da aka bayar ta hanyar amfani da dokokin sauyi.\n\nKowane doka yana ba da damar sauya lamba guda ɗaya zuwa wata. Ana amfani da binciken nisa na farko (BFS) don bincika dukkan yiwuwar sauye-sauye. Aikin yana mayar da adadin lambobi na musamman da za a iya samarwa daga lambar asali, ciki har da lambar kanta.\n\nArgs:\n- n (int): Lambar asali ta cikakken lamba don sauyawa.\n- rules (jerin tuples): Jerin dokokin sauyi, inda kowace doka ke wakiltar\na matsayin tuple (x, y) yana nuna cewa ana iya sauya lamba x zuwa y.\n\nReturns:\n- int: Jimillar adadin lambobi na musamman da za a iya samarwa.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nWannan yanayin ya kamata ya dawo da 4 saboda ana iya samar da lambobi na musamman masu zuwa:\n234 (asali), 534 (2 -> 5), 264 (3 -> 6), da 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nWannan yanayin ya kamata ya dawo da 2 saboda ana iya samar da lambobi na musamman masu zuwa:\n100 (asali) da 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nWannan yanayin ya kamata ya dawo da 3 saboda ana iya samar da lambobi na musamman masu zuwa:\n8 (asali), 3 (8 -> 3), da 5 (8 -> 5).",
      "hi": "दिए गए संख्या से सभी अद्वितीय संख्याएँ उत्पन्न करें, परिवर्तन नियम लागू करके।\n\nप्रत्येक नियम एकल अंक को दूसरे में बदलने की अनुमति देता है। सभी संभावित परिवर्तनों का पता लगाने के लिए ब्रेड्थ-फर्स्ट सर्च (BFS) का उपयोग किया जाता है। यह फ़ंक्शन उन अद्वितीय संख्याओं की गिनती लौटाता है जो मूल संख्या से उत्पन्न की जा सकती हैं, जिसमें संख्या स्वयं भी शामिल है।\n\nआर्ग्स:\n- n (int): परिवर्तित करने के लिए मूल पूर्णांक संख्या।\n- rules (list of tuples): परिवर्तन नियमों की सूची, जहाँ प्रत्येक नियम को एक ट्यूपल (x, y) के रूप में दर्शाया गया है, जो दर्शाता है कि अंक x को y में परिवर्तित किया जा सकता है।\n\nरिटर्न्स:\n- int: उत्पन्न की जा सकने वाली अद्वितीय संख्याओं की कुल गिनती।\n\nमामले:\n- मामला 1: n = 234, rules = [(2, 5), (3, 6)]\nयह मामला 4 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n234 (मूल), 534 (2 -> 5), 264 (3 -> 6), और 564 (2 -> 5, 3 -> 6)।\n\n- मामला 2: n = 100, rules = [(1, 9)]\nयह मामला 2 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n100 (मूल) और 900 (1 -> 9)।\n\n- मामला 3: n = 8, rules = [(8, 3), (8, 5)]\nयह मामला 3 लौटाना चाहिए क्योंकि निम्नलिखित अद्वितीय संख्याएँ उत्पन्न की जा सकती हैं:\n8 (मूल), 3 (8 -> 3), और 5 (8 -> 5)।",
      "hu": "Generálja az összes egyedi számot a megadott számból átalakítási szabályok alkalmazásával.\n\nMinden szabály lehetővé teszi egyetlen számjegy átalakítását egy másikra. Egy szélességi keresést (BFS) használnak az összes lehetséges átalakítás feltárására. A függvény visszaadja az eredeti számból generálható egyedi számok számát, beleértve magát a számot is.\n\nArgs:\n- n (int): Az eredeti egész szám, amelyet át kell alakítani.\n- rules (list of tuples): Az átalakítási szabályok listája, ahol minden szabály egy (x, y) tuple-ként van ábrázolva, jelezve, hogy az x számjegy átalakítható y-ra.\n\nReturns:\n- int: Az összes generálható egyedi szám teljes száma.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nEz az eset 4-et kell, hogy visszaadjon, mert a következő egyedi számok generálhatók: 234 (eredeti), 534 (2 -> 5), 264 (3 -> 6), és 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nEz az eset 2-t kell, hogy visszaadjon, mert a következő egyedi számok generálhatók: 100 (eredeti) és 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nEz az eset 3-at kell, hogy visszaadjon, mert a következő egyedi számok generálhatók: 8 (eredeti), 3 (8 -> 3), és 5 (8 -> 5)."
    },
    "docstring_bertscore": {
      "sq": "0.9900885426167401",
      "hy": "0.9653964026895311",
      "bn": "0.9695114282934308",
      "bg": "0.9780567059159327",
      "zh": "0.9555544659396334",
      "fr": "0.9871390800887531",
      "de": "0.9876654505984955",
      "ha": "0.9777200274200787",
      "hi": "0.9869769976978285",
      "hu": "0.9827584856654097"
    }
  },
  {
    "task_id": "Python/32",
    "prompt": {
      "en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      False if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\n      since statements about the day of the week are ignored.\n    \"\"\"\n    # Function implementation...",
      "sq": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\n    Kjo funksion merr emrin e një krimineli potencial (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon nëse\n    deklaratat e bëra nga të gjithë pjesëmarrësit janë konsistente me këtë skenar, duke injoruar çdo deklaratë\n    rreth ditës së javës.\n\n    Parametrat:\n    - scenario (str): Emri i pjesëmarrësit që po testohet si kriminel potencial.\n    - liar_count (set): Një grup emrash të pjesëmarrësve që supozohet të jenë gënjeshtarë.\n    - statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n    - days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\n    Kthen:\n    - bool: True nëse skenari është konsistent me deklaratat, False përndryshe.\n\n    Raste Testimi:\n    - Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\n      True nëse \"ALICE\" thotë \"I am guilty.\", \"BOB\" thotë \"ALICE is not guilty.\", dhe \"CHARLIE\" nuk bën deklarata relevante.\n\n    - Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\n      False nëse \"ALICE\" thotë \"I am not guilty.\", \"BOB\" thotë \"ALICE is guilty.\", që kundërshton skenarin.\n\n    - Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\n      True nëse \"ALICE\" thotë \"I am guilty.\", \"BOB\" thotë \"Today is MONDAY\", dhe \"CHARLIE\" thotë \"ALICE is guilty.\",\n      pasi deklaratat rreth ditës së javës injorohen.\n    \"\"\"\n    # Zbatimi i funksionit...",
      "hy": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Գնահատում է սցենարի հետևողականությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնված տրված հայտարարությունների վրա:\n\n    Այս ֆունկցիան ընդունում է հնարավոր հանցագործի անունը (scenario) և ստախոսների հավաքածու (liar_count) և ստուգում է,\n    արդյոք բոլոր մասնակիցների հայտարարությունները հետևողական են այս սցենարի հետ՝ անտեսելով շաբաթվա օրվա մասին\n    հայտարարությունները:\n\n    Պարամետրեր:\n    - scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ:\n    - liar_count (set): Մասնակիցների անունների հավաքածու, որոնք համարվում են ստախոսներ:\n    - statements (dict): Բառարան, որը կապում է մասնակիցների անունները նրանց համապատասխան հայտարարությունների ցուցակների հետ:\n    - days_of_week (set): Տողերի հավաքածու, որը ներկայացնում է շաբաթվա օրերը:\n\n    Վերադարձնում է:\n    - bool: True, եթե սցենարը հետևողական է հայտարարությունների հետ, False՝ հակառակ դեպքում:\n\n    Թեստային դեպքեր:\n    - Տրված սցենար, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\n      True, եթե \"ALICE\"-ը ասում է \"I am guilty.\", \"BOB\"-ը ասում է \"ALICE is not guilty.\", և \"CHARLIE\"-ն չի անում\n      համապատասխան հայտարարություններ:\n\n    - Տրված սցենար, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\n      False, եթե \"ALICE\"-ը ասում է \"I am not guilty.\", \"BOB\"-ը ասում է \"ALICE is guilty.\", ինչը հակասում է սցենարին:\n\n    - Տրված սցենար, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\n      True, եթե \"ALICE\"-ը ասում է \"I am guilty.\", \"BOB\"-ը ասում է \"Today is MONDAY\", և \"CHARLIE\"-ն ասում է \"ALICE is guilty.\",\n      քանի որ շաբաթվա օրվա մասին հայտարարությունները անտեսվում են:\n    \"\"\"\n    # Function implementation...",
      "bn": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    প্রদত্ত বিবৃতির উপর ভিত্তি করে এক অংশগ্রহণকারী অপরাধী এমন একটি দৃশ্যের সামঞ্জস্য মূল্যায়ন করে।\n\n    এই ফাংশনটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) নেয় এবং পরীক্ষা করে\n    যে সমস্ত অংশগ্রহণকারীর দ্বারা প্রদত্ত বিবৃতিগুলি এই দৃশ্যের সাথে সামঞ্জস্যপূর্ণ কিনা, সপ্তাহের দিনের \n    সম্পর্কে কোনো বিবৃতি উপেক্ষা করে।\n\n    প্যারামিটার:\n    - scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষিত অংশগ্রহণকারীর নাম।\n    - liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী বলে মনে করা হয়।\n    - statements (dict): অংশগ্রহণকারীদের নামকে তাদের সংশ্লিষ্ট বিবৃতির তালিকার সাথে ম্যাপ করে এমন একটি অভিধান।\n    - days_of_week (set): সপ্তাহের দিনের প্রতিনিধিত্বকারী স্ট্রিংগুলির একটি সেট।\n\n    রিটার্নস:\n    - bool: যদি দৃশ্যটি বিবৃতির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\n    পরীক্ষার কেস:\n    - একটি দৃশ্য দেওয়া হয়েছে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি \n      True রিটার্ন করা উচিত যদি \"ALICE\" বলে \"I am guilty.\", \"BOB\" বলে \"ALICE is not guilty.\", এবং \n      \"CHARLIE\" কোনো প্রাসঙ্গিক বিবৃতি না দেয়।\n\n    - একটি দৃশ্য দেওয়া হয়েছে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি \n      False রিটার্ন করা উচিত যদি \"ALICE\" বলে \"I am not guilty.\", \"BOB\" বলে \"ALICE is guilty.\", যা \n      দৃশ্যের সাথে বিরোধ করে।\n\n    - একটি দৃশ্য দেওয়া হয়েছে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি \n      True রিটার্ন করা উচিত যদি \"ALICE\" বলে \"I am guilty.\", \"BOB\" বলে \"Today is MONDAY\", এবং \n      \"CHARLIE\" বলে \"ALICE is guilty.\", যেহেতু সপ্তাহের দিনের সম্পর্কে বিবৃতিগুলি উপেক্ষা করা হয়।\n    \"\"\"\n    # Function implementation...",
      "bg": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Оценява последователността на сценарий, в който един участник е престъпникът въз основа на дадените изявления.\n\n    Тази функция приема името на потенциалния престъпник (scenario) и набор от лъжци (liar_count) и проверява дали\n    изявленията, направени от всички участници, са последователни с този сценарий, като се пренебрегват изявленията\n    за деня от седмицата.\n\n    Параметри:\n    - scenario (str): Името на участника, който се тества като потенциален престъпник.\n    - liar_count (set): Набор от имена на участници, които се приемат за лъжци.\n    - statements (dict): Речник, който свързва имената на участниците със списъци на техните съответни изявления.\n    - days_of_week (set): Набор от низове, представляващи дните от седмицата.\n\n    Връща:\n    - bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\n    Тестови случаи:\n    - При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\n      True, ако \"ALICE\" казва \"I am guilty.\", \"BOB\" казва \"ALICE is not guilty.\", и \"CHARLIE\" не прави релевантни изявления.\n\n    - При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\n      False, ако \"ALICE\" казва \"I am not guilty.\", \"BOB\" казва \"ALICE is guilty.\", което противоречи на сценария.\n\n    - При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\n      True, ако \"ALICE\" казва \"I am guilty.\", \"BOB\" казва \"Today is MONDAY\", и \"CHARLIE\" казва \"ALICE is guilty.\",\n      тъй като изявленията за деня от седмицата се игнорират.\n    \"\"\"\n    # Function implementation...",
      "zh": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    评估一个场景的连贯性，其中一名参与者是基于给定陈述的罪犯。\n\n    此函数接受一个潜在罪犯的名字（scenario）和一组说谎者（liar_count），并检查所有参与者的陈述是否与此场景一致，\n    忽略任何关于星期几的陈述。\n\n    参数:\n    - scenario (str): 被测试为潜在罪犯的参与者的名字。\n    - liar_count (set): 假定为说谎者的参与者名字集合。\n    - statements (dict): 一个字典，将参与者名字映射到各自陈述的列表。\n    - days_of_week (set): 表示一周中各天的字符串集合。\n\n    返回:\n    - bool: 如果场景与陈述一致，则返回 True，否则返回 False。\n\n    测试用例:\n    - 给定一个场景，其中 \"ALICE\" 是罪犯，\"BOB\" 和 \"CHARLIE\" 是说谎者，如果 \"ALICE\" 说 \"I am guilty.\",\n      \"BOB\" 说 \"ALICE is not guilty.\", 并且 \"CHARLIE\" 没有做出相关陈述，函数应返回 True。\n\n    - 给定一个场景，其中 \"ALICE\" 是罪犯，\"BOB\" 和 \"CHARLIE\" 是说谎者，如果 \"ALICE\" 说 \"I am not guilty.\",\n      \"BOB\" 说 \"ALICE is guilty.\", 这与场景矛盾，函数应返回 False。\n\n    - 给定一个场景，其中 \"ALICE\" 是罪犯，\"BOB\" 和 \"CHARLIE\" 是说谎者，如果 \"ALICE\" 说 \"I am guilty.\",\n      \"BOB\" 说 \"Today is MONDAY\", 并且 \"CHARLIE\" 说 \"ALICE is guilty.\",\n      由于关于星期几的陈述被忽略，函数应返回 True。\n    \"\"\"\n    # Function implementation...",
      "fr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Évalue la cohérence d'un scénario où un participant est le criminel basé sur les déclarations données.\n\n    Cette fonction prend le nom d'un criminel potentiel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\n    les déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\n    concernant le jour de la semaine.\n\n    Paramètres:\n    - scenario (str): Le nom du participant testé en tant que criminel potentiel.\n    - liar_count (set): Un ensemble de noms de participants supposés être des menteurs.\n    - statements (dict): Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n    - days_of_week (set): Un ensemble de chaînes représentant les jours de la semaine.\n\n    Renvoie:\n    - bool: True si le scénario est cohérent avec les déclarations, False sinon.\n\n    Cas de test:\n    - Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait retourner\n      True si \"ALICE\" dit \"I am guilty.\", \"BOB\" dit \"ALICE is not guilty.\", et \"CHARLIE\" ne fait aucune déclaration pertinente.\n\n    - Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait retourner\n      False si \"ALICE\" dit \"I am not guilty.\", \"BOB\" dit \"ALICE is guilty.\", ce qui contredit le scénario.\n\n    - Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait retourner\n      True si \"ALICE\" dit \"I am guilty.\", \"BOB\" dit \"Today is MONDAY\", et \"CHARLIE\" dit \"ALICE is guilty.\",\n      puisque les déclarations concernant le jour de la semaine sont ignorées.\n    \"\"\"\n    # Implémentation de la fonction...",
      "de": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Bewertet die Konsistenz eines Szenarios, in dem ein Teilnehmer der Kriminelle ist, basierend auf den gegebenen Aussagen.\n\n    Diese Funktion nimmt den Namen eines potenziellen Kriminellen (Szenario) und eine Menge von Lügnern (liar_count) und überprüft,\n    ob die Aussagen aller Teilnehmer mit diesem Szenario konsistent sind, wobei Aussagen über den Wochentag ignoriert werden.\n\n    Parameter:\n    - scenario (str): Der Name des Teilnehmers, der als potenzieller Krimineller getestet wird.\n    - liar_count (set): Eine Menge von Namen der Teilnehmer, die als Lügner angenommen werden.\n    - statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n    - days_of_week (set): Eine Menge von Zeichenfolgen, die die Wochentage darstellen.\n\n    Rückgabewerte:\n    - bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\n    Testfälle:\n    - Gegeben ein Szenario, in dem \"ALICE\" die Kriminelle ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion\n      True zurückgeben, wenn \"ALICE\" sagt \"I am guilty.\", \"BOB\" sagt \"ALICE is not guilty.\", und \"CHARLIE\" keine relevanten Aussagen macht.\n\n    - Gegeben ein Szenario, in dem \"ALICE\" die Kriminelle ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion\n      False zurückgeben, wenn \"ALICE\" sagt \"I am not guilty.\", \"BOB\" sagt \"ALICE is guilty.\", was dem Szenario widerspricht.\n\n    - Gegeben ein Szenario, in dem \"ALICE\" die Kriminelle ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion\n      True zurückgeben, wenn \"ALICE\" sagt \"I am guilty.\", \"BOB\" sagt \"Today is MONDAY\", und \"CHARLIE\" sagt \"ALICE is guilty.\",\n      da Aussagen über den Wochentag ignoriert werden.\n    \"\"\"\n    # Funktionsimplementierung...",
      "ha": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Yana tantance daidaiton wani yanayi inda ɗaya daga cikin mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\n    Wannan aikin yana ɗaukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin maƙaryata (liar_count) kuma yana duba idan\n    bayanan da duk mahalarta suka bayar suna daidai da wannan yanayin, ba tare da la'akari da duk wani bayani\n    game da ranar mako ba.\n\n    Sigogi:\n    - scenario (str): Sunan mahalarta da ake gwadawa a matsayin mai laifi mai yuwuwa.\n    - liar_count (set): Saiti na sunayen mahalarta waɗanda ake ɗauka a matsayin maƙaryata.\n    - statements (dict): Kamus ɗin da ke haɗa sunayen mahalarta da jerin bayanan su na musamman.\n    - days_of_week (set): Saiti na kirtani da ke wakiltar ranakun mako.\n\n    Yana dawowa:\n    - bool: True idan yanayin ya dace da bayanan, False in ba haka ba.\n\n    Gwaje-gwaje:\n    - An bayar da wani yanayi inda \"ALICE\" ita ce mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\n      True idan \"ALICE\" ta ce \"I am guilty.\", \"BOB\" ya ce \"ALICE is not guilty.\", kuma \"CHARLIE\" bai yi wani bayani mai mahimmanci ba.\n\n    - An bayar da wani yanayi inda \"ALICE\" ita ce mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\n      False idan \"ALICE\" ta ce \"I am not guilty.\", \"BOB\" ya ce \"ALICE is guilty.\", wanda ya saba wa yanayin.\n\n    - An bayar da wani yanayi inda \"ALICE\" ita ce mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\n      True idan \"ALICE\" ta ce \"I am guilty.\", \"BOB\" ya ce \"Today is MONDAY\", kuma \"CHARLIE\" ya ce \"ALICE is guilty.\",\n      tun da bayanai game da ranar mako an yi watsi da su.\n    \"\"\"\n    # Function implementation...",
      "hi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    एक परिदृश्य की संगति का मूल्यांकन करता है जहाँ एक प्रतिभागी दिए गए बयानों के आधार पर अपराधी होता है।\n\n    यह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठे माने जाने वाले प्रतिभागियों का सेट (liar_count) लेता है और\n    सभी प्रतिभागियों द्वारा किए गए बयानों की इस परिदृश्य के साथ संगति की जाँच करता है, सप्ताह के दिन के बारे में किसी भी बयान को\n    नजरअंदाज करते हुए।\n\n    पैरामीटर्स:\n    - scenario (str): उस प्रतिभागी का नाम जिसका संभावित अपराधी के रूप में परीक्षण किया जा रहा है।\n    - liar_count (set): प्रतिभागियों के नामों का एक सेट जो झूठे माने जाते हैं।\n    - statements (dict): प्रतिभागी के नामों को उनके संबंधित बयानों की सूचियों से मैप करने वाली एक डिक्शनरी।\n    - days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\n    रिटर्न्स:\n    - bool: True अगर परिदृश्य बयानों के साथ संगत है, अन्यथा False।\n\n    परीक्षण मामले:\n    - एक परिदृश्य दिया गया है जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, तो फ़ंक्शन को True लौटाना चाहिए\n      अगर \"ALICE\" कहती है \"I am guilty.\", \"BOB\" कहता है \"ALICE is not guilty.\", और \"CHARLIE\" कोई प्रासंगिक बयान नहीं देता।\n\n    - एक परिदृश्य दिया गया है जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, तो फ़ंक्शन को False लौटाना चाहिए\n      अगर \"ALICE\" कहती है \"I am not guilty.\", \"BOB\" कहता है \"ALICE is guilty.\", जो परिदृश्य का खंडन करता है।\n\n    - एक परिदृश्य दिया गया है जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, तो फ़ंक्शन को True लौटाना चाहिए\n      अगर \"ALICE\" कहती है \"I am guilty.\", \"BOB\" कहता है \"Today is MONDAY\", और \"CHARLIE\" कहता है \"ALICE is guilty.\",\n      क्योंकि सप्ताह के दिन के बारे में बयान नजरअंदाज किए जाते हैं।\n    \"\"\"\n    # Function implementation...",
      "hu": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Egy forgatókönyv konzisztenciájának értékelése, ahol az egyik résztvevő a bűnöző a megadott állítások alapján.\n\n    Ez a függvény egy potenciális bűnöző nevét (forgatókönyv) és egy hazugok halmazát (liar_count) veszi, és ellenőrzi,\n    hogy az összes résztvevő által tett állítások konzisztens-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjára\n    vonatkozó állításokat.\n\n    Paraméterek:\n    - scenario (str): A résztvevő neve, akit potenciális bűnözőként tesztelnek.\n    - liar_count (set): A hazugnak feltételezett résztvevők neveit tartalmazó halmaz.\n    - statements (dict): Egy szótár, amely a résztvevők neveit a hozzájuk tartozó állítások listájához rendeli.\n    - days_of_week (set): A hét napjait képviselő karakterláncok halmaza.\n\n    Visszatérési érték:\n    - bool: Igaz, ha a forgatókönyv konzisztens az állításokkal, hamis egyébként.\n\n    Tesztesetek:\n    - Adott egy forgatókönyv, ahol \"ALICE\" a bűnöző, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek igazat kell visszaadnia,\n      ha \"ALICE\" azt mondja \"Bűnös vagyok.\", \"BOB\" azt mondja \"ALICE nem bűnös.\", és \"CHARLIE\" nem tesz releváns állításokat.\n\n    - Adott egy forgatókönyv, ahol \"ALICE\" a bűnöző, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek hamisat kell visszaadnia,\n      ha \"ALICE\" azt mondja \"Nem vagyok bűnös.\", \"BOB\" azt mondja \"ALICE bűnös.\", ami ellentmond a forgatókönyvnek.\n\n    - Adott egy forgatókönyv, ahol \"ALICE\" a bűnöző, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek igazat kell visszaadnia,\n      ha \"ALICE\" azt mondja \"Bűnös vagyok.\", \"BOB\" azt mondja \"Ma HÉTFŐ van\", és \"CHARLIE\" azt mondja \"ALICE bűnös.\",\n      mivel a hét napjára vonatkozó állítások figyelmen kívül vannak hagyva.\n    \"\"\"\n    # Function implementation..."
    },
    "prompt_bertscore": {
      "sq": "0.9842206039002075",
      "hy": "0.9771497595961275",
      "bn": "0.9692093114838768",
      "bg": "0.9750424898837283",
      "zh": "0.9568755566038964",
      "fr": "0.9870836622124444",
      "de": "0.9831392601058535",
      "ha": "0.9630910984872402",
      "hi": "0.966090615871248",
      "hu": "0.9812361824251582"
    },
    "canonical_solution": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True",
    "instruction": {
      "en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.8657447323066139",
      "bg": "0.8983697723915943",
      "zh": "0.8886474111310796",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9217489655001627",
      "hi": "0.8964889413135749",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_check_scenario():\n    # Define a set of days of the week for the test cases\n    days_of_week = set([\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"])\n\n    # Test case 1: Simple case where the scenario is correct\n    statements_test1 = {\n        \"ALICE\": [\"I am not guilty.\", \"BOB is guilty.\"],\n        \"BOB\": [\"ALICE is not guilty.\", \"Today is MONDAY\"],\n        \"CHARLIE\": [\"I am guilty.\"]\n    }\n    scenario_test1 = \"CHARLIE\"\n    liar_count_test1 = {\"ALICE\", \"BOB\"}\n    assert check_scenario(scenario_test1, liar_count_test1, statements_test1, days_of_week) == False, \"Test case 1 failed\"\n\n    # Test case 2: Scenario with contradictory statements\n    statements_test2 = {\n        \"ALICE\": [\"I am guilty.\"],\n        \"BOB\": [\"I am not guilty.\", \"ALICE is guilty.\"],\n        \"CHARLIE\": [\"I am not guilty.\", \"Today is TUESDAY\"]\n    }\n    scenario_test2 = \"ALICE\"\n    liar_count_test2 = {\"BOB\", \"CHARLIE\"}\n    assert check_scenario(scenario_test2, liar_count_test2, statements_test2, days_of_week) == False, \"Test case 2 failed\"\n\n    # Test case 3: Scenario where the statements are ambiguous\n    statements_test3 = {\n        \"ALICE\": [\"I am not guilty.\", \"Today is WEDNESDAY\"],\n        \"BOB\": [\"I am not guilty.\", \"CHARLIE is guilty.\"],\n        \"CHARLIE\": [\"BOB is not guilty.\"]\n    }\n    scenario_test3 = \"BOB\"\n    liar_count_test3 = {\"ALICE\", \"CHARLIE\"}\n    assert check_scenario(scenario_test3, liar_count_test3, statements_test3, days_of_week) == False, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_check_scenario()",
    "entry_point": "check_scenario",
    "signature": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:",
    "docstring": {
      "en": "Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\nThis function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\nthe statements made by all participants are consistent with this scenario, disregarding any statements\nabout the day of the week.\n\nParameters:\n- scenario (str): The name of the participant being tested as the potential criminal.\n- liar_count (set): A set of names of participants who are assumed to be liars.\n- statements (dict): A dictionary mapping participant names to lists of their respective statements.\n- days_of_week (set): A set of strings representing the days of the week.\n\nReturns:\n- bool: True if the scenario is consistent with the statements, False otherwise.\n\nTest Cases:\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nFalse if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\nsince statements about the day of the week are ignored.",
      "sq": "Vlerëson konsistencën e një skenari ku një pjesëmarrës është krimineli bazuar në deklaratat e dhëna.\n\nKjo funksion merr emrin e një krimineli të mundshëm (skenari) dhe një grup gënjeshtarësh (liar_count) dhe kontrollon nëse\ndeklaratat e bëra nga të gjithë pjesëmarrësit janë konsistente me këtë skenar, duke injoruar çdo deklaratë\nrreth ditës së javës.\n\nParametrat:\n- scenario (str): Emri i pjesëmarrësit që po testohet si krimineli i mundshëm.\n- liar_count (set): Një grup emrash të pjesëmarrësve që supozohet të jenë gënjeshtarë.\n- statements (dict): Një fjalor që lidh emrat e pjesëmarrësve me listat e deklaratave të tyre përkatëse.\n- days_of_week (set): Një grup vargjesh që përfaqësojnë ditët e javës.\n\nKthen:\n- bool: True nëse skenari është konsistent me deklaratat, False përndryshe.\n\nRastet e Testimit:\n- Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\nTrue nëse \"ALICE\" thotë \"Unë jam fajtor.\", \"BOB\" thotë \"ALICE nuk është fajtore.\", dhe \"CHARLIE\" nuk bën deklarata të rëndësishme.\n\n- Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\nFalse nëse \"ALICE\" thotë \"Unë nuk jam fajtor.\", \"BOB\" thotë \"ALICE është fajtore.\", që bie ndesh me skenarin.\n\n- Duke dhënë një skenar ku \"ALICE\" është krimineli, dhe \"BOB\" dhe \"CHARLIE\" janë gënjeshtarë, funksioni duhet të kthejë\nTrue nëse \"ALICE\" thotë \"Unë jam fajtor.\", \"BOB\" thotë \"Sot është E HËNË\", dhe \"CHARLIE\" thotë \"ALICE është fajtore.\",\npasi deklaratat rreth ditës së javës injorohen.",
      "hy": "Գնահատում է սցենարի հետևողականությունը, որտեղ մեկ մասնակիցը հանցագործ է՝ հիմնվելով տրված հայտարարությունների վրա։\n\nԱյս ֆունկցիան վերցնում է հնարավոր հանցագործի անունը (սցենար) և ստախոսների հավաքածու (liar_count) և ստուգում է՝ արդյոք\nբոլոր մասնակիցների հայտարարությունները համահունչ են այս սցենարի հետ՝ անտեսելով շաբաթվա օրվա մասին հայտարարությունները։\n\nՊարամետրեր:\n- scenario (str): Մասնակցի անունը, որը փորձարկվում է որպես հնարավոր հանցագործ։\n- liar_count (set): Մասնակիցների անունների հավաքածու, որոնք համարվում են ստախոսներ։\n- statements (dict): Բառարան, որը կապում է մասնակիցների անունները նրանց համապատասխան հայտարարությունների ցուցակների հետ։\n- days_of_week (set): Տողերի հավաքածու, որը ներկայացնում է շաբաթվա օրերը։\n\nՎերադարձնում է:\n- bool: True, եթե սցենարը համահունչ է հայտարարություններին, False՝ հակառակ դեպքում։\n\nԹեստային դեպքեր:\n- Տրված սցենարում, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\nTrue, եթե \"ALICE\"-ն ասում է \"Ես մեղավոր եմ։\", \"BOB\"-ն ասում է \"ALICE-ը մեղավոր չէ։\", և \"CHARLIE\"-ն չի անում համապատասխան հայտարարություններ։\n\n- Տրված սցենարում, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\nFalse, եթե \"ALICE\"-ն ասում է \"Ես մեղավոր չեմ։\", \"BOB\"-ն ասում է \"ALICE-ը մեղավոր է։\", ինչը հակասում է սցենարին։\n\n- Տրված սցենարում, որտեղ \"ALICE\"-ը հանցագործ է, և \"BOB\"-ը և \"CHARLIE\"-ն ստախոսներ են, ֆունկցիան պետք է վերադարձնի\nTrue, եթե \"ALICE\"-ն ասում է \"Ես մեղավոր եմ։\", \"BOB\"-ն ասում է \"Այսօր երկուշաբթի է\", և \"CHARLIE\"-ն ասում է \"ALICE-ը մեղավոր է։\",\nքանի որ շաբաթվա օրվա մասին հայտարարությունները անտեսվում են։",
      "bn": "একটি পরিস্থিতির সামঞ্জস্য মূল্যায়ন করে যেখানে একজন অংশগ্রহণকারী অপরাধী হিসাবে বিবেচিত হয় প্রদত্ত বিবৃতির ভিত্তিতে।\n\nএই ফাংশনটি সম্ভাব্য অপরাধীর নাম (scenario) এবং মিথ্যাবাদীদের একটি সেট (liar_count) গ্রহণ করে এবং পরীক্ষা করে যে\nসকল অংশগ্রহণকারীর দ্বারা প্রদত্ত বিবৃতিগুলি এই পরিস্থিতির সাথে সামঞ্জস্যপূর্ণ কিনা, সপ্তাহের দিনের বিবৃতিগুলি উপেক্ষা করে।\n\nপ্যারামিটারসমূহ:\n- scenario (str): সম্ভাব্য অপরাধী হিসাবে পরীক্ষাধীন অংশগ্রহণকারীর নাম।\n- liar_count (set): অংশগ্রহণকারীদের নামের একটি সেট যারা মিথ্যাবাদী হিসাবে বিবেচিত।\n- statements (dict): অংশগ্রহণকারীদের নামকে তাদের সংশ্লিষ্ট বিবৃতির তালিকার সাথে ম্যাপ করা একটি অভিধান।\n- days_of_week (set): সপ্তাহের দিনের প্রতিনিধিত্বকারী স্ট্রিংগুলির একটি সেট।\n\nরিটার্নস:\n- bool: যদি পরিস্থিতি বিবৃতিগুলির সাথে সামঞ্জস্যপূর্ণ হয় তবে True, অন্যথায় False।\n\nপরীক্ষার কেসসমূহ:\n- একটি পরিস্থিতিতে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি True রিটার্ন করা উচিত\nযদি \"ALICE\" বলে \"I am guilty.\", \"BOB\" বলে \"ALICE is not guilty.\", এবং \"CHARLIE\" কোনো প্রাসঙ্গিক বিবৃতি না দেয়।\n\n- একটি পরিস্থিতিতে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি False রিটার্ন করা উচিত\nযদি \"ALICE\" বলে \"I am not guilty.\", \"BOB\" বলে \"ALICE is guilty.\", যা পরিস্থিতির সাথে বিরোধপূর্ণ।\n\n- একটি পরিস্থিতিতে যেখানে \"ALICE\" অপরাধী, এবং \"BOB\" এবং \"CHARLIE\" মিথ্যাবাদী, ফাংশনটি True রিটার্ন করা উচিত\nযদি \"ALICE\" বলে \"I am guilty.\", \"BOB\" বলে \"Today is MONDAY\", এবং \"CHARLIE\" বলে \"ALICE is guilty.\",\nকারণ সপ্তাহের দিনের বিবৃতিগুলি উপেক্ষা করা হয়।",
      "bg": "Оценява последователността на сценарий, в който един участник е престъпникът, въз основа на дадените изявления.\n\nТази функция приема име на потенциален престъпник (scenario) и набор от лъжци (liar_count) и проверява дали\nизявленията, направени от всички участници, са последователни с този сценарий, като се пренебрегват всички изявления\nотносно деня от седмицата.\n\nПараметри:\n- scenario (str): Името на участника, който се тества като потенциален престъпник.\n- liar_count (set): Набор от имена на участници, които се приемат за лъжци.\n- statements (dict): Речник, свързващ имената на участниците със списъци на техните съответни изявления.\n- days_of_week (set): Набор от низове, представляващи дните от седмицата.\n\nВръща:\n- bool: True, ако сценарият е последователен с изявленията, False в противен случай.\n\nТестови случаи:\n- При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\nTrue, ако \"ALICE\" казва \"I am guilty.\", \"BOB\" казва \"ALICE is not guilty.\", и \"CHARLIE\" не прави съответни изявления.\n\n- При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\nFalse, ако \"ALICE\" казва \"I am not guilty.\", \"BOB\" казва \"ALICE is guilty.\", което противоречи на сценария.\n\n- При даден сценарий, в който \"ALICE\" е престъпникът, а \"BOB\" и \"CHARLIE\" са лъжци, функцията трябва да върне\nTrue, ако \"ALICE\" казва \"I am guilty.\", \"BOB\" казва \"Today is MONDAY\", и \"CHARLIE\" казва \"ALICE is guilty.\",\nтъй като изявленията относно деня от седмицата се игнорират.",
      "zh": "评估一个场景的连贯性，其中一个参与者是基于给定陈述的罪犯。\n\n此函数接受一个潜在罪犯的名字（scenario）和一组说谎者（liar_count），并检查所有参与者所做的陈述是否与此场景一致，忽略任何关于星期几的陈述。\n\n参数：\n- scenario (str): 被测试为潜在罪犯的参与者的名字。\n- liar_count (set): 假定为说谎者的参与者名字集合。\n- statements (dict): 一个字典，将参与者名字映射到他们各自陈述的列表。\n- days_of_week (set): 表示一周中各天的字符串集合。\n\n返回：\n- bool: 如果场景与陈述一致则为True，否则为False。\n\n测试用例：\n- 给定一个场景，其中“ALICE”是罪犯，“BOB”和“CHARLIE”是说谎者，如果“ALICE”说“我是有罪的。”，“BOB”说“ALICE无罪。”，并且“CHARLIE”没有做出相关陈述，函数应返回True。\n\n- 给定一个场景，其中“ALICE”是罪犯，“BOB”和“CHARLIE”是说谎者，如果“ALICE”说“我无罪。”，“BOB”说“ALICE有罪。”，这与场景矛盾，函数应返回False。\n\n- 给定一个场景，其中“ALICE”是罪犯，“BOB”和“CHARLIE”是说谎者，如果“ALICE”说“我是有罪的。”，“BOB”说“今天是星期一。”，并且“CHARLIE”说“ALICE有罪。”，由于关于星期几的陈述被忽略，函数应返回True。",
      "fr": "Évalue la cohérence d'un scénario où un participant est le criminel en fonction des déclarations données.\n\nCette fonction prend le nom d'un potentiel criminel (scenario) et un ensemble de menteurs (liar_count) et vérifie si\nles déclarations faites par tous les participants sont cohérentes avec ce scénario, en ignorant toute déclaration\nconcernant le jour de la semaine.\n\nParamètres :\n- scenario (str) : Le nom du participant testé en tant que criminel potentiel.\n- liar_count (set) : Un ensemble de noms de participants supposés être des menteurs.\n- statements (dict) : Un dictionnaire associant les noms des participants à des listes de leurs déclarations respectives.\n- days_of_week (set) : Un ensemble de chaînes représentant les jours de la semaine.\n\nRenvoie :\n- bool : True si le scénario est cohérent avec les déclarations, False sinon.\n\nCas de test :\n- Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait renvoyer\nTrue si \"ALICE\" dit \"I am guilty.\", \"BOB\" dit \"ALICE is not guilty.\", et \"CHARLIE\" ne fait aucune déclaration pertinente.\n\n- Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait renvoyer\nFalse si \"ALICE\" dit \"I am not guilty.\", \"BOB\" dit \"ALICE is guilty.\", ce qui contredit le scénario.\n\n- Étant donné un scénario où \"ALICE\" est le criminel, et \"BOB\" et \"CHARLIE\" sont des menteurs, la fonction devrait renvoyer\nTrue si \"ALICE\" dit \"I am guilty.\", \"BOB\" dit \"Today is MONDAY\", et \"CHARLIE\" dit \"ALICE is guilty.\",\npuisque les déclarations concernant le jour de la semaine sont ignorées.",
      "de": "Überprüft die Konsistenz eines Szenarios, bei dem ein Teilnehmer der Täter ist, basierend auf den gegebenen Aussagen.\n\nDiese Funktion nimmt den Namen eines potenziellen Täters (scenario) und eine Menge von Lügnern (liar_count) und überprüft, ob die von allen Teilnehmern gemachten Aussagen mit diesem Szenario übereinstimmen, wobei Aussagen über den Wochentag ignoriert werden.\n\nParameter:\n- scenario (str): Der Name des Teilnehmers, der als potenzieller Täter getestet wird.\n- liar_count (set): Eine Menge von Namen der Teilnehmer, die als Lügner angenommen werden.\n- statements (dict): Ein Wörterbuch, das Teilnehmernamen auf Listen ihrer jeweiligen Aussagen abbildet.\n- days_of_week (set): Eine Menge von Zeichenketten, die die Wochentage darstellen.\n\nRückgabewert:\n- bool: True, wenn das Szenario mit den Aussagen konsistent ist, andernfalls False.\n\nTestfälle:\n- Gegeben ein Szenario, in dem \"ALICE\" der Täter ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion True zurückgeben, wenn \"ALICE\" sagt \"I am guilty.\", \"BOB\" sagt \"ALICE is not guilty.\", und \"CHARLIE\" keine relevanten Aussagen macht.\n\n- Gegeben ein Szenario, in dem \"ALICE\" der Täter ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion False zurückgeben, wenn \"ALICE\" sagt \"I am not guilty.\", \"BOB\" sagt \"ALICE is guilty.\", was dem Szenario widerspricht.\n\n- Gegeben ein Szenario, in dem \"ALICE\" der Täter ist und \"BOB\" und \"CHARLIE\" Lügner sind, sollte die Funktion True zurückgeben, wenn \"ALICE\" sagt \"I am guilty.\", \"BOB\" sagt \"Today is MONDAY\", und \"CHARLIE\" sagt \"ALICE is guilty.\", da Aussagen über den Wochentag ignoriert werden.",
      "ha": "Yana tantance daidaiton wani yanayi inda ɗaya daga cikin mahalarta shine mai laifi bisa ga bayanan da aka bayar.\n\nWannan aikin yana ɗaukar sunan mai laifi mai yuwuwa (scenario) da kuma saitin maƙaryata (liar_count) kuma yana duba idan\nbayanan da duk mahalarta suka yi suna da daidaito da wannan yanayi, ba tare da la'akari da kowanne bayani\ngame da ranar mako ba.\n\nSigogi:\n- scenario (str): Sunan mahalartin da ake gwada shi a matsayin mai laifi mai yuwuwa.\n- liar_count (set): Wani saitin sunayen mahalarta da ake ɗauka a matsayin maƙaryata.\n- statements (dict): Wani kamus mai haɗa sunayen mahalarta da jerin bayanan su na musamman.\n- days_of_week (set): Wani saitin kirtani da ke wakiltar ranakun mako.\n\nMayarwa:\n- bool: True idan yanayin ya dace da bayanan, False in ba haka ba.\n\nMisalan Gwaji:\n- Idan aka ba da yanayi inda \"ALICE\" shine mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\nTrue idan \"ALICE\" ta ce \"I am guilty.\", \"BOB\" ya ce \"ALICE is not guilty.\", kuma \"CHARLIE\" bai yi wani bayani mai mahimmanci ba.\n\n- Idan aka ba da yanayi inda \"ALICE\" shine mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\nFalse idan \"ALICE\" ta ce \"I am not guilty.\", \"BOB\" ya ce \"ALICE is guilty.\", wanda ya saba da yanayin.\n\n- Idan aka ba da yanayi inda \"ALICE\" shine mai laifi, kuma \"BOB\" da \"CHARLIE\" su ne maƙaryata, aikin ya kamata ya dawo\nTrue idan \"ALICE\" ta ce \"I am guilty.\", \"BOB\" ya ce \"Today is MONDAY\", kuma \"CHARLIE\" ya ce \"ALICE is guilty.\",\nsaboda bayanan game da ranar mako an yi watsi da su.",
      "hi": "एक परिदृश्य की संगति का मूल्यांकन करता है जहाँ एक प्रतिभागी अपराधी है, दिए गए बयानों के आधार पर।\n\nयह फ़ंक्शन एक संभावित अपराधी का नाम (scenario) और झूठे लोगों का एक सेट (liar_count) लेता है और जाँचता है कि\nसभी प्रतिभागियों द्वारा दिए गए बयान इस परिदृश्य के साथ संगत हैं या नहीं, सप्ताह के दिन के बारे में किसी भी बयान को अनदेखा करते हुए।\n\nपैरामीटर्स:\n- scenario (str): उस प्रतिभागी का नाम जिसे संभावित अपराधी के रूप में परीक्षण किया जा रहा है।\n- liar_count (set): उन प्रतिभागियों के नामों का सेट जिन्हें झूठा माना जा रहा है।\n- statements (dict): प्रतिभागी नामों को उनके संबंधित बयानों की सूचियों के साथ मैप करने वाली एक डिक्शनरी।\n- days_of_week (set): सप्ताह के दिनों का प्रतिनिधित्व करने वाले स्ट्रिंग्स का एक सेट।\n\nरिटर्न्स:\n- bool: True यदि परिदृश्य बयानों के साथ संगत है, अन्यथा False।\n\nटेस्ट केस:\n- एक दिए गए परिदृश्य में जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, फ़ंक्शन को True लौटाना चाहिए\nयदि \"ALICE\" कहती है \"I am guilty.\", \"BOB\" कहता है \"ALICE is not guilty.\", और \"CHARLIE\" कोई प्रासंगिक बयान नहीं देता।\n\n- एक दिए गए परिदृश्य में जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, फ़ंक्शन को False लौटाना चाहिए\nयदि \"ALICE\" कहती है \"I am not guilty.\", \"BOB\" कहता है \"ALICE is guilty.\", जो परिदृश्य का खंडन करता है।\n\n- एक दिए गए परिदृश्य में जहाँ \"ALICE\" अपराधी है, और \"BOB\" और \"CHARLIE\" झूठे हैं, फ़ंक्शन को True लौटाना चाहिए\nयदि \"ALICE\" कहती है \"I am guilty.\", \"BOB\" कहता है \"Today is MONDAY\", और \"CHARLIE\" कहता है \"ALICE is guilty.\",\nक्योंकि सप्ताह के दिन के बारे में बयानों को अनदेखा किया जाता है।",
      "hu": "Értékeli annak a forgatókönyvnek a konzisztenciáját, ahol az egyik résztvevő a bűnös a megadott állítások alapján.\n\nEz a függvény egy potenciális bűnös nevét (forgatókönyv) és egy hazugok halmazát (hazugok_száma) veszi, és ellenőrzi, hogy az összes résztvevő által tett állítások konzisztens-e ezzel a forgatókönyvvel, figyelmen kívül hagyva a hét napjára vonatkozó állításokat.\n\nParaméterek:\n- scenario (str): Annak a résztvevőnek a neve, akit potenciális bűnösként vizsgálnak.\n- liar_count (set): A hazugnak feltételezett résztvevők neveinek halmaza.\n- statements (dict): Egy szótár, amely a résztvevők neveit a megfelelő állításaik listájához rendeli.\n- days_of_week (set): A hét napjait reprezentáló karakterláncok halmaza.\n\nVisszatérési érték:\n- bool: Igaz, ha a forgatókönyv konzisztens az állításokkal, különben Hamis.\n\nTeszt Esetek:\n- Adott egy forgatókönyv, ahol \"ALICE\" a bűnös, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek Igazat kell visszaadnia, ha \"ALICE\" azt mondja: \"Bűnös vagyok.\", \"BOB\" azt mondja: \"ALICE nem bűnös.\", és \"CHARLIE\" nem tesz releváns állításokat.\n\n- Adott egy forgatókönyv, ahol \"ALICE\" a bűnös, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek Hamisat kell visszaadnia, ha \"ALICE\" azt mondja: \"Nem vagyok bűnös.\", \"BOB\" azt mondja: \"ALICE bűnös.\", ami ellentmond a forgatókönyvnek.\n\n- Adott egy forgatókönyv, ahol \"ALICE\" a bűnös, és \"BOB\" és \"CHARLIE\" hazugok, a függvénynek Igazat kell visszaadnia, ha \"ALICE\" azt mondja: \"Bűnös vagyok.\", \"BOB\" azt mondja: \"Ma HÉTFŐ van\", és \"CHARLIE\" azt mondja: \"ALICE bűnös.\", mivel a hét napjára vonatkozó állítások figyelmen kívül vannak hagyva."
    },
    "docstring_bertscore": {
      "sq": "0.989131541440914",
      "hy": "0.9696526544943467",
      "bn": "0.9555228837090489",
      "bg": "0.9798036601171346",
      "zh": "0.9582661679015217",
      "fr": "0.9863608462558584",
      "de": "0.9727532747423013",
      "ha": "0.9724388428491231",
      "hi": "0.9693102157174426",
      "hu": "0.9691582634759508"
    }
  },
  {
    "task_id": "Python/33",
    "prompt": {
      "en": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    - If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\n      with scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\n      The 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "sq": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Llogarit rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\n    Kjo funksion merr sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg \n    që përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L'). \n    Funksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"rezultati_i_lojtari:rezultati_i_kundërshtari\".\n\n    Loja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit \n    (11 ose 21) me të paktën një avantazh prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje, \n    rezultati aktual i asaj loje përfshihet gjithashtu në rezultat.\n\n    Argumentet:\n    - system (int): Numri i pikëve të kërkuara për të fituar një lojë (ose 11 ose 21).\n    - points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\n    Kthen:\n    - list: Një listë me vargje që përfaqësojnë rezultatin e secilës lojë.\n\n    Rastet:\n    - Nëse points = \"WWWWWWWWWWL\", përfaqëson një lojë të plotë me lojtarin që fiton 10-1 nën të dy sistemet.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Nëse points = \"WWLWWLWWLWWLWE\", përfaqëson dy lojëra të plota dhe një lojë në progres nën sistemin me 11 pikë,\n      me rezultatet 2-1, 2-1, dhe 1-1 respektivisht. Nën sistemin me 21 pikë, përfaqëson një lojë të vetme me rezultatin 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Nëse points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", përfaqëson disa lojëra nën të dy sistemet, me lojën e fundit të papërfunduar.\n      Sistemi me 11 pikë ka rezultatet 4-6, 5-5, dhe 1-0, ndërsa sistemi me 21 pikë ka rezultatet 13-16 dhe 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "hy": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Հաշվել պինգ-պոնգ խաղերի սերիայի հաշիվը ըստ տրամադրված միավորների համակարգի:\n\n    Այս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և \n    տող, որը ներկայացնում է խաղացողի ('W') և մրցակցի ('L') կողմից շահած միավորների \n    հաջորդականությունը: Ֆունկցիան մշակում է տողը և վերադարձնում խաղերի հաշիվների \n    ցուցակը, ձևաչափված որպես \"խաղացողի_հաշիվ:մրցակցի_հաշիվ\":\n\n    Խաղը համարվում է ավարտված, երբ խաղացողներից մեկը հասնում է համակարգի պահանջած \n    միավորների քանակին (11 կամ 21) առնվազն 2 միավորի առավելությամբ: Եթե միավորների \n    հաջորդականությունը ավարտվում է խաղի ընթացքում, այդ խաղի ընթացիկ հաշիվը նույնպես \n    ներառվում է արդյունքի մեջ:\n\n    Արգումենտներ:\n    - system (int): Խաղը շահելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21):\n    - points (str): 'W' և 'L' նիշերի տող, որը նշում է խաղացողի և մրցակցի կողմից շահած միավորները:\n\n    Վերադարձնում է:\n    - list: Տողերի ցուցակ, որը ներկայացնում է յուրաքանչյուր խաղի հաշիվը:\n\n    Դեպքեր:\n    - Եթե points = \"WWWWWWWWWWL\", այն ներկայացնում է մեկ ամբողջական խաղ, որտեղ խաղացողը \n      հաղթում է 10-1 երկու համակարգերում էլ:\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Եթե points = \"WWLWWLWWLWWLWE\", այն ներկայացնում է երկու ամբողջական խաղ և մեկ ընթացիկ \n      խաղ 11 միավորի համակարգում, համապատասխանաբար 2-1, 2-1 և 1-1 հաշիվներով: 21 միավորի \n      համակարգում այն ներկայացնում է մեկ խաղ 6-3 հաշիվով:\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Եթե points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", այն ներկայացնում է բազմաթիվ խաղեր երկու \n      համակարգերում էլ, վերջին խաղը չավարտված: 11 միավորի համակարգում հաշիվները 4-6, 5-5 և 1-0 են, \n      իսկ 21 միավորի համակարգում՝ 13-16 և 2-1:\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "bn": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    প্রদত্ত স্কোরিং সিস্টেমের ভিত্তিতে পিং-পং গেমের একটি সিরিজের স্কোর গণনা করুন।\n\n    এই ফাংশনটি কাঙ্ক্ষিত স্কোরিং সিস্টেম (১১ বা ২১ পয়েন্ট) এবং একটি স্ট্রিং \n    নেয় যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জেতা পয়েন্টের ক্রমকে উপস্থাপন করে। \n    ফাংশনটি স্ট্রিংটি প্রক্রিয়া করে এবং গেম স্কোরের একটি তালিকা প্রদান করে যা \"player_score:opponent_score\" হিসাবে ফরম্যাট করা হয়।\n\n    যখন একজন খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১) কমপক্ষে ২ পয়েন্টের লিড সহ পৌঁছায়, তখন গেমটি শেষ হয়েছে বলে বিবেচিত হয়। \n    যদি পয়েন্টের ক্রমটি একটি গেমের মাঝখানে শেষ হয়, তবে সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত করা হয়।\n\n    আর্গুমেন্টসমূহ:\n    - system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১ এর মধ্যে একটি)।\n    - points (str): 'W' এবং 'L' অক্ষরের একটি স্ট্রিং যা খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জেতা পয়েন্ট নির্দেশ করে।\n\n    রিটার্ন:\n    - list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\n    কেসসমূহ:\n    - যদি points = \"WWWWWWWWWWL\", এটি উভয় সিস্টেমের অধীনে খেলোয়াড়ের ১০-১ জয়ের সাথে একটি সম্পূর্ণ গেমকে উপস্থাপন করে।\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - যদি points = \"WWLWWLWWLWWLWE\", এটি ১১-পয়েন্ট সিস্টেমের অধীনে দুটি সম্পূর্ণ গেম এবং একটি চলমান গেমকে উপস্থাপন করে,\n      স্কোর ২-১, ২-১, এবং ১-১ যথাক্রমে। ২১-পয়েন্ট সিস্টেমের অধীনে, এটি একটি একক গেমকে ৬-৩ স্কোর সহ উপস্থাপন করে।\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - যদি points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", এটি উভয় সিস্টেমের অধীনে একাধিক গেমকে উপস্থাপন করে, শেষ গেমটি অসমাপ্ত।\n      ১১-পয়েন্ট সিস্টেমের স্কোর ৪-৬, ৫-৫, এবং ১-০, যখন ২১-পয়েন্ট সিস্টেমের স্কোর ১৩-১৬ এবং ২-১।\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "bg": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Изчисляване на резултата от серия пинг-понг игри на базата на предоставената система за точкуване.\n\n    Тази функция приема желаната система за точкуване (или 11 или 21 точки) и низ, \n    представляващ последователността от точки, спечелени от играча ('W') и противника ('L'). \n    Функцията обработва низа и връща списък с резултати от игрите, форматирани като \"player_score:opponent_score\".\n\n    Играта се счита за завършена, когато един играч достигне изисквания брой точки на системата \n    (11 или 21) с поне 2 точки преднина. Ако последователността от точки завърши в средата на игра, \n    текущият резултат на тази игра също е включен в изхода.\n\n    Аргументи:\n    - system (int): Броят точки, необходими за спечелване на игра (или 11 или 21).\n    - points (str): Низ от символи 'W' и 'L', обозначаващи точки, спечелени от играча и противника.\n\n    Връща:\n    - list: Списък от низове, представляващи резултата от всяка игра.\n\n    Примери:\n    - Ако points = \"WWWWWWWWWWL\", това представлява една завършена игра с победа на играча 10-1 и в двете системи.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Ако points = \"WWLWWLWWLWWLWE\", това представлява две завършени игри и една в процес на игра в системата с 11 точки,\n      с резултати 2-1, 2-1 и 1-1 съответно. В системата с 21 точки, това представлява една игра с резултат 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Ако points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", това представлява множество игри в двете системи, като последната игра е незавършена.\n      Системата с 11 точки има резултати 4-6, 5-5 и 1-0, докато системата с 21 точки има резултати 13-16 и 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "zh": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    根据提供的计分系统计算一系列乒乓球比赛的得分。\n\n    此函数接收所需的计分系统（11分或21分）和一个字符串，表示玩家（'W'）和对手（'L'）赢得的分数序列。\n    函数处理该字符串并返回一个游戏得分列表，格式为 \"player_score:opponent_score\"。\n\n    当一名玩家达到系统要求的分数（11或21）并至少领先2分时，比赛被视为结束。\n    如果分数序列在比赛中途结束，该比赛的当前得分也会包含在输出中。\n\n    参数:\n    - system (int): 赢得一局比赛所需的分数（11或21）。\n    - points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n    返回:\n    - list: 一个字符串列表，表示每局比赛的得分。\n\n    示例:\n    - 如果 points = \"WWWWWWWWWWL\"，表示在两种系统下玩家以10-1赢得一局完整比赛。\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - 如果 points = \"WWLWWLWWLWWLWE\"，表示在11分系统下有两局完整比赛和一局进行中的比赛，得分分别为2-1, 2-1和1-1。\n      在21分系统下，表示单局比赛，得分为6-3。\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - 如果 points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"，表示在两种系统下有多局比赛，最后一局未完成。\n      11分系统的得分为4-6, 5-5和1-0，而21分系统的得分为13-16和2-1。\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "fr": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculer le score d'une série de jeux de ping-pong basé sur le système de score fourni.\n\n    Cette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne \n    représentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L'). \n    La fonction traite la chaîne et renvoie une liste de scores de jeux formatés comme \"player_score:opponent_score\".\n\n    Le jeu est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système \n    (11 ou 21) avec au moins 2 points d'avance. Si la séquence de points se termine au milieu d'un jeu, \n    le score actuel de ce jeu est également inclus dans la sortie.\n\n    Args:\n    - system (int): Le nombre de points requis pour gagner un jeu (soit 11 ou 21).\n    - points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\n    Returns:\n    - list: Une liste de chaînes représentant le score de chaque jeu.\n\n    Cas:\n    - Si points = \"WWWWWWWWWWL\", cela représente un jeu complet avec le joueur gagnant 10-1 dans les deux systèmes.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Si points = \"WWLWWLWWLWWLWE\", cela représente deux jeux complets et un jeu en cours sous le système de 11 points,\n      avec des scores de 2-1, 2-1, et 1-1 respectivement. Sous le système de 21 points, cela représente un seul jeu avec un score de 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Si points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", cela représente plusieurs jeux sous les deux systèmes, avec le dernier jeu non terminé.\n      Le système de 11 points a des scores de 4-6, 5-5, et 1-0, tandis que le système de 21 points a des scores de 13-16 et 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "de": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Berechne die Punktzahl einer Serie von Tischtennisspielen basierend auf dem angegebenen Punktesystem.\n\n    Diese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String, \n    der die Abfolge der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt, entgegen. \n    Die Funktion verarbeitet den String und gibt eine Liste von Spielständen im Format \"player_score:opponent_score\" zurück.\n\n    Das Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems \n    (11 oder 21) mit mindestens 2 Punkten Vorsprung erreicht. Wenn die Punktesequenz mitten in einem Spiel endet, \n    wird der aktuelle Spielstand dieses Spiels ebenfalls in die Ausgabe aufgenommen.\n\n    Argumente:\n    - system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n    - points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte anzeigen.\n\n    Rückgabewert:\n    - list: Eine Liste von Strings, die den Spielstand jedes Spiels darstellen.\n\n    Fälle:\n    - Wenn points = \"WWWWWWWWWWL\", stellt es ein vollständiges Spiel dar, bei dem der Spieler mit 10-1 in beiden Systemen gewinnt.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Wenn points = \"WWLWWLWWLWWLWE\", stellt es zwei vollständige Spiele und ein laufendes Spiel im 11-Punkte-System dar,\n      mit den Spielständen 2-1, 2-1 und 1-1. Im 21-Punkte-System stellt es ein einzelnes Spiel mit einem Spielstand von 6-3 dar.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Wenn points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", stellt es mehrere Spiele in beiden Systemen dar, wobei das letzte Spiel unvollständig ist.\n      Das 11-Punkte-System hat die Spielstände 4-6, 5-5 und 1-0, während das 21-Punkte-System die Spielstände 13-16 und 2-1 hat.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "ha": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Lissafa maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\n    Wannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma wani igiyar \n    haruffa da ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci. \n    Aikin yana sarrafa igiyar kuma yana dawo da jerin maki na wasanni da aka tsara kamar \"maki_ɗan_wasa:maki_abokin_hamayya\".\n\n    Ana ɗaukar wasan ya ƙare idan ɗaya daga cikin 'yan wasan ya kai adadin maki da ake buƙata \n    na tsarin (11 ko 21) tare da tazarar maki 2 aƙalla. Idan jerin maki ya ƙare a tsakiyar wasa, \n    ana haɗa maki na wannan wasan a cikin sakamakon.\n\n    Args:\n    - system (int): Adadin maki da ake buƙata don cin wasa (ko dai 11 ko 21).\n    - points (str): Wani igiyar haruffa na 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\n    Returns:\n    - list: Jerin igiyoyi da ke wakiltar maki na kowane wasa.\n\n    Cases:\n    - Idan points = \"WWWWWWWWWWL\", yana wakiltar wasa guda ɗaya da ɗan wasa ya ci 10-1 a ƙarƙashin dukkan tsarin.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Idan points = \"WWLWWLWWLWWLWE\", yana wakiltar wasanni biyu cikakku da ɗaya da ke ci gaba a ƙarƙashin tsarin maki 11,\n      tare da maki 2-1, 2-1, da 1-1 bi da bi. A ƙarƙashin tsarin maki 21, yana wakiltar wasa guda ɗaya da maki 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Idan points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", yana wakiltar wasanni da yawa a ƙarƙashin dukkan tsarin, tare da wasan ƙarshe ba a gama ba.\n      Tsarin maki 11 yana da maki 4-6, 5-5, da 1-0, yayin da tsarin maki 21 yana da maki 13-16 da 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "hi": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    प्रदान किए गए स्कोरिंग सिस्टम के आधार पर पिंग-पोंग खेलों की श्रृंखला का स्कोर गणना करें।\n\n    यह फ़ंक्शन वांछित स्कोरिंग सिस्टम (या तो 11 या 21 अंक) और एक स्ट्रिंग लेता है \n    जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के अनुक्रम का प्रतिनिधित्व करता है। \n    फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और गेम स्कोर की एक सूची \"player_score:opponent_score\" के रूप में लौटाता है।\n\n    खेल को समाप्त माना जाता है जब एक खिलाड़ी सिस्टम द्वारा आवश्यक अंकों की संख्या \n    (11 या 21) कम से कम 2 अंकों की बढ़त के साथ प्राप्त कर लेता है। यदि अंकों का अनुक्रम खेल के बीच में समाप्त होता है, \n    तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल होता है।\n\n    तर्क:\n    - system (int): गेम जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n    - points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\n    रिटर्न:\n    - list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\n    मामले:\n    - यदि points = \"WWWWWWWWWWL\", तो यह एक पूर्ण खेल का प्रतिनिधित्व करता है जिसमें खिलाड़ी 10-1 से जीतता है दोनों सिस्टमों के तहत।\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - यदि points = \"WWLWWLWWLWWLWE\", तो यह 11-अंक प्रणाली के तहत दो पूर्ण खेलों और एक प्रगति में खेल का प्रतिनिधित्व करता है,\n      स्कोर 2-1, 2-1, और 1-1 क्रमशः। 21-अंक प्रणाली के तहत, यह एकल खेल का प्रतिनिधित्व करता है जिसका स्कोर 6-3 है।\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - यदि points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", तो यह दोनों सिस्टमों के तहत कई खेलों का प्रतिनिधित्व करता है, जिसमें अंतिम खेल अधूरा है।\n      11-अंक प्रणाली में स्कोर 4-6, 5-5, और 1-0 हैं, जबकि 21-अंक प्रणाली में स्कोर 13-16 और 2-1 हैं।\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "hu": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Számolja ki egy sorozat ping-pong játék pontszámát az adott pontozási rendszer alapján.\n\n    Ez a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot vesz fel, \n    amely a játékos ('W') és az ellenfél ('L') által nyert pontok sorozatát ábrázolja. \n    A függvény feldolgozza a karakterláncot, és visszaad egy listát a játék pontszámaival, \n    \"player_score:opponent_score\" formátumban.\n\n    A játék akkor tekinthető befejezettnek, amikor az egyik játékos eléri a rendszer által megkövetelt \n    pontszámot (11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorozata egy játék közepén ér véget, \n    az adott játék aktuális pontszáma is szerepel a kimenetben.\n\n    Args:\n    - system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n    - points (str): 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\n    Returns:\n    - list: A játékok pontszámait reprezentáló karakterláncok listája.\n\n    Esetek:\n    - Ha points = \"WWWWWWWWWWL\", ez egy teljes játékot jelent, ahol a játékos 10-1-re nyer mindkét rendszer alatt.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Ha points = \"WWLWWLWWLWWLWE\", ez két teljes játékot és egy folyamatban lévő játékot jelent a 11 pontos rendszer alatt,\n      pontszámokkal 2-1, 2-1 és 1-1. A 21 pontos rendszer alatt ez egyetlen játékot jelent 6-3-as pontszámmal.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Ha points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", ez több játékot jelent mindkét rendszer alatt, az utolsó játék befejezetlen.\n      A 11 pontos rendszer alatt a pontszámok 4-6, 5-5 és 1-0, míg a 21 pontos rendszer alatt 13-16 és 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9814528881708673",
      "hy": "0.9649848405400268",
      "bn": "0.9764855396019468",
      "bg": "0.9776036300167922",
      "zh": "0.941819572351833",
      "fr": "0.9740658243001798",
      "de": "0.9638157021172554",
      "ha": "0.977072691008286",
      "hi": "0.9755833604112863",
      "hu": "0.974436865851953"
    },
    "canonical_solution": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores",
    "instruction": {
      "en": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.8657447323066139",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9404883515381371",
      "hi": "0.8964889413135749",
      "hu": "0.9315178062698395"
    },
    "level": "",
    "test": "def test_calculate_score():\n    # Test case 1: A single game in both systems, with a clear winner.\n    points = \"WWWWWWWWWWL\"\n    expected_11 = [\"10:1\"]\n    expected_21 = [\"10:1\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 1 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 1 (21-point) failed\"\n\n    # Test case 2: Multiple games, some completed and one in progress.\n    points = \"WWLWWLWWLWWLWE\"\n    expected_11 = [\"9:4\"]\n    expected_21 = [\"9:4\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 2 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 2 (21-point) failed\"\n\n    # Test case 3: A longer sequence with many games and a final unfinished game.\n    points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"\n    expected_11 = ['12:10', '5:4']\n    expected_21 = ['17:14']\n    assert calculate_score(11, points) == expected_11, \"Test case 3 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 3 (21-point) failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_calculate_score()",
    "entry_point": "calculate_score",
    "signature": "def calculate_score(system: int, points: str) -> list:",
    "docstring": {
      "en": "Calculate the score of a series of ping-pong games based on the provided scoring system.\n\nThis function takes in the desired scoring system (either 11 or 21 points) and a string\nrepresenting the sequence of points won by the player ('W') and the opponent ('L').\nThe function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\nThe game is considered finished when one player reaches the system's required number of points\n(11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game,\nthat game's current score is also included in the output.\n\nArgs:\n- system (int): The number of points required to win a game (either 11 or 21).\n- points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\nReturns:\n- list: A list of strings representing the score of each game.\n\nCases:\n- If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\nwith scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\nThe 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "sq": "Llogaritni rezultatin e një serie lojërash ping-pong bazuar në sistemin e dhënë të pikëve.\n\nKjo funksion merr si hyrje sistemin e dëshiruar të pikëve (ose 11 ose 21 pikë) dhe një varg\nqë përfaqëson sekuencën e pikëve të fituara nga lojtari ('W') dhe kundërshtari ('L').\nFunksioni përpunon vargun dhe kthen një listë të rezultateve të lojërave të formatuara si \"rezultati_lojtari:rezultati_kundërshtari\".\n\nLoja konsiderohet e përfunduar kur një lojtar arrin numrin e kërkuar të pikëve të sistemit\n(11 ose 21) me të paktën një avantazh prej 2 pikësh. Nëse sekuenca e pikëve përfundon në mes të një loje,\nrezultati aktual i asaj loje gjithashtu përfshihet në dalje.\n\nArgumentet:\n- system (int): Numri i pikëve të kërkuara për të fituar një lojë (ose 11 ose 21).\n- points (str): Një varg me karaktere 'W' dhe 'L' që tregojnë pikët e fituara nga lojtari dhe kundërshtari.\n\nKthen:\n- list: Një listë me vargje që përfaqësojnë rezultatin e secilës lojë.\n\nRastet:\n- Nëse points = \"WWWWWWWWWWL\", përfaqëson një lojë të plotë me lojtarin që fiton 10-1 nën të dy sistemet.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Nëse points = \"WWLWWLWWLWWLWE\", përfaqëson dy lojëra të plota dhe një lojë në progres nën sistemin me 11 pikë,\nme rezultate 2-1, 2-1, dhe 1-1 respektivisht. Nën sistemin me 21 pikë, përfaqëson një lojë të vetme me rezultat 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Nëse points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", përfaqëson lojëra të shumta nën të dy sistemet, me lojën e fundit të papërfunduar.\nSistemi me 11 pikë ka rezultate 4-6, 5-5, dhe 1-0, ndërsa sistemi me 21 pikë ka rezultate 13-16 dhe 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "hy": "Հաշվարկել պինգ-պոնգ խաղերի շարքի միավորները՝ հիմնվելով տրված միավորների համակարգի վրա։\n\nԱյս ֆունկցիան ընդունում է ցանկալի միավորների համակարգը (կամ 11 կամ 21 միավոր) և մի տող,\nորը ներկայացնում է խաղացողի ('W') և մրցակցի ('L') կողմից շահած միավորների հաջորդականությունը։\nՖունկցիան մշակում է տողը և վերադարձնում խաղերի միավորների ցուցակը՝ ձևաչափված որպես \"խաղացողի_միավորներ:մրցակցի_միավորներ\"։\n\nԽաղը համարվում է ավարտված, երբ խաղացողներից մեկը հասնում է համակարգի պահանջվող միավորների քանակին\n(11 կամ 21) առնվազն 2 միավորի առավելությամբ։ Եթե միավորների հաջորդականությունը ավարտվում է խաղի ընթացքում,\nայդ խաղի ընթացիկ միավորները նույնպես ներառվում են արդյունքում։\n\nԱրձագանքներ:\n- system (int): Խաղը շահելու համար պահանջվող միավորների քանակը (կամ 11 կամ 21)։\n- points (str): 'W' և 'L' տառերի տող, որը նշում է խաղացողի և մրցակցի կողմից շահած միավորները։\n\nՎերադարձնում է:\n- list: Տողերի ցուցակ, որը ներկայացնում է յուրաքանչյուր խաղի միավորները։\n\nԴեպքեր:\n- Եթե points = \"WWWWWWWWWWL\", այն ներկայացնում է մեկ ամբողջական խաղ, որտեղ խաղացողը հաղթում է 10-1 երկու համակարգերով։\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Եթե points = \"WWLWWLWWLWWLWE\", այն ներկայացնում է երկու ամբողջական խաղ և մեկ ընթացիկ խաղ 11 միավորների համակարգով,\nմիավորներով 2-1, 2-1 և 1-1 համապատասխանաբար։ 21 միավորների համակարգով այն ներկայացնում է մեկ խաղ՝ 6-3 միավորով։\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Եթե points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", այն ներկայացնում է բազմաթիվ խաղեր երկու համակարգերով, վերջին խաղը չավարտված։\n11 միավորների համակարգը ունի 4-6, 5-5 և 1-0 միավորներ, մինչդեռ 21 միավորների համակարգը ունի 13-16 և 2-1 միավորներ։\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "bn": "পিং-পং গেমের একটি সিরিজের স্কোর প্রদত্ত স্কোরিং সিস্টেমের ভিত্তিতে গণনা করুন।\n\nএই ফাংশনটি ইচ্ছাকৃত স্কোরিং সিস্টেম (১১ বা ২১ পয়েন্ট) এবং একটি স্ট্রিং গ্রহণ করে যা খেলোয়াড় ('W') এবং প্রতিপক্ষ ('L') দ্বারা জেতা পয়েন্টের ক্রম উপস্থাপন করে। ফাংশনটি স্ট্রিংটি প্রক্রিয়া করে এবং \"player_score:opponent_score\" হিসাবে ফরম্যাট করা গেম স্কোরের একটি তালিকা প্রদান করে।\n\nযখন একজন খেলোয়াড় সিস্টেমের প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১) কমপক্ষে ২ পয়েন্টের লিড সহ পৌঁছায়, তখন গেমটি শেষ হয়েছে বলে বিবেচিত হয়। যদি পয়েন্টের ক্রম একটি গেমের মাঝখানে শেষ হয়, তবে সেই গেমের বর্তমান স্কোরও আউটপুটে অন্তর্ভুক্ত হয়।\n\nআর্গস:\n- system (int): একটি গেম জিততে প্রয়োজনীয় পয়েন্ট সংখ্যা (১১ বা ২১ এর যেকোনো একটি)।\n- points (str): 'W' এবং 'L' অক্ষরের একটি স্ট্রিং যা খেলোয়াড় এবং প্রতিপক্ষ দ্বারা জেতা পয়েন্ট নির্দেশ করে।\n\nরিটার্নস:\n- list: প্রতিটি গেমের স্কোর উপস্থাপনকারী স্ট্রিংগুলির একটি তালিকা।\n\nকেসসমূহ:\n- যদি points = \"WWWWWWWWWWL\", এটি উভয় সিস্টেমের অধীনে খেলোয়াড়ের ১০-১ জয়ে একটি সম্পূর্ণ গেম উপস্থাপন করে।\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- যদি points = \"WWLWWLWWLWWLWE\", এটি ১১-পয়েন্ট সিস্টেমের অধীনে দুটি সম্পূর্ণ গেম এবং একটি চলমান গেম উপস্থাপন করে, যার স্কোর যথাক্রমে ২-১, ২-১, এবং ১-১। ২১-পয়েন্ট সিস্টেমের অধীনে, এটি একটি একক গেম উপস্থাপন করে যার স্কোর ৬-৩।\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- যদি points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", এটি উভয় সিস্টেমের অধীনে একাধিক গেম উপস্থাপন করে, যেখানে শেষ গেমটি অসমাপ্ত। ১১-পয়েন্ট সিস্টেমের স্কোর ৪-৬, ৫-৫, এবং ১-০, যখন ২১-পয়েন্ট সিস্টেমের স্কোর ১৩-১৬ এবং ২-১।\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "bg": "Изчисляване на резултата от серия пинг-понг игри на базата на предоставената точкова система.\n\nТази функция приема желаната точкова система (или 11, или 21 точки) и низ, представляващ последователността от точки, спечелени от играча ('W') и противника ('L'). Функцията обработва низа и връща списък с резултати от игрите, форматирани като \"резултат_на_играча:резултат_на_противника\".\n\nИграта се счита за завършена, когато един играч достигне изисквания брой точки на системата (11 или 21) с поне 2 точки преднина. Ако последователността от точки завършва в средата на игра, текущият резултат на тази игра също се включва в изхода.\n\nАргументи:\n- system (int): Броят точки, необходими за спечелване на игра (или 11, или 21).\n- points (str): Низ от символи 'W' и 'L', обозначаващи точките, спечелени от играча и противника.\n\nВръща:\n- list: Списък от низове, представляващи резултата от всяка игра.\n\nСлучаи:\n- Ако points = \"WWWWWWWWWWL\", това представлява една завършена игра с победа на играча 10-1 при двете системи.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Ако points = \"WWLWWLWWLWWLWE\", това представлява две завършени игри и една игра в процес при системата с 11 точки, с резултати 2-1, 2-1 и 1-1 съответно. При системата с 21 точки, това представлява една игра с резултат 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Ако points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", това представлява множество игри при двете системи, като последната игра е незавършена. Системата с 11 точки има резултати 4-6, 5-5 и 1-0, докато системата с 21 точки има резултати 13-16 и 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "zh": "计算一系列乒乓球比赛的得分，基于提供的计分系统。\n\n此函数接收所需的计分系统（11分或21分）和一个字符串，表示玩家（'W'）和对手（'L'）赢得的分数序列。函数处理该字符串并返回一个游戏得分列表，格式为 \"player_score:opponent_score\"。\n\n当一名玩家达到系统要求的分数（11或21分）且至少领先2分时，比赛被视为结束。如果分数序列在比赛中途结束，该场比赛的当前得分也会包含在输出中。\n\n参数:\n- system (int): 赢得一场比赛所需的分数（11或21）。\n- points (str): 一个由 'W' 和 'L' 字符组成的字符串，表示玩家和对手赢得的分数。\n\n返回:\n- list: 一个字符串列表，表示每场比赛的得分。\n\n案例:\n- 如果 points = \"WWWWWWWWWWL\"，它表示在两种系统下玩家以10-1赢得一场完整比赛。\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- 如果 points = \"WWLWWLWWLWWLWE\"，在11分制下，它表示两场完整比赛和一场进行中的比赛，得分分别为2-1、2-1和1-1。在21分制下，它表示一场比赛，得分为6-3。\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- 如果 points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"，它表示在两种系统下的多场比赛，最后一场未完成。11分制的得分为4-6、5-5和1-0，而21分制的得分为13-16和2-1。\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "fr": "Calculer le score d'une série de jeux de ping-pong basé sur le système de score fourni.\n\nCette fonction prend en entrée le système de score souhaité (soit 11 ou 21 points) et une chaîne\nreprésentant la séquence de points gagnés par le joueur ('W') et l'adversaire ('L').\nLa fonction traite la chaîne et renvoie une liste de scores de jeu formatés comme \"score_joueur:score_adversaire\".\n\nLe jeu est considéré comme terminé lorsqu'un joueur atteint le nombre de points requis par le système\n(11 ou 21) avec au moins une avance de 2 points. Si la séquence de points se termine au milieu d'un jeu,\nle score actuel de ce jeu est également inclus dans le résultat.\n\nArgs:\n- system (int): Le nombre de points requis pour gagner un jeu (soit 11 ou 21).\n- points (str): Une chaîne de caractères 'W' et 'L' indiquant les points gagnés par le joueur et l'adversaire.\n\nReturns:\n- list: Une liste de chaînes représentant le score de chaque jeu.\n\nCas:\n- Si points = \"WWWWWWWWWWL\", cela représente un jeu complet avec le joueur gagnant 10-1 sous les deux systèmes.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Si points = \"WWLWWLWWLWWLWE\", cela représente deux jeux complets et un jeu en cours sous le système de 11 points,\navec des scores de 2-1, 2-1, et 1-1 respectivement. Sous le système de 21 points, cela représente un seul jeu avec un score de 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Si points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", cela représente plusieurs jeux sous les deux systèmes, avec le dernier jeu inachevé.\nLe système de 11 points a des scores de 4-6, 5-5, et 1-0, tandis que le système de 21 points a des scores de 13-16 et 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "de": "Berechne die Punktzahl einer Serie von Ping-Pong-Spielen basierend auf dem angegebenen Punktesystem.\n\nDiese Funktion nimmt das gewünschte Punktesystem (entweder 11 oder 21 Punkte) und einen String entgegen,\nder die Sequenz der vom Spieler ('W') und vom Gegner ('L') gewonnenen Punkte darstellt.\nDie Funktion verarbeitet den String und gibt eine Liste von Spielständen im Format \"spieler_punkte:gegner_punkte\" zurück.\n\nDas Spiel gilt als beendet, wenn ein Spieler die erforderliche Punktzahl des Systems erreicht\n(11 oder 21) mit mindestens einem 2-Punkte-Vorsprung. Wenn die Punktesequenz mitten in einem Spiel endet,\nwird der aktuelle Spielstand dieses Spiels ebenfalls in der Ausgabe enthalten.\n\nArgs:\n- system (int): Die Anzahl der Punkte, die erforderlich sind, um ein Spiel zu gewinnen (entweder 11 oder 21).\n- points (str): Ein String aus 'W'- und 'L'-Zeichen, die die vom Spieler und Gegner gewonnenen Punkte anzeigen.\n\nReturns:\n- list: Eine Liste von Strings, die den Spielstand jedes Spiels darstellen.\n\nFälle:\n- Wenn points = \"WWWWWWWWWWL\", stellt es ein vollständiges Spiel dar, bei dem der Spieler mit 10-1 in beiden Systemen gewinnt.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Wenn points = \"WWLWWLWWLWWLWE\", stellt es zwei vollständige Spiele und ein laufendes Spiel im 11-Punkte-System dar,\nmit den Spielständen 2-1, 2-1 und 1-1. Im 21-Punkte-System stellt es ein einzelnes Spiel mit einem Spielstand von 6-3 dar.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Wenn points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", stellt es mehrere Spiele in beiden Systemen dar, wobei das letzte Spiel unvollständig ist.\nDas 11-Punkte-System hat die Spielstände 4-6, 5-5 und 1-0, während das 21-Punkte-System die Spielstände 13-16 und 2-1 hat.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "ha": "Ƙididdige maki na jerin wasannin ping-pong bisa tsarin maki da aka bayar.\n\nWannan aikin yana karɓar tsarin maki da ake so (ko dai maki 11 ko 21) da kuma wani kirtani\nda ke wakiltar jerin maki da ɗan wasa ('W') da abokin hamayya ('L') suka ci.\nAikin yana sarrafa kirtanin kuma yana mayar da jerin maki na wasanni da aka tsara kamar \"maki_ɗan_wasa:maki_abokin_hamayya\".\n\nAna ɗaukar wasan ya ƙare idan ɗaya daga cikin 'yan wasan ya kai adadin maki da ake buƙata\n(11 ko 21) tare da tazarar maki 2 a kalla. Idan jerin maki ya ƙare a tsakiyar wasa,\nana kuma haɗa maki na yanzu na wannan wasan a cikin sakamakon.\n\nArgs:\n- system (int): Adadin maki da ake buƙata don cin nasara a wasa (ko dai 11 ko 21).\n- points (str): Wani kirtani na haruffan 'W' da 'L' da ke nuna maki da ɗan wasa da abokin hamayya suka ci.\n\nReturns:\n- list: Jerin kirtani da ke wakiltar maki na kowane wasa.\n\nMisalai:\n- Idan points = \"WWWWWWWWWWL\", yana wakiltar wasa guda ɗaya da ɗan wasa ya ci 10-1 a ƙarƙashin duka tsarin.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Idan points = \"WWLWWLWWLWWLWE\", yana wakiltar wasanni guda biyu da wasa ɗaya da ba a gama ba a ƙarƙashin tsarin maki 11,\ntare da maki 2-1, 2-1, da 1-1 bi da bi. A ƙarƙashin tsarin maki 21, yana wakiltar wasa ɗaya da maki 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Idan points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", yana wakiltar wasanni da yawa a ƙarƙashin duka tsarin, tare da wasan ƙarshe da ba a gama ba.\nTsarin maki 11 yana da maki 4-6, 5-5, da 1-0, yayin da tsarin maki 21 yana da maki 13-16 da 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "hi": "पिंग-पोंग खेलों की एक श्रृंखला का स्कोर प्रदान की गई स्कोरिंग प्रणाली के आधार पर गणना करें।\n\nयह फ़ंक्शन वांछित स्कोरिंग प्रणाली (या तो 11 या 21 अंक) और एक स्ट्रिंग को लेता है जो खिलाड़ी ('W') और प्रतिद्वंद्वी ('L') द्वारा जीते गए अंकों के अनुक्रम का प्रतिनिधित्व करती है। फ़ंक्शन स्ट्रिंग को प्रोसेस करता है और गेम स्कोर की एक सूची को \"player_score:opponent_score\" के रूप में स्वरूपित करके लौटाता है।\n\nखेल को समाप्त माना जाता है जब एक खिलाड़ी प्रणाली द्वारा आवश्यक अंकों की संख्या (11 या 21) तक कम से कम 2 अंकों की बढ़त के साथ पहुँच जाता है। यदि अंकों का अनुक्रम खेल के मध्य में समाप्त होता है, तो उस खेल का वर्तमान स्कोर भी आउटपुट में शामिल होता है।\n\nआर्ग्स:\n- system (int): एक खेल जीतने के लिए आवश्यक अंकों की संख्या (या तो 11 या 21)।\n- points (str): 'W' और 'L' वर्णों की एक स्ट्रिंग जो खिलाड़ी और प्रतिद्वंद्वी द्वारा जीते गए अंकों को दर्शाती है।\n\nरिटर्न्स:\n- list: प्रत्येक खेल के स्कोर का प्रतिनिधित्व करने वाली स्ट्रिंग्स की एक सूची।\n\nमामले:\n- यदि points = \"WWWWWWWWWWL\", तो यह एक पूर्ण खेल का प्रतिनिधित्व करता है जिसमें खिलाड़ी दोनों प्रणालियों के तहत 10-1 से जीतता है।\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- यदि points = \"WWLWWLWWLWWLWE\", तो यह 11-अंक प्रणाली के तहत दो पूर्ण खेलों और एक प्रगति पर खेल का प्रतिनिधित्व करता है, जिसमें स्कोर क्रमशः 2-1, 2-1, और 1-1 हैं। 21-अंक प्रणाली के तहत, यह एकल खेल का प्रतिनिधित्व करता है जिसका स्कोर 6-3 है।\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- यदि points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", तो यह दोनों प्रणालियों के तहत कई खेलों का प्रतिनिधित्व करता है, जिसमें अंतिम खेल अधूरा है। 11-अंक प्रणाली के तहत स्कोर 4-6, 5-5, और 1-0 हैं, जबकि 21-अंक प्रणाली के तहत स्कोर 13-16 और 2-1 हैं।\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "hu": "Számítsa ki egy sorozat pingpong játék eredményét a megadott pontozási rendszer alapján.\n\nEz a függvény a kívánt pontozási rendszert (vagy 11 vagy 21 pont) és egy karakterláncot vesz be,\namely a játékos ('W') és az ellenfél ('L') által nyert pontok sorozatát ábrázolja.\nA függvény feldolgozza a karakterláncot, és visszaad egy listát a játék eredményeiről, \"player_score:opponent_score\" formátumban.\n\nA játék akkor tekinthető befejezettnek, amikor az egyik játékos eléri a rendszer által megkövetelt pontszámot\n(11 vagy 21) legalább 2 pontos előnnyel. Ha a pontok sorozata egy játék közepén ér véget,\nakkor annak a játéknak az aktuális eredménye is szerepel a kimenetben.\n\nArgs:\n- system (int): A játék megnyeréséhez szükséges pontok száma (vagy 11 vagy 21).\n- points (str): 'W' és 'L' karakterekből álló karakterlánc, amely a játékos és az ellenfél által nyert pontokat jelöli.\n\nReturns:\n- list: A játékok eredményeit ábrázoló karakterláncok listája.\n\nEsetek:\n- Ha points = \"WWWWWWWWWWL\", akkor ez egy teljes játékot jelent, ahol a játékos 10-1-re nyer mindkét rendszerben.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Ha points = \"WWLWWLWWLWWLWE\", akkor ez két teljes játékot és egy folyamatban lévő játékot jelent a 11 pontos rendszerben,\n2-1, 2-1 és 1-1 eredményekkel. A 21 pontos rendszerben ez egyetlen játékot jelent 6-3 eredménnyel.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Ha points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", akkor ez több játékot jelent mindkét rendszerben, az utolsó játék befejezetlen.\nA 11 pontos rendszerben az eredmények 4-6, 5-5 és 1-0, míg a 21 pontos rendszerben 13-16 és 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9756796961460883",
      "hy": "0.9659408485639477",
      "bn": "0.9772963488173313",
      "bg": "0.9661279583828826",
      "zh": "0.9432993686905429",
      "fr": "0.9745473043438084",
      "de": "0.9706036967587417",
      "ha": "0.9704843198997397",
      "hi": "0.9777569726709512",
      "hu": "0.9579265099499521"
    }
  },
  {
    "task_id": "Python/34",
    "prompt": {
      "en": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n    - For n=0, the function should return 1, since C(0) = 1.\n      catalan_number(0) -> 1\n\n    - For n=3, the function should return 5, since C(3) = 5.\n      catalan_number(3) -> 5\n\n    - For n=5, the function should return 42, since C(5) = 42.\n      catalan_number(5) -> 42\n\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    \"\"\"",
      "sq": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Llogarit numrin e n-të të Catalan-it.\n\n    Funksioni llogarit numrin e n-të të Catalan-it duke përdorur programimin dinamik. Numrat e Catalan-it janë një sekuencë \n    numrash natyrorë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e llojeve të caktuara të \n    shtigjeve të rrjetit, numrin e shprehjeve që përmbajnë n çifte kllapash të cilat janë të përputhura saktësisht, numrin e \n    mënyrave të ndryshme që n+1 faktorë mund të jenë plotësisht të kllapëzuar, dhe më shumë.\n\n    Argumentet:\n    - n (int): Pozicioni në sekuencën e numrave të Catalan-it për të llogaritur (duhet të jetë jo-negativ).\n\n    Kthen:\n    - int: Numri i n-të i Catalan-it.\n\n    Raste:\n    - Për n=0, funksioni duhet të kthejë 1, pasi C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Për n=3, funksioni duhet të kthejë 5, pasi C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Për n=5, funksioni duhet të kthejë 42, pasi C(5) = 42.\n      catalan_number(5) -> 42\n\n    Shënim:\n    Llogaritja bazohet në formulën rekursive:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ku C(0) është 1.\n    \"\"\"",
      "hy": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Հաշվել n-րդ Կատալանի թիվը։\n\n    Ֆունկցիան հաշվում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական թվերի հաջորդականություն են, \n    որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորական մաթեմատիկայում, ներառյալ որոշակի տեսակի ցանցային ուղիների հաշվարկը, \n    n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ են համընկնում, n+1 գործոնների ամբողջական փակագծման \n    տարբեր եղանակների քանակը և ավելին։\n\n    Պարամետրեր:\n    - n (int): Կատալանի թվերի հաջորդականության այն դիրքը, որը պետք է հաշվել (պետք է լինի ոչ բացասական)։\n\n    Վերադարձնում է:\n    - int: n-րդ Կատալանի թիվը։\n\n    Դեպքեր:\n    - n=0-ի համար ֆունկցիան պետք է վերադարձնի 1, քանի որ C(0) = 1:\n      catalan_number(0) -> 1\n\n    - n=3-ի համար ֆունկցիան պետք է վերադարձնի 5, քանի որ C(3) = 5:\n      catalan_number(3) -> 5\n\n    - n=5-ի համար ֆունկցիան պետք է վերադարձնի 42, քանի որ C(5) = 42:\n      catalan_number(5) -> 42\n\n    Նշում:\n    Հաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    որտեղ C(0) հավասար է 1:\n    \"\"\"",
      "bn": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nth ক্যাটালান সংখ্যা গণনা করুন।\n\n    ফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে nth ক্যাটালান সংখ্যা গণনা করে। ক্যাটালান সংখ্যা হল প্রাকৃতিক সংখ্যার একটি ক্রম \n    যাদের সমাবেশিক গণিতে অনেক প্রয়োগ রয়েছে, যার মধ্যে নির্দিষ্ট ধরনের ল্যাটিস পথের গণনা, n জোড়া বন্ধনী ধারণকারী \n    অভিব্যক্তিগুলি যা সঠিকভাবে মেলানো হয়েছে, n+1 ফ্যাক্টরগুলি সম্পূর্ণভাবে বন্ধনীযুক্ত করার বিভিন্ন উপায়ের সংখ্যা, এবং আরও অনেক কিছু।\n\n    আর্গুমেন্ট:\n    - n (int): ক্যাটালান সংখ্যা ক্রমের অবস্থান যা গণনা করতে হবে (অবশ্যই অ-ঋণাত্মক হতে হবে)।\n\n    রিটার্নস:\n    - int: nth ক্যাটালান সংখ্যা।\n\n    কেস:\n    - n=0 এর জন্য, ফাংশনটি 1 রিটার্ন করা উচিত, যেহেতু C(0) = 1।\n      catalan_number(0) -> 1\n\n    - n=3 এর জন্য, ফাংশনটি 5 রিটার্ন করা উচিত, যেহেতু C(3) = 5।\n      catalan_number(3) -> 5\n\n    - n=5 এর জন্য, ফাংশনটি 42 রিটার্ন করা উচিত, যেহেতু C(5) = 42।\n      catalan_number(5) -> 42\n\n    নোট:\n    গণনাটি পুনরাবৃত্ত সূত্রের উপর ভিত্তি করে:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    যেখানে C(0) হল 1।\n    \"\"\"",
      "bg": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Изчисляване на n-тото число на Каталан.\n\n    Функцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са поредица от \n    естествени числа, които имат много приложения в комбинаторната математика, включително броене на определени видове \n    решетъчни пътища, броя на изразите, съдържащи n двойки скоби, които са правилно съчетани, броя на различните начини, \n    по които n+1 фактора могат да бъдат напълно скобирани, и други.\n\n    Аргументи:\n    - n (int): Позицията в последователността на числата на Каталан, която да се изчисли (трябва да е неотрицателно).\n\n    Връща:\n    - int: n-тото число на Каталан.\n\n    Примери:\n    - За n=0, функцията трябва да върне 1, тъй като C(0) = 1.\n      catalan_number(0) -> 1\n\n    - За n=3, функцията трябва да върне 5, тъй като C(3) = 5.\n      catalan_number(3) -> 5\n\n    - За n=5, функцията трябва да върне 42, тъй като C(5) = 42.\n      catalan_number(5) -> 42\n\n    Забележка:\n    Изчислението се основава на рекурсивната формула:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    където C(0) е 1.\n    \"\"\"",
      "zh": "def catalan_number(n: int) -> int:\n    \"\"\"\n    计算第 n 个 Catalan 数。\n\n    该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一系列自然数，在组合数学中有许多应用，包括计算某些类型的格路径、\n    包含 n 对括号的正确匹配表达式的数量、n+1 个因子可以完全括起来的不同方式的数量等。\n\n    参数:\n    - n (int): 要计算的 Catalan 数序列中的位置（必须是非负数）。\n\n    返回:\n    - int: 第 n 个 Catalan 数。\n\n    情况:\n    - 对于 n=0，函数应返回 1，因为 C(0) = 1。\n      catalan_number(0) -> 1\n\n    - 对于 n=3，函数应返回 5，因为 C(3) = 5。\n      catalan_number(3) -> 5\n\n    - 对于 n=5，函数应返回 42，因为 C(5) = 42。\n      catalan_number(5) -> 42\n\n    注意:\n    计算基于递归公式:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    其中 C(0) 是 1。\n    \"\"\"",
      "fr": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculer le nième nombre de Catalan.\n\n    La fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une \n    séquence de nombres naturels qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de \n    certains types de chemins de grille, le nombre d'expressions contenant n paires de parenthèses correctement appariées, \n    le nombre de façons différentes dont n+1 facteurs peuvent être complètement parenthésés, et plus encore.\n\n    Args:\n    - n (int): La position dans la séquence des nombres de Catalan à calculer (doit être non négative).\n\n    Returns:\n    - int: Le nième nombre de Catalan.\n\n    Cas:\n    - Pour n=0, la fonction doit retourner 1, puisque C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Pour n=3, la fonction doit retourner 5, puisque C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Pour n=5, la fonction doit retourner 42, puisque C(5) = 42.\n      catalan_number(5) -> 42\n\n    Remarque:\n    Le calcul est basé sur la formule récursive :\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    où C(0) est 1.\n    \"\"\"",
      "de": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Berechne die n-te Catalan-Zahl.\n\n    Die Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine \n    Folge natürlicher Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung \n    bestimmter Arten von Gitterpfaden, der Anzahl der Ausdrücke, die n korrekt gepaarte Klammern enthalten, der Anzahl der \n    verschiedenen Möglichkeiten, n+1 Faktoren vollständig zu klammern, und mehr.\n\n    Argumente:\n    - n (int): Die Position in der Catalan-Zahlenfolge, die berechnet werden soll (muss nicht-negativ sein).\n\n    Rückgabewert:\n    - int: Die n-te Catalan-Zahl.\n\n    Fälle:\n    - Für n=0 sollte die Funktion 1 zurückgeben, da C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Für n=3 sollte die Funktion 5 zurückgeben, da C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Für n=5 sollte die Funktion 42 zurückgeben, da C(5) = 42.\n      catalan_number(5) -> 42\n\n    Hinweis:\n    Die Berechnung basiert auf der rekursiven Formel:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    wobei C(0) gleich 1 ist.\n    \"\"\"",
      "ha": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Lissafa lambar Catalan ta n.\n\n    Aikin yana lissafin lambar Catalan ta n ta amfani da shirye-shiryen motsi. Lambobin Catalan suna jerin lambobin halitta \n    waɗanda ke da aikace-aikace da yawa a cikin lissafin haɗaka, ciki har da ƙididdigar wasu nau'ikan hanyoyin lattice, \n    adadin maganganun da ke ɗauke da nau'i-nau'i na ma'aurata waɗanda aka dace daidai, adadin hanyoyi daban-daban n+1 \n    abubuwa za a iya rarrabe su gaba ɗaya cikin ma'aurata, da ƙari.\n\n    Args:\n    - n (int): Matsayin a cikin jerin lambobin Catalan da za a lissafa (dole ne ya zama mara kyau).\n\n    Returns:\n    - int: Lambar Catalan ta n.\n\n    Cases:\n    - Ga n=0, aikin ya kamata ya dawo da 1, tun da C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Ga n=3, aikin ya kamata ya dawo da 5, tun da C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Ga n=5, aikin ya kamata ya dawo da 42, tun da C(5) = 42.\n      catalan_number(5) -> 42\n\n    Note:\n    Lissafin yana dogara ne akan tsarin maimaitawa:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    inda C(0) shine 1.\n    \"\"\"",
      "hi": "def catalan_number(n: int) -> int:\n    \"\"\"\n    nth कैटलन संख्या की गणना करें।\n\n    यह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth कैटलन संख्या की गणना करता है। कैटलन संख्याएँ प्राकृतिक संख्याओं की एक अनुक्रम हैं \n    जिनका संयोजकीय गणित में कई अनुप्रयोग हैं, जिनमें कुछ प्रकार के जाली पथों की गणना, n जोड़ों वाले कोष्ठकों की संख्या जो सही ढंग से मेल खाते हैं, \n    n+1 कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और अधिक शामिल हैं।\n\n    तर्क:\n    - n (int): कैटलन संख्या अनुक्रम में गणना करने के लिए स्थिति (गैर-ऋणात्मक होनी चाहिए)।\n\n    लौटाता है:\n    - int: nth कैटलन संख्या।\n\n    मामले:\n    - n=0 के लिए, फ़ंक्शन को 1 लौटाना चाहिए, क्योंकि C(0) = 1।\n      catalan_number(0) -> 1\n\n    - n=3 के लिए, फ़ंक्शन को 5 लौटाना चाहिए, क्योंकि C(3) = 5।\n      catalan_number(3) -> 5\n\n    - n=5 के लिए, फ़ंक्शन को 42 लौटाना चाहिए, क्योंकि C(5) = 42।\n      catalan_number(5) -> 42\n\n    नोट:\n    गणना पुनरावर्ती सूत्र पर आधारित है:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    जहाँ C(0) 1 है।\n    \"\"\"",
      "hu": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Kiszámítja az n-edik Catalan-számot.\n\n    A függvény dinamikus programozás segítségével számítja ki az n-edik Catalan-számot. A Catalan-számok olyan természetes \n    számok sorozata, amelyeknek számos alkalmazása van a kombinatorikus matematikában, beleértve bizonyos típusú rácsos utak \n    számolását, az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen vannak párosítva, az n+1 tényező különböző \n    módon történő teljes zárójelezésének számát, és még sok más.\n\n    Argumentumok:\n    - n (int): A Catalan-szám sorozatban lévő pozíció, amelyet ki kell számítani (nem lehet negatív).\n\n    Visszatérési érték:\n    - int: Az n-edik Catalan-szám.\n\n    Esetek:\n    - Ha n=0, a függvénynek 1-et kell visszaadnia, mivel C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Ha n=3, a függvénynek 5-öt kell visszaadnia, mivel C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Ha n=5, a függvénynek 42-t kell visszaadnia, mivel C(5) = 42.\n      catalan_number(5) -> 42\n\n    Megjegyzés:\n    A számítás a rekurzív képleten alapul:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ahol C(0) értéke 1.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9859810649673196",
      "hy": "0.9506476996369285",
      "bn": "0.9703957307497982",
      "bg": "0.971983184755029",
      "zh": "0.9659920952022547",
      "fr": "0.9689381810137642",
      "de": "0.9644106001084549",
      "ha": "0.9625814129295046",
      "hi": "0.9629407352887968",
      "hu": "0.9669991512341016"
    },
    "canonical_solution": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]",
    "instruction": {
      "en": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হতে হবে।",
      "bg": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nBada takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa ba tare da wucewa haruffa 500 ba.",
      "hi": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nइस Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.8827651710271124",
      "bg": "0.8983697723915943",
      "zh": "0.8886474111310796",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9103011021195979",
      "hi": "0.8955174401199333",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_catalan_number():\n    # Test case 1: The first Catalan number (base case)\n    n1 = 0\n    expected_output1 = 1\n    assert catalan_number(n1) == expected_output1, f\"Test case 1 failed: expected {expected_output1}, got {catalan_number(n1)}\"\n\n    # Test case 2: The third Catalan number\n    n2 = 3\n    expected_output2 = 5\n    assert catalan_number(n2) == expected_output2, f\"Test case 2 failed: expected {expected_output2}, got {catalan_number(n2)}\"\n\n    # Test case 3: The fifth Catalan number\n    n3 = 5\n    expected_output3 = 42\n    assert catalan_number(n3) == expected_output3, f\"Test case 3 failed: expected {expected_output3}, got {catalan_number(n3)}\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_catalan_number()",
    "entry_point": "catalan_number",
    "signature": "def catalan_number(n: int) -> int:",
    "docstring": {
      "en": "Calculate the nth Catalan number.\n\nThe function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural\nnumbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths,\nthe number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1\nfactors can be completely parenthesized, and more.\n\nArgs:\n- n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\nReturns:\n- int: The nth Catalan number.\n\nCases:\n- For n=0, the function should return 1, since C(0) = 1.\ncatalan_number(0) -> 1\n\n- For n=3, the function should return 5, since C(3) = 5.\ncatalan_number(3) -> 5\n\n- For n=5, the function should return 42, since C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nThe computation is based on the recursive formula:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwhere C(0) is 1.",
      "sq": "Llogarit numrin e n-të të Catalan-it.\n\nFunksioni llogarit numrin e n-të të Catalan-it duke përdorur programimin dinamik. Numrat e Catalan-it janë një sekuencë e numrave natyrorë që kanë shumë aplikime në matematikën kombinatorike, duke përfshirë numërimin e llojeve të caktuara të shtigjeve të rrjetit, numrin e shprehjeve që përmbajnë n çifte kllapash të cilat janë të përputhura saktësisht, numrin e mënyrave të ndryshme që n+1 faktorë mund të përfshihen plotësisht në kllapa, dhe më shumë.\n\nArgumentet:\n- n (int): Pozicioni në sekuencën e numrave të Catalan-it për të llogaritur (duhet të jetë jo-negativ).\n\nKthen:\n- int: Numri i n-të i Catalan-it.\n\nRastet:\n- Për n=0, funksioni duhet të kthejë 1, pasi C(0) = 1.\ncatalan_number(0) -> 1\n\n- Për n=3, funksioni duhet të kthejë 5, pasi C(3) = 5.\ncatalan_number(3) -> 5\n\n- Për n=5, funksioni duhet të kthejë 42, pasi C(5) = 42.\ncatalan_number(5) -> 42\n\nShënim:\nLlogaritja bazohet në formulën rekursive:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nku C(0) është 1.",
      "hy": "Հաշվել n-րդ Կատալանի թիվը։\n\nՖունկցիան հաշվում է n-րդ Կատալանի թիվը դինամիկ ծրագրավորման միջոցով։ Կատալանի թվերը բնական թվերի հաջորդականություն են, որոնք ունեն բազմաթիվ կիրառություններ կոմբինատորիկ մաթեմատիկայում, ներառյալ որոշ տեսակների ցանցային ուղիների հաշվարկը, n զույգ փակագծեր պարունակող արտահայտությունների քանակը, որոնք ճիշտ են զուգակցված, n+1 գործոնների ամբողջական փակագծման տարբեր եղանակների քանակը և ավելին։\n\nԱրձագանքներ:\n- n (int): Կատալանի թվերի հաջորդականության դիրքը, որը պետք է հաշվարկել (պետք է լինի ոչ բացասական)։\n\nՎերադարձնում է:\n- int: n-րդ Կատալանի թիվը։\n\nԴեպքեր:\n- Երբ n=0, ֆունկցիան պետք է վերադարձնի 1, քանի որ C(0) = 1։\ncatalan_number(0) -> 1\n\n- Երբ n=3, ֆունկցիան պետք է վերադարձնի 5, քանի որ C(3) = 5։\ncatalan_number(3) -> 5\n\n- Երբ n=5, ֆունկցիան պետք է վերադարձնի 42, քանի որ C(5) = 42։\ncatalan_number(5) -> 42\n\nՆշում:\nՀաշվարկը հիմնված է ռեկուրսիվ բանաձևի վրա:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nորտեղ C(0) հավասար է 1։",
      "bn": "nth Catalan সংখ্যা গণনা করুন।\n\nফাংশনটি গতিশীল প্রোগ্রামিং ব্যবহার করে nth Catalan সংখ্যা গণনা করে। Catalan সংখ্যা একটি প্রাকৃতিক সংখ্যার ক্রম যা সমাবেশিক গণিতে অনেক প্রয়োগ রয়েছে, যার মধ্যে রয়েছে নির্দিষ্ট ধরনের ল্যাটিস পথ গণনা, n জোড়া বন্ধনী ধারণকারী অভিব্যক্তির সংখ্যা যা সঠিকভাবে মিলেছে, n+1 ফ্যাক্টর সম্পূর্ণভাবে বন্ধনীযুক্ত করার বিভিন্ন উপায়ের সংখ্যা, এবং আরও অনেক কিছু।\n\nArgs:\n- n (int): Catalan সংখ্যা ক্রমে গণনা করার অবস্থান (অবশ্যই অ-ঋণাত্মক হতে হবে)।\n\nReturns:\n- int: nth Catalan সংখ্যা।\n\nCases:\n- n=0 এর জন্য, ফাংশনটি 1 ফেরত দেবে, যেহেতু C(0) = 1।\ncatalan_number(0) -> 1\n\n- n=3 এর জন্য, ফাংশনটি 5 ফেরত দেবে, যেহেতু C(3) = 5।\ncatalan_number(3) -> 5\n\n- n=5 এর জন্য, ফাংশনটি 42 ফেরত দেবে, যেহেতু C(5) = 42।\ncatalan_number(5) -> 42\n\nNote:\nগণনাটি পুনরাবৃত্ত সূত্রের উপর ভিত্তি করে:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nযেখানে C(0) হল 1।",
      "bg": "Изчисляване на n-тото число на Каталан.\n\nФункцията изчислява n-тото число на Каталан, използвайки динамично програмиране. Числата на Каталан са последователност от естествени числа, които имат много приложения в комбинаторната математика, включително броенето на определени видове решетъчни пътища, броя на изразите, съдържащи n двойки скоби, които са правилно съчетани, броя на различните начини n+1 фактори да бъдат напълно скобирани и други.\n\nАргументи:\n- n (int): Позицията в последователността на числата на Каталан, която да бъде изчислена (трябва да бъде неотрицателно).\n\nВръща:\n- int: n-тото число на Каталан.\n\nСлучаи:\n- За n=0, функцията трябва да върне 1, тъй като C(0) = 1.\ncatalan_number(0) -> 1\n\n- За n=3, функцията трябва да върне 5, тъй като C(3) = 5.\ncatalan_number(3) -> 5\n\n- За n=5, функцията трябва да върне 42, тъй като C(5) = 42.\ncatalan_number(5) -> 42\n\nЗабележка:\nИзчислението се основава на рекурсивната формула:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nкъдето C(0) е 1.",
      "zh": "计算第 n 个 Catalan 数。\n\n该函数使用动态规划计算第 n 个 Catalan 数。Catalan 数是一系列自然数，在组合数学中有许多应用，包括计数某些类型的格路径、包含 n 对正确匹配括号的表达式数量、n+1 个因子完全括号化的不同方式数量等。\n\n参数：\n- n (int): 要计算的 Catalan 数序列中的位置（必须是非负的）。\n\n返回：\n- int: 第 n 个 Catalan 数。\n\n案例：\n- 对于 n=0，函数应返回 1，因为 C(0) = 1。\ncatalan_number(0) -> 1\n\n- 对于 n=3，函数应返回 5，因为 C(3) = 5。\ncatalan_number(3) -> 5\n\n- 对于 n=5，函数应返回 42，因为 C(5) = 42。\ncatalan_number(5) -> 42\n\n注意：\n计算基于递归公式：\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n其中 C(0) 为 1。",
      "fr": "Calculer le nième nombre de Catalan.\n\nLa fonction calcule le nième nombre de Catalan en utilisant la programmation dynamique. Les nombres de Catalan sont une séquence de nombres naturels qui ont de nombreuses applications en mathématiques combinatoires, y compris le comptage de certains types de chemins de grille, le nombre d'expressions contenant n paires de parenthèses correctement appariées, le nombre de façons différentes dont n+1 facteurs peuvent être complètement parenthésés, et plus encore.\n\nArgs:\n- n (int): La position dans la séquence des nombres de Catalan à calculer (doit être non négative).\n\nReturns:\n- int: Le nième nombre de Catalan.\n\nCas:\n- Pour n=0, la fonction doit retourner 1, puisque C(0) = 1.\ncatalan_number(0) -> 1\n\n- Pour n=3, la fonction doit retourner 5, puisque C(3) = 5.\ncatalan_number(3) -> 5\n\n- Pour n=5, la fonction doit retourner 42, puisque C(5) = 42.\ncatalan_number(5) -> 42\n\nRemarque:\nLe calcul est basé sur la formule récursive :\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\noù C(0) est 1.",
      "de": "Berechne die n-te Catalan-Zahl.\n\nDie Funktion berechnet die n-te Catalan-Zahl unter Verwendung der dynamischen Programmierung. Catalan-Zahlen sind eine Folge von natürlichen Zahlen, die viele Anwendungen in der kombinatorischen Mathematik haben, einschließlich der Zählung bestimmter Arten von Gitterpfaden, der Anzahl von Ausdrücken, die n korrekt gepaarte Klammern enthalten, der Anzahl der verschiedenen Möglichkeiten, n+1 Faktoren vollständig zu klammern, und mehr.\n\nArgs:\n- n (int): Die Position in der Catalan-Zahlenfolge, die berechnet werden soll (muss nicht-negativ sein).\n\nReturns:\n- int: Die n-te Catalan-Zahl.\n\nFälle:\n- Für n=0 sollte die Funktion 1 zurückgeben, da C(0) = 1.\ncatalan_number(0) -> 1\n\n- Für n=3 sollte die Funktion 5 zurückgeben, da C(3) = 5.\ncatalan_number(3) -> 5\n\n- Für n=5 sollte die Funktion 42 zurückgeben, da C(5) = 42.\ncatalan_number(5) -> 42\n\nHinweis:\nDie Berechnung basiert auf der rekursiven Formel:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwobei C(0) 1 ist.",
      "ha": "Lissafa lambar Catalan ta n.\n\nAikin yana lissafin lambar Catalan ta nth ta amfani da shirye-shiryen motsi. Lambobin Catalan suna jerin lambobin halitta\nwadanda suke da aikace-aikace da yawa a cikin lissafin haɗin gwiwa, ciki har da ƙididdigar wasu nau'ikan hanyoyin lattice,\nyawan maganganun da ke ɗauke da nau'i-nau'i n na maƙalafan da aka haɗa daidai, yawan hanyoyin daban-daban n+1\nabubuwan da za a iya rarrabewa gaba ɗaya, da ƙari.\n\nArgs:\n- n (int): Matsayi a cikin jerin lambobin Catalan da za a lissafa (dole ne ya zama maras kyau).\n\nReturns:\n- int: Lambar Catalan ta nth.\n\nCases:\n- Ga n=0, aikin ya kamata ya dawo da 1, tun da C(0) = 1.\ncatalan_number(0) -> 1\n\n- Ga n=3, aikin ya kamata ya dawo da 5, tun da C(3) = 5.\ncatalan_number(3) -> 5\n\n- Ga n=5, aikin ya kamata ya dawo da 42, tun da C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nLissafin yana dogara ne akan tsarin maimaitawa:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\ninda C(0) yake 1.",
      "hi": "nth कैटलन संख्या की गणना करें।\n\nयह फ़ंक्शन गतिशील प्रोग्रामिंग का उपयोग करके nth कैटलन संख्या की गणना करता है। कैटलन संख्याएँ प्राकृतिक संख्याओं की एक श्रृंखला हैं जिनका संयोजकीय गणित में कई अनुप्रयोग हैं, जिसमें कुछ प्रकार के जाली पथों की गिनती, n जोड़े कोष्ठकों वाले अभिव्यक्तियों की संख्या जो सही ढंग से मेल खाते हैं, n+1 कारकों को पूरी तरह से कोष्ठक में रखने के विभिन्न तरीकों की संख्या, और अधिक शामिल हैं।\n\nआर्ग्स:\n- n (int): कैटलन संख्या अनुक्रम में स्थिति जिसकी गणना करनी है (गैर-ऋणात्मक होना चाहिए)।\n\nरिटर्न्स:\n- int: nth कैटलन संख्या।\n\nमामले:\n- n=0 के लिए, फ़ंक्शन को 1 लौटाना चाहिए, क्योंकि C(0) = 1।\ncatalan_number(0) -> 1\n\n- n=3 के लिए, फ़ंक्शन को 5 लौटाना चाहिए, क्योंकि C(3) = 5।\ncatalan_number(3) -> 5\n\n- n=5 के लिए, फ़ंक्शन को 42 लौटाना चाहिए, क्योंकि C(5) = 42।\ncatalan_number(5) -> 42\n\nनोट:\nगणना पुनरावर्ती सूत्र पर आधारित है:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nजहाँ C(0) 1 है।",
      "hu": "Számítsa ki az n-edik Catalan számot.\n\nA függvény dinamikus programozás segítségével számítja ki az n-edik Catalan számot. A Catalan számok egy sorozata a természetes számoknak, amelyek számos alkalmazással bírnak a kombinatorikus matematikában, beleértve bizonyos típusú rácsos utak számolását, az n pár zárójelet tartalmazó kifejezések számát, amelyek helyesen vannak párosítva, az n+1 tényező különböző módokon történő teljes zárójelezésének számát, és még sok mást.\n\nArgs:\n- n (int): A Catalan szám sorozatban a kiszámítandó pozíció (nem lehet negatív).\n\nReturns:\n- int: Az n-edik Catalan szám.\n\nEsetek:\n- Ha n=0, a függvénynek 1-et kell visszaadnia, mivel C(0) = 1.\ncatalan_number(0) -> 1\n\n- Ha n=3, a függvénynek 5-öt kell visszaadnia, mivel C(3) = 5.\ncatalan_number(3) -> 5\n\n- Ha n=5, a függvénynek 42-t kell visszaadnia, mivel C(5) = 42.\ncatalan_number(5) -> 42\n\nMegjegyzés:\nA számítás az alábbi rekurzív képleten alapul:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nahol C(0) értéke 1."
    },
    "docstring_bertscore": {
      "sq": "0.985106296769242",
      "hy": "0.9592718335207013",
      "bn": "0.9656631632912609",
      "bg": "0.9698459218550937",
      "zh": "0.9613580484127108",
      "fr": "0.9759696965023992",
      "de": "0.9655823207261798",
      "ha": "0.9581835376630112",
      "hi": "0.9664042532429021",
      "hu": "0.9624429675539233"
    }
  },
  {
    "task_id": "Python/35",
    "prompt": {
      "en": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n    1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"",
      "sq": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\n    Args:\n    apple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\n    tao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\n    Returns:\n    int: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\n    Kjo funksion iteron mbi listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao,\n    duke konsideruar një shtesë prej 30cm që stoli ofron.\n\n    Shembuj rastesh:\n    1. Tao Tao mund të arrijë mollët në 120cm pa stol, dhe të gjitha mollët janë në 150cm ose më poshtë.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao mund të arrijë mollët në 100cm pa stol, dhe të gjitha mollët janë mbi 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao mund të arrijë mollët në 110cm pa stol, dhe disa mollë janë në lartësi të ndryshme.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"",
      "hy": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Հաշվարկել խնձորների քանակը, որոնք Տաո Տաոն կարող է հասնել։\n\n    Արգումենտներ:\n    apple_heights (List[int]): Խնձորների բարձրությունները գետնից (սանտիմետրերով)։\n    tao_reach (int): Առավելագույն բարձրությունը, որին Տաո Տաոն կարող է հասնել ձեռքը վեր պարզած (սանտիմետրերով)։\n\n    Վերադարձնում է:\n    int: Խնձորների քանակը, որոնք Տաո Տաոն կարող է հասնել 30սմ աթոռի վրա կանգնած կամ առանց դրա։\n\n    Այս ֆունկցիան անցնում է խնձորների բարձրությունների ցանկով և հաշվում, թե դրանցից քանիսն են Տաո Տաոյի հասանելիության սահմաններում,\n    հաշվի առնելով աթոռի կողմից տրվող լրացուցիչ 30սմ-ը։\n\n    Օրինակային դեպքեր:\n    1. Տաո Տաոն կարող է հասնել 120սմ բարձրության խնձորներին առանց աթոռի, և բոլոր խնձորները 150սմ կամ ավելի ցածր են։\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n\n    2. Տաո Տաոն կարող է հասնել 100սմ բարձրության խնձորներին առանց աթոռի, և բոլոր խնձորները 130սմ-ից բարձր են։\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0\n\n    3. Տաո Տաոն կարող է հասնել 110սմ բարձրության խնձորներին առանց աթոռի, և որոշ խնձորներ տարբեր բարձրությունների վրա են։\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> վերադարձնում է 5\n    \"\"\"",
      "bn": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    কতগুলি আপেল তাও তাও পৌঁছাতে পারে তা গণনা করুন।\n\n    Args:\n    apple_heights (List[int]): মাটি থেকে আপেলের উচ্চতা (সেন্টিমিটারে)।\n    tao_reach (int): তাও তাও তার হাত প্রসারিত করে সর্বাধিক যে উচ্চতায় পৌঁছাতে পারে (সেন্টিমিটারে)।\n\n    Returns:\n    int: তাও তাও একটি 30cm স্টুলের উপর দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\n    এই ফাংশনটি আপেলের উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং কতগুলি আপেল তাও তাও এর নাগালের মধ্যে রয়েছে তা গণনা করে,\n    স্টুল যে অতিরিক্ত 30cm প্রদান করে তা বিবেচনা করে।\n\n    উদাহরণ কেস:\n    1. তাও তাও 120cm উচ্চতায় স্টুল ছাড়াই আপেল পৌঁছাতে পারে, এবং সমস্ত আপেল 150cm বা তার নিচে।\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. তাও তাও 100cm উচ্চতায় স্টুল ছাড়াই আপেল পৌঁছাতে পারে, এবং সমস্ত আপেল 130cm এর উপরে।\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. তাও তাও 110cm উচ্চতায় স্টুল ছাড়াই আপেল পৌঁছাতে পারে, এবং কিছু আপেল বিভিন্ন উচ্চতায় রয়েছে।\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"",
      "bg": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Изчислява броя на ябълките, които Тао Тао може да достигне.\n\n    Args:\n    apple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\n    tao_reach (int): Максималната височина, която Тао Тао може да достигне с протегната ръка нагоре (в сантиметри).\n\n    Returns:\n    int: Броят на ябълките, които Тао Тао може да достигне със или без да стои на столче от 30см.\n\n    Тази функция обхожда списъка с височините на ябълките и брои колко от тях са в обсега на Тао Тао,\n    като се вземат предвид допълнителните 30см, които столчето осигурява.\n\n    Примерни случаи:\n    1. Тао Тао може да достигне ябълки на 120см без столче, и всички ябълки са на 150см или по-ниско.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> връща 10\n\n    2. Тао Тао може да достигне ябълки на 100см без столче, и всички ябълки са над 130см.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> връща 0\n\n    3. Тао Тао може да достигне ябълки на 110см без столче, и някои ябълки са на различни височини.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> връща 5\n    \"\"\"",
      "zh": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    计算陶陶可以够到的苹果数量。\n\n    参数：\n    apple_heights (List[int]): 苹果距离地面的高度（以厘米为单位）。\n    tao_reach (int): 陶陶伸手向上可以达到的最大高度（以厘米为单位）。\n\n    返回：\n    int: 陶陶在站上30厘米高的凳子后可以够到的苹果数量。\n\n    此函数遍历苹果高度列表，并计算其中有多少在陶陶的够到范围内，\n    考虑到凳子提供的额外30厘米。\n\n    示例案例：\n    1. 陶陶在不使用凳子的情况下可以够到120厘米的苹果，所有苹果都在150厘米或以下。\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 返回 10\n\n    2. 陶陶在不使用凳子的情况下可以够到100厘米的苹果，所有苹果都在130厘米以上。\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 返回 0\n\n    3. 陶陶在不使用凳子的情况下可以够到110厘米的苹果，部分苹果在不同高度。\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 返回 5\n    \"\"\"",
      "fr": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculer le nombre de pommes que Tao Tao peut atteindre.\n\n    Args:\n    apple_heights (List[int]): Les hauteurs des pommes depuis le sol (en centimètres).\n    tao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\n    Returns:\n    int: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\n    Cette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\n    en considérant un supplément de 30 cm que le tabouret fournit.\n\n    Exemples de cas :\n    1. Tao Tao peut atteindre les pommes à 120 cm sans tabouret, et toutes les pommes sont à 150 cm ou moins.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao peut atteindre les pommes à 100 cm sans tabouret, et toutes les pommes sont au-dessus de 130 cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao peut atteindre les pommes à 110 cm sans tabouret, et certaines pommes sont à différentes hauteurs.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"",
      "de": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Berechne die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\n    Args:\n    apple_heights (List[int]): Die Höhen der Äpfel vom Boden aus (in Zentimetern).\n    tao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\n    Returns:\n    int: Die Anzahl der Äpfel, die Tao Tao mit oder ohne einen 30cm hohen Hocker erreichen kann.\n\n    Diese Funktion iteriert über die Liste der Apfelhöhen und zählt, wie viele davon in Tao Taos Reichweite liegen,\n    wobei zusätzliche 30cm berücksichtigt werden, die der Hocker bietet.\n\n    Beispielhafte Fälle:\n    1. Tao Tao kann Äpfel in 120cm Höhe ohne Hocker erreichen, und alle Äpfel sind bei 150cm oder darunter.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> gibt 10 zurück\n\n    2. Tao Tao kann Äpfel in 100cm Höhe ohne Hocker erreichen, und alle Äpfel sind über 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> gibt 0 zurück\n\n    3. Tao Tao kann Äpfel in 110cm Höhe ohne Hocker erreichen, und einige Äpfel sind in verschiedenen Höhen.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> gibt 5 zurück\n    \"\"\"",
      "ha": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Lissafa yawan tuffa da Tao Tao za ta iya kaiwa.\n\n    Args:\n    apple_heights (List[int]): Tsayin tuffa daga ƙasa (a cikin santimita).\n    tao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa da hannunta a miƙe sama (a cikin santimita).\n\n    Returns:\n    int: Yawan tuffa da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan kujerar 30cm ba.\n\n    Wannan aikin yana zagayawa a kan jerin tsayin tuffa kuma yana lissafa nawa daga cikinsu suke cikin isar Tao Tao,\n    la'akari da ƙarin 30cm da kujerar ke bayarwa.\n\n    Misalan lokuta:\n    1. Tao Tao za ta iya kaiwa tuffa a 120cm ba tare da kujera ba, kuma duk tuffa suna a 150cm ko ƙasa da haka.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao za ta iya kaiwa tuffa a 100cm ba tare da kujera ba, kuma duk tuffa suna sama da 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao za ta iya kaiwa tuffa a 110cm ba tare da kujera ba, kuma wasu tuffa suna a tsayin daban-daban.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"",
      "hi": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    गणना करें कि ताओ ताओ कितने सेब तक पहुँच सकती है।\n\n    Args:\n    apple_heights (List[int]): जमीन से सेबों की ऊँचाई (सेंटीमीटर में)।\n    tao_reach (int): अधिकतम ऊँचाई तक ताओ ताओ अपने हाथ को ऊपर खींचकर पहुँच सकती है (सेंटीमीटर में)।\n\n    Returns:\n    int: उन सेबों की संख्या जिन तक ताओ ताओ 30 सेमी स्टूल पर खड़े होकर या बिना खड़े हुए पहुँच सकती है।\n\n    यह फ़ंक्शन सेबों की ऊँचाई की सूची पर इटरेट करता है और गिनता है कि उनमें से कितने ताओ ताओ की पहुँच में हैं,\n    30 सेमी अतिरिक्त ऊँचाई को ध्यान में रखते हुए जो स्टूल प्रदान करता है।\n\n    उदाहरण मामले:\n    1. ताओ ताओ 120 सेमी पर बिना स्टूल के सेब तक पहुँच सकती है, और सभी सेब 150 सेमी या उससे नीचे हैं।\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. ताओ ताओ 100 सेमी पर बिना स्टूल के सेब तक पहुँच सकती है, और सभी सेब 130 सेमी से ऊपर हैं।\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. ताओ ताओ 110 सेमी पर बिना स्टूल के सेब तक पहुँच सकती है, और कुछ सेब विभिन्न ऊँचाइयों पर हैं।\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"",
      "hu": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Számolja ki, hány almát ér el Tao Tao.\n\n    Args:\n    apple_heights (List[int]): Az almák magassága a talajtól (centiméterben).\n    tao_reach (int): A maximális magasság, amit Tao Tao elérhet kinyújtott kézzel (centiméterben).\n\n    Returns:\n    int: Az elérhető almák száma Tao Tao számára, akár 30 cm-es sámlin állva is.\n\n    Ez a függvény végigmegy az almák magasságának listáján, és megszámolja, hány közülük van Tao Tao elérhetőségén belül,\n    figyelembe véve a sámi által biztosított további 30 cm-t.\n\n    Példa esetek:\n    1. Tao Tao eléri az almákat 120 cm-en sámi nélkül, és minden alma 150 cm vagy az alatt van.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszaadja 10\n\n    2. Tao Tao eléri az almákat 100 cm-en sámi nélkül, és minden alma 130 cm felett van.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszaadja 0\n\n    3. Tao Tao eléri az almákat 110 cm-en sámi nélkül, és néhány alma különböző magasságokban van.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> visszaadja 5\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9889764111133258",
      "hy": "0.9595381968616692",
      "bn": "0.9616695008501734",
      "bg": "0.9741478586475473",
      "zh": "0.9653566766133241",
      "fr": "0.9851084817034333",
      "de": "0.9734943646939425",
      "ha": "0.97603703220157",
      "hi": "0.976537382131397",
      "hu": "0.9791060702189401"
    },
    "canonical_solution": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples",
    "instruction": {
      "en": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nՏրամադրել Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\n请用不超过500个字符的中文为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548376088944786",
      "hy": "0.9069653035004981",
      "bn": "0.8657447323066139",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9215501364887467",
      "hi": "0.9332389385215069",
      "hu": "0.9216792462364195"
    },
    "level": "",
    "test": "import unittest\n\nclass TestTaoTaoApplePicking(unittest.TestCase):\n    def test_count_apples_reachable(self):\n        # Test case 1: Tao Tao can reach all apples\n        apples_1 = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]\n        tao_reach_1 = 120\n        self.assertEqual(count_apples_reachable(apples_1, tao_reach_1), 10)\n\n        # Test case 2: Tao Tao can't reach any apples\n        apples_2 = [200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n        tao_reach_2 = 100\n        self.assertEqual(count_apples_reachable(apples_2, tao_reach_2), 0)\n\n        # Test case 3: Tao Tao can reach some of the apples\n        apples_3 = [160, 150, 140, 170, 180, 190, 160, 150, 145, 155]\n        tao_reach_3 = 115\n        self.assertEqual(count_apples_reachable(apples_3, tao_reach_3), 2)\n\n# To run the tests\nif __name__ == '__main__':\n    unittest.main()",
    "entry_point": "count_apples_reachable",
    "signature": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:",
    "docstring": {
      "en": "Calculate the number of apples that Tao Tao can reach.\n\nArgs:\napple_heights (List[int]): The heights of apples from the ground (in centimeters).\ntao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\nReturns:\nint: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\nThis function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\nconsidering an additional 30cm that the stool provides.\n\nExample cases:\n1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5",
      "sq": "Llogarit numrin e mollëve që Tao Tao mund të arrijë.\n\nArgumentet:\napple_heights (List[int]): Lartësitë e mollëve nga toka (në centimetra).\ntao_reach (int): Lartësia maksimale që Tao Tao mund të arrijë me dorën e saj të shtrirë lart (në centimetra).\n\nKthen:\nint: Numri i mollëve që Tao Tao mund të arrijë me ose pa qëndruar në një stol 30cm.\n\nKjo funksion kalon nëpër listën e lartësive të mollëve dhe numëron sa prej tyre janë brenda arritjes së Tao Tao-s,\nduke marrë parasysh një shtesë prej 30cm që ofron stoli.\n\nShembuj rastesh:\n1. Tao Tao mund të arrijë mollët në 120cm pa stol, dhe të gjitha mollët janë në 150cm ose më poshtë.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> kthen 10\n\n2. Tao Tao mund të arrijë mollët në 100cm pa stol, dhe të gjitha mollët janë mbi 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> kthen 0\n\n3. Tao Tao mund të arrijë mollët në 110cm pa stol, dhe disa mollë janë në lartësi të ndryshme.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> kthen 5",
      "hy": "Հաշվարկել խնձորների քանակը, որոնք կարող է հասնել Տաո Տաոն:\n\nԱրգումենտներ:\napple_heights (List[int]): Խնձորների բարձրությունները հողից (սանտիմետրերով):\ntao_reach (int): Առավելագույն բարձրությունը, որին կարող է հասնել Տաո Տաոն՝ ձեռքը վեր պարզած (սանտիմետրերով):\n\nՎերադարձնում է:\nint: Խնձորների քանակը, որոնք Տաո Տաոն կարող է հասնել՝ 30սմ աթոռի վրա կանգնած կամ առանց դրա:\n\nԱյս ֆունկցիան անցնում է խնձորների բարձրությունների ցուցակը և հաշվում, թե դրանցից քանիսն են Տաո Տաոյի հասանելիության սահմաններում՝ հաշվի առնելով աթոռի ավելացրած 30սմ-ը:\n\nՕրինակներ:\n1. Տաո Տաոն կարող է հասնել 120սմ բարձրության խնձորներին առանց աթոռի, և բոլոր խնձորները 150սմ կամ ավելի ցածր են:\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> վերադարձնում է 10\n\n2. Տաո Տաոն կարող է հասնել 100սմ բարձրության խնձորներին առանց աթոռի, և բոլոր խնձորները 130սմ-ից բարձր են:\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> վերադարձնում է 0\n\n3. Տաո Տաոն կարող է հասնել 110սմ բարձրության խնձորներին առանց աթոռի, և որոշ խնձորներ տարբեր բարձրությունների վրա են:\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> վերադարձնում է 5",
      "bn": "Tao Tao কতগুলি আপেল পৌঁছাতে পারে তা গণনা করুন।\n\nArgs:\napple_heights (List[int]): মাটি থেকে আপেলের উচ্চতা (সেন্টিমিটারে)।\ntao_reach (int): Tao Tao তার হাত প্রসারিত করে সর্বাধিক যে উচ্চতায় পৌঁছাতে পারে (সেন্টিমিটারে)।\n\nReturns:\nint: Tao Tao একটি 30cm স্টুলের উপর দাঁড়িয়ে বা না দাঁড়িয়ে কতগুলি আপেল পৌঁছাতে পারে।\n\nএই ফাংশনটি আপেলের উচ্চতার তালিকার উপর পুনরাবৃত্তি করে এবং কতগুলি আপেল Tao Tao-এর নাগালের মধ্যে রয়েছে তা গণনা করে,\nস্টুলটি যে অতিরিক্ত 30cm প্রদান করে তা বিবেচনা করে।\n\nউদাহরণ কেস:\n1. Tao Tao একটি স্টুল ছাড়াই 120cm উচ্চতায় আপেল পৌঁছাতে পারে, এবং সমস্ত আপেল 150cm বা তার নিচে।\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao একটি স্টুল ছাড়াই 100cm উচ্চতায় আপেল পৌঁছাতে পারে, এবং সমস্ত আপেল 130cm এর উপরে।\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao একটি স্টুল ছাড়াই 110cm উচ্চতায় আপেল পৌঁছাতে পারে, এবং কিছু আপেল বিভিন্ন উচ্চতায় রয়েছে।\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5",
      "bg": "Изчислете броя на ябълките, до които Тао Тао може да достигне.\n\nАргументи:\napple_heights (List[int]): Височините на ябълките от земята (в сантиметри).\ntao_reach (int): Максималната височина, до която Тао Тао може да достигне с ръка, изпъната нагоре (в сантиметри).\n\nВръща:\nint: Броят на ябълките, до които Тао Тао може да достигне със или без да стои на 30см столче.\n\nТази функция обхожда списъка с височините на ябълките и брои колко от тях са в обсега на Тао Тао,\nкато се вземат предвид допълнителните 30см, които столчето осигурява.\n\nПримерни случаи:\n1. Тао Тао може да достигне ябълки на 120см без столче, и всички ябълки са на 150см или по-ниско.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> връща 10\n\n2. Тао Тао може да достигне ябълки на 100см без столче, и всички ябълки са над 130см.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> връща 0\n\n3. Тао Тао може да достигне ябълки на 110см без столче, и някои ябълки са на различни височини.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> връща 5",
      "zh": "计算陶陶可以够到的苹果数量。\n\n参数：\napple_heights (List[int]): 苹果距离地面的高度（以厘米为单位）。\ntao_reach (int): 陶陶伸手向上可以达到的最大高度（以厘米为单位）。\n\n返回：\nint: 陶陶在站上30厘米高的凳子时可以够到的苹果数量。\n\n此函数遍历苹果高度列表，并计算其中有多少在陶陶的可及范围内，\n考虑到凳子提供的额外30厘米高度。\n\n示例案例：\n1. 陶陶在不使用凳子的情况下可以够到120厘米高的苹果，并且所有苹果都在150厘米或以下。\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 返回 10\n\n2. 陶陶在不使用凳子的情况下可以够到100厘米高的苹果，并且所有苹果都在130厘米以上。\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 返回 0\n\n3. 陶陶在不使用凳子的情况下可以够到110厘米高的苹果，并且一些苹果处于不同的高度。\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 返回 5",
      "fr": "Calculer le nombre de pommes que Tao Tao peut atteindre.\n\nArgs:\napple_heights (List[int]): Les hauteurs des pommes par rapport au sol (en centimètres).\ntao_reach (int): La hauteur maximale que Tao Tao peut atteindre avec sa main tendue vers le haut (en centimètres).\n\nReturns:\nint: Le nombre de pommes que Tao Tao peut atteindre avec ou sans se tenir sur un tabouret de 30 cm.\n\nCette fonction parcourt la liste des hauteurs des pommes et compte combien d'entre elles sont à la portée de Tao Tao,\nen considérant un supplément de 30 cm que le tabouret fournit.\n\nExemples de cas :\n1. Tao Tao peut atteindre les pommes à 120 cm sans tabouret, et toutes les pommes sont à 150 cm ou moins.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao peut atteindre les pommes à 100 cm sans tabouret, et toutes les pommes sont au-dessus de 130 cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao peut atteindre les pommes à 110 cm sans tabouret, et certaines pommes sont à différentes hauteurs.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5",
      "de": "Berechne die Anzahl der Äpfel, die Tao Tao erreichen kann.\n\nArgs:\napple_heights (List[int]): Die Höhen der Äpfel vom Boden (in Zentimetern).\ntao_reach (int): Die maximale Höhe, die Tao Tao mit ausgestreckter Hand erreichen kann (in Zentimetern).\n\nReturns:\nint: Die Anzahl der Äpfel, die Tao Tao mit oder ohne einen 30cm hohen Hocker erreichen kann.\n\nDiese Funktion iteriert über die Liste der Apfelhöhen und zählt, wie viele davon innerhalb von Tao Taos Reichweite liegen,\nunter Berücksichtigung zusätzlicher 30cm, die der Hocker bietet.\n\nBeispiel Fälle:\n1. Tao Tao kann Äpfel in 120cm Höhe ohne Hocker erreichen, und alle Äpfel sind bei 150cm oder darunter.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> gibt 10 zurück\n\n2. Tao Tao kann Äpfel in 100cm Höhe ohne Hocker erreichen, und alle Äpfel sind über 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> gibt 0 zurück\n\n3. Tao Tao kann Äpfel in 110cm Höhe ohne Hocker erreichen, und einige Äpfel sind in verschiedenen Höhen.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> gibt 5 zurück",
      "ha": "Lissafa yawan tuffa da Tao Tao za ta iya kaiwa.\n\nArgs:\napple_heights (List[int]): Tsayin apples daga ƙasa (a cikin santimita).\ntao_reach (int): Matsakaicin tsayin da Tao Tao za ta iya kaiwa da hannunta a miƙe sama (a cikin santimita).\n\nReturns:\nint: Yawan apples da Tao Tao za ta iya kaiwa tare da ko ba tare da tsayawa a kan stool mai tsayin 30cm ba.\n\nWannan aikin yana zagayawa akan jerin tsayin apples kuma yana ƙirga nawa daga cikinsu suke cikin isar Tao Tao,\nla'akari da ƙarin 30cm da stool ke bayarwa.\n\nExample cases:\n1. Tao Tao za ta iya kaiwa apples a 120cm ba tare da stool ba, kuma duk apples suna a 150cm ko ƙasa da haka.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao za ta iya kaiwa apples a 100cm ba tare da stool ba, kuma duk apples suna sama da 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao za ta iya kaiwa apples a 110cm ba tare da stool ba, kuma wasu apples suna a tsayin daban-daban.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5",
      "hi": "Tao Tao कितने सेब तक पहुँच सकती है, इसकी गणना करें।\n\nआर्ग्स:\napple_heights (List[int]): जमीन से सेबों की ऊंचाई (सेंटीमीटर में)।\ntao_reach (int): अधिकतम ऊंचाई तक Tao Tao अपने हाथ को ऊपर की ओर खींच सकती है (सेंटीमीटर में)।\n\nरिटर्न्स:\nint: सेबों की संख्या जिन तक Tao Tao 30 सेमी के स्टूल पर खड़े होकर या बिना खड़े हुए पहुँच सकती है।\n\nयह फ़ंक्शन सेबों की ऊंचाई की सूची पर इटरेट करता है और गिनता है कि उनमें से कितने Tao Tao की पहुँच के भीतर हैं, \n30 सेमी का अतिरिक्त लाभ जो स्टूल प्रदान करता है, उसे ध्यान में रखते हुए।\n\nउदाहरण मामले:\n1. Tao Tao 120 सेमी पर स्टूल के बिना सेब तक पहुँच सकती है, और सभी सेब 150 सेमी या नीचे हैं।\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao 100 सेमी पर स्टूल के बिना सेब तक पहुँच सकती है, और सभी सेब 130 सेमी से ऊपर हैं।\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao 110 सेमी पर स्टूल के बिना सेब तक पहुँच सकती है, और कुछ सेब विभिन्न ऊंचाइयों पर हैं।\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5",
      "hu": "Számítsd ki, hány almát ér el Tao Tao.\n\nArgs:\napple_heights (List[int]): Az almák magassága a talajtól (centiméterben).\ntao_reach (int): Az a maximális magasság, amit Tao Tao elér a kezével felfelé nyújtózva (centiméterben).\n\nReturns:\nint: Az almák száma, amelyeket Tao Tao elérhet akár egy 30 cm-es zsámolyon állva, akár anélkül.\n\nEz a függvény végigmegy az alma magasságok listáján, és megszámolja, hány közülük van Tao Tao elérhetőségi tartományán belül,\nfigyelembe véve a zsámoly által biztosított további 30 cm-t.\n\nPélda esetek:\n1. Tao Tao eléri az almákat 120 cm-en zsámoly nélkül, és minden alma 150 cm-en vagy az alatt van.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> visszaadja 10\n\n2. Tao Tao eléri az almákat 100 cm-en zsámoly nélkül, és minden alma 130 cm felett van.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> visszaadja 0\n\n3. Tao Tao eléri az almákat 110 cm-en zsámoly nélkül, és néhány alma különböző magasságokban van.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> visszaadja 5"
    },
    "docstring_bertscore": {
      "sq": "0.9828877940434634",
      "hy": "0.9535339977037466",
      "bn": "0.9601829510785084",
      "bg": "0.9771056636515377",
      "zh": "0.9500966989599378",
      "fr": "0.9876167861551419",
      "de": "0.9713455812319071",
      "ha": "0.9855254068732257",
      "hi": "0.9689155371503262",
      "hu": "0.9724249387224506"
    }
  },
  {
    "task_id": "Python/36",
    "prompt": {
      "en": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\n      and 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\n      and at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\n      are cleared, leaving trees at positions 0 to 9 and 91 to 100.\n    \"\"\"",
      "sq": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit numrin e pemëve të mbetura përgjatë një rruge pasi zonat specifike janë pastruar.\n\n    Rruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\n    Çdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), që përfaqëson\n    intervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\n    Argumentet:\n    - l (int): Gjatësia e rrugës.\n    - areas (List[Tuple[int, int]]): Një listë e çifteve ku çdo çift përfaqëson një zonë të pastruar në rrugë.\n    \n    Kthen:\n    - int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n    \n    Shembuj:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5, pasi pemët nga pozicionet 2 deri 5\n      dhe 7 deri 9 janë pastruar, duke lënë pemët në pozicionet 0, 1, 6, dhe 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) do të kthejë 3, pasi pemët nga pozicionet 1 deri 3\n      dhe në pozicionin 4 janë pastruar, duke lënë pemët në pozicionet 0, 5, dhe 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20, pasi pemët nga pozicionet 10 deri 90\n      janë pastruar, duke lënë pemët në pozicionet 0 deri 9 dhe 91 deri 100.\n    \"\"\"",
      "hy": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվել ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են:\n\n    Ճանապարհը ներկայացված է որպես ուղիղ գիծ՝ 'l' երկարությամբ և սկզբում լցված է ծառերով:\n    Յուրաքանչյուր մաքրման համար նախատեսված տարածք նշված է ամբողջ թվերի զույգով (սկիզբ, վերջ), որը\n    ներկայացնում է ճանապարհի երկայնքով ներառական միջակայքը, որտեղ ծառերը կհեռացվեն:\n\n    Պարամետրեր:\n    - l (int): Ճանապարհի երկարությունը:\n    - areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի մաքրված տարածք:\n    \n    Վերադարձնում է:\n    - int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են:\n    \n    Օրինակներ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5, քանի որ 2-ից 5 և 7-ից 9 դիրքերում գտնվող ծառերը\n      մաքրվում են, թողնելով ծառեր 0, 1, 6 և 10 դիրքերում:\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) կվերադարձնի 3, քանի որ 1-ից 3 և 4 դիրքերում գտնվող ծառերը\n      մաքրվում են, թողնելով ծառեր 0, 5 և 6 դիրքերում:\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20, քանի որ 10-ից 90 դիրքերում գտնվող ծառերը\n      մաքրվում են, թողնելով ծառեր 0-ից 9 և 91-ից 100 դիրքերում:\n    \"\"\"",
      "bn": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    একটি রাস্তার পাশে নির্দিষ্ট এলাকা পরিষ্কার করার পর অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\n    রাস্তা একটি সরল রেখা হিসাবে 'l' দৈর্ঘ্যের প্রতিনিধিত্ব করে এবং প্রাথমিকভাবে গাছ দ্বারা পূর্ণ।\n    প্রতিটি নির্ধারিত পরিষ্কার এলাকা দুটি পূর্ণসংখ্যার জোড়া (শুরু, শেষ) হিসাবে নির্দিষ্ট করা হয়,\n    যা রাস্তার সেই অন্তর্ভুক্ত পরিসরকে উপস্থাপন করে যেখানে গাছগুলি সরানো হবে।\n\n    আর্গুমেন্টসমূহ:\n    - l (int): রাস্তার দৈর্ঘ্য।\n    - areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার একটি পরিষ্কার এলাকা উপস্থাপন করে।\n    \n    রিটার্ন:\n    - int: নির্দিষ্ট এলাকা পরিষ্কার করার পর রাস্তার পাশে অবশিষ্ট গাছের মোট সংখ্যা।\n    \n    উদাহরণ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 রিটার্ন করবে, কারণ অবস্থান 2 থেকে 5\n      এবং 7 থেকে 9 পর্যন্ত গাছ পরিষ্কার করা হয়, অবস্থান 0, 1, 6, এবং 10 এ গাছ অবশিষ্ট থাকে।\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 রিটার্ন করবে, কারণ অবস্থান 1 থেকে 3\n      এবং অবস্থান 4 এ গাছ পরিষ্কার করা হয়, অবস্থান 0, 5, এবং 6 এ গাছ অবশিষ্ট থাকে।\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 রিটার্ন করবে, কারণ অবস্থান 10 থেকে 90\n      পর্যন্ত গাছ পরিষ্কার করা হয়, অবস্থান 0 থেকে 9 এবং 91 থেকে 100 এ গাছ অবশিষ্ট থাকে।\n    \"\"\"",
      "bg": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява броя на останалите дървета по пътя след като определени зони са били изчистени.\n\n    Пътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\n    Всяка зона, планирана за изчистване, е посочена като двойка от цели числа (начало, край), представляващи\n    включителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\n    Аргументи:\n    - l (int): Дължината на пътя.\n    - areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона на пътя.\n    \n    Връща:\n    - int: Общият брой на останалите дървета по пътя след като определените зони са били изчистени.\n    \n    Примери:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5, тъй като дърветата от позиции 2 до 5\n      и 7 до 9 са изчистени, оставяйки дървета на позиции 0, 1, 6 и 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) ще върне 3, тъй като дърветата от позиции 1 до 3\n      и на позиция 4 са изчистени, оставяйки дървета на позиции 0, 5 и 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20, тъй като дърветата от позиции 10 до 90\n      са изчистени, оставяйки дървета на позиции 0 до 9 и 91 до 100.\n    \"\"\"",
      "zh": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在特定区域被清除后，沿道路剩余的树木数量。\n\n    道路表示为长度为 'l' 的直线，最初被树木填满。\n    每个计划清除的区域由一对整数 (start, end) 指定，表示将要移除树木的道路上的包含范围。\n\n    参数:\n    - l (int): 道路的长度。\n    - areas (List[Tuple[int, int]]): 一个元组列表，每个元组代表道路上的一个清除区域。\n    \n    返回:\n    - int: 指定区域被清除后，沿道路剩余的树木总数。\n    \n    示例:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5，因为位置 2 到 5 和 7 到 9 的树被清除，剩下位置 0, 1, 6 和 10 的树。\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 将返回 3，因为位置 1 到 3 和位置 4 的树被清除，剩下位置 0, 5 和 6 的树。\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20，因为位置 10 到 90 的树被清除，剩下位置 0 到 9 和 91 到 100 的树。\n    \"\"\"",
      "fr": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été défrichées.\n\n    La route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres.\n    Chaque zone prévue pour le défrichage est spécifiée comme une paire d'entiers (début, fin), représentant\n    la plage inclusive le long de la route où les arbres seront enlevés.\n\n    Args:\n    - l (int) : La longueur de la route.\n    - areas (List[Tuple[int, int]]) : Une liste de tuples où chaque tuple représente une zone défrichée sur la route.\n    \n    Returns:\n    - int : Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été défrichées.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) renverra 5, car les arbres des positions 2 à 5\n      et 7 à 9 sont défrichés, laissant des arbres aux positions 0, 1, 6 et 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) renverra 3, car les arbres des positions 1 à 3\n      et à la position 4 sont défrichés, laissant des arbres aux positions 0, 5 et 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) renverra 20, car les arbres des positions 10 à 90\n      sont défrichés, laissant des arbres aux positions 0 à 9 et 91 à 100.\n    \"\"\"",
      "de": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechne die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\n    Die Straße wird als gerade Linie der Länge 'l' dargestellt und ist zunächst mit Bäumen gefüllt.\n    Jeder zur Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (Start, Ende) angegeben, \n    das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\n    Argumente:\n    - l (int): Die Länge der Straße.\n    - areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n    \n    Rückgabewert:\n    - int: Die Gesamtanzahl der verbleibenden Bäume entlang der Straße, nachdem die angegebenen Bereiche gerodet wurden.\n    \n    Beispiele:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) gibt 5 zurück, da Bäume von den Positionen 2 bis 5\n      und 7 bis 9 gerodet werden, wodurch Bäume an den Positionen 0, 1, 6 und 10 verbleiben.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) gibt 3 zurück, da Bäume von den Positionen 1 bis 3\n      und an Position 4 gerodet werden, wodurch Bäume an den Positionen 0, 5 und 6 verbleiben.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) gibt 20 zurück, da Bäume von den Positionen 10 bis 90\n      gerodet werden, wodurch Bäume an den Positionen 0 bis 9 und 91 bis 100 verbleiben.\n    \"\"\"",
      "ha": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafi adadin bishiyoyin da suka rage a gefen hanya bayan an share wasu wurare.\n\n    Hanyar tana wakiltar layi madaidaici mai tsawon 'l' kuma a farko cike take da bishiyoyi.\n    Kowanne yanki da aka shirya sharewa an bayyana shi azaman ma'aurata na lambobi (farko, ƙarshe), wanda ke wakiltar\n    kewayon da aka haɗa a gefen hanya inda za a cire bishiyoyin.\n\n    Args:\n    - l (int): Tsawon hanyar.\n    - areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowanne ma'aurata ke wakiltar yankin da aka share a kan hanya.\n    \n    Returns:\n    - int: Jimillar adadin bishiyoyin da suka rage a gefen hanya bayan an share wuraren da aka bayyana.\n    \n    Misalai:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5, domin an share bishiyoyi daga wurare 2 zuwa 5\n      da 7 zuwa 9, suna barin bishiyoyi a wurare 0, 1, 6, da 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) zai dawo da 3, domin an share bishiyoyi daga wurare 1 zuwa 3\n      da a wurin 4, suna barin bishiyoyi a wurare 0, 5, da 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20, domin an share bishiyoyi daga wurare 10 zuwa 90\n      suna barin bishiyoyi a wurare 0 zuwa 9 da 91 zuwa 100.\n    \"\"\"",
      "hi": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    एक सड़क के साथ शेष पेड़ों की संख्या की गणना करें जब विशिष्ट क्षेत्रों को साफ़ कर दिया गया हो।\n\n    सड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और यह प्रारंभ में पेड़ों से भरी होती है।\n    प्रत्येक क्षेत्र जिसे साफ़ करने के लिए निर्धारित किया गया है, को पूर्णांक (start, end) की एक जोड़ी के रूप में निर्दिष्ट किया गया है,\n    जो सड़क के साथ समावेशी सीमा का प्रतिनिधित्व करता है जहाँ पेड़ हटा दिए जाएंगे।\n\n    तर्क:\n    - l (int): सड़क की लंबाई।\n    - areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहाँ प्रत्येक ट्यूपल सड़क पर साफ़ किए गए क्षेत्र का प्रतिनिधित्व करता है।\n    \n    लौटाता है:\n    - int: कुल शेष पेड़ों की संख्या जो निर्दिष्ट क्षेत्रों को साफ़ करने के बाद सड़क के साथ बची है।\n    \n    उदाहरण:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा, क्योंकि स्थिति 2 से 5 और 7 से 9 तक के पेड़ साफ़ कर दिए गए हैं,\n      जिससे स्थिति 0, 1, 6, और 10 पर पेड़ बचे हैं।\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 लौटाएगा, क्योंकि स्थिति 1 से 3 और स्थिति 4 पर पेड़ साफ़ कर दिए गए हैं,\n      जिससे स्थिति 0, 5, और 6 पर पेड़ बचे हैं।\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा, क्योंकि स्थिति 10 से 90 तक के पेड़ साफ़ कर दिए गए हैं,\n      जिससे स्थिति 0 से 9 और 91 से 100 पर पेड़ बचे हैं।\n    \"\"\"",
      "hu": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a megmaradt fák számát egy út mentén, miután meghatározott területeket kiirtottak.\n\n    Az út egy egyenes vonalként van ábrázolva, amelynek hossza 'l', és kezdetben fákkal van tele.\n    Minden irtásra tervezett területet egy (kezdő, vég) egész szám párként adnak meg, amely az út\n    mentén azt a tartományt jelöli, ahol a fákat eltávolítják.\n\n    Argumentumok:\n    - l (int): Az út hossza.\n    - areas (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár egy irtott területet jelöl az úton.\n    \n    Visszatérési érték:\n    - int: Az út mentén megmaradt fák teljes száma a meghatározott területek kiirtása után.\n    \n    Példák:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja az 5-öt, mivel a 2-től 5-ig\n      és 7-től 9-ig terjedő pozíciók fái ki vannak irtva, így a 0, 1, 6 és 10 pozíciókon maradnak fák.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) visszaadja a 3-at, mivel az 1-től 3-ig\n      és a 4-es pozíció fái ki vannak irtva, így a 0, 5 és 6 pozíciókon maradnak fák.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) visszaadja a 20-at, mivel a 10-től 90-ig\n      terjedő pozíciók fái ki vannak irtva, így a 0-tól 9-ig és 91-től 100-ig terjedő pozíciókon maradnak fák.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9778149727422133",
      "hy": "0.9606064310508747",
      "bn": "0.9593278472881532",
      "bg": "0.9742555163140681",
      "zh": "0.9623827825484698",
      "fr": "0.9895244323346011",
      "de": "0.9817107104054505",
      "ha": "0.9505150145423973",
      "hi": "0.9789320700051536",
      "hu": "0.9478640934771057"
    },
    "canonical_solution": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees",
    "instruction": {
      "en": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nՏվեք Python կոդի հակիրճ բնութագրական նկարագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9352562286712972",
      "hy": "0.8725670900040192",
      "bn": "0.9122435086157381",
      "bg": "0.8983697723915943",
      "zh": "0.8886474111310796",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9530483464221162",
      "hi": "0.8964889413135749",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_remaining_trees_after_clearing():\n    test_cases = [\n        (500, [(150, 300), (100, 200), (470, 471)], 298),\n        (1000, [(0, 100), (200, 300), (400, 500), (600, 700), (800, 900)], 496),\n        (10, [(3, 4), (7, 9)], 6),\n    ]\n\n    for i, (l, areas, expected) in enumerate(test_cases, 1):\n        result = remaining_trees_after_clearing(l, areas)\n        assert result == expected, f\"Test case {i} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i} passed.\")\n\n\ntest_remaining_trees_after_clearing()",
    "entry_point": "remaining_trees_after_clearing",
    "signature": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "Calculate the number of remaining trees along a road after specific areas have been cleared.\n\nThe road is represented as a straight line of length 'l' and is initially filled with trees.\nEach area scheduled for clearing is specified as a pair of integers (start, end), representing\nthe inclusive range along the road where the trees will be removed.\n\nArgs:\n- l (int): The length of the road.\n- areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n\nReturns:\n- int: The total number of trees remaining along the road after the specified areas have been cleared.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\nand 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\nand at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\nare cleared, leaving trees at positions 0 to 9 and 91 to 100.",
      "sq": "Llogarit numrin e pemëve të mbetura përgjatë një rruge pasi zona të caktuara janë pastruar.\n\nRruga përfaqësohet si një vijë e drejtë me gjatësi 'l' dhe fillimisht është e mbushur me pemë.\nÇdo zonë e planifikuar për pastrim specifikohet si një çift numrash të plotë (fillimi, fundi), që përfaqëson\nintervalin përfshirës përgjatë rrugës ku pemët do të hiqen.\n\nArgumentet:\n- l (int): Gjatësia e rrugës.\n- zonat (List[Tuple[int, int]]): Një listë e tupleve ku çdo tuple përfaqëson një zonë të pastruar në rrugë.\n\nKthen:\n- int: Numri total i pemëve të mbetura përgjatë rrugës pasi zonat e specifikuara janë pastruar.\n\nShembuj:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) do të kthejë 5, pasi pemët nga pozicionet 2 deri në 5\ndhe 7 deri në 9 janë pastruar, duke lënë pemët në pozicionet 0, 1, 6, dhe 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) do të kthejë 3, pasi pemët nga pozicionet 1 deri në 3\ndhe në pozicionin 4 janë pastruar, duke lënë pemët në pozicionet 0, 5, dhe 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) do të kthejë 20, pasi pemët nga pozicionet 10 deri në 90\njanë pastruar, duke lënë pemët në pozicionet 0 deri në 9 dhe 91 deri në 100.",
      "hy": "Հաշվարկել ճանապարհի երկայնքով մնացած ծառերի քանակը այն բանից հետո, երբ որոշակի տարածքներ մաքրվել են:\n\nՃանապարհը ներկայացված է որպես ուղիղ գիծ `l` երկարությամբ և սկզբում լցված է ծառերով:\nՅուրաքանչյուր մաքրման ենթակա տարածք նշված է որպես ամբողջ թվերի զույգ (սկիզբ, վերջ), որը ներկայացնում է\nճանապարհի երկայնքով ընդգրկուն միջակայքը, որտեղ ծառերը կհեռացվեն:\n\nԱրձանագրություններ:\n- l (int): Ճանապարհի երկարությունը:\n- areas (List[Tuple[int, int]]): Զույգերի ցուցակ, որտեղ յուրաքանչյուր զույգ ներկայացնում է ճանապարհի մաքրված տարածք:\n\nՎերադարձնում է:\n- int: Ճանապարհի երկայնքով մնացած ծառերի ընդհանուր քանակը այն բանից հետո, երբ նշված տարածքները մաքրվել են:\n\nՕրինակներ:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) կվերադարձնի 5, քանի որ 2-ից 5\nև 7-ից 9 դիրքերում ծառերը մաքրվում են, թողնելով ծառեր 0, 1, 6 և 10 դիրքերում:\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) կվերադարձնի 3, քանի որ 1-ից 3\nև 4 դիրքերում ծառերը մաքրվում են, թողնելով ծառեր 0, 5 և 6 դիրքերում:\n\n- remaining_trees_after_clearing(100, [(10, 90)]) կվերադարձնի 20, քանի որ 10-ից 90\nդիրքերում ծառերը մաքրվում են, թողնելով ծառեր 0-ից 9 և 91-ից 100 դիրքերում:",
      "bn": "রাস্তার পাশে নির্দিষ্ট কিছু এলাকা পরিষ্কার করার পর অবশিষ্ট গাছের সংখ্যা গণনা করুন।\n\nরাস্তা একটি সরল রেখা হিসাবে 'l' দৈর্ঘ্যের এবং প্রাথমিকভাবে গাছ দিয়ে পূর্ণ। প্রতিটি পরিষ্কার করার জন্য নির্ধারিত এলাকা একটি পূর্ণসংখ্যার জোড়া (শুরু, শেষ) হিসাবে নির্দিষ্ট করা হয়, যা রাস্তার বরাবর অন্তর্ভুক্তিকৃত পরিসরকে উপস্থাপন করে যেখানে গাছগুলি সরানো হবে।\n\nআর্গস:\n- l (int): রাস্তার দৈর্ঘ্য।\n- areas (List[Tuple[int, int]]): একটি টুপলের তালিকা যেখানে প্রতিটি টুপল রাস্তার একটি পরিষ্কার করা এলাকা উপস্থাপন করে।\n\nরিটার্নস:\n- int: নির্দিষ্ট এলাকাগুলি পরিষ্কার করার পরে রাস্তার পাশে অবশিষ্ট মোট গাছের সংখ্যা।\n\nউদাহরণ:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 ফেরত দেবে, কারণ অবস্থান 2 থেকে 5 এবং 7 থেকে 9 পর্যন্ত গাছগুলি পরিষ্কার করা হয়েছে, অবস্থান 0, 1, 6, এবং 10 এ গাছ রেখে।\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 ফেরত দেবে, কারণ অবস্থান 1 থেকে 3 এবং অবস্থান 4 এ গাছগুলি পরিষ্কার করা হয়েছে, অবস্থান 0, 5, এবং 6 এ গাছ রেখে।\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 20 ফেরত দেবে, কারণ অবস্থান 10 থেকে 90 পর্যন্ত গাছগুলি পরিষ্কার করা হয়েছে, অবস্থান 0 থেকে 9 এবং 91 থেকে 100 পর্যন্ত গাছ রেখে।",
      "bg": "Изчислете броя на останалите дървета по пътя след като определени зони са били изчистени.\n\nПътят е представен като права линия с дължина 'l' и първоначално е запълнен с дървета.\nВсяка зона, планирана за изчистване, е посочена като двойка от цели числа (начало, край), представляваща\nвключителния диапазон по пътя, където дърветата ще бъдат премахнати.\n\nАргументи:\n- l (int): Дължината на пътя.\n- areas (List[Tuple[int, int]]): Списък от двойки, където всяка двойка представлява изчистена зона на пътя.\n\nВръща:\n- int: Общият брой на дърветата, останали по пътя след като определените зони са били изчистени.\n\nПримери:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) ще върне 5, тъй като дърветата от позиции 2 до 5\nи 7 до 9 са изчистени, оставяйки дървета на позиции 0, 1, 6 и 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) ще върне 3, тъй като дърветата от позиции 1 до 3\nи на позиция 4 са изчистени, оставяйки дървета на позиции 0, 5 и 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) ще върне 20, тъй като дърветата от позиции 10 до 90\nса изчистени, оставяйки дървета на позиции от 0 до 9 и от 91 до 100.",
      "zh": "计算沿道路剩余的树木数量，在特定区域被清除后。\n\n道路表示为长度为 'l' 的直线，最初布满了树木。\n每个计划清除的区域由一对整数 (start, end) 指定，表示沿道路将要移除树木的包含范围。\n\n参数：\n- l (int): 道路的长度。\n- areas (List[Tuple[int, int]]): 一个元组列表，其中每个元组表示道路上的一个清除区域。\n\n返回：\n- int: 指定区域被清除后，沿道路剩余的树木总数。\n\n示例：\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 将返回 5，因为位置 2 到 5 和 7 到 9 的树木被清除，剩下位置 0, 1, 6 和 10 的树木。\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 将返回 3，因为位置 1 到 3 和位置 4 的树木被清除，剩下位置 0, 5 和 6 的树木。\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 将返回 20，因为位置 10 到 90 的树木被清除，剩下位置 0 到 9 和 91 到 100 的树木。",
      "fr": "Calculer le nombre d'arbres restants le long d'une route après que des zones spécifiques ont été défrichées.\n\nLa route est représentée comme une ligne droite de longueur 'l' et est initialement remplie d'arbres.\nChaque zone prévue pour le défrichage est spécifiée comme une paire d'entiers (début, fin), représentant\nla plage inclusive le long de la route où les arbres seront enlevés.\n\nArgs:\n- l (int) : La longueur de la route.\n- areas (List[Tuple[int, int]]) : Une liste de tuples où chaque tuple représente une zone défrichée sur la route.\n\nReturns:\n- int : Le nombre total d'arbres restants le long de la route après que les zones spécifiées ont été défrichées.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) retournera 5, car les arbres des positions 2 à 5\net 7 à 9 sont défrichés, laissant des arbres aux positions 0, 1, 6, et 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) retournera 3, car les arbres des positions 1 à 3\net à la position 4 sont défrichés, laissant des arbres aux positions 0, 5, et 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) retournera 20, car les arbres des positions 10 à 90\nsont défrichés, laissant des arbres aux positions 0 à 9 et 91 à 100.",
      "de": "Berechne die Anzahl der verbleibenden Bäume entlang einer Straße, nachdem bestimmte Bereiche gerodet wurden.\n\nDie Straße wird als gerade Linie der Länge 'l' dargestellt und ist zunächst mit Bäumen gefüllt.\nJeder zur Rodung vorgesehene Bereich wird als Paar von ganzen Zahlen (Start, Ende) angegeben, das den inklusiven Bereich entlang der Straße darstellt, in dem die Bäume entfernt werden.\n\nArgs:\n- l (int): Die Länge der Straße.\n- areas (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel einen gerodeten Bereich auf der Straße darstellt.\n\nReturns:\n- int: Die Gesamtanzahl der Bäume, die entlang der Straße verbleiben, nachdem die angegebenen Bereiche gerodet wurden.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) wird 5 zurückgeben, da die Bäume von den Positionen 2 bis 5 und 7 bis 9 gerodet werden, wodurch die Bäume an den Positionen 0, 1, 6 und 10 verbleiben.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) wird 3 zurückgeben, da die Bäume von den Positionen 1 bis 3 und an Position 4 gerodet werden, wodurch die Bäume an den Positionen 0, 5 und 6 verbleiben.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) wird 20 zurückgeben, da die Bäume von den Positionen 10 bis 90 gerodet werden, wodurch die Bäume an den Positionen 0 bis 9 und 91 bis 100 verbleiben.",
      "ha": "Lissafi adadin bishiyoyin da suka rage a gefen hanya bayan an share wasu wurare.\n\nAn hanyar tana wakiltar layi madaidaici mai tsawon 'l' kuma a farko cike take da itatuwa. Kowace yanki da aka tsara don sharewa an bayyana ta azaman ma'aurata na lambobi (farko, ƙarshe), wanda ke wakiltar kewayon da aka haɗa tare da hanya inda za a cire itatuwan.\n\nArgs:\n- l (int): Tsawon hanyar.\n- areas (List[Tuple[int, int]]): Jerin ma'aurata inda kowace ma'aurata ke wakiltar yanki da aka share akan hanya.\n\nReturns:\n- int: Jimillar adadin itatuwan da suka rage a kan hanya bayan an share yankunan da aka fayyace.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) zai dawo da 5, domin itatuwan daga matsayi na 2 zuwa 5\nda 7 zuwa 9 an share su, sun bar itatuwa a matsayi na 0, 1, 6, da 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) zai dawo da 3, domin itatuwan daga matsayi na 1 zuwa 3\nda a matsayi na 4 an share su, sun bar itatuwa a matsayi na 0, 5, da 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) zai dawo da 20, domin itatuwan daga matsayi na 10 zuwa 90\nan share su, sun bar itatuwa a matsayi na 0 zuwa 9 da 91 zuwa 100.",
      "hi": "सड़क के किनारे बचे हुए पेड़ों की संख्या की गणना करें जब कुछ विशिष्ट क्षेत्रों को साफ़ कर दिया गया हो।\n\nसड़क को 'l' लंबाई की एक सीधी रेखा के रूप में दर्शाया गया है और यह प्रारंभ में पेड़ों से भरी होती है। प्रत्येक क्षेत्र जिसे साफ़ करने के लिए निर्धारित किया गया है, को पूर्णांकों की एक जोड़ी (start, end) के रूप में निर्दिष्ट किया जाता है, जो सड़क के साथ समावेशी सीमा का प्रतिनिधित्व करता है जहाँ पेड़ों को हटाया जाएगा।\n\nआर्ग्स:\n- l (int): सड़क की लंबाई।\n- areas (List[Tuple[int, int]]): ट्यूपल की एक सूची जहाँ प्रत्येक ट्यूपल सड़क पर साफ़ किए गए क्षेत्र का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\n- int: सड़क के किनारे कुल बचे हुए पेड़ों की संख्या जब निर्दिष्ट क्षेत्रों को साफ़ कर दिया गया हो।\n\nउदाहरण:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 लौटाएगा, क्योंकि स्थिति 2 से 5 और 7 से 9 तक के पेड़ साफ़ कर दिए गए हैं, जिससे स्थिति 0, 1, 6, और 10 पर पेड़ बचे हैं।\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 लौटाएगा, क्योंकि स्थिति 1 से 3 और स्थिति 4 पर पेड़ साफ़ कर दिए गए हैं, जिससे स्थिति 0, 5, और 6 पर पेड़ बचे हैं।\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 20 लौटाएगा, क्योंकि स्थिति 10 से 90 तक के पेड़ साफ़ कर दिए गए हैं, जिससे स्थिति 0 से 9 और 91 से 100 पर पेड़ बचे हैं।",
      "hu": "Számítsa ki az út mentén megmaradt fák számát, miután bizonyos területeket megtisztítottak.\n\nAz út egy 'l' hosszúságú egyenes vonalként van ábrázolva, amely kezdetben fákkal van tele.\nMinden tisztításra ütemezett terület egy egész számokból álló párként van megadva (kezdő, vég),\namely az út mentén azt a tartományt jelöli, ahol a fákat eltávolítják.\n\nArgs:\n- l (int): Az út hossza.\n- areas (List[Tuple[int, int]]): Egy listája a pároknak, ahol minden pár egy tisztított területet jelöl az úton.\n\nReturns:\n- int: Az út mentén megmaradt fák teljes száma a megadott területek megtisztítása után.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) visszaadja az 5-öt, mivel a 2-től 5-ig\nés 7-től 9-ig terjedő pozíciók fái ki vannak tisztítva, így a 0, 1, 6 és 10 pozíciókon maradnak fák.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) visszaadja a 3-at, mivel az 1-től 3-ig\nés a 4-es pozíción lévő fák ki vannak tisztítva, így a 0, 5 és 6 pozíciókon maradnak fák.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) visszaadja a 20-at, mivel a 10-től 90-ig\nterjedő pozíciók fái ki vannak tisztítva, így a 0-tól 9-ig és 91-től 100-ig terjedő pozíciókon maradnak fák."
    },
    "docstring_bertscore": {
      "sq": "0.9830355750469533",
      "hy": "0.9477810659778331",
      "bn": "0.9558609526175702",
      "bg": "0.9730919395419658",
      "zh": "0.9624991799517563",
      "fr": "0.988602191475456",
      "de": "0.9840148228254553",
      "ha": "0.973155699894278",
      "hi": "0.985139865303637",
      "hu": "0.9563299189471937"
    }
  },
  {
    "task_id": "Python/37",
    "prompt": {
      "en": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      In this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\n      to the time constraint, leading to a maximum value of 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Here, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      With a time limit of 5, only the first herb can be picked, providing a value of 10.\n    \"\"\"",
      "sq": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri kohor të caktuar.\n\n    Kjo funksion zgjidh një variant të problemit të çantës 0/1 ku qëllimi është të maksimizohet\n    vlera totale e bimëve të mbledhura pa tejkaluar kufirin kohor. Çdo bimë mund të mblidhet\n    maksimumi një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\n    Argumentet:\n    - T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n    - M (int): Numri i bimëve të ndryshme në shpellë.\n    - herbs (List[Tuple[int, int]]): Një listë tuples, ku çdo tuple përmban dy numra të plotë\n      që përfaqësojnë kohën e kërkuar për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\n    Kthen:\n    - int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit kohor.\n\n    Shembuj:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Në këtë skenar, vetëm bima që kërkon 1 njësi kohe për një vlerë prej 2 mund të mblidhet për shkak\n      të kufizimit kohor, duke çuar në një vlerë maksimale prej 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Këtu, strategjia më e mirë është të mblidhen bimët me kohë 1, 2, dhe 3, duke çuar në një vlerë maksimale prej 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Me një kufi kohor prej 5, vetëm bima e parë mund të mblidhet, duke ofruar një vlerë prej 10.\n    \"\"\"",
      "hy": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Հաշվել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել տրված ժամանակային սահմանափակման շրջանակներում:\n\n    Այս ֆունկցիան լուծում է 0/1 պայուսակի խնդրի տարբերակը, որտեղ նպատակը խոտաբույսերի ընդհանուր արժեքի առավելագույնացումն է՝ առանց ժամանակային սահմանափակումը գերազանցելու: Յուրաքանչյուր խոտաբույս կարելի է հավաքել առավելագույնը մեկ անգամ և ունի կապված ժամանակային արժեք և արժեք:\n\n    Արգումենտներ:\n    - T (int): Ընդհանուր ժամանակը, որը հասանելի է խոտաբույսեր հավաքելու համար:\n    - M (int): Տարբեր խոտաբույսերի քանակը քարանձավում:\n    - herbs (List[Tuple[int, int]]): Ցուցակ, որտեղ յուրաքանչյուր տուփ պարունակում է երկու ամբողջ թիվ, որոնք ներկայացնում են խոտաբույսի հավաքման համար պահանջվող ժամանակը և խոտաբույսի արժեքը, համապատասխանաբար:\n\n    Վերադարձնում է:\n    - int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել ժամանակային սահմանափակման շրջանակներում:\n\n    Օրինակներ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Այս սցենարում, միայն այն խոտաբույսը, որը պահանջում է 1 միավոր ժամանակ արժեքով 2, կարելի է հավաքել\n      ժամանակային սահմանափակման պատճառով, ինչը հանգեցնում է առավելագույն արժեքի 3:\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Այստեղ, լավագույն ռազմավարությունն է հավաքել խոտաբույսերը, որոնց ժամանակները 1, 2 և 3 են, ինչը հանգեցնում է առավելագույն արժեքի 10 + 15 + 20 = 50:\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 ժամանակային սահմանափակմամբ, միայն առաջին խոտաբույսը կարելի է հավաքել՝ ապահովելով 10 արժեք:\n    \"\"\"",
      "bn": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    নির্দিষ্ট সময়সীমার মধ্যে যতটা সম্ভব সর্বোচ্চ মোট মূল্যবান ভেষজ সংগ্রহ করা যায় তা গণনা করুন।\n\n    এই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি পরিবর্তন সমাধান করে যেখানে লক্ষ্য হল\n    মোট ভেষজ মূল্য সর্বাধিক করা যা সময়সীমা অতিক্রম না করে সংগ্রহ করা যায়। প্রতিটি ভেষজ\n    সর্বাধিক একবার সংগ্রহ করা যেতে পারে এবং এর সাথে সম্পর্কিত সময় খরচ এবং মূল্য রয়েছে।\n\n    আর্গুমেন্টসমূহ:\n    - T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    - M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n    - herbs (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা\n      রয়েছে যা ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং ভেষজের মূল্য প্রতিনিধিত্ব করে।\n\n    রিটার্নস:\n    - int: সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বোচ্চ মোট মূল্য।\n\n    উদাহরণ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      এই পরিস্থিতিতে, সময় সীমাবদ্ধতার কারণে শুধুমাত্র 1 ইউনিট সময়ের জন্য 2 মূল্যের ভেষজটি সংগ্রহ করা যায়,\n      যা সর্বাধিক মূল্য 3 এ নিয়ে যায়।\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      এখানে, সর্বোত্তম কৌশল হল 1, 2 এবং 3 সময়ের ভেষজগুলি সংগ্রহ করা, যা সর্বাধিক মূল্য 10 + 15 + 20 = 50 এ নিয়ে যায়।\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 সময়সীমার মধ্যে, শুধুমাত্র প্রথম ভেষজটি সংগ্রহ করা যায়, যা 10 মূল্যের প্রদান করে।\n    \"\"\"",
      "bg": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\n    Тази функция решава вариация на проблема с раницата 0/1, където целта е да се максимизира\n    общата стойност на събраните билки, без да се превишава времевият лимит. Всяка билка може да бъде събрана\n    най-много веднъж и има свързани времеви разходи и стойност.\n\n    Аргументи:\n    - T (int): Общото време, налично за събиране на билки.\n    - M (int): Броят на различните билки в пещерата.\n    - herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа,\n      представляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\n    Връща:\n    - int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\n    Примери:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      В този сценарий, само билката, която отнема 1 единица време за стойност 2, може да бъде събрана поради\n      времевото ограничение, водещо до максимална стойност от 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Тук, най-добрата стратегия е да се съберат билките с времена 1, 2 и 3, водещи до максимална стойност от 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      С времеви лимит от 5, само първата билка може да бъде събрана, осигурявайки стойност от 10.\n    \"\"\"",
      "zh": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    计算在给定时间限制内可以采摘的草药的最大总价值。\n\n    此函数解决了0/1背包问题的一个变体，其目标是在不超过时间限制的情况下最大化\n    采摘草药的总价值。每种草药最多只能采摘一次，并且有一个相关的时间成本和价值。\n\n    参数:\n    - T (int): 可用于采摘草药的总时间。\n    - M (int): 洞穴中不同草药的数量。\n    - herbs (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数，\n      分别表示采摘草药所需的时间和草药的价值。\n\n    返回:\n    - int: 在时间限制内可以采摘的草药的最大总价值。\n\n    示例:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      在这种情况下，由于时间限制，只能采摘需要1单位时间且价值为2的草药，\n      从而达到最大价值3。\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      在这里，最佳策略是采摘时间为1、2和3的草药，最大价值为10 + 15 + 20 = 50。\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      在时间限制为5的情况下，只能采摘第一种草药，提供价值10。\n    \"\"\"",
      "fr": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculer la valeur totale maximale des herbes qui peuvent être cueillies dans un délai donné.\n\n    Cette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\n    la valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\n    au plus une fois et a un coût en temps et une valeur associés.\n\n    Args:\n    - T (int): Le temps total disponible pour cueillir les herbes.\n    - M (int): Le nombre d'herbes différentes dans la grotte.\n    - herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\n      représentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\n    Returns:\n    - int: La valeur totale maximale des herbes qui peuvent être cueillies dans la limite de temps.\n\n    Exemples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Dans ce scénario, seule l'herbe qui prend 1 unité de temps pour une valeur de 2 peut être cueillie en raison\n      de la contrainte de temps, conduisant à une valeur maximale de 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Ici, la meilleure stratégie est de cueillir les herbes avec des temps de 1, 2 et 3, conduisant à une valeur maximale de 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Avec une limite de temps de 5, seule la première herbe peut être cueillie, fournissant une valeur de 10.\n    \"\"\"",
      "de": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Berechne den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gesammelt werden können.\n\n    Diese Funktion löst eine Variation des 0/1-Rucksackproblems, bei dem das Ziel darin besteht,\n    den Gesamtwert der gesammelten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten.\n    Jedes Kraut kann höchstens einmal gesammelt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\n    Argumente:\n    - T (int): Die insgesamt verfügbare Zeit zum Sammeln der Kräuter.\n    - M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n    - herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält,\n      die die zum Sammeln des Krauts erforderliche Zeit und den Wert des Krauts darstellen.\n\n    Rückgabewert:\n    - int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gesammelt werden können.\n\n    Beispiele:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      In diesem Szenario kann aufgrund der Zeitbeschränkung nur das Kraut gesammelt werden,\n      das 1 Zeiteinheit für einen Wert von 2 benötigt, was zu einem maximalen Wert von 3 führt.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Hier ist die beste Strategie, Kräuter mit den Zeiten 1, 2 und 3 zu sammeln, was zu einem maximalen Wert von 10 + 15 + 20 = 50 führt.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Mit einem Zeitlimit von 5 kann nur das erste Kraut gesammelt werden, was einen Wert von 10 liefert.\n    \"\"\"",
      "ha": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Lissafa darajar ganyayyaki mafi girma da za a iya ɗauka cikin iyakar lokaci da aka bayar.\n\n    Wannan aikin yana warware wani bambancin matsalar jakar 0/1 inda manufar ita ce a ƙara\n    darajar ganyayyaki da aka ɗauka ba tare da wuce iyakar lokaci ba. Ana iya ɗaukar kowanne ganye\n    sau ɗaya kawai kuma yana da alaƙa da farashin lokaci da daraja.\n\n    Args:\n    - T (int): Jimillar lokacin da ake da shi don ɗaukar ganyayyaki.\n    - M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n    - herbs (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple ya ƙunshi lambobi biyu\n      da ke wakiltar lokacin da ake buƙata don ɗaukar ganyen da kuma darajar ganyen, bi da bi.\n\n    Returns:\n    - int: Mafi girman darajar ganyayyaki da za a iya ɗauka cikin iyakar lokacin.\n\n    Misalai:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      A wannan yanayin, kawai ganyen da ke ɗaukar 1 na lokaci don darajar 2 ne za a iya ɗauka saboda\n      ƙuntatawar lokaci, yana kaiwa ga darajar 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Anan, mafi kyawun dabaru ita ce ɗaukar ganyayyaki masu lokuta 1, 2, da 3, yana kaiwa ga darajar 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Tare da iyakar lokaci na 5, kawai ganye na farko ne za a iya ɗauka, yana bayar da darajar 10.\n    \"\"\"",
      "hi": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    दिए गए समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करें।\n\n    यह फ़ंक्शन 0/1 नॅपसैक समस्या के एक भिन्न रूप को हल करता है जहाँ लक्ष्य\n    समय सीमा से अधिक किए बिना चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम करना है। प्रत्येक जड़ी-बूटी को\n    अधिकतम एक बार चुना जा सकता है और इसका एक संबंधित समय लागत और मूल्य होता है।\n\n    तर्क:\n    - T (int): जड़ी-बूटियों को चुनने के लिए उपलब्ध कुल समय।\n    - M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n    - herbs (List[Tuple[int, int]]): टुपल की एक सूची, जहाँ प्रत्येक टुपल में दो पूर्णांक होते हैं\n      जो क्रमशः जड़ी-बूटी को चुनने के लिए आवश्यक समय और जड़ी-बूटी के मूल्य का प्रतिनिधित्व करते हैं।\n\n    वापसी:\n    - int: समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      इस परिदृश्य में, केवल वह जड़ी-बूटी जिसे 2 के मूल्य के लिए 1 इकाई समय लगता है,\n      समय सीमा के कारण चुनी जा सकती है, जिससे अधिकतम मूल्य 3 होता है।\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      यहाँ, सबसे अच्छी रणनीति 1, 2, और 3 समय वाली जड़ी-बूटियों को चुनना है, जिससे अधिकतम मूल्य 10 + 15 + 20 = 50 होता है।\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 की समय सीमा के साथ, केवल पहली जड़ी-बूटी को चुना जा सकता है, जो 10 का मूल्य प्रदान करती है।\n    \"\"\"",
      "hu": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Számítsa ki a maximális összértéket a gyógynövényeknek, amelyeket egy adott időkorláton belül lehet összegyűjteni.\n\n    Ez a függvény a 0/1 hátizsák probléma egy változatát oldja meg, ahol a cél a gyógynövények\n    összértékének maximalizálása anélkül, hogy túllépnénk az időkorlátot. Minden gyógynövényt\n    legfeljebb egyszer lehet összegyűjteni, és mindegyikhez tartozik egy időráfordítás és egy érték.\n\n    Argumentumok:\n    - T (int): Az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    - M (int): A különböző gyógynövények száma a barlangban.\n    - herbs (List[Tuple[int, int]]): Egy lista, amelyben minden elem egy pár, ahol az első szám\n      a gyógynövény összegyűjtéséhez szükséges időt, a második pedig a gyógynövény értékét jelenti.\n\n    Visszatérési érték:\n    - int: A maximális összérték a gyógynövényeknek, amelyeket az időkorláton belül lehet összegyűjteni.\n\n    Példák:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Ebben az esetben csak az a gyógynövény gyűjthető össze, amely 1 egységnyi időt igényel 2 értékért,\n      az időkorlát miatt, így a maximális érték 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Itt a legjobb stratégia az 1, 2 és 3 időt igénylő gyógynövények összegyűjtése, ami 10 + 15 + 20 = 50 maximális értéket eredményez.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5-ös időkorláttal csak az első gyógynövény gyűjthető össze, amely 10 értéket biztosít.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9785425558279441",
      "hy": "0.9604324308370882",
      "bn": "0.9539163611872387",
      "bg": "0.9741730847059387",
      "zh": "0.9657894922135991",
      "fr": "0.9846196523357066",
      "de": "0.9645309701193621",
      "ha": "0.9675199600931751",
      "hi": "0.9743317903803855",
      "hu": "0.9439445201681442"
    },
    "canonical_solution": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]",
    "instruction": {
      "en": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nՏվեք Python կոդի համառոտ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত ন্যাচারাল ল্যাঙ্গুয়েজ বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.933559130695735",
      "bn": "0.8827651710271124",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.9530483464221162",
      "hi": "0.9109764454151166",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_max_herb_value():\n    # Test case 1: Given example in the problem statement\n    T1, M1 = 70, 3\n    herbs1 = [(71, 100), (69, 1), (1, 2)]\n    expected1 = 3\n    assert max_herb_value(T1, M1,\n                          herbs1) == expected1, f\"Test case 1 failed: expected {expected1}, got {max_herb_value(T1, M1, herbs1)}\"\n\n    # Test case 2: Multiple herbs can be picked within the time limit\n    T2, M2 = 10, 4\n    herbs2 = [(1, 10), (2, 15), (3, 20), (4, 30)]\n    expected2 = 75  # We can pick herbs with time 1, 2 and 3 to get maximum value 10 + 15 + 20\n    assert max_herb_value(T2, M2,\n                          herbs2) == expected2, f\"Test case 2 failed: expected {expected2}, got {max_herb_value(T2, M2, herbs2)}\"\n\n    # Test case 3: Only one herb can be picked due to time constraint\n    T3, M3 = 5, 3\n    herbs3 = [(5, 10), (4, 7), (6, 12)]\n    expected3 = 10  # We can only pick the first herb\n    assert max_herb_value(T3, M3,\n                          herbs3) == expected3, f\"Test case 3 failed: expected {expected3}, got {max_herb_value(T3, M3, herbs3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\ntest_max_herb_value()",
    "entry_point": "max_herb_value",
    "signature": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "Calculate the maximum total value of herbs that can be picked within a given time limit.\n\nThis function solves a variation of the 0/1 knapsack problem where the goal is to maximize\nthe total value of herbs picked without exceeding the time limit. Each herb can be picked\nat most once and has an associated time cost and value.\n\nArgs:\n- T (int): The total time available for picking herbs.\n- M (int): The number of different herbs in the cave.\n- herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\nrepresenting the time required to pick the herb and the herb's value, respectively.\n\nReturns:\n- int: The maximum total value of herbs that can be picked within the time limit.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\nto the time constraint, leading to a maximum value of 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHere, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nWith a time limit of 5, only the first herb can be picked, providing a value of 10.",
      "sq": "Llogaritni vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohe.\n\nKjo funksion zgjidh një variant të problemit të çantës 0/1 ku qëllimi është të maksimizohet\nvlera totale e bimëve të mbledhura pa tejkaluar kufirin e kohës. Çdo bimë mund të mblidhet\nmaksimumi një herë dhe ka një kosto kohe dhe vlerë të lidhur.\n\nArgumentet:\n- T (int): Koha totale e disponueshme për mbledhjen e bimëve.\n- M (int): Numri i bimëve të ndryshme në shpellë.\n- herbs (List[Tuple[int, int]]): Një listë tuplesh, ku çdo tuple përmban dy numra të plotë\nqë përfaqësojnë kohën e kërkuar për të mbledhur bimën dhe vlerën e bimës, përkatësisht.\n\nKthen:\n- int: Vlera maksimale totale e bimëve që mund të mblidhen brenda kufirit të kohës.\n\nShembuj:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nNë këtë skenar, vetëm bima që kërkon 1 njësi kohe për një vlerë prej 2 mund të mblidhet për shkak\ntë kufizimit të kohës, duke çuar në një vlerë maksimale prej 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nKëtu, strategjia më e mirë është të mblidhen bimët me kohë 1, 2 dhe 3, duke çuar në një vlerë maksimale prej 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nMe një kufi kohe prej 5, vetëm bima e parë mund të mblidhet, duke ofruar një vlerë prej 10.",
      "hy": "Հաշվարկել խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակային սահմանափակման շրջանակներում:\n\nԱյս ֆունկցիան լուծում է 0/1 պայուսակի խնդրի տարբերակը, որտեղ նպատակն է առավելագույնացնել\nհավաքված խոտաբույսերի ընդհանուր արժեքը՝ առանց ժամանակային սահմանափակումը գերազանցելու: Յուրաքանչյուր խոտաբույս կարելի է հավաքել\nառավելագույնը մեկ անգամ և ունի կապված ժամանակային արժեք և արժեք:\n\nԱրձագանքներ:\n- T (int): Ընդհանուր ժամանակը, որը հասանելի է խոտաբույսեր հավաքելու համար:\n- M (int): Այլ խոտաբույսերի քանակը քարանձավում:\n- herbs (List[Tuple[int, int]]): Կրկնակի թվերի ցուցակ, որտեղ յուրաքանչյուր կրկնակի պարունակում է երկու ամբողջ թիվ,\nորոնք ներկայացնում են խոտաբույսը հավաքելու համար պահանջվող ժամանակը և խոտաբույսի արժեքը, համապատասխանաբար:\n\nՎերադարձնում է:\n- int: Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել ժամանակային սահմանափակման շրջանակներում:\n\nՕրինակներ:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nԱյս սցենարում, միայն այն խոտաբույսը, որը պահանջում է 1 միավոր ժամանակ 2 արժեքի համար, կարելի է հավաքել\nժամանակային սահմանափակման պատճառով, ինչը հանգեցնում է առավելագույն արժեքի՝ 3:\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nԱյստեղ, լավագույն ռազմավարությունն է հավաքել այն խոտաբույսերը, որոնք ունեն 1, 2 և 3 ժամանակներ, ինչը հանգեցնում է առավելագույն արժեքի՝ 10 + 15 + 20 = 50:\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5 ժամանակային սահմանափակման դեպքում, միայն առաջին խոտաբույսը կարելի է հավաքել, ինչը ապահովում է 10 արժեք:",
      "bn": "প্রদত্ত সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক মূল্যবান ভেষজ সংগ্রহের হিসাব করুন।\n\nএই ফাংশনটি 0/1 ন্যাপকস্যাক সমস্যার একটি রূপ সমাধান করে যেখানে লক্ষ্য হল সময়সীমা অতিক্রম না করে ভেষজ সংগ্রহের মোট মূল্য সর্বাধিক করা। প্রতিটি ভেষজ সর্বাধিক একবার সংগ্রহ করা যেতে পারে এবং এর সাথে একটি নির্দিষ্ট সময় খরচ এবং মূল্য যুক্ত থাকে।\n\nArgs:\n- T (int): ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n- M (int): গুহায় বিভিন্ন ভেষজের সংখ্যা।\n- herbs (List[Tuple[int, int]]): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে দুটি পূর্ণসংখ্যা থাকে যা যথাক্রমে ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং ভেষজের মূল্য উপস্থাপন করে।\n\nReturns:\n- int: প্রদত্ত সময়সীমার মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য।\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nএই পরিস্থিতিতে, সময় সীমাবদ্ধতার কারণে শুধুমাত্র সেই ভেষজটি সংগ্রহ করা যেতে পারে যা ১ ইউনিট সময় নেয় এবং যার মূল্য ২, যা সর্বাধিক মূল্য ৩ এ পৌঁছায়।\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nএখানে, সর্বোত্তম কৌশল হল সময় ১, ২, এবং ৩ সহ ভেষজ সংগ্রহ করা, যা সর্বাধিক মূল্য ১০ + ১৫ + ২০ = ৫০ এ পৌঁছায়।\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n৫ সময়সীমার মধ্যে, শুধুমাত্র প্রথম ভেষজটি সংগ্রহ করা যেতে পারে, যা ১০ এর মূল্য প্রদান করে।",
      "bg": "Изчислете максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n\nТази функция решава вариация на проблема с раницата 0/1, където целта е да се максимизира\nобщата стойност на събраните билки, без да се превишава времевият лимит. Всяка билка може да бъде събрана\nнай-много веднъж и има свързани времеви разходи и стойност.\n\nАргументи:\n- T (int): Общото време, налично за събиране на билки.\n- M (int): Броят на различните билки в пещерата.\n- herbs (List[Tuple[int, int]]): Списък от кортежи, където всеки кортеж съдържа две цели числа,\nпредставляващи времето, необходимо за събиране на билката и стойността на билката, съответно.\n\nВръща:\n- int: Максималната обща стойност на билките, които могат да бъдат събрани в рамките на времевия лимит.\n\nПримери:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nВ този сценарий, поради времевото ограничение, може да бъде събрана само билката, която отнема 1 единица време за стойност 2,\nводещо до максимална стойност от 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nТук най-добрата стратегия е да се съберат билките с времена 1, 2 и 3, водещо до максимална стойност от 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nС времеви лимит от 5, може да бъде събрана само първата билка, предоставяща стойност от 10.",
      "zh": "计算在给定时间限制内可以采摘的草药的最大总价值。\n\n此函数解决了0/1背包问题的一个变体，其目标是在不超过时间限制的情况下最大化采摘草药的总价值。每种草药最多可以采摘一次，并且具有相关的时间成本和价值。\n\n参数：\n- T (int): 可用于采摘草药的总时间。\n- M (int): 洞穴中不同草药的数量。\n- herbs (List[Tuple[int, int]]): 一个元组列表，其中每个元组包含两个整数，分别表示采摘草药所需的时间和草药的价值。\n\n返回：\n- int: 在时间限制内可以采摘的草药的最大总价值。\n\n示例：\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n在这种情况下，由于时间限制，只能采摘需要1单位时间且价值为2的草药，从而达到最大价值3。\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n在这里，最佳策略是采摘时间为1、2和3的草药，最大价值为10 + 15 + 20 = 50。\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n在时间限制为5的情况下，只能采摘第一种草药，提供价值10。",
      "fr": "Calculer la valeur totale maximale des herbes qui peuvent être cueillies dans un délai donné.\n\nCette fonction résout une variation du problème du sac à dos 0/1 où l'objectif est de maximiser\nla valeur totale des herbes cueillies sans dépasser la limite de temps. Chaque herbe peut être cueillie\nau plus une fois et a un coût en temps et une valeur associés.\n\nArgs:\n- T (int): Le temps total disponible pour cueillir des herbes.\n- M (int): Le nombre de différentes herbes dans la grotte.\n- herbs (List[Tuple[int, int]]): Une liste de tuples, où chaque tuple contient deux entiers\nreprésentant le temps nécessaire pour cueillir l'herbe et la valeur de l'herbe, respectivement.\n\nReturns:\n- int: La valeur totale maximale des herbes qui peuvent être cueillies dans la limite de temps.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nDans ce scénario, seule l'herbe qui prend 1 unité de temps pour une valeur de 2 peut être cueillie en raison\nde la contrainte de temps, conduisant à une valeur maximale de 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nIci, la meilleure stratégie est de cueillir les herbes avec des temps de 1, 2 et 3, conduisant à une valeur maximale de 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nAvec une limite de temps de 5, seule la première herbe peut être cueillie, fournissant une valeur de 10.",
      "de": "Berechne den maximalen Gesamtwert der Kräuter, die innerhalb eines gegebenen Zeitlimits gepflückt werden können.\n\nDiese Funktion löst eine Variante des 0/1-Rucksackproblems, bei der das Ziel darin besteht, den Gesamtwert der gepflückten Kräuter zu maximieren, ohne das Zeitlimit zu überschreiten. Jedes Kraut kann höchstens einmal gepflückt werden und hat eine zugehörige Zeitkosten und einen Wert.\n\nArgs:\n- T (int): Die insgesamt verfügbare Zeit zum Pflücken der Kräuter.\n- M (int): Die Anzahl der verschiedenen Kräuter in der Höhle.\n- herbs (List[Tuple[int, int]]): Eine Liste von Tupeln, wobei jedes Tupel zwei ganze Zahlen enthält, die die zum Pflücken des Krauts erforderliche Zeit und den Wert des Krauts darstellen.\n\nReturns:\n- int: Der maximale Gesamtwert der Kräuter, die innerhalb des Zeitlimits gepflückt werden können.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn diesem Szenario kann aufgrund der Zeitbeschränkung nur das Kraut gepflückt werden, das 1 Zeiteinheit für einen Wert von 2 benötigt, was zu einem maximalen Wert von 3 führt.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHier ist die beste Strategie, die Kräuter mit den Zeiten 1, 2 und 3 zu pflücken, was zu einem maximalen Wert von 10 + 15 + 20 = 50 führt.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nMit einem Zeitlimit von 5 kann nur das erste Kraut gepflückt werden, was einen Wert von 10 liefert.",
      "ha": "Ƙididdige mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka cikin iyakar lokacin da aka bayar.\n\nWannan aikin yana warware wani bambancin matsalar 0/1 knapsack inda burin shine a haɓaka\njimillar ƙimar ganyayyaki da aka ɗauka ba tare da wuce iyakar lokaci ba. Kowanne ganye za a iya ɗauka\nsau ɗaya kawai kuma yana da alaƙa da tsadar lokaci da ƙima.\n\nArgs:\n- T (int): Jimillar lokacin da ake da shi don ɗaukar ganyayyaki.\n- M (int): Yawan nau'ikan ganyayyaki daban-daban a cikin kogon.\n- herbs (List[Tuple[int, int]]): Jerin tuples, inda kowanne tuple yana ɗauke da lambobi biyu\nyana wakiltar lokacin da ake buƙata don ɗaukar ganyen da ƙimar ganyen, bi da bi.\n\nReturns:\n- int: Mafi girman jimillar ƙimar ganyayyaki da za a iya ɗauka cikin iyakar lokacin.\n\nMisalai:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nA wannan yanayin, kawai ganyen da ke ɗaukar 1 na lokaci don ƙimar 2 za a iya ɗauka saboda\nƙuntatawar lokaci, wanda ke haifar da mafi girman ƙima na 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nA nan, mafi kyawun dabaru shine ɗaukar ganyayyaki tare da lokuta 1, 2, da 3, wanda ke haifar da mafi girman ƙima na 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nTare da iyakar lokaci na 5, kawai ganye na farko za a iya ɗauka, yana ba da ƙima na 10.",
      "hi": "दी गई समय सीमा के भीतर जितनी अधिकतम कुल जड़ी-बूटियों का मूल्य प्राप्त किया जा सकता है, उसकी गणना करें।\n\nयह फ़ंक्शन 0/1 नॅपसैक समस्या के एक प्रकार को हल करता है जहाँ लक्ष्य है कि समय सीमा को पार किए बिना चुनी गई जड़ी-बूटियों के कुल मूल्य को अधिकतम किया जाए। प्रत्येक जड़ी-बूटी को अधिकतम एक बार चुना जा सकता है और इसका एक संबंधित समय लागत और मूल्य होता है।\n\nआर्ग्स:\n- T (int): जड़ी-बूटियों को चुनने के लिए उपलब्ध कुल समय।\n- M (int): गुफा में विभिन्न जड़ी-बूटियों की संख्या।\n- herbs (List[Tuple[int, int]]): ट्यूपल्स की एक सूची, जहाँ प्रत्येक ट्यूपल में दो पूर्णांक होते हैं जो क्रमशः जड़ी-बूटी को चुनने के लिए आवश्यक समय और जड़ी-बूटी के मूल्य का प्रतिनिधित्व करते हैं।\n\nरिटर्न्स:\n- int: समय सीमा के भीतर चुनी जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\nउदाहरण:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nइस परिदृश्य में, समय सीमा के कारण केवल वह जड़ी-बूटी चुनी जा सकती है जो 1 इकाई समय में 2 का मूल्य देती है, जिससे अधिकतम मूल्य 3 होता है।\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nयहाँ, सबसे अच्छी रणनीति है कि 1, 2, और 3 समय वाली जड़ी-बूटियाँ चुनी जाएं, जिससे अधिकतम मूल्य 10 + 15 + 20 = 50 होता है।\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5 की समय सीमा के साथ, केवल पहली जड़ी-बूटी ही चुनी जा सकती है, जो 10 का मूल्य प्रदान करती है।",
      "hu": "Számítsa ki a maximális összértéket a gyógynövényeknek, amelyeket egy adott időkorláton belül lehet begyűjteni.\n\nEz a függvény megold egy változatot a 0/1 hátizsák problémára, ahol a cél a gyógynövények összértékének maximalizálása anélkül, hogy túllépnénk az időkorlátot. Minden gyógynövényt legfeljebb egyszer lehet begyűjteni, és mindegyikhez társul egy időráfordítás és érték.\n\nArgs:\n- T (int): Az összes rendelkezésre álló idő a gyógynövények begyűjtésére.\n- M (int): A barlangban található különböző gyógynövények száma.\n- herbs (List[Tuple[int, int]]): Egy lista, amelyben minden egyes elem egy pár, amely két egész számot tartalmaz, az első a gyógynövény begyűjtéséhez szükséges időt, a második pedig a gyógynövény értékét jelöli.\n\nReturns:\n- int: A maximális összérték a gyógynövényeknek, amelyeket az időkorláton belül lehet begyűjteni.\n\nPéldák:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nEbben a helyzetben csak az a gyógynövény gyűjthető be, amely 1 egységnyi időt igényel és 2 értéket ad, az időkorlát miatt, ami 3 maximális értékhez vezet.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nItt a legjobb stratégia az 1, 2 és 3 időt igénylő gyógynövények begyűjtése, ami 10 + 15 + 20 = 50 maximális értékhez vezet.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5-ös időkorláttal csak az első gyógynövény gyűjthető be, amely 10 értéket ad."
    },
    "docstring_bertscore": {
      "sq": "0.9592732239333686",
      "hy": "0.966022088389791",
      "bn": "0.9493732871122087",
      "bg": "0.963710825276069",
      "zh": "0.9612384729233278",
      "fr": "0.9852455366663475",
      "de": "0.9711036494278066",
      "ha": "0.963938257062354",
      "hi": "0.9659148279840322",
      "hu": "0.9464075368929769"
    }
  },
  {
    "task_id": "Python/38",
    "prompt": {
      "en": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      All items can be fit into the box without any remaining space.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      An optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Since all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.\n    \"\"\"",
      "sq": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Llogarit hapësirën minimale të mbetur në një kuti pasi të përpiqesh të vendosësh një numër artikujsh me vëllime të dhëna.\n    \n    Kjo funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë\n    në kuti nga çdo nëngrup i artikujve të dhënë. Pastaj kthen diferencën midis kapacitetit total të kutisë\n    dhe këtij vëllimi maksimal të zënë, që është hapësira minimale e mbetur.\n\n    Argumentet:\n    - V (int): Kapaciteti total i kutisë.\n    - n (int): Numri i artikujve për t'u konsideruar për paketim në kuti.\n    - volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\n    Kthen:\n    - int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\n    Shembuj:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Të gjithë artikujt mund të vendosen në kuti pa asnjë hapësirë të mbetur.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Një mënyrë optimale për të vendosur artikujt mund të jetë marrja e artikujve me vëllime 3, 5, dhe 3, që lë 2 njësi hapësirë.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Meqenëse të gjithë artikujt kanë një vëllim më të madh se kapaciteti i kutisë, asnjë nuk mund të vendoset dhe i gjithë kapaciteti i kutisë mbetet.\n    \"\"\"",
      "hy": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Հաշվարկել արկղում մնացած նվազագույն տարածությունը այն բանից հետո, երբ փորձում ենք տեղավորել տրված ծավալներով մի շարք իրեր:\n    \n    Այս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն ծավալը, որը կարող է զբաղեցնել\n    արկղում տրված իրերի ցանկացած ենթաբազմություն: Այնուհետև վերադարձնում է արկղի ընդհանուր տարողության և այս առավելագույն զբաղեցրած ծավալի տարբերությունը, որը նվազագույն մնացած տարածությունն է:\n\n    Արգումենտներ:\n    - V (int): Արկղի ընդհանուր տարողությունը:\n    - n (int): Իրերի քանակը, որոնք պետք է հաշվի առնել արկղում տեղավորելու համար:\n    - volumes (List[int]): n իրերի ծավալների ցուցակ:\n\n    Վերադարձնում է:\n    - int: Նվազագույն մնացած տարածությունը արկղում իրերը տեղավորելուց հետո:\n\n    Օրինակներ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Բոլոր իրերը կարող են տեղավորվել արկղում առանց որևէ մնացած տարածության:\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Իրերը տեղավորելու օպտիմալ եղանակ կարող է լինել 3, 5 և 3 ծավալներով իրերի վերցնելը, ինչը թողնում է 2 միավոր տարածություն:\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Քանի որ բոլոր իրերի ծավալը մեծ է արկղի տարողությունից, ոչ մեկը չի կարող տեղավորվել, և ամբողջ արկղի տարողությունը մնում է:\n    \"\"\"",
      "bn": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    একটি বাক্সে নির্দিষ্ট ভলিউমের কিছু আইটেম ফিট করার পর বাক্সে অবশিষ্ট ন্যূনতম স্থান গণনা করুন।\n    \n    এই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে নির্ধারণ করে যে প্রদত্ত আইটেমগুলির যেকোনো উপসেট দ্বারা বাক্সে সর্বাধিক কত ভলিউম দখল করা যেতে পারে। তারপর এটি বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত ভলিউমের মধ্যে পার্থক্য ফিরিয়ে দেয়, যা ন্যূনতম অবশিষ্ট স্থান।\n\n    আর্গুমেন্টসমূহ:\n    - V (int): বাক্সের মোট ক্ষমতা।\n    - n (int): বাক্সে প্যাক করার জন্য বিবেচনা করা আইটেমের সংখ্যা।\n    - volumes (List[int]): n আইটেমের ভলিউমের একটি তালিকা।\n\n    রিটার্নস:\n    - int: আইটেম ফিট করার পর বাক্সে অবশিষ্ট ন্যূনতম স্থান।\n\n    উদাহরণ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      সব আইটেম বাক্সে ফিট করা যায় কোনো অবশিষ্ট স্থান ছাড়াই।\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      আইটেম ফিট করার একটি সর্বোত্তম উপায় হতে পারে 3, 5, এবং 3 ভলিউমের আইটেম নেওয়া, যা 2 ইউনিট স্থান অবশিষ্ট রাখে।\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      যেহেতু সব আইটেমের ভলিউম বাক্সের ক্ষমতার চেয়ে বেশি, কোনোটি ফিট করা যায় না এবং পুরো বাক্সের ক্ষমতা অবশিষ্ট থাকে।\n    \"\"\"",
      "bg": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Изчислява минималното оставащо пространство в кутия след опит да се поберат определен брой предмети с дадени обеми.\n    \n    Тази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает\n    в кутията от всяко подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията\n    и този максимален зает обем, което е минималното оставащо пространство.\n\n    Аргументи:\n    - V (int): Общият капацитет на кутията.\n    - n (int): Броят на предметите, които да се разгледат за опаковане в кутията.\n    - volumes (List[int]): Списък с обемите на n-те предмета.\n\n    Връща:\n    - int: Минималното оставащо пространство в кутията след побирането на предметите.\n\n    Примери:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Всички предмети могат да бъдат побрани в кутията без оставащо пространство.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Оптимален начин за побиране на предметите може да бъде вземане на предмети с обеми 3, 5 и 3, което оставя 2 единици пространство.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Тъй като всички предмети имат обем по-голям от капацитета на кутията, нито един не може да бъде побран и целият капацитет на кутията остава.\n    \"\"\"",
      "zh": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    计算在尝试将若干具有给定体积的物品放入箱子后，箱子中剩余的最小空间。\n\n    此函数使用动态规划方法来确定通过给定物品的任意子集可以占据箱子的最大体积。\n    然后返回箱子总容量与此最大占用体积之间的差值，即最小剩余空间。\n\n    参数:\n    - V (int): 箱子的总容量。\n    - n (int): 考虑放入箱子的物品数量。\n    - volumes (List[int]): n个物品的体积列表。\n\n    返回:\n    - int: 放入物品后箱子中剩余的最小空间。\n\n    示例:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      所有物品可以放入箱子中，没有剩余空间。\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      放置物品的最佳方式可能是选择体积为3、5和3的物品，剩下2个单位的空间。\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      由于所有物品的体积都大于箱子容量，无法放入任何物品，整个箱子容量保持不变。\n    \"\"\"",
      "fr": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculer l'espace restant minimum dans une boîte après avoir essayé de placer un certain nombre d'articles avec des volumes donnés.\n    \n    Cette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\n    dans la boîte par n'importe quel sous-ensemble des articles donnés. Elle renvoie ensuite la différence entre la capacité totale de la boîte\n    et ce volume maximum occupé, qui est l'espace restant minimum.\n\n    Args:\n    - V (int) : La capacité totale de la boîte.\n    - n (int) : Le nombre d'articles à considérer pour le rangement dans la boîte.\n    - volumes (List[int]) : Une liste des volumes des n articles.\n\n    Returns:\n    - int : L'espace restant minimum dans la boîte après avoir rangé les articles.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Tous les articles peuvent être rangés dans la boîte sans aucun espace restant.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Une façon optimale de ranger les articles pourrait être de prendre des articles avec des volumes de 3, 5, et 3, ce qui laisse 2 unités d'espace.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Puisque tous les articles ont un volume supérieur à la capacité de la boîte, aucun ne peut être rangé et la capacité totale de la boîte reste.\n    \"\"\"",
      "de": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Berechne den minimal verbleibenden Platz in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumina unterzubringen.\n    \n    Diese Funktion verwendet einen dynamischen Programmierungsansatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Sie gibt dann die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was den minimal verbleibenden Platz darstellt.\n\n    Argumente:\n    - V (int): Die Gesamtkapazität der Box.\n    - n (int): Die Anzahl der Gegenstände, die in die Box gepackt werden sollen.\n    - volumes (List[int]): Eine Liste der Volumina der n Gegenstände.\n\n    Rückgabewert:\n    - int: Der minimal verbleibende Platz in der Box nach dem Einpassen der Gegenstände.\n\n    Beispiele:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Alle Gegenstände können ohne verbleibenden Platz in die Box passen.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Eine optimale Möglichkeit, die Gegenstände einzupassen, könnte darin bestehen, Gegenstände mit den Volumina 3, 5 und 3 zu nehmen, was 2 Einheiten Platz übrig lässt.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Da alle Gegenstände ein Volumen größer als die Boxkapazität haben, kann keiner passen und die gesamte Boxkapazität bleibt erhalten.\n    \"\"\"",
      "ha": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Lissafi mafi ƙarancin sarari da ya rage a cikin akwati bayan ƙoƙarin sanya adadin abubuwa tare da girma da aka bayar.\n\n    Wannan aikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade mafi girman girman da za a iya mamaye\n    a cikin akwatin ta kowace ƙungiya ta abubuwan da aka bayar. Sannan yana dawo da bambanci tsakanin jimlar ƙarfin akwatin\n    da wannan mafi girman girman da aka mamaye, wanda shine mafi ƙarancin sarari da ya rage.\n\n    Args:\n    - V (int): Jimlar ƙarfin akwatin.\n    - n (int): Adadin abubuwan da za a yi la'akari da su don cika cikin akwatin.\n    - volumes (List[int]): Jerin girman abubuwan n.\n\n    Returns:\n    - int: Mafi ƙarancin sarari da ya rage a cikin akwatin bayan cika abubuwan.\n\n    Misalai:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Duk abubuwan za a iya cika su cikin akwatin ba tare da wani sarari da ya rage ba.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Hanya mafi kyau don cika abubuwan na iya zama ɗaukar abubuwa tare da girma 3, 5, da 3, wanda ke barin sarari guda 2.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Tun da duk abubuwan suna da girma fiye da ƙarfin akwatin, babu wanda za a iya cika kuma duka ƙarfin akwatin ya rage.\n    \"\"\"",
      "hi": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    दिए गए वॉल्यूम वाले वस्तुओं की संख्या को फिट करने की कोशिश करने के बाद बॉक्स में न्यूनतम शेष स्थान की गणना करें।\n\n    यह फ़ंक्शन एक डायनामिक प्रोग्रामिंग दृष्टिकोण का उपयोग करता है ताकि यह निर्धारित किया जा सके कि दिए गए वस्तुओं के किसी भी उपसमूह द्वारा बॉक्स में अधिकतम वॉल्यूम कितना भरा जा सकता है। \n    फिर यह बॉक्स की कुल क्षमता और इस अधिकतम भरे हुए वॉल्यूम के बीच का अंतर लौटाता है, जो न्यूनतम शेष स्थान है।\n\n    तर्क:\n    - V (int): बॉक्स की कुल क्षमता।\n    - n (int): बॉक्स में पैक करने के लिए विचार करने वाली वस्तुओं की संख्या।\n    - volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\n    रिटर्न्स:\n    - int: वस्तुओं को फिट करने के बाद बॉक्स में न्यूनतम शेष स्थान।\n\n    उदाहरण:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      सभी वस्तुएं बिना किसी शेष स्थान के बॉक्स में फिट हो सकती हैं।\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      वस्तुओं को फिट करने का एक आदर्श तरीका हो सकता है वॉल्यूम 3, 5, और 3 वाली वस्तुओं को लेना, जिससे 2 इकाई स्थान बचता है।\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      चूंकि सभी वस्तुओं का वॉल्यूम बॉक्स की क्षमता से अधिक है, कोई भी फिट नहीं हो सकता और पूरी बॉक्स क्षमता शेष रहती है।\n    \"\"\"",
      "hu": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Számítsa ki a minimális megmaradó helyet egy dobozban, miután megpróbálja elhelyezni a megadott térfogatú tárgyakat.\n    \n    Ez a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a megadott tárgyak bármely részhalmazával\n    mekkora maximális térfogat foglalható el a dobozban. Ezután visszaadja a doboz teljes kapacitása és a maximálisan elfoglalt térfogat\n    közötti különbséget, ami a minimális megmaradó hely.\n\n    Paraméterek:\n    - V (int): A doboz teljes kapacitása.\n    - n (int): A dobozba csomagolni kívánt tárgyak száma.\n    - volumes (List[int]): Az n tárgy térfogatainak listája.\n\n    Visszatérési érték:\n    - int: A minimális megmaradó hely a dobozban a tárgyak elhelyezése után.\n\n    Példák:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Minden tárgy elhelyezhető a dobozban maradék hely nélkül.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Az optimális elhelyezés lehet a 3, 5 és 3 térfogatú tárgyak kiválasztása, ami 2 egységnyi helyet hagy.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Mivel minden tárgy térfogata nagyobb, mint a doboz kapacitása, egyik sem helyezhető el, így a teljes doboz kapacitása megmarad.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.974197913503568",
      "hy": "0.9705244432367088",
      "bn": "0.9601116427717169",
      "bg": "0.9820243477771047",
      "zh": "0.9454135904662783",
      "fr": "0.9717883283512337",
      "de": "0.9816427788151366",
      "ha": "0.9467086605506257",
      "hi": "0.9573097626168388",
      "hu": "0.9478499907200522"
    },
    "canonical_solution": "    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]",
    "instruction": {
      "en": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nՏրամադրել համառոտ բնական լեզվով նկարագրություն (docstring) այս Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548376088944786",
      "hy": "0.9164818836862606",
      "bn": "0.8827651710271124",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.9371692378710441",
      "ha": "0.9104673557485241",
      "hi": "0.8964889413135749",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_min_remaining_space():\n    # Test case 1: Sample provided in the problem statement where all items can fit perfectly\n    V1, n1 = 24, 6\n    volumes1 = [8, 3, 12, 7, 9, 7]\n    expected1 = 0\n    assert min_remaining_space(V1, n1,\n                               volumes1) == expected1, f\"Test case 1 failed: expected {expected1}, got {min_remaining_space(V1, n1, volumes1)}\"\n\n    # Test case 2: Some space is expected to remain in the box\n    V2, n2 = 10, 4\n    volumes2 = [3, 5, 3, 2]\n    expected2 = 0  # Possible packing: 3, 5, and 3, leaves 2 units of space\n    assert min_remaining_space(V2, n2,\n                               volumes2) == expected2, f\"Test case 2 failed: expected {expected2}, got {min_remaining_space(V2, n2, volumes2)}\"\n\n    # Test case 3: No items can fit due to the items being larger than the box capacity\n    V3, n3 = 5, 3\n    volumes3 = [6, 7, 8]\n    expected3 = 5  # No items fit, so all 5 units of space remain\n    assert min_remaining_space(V3, n3,\n                               volumes3) == expected3, f\"Test case 3 failed: expected {expected3}, got {min_remaining_space(V3, n3, volumes3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_min_remaining_space()",
    "entry_point": "min_remaining_space",
    "signature": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:",
    "docstring": {
      "en": "Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n\nThis function uses a dynamic programming approach to determine the maximum volume that can be occupied\nin the box by any subset of the given items. It then returns the difference between the box's total capacity\nand this maximum occupied volume, which is the minimum remaining space.\n\nArgs:\n- V (int): The total capacity of the box.\n- n (int): The number of items to consider for packing into the box.\n- volumes (List[int]): A list of the volumes of the n items.\n\nReturns:\n- int: The minimum remaining space in the box after fitting the items.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAll items can be fit into the box without any remaining space.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAn optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nSince all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.",
      "sq": "Llogarit hapësirën minimale të mbetur në një kuti pas përpjekjes për të vendosur një numër artikujsh me vëllime të dhëna.\n\nKjo funksion përdor një qasje të programimit dinamik për të përcaktuar vëllimin maksimal që mund të zërë në kuti nga çdo nën-grup i artikujve të dhënë. Pastaj kthen diferencën midis kapacitetit total të kutisë dhe këtij vëllimi maksimal të zënë, që është hapësira minimale e mbetur.\n\nArgumentet:\n- V (int): Kapaciteti total i kutisë.\n- n (int): Numri i artikujve për t'u konsideruar për paketim në kuti.\n- volumes (List[int]): Një listë e vëllimeve të n artikujve.\n\nKthen:\n- int: Hapësira minimale e mbetur në kuti pas vendosjes së artikujve.\n\nShembuj:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTë gjithë artikujt mund të vendosen në kuti pa asnjë hapësirë të mbetur.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nNjë mënyrë optimale për të vendosur artikujt mund të jetë marrja e artikujve me vëllime 3, 5, dhe 3, që lë 2 njësi hapësirë.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nMeqenëse të gjithë artikujt kanë një vëllim më të madh se kapaciteti i kutisë, asnjëri nuk mund të vendoset dhe i gjithë kapaciteti i kutisë mbetet.",
      "hy": "Հաշվել տուփում մնացած նվազագույն տարածքը այն բանից հետո, երբ փորձ է արվում տեղավորել որոշակի ծավալներով իրերի քանակը:\n\nԱյս ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն ծավալը, որը կարող է զբաղեցվել տուփում տրված իրերի ցանկացած ենթաբազմությամբ: Այնուհետև վերադարձնում է տուփի ընդհանուր տարողության և այս առավելագույն զբաղեցված ծավալի տարբերությունը, որը նվազագույն մնացած տարածքն է:\n\nԱրձագանքներ:\n- V (int): Տուփի ընդհանուր տարողությունը:\n- n (int): Տուփի մեջ տեղավորելու համար հաշվի առնվող իրերի քանակը:\n- volumes (List[int]): n իրերի ծավալների ցուցակը:\n\nՎերադարձնում է:\n- int: Տուփում մնացած նվազագույն տարածքը իրերը տեղավորելուց հետո:\n\nՕրինակներ:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nԲոլոր իրերը կարող են տեղավորվել տուփում առանց մնացած տարածքի:\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nԻրերը տեղավորելու օպտիմալ եղանակ կարող է լինել 3, 5 և 3 ծավալներով իրերը վերցնելը, որը թողնում է 2 միավոր տարածք:\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nՔանի որ բոլոր իրերի ծավալը մեծ է տուփի տարողությունից, ոչ մեկը չի կարող տեղավորվել, և ամբողջ տուփի տարողությունը մնում է:",
      "bn": "বাক্সে নির্দিষ্ট ভলিউমের কিছু আইটেম ফিট করার পরে বাক্সে ন্যূনতম অবশিষ্ট স্থান গণনা করুন।\n\nএই ফাংশনটি একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে নির্ধারণ করে যে প্রদত্ত আইটেমগুলির যেকোনো উপসেট দ্বারা বাক্সে সর্বাধিক কত ভলিউম দখল করা যেতে পারে। তারপর এটি বাক্সের মোট ক্ষমতা এবং এই সর্বাধিক দখলকৃত ভলিউমের মধ্যে পার্থক্য প্রদান করে, যা ন্যূনতম অবশিষ্ট স্থান।\n\nArgs:\n- V (int): বাক্সের মোট ক্ষমতা।\n- n (int): বাক্সে প্যাক করার জন্য বিবেচিত আইটেমের সংখ্যা।\n- volumes (List[int]): n আইটেমের ভলিউমের একটি তালিকা।\n\nReturns:\n- int: আইটেমগুলি ফিট করার পরে বাক্সে ন্যূনতম অবশিষ্ট স্থান।\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nসব আইটেম বাক্সে ফিট করা যায় কোনো অবশিষ্ট স্থান ছাড়াই।\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nআইটেমগুলি ফিট করার একটি সর্বোত্তম উপায় হতে পারে ভলিউম 3, 5, এবং 3 সহ আইটেমগুলি নেওয়া, যা 2 ইউনিট স্থান অবশিষ্ট রাখে।\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nযেহেতু সব আইটেমের ভলিউম বাক্সের ক্ষমতার চেয়ে বেশি, তাই কোনোটি ফিট করা যায় না এবং পুরো বাক্সের ক্ষমতা অবশিষ্ট থাকে।",
      "bg": "Изчислете минималното оставащо пространство в кутия след опит за поставяне на определен брой предмети с дадени обеми.\n\nТази функция използва подход на динамично програмиране, за да определи максималния обем, който може да бъде зает в кутията от всяко подмножество на дадените предмети. След това връща разликата между общия капацитет на кутията и този максимален зает обем, което е минималното оставащо пространство.\n\nАргументи:\n- V (int): Общият капацитет на кутията.\n- n (int): Броят на предметите, които да се разгледат за опаковане в кутията.\n- volumes (List[int]): Списък с обемите на n-те предмета.\n\nВръща:\n- int: Минималното оставащо пространство в кутията след поставяне на предметите.\n\nПримери:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nВсички предмети могат да бъдат поставени в кутията без оставащо пространство.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nОптимален начин за поставяне на предметите може да бъде вземането на предмети с обеми 3, 5 и 3, което оставя 2 единици пространство.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nТъй като всички предмети имат обем, по-голям от капацитета на кутията, нито един не може да бъде поставен и целият капацитет на кутията остава.",
      "zh": "计算在尝试将若干具有给定体积的物品放入一个箱子后，箱子内的最小剩余空间。\n\n此函数使用动态规划方法来确定给定物品的任何子集在箱子中可以占据的最大体积。然后返回箱子的总容量与此最大占用体积之间的差值，即最小剩余空间。\n\n参数：\n- V (int): 箱子的总容量。\n- n (int): 要考虑放入箱子的物品数量。\n- volumes (List[int]): n个物品的体积列表。\n\n返回：\n- int: 在放入物品后箱子内的最小剩余空间。\n\n示例：\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n所有物品可以放入箱子中，没有剩余空间。\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n一种优化的放置方式可以是选择体积为3、5和3的物品，这样会剩下2个单位的空间。\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\n由于所有物品的体积都大于箱子的容量，因此无法放入任何物品，整个箱子容量保持不变。",
      "fr": "Calculer l'espace restant minimum dans une boîte après avoir essayé d'y placer un certain nombre d'articles avec des volumes donnés.\n\nCette fonction utilise une approche de programmation dynamique pour déterminer le volume maximum qui peut être occupé\ndans la boîte par n'importe quel sous-ensemble des articles donnés. Elle retourne ensuite la différence entre la capacité totale de la boîte\net ce volume maximum occupé, qui est l'espace restant minimum.\n\nArgs:\n- V (int): La capacité totale de la boîte.\n- n (int): Le nombre d'articles à considérer pour le rangement dans la boîte.\n- volumes (List[int]): Une liste des volumes des n articles.\n\nReturns:\n- int: L'espace restant minimum dans la boîte après avoir rangé les articles.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTous les articles peuvent être rangés dans la boîte sans aucun espace restant.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nUne façon optimale de ranger les articles pourrait être de prendre les articles avec des volumes de 3, 5 et 3, ce qui laisse 2 unités d'espace.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nPuisque tous les articles ont un volume supérieur à la capacité de la boîte, aucun ne peut être rangé et la capacité totale de la boîte reste.",
      "de": "Berechne den minimal verbleibenden Platz in einer Box, nachdem versucht wurde, eine Anzahl von Gegenständen mit gegebenen Volumen unterzubringen.\n\nDiese Funktion verwendet einen dynamischen Programmierungsansatz, um das maximale Volumen zu bestimmen, das durch eine beliebige Teilmenge der gegebenen Gegenstände in der Box belegt werden kann. Sie gibt dann die Differenz zwischen der Gesamtkapazität der Box und diesem maximal belegten Volumen zurück, was den minimal verbleibenden Platz darstellt.\n\nArgs:\n- V (int): Die Gesamtkapazität der Box.\n- n (int): Die Anzahl der Gegenstände, die in die Box gepackt werden sollen.\n- volumes (List[int]): Eine Liste der Volumen der n Gegenstände.\n\nReturns:\n- int: Der minimal verbleibende Platz in der Box, nachdem die Gegenstände untergebracht wurden.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAlle Gegenstände können ohne verbleibenden Platz in die Box gepackt werden.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nEine optimale Möglichkeit, die Gegenstände zu packen, könnte darin bestehen, Gegenstände mit den Volumen 3, 5 und 3 zu nehmen, was 2 Einheiten Platz übrig lässt.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nDa alle Gegenstände ein Volumen größer als die Boxkapazität haben, kann keiner untergebracht werden und die gesamte Boxkapazität bleibt erhalten.",
      "ha": "Lissafi mafi ƙarancin sarari da ya rage a cikin akwati bayan ƙoƙarin sanya adadin abubuwa tare da girma da aka bayar.\n\nWannan aikin yana amfani da hanyar shirye-shiryen motsi don tantance mafi girman girma da za a iya cika\na cikin akwatin ta kowace rukuni na abubuwan da aka bayar. Sannan yana dawowa da bambanci tsakanin jimlar damar akwatin\nda wannan mafi girman girma da aka cika, wanda shine mafi karancin sarari da ya rage.\n\nArgs:\n- V (int): Jimlar damar akwatin.\n- n (int): Yawan abubuwan da za a yi la'akari da su don cika cikin akwatin.\n- volumes (List[int]): Jerin girman abubuwan n.\n\nReturns:\n- int: Mafi karancin sarari da ya rage a cikin akwatin bayan cika abubuwan.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nDukkan abubuwan na iya shiga cikin akwatin ba tare da wani sarari da ya rage ba.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nHanya mafi kyau don cika abubuwan na iya zama daukar abubuwa da girman 3, 5, da 3, wanda ke barin sarari na raka'a 2.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nTun da duk abubuwan suna da girma fiye da damar akwatin, babu wanda zai iya shiga kuma dukkan damar akwatin ta rage.",
      "hi": "बॉक्स में दिए गए वॉल्यूम वाले वस्तुओं की संख्या को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह की गणना करें।\n\nयह फ़ंक्शन बॉक्स में दिए गए वस्तुओं के किसी भी उपसमूह द्वारा अधिकतम वॉल्यूम को निर्धारित करने के लिए एक डायनामिक प्रोग्रामिंग दृष्टिकोण का उपयोग करता है। फिर यह बॉक्स की कुल क्षमता और इस अधिकतम भरे हुए वॉल्यूम के बीच के अंतर को लौटाता है, जो कि बची हुई न्यूनतम जगह है।\n\nआर्ग्स:\n- V (int): बॉक्स की कुल क्षमता।\n- n (int): बॉक्स में पैक करने के लिए विचार की जाने वाली वस्तुओं की संख्या।\n- volumes (List[int]): n वस्तुओं के वॉल्यूम की सूची।\n\nरिटर्न्स:\n- int: वस्तुओं को फिट करने के बाद बॉक्स में बची हुई न्यूनतम जगह।\n\nउदाहरण:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nसभी वस्तुओं को बिना किसी बची हुई जगह के बॉक्स में फिट किया जा सकता है।\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nवस्तुओं को फिट करने का एक आदर्श तरीका हो सकता है 3, 5, और 3 वॉल्यूम वाली वस्तुओं को लेना, जिससे 2 यूनिट जगह बचती है।\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nचूंकि सभी वस्तुओं का वॉल्यूम बॉक्स की क्षमता से अधिक है, कोई भी फिट नहीं हो सकता और पूरी बॉक्स क्षमता बची रहती है।",
      "hu": "Számítsa ki a minimális megmaradó helyet egy dobozban, miután megpróbált elhelyezni egy adott számú tárgyat adott térfogatokkal.\n\nEz a függvény dinamikus programozási megközelítést alkalmaz annak meghatározására, hogy a megadott tárgyak bármely részhalmaza által a dobozban elfoglalt maximális térfogat mekkora lehet. Ezután visszaadja a doboz teljes kapacitása és az elfoglalt maximális térfogat közötti különbséget, ami a minimális megmaradó hely.\n\nArgs:\n- V (int): A doboz teljes kapacitása.\n- n (int): A figyelembe veendő tárgyak száma a dobozba való csomagoláshoz.\n- volumes (List[int]): Az n tárgy térfogatainak listája.\n\nReturns:\n- int: A minimális megmaradó hely a dobozban a tárgyak elhelyezése után.\n\nPéldák:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nMinden tárgy elfér a dobozban anélkül, hogy bármilyen megmaradó hely maradna.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAz optimális elhelyezés lehet, ha a 3, 5 és 3 térfogatú tárgyakat választjuk, ami 2 egységnyi helyet hagy.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nMivel minden tárgy térfogata nagyobb, mint a doboz kapacitása, egyik sem fér el, és a teljes dobozkapacitás megmarad."
    },
    "docstring_bertscore": {
      "sq": "0.9749171541132954",
      "hy": "0.9701754496572305",
      "bn": "0.9523386400706786",
      "bg": "0.9695420173721102",
      "zh": "0.9413494142399234",
      "fr": "0.9628829338479156",
      "de": "0.9666302946165198",
      "ha": "0.9756431481559779",
      "hi": "0.9489355057524078",
      "hu": "0.9653495259196069"
    }
  },
  {
    "task_id": "Python/39",
    "prompt": {
      "en": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n      There are two possible arrangements for 4 pots using two types of flowers with\n      at most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n      There are six ways to arrange 3 pots using three types of flowers when the\n      maximum pots are 1, 2, and 3 for the first, second, and third types respectively.\n    \"\"\"",
      "sq": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Llogarit numrin e mënyrave për të rregulluar m vazo me lule duke përdorur deri në n lloje,\n    ku lloji i-të mund të ketë më së shumti a[i] vazo, dhe rregullimi duhet të jetë në\n    rend rritës të llojeve të luleve.\n\n    Argumentet:\n    - n (int): Numri i llojeve të luleve të disponueshme.\n    - m (int): Numri total i vazove me lule për t'u rregulluar.\n    - a (listë e int): Një listë ku a[i] është numri maksimal i vazove për llojin i-të të luleve.\n\n    Kthen:\n    - int: Numri i rregullimeve të dallueshme modulo (10^6 + 7).\n\n    Shembuj:\n    - calculate_arrangements(2, 4, [3, 2]) kthen 2.\n      Ka dy rregullime të mundshme për 4 vazo duke përdorur dy lloje lulesh me\n      më së shumti 3 të llojit të parë dhe 2 të llojit të dytë: [1, 1, 2, 2] dhe [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) kthen 6.\n      Ka gjashtë mënyra për të rregulluar 3 vazo duke përdorur tre lloje lulesh kur\n      maksimumi i vazove është 1, 2, dhe 3 për llojin e parë, të dytë, dhe të tretë respektivisht.\n    \"\"\"",
      "hy": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Հաշվել, թե քանի եղանակով կարելի է դասավորել m ծաղկամաններ՝ օգտագործելով մինչև n տեսակներ,\n    որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] ծաղկաման, և դասավորությունը պետք է լինի\n    ծաղիկների տեսակների աճման կարգով:\n\n    Արգումենտներ:\n    - n (int): Առկա ծաղիկների տեսակների քանակը:\n    - m (int): Դասավորելու ընդհանուր ծաղկամանների քանակը:\n    - a (list of int): Ցուցակ, որտեղ a[i]-ն i-րդ տեսակի ծաղիկների առավելագույն ծաղկամանների քանակն է:\n\n    Վերադարձնում է:\n    - int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\n    Օրինակներ:\n    - calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\n      Կան երկու հնարավոր դասավորություններ 4 ծաղկամանների համար՝ օգտագործելով երկու տեսակի ծաղիկներ՝\n      առավելագույնը 3 առաջին տեսակից և 2 երկրորդ տեսակից: [1, 1, 2, 2] և [1, 2, 2, 2]:\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:\n      Կան վեց եղանակներ դասավորելու 3 ծաղկաման՝ օգտագործելով երեք տեսակի ծաղիկներ, երբ\n      առավելագույն ծաղկամանների քանակները 1, 2 և 3 են առաջին, երկրորդ և երրորդ տեսակների համար համապատասխանաբար.\n    \"\"\"",
      "bn": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    m টি ফুলের টব n প্রকারের ফুল ব্যবহার করে সাজানোর উপায়ের সংখ্যা গণনা করুন,\n    যেখানে i তম প্রকারের ফুলের সর্বাধিক a[i] টব থাকতে পারে, এবং সাজানো\n    অবশ্যই ফুলের প্রকারের ক্রমবর্ধমান ক্রমে হতে হবে।\n\n    আর্গুমেন্টসমূহ:\n    - n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n    - m (int): সাজানোর জন্য মোট ফুলের টবের সংখ্যা।\n    - a (list of int): একটি তালিকা যেখানে a[i] হল i তম প্রকারের ফুলের জন্য সর্বাধিক টবের সংখ্যা।\n\n    রিটার্নস:\n    - int: ভিন্ন ভিন্ন সাজানোর সংখ্যা মডুলো (10^6 + 7)।\n\n    উদাহরণ:\n    - calculate_arrangements(2, 4, [3, 2]) 2 রিটার্ন করে।\n      দুটি সম্ভবপর সাজানো রয়েছে 4 টবের জন্য দুটি প্রকারের ফুল ব্যবহার করে\n      যেখানে প্রথম প্রকারের সর্বাধিক 3 এবং দ্বিতীয় প্রকারের সর্বাধিক 2: [1, 1, 2, 2] এবং [1, 2, 2, 2]।\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 রিটার্ন করে।\n      3 টব সাজানোর ছয়টি উপায় রয়েছে তিন প্রকারের ফুল ব্যবহার করে যখন\n      সর্বাধিক টবের সংখ্যা প্রথম, দ্বিতীয় এবং তৃতীয় প্রকারের জন্য যথাক্রমে 1, 2, এবং 3।\n    \"\"\"",
      "bg": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Изчислете броя на начините за подреждане на m саксии с цветя, използвайки до n типа,\n    където i-тият тип може да има най-много a[i] саксии, и подреждането трябва да бъде в\n    нарастващ ред на типовете цветя.\n\n    Аргументи:\n    - n (int): Броят на наличните типове цветя.\n    - m (int): Общият брой саксии с цветя за подреждане.\n    - a (списък от int): Списък, където a[i] е максималният брой саксии за i-тия тип цветя.\n\n    Връща:\n    - int: Броят на различните подреждания по модул (10^6 + 7).\n\n    Примери:\n    - calculate_arrangements(2, 4, [3, 2]) връща 2.\n      Има два възможни подреждания за 4 саксии, използвайки два типа цветя с\n      най-много 3 от първия тип и 2 от втория тип: [1, 1, 2, 2] и [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) връща 6.\n      Има шест начина за подреждане на 3 саксии, използвайки три типа цветя, когато\n      максималният брой саксии е 1, 2 и 3 за първия, втория и третия тип съответно.\n    \"\"\"",
      "zh": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    计算使用最多 n 种类型来安排 m 个花盆的方法数，\n    其中第 i 种类型最多可以有 a[i] 个花盆，并且排列必须按花的类型递增顺序。\n\n    参数:\n    - n (int): 可用的花的种类数。\n    - m (int): 要安排的花盆总数。\n    - a (list of int): 一个列表，其中 a[i] 是第 i 种花的最大花盆数。\n\n    返回:\n    - int: 不同排列的数量，模 (10^6 + 7)。\n\n    示例:\n    - calculate_arrangements(2, 4, [3, 2]) 返回 2。\n      使用两种类型的花来安排 4 个花盆的两种可能排列是\n      最多 3 个第一种类型和 2 个第二种类型：[1, 1, 2, 2] 和 [1, 2, 2, 2]。\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。\n      使用三种类型的花来安排 3 个花盆的六种方法是\n      当最大花盆数分别为 1、2 和 3 时，第一、第二和第三种类型。\n    \"\"\"",
      "fr": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Calculer le nombre de façons d'arranger m pots de fleurs en utilisant jusqu'à n types,\n    où le i-ème type peut avoir au plus a[i] pots, et l'arrangement doit être dans\n    l'ordre croissant des types de fleurs.\n\n    Args:\n    - n (int): Le nombre de types de fleurs disponibles.\n    - m (int): Le nombre total de pots de fleurs à arranger.\n    - a (list of int): Une liste où a[i] est le nombre maximum de pots pour le i-ème type de fleur.\n\n    Returns:\n    - int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\n    Exemples:\n    - calculate_arrangements(2, 4, [3, 2]) retourne 2.\n      Il y a deux arrangements possibles pour 4 pots en utilisant deux types de fleurs avec\n      au plus 3 du premier type et 2 du second type : [1, 1, 2, 2] et [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) retourne 6.\n      Il y a six façons d'arranger 3 pots en utilisant trois types de fleurs lorsque les\n      pots maximums sont 1, 2 et 3 pour les premier, deuxième et troisième types respectivement.\n    \"\"\"",
      "de": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Berechne die Anzahl der Möglichkeiten, m Blumentöpfe unter Verwendung von bis zu n Typen anzuordnen,\n    wobei der i-te Typ höchstens a[i] Töpfe haben kann und die Anordnung in\n    aufsteigender Reihenfolge der Blumentypen erfolgen muss.\n\n    Argumente:\n    - n (int): Die Anzahl der verfügbaren Blumentypen.\n    - m (int): Die Gesamtanzahl der anzuordnenden Blumentöpfe.\n    - a (Liste von int): Eine Liste, wobei a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\n    Rückgabewert:\n    - int: Die Anzahl der unterschiedlichen Anordnungen modulo (10^6 + 7).\n\n    Beispiele:\n    - calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\n      Es gibt zwei mögliche Anordnungen für 4 Töpfe unter Verwendung von zwei Blumentypen mit\n      höchstens 3 vom ersten Typ und 2 vom zweiten Typ: [1, 1, 2, 2] und [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.\n      Es gibt sechs Möglichkeiten, 3 Töpfe unter Verwendung von drei Blumentypen anzuordnen, wenn die\n      maximalen Töpfe 1, 2 und 3 für den ersten, zweiten und dritten Typ sind.\n    \"\"\"",
      "ha": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Lissafa yawan hanyoyin da za a iya tsara tukwane m na furanni ta amfani da nau'ikan n,\n    inda nau'in na i zai iya samun a[i] tukwane, kuma tsarin dole ne ya kasance a cikin\n    tsari mai ƙaruwa na nau'ikan furanni.\n\n    Args:\n    - n (int): Yawan nau'ikan furanni da ake da su.\n    - m (int): Jimillar adadin tukwane na furanni da za a tsara.\n    - a (jerin int): Jerin inda a[i] shine mafi yawan tukwane don nau'in furanni na i.\n\n    Returns:\n    - int: Yawan tsare-tsaren daban-daban modulo (10^6 + 7).\n\n    Misalai:\n    - calculate_arrangements(2, 4, [3, 2]) yana dawowa 2.\n      Akwai hanyoyi biyu masu yiwuwa don tsara tukwane 4 ta amfani da nau'ikan furanni biyu tare da\n      akalla 3 na nau'in farko da 2 na nau'in na biyu: [1, 1, 2, 2] da [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) yana dawowa 6.\n      Akwai hanyoyi shida don tsara tukwane 3 ta amfani da nau'ikan furanni uku lokacin da\n      mafi yawan tukwane su ne 1, 2, da 3 don nau'in farko, na biyu, da na uku bi da bi.\n    \"\"\"",
      "hi": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    m गमलों के फूलों को n प्रकारों तक का उपयोग करके सजाने के तरीकों की संख्या की गणना करें,\n    जहाँ ith प्रकार में अधिकतम a[i] गमले हो सकते हैं, और व्यवस्था फूलों के प्रकारों के\n    बढ़ते क्रम में होनी चाहिए।\n\n    तर्क:\n    - n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n    - m (int): सजाने के लिए कुल गमलों की संख्या।\n    - a (list of int): एक सूची जहाँ a[i] ith प्रकार के फूल के लिए अधिकतम गमलों की संख्या है।\n\n    लौटाता है:\n    - int: विशिष्ट व्यवस्थाओं की संख्या (10^6 + 7) के मापांक के रूप में।\n\n    उदाहरण:\n    - calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\n      दो प्रकार के फूलों का उपयोग करके 4 गमलों के लिए दो संभावित व्यवस्थाएँ हैं\n      जहाँ पहले प्रकार के अधिकतम 3 और दूसरे प्रकार के अधिकतम 2 गमले हो सकते हैं: [1, 1, 2, 2] और [1, 2, 2, 2]।\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।\n      तीन प्रकार के फूलों का उपयोग करके 3 गमलों को सजाने के छह तरीके हैं जब\n      पहले, दूसरे और तीसरे प्रकार के लिए अधिकतम गमले 1, 2, और 3 हैं।\n    \"\"\"",
      "hu": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Számítsa ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus\n    felhasználásával, ahol az i-edik típusból legfeljebb a[i] cserép lehet, és az\n    elrendezésnek növekvő sorrendben kell lennie a virágtípusok szerint.\n\n    Argumentumok:\n    - n (int): A rendelkezésre álló virágtípusok száma.\n    - m (int): Az elrendezendő virágcserepek teljes száma.\n    - a (list of int): Egy lista, ahol a[i] az i-edik virágtípushoz tartozó maximális cserépszám.\n\n    Visszatér:\n    - int: A különböző elrendezések száma modulo (10^6 + 7).\n\n    Példák:\n    - calculate_arrangements(2, 4, [3, 2]) visszaadja 2.\n      Két lehetséges elrendezés van 4 cseréphez két virágtípus felhasználásával,\n      legfeljebb 3 az első típusból és 2 a második típusból: [1, 1, 2, 2] és [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) visszaadja 6.\n      Hatféleképpen lehet elrendezni 3 cserepet három virágtípus felhasználásával, amikor a\n      maximális cserépszámok 1, 2 és 3 az első, második és harmadik típushoz.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9752506545230529",
      "hy": "0.9266672523649676",
      "bn": "0.9405417831106355",
      "bg": "0.9753207710475582",
      "zh": "0.9590330798026974",
      "fr": "0.9839882063543967",
      "de": "0.9651814846172514",
      "ha": "0.9614716649906627",
      "hi": "0.9521243178895419",
      "hu": "0.9420114492999127"
    },
    "canonical_solution": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]",
    "instruction": {
      "en": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nBada takaitaccen bayanin harshen dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8653907729676097",
      "bn": "0.8827651710271124",
      "bg": "0.8983697723915943",
      "zh": "0.8886474111310796",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9530483464221162",
      "hi": "0.9332389385215069",
      "hu": "0.9317666901372762"
    },
    "level": "",
    "test": "def test_calculate_arrangements():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_calculate_arrangements()",
    "entry_point": "calculate_arrangements",
    "signature": "def calculate_arrangements(n, m, a) -> int:",
    "docstring": {
      "en": "Compute the number of ways to arrange m pots of flowers using up to n types,\nwhere the ith type can have at most a[i] pots, and the arrangement must be in\nincreasing order of flower types.\n\nArgs:\n- n (int): The number of flower types available.\n- m (int): The total number of flower pots to arrange.\n- a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\nReturns:\n- int: The number of distinct arrangements modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nThere are two possible arrangements for 4 pots using two types of flowers with\nat most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nThere are six ways to arrange 3 pots using three types of flowers when the\nmaximum pots are 1, 2, and 3 for the first, second, and third types respectively.",
      "sq": "Llogarit numrin e mënyrave për të rregulluar m vazo me lule duke përdorur deri në n lloje,\nku lloji i-të mund të ketë më së shumti a[i] vazo, dhe rregullimi duhet të jetë në\nrend rritës të llojeve të luleve.\n\nArgumentet:\n- n (int): Numri i llojeve të luleve në dispozicion.\n- m (int): Numri total i vazove të luleve për t'u rregulluar.\n- a (listë e int): Një listë ku a[i] është numri maksimal i vazove për llojin e i-të të luleve.\n\nKthen:\n- int: Numri i rregullimeve të dallueshme modulo (10^6 + 7).\n\nShembuj:\n- calculate_arrangements(2, 4, [3, 2]) kthen 2.\nEkzistojnë dy rregullime të mundshme për 4 vazo duke përdorur dy lloje lulesh me\nmë së shumti 3 të llojit të parë dhe 2 të llojit të dytë: [1, 1, 2, 2] dhe [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) kthen 6.\nEkzistojnë gjashtë mënyra për të rregulluar 3 vazo duke përdorur tre lloje lulesh kur\nnumri maksimal i vazove është 1, 2, dhe 3 për llojin e parë, të dytë, dhe të tretë përkatësisht.",
      "hy": "Հաշվել, թե քանի ձևով կարելի է դասավորել m ծաղկամաններ՝ օգտագործելով մինչև n տեսակներ, որտեղ i-րդ տեսակը կարող է ունենալ առավելագույնը a[i] ծաղկաման, և դասավորությունը պետք է լինի ծաղիկների տեսակների աճման կարգով:\n\nԱրձանագրություններ:\n- n (int): Առկա ծաղիկների տեսակների քանակը:\n- m (int): Դասավորելու ընդհանուր ծաղկամանների քանակը:\n- a (list of int): Ցուցակ, որտեղ a[i]-ն i-րդ տեսակի ծաղիկների առավելագույն ծաղկամանների քանակն է:\n\nՎերադարձնում է:\n- int: Տարբեր դասավորությունների քանակը մոդուլո (10^6 + 7):\n\nՕրինակներ:\n- calculate_arrangements(2, 4, [3, 2]) վերադարձնում է 2:\nԿան երկու հնարավոր դասավորություններ 4 ծաղկամանների համար՝ օգտագործելով երկու տեսակի ծաղիկներ, երբ առավելագույնը 3 առաջին տեսակի և 2 երկրորդ տեսակի համար՝ [1, 1, 2, 2] և [1, 2, 2, 2]:\n\n- calculate_arrangements(3, 3, [1, 2, 3]) վերադարձնում է 6:\nԿան վեց ձևեր դասավորելու 3 ծաղկամաններ՝ օգտագործելով երեք տեսակի ծաղիկներ, երբ առավելագույն ծաղկամանները 1, 2 և 3 են համապատասխանաբար առաջին, երկրորդ և երրորդ տեսակների համար:",
      "bn": "m টি ফুলের টব সাজানোর উপায়ের সংখ্যা গণনা করুন n প্রকারের মধ্যে, যেখানে i-তম প্রকারের সর্বাধিক a[i] টব থাকতে পারে এবং বিন্যাসটি ফুলের প্রকারের ক্রমবর্ধমান ক্রমে হতে হবে।\n\nআর্গস:\n- n (int): উপলব্ধ ফুলের প্রকারের সংখ্যা।\n- m (int): সাজানোর জন্য মোট ফুলের টবের সংখ্যা।\n- a (list of int): একটি তালিকা যেখানে a[i] হল i-তম প্রকারের ফুলের জন্য সর্বাধিক টবের সংখ্যা।\n\nরিটার্নস:\n- int: স্বতন্ত্র বিন্যাসের সংখ্যা মডুলো (10^6 + 7)।\n\nউদাহরণ:\n- calculate_arrangements(2, 4, [3, 2]) 2 প্রদান করে।\nদুটি সম্ভাব্য বিন্যাস আছে 4 টবের জন্য দুটি প্রকারের ফুল ব্যবহার করে যেখানে প্রথম প্রকারের সর্বাধিক 3 এবং দ্বিতীয় প্রকারের সর্বাধিক 2: [1, 1, 2, 2] এবং [1, 2, 2, 2]।\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 প্রদান করে।\n6টি উপায় আছে 3 টব সাজানোর জন্য তিন প্রকারের ফুল ব্যবহার করে যখন সর্বাধিক টবের সংখ্যা যথাক্রমে প্রথম, দ্বিতীয় এবং তৃতীয় প্রকারের জন্য 1, 2, এবং 3।",
      "bg": "Изчислете броя на начините за подреждане на m саксии с цветя, използвайки до n типа, като i-тият тип може да има най-много a[i] саксии, и подреждането трябва да бъде във възходящ ред на типовете цветя.\n\nАргументи:\n- n (int): Броят на наличните типове цветя.\n- m (int): Общият брой саксии с цветя за подреждане.\n- a (списък от int): Списък, където a[i] е максималният брой саксии за i-тия тип цветя.\n\nВръща:\n- int: Броят на различните подреждания по модул (10^6 + 7).\n\nПримери:\n- calculate_arrangements(2, 4, [3, 2]) връща 2.\nИма два възможни подреждания за 4 саксии, използвайки два типа цветя с най-много 3 от първия тип и 2 от втория тип: [1, 1, 2, 2] и [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) връща 6.\nИма шест начина за подреждане на 3 саксии, използвайки три типа цветя, когато максималният брой саксии е 1, 2 и 3 за първия, втория и третия тип съответно.",
      "zh": "计算使用最多 n 种类型的 m 个花盆的排列方式，其中第 i 种类型最多可以有 a[i] 个花盆，并且排列必须按照花的类型递增顺序。\n\n参数:\n- n (int): 可用的花的类型数量。\n- m (int): 要排列的花盆总数。\n- a (list of int): 一个列表，其中 a[i] 是第 i 种花的最大花盆数量。\n\n返回:\n- int: 不同排列的数量，结果取模 (10^6 + 7)。\n\n示例:\n- calculate_arrangements(2, 4, [3, 2]) 返回 2。\n使用两种类型的花来排列 4 个花盆，第一种类型最多 3 个，第二种类型最多 2 个，有两种可能的排列：[1, 1, 2, 2] 和 [1, 2, 2, 2]。\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 返回 6。\n使用三种类型的花来排列 3 个花盆，当第一、第二和第三种类型的最大花盆数分别为 1、2 和 3 时，有六种排列方式。",
      "fr": "Calculer le nombre de façons d'arranger m pots de fleurs en utilisant jusqu'à n types,\noù le ième type peut avoir au plus a[i] pots, et l'arrangement doit être en\nordre croissant des types de fleurs.\n\nArgs:\n- n (int): Le nombre de types de fleurs disponibles.\n- m (int): Le nombre total de pots de fleurs à arranger.\n- a (list of int): Une liste où a[i] est le nombre maximum de pots pour le ième type de fleur.\n\nReturns:\n- int: Le nombre d'arrangements distincts modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) retourne 2.\nIl y a deux arrangements possibles pour 4 pots en utilisant deux types de fleurs avec\nau plus 3 du premier type et 2 du second type : [1, 1, 2, 2] et [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) retourne 6.\nIl y a six façons d'arranger 3 pots en utilisant trois types de fleurs lorsque les\npots maximums sont 1, 2, et 3 pour les premier, deuxième, et troisième types respectivement.",
      "de": "Berechne die Anzahl der Möglichkeiten, m Blumentöpfe unter Verwendung von bis zu n Typen anzuordnen, wobei der i-te Typ höchstens a[i] Töpfe haben kann, und die Anordnung muss in aufsteigender Reihenfolge der Blumentypen erfolgen.\n\nArgs:\n- n (int): Die Anzahl der verfügbaren Blumentypen.\n- m (int): Die Gesamtanzahl der anzuordnenden Blumentöpfe.\n- a (list of int): Eine Liste, in der a[i] die maximale Anzahl von Töpfen für den i-ten Blumentyp ist.\n\nReturns:\n- int: Die Anzahl der unterschiedlichen Anordnungen modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) gibt 2 zurück.\nEs gibt zwei mögliche Anordnungen für 4 Töpfe unter Verwendung von zwei Blumentypen mit höchstens 3 vom ersten Typ und 2 vom zweiten Typ: [1, 1, 2, 2] und [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) gibt 6 zurück.\nEs gibt sechs Möglichkeiten, 3 Töpfe unter Verwendung von drei Blumentypen anzuordnen, wenn die maximale Anzahl der Töpfe 1, 2 und 3 für den ersten, zweiten und dritten Typ beträgt.",
      "ha": "Lissafa yawan hanyoyin da za a iya tsara tukwane m na furanni ta amfani da nau'ikan n,\ninda nau'in na i zai iya samun a[i] tukwane, kuma tsarin dole ne ya kasance a cikin\ntsari mai ƙaruwa na nau'ikan furanni.\n\nArgs:\n- n (int): Yawan nau'ikan furanni da ake da su.\n- m (int): Jimillar adadin tukwanen fure da za a tsara.\n- a (list of int): Jerin inda a[i] shine iyakar adadin tukwane don nau'in fure na i.\n\nReturns:\n- int: Yawan tsarukan daban-daban modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nAkwai hanyoyi biyu masu yiyuwa don tsara tukwane 4 ta amfani da nau'ikan furanni biyu tare da akalla 3 na nau'in farko da 2 na nau'in na biyu: [1, 1, 2, 2] da [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nAkwai hanyoyi guda shida don tsara tukwane 3 ta amfani da nau'ikan furanni uku idan iyakar tukwane suna 1, 2, da 3 don nau'in farko, na biyu, da na uku bi da bi.",
      "hi": "फूलों के m गमलों को n प्रकारों का उपयोग करके व्यवस्थित करने के तरीकों की संख्या की गणना करें, जहाँ iवें प्रकार में अधिकतम a[i] गमले हो सकते हैं, और व्यवस्था फूलों के प्रकारों के बढ़ते क्रम में होनी चाहिए।\n\nआर्ग्स:\n- n (int): उपलब्ध फूलों के प्रकारों की संख्या।\n- m (int): व्यवस्थित करने के लिए कुल फूल गमलों की संख्या।\n- a (list of int): एक सूची जहाँ a[i] iवें प्रकार के फूल के लिए अधिकतम गमलों की संख्या है।\n\nवापसी:\n- int: विशिष्ट व्यवस्थाओं की संख्या (10^6 + 7) के मापांक के अनुसार।\n\nउदाहरण:\n- calculate_arrangements(2, 4, [3, 2]) 2 लौटाता है।\nदो प्रकार के फूलों का उपयोग करके 4 गमलों के लिए दो संभावित व्यवस्थाएँ हैं, पहले प्रकार के अधिकतम 3 और दूसरे प्रकार के अधिकतम 2: [1, 1, 2, 2] और [1, 2, 2, 2]।\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 लौटाता है।\n3 गमलों को तीन प्रकार के फूलों का उपयोग करके व्यवस्थित करने के छह तरीके हैं जब पहले, दूसरे, और तीसरे प्रकार के लिए अधिकतम गमले क्रमशः 1, 2, और 3 हैं।",
      "hu": "Számítsuk ki, hányféleképpen lehet elrendezni m virágcserepet legfeljebb n típus használatával, ahol az i-edik típusnak legfeljebb a[i] cserép lehet, és az elrendezésnek növekvő sorrendben kell lennie a virágtípusok szerint.\n\nArgs:\n- n (int): A rendelkezésre álló virágtípusok száma.\n- m (int): Az elrendezendő virágcserepek teljes száma.\n- a (list of int): Egy lista, ahol a[i] az i-edik virágtípus maximális cserépszáma.\n\nReturns:\n- int: Az eltérő elrendezések száma modulo (10^6 + 7).\n\nPéldák:\n- calculate_arrangements(2, 4, [3, 2]) visszaadja 2.\nKét lehetséges elrendezés van 4 cserépre két virágtípus használatával, legfeljebb 3 az első típusból és 2 a második típusból: [1, 1, 2, 2] és [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) visszaadja 6.\nHatféleképpen lehet elrendezni 3 cserepet három virágtípus használatával, amikor a maximális cserépszámok 1, 2 és 3 az első, második és harmadik típusra."
    },
    "docstring_bertscore": {
      "sq": "0.9730025558705001",
      "hy": "0.9164316301998587",
      "bn": "0.9352077628583246",
      "bg": "0.9692712841627596",
      "zh": "0.9128145709612134",
      "fr": "0.9925336826072796",
      "de": "0.966699815249882",
      "ha": "0.9739869680389089",
      "hi": "0.9502349457051381",
      "hu": "0.9488038138097817"
    }
  },
  {
    "task_id": "Python/40",
    "prompt": {
      "en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided",
      "sq": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Dekripton një tekst të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n    \n    Shifra Vigenère është një metodë për të koduar tekst alfabetik duke përdorur një seri\n    shifrash Caesar bazuar në shkronjat e një fjale kyçe. Kjo funksion kthen procesin\n    për të rikuperuar tekstin origjinal nga teksti i koduar.\n\n    Argumentet:\n        key (str): Çelësi i enkriptimit i përdorur për të koduar tekstin origjinal.\n                   Ky çelës duhet të përmbajë vetëm karaktere alfabetike.\n        ciphertext (str): Teksti i koduar që duhet të dekriptohet.\n                          Teksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\n    Kthen:\n        str: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë.\n\n    Shembuj:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Zbatimi i funksionit siç është dhënë",
      "hy": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Վիջեներ կոդով կոդավորված գաղտնագիրը ապակոդավորում է տրված բանալու միջոցով:\n    \n    Վիջեներ կոդը այբբենական տեքստի կոդավորման մեթոդ է, որը օգտագործում է\n    Կեսարի կոդերի շարք հիմնված բանալի բառի տառերի վրա: Այս ֆունկցիան հակադարձում է գործընթացը\n    վերականգնելու համար սկզբնական պարզ տեքստը գաղտնագրից:\n\n    Պարամետրեր:\n        key (str): Կոդավորման բանալին, որը օգտագործվել է սկզբնական պարզ տեքստը կոդավորելու համար:\n                   Այս բանալին պետք է կազմված լինի միայն այբբենական նիշերից:\n        ciphertext (str): Կոդավորված տեքստը, որը պետք է ապակոդավորվի:\n                          Գաղտնագիրը պետք է կազմված լինի միայն այբբենական նիշերից:\n\n    Վերադարձնում է:\n        str: Ապակոդավորված պարզ տեքստը, որը համապատասխանում է մուտքային գաղտնագրին:\n\n    Օրինակներ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Ֆունկցիայի իրականացումը ինչպես տրված է",
      "bn": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    প্রদত্ত কী ব্যবহার করে Vigenère সাইফার দিয়ে এনক্রিপ্ট করা একটি সাইফারটেক্সট ডিক্রিপ্ট করে।\n\n    Vigenère সাইফার হল একটি পদ্ধতি যা একটি কীওয়ার্ডের অক্ষরগুলির উপর ভিত্তি করে সিজার সাইফারের একটি সিরিজ ব্যবহার করে বর্ণানুক্রমিক টেক্সট এনক্রিপ্ট করে। এই ফাংশনটি প্রক্রিয়াটি বিপরীত করে সাইফারটেক্সট থেকে আসল প্লেইনটেক্সট পুনরুদ্ধার করে।\n\n    আর্গুমেন্টসমূহ:\n        key (str): এনক্রিপশন কী যা আসল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত হয়েছিল।\n                   এই কী শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n        ciphertext (str): এনক্রিপ্ট করা টেক্সট যা ডিক্রিপ্ট করা প্রয়োজন।\n                          সাইফারটেক্সট শুধুমাত্র বর্ণানুক্রমিক অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\n    রিটার্নস:\n        str: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\n    উদাহরণ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided",
      "bg": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Декриптира шифротекст, шифрован с шифъра на Виженер, използвайки предоставения ключ.\n    \n    Шифърът на Виженер е метод за шифроване на азбучен текст чрез използване на серия от\n    шифри на Цезар, базирани на буквите на ключова дума. Тази функция обръща процеса,\n    за да възстанови оригиналния открит текст от шифротекста.\n\n    Args:\n        key (str): Ключът за шифроване, използван за шифроване на оригиналния открит текст.\n                   Този ключ трябва да се състои само от азбучни символи.\n        ciphertext (str): Шифротекстът, който трябва да бъде декриптиран.\n                          Шифротекстът трябва да се състои само от азбучни символи.\n\n    Returns:\n        str: Декриптираният открит текст, съответстващ на входния шифротекст.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Реализация на функцията, както е предоставена",
      "zh": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    使用提供的密钥解密用维吉尼亚密码加密的密文。\n    \n    维吉尼亚密码是一种通过使用基于关键字字母的凯撒密码系列来加密字母文本的方法。\n    此函数逆转该过程，从密文中恢复原始明文。\n\n    参数:\n        key (str): 用于加密原始明文的加密密钥。\n                   此密钥应仅由字母字符组成。\n        ciphertext (str): 需要解密的加密文本。\n                          密文应仅由字母字符组成。\n\n    返回:\n        str: 与输入密文对应的解密明文。\n\n    示例:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided",
      "fr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Décrypte un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n    \n    Le chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\n    chiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\n    pour récupérer le texte original à partir du texte chiffré.\n\n    Args:\n        key (str): La clé de chiffrement utilisée pour chiffrer le texte original.\n                   Cette clé doit être composée uniquement de caractères alphabétiques.\n        ciphertext (str): Le texte chiffré qui doit être déchiffré.\n                          Le texte chiffré doit être composé uniquement de caractères alphabétiques.\n\n    Returns:\n        str: Le texte déchiffré correspondant au texte chiffré d'entrée.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Implémentation de la fonction telle que fournie",
      "de": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Entschlüsselt einen mit dem Vigenère-Chiffre verschlüsselten Geheimtext unter Verwendung des bereitgestellten Schlüssels.\n    \n    Das Vigenère-Chiffre ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von\n    Caesar-Chiffren basierend auf den Buchstaben eines Schlüsselworts. Diese Funktion kehrt den Prozess um,\n    um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\n    Args:\n        key (str): Der Verschlüsselungsschlüssel, der zur Verschlüsselung des ursprünglichen Klartexts verwendet wurde.\n                   Dieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\n        ciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\n                          Der Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\n    Returns:\n        str: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\n    Beispiele:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Funktionsimplementierung wie bereitgestellt",
      "ha": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Yana fassara rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n    \n    Vigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta hanyar amfani da jerin\n    Caesar ciphers bisa ga haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\n    don dawo da ainihin rubutun daga rubutun da aka ɓoye.\n\n    Args:\n        key (str): Mabuɗin ɓoyewa da aka yi amfani da shi don ɓoye ainihin rubutun.\n                   Wannan mabuɗin ya kamata ya ƙunshi haruffa kawai.\n        ciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a fassara.\n                          Rubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\n    Returns:\n        str: Rubutun da aka fassara wanda ya dace da rubutun da aka bayar.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Aiwatar da aikin kamar yadda aka bayar",
      "hi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Vigenère सिफर का उपयोग करके एन्क्रिप्ट किए गए सिफरटेक्स्ट को दिए गए कुंजी का उपयोग करके डिक्रिप्ट करता है।\n    \n    Vigenère सिफर एक कीवर्ड के अक्षरों के आधार पर सीज़र सिफर की एक श्रृंखला का उपयोग करके वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है। \n    यह फ़ंक्शन प्रक्रिया को उलटता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट को पुनः प्राप्त किया जा सके।\n\n    Args:\n        key (str): एन्क्रिप्शन कुंजी जो मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए उपयोग की गई थी।\n                   यह कुंजी केवल वर्णमाला के अक्षरों से बनी होनी चाहिए।\n        ciphertext (str): एन्क्रिप्टेड पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\n                          सिफरटेक्स्ट केवल वर्णमाला के अक्षरों से बना होना चाहिए।\n\n    Returns:\n        str: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्टेड प्लेनटेक्स्ट।\n\n    उदाहरण:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided",
      "hu": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Egy Vigenère-rejtjel segítségével titkosított szöveg visszafejtése a megadott kulcs használatával.\n    \n    A Vigenère-rejtjel egy módszer az alfabetikus szöveg titkosítására, amely egy kulcsszó betűin alapuló\n    Caesar-rejtjelek sorozatát használja. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje\n    az eredeti nyílt szöveget a titkosított szövegből.\n\n    Args:\n        key (str): A titkosításhoz használt kulcs az eredeti nyílt szöveg titkosításához.\n                   Ez a kulcs csak alfabetikus karaktereket tartalmazhat.\n        ciphertext (str): A titkosított szöveg, amelyet vissza kell fejteni.\n                          A titkosított szöveg csak alfabetikus karaktereket tartalmazhat.\n\n    Returns:\n        str: A visszafejtett nyílt szöveg, amely megfelel a bemeneti titkosított szövegnek.\n\n    Példák:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # A függvény megvalósítása a megadottak szerint"
    },
    "prompt_bertscore": {
      "sq": "0.9483366351535877",
      "hy": "0.9866609767616021",
      "bn": "0.9888496849302255",
      "bg": "0.9945595138634544",
      "zh": "0.9863924284864429",
      "fr": "0.9688811740944072",
      "de": "0.9929444502352598",
      "ha": "0.9605094994249297",
      "hi": "0.9873136761936827",
      "hu": "0.9724743976873284"
    },
    "canonical_solution": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)",
    "instruction": {
      "en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nՏրամադրել հակիրճ բնութագրում (docstring) այս Python կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8846885090066733",
      "bn": "0.8825850132715138",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9174422615785642",
      "hi": "0.8964889413135749",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_vigenere_decrypt():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_vigenere_decrypt()",
    "entry_point": "vigenere_decrypt",
    "signature": "def vigenere_decrypt(key: str, ciphertext: str) -> str:",
    "docstring": {
      "en": "Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n\nThe Vigenère cipher is a method of encrypting alphabetic text by using a series of\nCaesar ciphers based on the letters of a keyword. This function reverses the process\nto recover the original plaintext from the ciphertext.\n\nArgs:\nkey (str): The encryption key used to encrypt the original plaintext.\nThis key should consist only of alphabetic characters.\nciphertext (str): The encrypted text that needs to be decrypted.\nThe ciphertext should consist only of alphabetic characters.\n\nReturns:\nstr: The decrypted plaintext corresponding to the input ciphertext.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "sq": "Dekripton një tekst të koduar me shifrën Vigenère duke përdorur çelësin e dhënë.\n\nShifra Vigenère është një metodë për të koduar tekstin alfabetik duke përdorur një seri\nshifrash Caesar bazuar në shkronjat e një fjale kyçe. Kjo funksion rikthen procesin\npër të rikuperuar tekstin origjinal nga teksti i koduar.\n\nArgumentet:\nkey (str): Çelësi i enkriptimit i përdorur për të koduar tekstin origjinal.\nKy çelës duhet të përmbajë vetëm karaktere alfabetike.\nciphertext (str): Teksti i koduar që duhet të dekriptohet.\nTeksti i koduar duhet të përmbajë vetëm karaktere alfabetike.\n\nKthen:\nstr: Teksti i dekriptuar që korrespondon me tekstin e koduar të dhënë si hyrje.\n\nShembuj:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "hy": "Վիգեներ ծածկագրով կոդավորված տեքստը ապակոդավորում է տրված բանալիով:\n\nՎիգեներ ծածկագիրը այբբենական տեքստը ծածկագրելու մեթոդ է, որը օգտագործում է Կեսարի մի շարք\nծածկագրեր՝ հիմնված բանալի բառի տառերի վրա: Այս ֆունկցիան հակառակ գործընթացն է կատարում՝\nվերականգնելու սկզբնական բաց տեքստը ծածկագրից:\n\nԱրգումենտներ:\nkey (str): Ծածկագրման բանալին, որը օգտագործվել է սկզբնական բաց տեքստը ծածկագրելու համար:\nԱյս բանալին պետք է բաղկացած լինի միայն այբբենական նիշերից:\nciphertext (str): Ծածկագրված տեքստը, որը պետք է ապակոդավորվի:\nԾածկագիրը պետք է բաղկացած լինի միայն այբբենական նիշերից:\n\nՎերադարձնում է:\nstr: Ապակոդավորված բաց տեքստը, որը համապատասխանում է մուտքային ծածկագրին:\n\nՕրինակներ:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "bn": "একটি সাইফারটেক্সটকে ডিক্রিপ্ট করে যা Vigenère সাইফার দ্বারা প্রদত্ত কী ব্যবহার করে এনক্রিপ্ট করা হয়েছিল।\n\nVigenère সাইফার হল একটি পদ্ধতি যা অক্ষরগত টেক্সট এনক্রিপ্ট করার জন্য একটি কীওয়ার্ডের অক্ষরের উপর ভিত্তি করে একাধিক Caesar সাইফার ব্যবহার করে। এই ফাংশনটি প্রক্রিয়াটি উল্টে দেয় যাতে সাইফারটেক্সট থেকে মূল প্লেইনটেক্সট পুনরুদ্ধার করা যায়।\n\nআর্গস:\nkey (str): এনক্রিপশন কী যা মূল প্লেইনটেক্সট এনক্রিপ্ট করতে ব্যবহৃত হয়েছিল।\nএই কী শুধুমাত্র অক্ষরগত অক্ষর নিয়ে গঠিত হওয়া উচিত।\nciphertext (str): এনক্রিপ্ট করা টেক্সট যা ডিক্রিপ্ট করা প্রয়োজন।\nসাইফারটেক্সট শুধুমাত্র অক্ষরগত অক্ষর নিয়ে গঠিত হওয়া উচিত।\n\nরিটার্নস:\nstr: ইনপুট সাইফারটেক্সটের সাথে সম্পর্কিত ডিক্রিপ্ট করা প্লেইনটেক্সট।\n\nউদাহরণ:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "bg": "Декриптира шифротекст, шифрован с шифъра на Виженер, използвайки предоставения ключ.\n\nШифърът на Виженер е метод за шифроване на азбучен текст чрез използване на серия от\nЦезарови шифри, базирани на буквите от ключова дума. Тази функция обръща процеса,\nза да възстанови оригиналния обикновен текст от шифротекста.\n\nАргументи:\nkey (str): Ключът за шифроване, използван за шифроване на оригиналния обикновен текст.\nТози ключ трябва да се състои само от азбучни символи.\nciphertext (str): Шифротекстът, който трябва да бъде декриптиран.\nШифротекстът трябва да се състои само от азбучни символи.\n\nВръща:\nstr: Декриптираният обикновен текст, съответстващ на входния шифротекст.\n\nПримери:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "zh": "解密使用提供的密钥通过维吉尼亚密码加密的密文。\n\n维吉尼亚密码是一种通过使用基于关键词字母的凯撒密码系列来加密字母文本的方法。此函数反转该过程以从密文中恢复原始明文。\n\n参数：\nkey (str): 用于加密原始明文的加密密钥。\n该密钥应仅由字母字符组成。\nciphertext (str): 需要解密的加密文本。\n密文应仅由字母字符组成。\n\n返回：\nstr: 与输入密文对应的解密明文。\n\n示例：\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "fr": "Déchiffre un texte chiffré avec le chiffre de Vigenère en utilisant la clé fournie.\n\nLe chiffre de Vigenère est une méthode de chiffrement de texte alphabétique en utilisant une série de\nchiffres de César basés sur les lettres d'un mot-clé. Cette fonction inverse le processus\npour récupérer le texte en clair original à partir du texte chiffré.\n\nArgs:\nkey (str): La clé de chiffrement utilisée pour chiffrer le texte en clair original.\nCette clé doit être composée uniquement de caractères alphabétiques.\nciphertext (str): Le texte chiffré qui doit être déchiffré.\nLe texte chiffré doit être composé uniquement de caractères alphabétiques.\n\nReturns:\nstr: Le texte en clair déchiffré correspondant au texte chiffré d'entrée.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "de": "Entschlüsselt einen mit dem Vigenère-Chiffre verschlüsselten Geheimtext mit dem bereitgestellten Schlüssel.\n\nDas Vigenère-Chiffre ist eine Methode zur Verschlüsselung von alphabetischem Text durch die Verwendung einer Reihe von Caesar-Chiffren, die auf den Buchstaben eines Schlüsselworts basieren. Diese Funktion kehrt den Prozess um, um den ursprünglichen Klartext aus dem Geheimtext wiederherzustellen.\n\nArgs:\nkey (str): Der Verschlüsselungsschlüssel, der verwendet wurde, um den ursprünglichen Klartext zu verschlüsseln.\nDieser Schlüssel sollte nur aus alphabetischen Zeichen bestehen.\nciphertext (str): Der verschlüsselte Text, der entschlüsselt werden muss.\nDer Geheimtext sollte nur aus alphabetischen Zeichen bestehen.\n\nReturns:\nstr: Der entschlüsselte Klartext, der dem Eingabe-Geheimtext entspricht.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "ha": "Yana fassara rubutun da aka ɓoye tare da Vigenère cipher ta amfani da mabuɗin da aka bayar.\n\nVigenère cipher wata hanya ce ta ɓoye rubutun haruffa ta hanyar amfani da jerin\nCaesar ciphers bisa ga haruffan kalmar sirri. Wannan aikin yana juyar da tsarin\ndon dawo da ainihin rubutun asali daga rubutun da aka ɓoye.\n\nArgs:\nkey (str): Maɓallin ɓoyewa da aka yi amfani da shi don ɓoye rubutun asali.\nWannan maɓalli ya kamata ya ƙunshi haruffa kawai.\nciphertext (str): Rubutun da aka ɓoye wanda ake buƙatar a warware.\nRubutun da aka ɓoye ya kamata ya ƙunshi haruffa kawai.\n\nReturns:\nstr: Rubutun da aka warware wanda ya dace da rubutun da aka shigar.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "hi": "Vigenère सिफर का उपयोग करके एन्क्रिप्ट किए गए सिफरटेक्स्ट को दिए गए कुंजी का उपयोग करके डिक्रिप्ट करता है।\n\nVigenère सिफर वर्णमाला पाठ को एन्क्रिप्ट करने की एक विधि है जो एक कुंजी शब्द के अक्षरों पर आधारित कैसर सिफर की एक श्रृंखला का उपयोग करती है। यह फ़ंक्शन प्रक्रिया को उलट देता है ताकि सिफरटेक्स्ट से मूल प्लेनटेक्स्ट पुनः प्राप्त किया जा सके।\n\nआर्ग्स:\nkey (str): एन्क्रिप्शन कुंजी जिसका उपयोग मूल प्लेनटेक्स्ट को एन्क्रिप्ट करने के लिए किया गया था।\nयह कुंजी केवल वर्णमाला के अक्षरों से बनी होनी चाहिए।\nciphertext (str): एन्क्रिप्टेड पाठ जिसे डिक्रिप्ट करने की आवश्यकता है।\nसिफरटेक्स्ट केवल वर्णमाला के अक्षरों से बना होना चाहिए।\n\nरिटर्न्स:\nstr: इनपुट सिफरटेक्स्ट के अनुरूप डिक्रिप्टेड प्लेनटेक्स्ट।\n\nउदाहरण:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "hu": "Visszafejt egy Vigenère-rejtjel által titkosított titkos szöveget a megadott kulcs használatával.\n\nA Vigenère-rejtjel egy olyan módszer, amely az ábécé szöveg titkosítására szolgál egy kulcsszó betűin alapuló Caesar-rejtjelek sorozatával. Ez a függvény visszafordítja a folyamatot, hogy visszanyerje az eredeti nyílt szöveget a titkos szövegből.\n\nArgs:\nkey (str): A titkosítási kulcs, amelyet az eredeti nyílt szöveg titkosítására használtak.\nEz a kulcs csak ábécé karakterekből állhat.\nciphertext (str): A titkosított szöveg, amelyet vissza kell fejteni.\nA titkos szöveg csak ábécé karakterekből állhat.\n\nReturns:\nstr: A visszafejtett nyílt szöveg, amely megfelel a bemeneti titkos szövegnek.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'"
    },
    "docstring_bertscore": {
      "sq": "0.94900502638577",
      "hy": "0.9635423867129514",
      "bn": "0.9582457089722751",
      "bg": "0.9906449063140188",
      "zh": "0.9767697796772078",
      "fr": "0.9866764699313229",
      "de": "0.9918317228407023",
      "ha": "0.9687411396757776",
      "hi": "0.9872064157879239",
      "hu": "0.9891053222306174"
    }
  },
  {
    "task_id": "Python/41",
    "prompt": {
      "en": "def mod_inverse(a, b):\n    \"\"\"\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n      # Explanation: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explanation: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explanation: gcd(42, 2017) != 1, so no inverse exists\n    \"\"\"",
      "sq": "def mod_inverse(a, b):\n    \"\"\"\n    Llogarit inversin modular multiplikativ të `a` modulo `b`.\n    \n    Kjo funksion gjen një numër të plotë `x` të tillë që (a * x) % b == 1, me kusht që\n    `a` dhe `b` janë të bashkëkryqëzuar (d.m.th., gcd(a, b) == 1). Përdor Algoritmin e Zgjeruar të Euklidit\n    për të llogaritur inversin. Nëse `a` dhe `b` nuk janë të bashkëkryqëzuar, inversi modular\n    nuk ekziston, dhe funksioni kthen `None`.\n    \n    Args:\n      a (int): Numri i plotë për të cilin do të gjendet inversi modular.\n      b (int): Moduli me të cilin kërkohet inversi.\n    \n    Returns:\n      int: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n    \n    Shembuj:\n      >>> mod_inverse(3, 10)\n      7\n      # Shpjegim: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Shpjegim: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Shpjegim: gcd(42, 2017) != 1, kështu që nuk ekziston invers\n    \"\"\"",
      "hy": "def mod_inverse(a, b):\n    \"\"\"\n    Հաշվել `a`-ի մոդուլային բազմապատիկ հակադարձը `b`-ի նկատմամբ։\n    \n    Այս ֆունկցիան գտնում է ամբողջ թիվ `x`, այնպես որ (a * x) % b == 1, ենթադրելով, որ\n    `a` և `b` փոխադարձ պարզ են (այսինքն՝ gcd(a, b) == 1): Այն օգտագործում է ընդլայնված Էվկլիդյան\n    ալգորիթմը հակադարձը հաշվարկելու համար։ Եթե `a` և `b` փոխադարձ պարզ չեն, ապա մոդուլային\n    հակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`։\n    \n    Արգումենտներ:\n      a (int): Ամբողջ թիվ, որի մոդուլային հակադարձը պետք է գտնվի։\n      b (int): Մոդուլը, որի նկատմամբ հակադարձը փնտրվում է։\n    \n    Վերադարձնում է:\n      int: `a`-ի մոդուլային հակադարձը `b`-ի նկատմամբ, եթե այն գոյություն ունի, հակառակ դեպքում `None`։\n    \n    Օրինակներ:\n      >>> mod_inverse(3, 10)\n      7\n      # Բացատրություն: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Բացատրություն: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Բացատրություն: gcd(42, 2017) != 1, ուստի հակադարձը գոյություն չունի\n    \"\"\"",
      "bn": "def mod_inverse(a, b):\n    \"\"\"\n    `a` এর মডুলার গুণনীয় বিপরীত `b` মডুলোর হিসাব করুন।\n    \n    এই ফাংশন একটি পূর্ণসংখ্যা `x` খুঁজে বের করে যাতে (a * x) % b == 1 হয়, যদি\n    `a` এবং `b` পরস্পর সহমৌলিক হয় (অর্থাৎ, gcd(a, b) == 1)। এটি Extended Euclidean\n    Algorithm ব্যবহার করে বিপরীত হিসাব করে। যদি `a` এবং `b` পরস্পর সহমৌলিক না হয়, তবে মডুলার\n    বিপরীত বিদ্যমান নেই এবং ফাংশন `None` ফেরত দেয়।\n    \n    Args:\n      a (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\n      b (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n    \n    Returns:\n      int: `a` এর মডুলার বিপরীত `b` মডুলোর যদি বিদ্যমান থাকে, অন্যথায় `None`।\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n      # ব্যাখ্যা: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # ব্যাখ্যা: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # ব্যাখ্যা: gcd(42, 2017) != 1, তাই কোন বিপরীত নেই\n    \"\"\"",
      "bg": "def mod_inverse(a, b):\n    \"\"\"\n    Изчислява модулната мултипликативна обратна стойност на `a` по модул `b`.\n    \n    Тази функция намира цяло число `x`, такова че (a * x) % b == 1, при условие че\n    `a` и `b` са взаимно прости (т.е., gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\n    за изчисляване на обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\n    обратна стойност не съществува и функцията връща `None`.\n    \n    Аргументи:\n      a (int): Цялото число, чиято модулна обратна стойност трябва да бъде намерена.\n      b (int): Модулът, спрямо който се търси обратната стойност.\n    \n    Връща:\n      int: Модулната обратна стойност на `a` по модул `b`, ако съществува, в противен случай `None`.\n    \n    Примери:\n      >>> mod_inverse(3, 10)\n      7\n      # Обяснение: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Обяснение: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Обяснение: gcd(42, 2017) != 1, така че обратната стойност не съществува\n    \"\"\"",
      "zh": "def mod_inverse(a, b):\n    \"\"\"\n    计算 `a` 模 `b` 的模逆。\n    \n    此函数寻找一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即 gcd(a, b) == 1）。\n    它使用扩展欧几里得算法来计算逆。如果 `a` 和 `b` 不互质，则模逆不存在，函数返回 `None`。\n    \n    参数:\n      a (int): 要找到模逆的整数。\n      b (int): 模数。\n    \n    返回:\n      int: 如果存在，返回 `a` 模 `b` 的模逆，否则返回 `None`。\n    \n    示例:\n      >>> mod_inverse(3, 10)\n      7\n      # 解释: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # 解释: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # 解释: gcd(42, 2017) != 1，因此不存在逆\n    \"\"\"",
      "fr": "def mod_inverse(a, b):\n    \"\"\"\n    Calculer l'inverse multiplicatif modulaire de `a` modulo `b`.\n    \n    Cette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n    `a` et `b` soient copremiers (c'est-à-dire, gcd(a, b) == 1). Elle utilise l'algorithme\n    d'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas copremiers, l'inverse\n    modulaire n'existe pas, et la fonction renvoie `None`.\n    \n    Args:\n      a (int): L'entier dont l'inverse modulaire doit être trouvé.\n      b (int): Le module par rapport auquel l'inverse est recherché.\n    \n    Returns:\n      int: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n    \n    Exemples:\n      >>> mod_inverse(3, 10)\n      7\n      # Explication : (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explication : (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explication : gcd(42, 2017) != 1, donc aucun inverse n'existe\n    \"\"\"",
      "de": "def mod_inverse(a, b):\n    \"\"\"\n    Berechne den modularen multiplikativen Inversen von `a` modulo `b`.\n    \n    Diese Funktion findet eine ganze Zahl `x`, so dass (a * x) % b == 1, vorausgesetzt,\n    `a` und `b` sind teilerfremd (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten\n    euklidischen Algorithmus, um den Inversen zu berechnen. Wenn `a` und `b` nicht\n    teilerfremd sind, existiert der modulare Inverse nicht, und die Funktion gibt `None` zurück.\n    \n    Args:\n      a (int): Die ganze Zahl, deren modularer Inverser gefunden werden soll.\n      b (int): Der Modulus, in Bezug auf den der Inverser gesucht wird.\n    \n    Returns:\n      int: Der modulare Inverse von `a` modulo `b`, falls er existiert, sonst `None`.\n    \n    Beispiele:\n      >>> mod_inverse(3, 10)\n      7\n      # Erklärung: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Erklärung: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Erklärung: gcd(42, 2017) != 1, daher existiert kein Inverser\n    \"\"\"",
      "ha": "def mod_inverse(a, b):\n    \"\"\"\n    Lissafi na modular multiplicative inverse na `a` modulo `b`.\n    \n    Wannan aikin yana nemo wani cikakken lamba `x` wanda (a * x) % b == 1, idan\n    `a` da `b` suna da bambanci guda (wato, gcd(a, b) == 1). Yana amfani da\n    Tsarin Euclidean da aka faɗaɗa don lissafin inverse. Idan `a` da `b` ba su da\n    bambanci guda, to modular inverse bai wanzu ba, kuma aikin yana mayar da `None`.\n    \n    Args:\n      a (int): Lambar cikakke wanda za a nemo modular inverse ɗinsa.\n      b (int): Modulus da za a nema inverse a kansa.\n    \n    Returns:\n      int: Modular inverse na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n    \n    Misalai:\n      >>> mod_inverse(3, 10)\n      7\n      # Bayani: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Bayani: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Bayani: gcd(42, 2017) != 1, don haka babu inverse da ya wanzu\n    \"\"\"",
      "hi": "def mod_inverse(a, b):\n    \"\"\"\n    `a` का `b` के मापांक के सापेक्ष गुणात्मक व्युत्क्रम की गणना करें।\n    \n    यह फ़ंक्शन एक पूर्णांक `x` ढूंढता है ताकि (a * x) % b == 1, बशर्ते कि\n    `a` और `b` सह-प्राइम हों (अर्थात, gcd(a, b) == 1)। यह व्युत्क्रम की गणना करने के लिए विस्तारित यूक्लिडियन\n    एल्गोरिथ्म का उपयोग करता है। यदि `a` और `b` सह-प्राइम नहीं हैं, तो गुणात्मक\n    व्युत्क्रम मौजूद नहीं है, और फ़ंक्शन `None` लौटाता है।\n    \n    Args:\n      a (int): वह पूर्णांक जिसका गुणात्मक व्युत्क्रम ढूंढा जाना है।\n      b (int): वह मापांक जिसके सापेक्ष व्युत्क्रम खोजा जा रहा है।\n    \n    Returns:\n      int: यदि यह मौजूद है तो `a` का `b` के मापांक के सापेक्ष गुणात्मक व्युत्क्रम, अन्यथा `None`।\n    \n    उदाहरण:\n      >>> mod_inverse(3, 10)\n      7\n      # व्याख्या: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # व्याख्या: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # व्याख्या: gcd(42, 2017) != 1, इसलिए कोई व्युत्क्रम मौजूद नहीं है\n    \"\"\"",
      "hu": "def mod_inverse(a, b):\n    \"\"\"\n    Számítsa ki `a` moduláris multiplikatív inverzét `b` modulussal.\n\n    Ez a függvény egy olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n    `a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához az\n    Kiterjesztett Euklideszi Algoritmust használja. Ha `a` és `b` nem relatív prímek, akkor a moduláris\n    inverz nem létezik, és a függvény `None` értéket ad vissza.\n\n    Args:\n      a (int): Az egész szám, amelynek moduláris inverzét meg kell találni.\n      b (int): A modulus, amelyhez képest az inverz keresett.\n\n    Returns:\n      int: `a` moduláris inverze `b` modulussal, ha létezik, különben `None`.\n\n    Példák:\n      >>> mod_inverse(3, 10)\n      7\n      # Magyarázat: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Magyarázat: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Magyarázat: gcd(42, 2017) != 1, így nem létezik inverz\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9849269335351675",
      "hy": "0.9766706631170714",
      "bn": "0.9846810291234463",
      "bg": "0.9837411101603892",
      "zh": "0.961552706186125",
      "fr": "0.9965489957598999",
      "de": "0.9906252419062964",
      "ha": "0.9792681526098646",
      "hi": "0.951202275660778",
      "hu": "0.9757186277007711"
    },
    "canonical_solution": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b",
    "instruction": {
      "en": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nՏվյալ Python կոդի համար տրամադրեք կարճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），不超过500个字符。",
      "fr": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nBa da taƙaitaccen bayani a cikin yaren mutum (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548376088944786",
      "hy": "0.8697749427378118",
      "bn": "0.8825850132715138",
      "bg": "0.8983697723915943",
      "zh": "0.8839134532598751",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.8965552838608406",
      "hi": "0.8964889413135749",
      "hu": "0.9429881148834612"
    },
    "level": "",
    "test": "def test_mod_inverse():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ntest_mod_inverse()",
    "entry_point": "mod_inverse",
    "signature": "def mod_inverse(a, b):",
    "docstring": {
      "en": "Calculate the modular multiplicative inverse of `a` modulo `b`.\n\nThis function finds an integer `x` such that (a * x) % b == 1, provided that\n`a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\nAlgorithm to compute the inverse. If `a` and `b` are not coprime, the modular\ninverse does not exist, and the function returns `None`.\n\nArgs:\na (int): The integer whose modular inverse is to be found.\nb (int): The modulus with respect to which the inverse is sought.\n\nReturns:\nint: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplanation: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplanation: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplanation: gcd(42, 2017) != 1, so no inverse exists",
      "sq": "Llogaritni inversin modular multiplikativ të `a` modulo `b`.\n\nKjo funksion gjen një numër të plotë `x` i tillë që (a * x) % b == 1, me kusht që\n`a` dhe `b` të jenë të papërbashkët (d.m.th., gcd(a, b) == 1). Përdor Algoritmin e Zgjeruar të Euklidit për të llogaritur inversin. Nëse `a` dhe `b` nuk janë të papërbashkët, inversi modular nuk ekziston, dhe funksioni kthen `None`.\n\nArgs:\na (int): Numri i plotë për të cilin do të gjendet inversi modular.\nb (int): Moduli në lidhje me të cilin kërkohet inversi.\n\nReturns:\nint: Inversi modular i `a` modulo `b` nëse ekziston, përndryshe `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nShpjegim: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nShpjegim: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nShpjegim: gcd(42, 2017) != 1, kështu që nuk ekziston asnjë invers",
      "hy": "Հաշվարկել `a`-ի մոդուլային բազմապատիկ հակադարձը `b` մոդուլով։\n\nԱյս ֆունկցիան գտնում է ամբողջ թիվ `x`, այնպես որ (a * x) % b == 1, եթե\n`a` և `b` փոխադարձաբար պարզ են (այսինքն՝ gcd(a, b) == 1)։ Այն օգտագործում է ընդլայնված Էվկլիդյան\nալգորիթմը հակադարձը հաշվարկելու համար։ Եթե `a` և `b` փոխադարձաբար պարզ չեն, մոդուլային\nհակադարձը գոյություն չունի, և ֆունկցիան վերադարձնում է `None`։\n\nԱրգումենտներ:\na (int): Ամբողջ թիվը, որի մոդուլային հակադարձը պետք է գտնվի։\nb (int): Մոդուլը, որի նկատմամբ հակադարձը փնտրվում է։\n\nՎերադարձներ:\nint: `a`-ի մոդուլային հակադարձը `b` մոդուլով, եթե այն գոյություն ունի, հակառակ դեպքում `None`։\n\nՕրինակներ:\n>>> mod_inverse(3, 10)\n7\nԲացատրություն: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nԲացատրություն: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nԲացատրություն: gcd(42, 2017) != 1, ուստի հակադարձը գոյություն չունի",
      "bn": "`a` এর মডুলার গুণগত বিপরীত `b` মডুলোর সাথে গণনা করুন।\n\nএই ফাংশনটি এমন একটি পূর্ণসংখ্যা `x` খুঁজে বের করে যাতে (a * x) % b == 1, যদি `a` এবং `b` পরস্পর সহমর্মী হয় (অর্থাৎ, gcd(a, b) == 1)। এটি বিপরীত গণনা করতে Extended Euclidean Algorithm ব্যবহার করে। যদি `a` এবং `b` পরস্পর সহমর্মী না হয়, তাহলে মডুলার বিপরীত বিদ্যমান নয় এবং ফাংশনটি `None` ফেরত দেয়।\n\nআর্গস:\na (int): পূর্ণসংখ্যা যার মডুলার বিপরীত খুঁজে বের করতে হবে।\nb (int): মডুলাস যার সাথে বিপরীত খোঁজা হচ্ছে।\n\nরিটার্নস:\nint: `a` এর মডুলার বিপরীত `b` মডুলোর সাথে যদি বিদ্যমান থাকে, অন্যথায় `None`।\n\nউদাহরণ:\n>>> mod_inverse(3, 10)\n7\nব্যাখ্যা: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nব্যাখ্যা: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nব্যাখ্যা: gcd(42, 2017) != 1, তাই কোনো বিপরীত বিদ্যমান নেই",
      "bg": "Изчислява модулната мултипликативна обратна стойност на `a` модул `b`.\n\nТази функция намира цяло число `x`, такова че (a * x) % b == 1, при условие че\n`a` и `b` са взаимно прости (т.е., gcd(a, b) == 1). Използва разширения алгоритъм на Евклид\nза да изчисли обратната стойност. Ако `a` и `b` не са взаимно прости, модулната\nобратна стойност не съществува и функцията връща `None`.\n\nАргументи:\na (int): Цялото число, чиято модулна обратна стойност трябва да се намери.\nb (int): Модулът, спрямо който се търси обратната стойност.\n\nВръща:\nint: Модулната обратна стойност на `a` модул `b`, ако съществува, в противен случай `None`.\n\nПримери:\n>>> mod_inverse(3, 10)\n7\nОбяснение: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nОбяснение: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nОбяснение: gcd(42, 2017) != 1, така че обратна стойност не съществува",
      "zh": "计算 `a` 模 `b` 的模逆。\n\n此函数寻找一个整数 `x`，使得 (a * x) % b == 1，前提是 `a` 和 `b` 互质（即，gcd(a, b) == 1）。它使用扩展欧几里得算法来计算逆。如果 `a` 和 `b` 不互质，则模逆不存在，函数返回 `None`。\n\n参数：\na (int): 要找到模逆的整数。\nb (int): 所求逆的模数。\n\n返回：\nint: 如果存在，则返回 `a` 模 `b` 的模逆，否则返回 `None`。\n\n示例：\n>>> mod_inverse(3, 10)\n7\n解释: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\n解释: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\n解释: gcd(42, 2017) != 1，因此不存在逆。",
      "fr": "Calculer l'inverse multiplicatif modulaire de `a` modulo `b`.\n\nCette fonction trouve un entier `x` tel que (a * x) % b == 1, à condition que\n`a` et `b` soient copremiers (c'est-à-dire, gcd(a, b) == 1). Elle utilise l'algorithme\nd'Euclide étendu pour calculer l'inverse. Si `a` et `b` ne sont pas copremiers, l'inverse\nmodulaire n'existe pas, et la fonction retourne `None`.\n\nArgs:\na (int): L'entier dont l'inverse modulaire doit être trouvé.\nb (int): Le module par rapport auquel l'inverse est recherché.\n\nReturns:\nint: L'inverse modulaire de `a` modulo `b` s'il existe, sinon `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplication : (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplication : (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplication : gcd(42, 2017) != 1, donc aucun inverse n'existe",
      "de": "Berechne das modulare multiplikative Inverse von `a` modulo `b`.\n\nDiese Funktion findet eine ganze Zahl `x`, so dass (a * x) % b == 1, vorausgesetzt, dass `a` und `b` teilerfremd sind (d.h., gcd(a, b) == 1). Sie verwendet den erweiterten euklidischen Algorithmus, um das Inverse zu berechnen. Wenn `a` und `b` nicht teilerfremd sind, existiert das modulare Inverse nicht, und die Funktion gibt `None` zurück.\n\nArgs:\na (int): Die ganze Zahl, deren modulares Inverses gefunden werden soll.\nb (int): Der Modul, bezüglich dessen das Inverse gesucht wird.\n\nReturns:\nint: Das modulare Inverse von `a` modulo `b`, falls es existiert, andernfalls `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nErläuterung: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nErläuterung: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nErläuterung: gcd(42, 2017) != 1, daher existiert kein Inverses",
      "ha": "Lissafi na modular multiplicative inverse na `a` modulo `b`.\n\nWannan aikin yana nemo wani lamba `x` wanda (a * x) % b == 1, idan har `a` da `b` suna da bambancin daya (wato, gcd(a, b) == 1). Yana amfani da Tsarin Euclidean Mai Fadada don lissafa abin da ya dace. Idan `a` da `b` ba su da bambancin daya, to babu modular inverse, kuma aikin zai dawo da `None`.\n\nArgs:\na (int): Lambar da za a nemo modular inverse dinta.\nb (int): Modulus wanda ake nema inverse dinta dangane da shi.\n\nReturns:\nint: Modular inverse na `a` modulo `b` idan yana wanzu, in ba haka ba `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nBayani: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nBayani: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nBayani: gcd(42, 2017) != 1, don haka babu inverse da ke wanzu",
      "hi": "`a` का `b` के मापांक में गुणात्मक प्रतिलोम गणना करें।\n\nयह फ़ंक्शन एक पूर्णांक `x` खोजता है ताकि (a * x) % b == 1 हो, बशर्ते कि `a` और `b` परस्पर अभाज्य हों (अर्थात, gcd(a, b) == 1)। यह प्रतिलोम की गणना के लिए विस्तारित यूक्लिडियन एल्गोरिदम का उपयोग करता है। यदि `a` और `b` परस्पर अभाज्य नहीं हैं, तो गुणात्मक प्रतिलोम मौजूद नहीं होता है, और फ़ंक्शन `None` लौटाता है।\n\nआर्ग्स:\na (int): वह पूर्णांक जिसका गुणात्मक प्रतिलोम खोजना है।\nb (int): वह मापांक जिसके सापेक्ष प्रतिलोम खोजा जा रहा है।\n\nरिटर्न्स:\nint: `a` का `b` के मापांक में गुणात्मक प्रतिलोम यदि यह मौजूद है, अन्यथा `None`।\n\nउदाहरण:\n>>> mod_inverse(3, 10)\n7\nव्याख्या: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nव्याख्या: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nव्याख्या: gcd(42, 2017) != 1, इसलिए कोई प्रतिलोम मौजूद नहीं है।",
      "hu": "Számítsa ki `a` moduláris multiplikatív inverzét `b` modulóval.\n\nEz a függvény olyan egész számot talál `x`, amelyre (a * x) % b == 1, feltéve, hogy\n`a` és `b` relatív prímek (azaz gcd(a, b) == 1). Az inverz kiszámításához a kiterjesztett euklideszi algoritmust használja. Ha `a` és `b` nem relatív prímek, a moduláris inverz nem létezik, és a függvény `None`-t ad vissza.\n\nArgok:\na (int): Az egész szám, amelynek moduláris inverzét meg kell találni.\nb (int): A modulus, amelyhez képest az inverz keresendő.\n\nVisszatér:\nint: `a` moduláris inverze `b` modulóval, ha létezik, egyébként `None`.\n\nPéldák:\n>>> mod_inverse(3, 10)\n7\nMagyarázat: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nMagyarázat: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nMagyarázat: gcd(42, 2017) != 1, így nem létezik inverz"
    },
    "docstring_bertscore": {
      "sq": "0.9910060163467402",
      "hy": "0.9831938834606381",
      "bn": "0.9736022209908444",
      "bg": "0.9840616995953796",
      "zh": "0.9519971944456797",
      "fr": "0.996116577420387",
      "de": "0.9940089104472257",
      "ha": "0.9710766356959858",
      "hi": "0.9816479432050436",
      "hu": "0.9781298018961536"
    }
  },
  {
    "task_id": "Python/42",
    "prompt": {
      "en": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n        - If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          she is most unhappy on Wednesday (day 3), so the function will return 3.\n        - If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\n          unhappy, and the function will return 0.\n        - For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally \n          unhappy on Monday and Thursday, but since Monday comes first, the function returns 1.\n    \"\"\"",
      "sq": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Llogarit ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n    \n    Jinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe klasa shtesë tejkalojnë 8 orë në një ditë.\n    Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më të larta mbi pragun.\n    Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme. Nëse Jinjin nuk është e pakënaqur në asnjë ditë,\n    funksioni kthen 0.\n    \n    Argumentet:\n        schedule (list[tuple[int, int]]): Një listë me 7 tufa, ku çdo tufë përfaqëson \n                                           numrin e orëve të kaluara në shkollë dhe në klasa shtesë\n                                           për çdo ditë të javës, respektivisht.\n                                           \n    Kthen:\n        int: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0 \n             nëse ajo nuk është kurrë e pakënaqur.\n    \n    Rastet:\n        - Nëse Jinjin ka orarin e mëposhtëm [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          ajo është më e pakënaqur të mërkurën (dita 3), kështu që funksioni do të kthejë 3.\n        - Nëse orari i saj është [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin nuk është kurrë\n          e pakënaqur, dhe funksioni do të kthejë 0.\n        - Për një orar [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin është njësoj \n          e pakënaqur të hënën dhe të enjten, por meqë e hëna vjen e para, funksioni kthen 1.\n    \"\"\"",
      "hy": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Հաշվարկել այն շաբաթվա օրը, երբ Ջինջինը ամենաանհաջողն է իր ժամանակացույցի հիման վրա։\n    \n    Ջինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերի ժամանակ անցկացրած ընդհանուր ժամերը գերազանցում են 8 ժամը մեկ օրում։ \n    Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը ամենամեծն է, այսինքն՝ այն օրը, երբ ընդհանուր\n    ժամերը առավելագույնս գերազանցում են շեմը։ Եթե կան մի քանի օրեր նույն մակարդակի \n    առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։ Եթե Ջինջինը ոչ մի օր դժգոհ չէ, \n    ֆունկցիան վերադարձնում է 0։\n    \n    Արգումենտներ:\n        schedule (list[tuple[int, int]]): 7 տուփերի ցուցակ, որտեղ յուրաքանչյուր տուփ ներկայացնում է \n                                           դպրոցում և լրացուցիչ դասերի ժամանակ անցկացրած \n                                           ժամերի քանակը շաբաթվա յուրաքանչյուր օրվա համար։\n                                           \n    Վերադարձնում է:\n        int: Շաբաթվա այն օրը, երբ Ջինջինը ամենաանհաջողն է (1-7 երկուշաբթիից կիրակի) կամ 0 \n             եթե նա երբեք դժգոհ չէ։\n    \n    Դեպքեր:\n        - Եթե Ջինջինը ունի հետևյալ ժամանակացույցը [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          նա ամենաանհաջողն է չորեքշաբթի (օր 3), ուստի ֆունկցիան կվերադարձնի 3։\n        - Եթե նրա ժամանակացույցը [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] է, Ջինջինը երբեք\n          դժգոհ չէ, և ֆունկցիան կվերադարձնի 0։\n        - Ժամանակացույցի համար [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Ջինջինը հավասարապես \n          դժգոհ է երկուշաբթի և հինգշաբթի, բայց քանի որ երկուշաբթին առաջինն է, ֆունկցիան կվերադարձնի 1։\n    \"\"\"",
      "bn": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    জিনজিনের সময়সূচির ভিত্তিতে সপ্তাহের কোন দিনটি সে সবচেয়ে অসুখী তা নির্ণয় করুন।\n    \n    জিনজিন অসুখী হয় যদি স্কুল এবং অতিরিক্ত ক্লাসে ব্যয় করা মোট সময় এক দিনে ৮ ঘণ্টার বেশি হয়।\n    ফাংশনটি সেই দিনটি খুঁজে বের করে যখন তার অসুখীতা সবচেয়ে বেশি, অর্থাৎ যেদিন মোট \n    সময় সীমার উপরে সবচেয়ে বেশি। যদি একাধিক দিন একই স্তরের সর্বাধিক অসুখীতা থাকে, \n    তাহলে সবচেয়ে প্রথম দিনটি ফেরত দেওয়া হয়। যদি জিনজিন কোনো দিনই অসুখী না হয়, তাহলে \n    ফাংশনটি 0 ফেরত দেয়।\n    \n    Args:\n        schedule (list[tuple[int, int]]): ৭টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল \n                                           সপ্তাহের প্রতিটি দিনের জন্য স্কুল এবং অতিরিক্ত \n                                           ক্লাসে ব্যয় করা ঘণ্টার সংখ্যা উপস্থাপন করে।\n                                           \n    Returns:\n        int: সপ্তাহের যে দিনটিতে জিনজিন সবচেয়ে অসুখী (সোমবার থেকে রবিবারের জন্য ১-৭) \n             অথবা যদি সে কখনোই অসুখী না হয় তাহলে 0।\n    \n    উদাহরণ:\n        - যদি জিনজিনের সময়সূচি হয় [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          তাহলে সে বুধবার (দিন ৩) সবচেয়ে অসুখী, তাই ফাংশনটি ৩ ফেরত দেবে।\n        - যদি তার সময়সূচি হয় [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], \n          জিনজিন কখনোই অসুখী নয়, এবং ফাংশনটি 0 ফেরত দেবে।\n        - একটি সময়সূচির জন্য [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], \n          জিনজিন সোমবার এবং বৃহস্পতিবার সমানভাবে অসুখী, কিন্তু যেহেতু সোমবার প্রথমে আসে, \n          ফাংশনটি ১ ফেরত দেবে।\n    \"\"\"",
      "bg": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Изчислява деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n    \n    Джинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни класове, надвишава 8 часа на ден.\n    Функцията намира деня, когато нещастието ѝ е най-голямо, което е денят, когато общият брой часове е най-далеч над прага.\n    Ако има няколко дни със същото ниво на максимално нещастие, се връща най-ранният ден. Ако Джинджин не е нещастна в нито един ден,\n    функцията връща 0.\n    \n    Аргументи:\n        schedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\n                                           броя часове, прекарани в училище и в допълнителни класове\n                                           за всеки ден от седмицата, съответно.\n                                           \n    Връща:\n        int: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\n             ако никога не е нещастна.\n    \n    Примери:\n        - Ако Джинджин има следния график [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          тя е най-нещастна в сряда (ден 3), така че функцията ще върне 3.\n        - Ако графикът ѝ е [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Джинджин никога не е\n          нещастна и функцията ще върне 0.\n        - За график [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Джинджин е еднакво\n          нещастна в понеделник и четвъртък, но тъй като понеделник е първи, функцията връща 1.\n    \"\"\"",
      "zh": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    计算根据日程安排，金金在哪一天最不开心。\n    \n    如果金金在学校和额外课程上花费的总时间超过8小时，她就会不开心。\n    该函数找出她不开心程度最大的那一天，即总小时数超过阈值最多的那一天。\n    如果有多天达到相同的最大不开心程度，则返回最早的一天。\n    如果金金在任何一天都不不开心，函数返回0。\n    \n    参数:\n        schedule (list[tuple[int, int]]): 一个包含7个元组的列表，每个元组分别表示\n                                           每周每天在学校和额外课程上花费的小时数。\n                                           \n    返回:\n        int: 金金最不开心的那一天（1-7表示星期一到星期天），如果她从不不开心则返回0。\n    \n    示例:\n        - 如果金金的日程是 [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          她在星期三（第3天）最不开心，所以函数将返回3。\n        - 如果她的日程是 [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]，金金从不\n          不开心，函数将返回0。\n        - 对于日程 [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]，金金在星期一和\n          星期四同样不开心，但由于星期一在前，函数返回1。\n    \"\"\"",
      "fr": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculer le jour de la semaine où Jinjin est la plus malheureuse en fonction de son emploi du temps.\n    \n    Jinjin est malheureuse si le total des heures passées à l'école et aux cours supplémentaires dépasse 8 heures par jour.\n    La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total\n    des heures est le plus au-dessus du seuil. S'il y a plusieurs jours avec le même niveau de\n    malheur maximal, le premier jour est retourné. Si Jinjin n'est malheureuse aucun jour, la\n    fonction retourne 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le\n                                           nombre d'heures passées à l'école et aux cours supplémentaires\n                                           pour chaque jour de la semaine, respectivement.\n                                           \n    Returns:\n        int: Le jour de la semaine où Jinjin est la plus malheureuse (1-7 pour lundi à dimanche) ou 0\n             si elle n'est jamais malheureuse.\n    \n    Cas:\n        - Si Jinjin a l'emploi du temps suivant [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          elle est la plus malheureuse le mercredi (jour 3), donc la fonction retournera 3.\n        - Si son emploi du temps est [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin n'est jamais\n          malheureuse, et la fonction retournera 0.\n        - Pour un emploi du temps [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin est également\n          malheureuse le lundi et le jeudi, mais comme le lundi vient en premier, la fonction retourne 1.\n    \"\"\"",
      "de": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Berechne den Wochentag, an dem Jinjin am unglücklichsten ist, basierend auf ihrem Stundenplan.\n    \n    Jinjin ist unglücklich, wenn die Gesamtstunden, die sie in der Schule und in zusätzlichen Kursen verbringt, 8 Stunden an einem Tag überschreiten. \n    Die Funktion findet den Tag, an dem ihr Unglück am größten ist, was der Tag ist, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen. \n    Wenn es mehrere Tage mit dem gleichen Maß an maximalem Unglück gibt, wird der früheste Tag zurückgegeben. \n    Wenn Jinjin an keinem Tag unglücklich ist, gibt die Funktion 0 zurück.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die Anzahl der Stunden darstellt, \n                                           die an der Schule und in zusätzlichen Kursen für jeden Wochentag verbracht werden.\n                                           \n    Returns:\n        int: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, \n             wenn sie nie unglücklich ist.\n    \n    Fälle:\n        - Wenn Jinjin den folgenden Stundenplan hat [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          ist sie am Mittwoch (Tag 3) am unglücklichsten, daher wird die Funktion 3 zurückgeben.\n        - Wenn ihr Stundenplan [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] ist, ist Jinjin nie\n          unglücklich, und die Funktion wird 0 zurückgeben.\n        - Für einen Stundenplan [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] ist Jinjin gleichermaßen \n          unglücklich am Montag und Donnerstag, aber da Montag zuerst kommt, gibt die Funktion 1 zurück.\n    \"\"\"",
      "ha": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Lissafa ranar mako da Jinjin take mafi rashin jin daɗi bisa ga jadawalin ta.\n    \n    Jinjin tana rashin jin daɗi idan jimillar awanni da aka kwashe a makaranta da ƙarin aji sun wuce awanni 8 a rana.\n    Aikin yana nemo ranar da rashin jin daɗin ta ya fi yawa, wato ranar da jimillar awanni suka fi nesa daga ƙayyadadden\n    matakin. Idan akwai ranaku da yawa da suke da irin wannan matakin mafi girman rashin jin daɗi, za a dawo da ranar da\n    ta fara. Idan Jinjin ba ta rashin jin daɗi a kowace rana, aikin zai dawo da 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowanne tuple ke wakiltar\n                                           adadin awanni da aka kwashe a makaranta da ƙarin aji\n                                           don kowace rana ta mako, bi da bi.\n                                           \n    Returns:\n        int: Ranar mako da Jinjin take mafi rashin jin daɗi (1-7 don Litinin zuwa Lahadi) ko 0\n             idan ba ta taɓa rashin jin daɗi ba.\n    \n    Cases:\n        - Idan Jinjin tana da jadawalin mai zuwa [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          tana mafi rashin jin daɗi a ranar Laraba (rana ta 3), don haka aikin zai dawo da 3.\n        - Idan jadawalin ta shine [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin ba ta taɓa\n          rashin jin daɗi ba, kuma aikin zai dawo da 0.\n        - Don jadawalin [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin tana daidai\n          rashin jin daɗi a ranar Litinin da Alhamis, amma tunda Litinin ta fara, aikin zai dawo da 1.\n    \"\"\"",
      "hi": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjin के कार्यक्रम के आधार पर सप्ताह के उस दिन की गणना करें जब वह सबसे अधिक दुखी होती है।\n    \n    Jinjin दुखी होती है यदि स्कूल और अतिरिक्त कक्षाओं में बिताए गए कुल घंटे एक दिन में 8 घंटे से अधिक होते हैं।\n    फ़ंक्शन उस दिन को खोजता है जब उसकी दुखी होने की स्थिति सबसे अधिक होती है, जो वह दिन होता है जब कुल\n    घंटे सीमा से सबसे अधिक ऊपर होते हैं। यदि कई दिनों में अधिकतम दुखी होने का स्तर समान होता है, तो सबसे पहले\n    आने वाला दिन लौटाया जाता है। यदि Jinjin किसी भी दिन दुखी नहीं होती है, तो फ़ंक्शन 0 लौटाता है।\n    \n    Args:\n        schedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल स्कूल और अतिरिक्त कक्षाओं में\n                                           बिताए गए घंटों की संख्या को क्रमशः सप्ताह के प्रत्येक दिन के लिए दर्शाता है।\n                                           \n    Returns:\n        int: सप्ताह का वह दिन जब Jinjin सबसे अधिक दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 \n             यदि वह कभी दुखी नहीं होती है।\n    \n    उदाहरण:\n        - यदि Jinjin का कार्यक्रम इस प्रकार है [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          वह बुधवार (दिन 3) को सबसे अधिक दुखी होती है, इसलिए फ़ंक्शन 3 लौटाएगा।\n        - यदि उसका कार्यक्रम [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] है, तो Jinjin कभी\n          दुखी नहीं होती है, और फ़ंक्शन 0 लौटाएगा।\n        - एक कार्यक्रम [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] के लिए, Jinjin सोमवार और\n          गुरुवार को समान रूप से दुखी होती है, लेकिन चूंकि सोमवार पहले आता है, इसलिए फ़ंक्शन 1 लौटाएगा।\n    \"\"\"",
      "hu": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Számítsd ki, hogy a hét melyik napján a legboldogtalanabb Jinjin az időbeosztása alapján.\n    \n    Jinjin boldogtalan, ha az iskolában és az extra órákon eltöltött összes idő meghaladja a napi 8 órát.\n    A függvény megkeresi azt a napot, amikor a boldogtalansága a legnagyobb, vagyis azt a napot, amikor\n    az összes óraszám a legjobban meghaladja a küszöböt. Ha több nap is azonos szintű maximális\n    boldogtalansággal bír, akkor a legkorábbi napot adja vissza. Ha Jinjin egyetlen napon sem boldogtalan,\n    a függvény 0-t ad vissza.\n    \n    Args:\n        schedule (list[tuple[int, int]]): Egy lista 7 darab párral, ahol minden pár az iskolában és az\n                                           extra órákon eltöltött órák számát jelenti a hét minden napjára\n                                           vonatkozóan.\n                                           \n    Returns:\n        int: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig) vagy 0, ha\n             soha nem boldogtalan.\n    \n    Esetek:\n        - Ha Jinjin időbeosztása a következő: [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          akkor a legboldogtalanabb szerdán (3. nap), így a függvény 3-at ad vissza.\n        - Ha az időbeosztása [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin soha nem\n          boldogtalan, és a függvény 0-t ad vissza.\n        - Egy olyan időbeosztásnál, mint [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin\n          egyformán boldogtalan hétfőn és csütörtökön, de mivel hétfő az első, a függvény 1-et ad vissza.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.983358746676897",
      "hy": "0.9697420381658124",
      "bn": "0.9621519740457072",
      "bg": "0.9823932043946865",
      "zh": "0.934526063390613",
      "fr": "0.9840090625444053",
      "de": "0.9859016128149057",
      "ha": "0.970969375290227",
      "hi": "0.9697172093681831",
      "hu": "0.9559636445245653"
    },
    "canonical_solution": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day",
    "instruction": {
      "en": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nSiguroni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nՏվեք Python կոդի հակիրճ բնութագրումը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nনিচের পাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nПредоставете кратко описание на Python кода на естествен език на български, използвайки най-много 500 символа.",
      "zh": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9269590403947078",
      "bn": "0.8739292971571565",
      "bg": "0.848836321121019",
      "zh": "0.8886474111310796",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9349860913530897",
      "hi": "0.9109764454151166",
      "hu": "0.9429881148834612"
    },
    "level": "",
    "test": "def test_find_most_unhappy_day():\n    # Test case 1: Provided example where Jinjin is most unhappy on Wednesday\n    schedule1 = [\n        (5, 3),\n        (6, 2),\n        (7, 2),\n        (5, 3),\n        (5, 4),\n        (0, 4),\n        (0, 6)\n    ]\n    assert find_most_unhappy_day(schedule1) == 3, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin is never unhappy\n    schedule2 = [\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule2) == 0, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin is most unhappy on Monday and Thursday, but Monday should be returned\n    schedule3 = [\n        (6, 3),\n        (6, 2),\n        (6, 2),\n        (6, 3),\n        (6, 2),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule3) == 1, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_find_most_unhappy_day()",
    "entry_point": "find_most_unhappy_day",
    "signature": "def find_most_unhappy_day(schedule) -> int:",
    "docstring": {
      "en": "Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n\nJinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day.\nThe function finds the day when her unhappiness is the greatest, which is the day when the total\nhours are the farthest above the threshold. If there are multiple days with the same level of\nmaximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the\nfunction returns 0.\n\nArgs:\nschedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the\nnumber of hours spent at school and in extra classes\nfor each day of the week, respectively.\n\nReturns:\nint: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0\nif she is never unhappy.\n\nCases:\n- If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nshe is most unhappy on Wednesday (day 3), so the function will return 3.\n- If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\nunhappy, and the function will return 0.\n- For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally\nunhappy on Monday and Thursday, but since Monday comes first, the function returns 1.",
      "sq": "Llogarit ditën e javës kur Jinjin është më e pakënaqur bazuar në orarin e saj.\n\nJinjin është e pakënaqur nëse orët totale të kaluara në shkollë dhe në klasa shtesë tejkalojnë 8 orë në një ditë. Funksioni gjen ditën kur pakënaqësia e saj është më e madhe, që është dita kur orët totale janë më të larta mbi pragun. Nëse ka disa ditë me të njëjtin nivel të pakënaqësisë maksimale, kthehet dita më e hershme. Nëse Jinjin nuk është e pakënaqur në asnjë ditë, funksioni kthen 0.\n\nArgumentet:\nschedule (list[tuple[int, int]]): Një listë me 7 tufa, ku çdo tufë përfaqëson\nnumrin e orëve të kaluara në shkollë dhe në klasa shtesë\npër çdo ditë të javës, respektivisht.\n\nKthen:\nint: Dita e javës kur Jinjin është më e pakënaqur (1-7 për të hënën deri të dielën) ose 0\nnëse ajo nuk është kurrë e pakënaqur.\n\nRastet:\n- Nëse Jinjin ka orarin e mëposhtëm [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\najo është më e pakënaqur të mërkurën (dita 3), kështu që funksioni do të kthejë 3.\n- Nëse orari i saj është [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin nuk është kurrë\ne pakënaqur, dhe funksioni do të kthejë 0.\n- Për një orar [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin është njësoj\ne pakënaqur të hënën dhe të enjten, por meqë e hëna vjen e para, funksioni kthen 1.",
      "hy": "Հաշվարկել այն շաբաթվա օրը, երբ Ջինջինը ամենից դժգոհ է իր ժամանակացույցի հիման վրա։\n\nՋինջինը դժգոհ է, եթե դպրոցում և լրացուցիչ դասերի վրա ծախսված ընդհանուր ժամերը գերազանցում են 8 ժամը մեկ օրվա ընթացքում։ Ֆունկցիան գտնում է այն օրը, երբ նրա դժգոհությունը առավելագույնն է, այսինքն՝ այն օրը, երբ ընդհանուր ժամերը ամենից շատ են գերազանցում շեմը։ Եթե կան մի քանի օրեր նույն մակարդակի առավելագույն դժգոհությամբ, վերադարձվում է ամենավաղ օրը։ Եթե Ջինջինը ոչ մի օր դժգոհ չէ, ֆունկցիան վերադարձնում է 0։\n\nԱրձագանքներ:\nschedule (list[tuple[int, int]]): 7 տուփերի ցուցակ, որտեղ յուրաքանչյուր տուփ ներկայացնում է\nդպրոցում և լրացուցիչ դասերի վրա ծախսված ժամերի քանակը\nշաբաթվա յուրաքանչյուր օրվա համար, համապատասխանաբար։\n\nՎերադարձնում է:\nint: Շաբաթվա օրը, երբ Ջինջինը ամենից դժգոհ է (1-7 երկուշաբթիից կիրակի) կամ 0,\nեթե նա երբեք դժգոհ չէ։\n\nՕրինակներ:\n- Եթե Ջինջինի ժամանակացույցը [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] է,\nնա ամենից դժգոհ է չորեքշաբթի (օր 3), ուստի ֆունկցիան կվերադարձնի 3։\n- Եթե նրա ժամանակացույցը [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] է, Ջինջինը երբեք\nդժգոհ չէ, և ֆունկցիան կվերադարձնի 0։\n- Ժամանակացույցի համար [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Ջինջինը հավասարապես\nդժգոհ է երկուշաբթի և հինգշաբթի, բայց քանի որ երկուշաբթին առաջինն է, ֆունկցիան կվերադարձնի 1։",
      "bn": "জিনজিনের সময়সূচির ভিত্তিতে সপ্তাহের কোন দিনটি সে সবচেয়ে অসুখী তা নির্ণয় করুন।\n\nজিনজিন সবচেয়ে অসুখী হয় যেদিন তার স্কুল এবং অতিরিক্ত ক্লাসে ব্যয় করা মোট সময় ৮ ঘণ্টার বেশি হয়। ফাংশনটি সেই দিনটি খুঁজে বের করে যেদিন তার অসুখী হওয়ার মাত্রা সবচেয়ে বেশি, অর্থাৎ যেদিন মোট সময় সীমার উপরে সবচেয়ে বেশি। যদি একই স্তরের সর্বাধিক অসুখী হওয়ার একাধিক দিন থাকে, তাহলে সবচেয়ে প্রথম দিনটি ফেরত দেওয়া হয়। যদি কোনও দিন জিনজিন অসুখী না হয়, তাহলে ফাংশনটি 0 ফেরত দেয়।\n\nArgs:\nschedule (list[tuple[int, int]]): ৭টি টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল\nপ্রতিনিধিত্ব করে প্রতিটি সপ্তাহের দিনের জন্য স্কুল এবং অতিরিক্ত ক্লাসে\nকত ঘণ্টা ব্যয় করা হয়েছে।\n\nReturns:\nint: সপ্তাহের দিন যেদিন জিনজিন সবচেয়ে অসুখী (১-৭ সোমবার থেকে রবিবার) অথবা ০\nযদি সে কখনও অসুখী না হয়।\n\nCases:\n- যদি জিনজিনের সময়সূচি হয় [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nতাহলে সে সবচেয়ে অসুখী বুধবার (দিন ৩) এ, তাই ফাংশনটি ৩ ফেরত দেবে।\n- যদি তার সময়সূচি হয় [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], জিনজিন কখনও\nঅসুখী নয়, এবং ফাংশনটি ০ ফেরত দেবে।\n- একটি সময়সূচির জন্য [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], জিনজিন সমানভাবে\nঅসুখী সোমবার এবং বৃহস্পতিবার, কিন্তু যেহেতু সোমবার প্রথম আসে, ফাংশনটি ১ ফেরত দেবে।",
      "bg": "Изчислете деня от седмицата, когато Джинджин е най-нещастна въз основа на нейния график.\n\nДжинджин е нещастна, ако общият брой часове, прекарани в училище и допълнителни часове, надвишава 8 часа на ден. Функцията намира деня, когато нейното нещастие е най-голямо, което е денят, когато общият брой часове е най-далеч над прага. Ако има няколко дни с едно и също ниво на максимално нещастие, се връща най-ранният ден. Ако Джинджин не е нещастна в нито един ден, функцията връща 0.\n\nАргументи:\nschedule (list[tuple[int, int]]): Списък от 7 кортежа, където всеки кортеж представлява\nброя часове, прекарани в училище и в допълнителни часове\nза всеки ден от седмицата, съответно.\n\nВръща:\nint: Денят от седмицата, когато Джинджин е най-нещастна (1-7 за понеделник до неделя) или 0\nако тя никога не е нещастна.\n\nПримери:\n- Ако Джинджин има следния график [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nтя е най-нещастна в сряда (ден 3), така че функцията ще върне 3.\n- Ако нейният график е [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Джинджин никога не е\nнещастна и функцията ще върне 0.\n- За график [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Джинджин е еднакво\nнещастна в понеделник и четвъртък, но тъй като понеделник идва първи, функцията връща 1.",
      "zh": "计算Jinjin在她的日程安排中最不开心的那一天。\n\n如果Jinjin在学校和额外课程中花费的总时间超过8小时，她会感到不开心。该函数找到她最不开心的那一天，即总时间超过阈值最多的那一天。如果有多天达到相同的最大不开心程度，则返回最早的一天。如果Jinjin在任何一天都不感到不开心，函数返回0。\n\n参数：\nschedule (list[tuple[int, int]]): 一个包含7个元组的列表，每个元组分别表示\n每周每天在学校和额外课程中花费的小时数。\n\n返回：\nint: Jinjin最不开心的那一天（1-7表示周一到周日）或0如果她从未感到不开心。\n\n案例：\n- 如果Jinjin的日程安排是[(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n她在星期三（第3天）最不开心，所以函数将返回3。\n- 如果她的日程安排是[(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]，Jinjin从未\n感到不开心，函数将返回0。\n- 对于日程安排[(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]，Jinjin在周一和周四同样\n不开心，但由于周一在前，函数返回1。",
      "fr": "Calculer le jour de la semaine où Jinjin est la plus malheureuse en fonction de son emploi du temps.\n\nJinjin est malheureuse si le total des heures passées à l'école et en cours supplémentaires dépasse 8 heures en une journée. La fonction trouve le jour où son malheur est le plus grand, c'est-à-dire le jour où le total des heures dépasse le plus le seuil. S'il y a plusieurs jours avec le même niveau de malheur maximal, le premier jour est retourné. Si Jinjin n'est malheureuse aucun jour, la fonction retourne 0.\n\nArgs:\nschedule (list[tuple[int, int]]): Une liste de 7 tuples, où chaque tuple représente le\nnombre d'heures passées à l'école et en cours supplémentaires\npour chaque jour de la semaine, respectivement.\n\nReturns:\nint: Le jour de la semaine où Jinjin est la plus malheureuse (1-7 pour lundi à dimanche) ou 0\nsi elle n'est jamais malheureuse.\n\nCases:\n- Si Jinjin a l'emploi du temps suivant [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nelle est la plus malheureuse le mercredi (jour 3), donc la fonction retournera 3.\n- Si son emploi du temps est [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin n'est jamais\nmalheureuse, et la fonction retournera 0.\n- Pour un emploi du temps [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin est également\nmalheureuse le lundi et le jeudi, mais comme le lundi vient en premier, la fonction retourne 1.",
      "de": "Berechne den Wochentag, an dem Jinjin am unglücklichsten ist, basierend auf ihrem Stundenplan.\n\nJinjin ist unglücklich, wenn die Gesamtstunden, die sie in der Schule und in zusätzlichen Kursen verbringt, an einem Tag 8 Stunden überschreiten. Die Funktion findet den Tag, an dem ihr Unglück am größten ist, was der Tag ist, an dem die Gesamtstunden am weitesten über dem Schwellenwert liegen. Wenn es mehrere Tage mit dem gleichen Maß an maximalem Unglück gibt, wird der früheste Tag zurückgegeben. Wenn Jinjin an keinem Tag unglücklich ist, gibt die Funktion 0 zurück.\n\nArgs:\nschedule (list[tuple[int, int]]): Eine Liste von 7 Tupeln, wobei jedes Tupel die Anzahl der Stunden darstellt, die in der Schule und in zusätzlichen Kursen verbracht werden, jeweils für jeden Tag der Woche.\n\nReturns:\nint: Der Wochentag, an dem Jinjin am unglücklichsten ist (1-7 für Montag bis Sonntag) oder 0, wenn sie nie unglücklich ist.\n\nFälle:\n- Wenn Jinjin den folgenden Stundenplan hat [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)], ist sie am unglücklichsten am Mittwoch (Tag 3), daher wird die Funktion 3 zurückgeben.\n- Wenn ihr Stundenplan [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] ist, ist Jinjin nie unglücklich, und die Funktion wird 0 zurückgeben.\n- Für einen Stundenplan [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] ist Jinjin gleichermaßen unglücklich am Montag und Donnerstag, aber da Montag zuerst kommt, gibt die Funktion 1 zurück.",
      "ha": "Lissafa ranar mako da Jinjin take mafi rashin jin daɗi bisa ga jadawalin ta.\n\nJinjin tana cikin rashin jin daɗi idan jimillar awanni da aka kashe a makaranta da ƙarin aji sun wuce awanni 8 a rana. Aikin yana gano ranar da rashin jin daɗinta ya fi tsanani, wato ranar da jimillar awanni suka fi nisa daga matakin. Idan akwai ranaku da yawa da suke da irin wannan matakin na rashin jin daɗi, ranar farko za a dawo da ita. Idan Jinjin ba ta cikin rashin jin daɗi a kowace rana, aikin yana dawo da 0.\n\nArgs:\nschedule (list[tuple[int, int]]): Jerin tuples guda 7, inda kowanne tuple ke wakiltar\nyawan awanni da aka kashe a makaranta da kuma a ƙarin aji\ndon kowace rana ta mako, bi da bi.\n\nReturns:\nint: Ranar mako inda Jinjin ta fi rashin jin daɗi (1-7 don Litinin zuwa Lahadi) ko 0\nidan ba ta taɓa rashin jin daɗi ba.\n\nCases:\n- Idan Jinjin tana da jadawalin mai zuwa [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nta fi rashin jin daɗi a ranar Laraba (rana ta 3), don haka aikin zai dawo da 3.\n- Idan jadawalinta shi ne [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin ba ta taɓa\nrashin jin daɗi ba, kuma aikin zai dawo da 0.\n- Don jadawalin [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin tana da\nrashin jin daɗi iri ɗaya a ranar Litinin da Alhamis, amma tun da Litinin ta fara zuwa, aikin zai dawo da 1.",
      "hi": "सप्ताह के उस दिन की गणना करें जब जिनजिन अपने कार्यक्रम के आधार पर सबसे अधिक दुखी होती है।\n\nजिनजिन तब दुखी होती है जब स्कूल और अतिरिक्त कक्षाओं में बिताए गए कुल घंटे एक दिन में 8 घंटे से अधिक होते हैं। यह फ़ंक्शन उस दिन को खोजता है जब उसकी उदासी सबसे अधिक होती है, जो वह दिन होता है जब कुल घंटे सीमा से सबसे अधिक ऊपर होते हैं। यदि अधिकतम उदासी के समान स्तर वाले कई दिन हैं, तो सबसे पहला दिन लौटाया जाता है। यदि जिनजिन किसी भी दिन दुखी नहीं है, तो फ़ंक्शन 0 लौटाता है।\n\nआर्ग्स:\nschedule (list[tuple[int, int]]): 7 ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल क्रमशः सप्ताह के प्रत्येक दिन के लिए स्कूल और अतिरिक्त कक्षाओं में बिताए गए घंटों की संख्या का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\nint: सप्ताह का वह दिन जब जिनजिन सबसे अधिक दुखी होती है (सोमवार से रविवार के लिए 1-7) या 0 यदि वह कभी दुखी नहीं होती।\n\nमामले:\n- यदि जिनजिन का कार्यक्रम निम्नलिखित है [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)], तो वह बुधवार (दिन 3) को सबसे अधिक दुखी होती है, इसलिए फ़ंक्शन 3 लौटाएगा।\n- यदि उसका कार्यक्रम [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] है, तो जिनजिन कभी दुखी नहीं होती, और फ़ंक्शन 0 लौटाएगा।\n- एक कार्यक्रम [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] के लिए, जिनजिन सोमवार और गुरुवार को समान रूप से दुखी होती है, लेकिन चूंकि सोमवार पहले आता है, इसलिए फ़ंक्शन 1 लौटाएगा।",
      "hu": "Számítsuk ki, hogy Jinjin melyik napon a legboldogtalanabb a beosztása alapján.\n\nJinjin boldogtalan, ha az iskolában és a különórákon töltött összes órák száma meghaladja a napi 8 órát. A függvény megkeresi azt a napot, amikor a boldogtalansága a legnagyobb, vagyis azt a napot, amikor az összóraszám a legjobban meghaladja a küszöböt. Ha több nap is azonos szintű maximális boldogtalansággal bír, akkor a legkorábbi napot adja vissza. Ha Jinjin egyetlen napon sem boldogtalan, a függvény 0-t ad vissza.\n\nArgs:\nschedule (list[tuple[int, int]]): Egy 7 elemből álló lista, ahol minden egyes elem egy\npár, amely az iskolában és a különórákon töltött órák számát\nképviseli a hét minden napjára vonatkozóan.\n\nReturns:\nint: A hét azon napja, amikor Jinjin a legboldogtalanabb (1-7 hétfőtől vasárnapig) vagy 0,\nha soha nem boldogtalan.\n\nEsetek:\n- Ha Jinjin beosztása a következő: [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nakkor szerdán (3. nap) a legboldogtalanabb, így a függvény 3-at ad vissza.\n- Ha a beosztása [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin soha nem\nboldogtalan, és a függvény 0-t ad vissza.\n- Egy beosztás esetén [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin egyformán\nboldogtalan hétfőn és csütörtökön, de mivel hétfő az első, a függvény 1-et ad vissza."
    },
    "docstring_bertscore": {
      "sq": "0.9699080931643576",
      "hy": "0.9555322193369575",
      "bn": "0.9726865349342736",
      "bg": "0.9816252993416056",
      "zh": "0.9361862161153025",
      "fr": "0.9808609696353834",
      "de": "0.98635925721281",
      "ha": "0.9674667271510577",
      "hi": "0.9863280722429876",
      "hu": "0.9396658231302717"
    }
  },
  {
    "task_id": "Python/43",
    "prompt": {
      "en": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "sq": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transformon permutacionin hyrës në permutacionin e radhës në rend leksikografik.\n    \n    Funksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek \n    dhe e shkëmben atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj kthen \n    rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutacioni i fundit \n    (në rend zbritës), funksioni kthen False, duke treguar se asnjë permutacion i radhës nuk është i mundur.\n    \n    Args:\n    perm (list): Një listë e numrave të plotë që përfaqëson permutacionin aktual.\n    \n    Returns:\n    bool: True nëse permutacioni u transformua me sukses, False nëse ishte permutacioni i fundit.\n    \n    Shembuj:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "hy": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Փոխակերպում է մուտքային փոխադրությունը հաջորդ փոխադրության դեպի բառարանային կարգով:\n    \n    Ֆունկցիան գտնում է առաջին թիվը վերջից, որը փոքր է իրեն հաջորդող թվից և փոխանակում է այն \n    ամենափոքր թվի հետ, որը մեծ է և գտնվում է դրանից հետո: Այնուհետև այն շրջում է թվերի \n    կարգը սկզբնական առաջին փոքր թվից հետո: Եթե մուտքը վերջին փոխադրությունն է (նվազող կարգով), \n    ֆունկցիան վերադարձնում է False, ցույց տալով, որ հաջորդ փոխադրությունը հնարավոր չէ:\n    \n    Պարամետրեր:\n    perm (list): Ցուցակ ամբողջ թվերի, որը ներկայացնում է ընթացիկ փոխադրությունը:\n    \n    Վերադարձնում է:\n    bool: True, եթե փոխադրությունը հաջողությամբ փոխակերպվել է, False, եթե դա վերջին փոխադրությունն էր:\n    \n    Օրինակներ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "bn": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    ইনপুট পারমুটেশনকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী পারমুটেশনে রূপান্তর করে।\n\n    ফাংশনটি শেষ থেকে প্রথম সংখ্যাটি খুঁজে পায় যা তার পরবর্তী সংখ্যার থেকে ছোট \n    এবং এটি এমন একটি ছোট সংখ্যার সাথে অদলবদল করে যা বড় এবং এর পরে আসে। তারপর এটি \n    মূল প্রথম ছোট সংখ্যার পরে সংখ্যাগুলির ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ পারমুটেশন হয় \n    (অবতরণ ক্রমে), ফাংশনটি False ফেরত দেয়, যা নির্দেশ করে যে কোনও পরবর্তী পারমুটেশন সম্ভব নয়।\n\n    Args:\n    perm (list): বর্তমান পারমুটেশন উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    Returns:\n    bool: যদি পারমুটেশন সফলভাবে রূপান্তরিত হয় তবে True, যদি এটি শেষ পারমুটেশন হয় তবে False।\n\n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "bg": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Преобразува входната пермутация в следващата пермутация в лексикографски ред.\n    \n    Функцията намира първото число от края, което е по-малко от следващото число \n    и го разменя с най-малкото число, което е по-голямо и идва след него. След това обръща \n    реда на числата след оригиналното първо по-малко число. Ако входът е последната пермутация \n    (в низходящ ред), функцията връща False, което показва, че няма възможна следваща пермутация.\n    \n    Аргументи:\n    perm (list): Списък от цели числа, представляващи текущата пермутация.\n    \n    Връща:\n    bool: True ако пермутацията беше успешно преобразувана, False ако беше последната пермутация.\n    \n    Примери:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "zh": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    将输入的排列转换为字典序中的下一个排列。\n    \n    该函数从末尾开始找到第一个小于其后面数字的数字，并将其与后面比它大的最小数字交换。\n    然后反转原始第一个较小数字之后的数字顺序。如果输入是最后一个排列（降序排列），\n    函数返回False，表示没有下一个排列。\n    \n    参数:\n    perm (list): 一个整数列表，表示当前排列。\n    \n    返回:\n    bool: 如果排列成功转换，返回True；如果是最后一个排列，返回False。\n    \n    示例:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "fr": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n    \n    La fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit \n    et l'échange avec le plus petit nombre qui est plus grand et vient après lui. Ensuite, elle inverse \n    l'ordre des nombres après le premier nombre plus petit d'origine. Si l'entrée est la dernière permutation \n    (dans l'ordre décroissant), la fonction retourne False, indiquant qu'aucune permutation suivante n'est possible.\n    \n    Args:\n    perm (list): Une liste d'entiers représentant la permutation actuelle.\n    \n    Returns:\n    bool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "de": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transformiert die Eingabepermutation in die nächste Permutation in lexikographischer Reihenfolge.\n    \n    Die Funktion findet die erste Zahl von hinten, die kleiner ist als die folgende Zahl, \n    und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die \n    Reihenfolge der Zahlen nach der ursprünglichen ersten kleineren Zahl um. Wenn die Eingabe die \n    letzte Permutation ist (in absteigender Reihenfolge), gibt die Funktion False zurück, was \n    anzeigt, dass keine nächste Permutation möglich ist.\n    \n    Argumente:\n    perm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n    \n    Rückgabewerte:\n    bool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n    \n    Beispiele:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "ha": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Canza shigarwar permutation zuwa permutation na gaba a cikin tsari na lexicographic.\n    \n    Aikin yana nemo lambar farko daga ƙarshe wadda ta fi ƙarami fiye da lambar da ke biyo baya \n    kuma yana musanya ta da mafi ƙarancin lamba wadda ta fi girma kuma ta zo bayan ta. Sannan yana jujjuya \n    tsarin lambobin bayan asalin lambar farko mafi ƙarami. Idan shigarwar ita ce permutation na ƙarshe \n    (a cikin tsari mai saukarwa), aikin yana dawowa da False, yana nuna babu wani permutation na gaba da zai yiwu.\n    \n    Args:\n    perm (list): Jerin lambobi masu wakiltar permutation na yanzu.\n    \n    Returns:\n    bool: True idan an yi nasarar canza permutation, False idan ita ce permutation na ƙarshe.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "hi": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    इनपुट क्रमचय को लेक्सिकोग्राफिक क्रम में अगले क्रमचय में बदलता है।\n    \n    यह फ़ंक्शन अंत से पहला ऐसा नंबर ढूंढता है जो उसके बाद आने वाले नंबर से छोटा होता है \n    और उसे सबसे छोटे नंबर से बदलता है जो बड़ा होता है और उसके बाद आता है। फिर यह \n    मूल पहले छोटे नंबर के बाद के नंबरों के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय \n    (अवरोही क्रम में) है, तो फ़ंक्शन False लौटाता है, जो इंगित करता है कि कोई अगला क्रमचय संभव नहीं है।\n    \n    Args:\n    perm (list): पूर्णांकों की एक सूची जो वर्तमान क्रमचय का प्रतिनिधित्व करती है।\n    \n    Returns:\n    bool: True यदि क्रमचय को सफलतापूर्वक बदला गया, False यदि यह अंतिम क्रमचय था।\n    \n    उदाहरण:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "hu": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Az input permutációt átalakítja a következő permutációvá lexikografikus sorrendben.\n    \n    A függvény megkeresi az első számot a végéről, amely kisebb, mint az utána következő szám, \n    és kicseréli a legkisebb, nála nagyobb számmal, amely utána következik. Ezután megfordítja \n    az eredeti első kisebb szám utáni számok sorrendjét. Ha az input a legutolsó permutáció \n    (csökkenő sorrendben), a függvény False értéket ad vissza, jelezve, hogy nincs következő permutáció.\n    \n    Args:\n    perm (list): Egész számokat tartalmazó lista, amely a jelenlegi permutációt képviseli.\n    \n    Returns:\n    bool: True, ha a permutációt sikeresen átalakították, False, ha ez volt az utolsó permutáció.\n    \n    Példák:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9668442195368944",
      "hy": "0.953120647880813",
      "bn": "0.9901318440398057",
      "bg": "0.9851825708355594",
      "zh": "0.9659052937257425",
      "fr": "0.9910938109751577",
      "de": "0.980573750104407",
      "ha": "0.9770401156257963",
      "hi": "0.9892252949807625",
      "hu": "0.9816876692812505"
    },
    "canonical_solution": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True",
    "instruction": {
      "en": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Python կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nনিচের পাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyar nyelven, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8860334353166605",
      "bn": "0.8657447323066139",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9217489655001627",
      "hi": "0.91110952777041",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_next_permutation():\n    # Test case 1: ordinary case\n    perm1 = [1, 2, 3]\n    assert next_permutation(perm1) == True, \"Test case 1 failed: next_permutation([1, 2, 3]) should return True\"\n    assert perm1 == [1, 3, 2], \"Test case 1 failed: perm1 should be [1, 3, 2]\"\n    \n    # Test case 2: last permutation, should return False\n    perm2 = [3, 2, 1]\n    assert next_permutation(perm2) == False, \"Test case 2 failed: next_permutation([3, 2, 1]) should return False\"\n    assert perm2 == [3, 2, 1], \"Test case 2 failed: perm2 should be [3, 2, 1] (unchanged)\"\n    \n    # Test case 3: permutation with repeated elements\n    perm3 = [1, 5, 1]\n    assert next_permutation(perm3) == True, \"Test case 3 failed: next_permutation([1, 5, 1]) should return True\"\n    assert perm3 == [5, 1, 1], \"Test case 3 failed: perm3 should be [5, 1, 1]\"\n\n    # Test case 4: permutation with all elements equal\n    perm4 = [1, 1, 1]\n    assert next_permutation(perm4) == False, \"Test case 4 failed: next_permutation([1, 1, 1]) should return False\"\n    assert perm4 == [1, 1, 1], \"Test case 4 failed: perm4 should be [1, 1, 1] (unchanged)\"\n    \n    # Test case 5: permutation with only one element\n    perm5 = [42]\n    assert next_permutation(perm5) == False, \"Test case 5 failed: next_permutation([42]) should return False\"\n    assert perm5 == [42], \"Test case 5 failed: perm5 should be [42] (unchanged)\"\n    \n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_next_permutation()",
    "entry_point": "next_permutation",
    "signature": "def next_permutation(perm: list) -> bool:",
    "docstring": {
      "en": "Transforms the input permutation to the next permutation in lexicographic order.\n\nThe function finds the first number from the end that is smaller than the number following it\nand swaps it with the smallest number that is larger and comes after it. Then it reverses the\norder of numbers after the original first smaller number. If the input is the last permutation\n(in descending order), the function returns False, indicating no next permutation is possible.\n\nArgs:\nperm (list): A list of integers representing the current permutation.\n\nReturns:\nbool: True if the permutation was successfully transformed, False if it was the last permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "sq": "Transformon permutimin hyrës në permutimin e radhës në rend leksikografik.\n\nFunksioni gjen numrin e parë nga fundi që është më i vogël se numri që e ndjek atë dhe e ndërron atë me numrin më të vogël që është më i madh dhe vjen pas tij. Pastaj e kthen rendin e numrave pas numrit të parë origjinal më të vogël. Nëse hyrja është permutimi i fundit (në rend zbritës), funksioni kthen False, duke treguar se nuk është e mundur një permutim tjetër.\n\nArgumentet:\nperm (listë): Një listë e numrave të plotë që përfaqëson permutimin aktual.\n\nKthen:\nbool: True nëse permutimi u transformua me sukses, False nëse ishte permutimi i fundit.\n\nShembuj:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "hy": "Վերափոխում է մուտքային փոխատեղումը հաջորդ փոխատեղման դեպի բառարանային կարգով:\n\nՖունկցիան գտնում է առաջին թիվը վերջից, որը փոքր է իրեն հաջորդող թվից և փոխանակում այն ամենափոքր թվի հետ, որը մեծ է և գալիս է դրանից հետո: Այնուհետև այն շրջում է թվերի կարգը սկզբնական առաջին փոքր թվից հետո: Եթե մուտքը վերջին փոխատեղումն է (նվազող կարգով), ֆունկցիան վերադարձնում է False, նշելով, որ հաջորդ փոխատեղումը հնարավոր չէ:\n\nԱրձագանքներ:\nperm (list): Թվերի ցուցակ, որը ներկայացնում է ընթացիկ փոխատեղումը:\n\nՎերադարձնում է:\nbool: True, եթե փոխատեղումը հաջողությամբ վերափոխվել է, False, եթե դա վերջին փոխատեղումն էր:\n\nՕրինակներ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "bn": "ইনপুট পারমুটেশনকে লেক্সিকোগ্রাফিক ক্রমে পরবর্তী পারমুটেশনে রূপান্তর করে।\n\nফাংশনটি শেষ থেকে প্রথম যে সংখ্যাটি তার পরবর্তী সংখ্যার চেয়ে ছোট সেটি খুঁজে বের করে এবং এটি তার পরবর্তী সবচেয়ে ছোট বড় সংখ্যার সাথে অদলবদল করে। তারপর এটি মূল প্রথম ছোট সংখ্যার পরের সংখ্যাগুলোর ক্রম উল্টে দেয়। যদি ইনপুটটি শেষ পারমুটেশন হয় (অবনমিত ক্রমে), তাহলে ফাংশনটি False রিটার্ন করে, যা নির্দেশ করে যে কোনো পরবর্তী পারমুটেশন সম্ভব নয়।\n\nআর্গস:\nperm (list): পূর্ণসংখ্যার একটি তালিকা যা বর্তমান পারমুটেশনকে উপস্থাপন করে।\n\nরিটার্নস:\nbool: যদি পারমুটেশন সফলভাবে রূপান্তরিত হয় তাহলে True, যদি এটি শেষ পারমুটেশন হয় তাহলে False।\n\nউদাহরণ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "bg": "Трансформира входната пермутация към следващата пермутация в лексикографски ред.\n\nФункцията намира първото число от края, което е по-малко от следващото число и го разменя с най-малкото число, което е по-голямо и идва след него. След това обръща реда на числата след оригиналното първо по-малко число. Ако входът е последната пермутация (в низходящ ред), функцията връща False, което означава, че не е възможна следваща пермутация.\n\nАргументи:\nperm (list): Списък от цели числа, представляващ текущата пермутация.\n\nВръща:\nbool: True, ако пермутацията беше успешно трансформирана, False, ако беше последната пермутация.\n\nПримери:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "zh": "将输入排列转换为字典序中的下一个排列。\n\n该函数从末尾开始找到第一个小于其后面的数字的数字，并将其与后面最小的且大于它的数字交换。然后反转原始第一个较小数字之后的数字顺序。如果输入是最后一个排列（降序排列），函数返回 False，表示没有下一个排列可能。\n\n参数：\nperm (list): 一个整数列表，表示当前排列。\n\n返回：\nbool: 如果排列成功转换，返回 True；如果是最后一个排列，返回 False。\n\n示例：\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "fr": "Transforme la permutation d'entrée en la permutation suivante dans l'ordre lexicographique.\n\nLa fonction trouve le premier nombre depuis la fin qui est plus petit que le nombre qui le suit\net l'échange avec le plus petit nombre qui est plus grand et vient après lui. Ensuite, elle inverse l'ordre des nombres après le premier nombre plus petit d'origine. Si l'entrée est la dernière permutation (en ordre décroissant), la fonction renvoie False, indiquant qu'aucune permutation suivante n'est possible.\n\nArgs:\nperm (list): Une liste d'entiers représentant la permutation actuelle.\n\nReturns:\nbool: True si la permutation a été transformée avec succès, False si c'était la dernière permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "de": "Transformiert die Eingabepermutation in die nächste Permutation in lexikographischer Reihenfolge.\n\nDie Funktion findet die erste Zahl vom Ende her, die kleiner ist als die ihr folgende Zahl, und tauscht sie mit der kleinsten Zahl, die größer ist und danach kommt. Dann kehrt sie die Reihenfolge der Zahlen nach der ursprünglichen ersten kleineren Zahl um. Wenn die Eingabe die letzte Permutation (in absteigender Reihenfolge) ist, gibt die Funktion False zurück, was anzeigt, dass keine nächste Permutation möglich ist.\n\nArgs:\nperm (list): Eine Liste von ganzen Zahlen, die die aktuelle Permutation darstellt.\n\nReturns:\nbool: True, wenn die Permutation erfolgreich transformiert wurde, False, wenn es die letzte Permutation war.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "ha": "Canza shigarwar permutation zuwa permutation na gaba a cikin tsari na lexicographic.\n\nAikin yana nemo lambar farko daga ƙarshe wadda ta fi ƙarami fiye da lambar da ke binta\nkuma yana musanya ta da lambar mafi ƙaranci wadda ta fi girma kuma tana zuwa bayan ta. Sannan yana juyar da\ntsarin lambobin bayan lambar farko mafi ƙaranci ta asali. Idan shigarwar ita ce permutation na ƙarshe\n(a cikin tsari mai sauka), aikin yana dawowa da False, yana nuna babu wani permutation na gaba da zai yiwu.\n\nArgs:\nperm (list): Jerin lambobi masu nuna permutation na yanzu.\n\nReturns:\nbool: True idan an yi nasarar sauya permutation, False idan ita ce permutation na ƙarshe.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "hi": "इनपुट क्रमचय को शब्दकोशीय क्रम में अगले क्रमचय में बदलता है।\n\nयह फ़ंक्शन अंत से पहला ऐसा संख्या ढूंढता है जो उसके बाद आने वाले संख्या से छोटा हो और उसे उसके बाद आने वाले सबसे छोटे और बड़े संख्या के साथ अदला-बदली करता है। फिर यह मूल पहले छोटे संख्या के बाद के संख्याओं के क्रम को उलट देता है। यदि इनपुट अंतिम क्रमचय है (अवरोही क्रम में), तो फ़ंक्शन False लौटाता है, यह दर्शाते हुए कि कोई अगला क्रमचय संभव नहीं है।\n\nआर्ग्स:\nperm (list): पूर्णांकों की एक सूची जो वर्तमान क्रमचय का प्रतिनिधित्व करती है।\n\nरिटर्न्स:\nbool: True यदि क्रमचय को सफलतापूर्वक बदला गया, False यदि यह अंतिम क्रमचय था।\n\nउदाहरण:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "hu": "Átalakítja a bemeneti permutációt a következő permutációvá lexikografikus sorrendben.\n\nA függvény megkeresi a végétől az első számot, amely kisebb, mint az utána következő szám, és kicseréli azt a legkisebb számmal, amely nagyobb és utána következik. Ezután megfordítja az eredeti első kisebb szám utáni számok sorrendjét. Ha a bemenet az utolsó permutáció (csökkenő sorrendben), a függvény False értéket ad vissza, jelezve, hogy nincs lehetséges következő permutáció.\n\nArgs:\nperm (list): Egész számok listája, amely a jelenlegi permutációt képviseli.\n\nReturns:\nbool: True, ha a permutációt sikeresen átalakították, False, ha az utolsó permutáció volt.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.9840835489372933",
      "hy": "0.9829922736238877",
      "bn": "0.9657978346896026",
      "bg": "0.9797327490711052",
      "zh": "0.9683206391591267",
      "fr": "0.9871098814227409",
      "de": "0.9899502958715398",
      "ha": "0.9786077065929236",
      "hi": "0.9735267414460511",
      "hu": "0.9832626095724761"
    }
  },
  {
    "task_id": "Python/44",
    "prompt": {
      "en": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin runs out of money in July (the 7th month)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin has 1580 units of currency by the end of the year\n    \"\"\"",
      "sq": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\n    pas ndjekjes së planit të saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\n    shumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon të ketë\n    të paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\n    interes në fund të vitit.\n\n    Parametrat:\n    budgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\n    Kthen:\n    int: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\n         Nëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\n         atij muaji (-X, ku X është numri i muajit).\n\n    Shembuj:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin mbetet pa para në korrik (muaji i 7-të)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin ka 1580 njësi të monedhës deri në fund të vitit\n    \"\"\"",
      "hy": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Հաշվարկում է այն գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում\n    իր մոր հետ խնայողությունների պլանը հետևելուց հետո: Ամեն ամիս, նա կարող է խնայել\n    100-ի բազմապատիկները իր գրպանի գումարից (300 ամեն ամիս), եթե կանխատեսում է, որ\n    ծախսերից հետո կունենա առնվազն 100 միավոր: Խնայված գումարը կստանա 20%\n    տոկոսադրույք տարվա վերջում:\n\n    Պարամետրեր:\n    budgets (List[int]): Ցուցակ 12 ամբողջ թվերից, որոնք ներկայացնում են Ջինջինի ամսական բյուջեն:\n\n    Վերադարձնում է:\n    int: Գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում տոկոսադրույքից հետո:\n         Եթե Ջինջինը որևէ ամսում գումարից դուրս է գալիս, վերադարձնում է\n         այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարն է):\n\n    Օրինակներ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Ջինջինը գումարից դուրս է գալիս հուլիսին (7-րդ ամիս)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Ջինջինը տարվա վերջում ունի 1580 միավոր արժույթ\n    \"\"\"",
      "bn": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    বছরের শেষে জিনজিনের মোট কত টাকা থাকবে তা গণনা করে\n    তার মায়ের সাথে তার সঞ্চয় পরিকল্পনা অনুসরণ করার পরে। প্রতি মাসে, সে তার\n    পকেট মানি (প্রতি মাসে 300) থেকে 100 এর গুণিতক সঞ্চয় করতে পারে যদি সে\n    খরচের পরে কমপক্ষে 100 ইউনিট অবশিষ্ট থাকার পূর্বাভাস দেয়। সঞ্চিত টাকা বছরের শেষে 20%\n    সুদ অর্জন করবে।\n\n    প্যারামিটার:\n    budgets (List[int]): ১২টি পূর্ণসংখ্যার একটি তালিকা যা জিনজিনের মাসিক বাজেট উপস্থাপন করে।\n\n    রিটার্নস:\n    int: বছরের শেষে সুদের পরে জিনজিনের মোট কত টাকা থাকবে।\n         যদি জিনজিন কোনো মাসে টাকা শেষ করে ফেলে, তবে সেই মাসের ঋণাত্মক মান (-X, যেখানে X মাসের সংখ্যা) ফেরত দেয়।\n\n    উদাহরণ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # জিনজিন জুলাই মাসে (৭ম মাস) টাকা শেষ করে ফেলে\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # বছরের শেষে জিনজিনের 1580 ইউনিট মুদ্রা থাকে\n    \"\"\"",
      "bg": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Изчислява общата сума пари, която Джинджин ще има в края на годината\n    след като следва своя план за спестявания с майка си. Всеки месец тя може да спести\n    кратни на 100 от джобните си пари (300 на месец), ако предвижда да има\n    поне 100 единици, останали след разходите. Спестените пари ще получат 20%\n    лихва в края на годината.\n\n    Параметри:\n    budgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\n    Връща:\n    int: Общата сума пари, която Джинджин ще има в края на годината след лихвата.\n         Ако Джинджин остане без пари в който и да е месец, връща отрицателната стойност на\n         този месец (-X, където X е номерът на месеца).\n\n    Примери:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Джинджин остава без пари през юли (7-ми месец)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Джинджин има 1580 единици валута в края на годината\n    \"\"\"",
      "zh": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    计算金金在年底按照她和她母亲的储蓄计划后将拥有的总金额。每个月，如果她预测在支出后至少剩余100单位，她可以从她的零花钱（每月300）中存入100的倍数。存入的钱将在年底获得20%的利息。\n\n    参数：\n    budgets (List[int]): 一个包含12个整数的列表，表示金金每个月的预算。\n\n    返回：\n    int: 年底金金在利息后将拥有的总金额。\n         如果金金在任何一个月用完了钱，返回该月份的负值（-X，其中X是月份编号）。\n\n    示例：\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # 金金在七月（第7个月）用完了钱\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # 年底金金有1580单位的货币\n    \"\"\"",
      "fr": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calcule le montant total d'argent que Jinjin aura à la fin de l'année\n    après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut économiser\n    des multiples de 100 de son argent de poche (300 par mois) si elle prévoit d'avoir\n    au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20%\n    d'intérêt à la fin de l'année.\n\n    Paramètres:\n    budgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\n    Renvoie:\n    int: Le montant total d'argent que Jinjin aura à la fin de l'année après les intérêts.\n         Si Jinjin manque d'argent à un moment donné du mois, renvoie la valeur négative\n         de ce mois (-X, où X est le numéro du mois).\n\n    Exemples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin manque d'argent en juillet (le 7ème mois)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin a 1580 unités de monnaie à la fin de l'année\n    \"\"\"",
      "de": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Berechnet den Gesamtbetrag an Geld, den Jinjin am Ende des Jahres haben wird,\n    nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie\n    Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie\n    voraussieht, dass nach den Ausgaben mindestens 100 Einheiten übrig bleiben.\n    Das gesparte Geld wird am Ende des Jahres 20% Zinsen erhalten.\n\n    Parameter:\n    budgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\n    Rückgabe:\n    int: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird.\n         Wenn Jinjin in einem bestimmten Monat kein Geld mehr hat, wird der negative Wert\n         dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\n    Beispiele:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin hat im Juli (dem 7. Monat) kein Geld mehr\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin hat am Ende des Jahres 1580 Währungseinheiten\n    \"\"\"",
      "ha": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\n    bayan bin shirin ajiyar kuɗi tare da mahaifiyarta. Kowace wata, za ta iya ajiye\n    sau na 100 daga cikin kuɗin aljihunta (300 a kowane wata) idan ta hango samun\n    aƙalla 100 saura bayan kashe kuɗi. Kuɗin da aka ajiye zai samu riba 20%\n    a ƙarshen shekara.\n\n    Sigogi:\n    budgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n\n    Abin da ake dawowa da shi:\n    int: Jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba.\n         Idan Jinjin ta ƙare da kuɗi a kowanne wata, za a dawo da ƙimar da ta yi\n         rashin kuɗi a watan (-X, inda X shine lambar watan).\n\n    Misalai:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin ta ƙare da kuɗi a watan Yuli (wata na 7)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin tana da 1580 na kuɗi a ƙarshen shekara\n    \"\"\"",
      "hi": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    वर्ष के अंत तक Jinjin के पास कुल कितनी राशि होगी, इसकी गणना करता है\n    अपनी माँ के साथ उसकी बचत योजना का पालन करने के बाद। प्रत्येक महीने, वह\n    अपनी पॉकेट मनी (प्रति माह 300) से 100 के गुणकों की बचत कर सकती है यदि वह\n    खर्चों के बाद कम से कम 100 इकाइयाँ बचने की भविष्यवाणी करती है। बचाई गई राशि\n    को वर्ष के अंत में 20% ब्याज प्राप्त होगा।\n\n    पैरामीटर्स:\n    budgets (List[int]): Jinjin के मासिक बजट का प्रतिनिधित्व करने वाले 12 पूर्णांकों की सूची।\n\n    रिटर्न्स:\n    int: वर्ष के अंत में ब्याज के बाद Jinjin के पास कुल कितनी राशि होगी।\n         यदि Jinjin किसी भी महीने में पैसे से बाहर हो जाती है, तो उस महीने का\n         नकारात्मक मान लौटाता है (-X, जहाँ X महीने का नंबर है)।\n\n    उदाहरण:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin जुलाई (7वां महीना) में पैसे से बाहर हो जाती है\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # वर्ष के अंत तक Jinjin के पास 1580 मुद्रा इकाइयाँ हैं\n    \"\"\"",
      "hu": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Kiszámítja, hogy mennyi pénze lesz Jinjinnek az év végére,\n    miután követi a megtakarítási tervét az anyukájával. Minden hónapban\n    100 többszöröseit tudja megtakarítani a zsebpénzéből (havonta 300),\n    ha előre látja, hogy legalább 100 egység marad a kiadások után. A megtakarított\n    pénz 20%-os kamatot kap az év végén.\n\n    Paraméterek:\n    budgets (List[int]): Egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelöli.\n\n    Visszatérési érték:\n    int: Az év végére Jinjin által birtokolt teljes pénzösszeg a kamatokkal együtt.\n         Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor az adott hónap negatív\n         értékével tér vissza (-X, ahol X a hónap száma).\n\n    Példák:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin kifogy a pénzből júliusban (a 7. hónapban)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjinnek 1580 pénzegysége van az év végére\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9878742111289632",
      "hy": "0.9685071530869185",
      "bn": "0.9869193948873285",
      "bg": "0.9842347066572609",
      "zh": "0.9615823021128992",
      "fr": "0.9808699080025299",
      "de": "0.9672565762079228",
      "ha": "0.9556919181633096",
      "hi": "0.9741816258123231",
      "hu": "0.9762471831447049"
    },
    "canonical_solution": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money",
    "instruction": {
      "en": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nՏվեք Python կոդի հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\n请用中文为以下Python代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nFournir une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nBa da taƙaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9269590403947078",
      "bn": "0.8842060358111395",
      "bg": "0.8983697723915943",
      "zh": "0.8886474111310796",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9404883515381371",
      "hi": "0.8869427652010382",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_jinjin_savings_plan():\n    # Test case 1: Jinjin runs out of money in July (the 7th month)\n    budgets1 = [290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets1) == -7, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin has 1580 units of currency by the end of the year\n    budgets2 = [290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets2) == 1580, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin manages her budget perfectly and has a specific amount by the end\n    budgets3 = [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]\n    assert jinjin_savings_plan(budgets3) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Jinjin does not need to save any money and spends exactly the amount she receives\n    budgets4 = [300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190]\n    assert jinjin_savings_plan(budgets4) == 780, \"Test case 4 failed\"\n\n    # Test case 5: Jinjin runs out of money in the first month\n    budgets5 = [350, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n    assert jinjin_savings_plan(budgets5) == -1, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_jinjin_savings_plan()",
    "entry_point": "jinjin_savings_plan",
    "signature": "def jinjin_savings_plan(budgets: List[int]) -> int:",
    "docstring": {
      "en": "Calculates the total amount of money Jinjin will have by the end of the year\nafter following her savings plan with her mother. Each month, she can save\nmultiples of 100 from her pocket money (300 per month) if she predicts having\nat least 100 units remaining after expenses. The saved money will gain 20%\ninterest at the end of the year.\n\nParameters:\nbudgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\nReturns:\nint: The total amount of money Jinjin will have at the end of the year after interest.\nIf Jinjin runs out of money in any given month, returns the negative value of\nthat month (-X, where X is the month number).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin runs out of money in July (the 7th month)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin has 1580 units of currency by the end of the year",
      "sq": "Llogarit shumën totale të parave që Jinjin do të ketë deri në fund të vitit\npas ndjekjes së planit të saj të kursimeve me nënën e saj. Çdo muaj, ajo mund të kursejë\nshumëfish të 100 nga paratë e saj të xhepit (300 në muaj) nëse parashikon të ketë\ntë paktën 100 njësi të mbetura pas shpenzimeve. Paratë e kursyera do të fitojnë 20%\ninteres në fund të vitit.\n\nParametrat:\nbudgets (List[int]): Një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n\nKthen:\nint: Shuma totale e parave që Jinjin do të ketë në fund të vitit pas interesit.\nNëse Jinjin mbetet pa para në ndonjë muaj të caktuar, kthen vlerën negative të\natij muaji (-X, ku X është numri i muajit).\n\nShembuj:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin mbetet pa para në korrik (muaji i 7-të)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin ka 1580 njësi monedhe deri në fund të vitit",
      "hy": "Հաշվում է, թե որքան գումար կունենա Ջինջինը տարվա վերջում՝ իր խնայողությունների պլանը իր մոր հետ հետևելուց հետո: Ամեն ամիս նա կարող է խնայել 100-ի բազմապատիկներ իր գրպանի գումարից (300 ամսական), եթե կանխատեսում է, որ ծախսերից հետո առնվազն 100 միավոր կմնա: Խնայված գումարը տարվա վերջում կստանա 20% տոկոսադրույք:\n\nՊարամետրեր:\nbudgets (List[int]): Ցուցակ 12 ամբողջ թվերից, որոնք ներկայացնում են Ջինջինի ամսական բյուջեն:\n\nՎերադարձնում է:\nint: Գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում՝ տոկոսադրույքից հետո:\nԵթե Ջինջինը որևէ ամսում գումարը սպառվի, վերադարձնում է այդ ամսվա բացասական արժեքը (-X, որտեղ X-ը ամսվա համարն է):\n\nՕրինակներ:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Ջինջինը գումարը սպառվում է հուլիսին (7-րդ ամիս)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Ջինջինը տարվա վերջում ունի 1580 միավոր արժույթ",
      "bn": "বছরের শেষে জিনজিনের মোট কত টাকা থাকবে তা গণনা করে তার সঞ্চয় পরিকল্পনা অনুসরণ করার পর তার মায়ের সাথে। প্রতিটি মাসে, সে তার পকেট মানি (প্রতি মাসে ৩০০) থেকে ১০০-এর গুণিতক সঞ্চয় করতে পারে যদি সে খরচের পর অন্তত ১০০ ইউনিট অবশিষ্ট থাকবে বলে পূর্বাভাস দেয়। সঞ্চিত অর্থ বছরের শেষে ২০% সুদ অর্জন করবে।\n\nপ্যারামিটার:\nbudgets (List[int]): জিনজিনের মাসিক বাজেটের প্রতিনিধিত্বকারী ১২টি পূর্ণসংখ্যার একটি তালিকা।\n\nরিটার্নস:\nint: বছরের শেষে সুদের পর জিনজিনের মোট কত টাকা থাকবে। যদি কোনো মাসে জিনজিনের টাকা শেষ হয়ে যায়, তাহলে সেই মাসের ঋণাত্মক মান (-X, যেখানে X হল মাসের সংখ্যা) রিটার্ন করে।\n\nউদাহরণ:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # জিনজিন জুলাই মাসে (৭ম মাসে) টাকা শেষ হয়ে যায়\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # বছরের শেষে জিনজিনের ১৫৮০ ইউনিট মুদ্রা থাকে",
      "bg": "Изчислява общата сума пари, която Джинджин ще има до края на годината след като следва плана си за спестявания с майка си. Всеки месец тя може да спести кратни на 100 от джобните си пари (300 на месец), ако предвижда, че ще има поне 100 единици, останали след разходите. Спестените пари ще получат 20% лихва в края на годината.\n\nПараметри:\nbudgets (List[int]): Списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n\nВръща:\nint: Общата сума пари, която Джинджин ще има в края на годината след лихвата. Ако Джинджин остане без пари през който и да е месец, връща отрицателната стойност на този месец (-X, където X е номерът на месеца).\n\nПримери:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Джинджин остава без пари през юли (седмия месец)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Джинджин има 1580 единици валута до края на годината",
      "zh": "计算金金在遵循她与母亲的储蓄计划后，到年底将拥有的总金额。每个月，如果她预测在支出后至少剩余100单位，她可以从她的零花钱（每月300）中存下100的倍数。储蓄的钱将在年底获得20%的利息。\n\n参数：\nbudgets (List[int]): 一个包含12个整数的列表，表示金金每月的预算。\n\n返回：\nint: 金金在年底加上利息后将拥有的总金额。如果金金在任何一个月用完了钱，返回该月份的负值（-X，其中X是月份编号）。\n\n示例：\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # 金金在七月（第7个月）用完了钱\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # 金金在年底有1580单位的货币",
      "fr": "Calcule le montant total d'argent que Jinjin aura à la fin de l'année après avoir suivi son plan d'épargne avec sa mère. Chaque mois, elle peut économiser des multiples de 100 de son argent de poche (300 par mois) si elle prévoit d'avoir au moins 100 unités restantes après les dépenses. L'argent économisé gagnera 20% d'intérêt à la fin de l'année.\n\nParamètres :\nbudgets (List[int]): Une liste de 12 entiers représentant le budget mensuel de Jinjin.\n\nRenvoie :\nint : Le montant total d'argent que Jinjin aura à la fin de l'année après intérêts. Si Jinjin manque d'argent à un moment donné du mois, renvoie la valeur négative de ce mois (-X, où X est le numéro du mois).\n\nExemples :\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin manque d'argent en juillet (le 7ème mois)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin a 1580 unités de monnaie à la fin de l'année",
      "de": "Berechnet den Gesamtbetrag an Geld, den Jinjin bis zum Ende des Jahres haben wird, nachdem sie ihren Sparplan mit ihrer Mutter befolgt hat. Jeden Monat kann sie Vielfache von 100 von ihrem Taschengeld (300 pro Monat) sparen, wenn sie voraussagt, dass nach den Ausgaben mindestens 100 Einheiten übrig bleiben. Das gesparte Geld wird am Ende des Jahres 20% Zinsen erhalten.\n\nParameter:\nbudgets (List[int]): Eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n\nRückgabewerte:\nint: Der Gesamtbetrag an Geld, den Jinjin am Ende des Jahres nach Zinsen haben wird. Wenn Jinjin in einem beliebigen Monat kein Geld mehr hat, wird der negative Wert dieses Monats zurückgegeben (-X, wobei X die Monatsnummer ist).\n\nBeispiele:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin hat im Juli (dem 7. Monat) kein Geld mehr\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin hat bis zum Ende des Jahres 1580 Währungseinheiten",
      "ha": "Lissafa jimillar kuɗin da Jinjin za ta samu a ƙarshen shekara\nbayan bin shirin ajiyar kuɗi tare da mahaifiyarta. Kowace wata, za ta iya ajiye\nsau na 100 daga cikin kuɗin aljihunta (300 a kowane wata) idan ta hango samun\naƙalla 100 saura bayan kashe kuɗi. Kuɗin da aka ajiye zai samu riba 20%\na ƙarshen shekara.\n\nSigogi:\nbudgets (List[int]): Jerin lambobi 12 da ke wakiltar kasafin kudin wata-wata na Jinjin.\n\nReturns:\nint: Jimillar adadin kuɗin da Jinjin za ta samu a ƙarshen shekara bayan riba. Idan Jinjin ta ƙare da kuɗi a kowane wata, yana dawo da ƙimar mara kyau na wannan watan (-X, inda X shine lambar wata).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin ta ƙare da kuɗi a watan Yuli (wata na 7)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin tana da 1580 na kuɗi a ƙarshen shekara",
      "hi": "वर्ष के अंत तक Jinjin के पास कुल कितनी राशि होगी, इसकी गणना करता है\nअपनी माँ के साथ उसकी बचत योजना का पालन करने के बाद। प्रत्येक महीने, वह\nअपनी पॉकेट मनी (प्रति माह 300) से 100 के गुणकों की बचत कर सकती है यदि वह\nखर्चों के बाद कम से कम 100 इकाइयाँ बचने की भविष्यवाणी करती है। बचाई गई राशि\nको वर्ष के अंत में 20% ब्याज प्राप्त होगा।\n\nमापदंड:\nbudgets (List[int]): 12 पूर्णांकों की एक सूची जो जिनजिन के मासिक बजट का प्रतिनिधित्व करती है।\n\nवापसी:\nint: वर्ष के अंत में ब्याज के बाद जिनजिन के पास कुल धनराशि होगी।\nयदि जिनजिन किसी भी महीने में पैसे से बाहर हो जाती है, तो उस महीने का नकारात्मक मान लौटाता है (-X, जहाँ X महीने का क्रमांक है)।\n\nउदाहरण:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # जिनजिन जुलाई (7वां महीना) में पैसे से बाहर हो जाती है\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # जिनजिन के पास वर्ष के अंत तक 1580 मुद्रा इकाइयाँ हैं",
      "hu": "Kiszámítja, hogy mennyi pénze lesz Jinjinnek az év végére, miután követi a megtakarítási tervét az anyukájával. Minden hónapban 100-as többszöröseit tudja megtakarítani a zsebpénzéből (havonta 300), ha előre látja, hogy legalább 100 egység marad a kiadások után. A megtakarított pénz 20%-os kamatot kap az év végén.\n\nParaméterek:\nbudgets (List[int]): Egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelöli.\n\nVisszatérési érték:\nint: Az összeg, amennyi pénze lesz Jinjinnek az év végén a kamatokkal együtt. Ha Jinjin bármelyik hónapban kifogy a pénzből, akkor az adott hónap negatív értékét adja vissza (-X, ahol X a hónap száma).\n\nPéldák:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin kifogy a pénzből júliusban (a 7. hónap)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjinnek 1580 pénzegysége van az év végére"
    },
    "docstring_bertscore": {
      "sq": "0.9888822603127152",
      "hy": "0.9751006885853716",
      "bn": "0.9863558804963325",
      "bg": "0.9885368420800955",
      "zh": "0.9567820016944291",
      "fr": "0.9769437798909943",
      "de": "0.9826303690696422",
      "ha": "0.9830031982948446",
      "hi": "0.9882504170706432",
      "hu": "0.9683395090453251"
    }
  },
  {
    "task_id": "Python/45",
    "prompt": {
      "en": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Merging (5+5) with a total cost of 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\n        # followed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\n        # Total cost is 30+60+90+150 = 300.\n    \"\"\"",
      "sq": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm.\n    Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor\n    një algoritëm lakmitar me një grumbull minimal (radhë prioriteti) për të siguruar që grumbujt më të vegjël të bashkohen të parët,\n    duke minimizuar koston totale.\n\n    Parametrat:\n    fruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrat e secilit lloj fruti.\n\n    Kthen:\n    int: Kostoja minimale totale e kërkuar për të bashkuar të gjithë grumbujt e frutave.\n\n    Shembuj:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Bashkimi (1+2) me një kosto prej 3, dhe pastaj (3+9) me një kosto prej 12, jep një kosto totale prej 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Bashkimi (5+5) me një kosto totale prej 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Një mënyrë optimale është bashkimi 10+20 (kosto 30), pastaj bashkimi 30+30 (kosto 60),\n        # pasuar nga 40+50 (kosto 90), dhe në fund bashkimi i dy grumbujve të mbetur 60+90 (kosto 150).\n        # Kostoja totale është 30+60+90+150 = 300.\n    \"\"\"",
      "hy": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Հաշվում է մրգերի մի քանի կույտերը մեկ կույտի մեջ միացնելու նվազագույն ընդհանուր արժեքը:\n    Երկու կույտերի միացման արժեքը հավասար է նրանց կշիռների գումարին: Ֆունկցիան օգտագործում է\n    ագահ ալգորիթմ մին-կույտով (առաջնահերթության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը\n    առաջինը միացվեն՝ նվազեցնելով ընդհանուր արժեքը:\n\n    Պարամետրեր:\n    fruit_counts (List[int]): Թվերի ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի մրգի քանակը:\n\n    Վերադարձնում է:\n    int: Նվազագույն ընդհանուր արժեքը, որը պահանջվում է մրգերի բոլոր կույտերը միացնելու համար:\n\n    Օրինակներ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Միացնելով (1+2) արժեքով 3, և ապա (3+9) արժեքով 12, ստացվում է ընդհանուր արժեք 15:\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Միացնելով (5+5) ընդհանուր արժեքով 10:\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Մեկ օպտիմալ եղանակ է միացնել 10+20 (արժեք 30), ապա միացնել 30+30 (արժեք 60),\n        # այնուհետև 40+50 (արժեք 90), և վերջապես միացնել երկու մնացած կույտերը 60+90 (արժեք 150):\n        # Ընդհանուր արժեքը 30+60+90+150 = 300:\n    \"\"\"",
      "bn": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    একাধিক ফলের স্তূপকে একক স্তূপে একত্রিত করার জন্য সর্বনিম্ন মোট খরচ হিসাব করে।\n    দুটি স্তূপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\n    একটি মিন-হিপ (অগ্রাধিকার সারি) সহ নিশ্চিত করে যে ছোট স্তূপগুলি প্রথমে একত্রিত হয়,\n    মোট খরচ কমিয়ে দেয়।\n\n    প্যারামিটার:\n    fruit_counts (List[int]): প্রতিটি ধরণের ফলের গণনা উপস্থাপনকারী পূর্ণসংখ্যার একটি তালিকা।\n\n    রিটার্নস:\n    int: সমস্ত ফলের স্তূপ একত্রিত করার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ।\n\n    উদাহরণ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2) একত্রিত করার খরচ 3, এবং তারপর (3+9) একত্রিত করার খরচ 12, মোট খরচ 15 দেয়।\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5) একত্রিত করার মোট খরচ 10।\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # একটি সর্বোত্তম উপায় হল 10+20 (খরচ 30) একত্রিত করা, তারপর 30+30 (খরচ 60) একত্রিত করা,\n        # তারপরে 40+50 (খরচ 90), এবং অবশেষে দুটি অবশিষ্ট স্তূপ 60+90 (খরচ 150) একত্রিত করা।\n        # মোট খরচ 30+60+90+150 = 300।\n    \"\"\"",
      "bg": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Изчислява минималната обща цена за сливане на множество купчини плодове в една купчина.\n    Цената за сливане на две купчини е равна на сумата от техните тегла. Функцията използва\n    алчен алгоритъм с мин-купа (приоритетна опашка), за да гарантира, че най-малките купчини се сливат първи,\n    минимизирайки общата цена.\n\n    Параметри:\n    fruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плод.\n\n    Връща:\n    int: Минималната обща цена, необходима за сливане на всички купчини плодове.\n\n    Примери:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Сливане (1+2) с цена 3, и след това (3+9) с цена 12, дава обща цена от 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Сливане (5+5) с обща цена 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Един оптимален начин е сливане на 10+20 (цена 30), след това сливане на 30+30 (цена 60),\n        # следвано от 40+50 (цена 90), и накрая сливане на двете останали купчини 60+90 (цена 150).\n        # Общата цена е 30+60+90+150 = 300.\n    \"\"\"",
      "zh": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    计算将多个水果堆合并成一个堆的最小总成本。\n    合并两个堆的成本等于它们重量的总和。该函数利用贪心算法和最小堆（优先队列）\n    来确保首先合并最小的堆，从而最小化总成本。\n\n    参数:\n    fruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n    返回:\n    int: 合并所有水果堆所需的最小总成本。\n\n    示例:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # 合并 (1+2) 的成本为 3，然后合并 (3+9) 的成本为 12，总成本为 15。\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # 合并 (5+5) 的总成本为 10。\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # 一种最优方式是合并 10+20（成本 30），然后合并 30+30（成本 60），\n        # 接着合并 40+50（成本 90），最后合并剩下的两个堆 60+90（成本 150）。\n        # 总成本是 30+60+90+150 = 300。\n    \"\"\"",
      "fr": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas.\n    Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise\n    un algorithme glouton avec un tas minimum (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier,\n    minimisant ainsi le coût total.\n\n    Paramètres:\n    fruit_counts (List[int]): Une liste d'entiers représentant les quantités de chaque type de fruit.\n\n    Retourne:\n    int: Le coût total minimum requis pour fusionner tous les tas de fruits.\n\n    Exemples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Fusionner (1+2) avec un coût de 3, puis (3+9) avec un coût de 12, donne un coût total de 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Fusionner (5+5) avec un coût total de 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Une façon optimale est de fusionner 10+20 (coût 30), puis fusionner 30+30 (coût 60),\n        # suivi par 40+50 (coût 90), et enfin fusionner les deux tas restants 60+90 (coût 150).\n        # Le coût total est 30+60+90+150 = 300.\n    \"\"\"",
      "de": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zu verschmelzen.\n    Die Kosten für das Verschmelzen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\n    einen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten Haufen zuerst verschmolzen werden,\n    wodurch die Gesamtkosten minimiert werden.\n\n    Parameter:\n    fruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl der Früchte jeder Art darstellen.\n\n    Rückgabewert:\n    int: Die minimalen Gesamtkosten, die erforderlich sind, um alle Haufen von Früchten zu verschmelzen.\n\n    Beispiele:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Verschmelzen von (1+2) mit Kosten von 3 und dann (3+9) mit Kosten von 12 ergibt Gesamtkosten von 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Verschmelzen von (5+5) mit Gesamtkosten von 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Eine optimale Methode ist das Verschmelzen von 10+20 (Kosten 30), dann das Verschmelzen von 30+30 (Kosten 60),\n        # gefolgt von 40+50 (Kosten 90) und schließlich das Verschmelzen der beiden verbleibenden Haufen 60+90 (Kosten 150).\n        # Gesamtkosten sind 30+60+90+150 = 300.\n    \"\"\"",
      "ha": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Lissafa mafi ƙarancin jimillar kuɗi don haɗa tarin 'ya'yan itatuwa da yawa zuwa tarin guda.\n    Farashin haɗa tarin biyu yana daidai da jimillar nauyin su. Aikin yana amfani da\n    dabarun kwaikwayo tare da ƙaramin tarin (layin fifiko) don tabbatar da cewa an fara haɗa ƙananan tarin,\n    yana rage jimillar kuɗi.\n\n    Sigogi:\n    fruit_counts (List[int]): Jerin lambobi da ke wakiltar ƙididdigar kowane nau'in 'ya'yan itace.\n\n    Komawa:\n    int: Mafi ƙarancin jimillar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\n    Misalai:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Haɗa (1+2) tare da kuɗin 3, sannan (3+9) tare da kuɗin 12, yana ba da jimillar kuɗi 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Haɗa (5+5) tare da jimillar kuɗi 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Ɗaya daga cikin hanyoyin da za a iya bi shi ne haɗa 10+20 (kuɗi 30), sannan haɗa 30+30 (kuɗi 60),\n        # biye da 40+50 (kuɗi 90), kuma a ƙarshe haɗa ragowar tarin guda biyu 60+90 (kuɗi 150).\n        # Jimillar kuɗi ita ce 30+60+90+150 = 300.\n    \"\"\"",
      "hi": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    कई ढेरों फलों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करता है।\n    दो ढेरों को मिलाने की लागत उनके भार के योग के बराबर होती है। यह फ़ंक्शन सुनिश्चित करने के लिए\n    एक लालची एल्गोरिदम के साथ एक मिन-हीप (प्राथमिकता कतार) का उपयोग करता है कि सबसे छोटे ढेर पहले\n    मिलाए जाएं, जिससे कुल लागत न्यूनतम हो।\n\n    पैरामीटर्स:\n    fruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची।\n\n    रिटर्न्स:\n    int: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\n    उदाहरण:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2) को 3 की लागत से मिलाना, और फिर (3+9) को 12 की लागत से मिलाना, कुल लागत 15 देता है।\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5) को 10 की कुल लागत से मिलाना।\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # एक इष्टतम तरीका है 10+20 को मिलाना (लागत 30), फिर 30+30 को मिलाना (लागत 60),\n        # उसके बाद 40+50 को मिलाना (लागत 90), और अंत में बचे हुए दो ढेरों 60+90 को मिलाना (लागत 150)।\n        # कुल लागत 30+60+90+150 = 300 है।\n    \"\"\"",
      "hu": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Kiszámítja a minimális összköltséget, hogy több gyümölcshalmazt egyetlen halmazzá egyesítsen.\n    Két halmaz egyesítésének költsége megegyezik a súlyuk összegével. A függvény egy mohó algoritmust\n    használ egy min-kupaccal (prioritási sor), hogy biztosítsa, a legkisebb halmazok kerülnek először egyesítésre,\n    minimalizálva az összköltséget.\n\n    Paraméterek:\n    fruit_counts (List[int]): Egész számokat tartalmazó lista, amely az egyes gyümölcstípusok számát jelöli.\n\n    Visszatérési érték:\n    int: A minimális összköltség, amely szükséges az összes gyümölcshalmaz egyesítéséhez.\n\n    Példák:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Az (1+2) egyesítése 3 költséggel, majd a (3+9) egyesítése 12 költséggel, összesen 15 költséget ad.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Az (5+5) egyesítése összesen 10 költséggel.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Egy optimális mód az, ha először 10+20-at egyesítünk (30 költség), majd 30+30-at (60 költség),\n        # ezt követően 40+50-et (90 költség), és végül a két megmaradt halmazt 60+90 (150 költség).\n        # Az összköltség 30+60+90+150 = 300.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9760956281639753",
      "hy": "0.9574638997925218",
      "bn": "0.9470371952008574",
      "bg": "0.9672849803524108",
      "zh": "0.9448468979891858",
      "fr": "0.9603265608439966",
      "de": "0.9652075051971669",
      "ha": "0.9579570990286315",
      "hi": "0.9591582169427494",
      "hu": "0.9673060351728006"
    },
    "canonical_solution": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost",
    "instruction": {
      "en": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nՏվյալ Python կոդի համար տրամադրեք համառոտ բնութագրում (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），不超过 500 个字符。",
      "fr": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9431412589072391",
      "hy": "0.8697749427378118",
      "bn": "0.8827651710271124",
      "bg": "0.8983697723915943",
      "zh": "0.8839134532598751",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9404883515381371",
      "hi": "0.9170904871737514",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_minimum_cost_to_merge_fruits():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_minimum_cost_to_merge_fruits()",
    "entry_point": "minimum_cost_to_merge_fruits",
    "signature": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:",
    "docstring": {
      "en": "Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\nThe cost of merging two heaps is equal to the sum of their weights. The function utilizes\na greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\nminimizing the total cost.\n\nParameters:\nfruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\nReturns:\nint: The minimum total cost required to merge all heaps of fruits.\n\nExamples:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Merging (5+5) with a total cost of 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\nfollowed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\nTotal cost is 30+60+90+150 = 300.",
      "sq": "Llogarit koston minimale totale për të bashkuar disa grumbuj frutash në një grumbull të vetëm. Kostoja e bashkimit të dy grumbujve është e barabartë me shumën e peshave të tyre. Funksioni përdor një algoritëm lakmitar me një grumbull minimal (radhë prioriteti) për të siguruar që grumbujt më të vegjël të bashkohen të parët, duke minimizuar koston totale.\n\nParametrat:\nfruit_counts (List[int]): Një listë e numrave të plotë që përfaqësojnë numrin e secilit lloj fruti.\n\nKthen:\nint: Kostoja minimale totale e kërkuar për të bashkuar të gjithë grumbujt e frutave.\n\nShembuj:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Bashkimi (1+2) me një kosto prej 3, dhe pastaj (3+9) me një kosto prej 12, jep një kosto totale prej 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Bashkimi (5+5) me një kosto totale prej 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Një mënyrë optimale është bashkimi 10+20 (kosto 30), pastaj bashkimi 30+30 (kosto 60),\nndjekur nga 40+50 (kosto 90), dhe në fund bashkimi i dy grumbujve të mbetur 60+90 (kosto 150).\nKostoja totale është 30+60+90+150 = 300.",
      "hy": "Հաշվում է մրգերի մի քանի կույտերը մեկ կույտի մեջ միացնելու նվազագույն ընդհանուր արժեքը: Երկու կույտերի միացման արժեքը հավասար է նրանց քաշերի գումարին: Ֆունկցիան օգտագործում է ագահ ալգորիթմ մին-կույտով (առաջնահերթության հերթ)՝ ապահովելու համար, որ ամենափոքր կույտերը առաջինը միացվեն, նվազեցնելով ընդհանուր արժեքը:\n\nՊարամետրեր:\nfruit_counts (List[int]): Թվերի ցուցակ, որը ներկայացնում է յուրաքանչյուր տեսակի մրգերի քանակը:\n\nՎերադարձնում է:\nint: Նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր մրգերի կույտերը միացնելու համար:\n\nՕրինակներ:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Միացնելով (1+2) արժեքով 3, և հետո (3+9) արժեքով 12, ստացվում է ընդհանուր արժեք 15:\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Միացնելով (5+5) ընդհանուր արժեքով 10:\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Մեկ օպտիմալ եղանակ է միացնել 10+20 (արժեք 30), հետո միացնել 30+30 (արժեք 60),\nհետո 40+50 (արժեք 90), և վերջապես միացնել մնացած երկու կույտերը 60+90 (արժեք 150):\nԸնդհանուր արժեքը 30+60+90+150 = 300:",
      "bn": "একাধিক ফলের স্তূপকে একটি একক স্তূপে একত্রিত করার জন্য সর্বনিম্ন মোট খরচ গণনা করে।\nদুইটি স্তূপ একত্রিত করার খরচ তাদের ওজনের সমান। ফাংশনটি একটি লোভী অ্যালগরিদম ব্যবহার করে\nএকটি মিন-হীপ (অগ্রাধিকার সারি) সহ নিশ্চিত করে যে ছোট স্তূপগুলি প্রথমে একত্রিত হয়,\nমোট খরচ কমিয়ে দেয়।\n\nপ্যারামিটারসমূহ:\nfruit_counts (List[int]): প্রতিটি প্রকারের ফলের সংখ্যা নির্দেশকারী পূর্ণসংখ্যার একটি তালিকা।\n\nরিটার্নস:\nint: সমস্ত ফলের স্তূপ একত্রিত করার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ।\n\nউদাহরণ:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2) একত্রিত করার খরচ 3, এবং তারপর (3+9) একত্রিত করার খরচ 12, মোট খরচ 15 দেয়।\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5) একত্রিত করার মোট খরচ 10।\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # একটি অনুকূল উপায় হলো 10+20 একত্রিত করা (খরচ 30), তারপর 30+30 একত্রিত করা (খরচ 60),\nএরপর 40+50 একত্রিত করা (খরচ 90), এবং শেষ পর্যন্ত অবশিষ্ট দুটি স্তূপ 60+90 একত্রিত করা (খরচ 150)।\nমোট খরচ হলো 30+60+90+150 = 300।",
      "bg": "Изчислява минималната обща стойност за сливане на множество купчини плодове в една купчина. Стойността на сливане на две купчини е равна на сумата от техните тегла. Функцията използва алчен алгоритъм с мин-купа (приоритетна опашка), за да гарантира, че най-малките купчини се сливат първи, минимизирайки общата стойност.\n\nПараметри:\nfruit_counts (List[int]): Списък от цели числа, представляващи броя на всеки вид плодове.\n\nВръща:\nint: Минималната обща стойност, необходима за сливане на всички купчини плодове.\n\nПримери:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Сливане (1+2) със стойност 3, и след това (3+9) със стойност 12, дава обща стойност 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Сливане (5+5) с обща стойност 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Един оптимален начин е сливане на 10+20 (стойност 30), след това сливане на 30+30 (стойност 60),\nпоследвано от 40+50 (стойност 90), и накрая сливане на двете останали купчини 60+90 (стойност 150).\nОбщата стойност е 30+60+90+150 = 300.",
      "zh": "计算将多个水果堆合并为一个堆的最小总成本。\n合并两个堆的成本等于它们重量的总和。该函数利用贪心算法与最小堆（优先队列）来确保最小的堆先合并，从而最小化总成本。\n\n参数：\nfruit_counts (List[int]): 一个整数列表，表示每种水果的数量。\n\n返回：\nint: 合并所有水果堆所需的最小总成本。\n\n示例：\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # 合并 (1+2) 的成本为 3，然后合并 (3+9) 的成本为 12，总成本为 15。\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # 合并 (5+5) 的总成本为 10。\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # 一种最优方式是合并 10+20（成本 30），然后合并 30+30（成本 60），\n接着合并 40+50（成本 90），最后合并剩下的两个堆 60+90（成本 150）。\n总成本是 30+60+90+150 = 300。",
      "fr": "Calcule le coût total minimum pour fusionner plusieurs tas de fruits en un seul tas. Le coût de fusion de deux tas est égal à la somme de leurs poids. La fonction utilise un algorithme glouton avec un tas min (file de priorité) pour s'assurer que les plus petits tas sont fusionnés en premier, minimisant ainsi le coût total.\n\nParamètres :\nfruit_counts (List[int]): Une liste d'entiers représentant les quantités de chaque type de fruit.\n\nRenvoie :\nint: Le coût total minimum requis pour fusionner tous les tas de fruits.\n\nExemples :\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Fusionner (1+2) avec un coût de 3, puis (3+9) avec un coût de 12, donne un coût total de 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Fusionner (5+5) avec un coût total de 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Une manière optimale est de fusionner 10+20 (coût 30), puis fusionner 30+30 (coût 60),\nsuivi de 40+50 (coût 90), et enfin fusionner les deux tas restants 60+90 (coût 150).\nLe coût total est 30+60+90+150 = 300.",
      "de": "Berechnet die minimalen Gesamtkosten, um mehrere Haufen von Früchten zu einem einzigen Haufen zusammenzuführen.\nDie Kosten für das Zusammenführen von zwei Haufen entsprechen der Summe ihrer Gewichte. Die Funktion verwendet\neinen gierigen Algorithmus mit einem Min-Heap (Prioritätswarteschlange), um sicherzustellen, dass die kleinsten Haufen zuerst zusammengeführt werden,\nwodurch die Gesamtkosten minimiert werden.\n\nParameter:\nfruit_counts (List[int]): Eine Liste von ganzen Zahlen, die die Anzahl jeder Fruchtsorte darstellen.\n\nRückgabewert:\nint: Die minimalen Gesamtkosten, die erforderlich sind, um alle Fruchthaufen zusammenzuführen.\n\nBeispiele:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Zusammenführen von (1+2) mit Kosten von 3 und dann (3+9) mit Kosten von 12 ergibt Gesamtkosten von 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Zusammenführen von (5+5) mit Gesamtkosten von 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Eine optimale Möglichkeit ist das Zusammenführen von 10+20 (Kosten 30), dann 30+30 (Kosten 60),\ngefolgt von 40+50 (Kosten 90) und schließlich das Zusammenführen der beiden verbleibenden Haufen 60+90 (Kosten 150).\nGesamtkosten sind 30+60+90+150 = 300.",
      "ha": "Yana ƙididdige mafi ƙarancin jimlar kuɗi don haɗa tarin 'ya'yan itatuwa da yawa zuwa tarin guda ɗaya. \nKuɗin haɗa tarin biyu ya yi daidai da jimlar nauyinsu. Aikin yana amfani da \nalgoritm mai kwaɗayi tare da ƙaramin tarin (layin fifiko) don tabbatar da cewa ana haɗa ƙananan tarin farko, \nyana rage jimlar kuɗi.\n\nSigogi:\nfruit_counts (List[int]): Jerin lambobi da ke wakiltar adadin kowanne nau'in 'ya'yan itace.\n\nAbubuwan da ake dawowa:\nint: Mafi ƙarancin jimlar kuɗi da ake buƙata don haɗa dukkan tarin 'ya'yan itatuwa.\n\nMisalai:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Haɗa (1+2) tare da kuɗin 3, sannan (3+9) tare da kuɗin 12, yana ba da jimlar kuɗi 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Haɗa (5+5) tare da jimlar kuɗi 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Ɗaya daga cikin hanyoyi masu kyau shine haɗa 10+20 (kuɗin 30), sannan haɗa 30+30 (kuɗin 60),\nsannan 40+50 (kuɗin 90), kuma a ƙarshe haɗa sauran tarin guda biyu 60+90 (kuɗin 150).\nJimlar kuɗi shine 30+60+90+150 = 300.",
      "hi": "फल के ढेरों को एक ही ढेर में मिलाने की न्यूनतम कुल लागत की गणना करता है।\nदो ढेरों को मिलाने की लागत उनके वजन के योग के बराबर होती है। यह फ़ंक्शन\nएक लालची एल्गोरिदम का उपयोग करता है जिसमें सबसे छोटे ढेर पहले मिलाए जाते हैं,\nजिससे कुल लागत न्यूनतम होती है।\n\nपैरामीटर्स:\nfruit_counts (List[int]): प्रत्येक प्रकार के फल की गिनती को दर्शाने वाली पूर्णांकों की एक सूची।\n\nवापसी:\nint: सभी फलों के ढेरों को मिलाने के लिए आवश्यक न्यूनतम कुल लागत।\n\nउदाहरण:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2) को 3 की लागत पर मिलाना, और फिर (3+9) को 12 की लागत पर मिलाना, कुल लागत 15 देता है।\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5) को मिलाना, कुल लागत 10।\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # एक आदर्श तरीका है 10+20 (लागत 30) को मिलाना, फिर 30+30 (लागत 60) को मिलाना,\nइसके बाद 40+50 (लागत 90), और अंत में दो शेष ढेरों 60+90 (लागत 150) को मिलाना।\nकुल लागत 30+60+90+150 = 300 है।",
      "hu": "Kiszámítja a minimális összköltséget, hogy több gyümölcshalom egyetlen halommá egyesüljön.\nKét halom egyesítésének költsége egyenlő a súlyuk összegével. A függvény egy mohó algoritmust használ egy min-halommal (prioritási sor), hogy biztosítsa, hogy a legkisebb halmokat egyesítik először, minimalizálva az összköltséget.\n\nParaméterek:\nfruit_counts (List[int]): Egész számokat tartalmazó lista, amely az egyes gyümölcstípusok számát jelöli.\n\nVisszatérési érték:\nint: Az összes gyümölcshalom egyesítéséhez szükséges minimális összköltség.\n\nPéldák:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Az (1+2) egyesítése 3 költséggel, majd a (3+9) egyesítése 12 költséggel, összesen 15 költséget ad.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Az (5+5) egyesítése összesen 10 költséggel.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Egy optimális mód az 10+20 egyesítése (30 költség), majd a 30+30 egyesítése (60 költség),\nezt követi a 40+50 egyesítése (90 költség), végül az utolsó két halom 60+90 egyesítése (150 költség).\nAz összköltség 30+60+90+150 = 300."
    },
    "docstring_bertscore": {
      "sq": "0.9720540958010585",
      "hy": "0.9566763303317185",
      "bn": "0.9382233693031963",
      "bg": "0.9629093516885933",
      "zh": "0.9445048564730436",
      "fr": "0.9806444625200553",
      "de": "0.9637948459272468",
      "ha": "0.9542862109567256",
      "hi": "0.9324390539770794",
      "hu": "0.9693920514344289"
    }
  },
  {
    "task_id": "Python/46",
    "prompt": {
      "en": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    \"\"\"",
      "sq": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Llogarit numrin minimal të studentëve që duhet të largohen për të formuar një formacion kori.\n    Një formacion kori përcaktohet në mënyrë të tillë që për disa pozicione 'i', lartësitë e studentëve\n    rriten nga fillimi deri te 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\n    Argumentet:\n    heights (List[int]): Një listë e lartësive të studentëve.\n\n    Kthen:\n    int: Numri minimal i studentëve që duhet të largohen.\n    \"\"\"",
      "hy": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Հաշվել նվազագույն թվով ուսանողներ, որոնք պետք է հեռանան երգչախմբի կազմ ձևավորելու համար:\n    Երգչախմբի կազմը սահմանվում է այնպես, որ որոշ դիրքի 'i' համար ուսանողների բարձրությունները\n    աճում են սկզբից մինչև 'i' և նվազում են 'i'-ից մինչև կազմի վերջը:\n\n    Արձանագրություններ:\n    heights (List[int]): Ուսանողների բարձրությունների ցուցակ:\n\n    Վերադարձնում է:\n    int: Նվազագույն թվով ուսանողներ, որոնք պետք է հեռանան:\n    \"\"\"",
      "bn": "def minimum_students_to_leave(heights):\n    \"\"\"\n    একটি গায়কদল গঠনের জন্য কতজন ছাত্রকে ছেড়ে যেতে হবে তার সর্বনিম্ন সংখ্যা গণনা করুন।\n    একটি গায়কদল গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কোনো একটি অবস্থান 'i' এর জন্য, ছাত্রদের উচ্চতা\n    শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠনের শেষ পর্যন্ত হ্রাস পায়।\n\n    আর্গুমেন্টসমূহ:\n    heights (List[int]): ছাত্রদের উচ্চতার একটি তালিকা।\n\n    রিটার্নস:\n    int: সর্বনিম্ন সংখ্যক ছাত্র যারা ছেড়ে যেতে হবে।\n    \"\"\"",
      "bg": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация.\n    Хоровата формация е дефинирана така, че за някаква позиция 'i', височините на учениците\n    се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\n    Аргументи:\n    heights (List[int]): Списък с височините на учениците.\n\n    Връща:\n    int: Минималният брой ученици, които трябва да напуснат.\n    \"\"\"",
      "zh": "def minimum_students_to_leave(heights):\n    \"\"\"\n    计算需要离开的最小学生人数以形成合唱队形。\n    合唱队形的定义是，对于某个位置 'i'，学生的身高从开始到 'i' 递增，并从 'i' 到队形的结束递减。\n\n    参数:\n    heights (List[int]): 学生身高的列表。\n\n    返回:\n    int: 需要离开的最小学生人数。\n    \"\"\"",
      "fr": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculer le nombre minimum d'élèves qui doivent partir pour former une formation de chorale.\n    Une formation de chorale est définie de telle sorte que pour une position 'i', les hauteurs des élèves\n    augmentent du début à 'i' et diminuent de 'i' à la fin de la formation.\n\n    Args:\n    heights (List[int]): Une liste des hauteurs des élèves.\n\n    Returns:\n    int: Le nombre minimum d'élèves qui doivent partir.\n    \"\"\"",
      "de": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Berechne die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\n    Eine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\n    vom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\n    Argumente:\n    heights (List[int]): Eine Liste von Schülerhöhen.\n\n    Rückgabewert:\n    int: Die minimale Anzahl von Schülern, die gehen müssen.\n    \"\"\"",
      "ha": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Lissafi adadin ɗaliban da ya kamata su bar wurin don a samar da tsarin rera waka.\n    An bayyana tsarin rera waka ta yadda a wani matsayi 'i', tsayin ɗalibai\n    yana ƙaruwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\n    Args:\n    heights (List[int]): Jerin tsayin ɗalibai.\n\n    Returns:\n    int: Mafi ƙarancin adadin ɗaliban da ya kamata su bar wurin.\n    \"\"\"",
      "hi": "def minimum_students_to_leave(heights):\n    \"\"\"\n    गणना करें कि गाना गाने वाले समूह की संरचना बनाने के लिए न्यूनतम कितने छात्रों को छोड़ना पड़ेगा।\n    गाना गाने वाले समूह की संरचना इस प्रकार परिभाषित की जाती है कि किसी स्थिति 'i' के लिए,\n    छात्रों की ऊँचाई शुरू से 'i' तक बढ़ती है और 'i' से संरचना के अंत तक घटती है।\n\n    तर्क:\n    heights (List[int]): छात्रों की ऊँचाई की सूची।\n\n    वापसी:\n    int: न्यूनतम छात्रों की संख्या जिन्हें छोड़ना पड़ेगा।\n    \"\"\"",
      "hu": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Számítsa ki a minimális számú diákot, akinek el kell hagynia a kórus felállás kialakításához.\n    Egy kórus felállás úgy van meghatározva, hogy egy 'i' pozíció esetén a diákok magassága\n    növekszik a kezdetektől 'i'-ig, majd csökken 'i'-től a felállás végéig.\n\n    Args:\n    heights (List[int]): A diákok magasságainak listája.\n\n    Returns:\n    int: A minimális számú diák, akinek el kell hagynia a sort.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9883439719801107",
      "hy": "0.9631282423684937",
      "bn": "0.9723967332083436",
      "bg": "0.9825687936515213",
      "zh": "0.9664870821117937",
      "fr": "0.9796260845564895",
      "de": "0.9722100206501708",
      "ha": "0.9753851272910136",
      "hi": "0.9125372829492887",
      "hu": "0.9531724904102631"
    },
    "canonical_solution": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length",
    "instruction": {
      "en": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nՏվեք Python կոդի համառոտ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nBada takaitaccen bayani a cikin yaren halitta (docstring) na lambar Python a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा में विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9069653035004981",
      "bn": "0.9053846029282224",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9030075931583779",
      "hi": "0.8964889413135749",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_minimum_students_to_leave():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_minimum_students_to_leave()",
    "entry_point": "minimum_students_to_leave",
    "signature": "def minimum_students_to_leave(heights):",
    "docstring": {
      "en": "Calculate the minimum number of students that need to leave to form a choir formation.\nA choir formation is defined such that for some position 'i', the heights of students\nincrease from the start to 'i' and decrease from 'i' to the end of the formation.\n\nArgs:\nheights (List[int]): A list of student heights.\n\nReturns:\nint: The minimum number of students that need to leave.",
      "sq": "Llogarit numrin minimal të nxënësve që duhet të largohen për të formuar një formacion kori. Një formacion kori përcaktohet në mënyrë të tillë që për një pozicion 'i', lartësitë e nxënësve rriten nga fillimi deri te 'i' dhe ulen nga 'i' deri në fund të formacionit.\n\nArgumentet:\nheights (List[int]): Një listë e lartësive të nxënësve.\n\nKthen:\nint: Numri minimal i nxënësve që duhet të largohen.",
      "hy": "Հաշվարկել նվազագույն թվով ուսանողներ, որոնք պետք է հեռանան, որպեսզի կազմվի երգչախմբի կազմավորում:\nԵրգչախմբի կազմավորումը սահմանվում է այնպես, որ որոշ դիրքի 'i' համար ուսանողների բարձրությունները\nաճում են սկզբից մինչև 'i' և նվազում 'i'-ից մինչև կազմավորման վերջը:\n\nԱրգումենտներ:\nheights (List[int]): Ուսանողների բարձրությունների ցանկ:\n\nՎերադարձնում է:\nint: Նվազագույն թվով ուսանողներ, որոնք պետք է հեռանան:",
      "bn": "একটি গায়কদল গঠনের জন্য কতজন ছাত্রকে ছেড়ে যেতে হবে তার সর্বনিম্ন সংখ্যা গণনা করুন।\nএকটি গায়কদলের গঠন এমনভাবে সংজ্ঞায়িত করা হয় যে কিছু অবস্থান 'i' এর জন্য, শিক্ষার্থীদের উচ্চতা শুরু থেকে 'i' পর্যন্ত বৃদ্ধি পায় এবং 'i' থেকে গঠনের শেষ পর্যন্ত হ্রাস পায়।\n\nআর্গস:\nheights (List[int]): শিক্ষার্থীদের উচ্চতার একটি তালিকা।\n\nরিটার্নস:\nint: ন্যূনতম সংখ্যক শিক্ষার্থী যারা চলে যেতে হবে।",
      "bg": "Изчислете минималния брой ученици, които трябва да напуснат, за да се формира хорова формация. Хоровата формация е дефинирана така, че за някаква позиция 'i', височините на учениците се увеличават от началото до 'i' и намаляват от 'i' до края на формацията.\n\nАргументи:\nheights (List[int]): Списък с височините на учениците.\n\nВръща:\nint: Минималният брой ученици, които трябва да напуснат.",
      "zh": "计算需要离开的最小学生人数以形成合唱队形。  \n合唱队形的定义是，对于某个位置 'i'，学生的身高从开始到 'i' 递增，并从 'i' 到队形的结束递减。\n\n参数：\nheights (List[int]): 学生身高的列表。\n\n返回：\nint: 需要离开的最小学生人数。",
      "fr": "Calculer le nombre minimum d'élèves qui doivent partir pour former une chorale.\nUne formation de chorale est définie de telle sorte que pour une certaine position 'i', les hauteurs des élèves augmentent du début jusqu'à 'i' et diminuent de 'i' jusqu'à la fin de la formation.\n\nArgs:\nheights (List[int]): Une liste des hauteurs des élèves.\n\nReturns:\nint: Le nombre minimum d'élèves qui doivent partir.",
      "de": "Berechne die minimale Anzahl von Schülern, die gehen müssen, um eine Chorformation zu bilden.\nEine Chorformation ist so definiert, dass für eine Position 'i' die Höhen der Schüler\nvom Anfang bis 'i' zunehmen und von 'i' bis zum Ende der Formation abnehmen.\n\nArgs:\nheights (List[int]): Eine Liste von Schülerhöhen.\n\nReturns:\nint: Die minimale Anzahl von Schülern, die gehen müssen.",
      "ha": "Ƙididdige mafi ƙarancin adadin ɗaliban da ya kamata su bar wurin don samar da tsarin rera waka. \nAna ayyana tsarin rera waka ta yadda don wani matsayi 'i', tsayin ɗalibai yana ƙaruwa daga farkon zuwa 'i' kuma yana raguwa daga 'i' zuwa ƙarshen tsarin.\n\nArgs:\nheights (List[int]): Jerin tsayin ɗalibai.\n\nReturns:\nint: Mafi ƙarancin adadin ɗaliban da ya kamata su bar wurin.",
      "hi": "गणना करें कि गाना गाने वाले समूह की संरचना बनाने के लिए न्यूनतम कितने छात्रों को छोड़ना पड़ेगा।\nएक गाना समूह गठन को इस प्रकार परिभाषित किया जाता है कि किसी स्थिति 'i' के लिए, छात्रों की ऊंचाई  \nशुरुआत से 'i' तक बढ़ती है और 'i' से गठन के अंत तक घटती है।\n\nArgs:  \nheights (List[int]): छात्रों की ऊंचाइयों की एक सूची।\n\nReturns:  \nint: न्यूनतम संख्या में छात्र जिन्हें छोड़ना आवश्यक है।",
      "hu": "Számítsa ki a minimum hány diáknak kell elhagynia a kórus felállás kialakításához.\nEgy kórus felállás úgy van meghatározva, hogy egy 'i' pozíció esetén a diákok magassága\nnövekszik a kezdetektől 'i'-ig, majd csökken 'i'-től a felállás végéig.\n\nArgs:\nheights (List[int]): A diákok magasságának listája.\n\nReturns:\nint: A minimum hány diáknak kell elhagynia."
    },
    "docstring_bertscore": {
      "sq": "0.9470789075808748",
      "hy": "0.9648050800451903",
      "bn": "0.9788164671233912",
      "bg": "0.9719245887926238",
      "zh": "0.9480512032960405",
      "fr": "0.9649751076513561",
      "de": "0.9908902148345969",
      "ha": "0.9376560809349607",
      "hi": "0.9639799694423713",
      "hu": "0.9536343060461692"
    }
  },
  {
    "task_id": "Python/47",
    "prompt": {
      "en": "def sort_students(student_scores):\n    \"\"\"\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    In the first example, the student with the highest total score is number 6. Students number 4 and 3 follow,\n    with descending total scores. Student number 1 has a lower total score than student number 2, but a higher Chinese score,\n    so student number 1 is placed after student number 2 in the sorted list.\n    \n    In the second example, students number 1 and 2 have the same total score, but student number 1 has a higher Chinese score,\n    so they are placed first. The rest are sorted by their descending total scores.\n    \"\"\"",
      "sq": "def sort_students(student_scores):\n    \"\"\"\n    Rendit një listë studentësh bazuar në pikët e tyre. Studentët renditen kryesisht sipas pikëve të tyre totale (në zbritje),\n    pastaj sipas pikëve të tyre në gjuhën kineze (në zbritje), dhe së fundi sipas numrit të studentit (në rritje) në rast barazimi.\n    \n    Args:\n    student_scores (list): Një listë tuplesh, ku secili tuple përbëhet nga (numri_studentit, pikët_totale, pikët_kineze).\n    \n    Returns:\n    list: Një listë tuplesh e renditur sipas rregullave të mësipërme.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Në shembullin e parë, studenti me pikët më të larta totale është numri 6. Studentët numër 4 dhe 3 ndjekin,\n    me pikë totale në zbritje. Studenti numër 1 ka pikë totale më të ulëta se studenti numër 2, por pikë më të larta në gjuhën kineze,\n    kështu që studenti numër 1 vendoset pas studentit numër 2 në listën e renditur.\n    \n    Në shembullin e dytë, studentët numër 1 dhe 2 kanë të njëjtat pikë totale, por studenti numër 1 ka pikë më të larta në gjuhën kineze,\n    kështu që ata vendosen të parët. Të tjerët renditen sipas pikëve të tyre totale në zbritje.\n    \"\"\"",
      "hy": "def sort_students(student_scores):\n    \"\"\"\n    Դասավորում է ուսանողների ցուցակը՝ հիմնվելով նրանց միավորների վրա։ Ուսանողները դասավորվում են նախ իրենց ընդհանուր միավորներով (նվազման կարգով),\n    հետո՝ չինարենի միավորներով (նվազման կարգով), և վերջապես՝ ուսանողի համարով (աճման կարգով)՝ եթե միավորները հավասար են։\n    \n    Արգումենտներ:\n    student_scores (ցուցակ): Ցուցակ, որը բաղկացած է տուփերից, որտեղ յուրաքանչյուր տուփ ներառում է (ուսանողի համար, ընդհանուր միավոր, չինարենի միավոր)։\n    \n    Վերադարձնում է:\n    ցուցակ: Տուփերի ցուցակ, դասավորված ըստ վերը նշված կանոնների։\n    \n    Օրինակներ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Առաջին օրինակով, ուսանողը, ով ունի ամենաբարձր ընդհանուր միավորը, համար 6-ն է։ Հետևում են համար 4 և 3 ուսանողները՝ նվազման կարգով ընդհանուր միավորներով։ \n    Ուսանող համար 1-ը ունի ավելի ցածր ընդհանուր միավոր, քան ուսանող համար 2-ը, բայց ավելի բարձր չինարենի միավոր, \n    ուստի ուսանող համար 1-ը տեղադրվում է ուսանող համար 2-ից հետո դասավորված ցուցակում։\n    \n    Երկրորդ օրինակով, ուսանողներ համար 1-ը և 2-ը ունեն նույն ընդհանուր միավորը, բայց ուսանող համար 1-ը ունի ավելի բարձր չինարենի միավոր,\n    ուստի նրանք տեղադրվում են առաջինը։ Մնացածները դասավորվում են իրենց ընդհանուր միավորների նվազման կարգով։\n    \"\"\"",
      "bn": "def sort_students(student_scores):\n    \"\"\"\n    শিক্ষার্থীদের স্কোরের ভিত্তিতে একটি তালিকা সাজায়। শিক্ষার্থীরা প্রধানত তাদের মোট স্কোর (অবতরণী ক্রমে) দ্বারা সাজানো হয়,\n    তারপর তাদের চীনা স্কোর (অবতরণী ক্রমে) দ্বারা, এবং অবশেষে শিক্ষার্থী নম্বর (আরোহণী ক্রমে) দ্বারা যদি স্কোর সমান হয়।\n    \n    Args:\n    student_scores (list): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপলে (student_number, total_score, Chinese_score) থাকে।\n    \n    Returns:\n    list: উপরের নিয়ম অনুযায়ী সাজানো টুপলের একটি তালিকা।\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    প্রথম উদাহরণে, সর্বোচ্চ মোট স্কোর সহ শিক্ষার্থী হলেন নম্বর 6। শিক্ষার্থী নম্বর 4 এবং 3 তাদের অবতরণী মোট স্কোর সহ অনুসরণ করে।\n    শিক্ষার্থী নম্বর 1 এর মোট স্কোর শিক্ষার্থী নম্বর 2 এর চেয়ে কম, কিন্তু চীনা স্কোর বেশি, তাই শিক্ষার্থী নম্বর 1 শিক্ষার্থী নম্বর 2 এর পরে স্থাপন করা হয়।\n    \n    দ্বিতীয় উদাহরণে, শিক্ষার্থী নম্বর 1 এবং 2 এর একই মোট স্কোর রয়েছে, কিন্তু শিক্ষার্থী নম্বর 1 এর চীনা স্কোর বেশি,\n    তাই তারা প্রথম স্থানে রাখা হয়। বাকিরা তাদের অবতরণী মোট স্কোর দ্বারা সাজানো হয়।\n    \"\"\"",
      "bg": "def sort_students(student_scores):\n    \"\"\"\n    Сортира списък от студенти въз основа на техните резултати. Студентите се сортират първоначално по общия им резултат (в низходящ ред),\n    след това по резултата им по китайски език (в низходящ ред), и накрая по техния студентски номер (във възходящ ред) в случай на равенство.\n    \n    Args:\n    student_scores (list): Списък от кортежи, където всеки кортеж се състои от (студентски номер, общ резултат, резултат по китайски език).\n    \n    Returns:\n    list: Списък от кортежи, сортирани според горепосочените правила.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    В първия пример, студентът с най-висок общ резултат е номер 6. Следват студенти номер 4 и 3,\n    с намаляващи общи резултати. Студент номер 1 има по-нисък общ резултат от студент номер 2, но по-висок резултат по китайски език,\n    затова студент номер 1 е поставен след студент номер 2 в сортирания списък.\n    \n    Във втория пример, студенти номер 1 и 2 имат еднакъв общ резултат, но студент номер 1 има по-висок резултат по китайски език,\n    затова те са поставени първи. Останалите са сортирани по техните намаляващи общи резултати.\n    \"\"\"",
      "zh": "def sort_students(student_scores):\n    \"\"\"\n    根据学生的分数对学生列表进行排序。学生首先按总分（降序）排序，\n    然后按语文分数（降序）排序，最后在总分和语文分数相同的情况下按学号（升序）排序。\n    \n    参数:\n    student_scores (list): 一个元组列表，每个元组包含 (student_number, total_score, Chinese_score)。\n    \n    返回:\n    list: 一个根据上述规则排序的元组列表。\n    \n    示例:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    在第一个示例中，总分最高的学生是6号。接下来是4号和3号学生，总分依次递减。1号学生的总分低于2号学生，\n    但语文分数更高，因此在排序列表中1号学生排在2号学生之后。\n    \n    在第二个示例中，1号和2号学生的总分相同，但1号学生的语文分数更高，因此他们排在最前面。其余的按总分降序排列。\n    \"\"\"",
      "fr": "def sort_students(student_scores):\n    \"\"\"\n    Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant),\n    puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n    \n    Args:\n    student_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n    \n    Returns:\n    list: Une liste de tuples triés selon les règles ci-dessus.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Dans le premier exemple, l'étudiant avec le score total le plus élevé est le numéro 6. Les étudiants numéros 4 et 3 suivent,\n    avec des scores totaux décroissants. L'étudiant numéro 1 a un score total inférieur à l'étudiant numéro 2, mais un score en chinois plus élevé,\n    donc l'étudiant numéro 1 est placé après l'étudiant numéro 2 dans la liste triée.\n    \n    Dans le deuxième exemple, les étudiants numéros 1 et 2 ont le même score total, mais l'étudiant numéro 1 a un score en chinois plus élevé,\n    donc ils sont placés en premier. Les autres sont triés par leurs scores totaux décroissants.\n    \"\"\"",
      "de": "def sort_students(student_scores):\n    \"\"\"\n    Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden primär nach ihrer Gesamtpunktzahl (absteigend),\n    dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands sortiert.\n    \n    Args:\n    student_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (Studentennummer, Gesamtpunktzahl, Chinesisch-Punktzahl) besteht.\n    \n    Returns:\n    list: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n    \n    Beispiele:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Im ersten Beispiel hat der Student mit der höchsten Gesamtpunktzahl die Nummer 6. Die Studenten mit den Nummern 4 und 3 folgen,\n    mit absteigenden Gesamtpunktzahlen. Student Nummer 1 hat eine niedrigere Gesamtpunktzahl als Student Nummer 2, aber eine höhere Chinesisch-Punktzahl,\n    daher wird Student Nummer 1 nach Student Nummer 2 in der sortierten Liste platziert.\n    \n    Im zweiten Beispiel haben die Studenten mit den Nummern 1 und 2 die gleiche Gesamtpunktzahl, aber Student Nummer 1 hat eine höhere Chinesisch-Punktzahl,\n    daher werden sie zuerst platziert. Der Rest wird nach ihren absteigenden Gesamtpunktzahlen sortiert.\n    \"\"\"",
      "ha": "def sort_students(student_scores):\n    \"\"\"\n    Yana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimillar maki nasu (daga mafi girma zuwa ƙasa),\n    sannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙasa), kuma a ƙarshe bisa ga lambar ɗalibi (daga mafi ƙanƙanta zuwa mafi girma) idan akwai daidaito.\n    \n    Args:\n    student_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (lambar_ɗalibi, jimillar_maki, maki_Sinanci).\n    \n    Returns:\n    list: Jerin tuples da aka tsara bisa ga ƙa'idodin da ke sama.\n    \n    Misalai:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    A cikin misali na farko, ɗalibin da ke da jimillar maki mafi girma shi ne lamba 6. Ɗalibai lambobi 4 da 3 suna biye,\n    tare da jimillar maki masu raguwa. Ɗalibi lamba 1 yana da jimillar maki ƙasa da ɗalibi lamba 2, amma yana da maki na Sinanci mafi girma,\n    don haka ɗalibi lamba 1 yana bayan ɗalibi lamba 2 a cikin jerin da aka tsara.\n    \n    A cikin misali na biyu, ɗalibai lambobi 1 da 2 suna da jimillar maki ɗaya, amma ɗalibi lamba 1 yana da maki na Sinanci mafi girma,\n    don haka suna farko. Sauran suna tsara bisa ga jimillar maki nasu daga mafi girma zuwa ƙasa.\n    \"\"\"",
      "hi": "def sort_students(student_scores):\n    \"\"\"\n    छात्रों की एक सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंक (अवरोही क्रम में),\n    फिर उनके चीनी अंकों (अवरोही क्रम में), और अंत में टाई होने पर उनके छात्र संख्या (आरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है।\n    \n    Args:\n    student_scores (list): टुपल की एक सूची, जहाँ प्रत्येक टुपल में (student_number, total_score, Chinese_score) होते हैं।\n    \n    Returns:\n    list: उपरोक्त नियमों के अनुसार क्रमबद्ध टुपल की एक सूची।\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    पहले उदाहरण में, सबसे अधिक कुल अंक वाला छात्र संख्या 6 है। छात्र संख्या 4 और 3 इसके बाद आते हैं,\n    उनके कुल अंकों के अवरोही क्रम में। छात्र संख्या 1 के पास छात्र संख्या 2 की तुलना में कम कुल अंक हैं, लेकिन चीनी अंक अधिक हैं,\n    इसलिए छात्र संख्या 1 को क्रमबद्ध सूची में छात्र संख्या 2 के बाद रखा गया है।\n    \n    दूसरे उदाहरण में, छात्र संख्या 1 और 2 के समान कुल अंक हैं, लेकिन छात्र संख्या 1 के चीनी अंक अधिक हैं,\n    इसलिए उन्हें पहले रखा गया है। बाकी छात्रों को उनके कुल अंकों के अवरोही क्रम में क्रमबद्ध किया गया है।\n    \"\"\"",
      "hu": "def sort_students(student_scores):\n    \"\"\"\n    Egy lista diákot rendez a pontszámaik alapján. A diákok elsősorban az összpontszámuk szerint vannak rendezve (csökkenő sorrendben),\n    majd a kínai pontszámuk szerint (csökkenő sorrendben), és végül a diák azonosítójuk szerint (növekvő sorrendben) döntetlen esetén.\n    \n    Args:\n    student_scores (list): Egy lista, amelyben minden elem egy tuple, ami a következőket tartalmazza: (diák_azonosító, összpontszám, kínai_pontszám).\n    \n    Returns:\n    list: Egy lista tuple-ökkel, a fenti szabályok szerint rendezve.\n    \n    Példák:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Az első példában a legmagasabb összpontszámú diák a 6-os számú. A 4-es és 3-as számú diákok következnek,\n    csökkenő összpontszám szerint. Az 1-es számú diáknak alacsonyabb az összpontszáma, mint a 2-es számú diáknak, de magasabb a kínai pontszáma,\n    így az 1-es számú diák a 2-es számú diák után kerül a rendezett listába.\n    \n    A második példában az 1-es és 2-es számú diákoknak azonos az összpontszámuk, de az 1-es számú diáknak magasabb a kínai pontszáma,\n    így ők kerülnek az első helyre. A többiek csökkenő összpontszám szerint vannak rendezve.\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.978404706343506",
      "hy": "0.9615276787581146",
      "bn": "0.9766948960235576",
      "bg": "0.9688029137242794",
      "zh": "0.9485328819700501",
      "fr": "0.993458108400616",
      "de": "0.9841800833024763",
      "ha": "0.9527472227644673",
      "hi": "0.9729240968699913",
      "hu": "0.9554003287639503"
    },
    "canonical_solution": "    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students",
    "instruction": {
      "en": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nՏվյալ Python կոդի համար տրամադրեք կարճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\n请为以下Python代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nBa da takaitaccen bayanin yanayi na lamba (docstring) na lambar Python a cikin Hausa wanda bai wuce haruffa 500 ba.",
      "hi": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8697749427378118",
      "bn": "0.8751039972305968",
      "bg": "0.8983697723915943",
      "zh": "0.8708993893248503",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.8604514312824152",
      "hi": "0.8964889413135749",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_sort_students():\n    # Test case 1\n    input_scores = [(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)]\n    expected_output = [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 1 failed\"\n\n    # Test case 2\n    input_scores = [(1, 258, 80), (2, 264, 88), (3, 258, 90), (4, 244, 87), (5, 258, 78), (6, 264, 88), (7, 220, 67), (8, 265, 78)]\n    expected_output = [(8, 265, 78), (2, 264, 88), (6, 264, 88), (3, 258, 90), (1, 258, 80), (5, 258, 78), (4, 244, 87), (7, 220, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 2 failed\"\n\n    # Test case 3\n    input_scores = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    expected_output = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    assert sort_students(input_scores) == expected_output, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_sort_students()",
    "entry_point": "sort_students",
    "signature": "def sort_students(student_scores):",
    "docstring": {
      "en": "Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\nthen by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n\nArgs:\nstudent_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n\nReturns:\nlist: A list of tuples sorted according to the above rules.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nIn the first example, the student with the highest total score is number 6. Students number 4 and 3 follow,\nwith descending total scores. Student number 1 has a lower total score than student number 2, but a higher Chinese score,\nso student number 1 is placed after student number 2 in the sorted list.\n\nIn the second example, students number 1 and 2 have the same total score, but student number 1 has a higher Chinese score,\nso they are placed first. The rest are sorted by their descending total scores.",
      "sq": "Rendit një listë studentësh bazuar në notat e tyre. Studentët renditen kryesisht sipas notës së tyre totale (në zbritje), pastaj sipas notës së tyre në gjuhën kineze (në zbritje), dhe së fundi sipas numrit të tyre të studentit (në rritje) në rast të një barazimi.\n\nArgs:\nstudent_scores (list): Një listë tuples, ku çdo tuple përbëhet nga (numri_i_studentit, nota_totale, nota_kineze).\n\nReturns:\nlist: Një listë tuples e renditur sipas rregullave të mësipërme.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nNë shembullin e parë, studenti me notën më të lartë totale është numri 6. Studentët numër 4 dhe 3 ndjekin, me nota totale në zbritje. Studenti numër 1 ka një notë totale më të ulët se studenti numër 2, por një notë më të lartë në gjuhën kineze, kështu që studenti numër 1 vendoset pas studentit numër 2 në listën e renditur.\n\nNë shembullin e dytë, studentët numër 1 dhe 2 kanë të njëjtën notë totale, por studenti numër 1 ka një notë më të lartë në gjuhën kineze, kështu që ata vendosen të parët. Pjesa tjetër renditet sipas notave të tyre totale në zbritje.",
      "hy": "Դասավորում է ուսանողների ցուցակը՝ հիմնվելով նրանց գնահատականների վրա։ Ուսանողները դասավորվում են հիմնականում ըստ իրենց ընդհանուր գնահատականի (նվազման կարգով), ապա՝ ըստ իրենց չինարենի գնահատականի (նվազման կարգով), և վերջապես՝ ըստ իրենց ուսանողի համարի (աճման կարգով)՝ հավասարության դեպքում։\n\nԱրձանագրումներ:\nstudent_scores (list): Ցուցակ, որտեղ յուրաքանչյուր տուփ բաղկացած է (ուսանողի համար, ընդհանուր գնահատական, չինարեն գնահատական)։\n\nՎերադարձնում է:\nlist: Տուփերի ցուցակ՝ դասավորված ըստ վերը նշված կանոնների։\n\nՕրինակներ:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nԱռաջին օրինակով, ուսանողը, ով ունի ամենաբարձր ընդհանուր գնահատականը, համար 6-ն է։ Ուսանողներ համար 4-ը և 3-ը հաջորդում են՝ նվազման կարգով ընդհանուր գնահատականներով։ Ուսանող համար 1-ը ունի ավելի ցածր ընդհանուր գնահատական, քան ուսանող համար 2-ը, բայց ավելի բարձր չինարեն գնահատական, ուստի ուսանող համար 1-ը տեղադրվում է ուսանող համար 2-ից հետո դասավորված ցուցակում։\n\nԵրկրորդ օրինակով, ուսանողներ համար 1-ը և 2-ը ունեն նույն ընդհանուր գնահատականը, բայց ուսանող համար 1-ը ունի ավելի բարձր չինարեն գնահատական, ուստի նրանք տեղադրվում են առաջինը։ Մնացածը դասավորվում են իրենց ընդհանուր գնահատականների նվազման կարգով։",
      "bn": "ছাত্রদের একটি তালিকা তাদের স্কোরের ভিত্তিতে সাজায়। ছাত্রদের প্রধানত তাদের মোট স্কোর (অবতরণক্রমে) দ্বারা সাজানো হয়, তারপর তাদের চীনা স্কোর (অবতরণক্রমে) দ্বারা, এবং অবশেষে সমতার ক্ষেত্রে তাদের ছাত্র নম্বর (আরোহণক্রমে) দ্বারা।\n\nআর্গস:\nstudent_scores (list): একটি টুপলের তালিকা, যেখানে প্রতিটি টুপল (student_number, total_score, Chinese_score) নিয়ে গঠিত।\n\nরিটার্নস:\nlist: উপরের নিয়ম অনুযায়ী সাজানো টুপলের একটি তালিকা।\n\nউদাহরণ:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nপ্রথম উদাহরণে, সর্বোচ্চ মোট স্কোর সহ ছাত্র হলেন নম্বর 6। ছাত্র নম্বর 4 এবং 3 অনুসরণ করে, অবতরণক্রমে মোট স্কোর সহ। ছাত্র নম্বর 1 এর মোট স্কোর ছাত্র নম্বর 2 এর চেয়ে কম, কিন্তু চীনা স্কোর বেশি, তাই ছাত্র নম্বর 1 কে ছাত্র নম্বর 2 এর পরে সাজানো তালিকায় রাখা হয়েছে।\n\nদ্বিতীয় উদাহরণে, ছাত্র নম্বর 1 এবং 2 এর একই মোট স্কোর আছে, কিন্তু ছাত্র নম্বর 1 এর চীনা স্কোর বেশি, তাই তারা প্রথমে রাখা হয়েছে। বাকি ছাত্ররা তাদের অবতরণক্রমে মোট স্কোর দ্বারা সাজানো হয়েছে।",
      "bg": "Сортира списък от студенти въз основа на техните оценки. Студентите са сортирани основно по общата им оценка (в низходящ ред), след това по оценката им по китайски (в низходящ ред), и накрая по номера на студента (възходящ ред) в случай на равенство.\n\nАргументи:\nstudent_scores (list): Списък от кортежи, където всеки кортеж се състои от (номер_на_студент, обща_оценка, оценка_по_китайски).\n\nВръща:\nlist: Списък от кортежи, сортирани според горните правила.\n\nПримери:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nВ първия пример, студентът с най-висока обща оценка е номер 6. Следват студенти номер 4 и 3 с намаляващи общи оценки. Студент номер 1 има по-ниска обща оценка от студент номер 2, но по-висока оценка по китайски, затова студент номер 1 е поставен след студент номер 2 в сортирания списък.\n\nВъв втория пример, студентите номер 1 и 2 имат еднаква обща оценка, но студент номер 1 има по-висока оценка по китайски, затова те са поставени първи. Останалите са сортирани по намаляващите им общи оценки.",
      "zh": "对学生列表进行排序，主要依据他们的总分（降序），然后是他们的语文分数（降序），最后在分数相同的情况下根据学号（升序）排序。\n\n参数：\nstudent_scores (list): 一个元组列表，每个元组包含 (student_number, total_score, Chinese_score)。\n\n返回：\nlist: 一个根据上述规则排序的元组列表。\n\n示例：\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\n在第一个示例中，总分最高的学生是学号6。接下来是学号4和3，总分依次递减。学号1的总分低于学号2，但语文分数更高，因此学号1在排序列表中排在学号2之后。\n\n在第二个示例中，学号1和2的总分相同，但学号1的语文分数更高，因此他们排在最前面。其余的按照总分降序排序。",
      "fr": "Trie une liste d'étudiants en fonction de leurs scores. Les étudiants sont triés principalement par leur score total (décroissant), puis par leur score en chinois (décroissant), et enfin par leur numéro d'étudiant (croissant) en cas d'égalité.\n\nArgs:\nstudent_scores (list): Une liste de tuples, où chaque tuple se compose de (numéro_étudiant, score_total, score_chinois).\n\nReturns:\nlist: Une liste de tuples triés selon les règles ci-dessus.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nDans le premier exemple, l'étudiant avec le score total le plus élevé est le numéro 6. Les étudiants numéro 4 et 3 suivent, avec des scores totaux décroissants. L'étudiant numéro 1 a un score total inférieur à l'étudiant numéro 2, mais un score en chinois plus élevé, donc l'étudiant numéro 1 est placé après l'étudiant numéro 2 dans la liste triée.\n\nDans le deuxième exemple, les étudiants numéro 1 et 2 ont le même score total, mais l'étudiant numéro 1 a un score en chinois plus élevé, donc ils sont placés en premier. Les autres sont triés par leurs scores totaux décroissants.",
      "de": "Sortiert eine Liste von Studenten basierend auf ihren Punktzahlen. Die Studenten werden hauptsächlich nach ihrer Gesamtpunktzahl (absteigend) sortiert, dann nach ihrer Chinesisch-Punktzahl (absteigend) und schließlich nach ihrer Studentennummer (aufsteigend) im Falle eines Gleichstands.\n\nArgs:\nstudent_scores (list): Eine Liste von Tupeln, wobei jedes Tupel aus (student_number, total_score, Chinese_score) besteht.\n\nReturns:\nlist: Eine Liste von Tupeln, die gemäß den obigen Regeln sortiert ist.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nIm ersten Beispiel hat der Student mit der höchsten Gesamtpunktzahl die Nummer 6. Die Studenten mit den Nummern 4 und 3 folgen, mit absteigenden Gesamtpunktzahlen. Student Nummer 1 hat eine niedrigere Gesamtpunktzahl als Student Nummer 2, aber eine höhere Chinesisch-Punktzahl, daher wird Student Nummer 1 nach Student Nummer 2 in der sortierten Liste platziert.\n\nIm zweiten Beispiel haben die Studenten mit den Nummern 1 und 2 die gleiche Gesamtpunktzahl, aber Student Nummer 1 hat eine höhere Chinesisch-Punktzahl, daher werden sie zuerst platziert. Der Rest wird nach ihren absteigenden Gesamtpunktzahlen sortiert.",
      "ha": "Yana tsara jerin ɗalibai bisa ga maki nasu. Ana tsara ɗaliban ne da farko bisa ga jimillar maki nasu (daga mafi girma zuwa ƙasa),\nsannan bisa ga maki na Sinanci (daga mafi girma zuwa ƙasa), kuma a ƙarshe bisa ga lambar ɗalibi (daga mafi ƙanƙanta zuwa mafi girma) idan akwai daidaito.\n\nArgs:\nstudent_scores (list): Jerin tuples, inda kowanne tuple ya ƙunshi (student_number, total_score, Chinese_score).\n\nReturns:\nlist: Jerin tuples da aka jera bisa ga dokokin da ke sama.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nA cikin misali na farko, ɗalibin da ke da mafi girman jimillar maki shi ne lamba 6. Dalibai lamba 4 da 3 suna biye, tare da jimillar maki mai sauka. Dalibi lamba 1 yana da ƙananan jimillar maki fiye da dalibi lamba 2, amma yana da mafi girman maki na Sinanci, don haka dalibi lamba 1 yana bayan dalibi lamba 2 a cikin jerin da aka jera.\n\nA cikin misali na biyu, dalibai lamba 1 da 2 suna da jimillar maki iri ɗaya, amma dalibi lamba 1 yana da mafi girman maki na Sinanci, don haka suna farko. Sauran suna jerawa bisa ga jimillar maki mai sauka.",
      "hi": "छात्रों की एक सूची को उनके अंकों के आधार पर क्रमबद्ध करता है। छात्रों को मुख्य रूप से उनके कुल अंकों (अवरोही क्रम में) के आधार पर क्रमबद्ध किया जाता है, फिर उनके चीनी अंकों (अवरोही क्रम में), और अंत में टाई की स्थिति में उनके छात्र संख्या (आरोही क्रम में) के आधार पर।\n\nआर्ग्स:\nstudent_scores (list): ट्यूपल की एक सूची, जहाँ प्रत्येक ट्यूपल में (student_number, total_score, Chinese_score) होते हैं।\n\nवापसी:\nlist: उपरोक्त नियमों के अनुसार क्रमबद्ध ट्यूपल की एक सूची।\n\nउदाहरण:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nपहले उदाहरण में, सबसे अधिक कुल अंक वाला छात्र संख्या 6 है। छात्र संख्या 4 और 3 उसके बाद आते हैं, अवरोही कुल अंकों के साथ। छात्र संख्या 1 के पास छात्र संख्या 2 की तुलना में कम कुल अंक हैं, लेकिन अधिक चीनी अंक हैं, इसलिए छात्र संख्या 1 को क्रमबद्ध सूची में छात्र संख्या 2 के बाद रखा गया है।\n\nदूसरे उदाहरण में, छात्र संख्या 1 और 2 के पास समान कुल अंक हैं, लेकिन छात्र संख्या 1 के पास अधिक चीनी अंक हैं, इसलिए उन्हें पहले रखा गया है। बाकी को उनके अवरोही कुल अंकों के अनुसार क्रमबद्ध किया गया है।",
      "hu": "Rendezi a diákok listáját a pontszámaik alapján. A diákok elsősorban az összpontszámuk szerint (csökkenő sorrendben) vannak rendezve, majd a kínai pontszámuk szerint (csökkenő sorrendben), és végül a diák számuk szerint (növekvő sorrendben) döntetlen esetén.\n\nArgs:\nstudent_scores (list): Egy listája a tuple-öknek, ahol minden tuple a következőkből áll: (diák_szám, összpontszám, kínai_pontszám).\n\nReturns:\nlist: Egy listája a tuple-öknek, a fenti szabályok szerint rendezve.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nAz első példában a legmagasabb összpontszámmal rendelkező diák a 6-os számú. A 4-es és 3-as számú diákok követik, csökkenő összpontszámokkal. Az 1-es számú diáknak alacsonyabb az összpontszáma, mint a 2-es számú diáknak, de magasabb a kínai pontszáma, így az 1-es számú diák a 2-es számú diák után van elhelyezve a rendezett listában.\n\nA második példában az 1-es és 2-es számú diákoknak azonos az összpontszámuk, de az 1-es számú diáknak magasabb a kínai pontszáma, így ők kerülnek előre. A többiek csökkenő összpontszám szerint vannak rendezve."
    },
    "docstring_bertscore": {
      "sq": "0.9607107120009181",
      "hy": "0.964586983886814",
      "bn": "0.9785278571797476",
      "bg": "0.9703665320837861",
      "zh": "0.9468216812374346",
      "fr": "0.9922782439372687",
      "de": "0.9940150679890378",
      "ha": "0.9941715887292932",
      "hi": "0.9731835081476229",
      "hu": "0.9661887392794792"
    }
  },
  {
    "task_id": "Python/48",
    "prompt": {
      "en": "def min_groups(w, n, prices):\n    \"\"\"\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    \n    Case 1:\n    A limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    The minimum number of groups is 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Case 2:\n    A limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\n    The minimum number of groups is 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Case 3:\n    A limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\n    Since each pair's total price does not exceed the limit, the minimum number of groups is 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "sq": "def min_groups(w, n, prices):\n    \"\"\"\n    Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suveniret me një kufizim në çmimin total të grupit.\n    \n    Suveniret grupohen në çifte të tilla që çmimi total i secilit grup nuk e tejkalon kufirin `w`. \n    Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n    \n    Args:\n    w (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\n    n (int): Numri total i suvenireve.\n    prices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n    \n    Returns:\n    int: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\n    Shembuj:\n    \n    Rasti 1:\n    Një kufi prej 100 dhe 9 suvenire me çmime [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Numri minimal i grupeve është 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Rasti 2:\n    Një kufi prej 200 dhe 5 suvenire me çmime [80, 120, 60, 40, 100].\n    Numri minimal i grupeve është 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Rasti 3:\n    Një kufi prej 80 dhe 4 suvenire me çmime [30, 30, 20, 10].\n    Meqenëse çmimi total i secilit çift nuk e tejkalon kufirin, numri minimal i grupeve është 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "hy": "def min_groups(w, n, prices):\n    \"\"\"\n    Որոշում է անհրաժեշտ խմբերի նվազագույն քանակը հուշանվերները բաշխելու համար՝ խմբի ընդհանուր գնի սահմանափակմամբ։\n    \n    Հուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի `w` սահմանը։\n    Ֆունկցիան նպատակ ունի նվազեցնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո։\n    \n    Արգումենտներ:\n    w (int): Հուշանվերների ցանկացած խմբի գների թույլատրելի առավելագույն գումարը։\n    n (int): Հուշանվերների ընդհանուր քանակը։\n    prices (list): Ցանկ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը ամբողջ թվերով։\n    \n    Վերադարձնում է:\n    int: Անհրաժեշտ խմբերի նվազագույն քանակը՝ բոլոր հուշանվերները բաշխելու համար։\n\n    Օրինակներ:\n    \n    Դեպք 1:\n    100 սահման և 9 հուշանվերներ գներով [90, 20, 20, 30, 50, 60, 70, 80, 90]։\n    Նվազագույն խմբերի քանակը 6 է։\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Դեպք 2:\n    200 սահման և 5 հուշանվերներ գներով [80, 120, 60, 40, 100]։\n    Նվազագույն խմբերի քանակը 3 է։\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Դեպք 3:\n    80 սահման և 4 հուշանվերներ գներով [30, 30, 20, 10]։\n    Քանի որ յուրաքանչյուր զույգի ընդհանուր գինը չի գերազանցում սահմանը, նվազագույն խմբերի քանակը 2 է։\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "bn": "def min_groups(w, n, prices):\n    \"\"\"\n    স্মৃতিচিহ্ন বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করে একটি গ্রুপের মোট মূল্যের সীমাবদ্ধতা সহ।\n    \n    স্মৃতিচিহ্নগুলি এমনভাবে জোড়ায় জোড়ায় গ্রুপ করা হয় যাতে প্রতিটি গ্রুপের মোট মূল্য সীমা `w` অতিক্রম না করে। \n    এই সীমাবদ্ধতার অধীনে তৈরি গ্রুপের সংখ্যা কমিয়ে আনার লক্ষ্য রাখে ফাংশনটি।\n    \n    Args:\n    w (int): যে কোনো স্মৃতিচিহ্নের গ্রুপের জন্য অনুমোদিত সর্বাধিক মূল্যের যোগফল।\n    n (int): স্মৃতিচিহ্নের মোট সংখ্যা।\n    prices (list): প্রতিটি স্মৃতিচিহ্নের মূল্য উপস্থাপনকারী পূর্ণসংখ্যার তালিকা।\n    \n    Returns:\n    int: সমস্ত স্মৃতিচিহ্ন বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ।\n\n    উদাহরণসমূহ:\n    \n    কেস 1:\n    100 এর সীমা এবং 9 টি স্মৃতিচিহ্ন যার মূল্য [90, 20, 20, 30, 50, 60, 70, 80, 90]।\n    সর্বনিম্ন গ্রুপের সংখ্যা 6।\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    কেস 2:\n    200 এর সীমা এবং 5 টি স্মৃতিচিহ্ন যার মূল্য [80, 120, 60, 40, 100]।\n    সর্বনিম্ন গ্রুপের সংখ্যা 3।\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    কেস 3:\n    80 এর সীমা এবং 4 টি স্মৃতিচিহ্ন যার মূল্য [30, 30, 20, 10]।\n    যেহেতু প্রতিটি জোড়ার মোট মূল্য সীমা অতিক্রম করে না, সর্বনিম্ন গ্রুপের সংখ্যা 2।\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "bg": "def min_groups(w, n, prices):\n    \"\"\"\n    Определя минималния брой групи, необходими за разпределение на сувенири с ограничение на общата цена на групата.\n    \n    Сувенирите се групират по двойки така, че общата цена на всяка група да не надвишава лимита `w`. \n    Функцията има за цел да минимизира броя на създадените групи при това ограничение.\n    \n    Аргументи:\n    w (int): Максимално допустимата сума на цените за която и да е група сувенири.\n    n (int): Общият брой на сувенирите.\n    prices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n    \n    Връща:\n    int: Минималният брой групи, необходими за разпределение на всички сувенири.\n\n    Примери:\n    \n    Случай 1:\n    Лимит от 100 и 9 сувенира с цени [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Минималният брой групи е 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Случай 2:\n    Лимит от 200 и 5 сувенира с цени [80, 120, 60, 40, 100].\n    Минималният брой групи е 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Случай 3:\n    Лимит от 80 и 4 сувенира с цени [30, 30, 20, 10].\n    Тъй като общата цена на всяка двойка не надвишава лимита, минималният брой групи е 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "zh": "def min_groups(w, n, prices):\n    \"\"\"\n    确定在对组的总价格有限制的情况下分配纪念品所需的最小组数。\n    \n    纪念品成对分组，使每组的总价格不超过限制 `w`。\n    该函数旨在在此限制下最小化创建的组数。\n    \n    参数:\n    w (int): 任何纪念品组允许的最大价格总和。\n    n (int): 纪念品的总数量。\n    prices (list): 一个整数列表，表示每个纪念品的价格。\n    \n    返回:\n    int: 分配所有纪念品所需的最小组数。\n\n    示例:\n    \n    案例 1:\n    限制为 100 和 9 个纪念品，价格为 [90, 20, 20, 30, 50, 60, 70, 80, 90]。\n    最小组数为 6。\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    案例 2:\n    限制为 200 和 5 个纪念品，价格为 [80, 120, 60, 40, 100]。\n    最小组数为 3。\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    案例 3:\n    限制为 80 和 4 个纪念品，价格为 [30, 30, 20, 10]。\n    由于每对的总价格不超过限制，最小组数为 2。\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "fr": "def min_groups(w, n, prices):\n    \"\"\"\n    Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n    \n    Les souvenirs sont regroupés par paires de sorte que le prix total de chaque groupe ne dépasse pas la limite `w`. \n    La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n    \n    Args:\n    w (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\n    n (int): Le nombre total de souvenirs.\n    prices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n    \n    Returns:\n    int: Le nombre minimum de groupes requis pour distribuer tous les souvenirs.\n\n    Exemples:\n    \n    Cas 1:\n    Une limite de 100 et 9 souvenirs avec des prix [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Le nombre minimum de groupes est 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Cas 2:\n    Une limite de 200 et 5 souvenirs avec des prix [80, 120, 60, 40, 100].\n    Le nombre minimum de groupes est 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Cas 3:\n    Une limite de 80 et 4 souvenirs avec des prix [30, 30, 20, 10].\n    Comme le prix total de chaque paire ne dépasse pas la limite, le nombre minimum de groupes est 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "de": "def min_groups(w, n, prices):\n    \"\"\"\n    Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung auf den Gesamtpreis der Gruppe zu verteilen.\n    \n    Die Souvenirs werden paarweise gruppiert, sodass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet. \n    Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n    \n    Argumente:\n    w (int): Die maximal erlaubte Summe der Preise für jede Gruppe von Souvenirs.\n    n (int): Die Gesamtanzahl der Souvenirs.\n    prices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n    \n    Rückgabewert:\n    int: Die minimale Anzahl von Gruppen, die erforderlich sind, um alle Souvenirs zu verteilen.\n\n    Beispiele:\n    \n    Fall 1:\n    Ein Limit von 100 und 9 Souvenirs mit Preisen [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Die minimale Anzahl von Gruppen ist 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Fall 2:\n    Ein Limit von 200 und 5 Souvenirs mit Preisen [80, 120, 60, 40, 100].\n    Die minimale Anzahl von Gruppen ist 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Fall 3:\n    Ein Limit von 80 und 4 Souvenirs mit Preisen [30, 30, 20, 10].\n    Da der Gesamtpreis jedes Paares das Limit nicht überschreitet, ist die minimale Anzahl von Gruppen 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "ha": "def min_groups(w, n, prices):\n    \"\"\"\n    Yana tantance mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta tare da ƙuntatawa kan jimillar farashin ƙungiyar.\n\n    Ana haɗa kayan kyaututtuka a cikin ma'aurata ta yadda jimillar farashin kowace ƙungiya ba ta wuce iyaka `w`. \n    Aikin yana nufin rage yawan ƙungiyoyin da aka ƙirƙira ƙarƙashin wannan ƙuntatawa.\n\n    Args:\n    w (int): Mafi girman adadin jimillar farashin kowace ƙungiyar kayan kyauta.\n    n (int): Jimillar adadin kayan kyauta.\n    prices (list): Jerin lambobi masu wakiltar farashin kowane kayan kyauta.\n\n    Returns:\n    int: Mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba duk kayan kyauta.\n\n    Misalai:\n    \n    Case 1:\n    Iyaka na 100 da kayan kyauta 9 tare da farashi [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Mafi ƙarancin adadin ƙungiyoyi shine 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Case 2:\n    Iyaka na 200 da kayan kyauta 5 tare da farashi [80, 120, 60, 40, 100].\n    Mafi ƙarancin adadin ƙungiyoyi shine 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Case 3:\n    Iyaka na 80 da kayan kyauta 4 tare da farashi [30, 30, 20, 10].\n    Tun da jimillar farashin kowace ma'aurata ba ta wuce iyaka ba, mafi ƙarancin adadin ƙungiyoyi shine 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "hi": "def min_groups(w, n, prices):\n    \"\"\"\n    स्मृति चिह्नों को एक सीमा के साथ समूह की कुल कीमत पर वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करता है।\n    \n    स्मृति चिह्नों को जोड़ों में इस तरह से समूहबद्ध किया जाता है कि प्रत्येक समूह की कुल कीमत सीमा `w` से अधिक न हो। \n    यह फ़ंक्शन इस सीमा के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का प्रयास करता है।\n    \n    Args:\n    w (int): किसी भी स्मृति चिह्न समूह के लिए अनुमत कीमतों का अधिकतम योग।\n    n (int): स्मृति चिह्नों की कुल संख्या।\n    prices (list): प्रत्येक स्मृति चिह्न की कीमत का प्रतिनिधित्व करने वाले पूर्णांकों की सूची।\n    \n    Returns:\n    int: सभी स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\n    उदाहरण:\n    \n    मामला 1:\n    100 की सीमा और 9 स्मृति चिह्न जिनकी कीमतें [90, 20, 20, 30, 50, 60, 70, 80, 90] हैं।\n    न्यूनतम समूहों की संख्या 6 है।\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    मामला 2:\n    200 की सीमा और 5 स्मृति चिह्न जिनकी कीमतें [80, 120, 60, 40, 100] हैं।\n    न्यूनतम समूहों की संख्या 3 है।\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    मामला 3:\n    80 की सीमा और 4 स्मृति चिह्न जिनकी कीमतें [30, 30, 20, 10] हैं।\n    चूंकि प्रत्येक जोड़े की कुल कीमत सीमा से अधिक नहीं है, न्यूनतम समूहों की संख्या 2 है।\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "hu": "def min_groups(w, n, prices):\n    \"\"\"\n    Meghatározza a szükséges minimális csoportok számát az ajándéktárgyak elosztásához, a csoport teljes árának korlátozásával.\n    \n    Az ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport teljes ára ne haladja meg a `w` korlátot. \n    A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás alatt.\n    \n    Args:\n    w (int): Az ajándéktárgyak bármely csoportjának megengedett maximális árösszege.\n    n (int): Az ajándéktárgyak teljes száma.\n    prices (list): Egész számokat tartalmazó lista, amely az egyes ajándéktárgyak árát reprezentálja.\n    \n    Returns:\n    int: A szükséges minimális csoportok száma az összes ajándéktárgy elosztásához.\n\n    Példák:\n    \n    1. eset:\n    100-as korlát és 9 ajándéktárgy áraival [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    A minimális csoportok száma 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    2. eset:\n    200-as korlát és 5 ajándéktárgy áraival [80, 120, 60, 40, 100].\n    A minimális csoportok száma 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    3. eset:\n    80-as korlát és 4 ajándéktárgy áraival [30, 30, 20, 10].\n    Mivel minden pár teljes ára nem haladja meg a korlátot, a minimális csoportok száma 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9790246317627158",
      "hy": "0.9747514963755123",
      "bn": "0.9795541803585548",
      "bg": "0.9844452548611579",
      "zh": "0.9525563389682928",
      "fr": "0.9872822925934792",
      "de": "0.9807600654018176",
      "ha": "0.9419546410109367",
      "hi": "0.9645659290664242",
      "hu": "0.9335781992123144"
    },
    "canonical_solution": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups",
    "instruction": {
      "en": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nপাইথন কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nपायथन कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.9053846029282224",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9349860913530897",
      "hi": "0.9109764454151166",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "def test_min_groups():\n    # Test case 1\n    w1 = 100\n    n1 = 9\n    prices1 = [90, 20, 20, 30, 50, 60, 70, 80, 90]\n    expected_output1 = 6\n    assert min_groups(w1, n1, prices1) == expected_output1, \"Test case 1 failed\"\n\n    # Test case 2\n    w2 = 200\n    n2 = 5\n    prices2 = [80, 120, 60, 40, 100]\n    expected_output2 = 3\n    assert min_groups(w2, n2, prices2) == expected_output2, \"Test case 2 failed\"\n\n    # Test case 3\n    w3 = 80\n    n3 = 4\n    prices3 = [30, 30, 20, 10]\n    expected_output3 = 2\n    assert min_groups(w3, n3, prices3) == expected_output3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_min_groups()",
    "entry_point": "min_groups",
    "signature": "def min_groups(w, n, prices):",
    "docstring": {
      "en": "Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n\nThe souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`.\nThe function aims to minimize the number of groups created under this constraint.\n\nArgs:\nw (int): The maximum allowed sum of prices for any group of souvenirs.\nn (int): The total number of souvenirs.\nprices (list): A list of integers representing the price of each souvenir.\n\nReturns:\nint: The minimum number of groups required to distribute all souvenirs.\n\nExamples:\n\nCase 1:\nA limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\nThe minimum number of groups is 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCase 2:\nA limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\nThe minimum number of groups is 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCase 3:\nA limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\nSince each pair's total price does not exceed the limit, the minimum number of groups is 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "sq": "Përcakton numrin minimal të grupeve të nevojshme për të shpërndarë suveniret me një kufizim mbi çmimin total të grupit.\n\nSuveniret janë grupuar në çifte në mënyrë që çmimi total i secilit grup të mos e kalojë kufirin `w`. Funksioni synon të minimizojë numrin e grupeve të krijuara nën këtë kufizim.\n\nArgumentet:\nw (int): Shuma maksimale e lejuar e çmimeve për çdo grup suveniresh.\nn (int): Numri total i suvenireve.\nprices (list): Një listë e numrave të plotë që përfaqësojnë çmimin e secilit suvenir.\n\nKthen:\nint: Numri minimal i grupeve të nevojshme për të shpërndarë të gjitha suveniret.\n\nShembuj:\n\nRasti 1:\nNjë kufi prej 100 dhe 9 suvenire me çmime [90, 20, 20, 30, 50, 60, 70, 80, 90].\nNumri minimal i grupeve është 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nRasti 2:\nNjë kufi prej 200 dhe 5 suvenire me çmime [80, 120, 60, 40, 100].\nNumri minimal i grupeve është 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nRasti 3:\nNjë kufi prej 80 dhe 4 suvenire me çmime [30, 30, 20, 10].\nMeqenëse çmimi total i çdo çifti nuk e kalon kufirin, numri minimal i grupeve është 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "hy": "Սահմանում է անհրաժեշտ խմբերի նվազագույն քանակը, որպեսզի բաշխվեն հուշանվերները՝ խմբի ընդհանուր գնի սահմանափակմամբ։\n\nՀուշանվերները խմբավորվում են զույգերով այնպես, որ յուրաքանչյուր խմբի ընդհանուր գինը չգերազանցի սահմանը `w`:\nՖունկցիան նպատակ ունի նվազագույնացնել ստեղծված խմբերի քանակը այս սահմանափակման ներքո։\n\nԱրգումենտներ:\nw (int): Հուշանվերների ցանկացած խմբի համար թույլատրելի գների գումարի առավելագույն սահմանը։\nn (int): Հուշանվերների ընդհանուր քանակը։\nprices (list): Ցուցակ, որը ներկայացնում է յուրաքանչյուր հուշանվերի գինը։\n\nՎերադարձնում է:\nint: Անհրաժեշտ խմբերի նվազագույն քանակը՝ բոլոր հուշանվերները բաշխելու համար։\n\nՕրինակներ:\n\nԴեպք 1:\n100 սահման և 9 հուշանվերներ՝ գներով [90, 20, 20, 30, 50, 60, 70, 80, 90]:\nՆվազագույն խմբերի քանակը 6 է։\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nԴեպք 2:\n200 սահման և 5 հուշանվերներ՝ գներով [80, 120, 60, 40, 100]:\nՆվազագույն խմբերի քանակը 3 է։\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nԴեպք 3:\n80 սահման և 4 հուշանվերներ՝ գներով [30, 30, 20, 10]:\nՔանի որ յուրաքանչյուր զույգի ընդհանուր գինը չի գերազանցում սահմանը, նվազագույն խմբերի քանակը 2 է։\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "bn": "স্মারক বিতরণের জন্য প্রয়োজনীয় ন্যূনতম সংখ্যক গ্রুপ নির্ধারণ করে যেখানে গ্রুপের মোট মূল্যের উপর একটি সীমাবদ্ধতা রয়েছে।\n\nস্মারকগুলোকে জোড়ায় জোড়ায় গ্রুপ করা হয় যাতে প্রতিটি গ্রুপের মোট মূল্য সীমা `w` অতিক্রম না করে। এই ফাংশনটি এই সীমাবদ্ধতার অধীনে তৈরি করা গ্রুপের সংখ্যা কমানোর লক্ষ্য রাখে।\n\nআর্গস:\nw (int): যে কোনো স্মারক গ্রুপের জন্য অনুমোদিত মূল্যের সর্বাধিক যোগফল।\nn (int): স্মারকের মোট সংখ্যা।\nprices (list): প্রতিটি স্মারকের মূল্য উপস্থাপনকারী পূর্ণসংখ্যার তালিকা।\n\nরিটার্নস:\nint: সমস্ত স্মারক বিতরণের জন্য প্রয়োজনীয় ন্যূনতম গ্রুপের সংখ্যা।\n\nউদাহরণসমূহ:\n\nকেস ১:\n১০০ এর সীমা এবং ৯টি স্মারক যার মূল্য [90, 20, 20, 30, 50, 60, 70, 80, 90]।\nন্যূনতম গ্রুপের সংখ্যা ৬।\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nকেস ২:\n২০০ এর সীমা এবং ৫টি স্মারক যার মূল্য [80, 120, 60, 40, 100]।\nন্যূনতম গ্রুপের সংখ্যা ৩।\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nকেস ৩:\n৮০ এর সীমা এবং ৪টি স্মারক যার মূল্য [30, 30, 20, 10]।\nযেহেতু প্রতিটি জোড়ার মোট মূল্য সীমা অতিক্রম করে না, ন্যূনতম গ্রুপের সংখ্যা ২।\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "bg": "Определя минималния брой групи, необходими за разпределение на сувенири с ограничение върху общата цена на групата.\n\nСувенирите са групирани по двойки така, че общата цена на всяка група да не надвишава лимита `w`. Функцията цели да минимизира броя на създадените групи при това ограничение.\n\nArgs:\nw (int): Максимално допустимата сума на цените за всяка група сувенири.\nn (int): Общият брой на сувенирите.\nprices (list): Списък от цели числа, представляващи цената на всеки сувенир.\n\nReturns:\nint: Минималният брой групи, необходими за разпределение на всички сувенири.\n\nExamples:\n\nСлучай 1:\nЛимит от 100 и 9 сувенира с цени [90, 20, 20, 30, 50, 60, 70, 80, 90].\nМинималният брой групи е 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nСлучай 2:\nЛимит от 200 и 5 сувенира с цени [80, 120, 60, 40, 100].\nМинималният брой групи е 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nСлучай 3:\nЛимит от 80 и 4 сувенира с цени [30, 30, 20, 10].\nТъй като общата цена на всяка двойка не надвишава лимита, минималният брой групи е 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "zh": "确定分配纪念品所需的最小组数，并对组的总价格进行限制。\n\n纪念品按对分组，使得每组的总价格不超过限制 `w`。\n该函数旨在在此约束下最小化创建的组数。\n\n参数：\nw (int): 任何纪念品组允许的最大价格总和。\nn (int): 纪念品的总数量。\nprices (list): 一个整数列表，表示每个纪念品的价格。\n\n返回：\nint: 分配所有纪念品所需的最小组数。\n\n示例：\n\n案例 1：\n限制为 100 和 9 个纪念品，价格为 [90, 20, 20, 30, 50, 60, 70, 80, 90]。\n最小组数为 6。\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\n案例 2：\n限制为 200 和 5 个纪念品，价格为 [80, 120, 60, 40, 100]。\n最小组数为 3。\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\n案例 3：\n限制为 80 和 4 个纪念品，价格为 [30, 30, 20, 10]。\n由于每对的总价格不超过限制，最小组数为 2。\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "fr": "Détermine le nombre minimum de groupes nécessaires pour distribuer des souvenirs avec une contrainte sur le prix total du groupe.\n\nLes souvenirs sont regroupés par paires de telle sorte que le prix total de chaque groupe ne dépasse pas la limite `w`. La fonction vise à minimiser le nombre de groupes créés sous cette contrainte.\n\nArgs:\nw (int): La somme maximale autorisée des prix pour tout groupe de souvenirs.\nn (int): Le nombre total de souvenirs.\nprices (list): Une liste d'entiers représentant le prix de chaque souvenir.\n\nReturns:\nint: Le nombre minimum de groupes requis pour distribuer tous les souvenirs.\n\nExamples:\n\nCas 1:\nUne limite de 100 et 9 souvenirs avec des prix [90, 20, 20, 30, 50, 60, 70, 80, 90].\nLe nombre minimum de groupes est 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCas 2:\nUne limite de 200 et 5 souvenirs avec des prix [80, 120, 60, 40, 100].\nLe nombre minimum de groupes est 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCas 3:\nUne limite de 80 et 4 souvenirs avec des prix [30, 30, 20, 10].\nPuisque le prix total de chaque paire ne dépasse pas la limite, le nombre minimum de groupes est 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "de": "Bestimmt die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs mit einer Einschränkung des Gesamtpreises der Gruppe zu verteilen.\n\nDie Souvenirs werden paarweise gruppiert, so dass der Gesamtpreis jeder Gruppe das Limit `w` nicht überschreitet. Die Funktion zielt darauf ab, die Anzahl der unter dieser Einschränkung erstellten Gruppen zu minimieren.\n\nArgs:\nw (int): Die maximal zulässige Summe der Preise für jede Gruppe von Souvenirs.\nn (int): Die Gesamtanzahl der Souvenirs.\nprices (list): Eine Liste von ganzen Zahlen, die den Preis jedes Souvenirs darstellen.\n\nReturns:\nint: Die minimale Anzahl von Gruppen, die erforderlich sind, um alle Souvenirs zu verteilen.\n\nExamples:\n\nFall 1:\nEin Limit von 100 und 9 Souvenirs mit Preisen [90, 20, 20, 30, 50, 60, 70, 80, 90].\nDie minimale Anzahl von Gruppen ist 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nFall 2:\nEin Limit von 200 und 5 Souvenirs mit Preisen [80, 120, 60, 40, 100].\nDie minimale Anzahl von Gruppen ist 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nFall 3:\nEin Limit von 80 und 4 Souvenirs mit Preisen [30, 30, 20, 10].\nDa der Gesamtpreis jedes Paares das Limit nicht überschreitet, ist die minimale Anzahl von Gruppen 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "ha": "Yana tantance mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta tare da ƙuntatawa akan jimillar farashin ƙungiyar.\n\nAna haɗa kayan kyaututtuka a cikin ma'aurata ta yadda jimillar farashin kowace ƙungiya ba ta wuce iyaka `w`.\nAikin aikin shine rage adadin ƙungiyoyin da aka ƙirƙira ƙarƙashin wannan ƙuntatawa.\n\nArgs:\nw (int): Mafi girman adadin farashin da aka yarda don kowace ƙungiyar kayan kyauta.\nn (int): Jimillar adadin kayan kyauta.\nprices (list): Jerin lambobin da ke wakiltar farashin kowanne kayan kyauta.\n\nReturns:\nint: Mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba duk kayan kyauta.\n\nMisalai:\n\nHali na 1:\nIyaka na 100 da kayan kyauta 9 tare da farashi [90, 20, 20, 30, 50, 60, 70, 80, 90].\nMafi ƙarancin adadin ƙungiyoyi shine 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nHali na 2:\nIyaka na 200 da kayan kyauta 5 tare da farashi [80, 120, 60, 40, 100].\nMafi ƙarancin adadin ƙungiyoyi shine 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nHali na 3:\nIyaka na 80 da kayan kyauta 4 tare da farashi [30, 30, 20, 10].\nTunda jimillar farashin kowanne ma'aurata ba ta wuce iyaka ba, mafi ƙarancin adadin ƙungiyoyi shine 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "hi": "स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करता है, जिसमें समूह की कुल कीमत पर एक बाधा होती है।\n\nस्मृति चिह्नों को जोड़ों में इस प्रकार समूहित किया जाता है कि प्रत्येक समूह की कुल कीमत सीमा `w` से अधिक न हो।\nयह फ़ंक्शन इस बाधा के तहत बनाए गए समूहों की संख्या को न्यूनतम करने का प्रयास करता है।\n\nआर्ग्स:\nw (int): किसी भी स्मृति चिन्ह समूह के लिए अनुमत कीमतों का अधिकतम योग।\nn (int): स्मृति चिह्नों की कुल संख्या।\nprices (list): प्रत्येक स्मृति चिन्ह की कीमत का प्रतिनिधित्व करने वाले पूर्णांकों की सूची।\n\nरिटर्न्स:\nint: सभी स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या।\n\nउदाहरण:\n\nमामला 1:\n100 की सीमा और 9 स्मृति चिह्न जिनकी कीमतें [90, 20, 20, 30, 50, 60, 70, 80, 90] हैं।\nन्यूनतम समूहों की संख्या 6 है।\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nमामला 2:\n200 की सीमा और 5 स्मृति चिह्न जिनकी कीमतें [80, 120, 60, 40, 100] हैं।\nन्यूनतम समूहों की संख्या 3 है।\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nमामला 3:\n80 की सीमा और 4 स्मृति चिह्न जिनकी कीमतें [30, 30, 20, 10] हैं।\nचूंकि प्रत्येक जोड़े की कुल कीमत सीमा से अधिक नहीं है, न्यूनतम समूहों की संख्या 2 है।\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "hu": "Meghatározza a szükséges csoportok minimális számát az ajándéktárgyak elosztásához, figyelembe véve a csoportok összárának korlátozását.\n\nAz ajándéktárgyakat párokba csoportosítják úgy, hogy minden csoport összára ne haladja meg a `w` korlátot. A függvény célja a létrehozott csoportok számának minimalizálása ezen korlátozás mellett.\n\nArgs:\nw (int): Az ajándéktárgyak bármely csoportjának megengedett maximális árösszege.\nn (int): Az ajándéktárgyak teljes száma.\nprices (list): Egész számokat tartalmazó lista, amely az egyes ajándéktárgyak árát jelöli.\n\nReturns:\nint: A szükséges minimális csoportok száma az összes ajándéktárgy elosztásához.\n\nPéldák:\n\n1. eset:\n100-as korlát és 9 ajándéktárgy, amelyek árai [90, 20, 20, 30, 50, 60, 70, 80, 90].\nA minimális csoportok száma 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\n2. eset:\n200-as korlát és 5 ajándéktárgy, amelyek árai [80, 120, 60, 40, 100].\nA minimális csoportok száma 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\n3. eset:\n80-as korlát és 4 ajándéktárgy, amelyek árai [30, 30, 20, 10].\nMivel minden pár összára nem haladja meg a korlátot, a minimális csoportok száma 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9835470482781181",
      "hy": "0.9710943137998979",
      "bn": "0.9420509767457386",
      "bg": "0.9859069758351936",
      "zh": "0.9605514104353281",
      "fr": "0.9894064458882663",
      "de": "0.9890401714656379",
      "ha": "0.9237908858172014",
      "hi": "0.978609891527115",
      "hu": "0.9436636568093608"
    }
  },
  {
    "task_id": "Python/49",
    "prompt": {
      "en": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n    - For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n    - For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair, \n      4 more for the second, and then 8 additional moves for the third pair.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "sq": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Llogarit numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoi me dy disqe për n palë disqesh.\n    \n    Kjo funksion implementon një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n    2n disqe nga shtylla A në shtyllën C në një konfigurim të Kullave të Hanoi me dy disqe, duke ndjekur rregullat që vetëm një disk \n    mund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një lidhje të njohur rekursive \n    dhe llogarit në mënyrë iterative numrin total të lëvizjeve për n palë disqesh.\n    \n    Argumentet:\n    n (int): Numri i palëve të disqeve (secila prej dy disqeve identike) në shtyllën A.\n\n    Kthen:\n    int: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjithë disqet nga shtylla A në shtyllën C.\n\n    Rastet:\n    - Për n=1, funksioni duhet të kthejë 2, pasi ka dy disqe identike që mund të zhvendosen në dy lëvizje.\n    - Për n=2, funksioni duhet të kthejë 6, pasi duhen 2 lëvizje për palën e parë dhe pastaj 4 lëvizje të tjera për palën e dytë.\n    - Për n=3, funksioni duhet të kthejë 14, që është rezultati i procesit iterativ: 2 lëvizje për palën e parë, \n      4 të tjera për të dytën, dhe pastaj 8 lëvizje shtesë për palën e tretë.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "hy": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Հաշվարկել նվազագույն քայլերի քանակը, որը պահանջվում է կրկնակի սկավառակների Հանոյյան աշտարակների խնդիրը լուծելու համար n զույգ սկավառակների համար:\n    \n    Այս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու համար նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները\n    A ձողից C ձող տեղափոխելու համար կրկնակի սկավառակների Հանոյյան աշտարակների պարագայում՝ հետևելով այն կանոններին, որ միայն մեկ սկավառակ\n    կարող է տեղափոխվել միաժամանակ և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա: Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն\n    և իտերատիվ կերպով հաշվարկում է քայլերի ընդհանուր քանակը n զույգ սկավառակների համար:\n    \n    Արգումենտներ:\n    n (int): A ձողի վրա գտնվող սկավառակների զույգերի քանակը (յուրաքանչյուր զույգ բաղկացած է երկու նույնական սկավառակներից):\n\n    Վերադարձնում է:\n    int: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A ձողից C ձող տեղափոխելու համար:\n\n    Դեպքեր:\n    - n=1-ի դեպքում ֆունկցիան պետք է վերադարձնի 2, քանի որ կան երկու նույնական սկավառակներ, որոնք կարող են տեղափոխվել երկու քայլով:\n    - n=2-ի դեպքում ֆունկցիան պետք է վերադարձնի 6, քանի որ 2 քայլ է պահանջվում առաջին զույգի համար, և ապա 4 քայլ՝ երկրորդ զույգի համար:\n    - n=3-ի դեպքում ֆունկցիան պետք է վերադարձնի 14, որը իտերատիվ գործընթացի արդյունքն է՝ 2 քայլ առաջին զույգի համար,\n      4 քայլ երկրորդ զույգի համար, և ապա 8 լրացուցիչ քայլեր՝ երրորդ զույգի համար:\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "bn": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    n জোড়া ডিস্কের জন্য ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যার সমাধান করতে প্রয়োজনীয় ন্যূনতম চলাচলের সংখ্যা গণনা করুন।\n    \n    এই ফাংশনটি একটি পুনরাবৃত্ত অ্যালগরিদম প্রয়োগ করে যা ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে 2n ডিস্ককে A পোল থেকে C পোল পর্যন্ত স্থানান্তর করার জন্য প্রয়োজনীয় ন্যূনতম চলাচলের সংখ্যা নির্ধারণ করে, এই নিয়মগুলি অনুসরণ করে যে একবারে শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোন ডিস্ক ছোট ডিস্কের উপরে স্থাপন করা যাবে না। ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে এবং n জোড়া ডিস্কের জন্য মোট চলাচলের সংখ্যা পুনরাবৃত্তভাবে গণনা করে।\n    \n    Args:\n    n (int): A পোলের উপর ডিস্ক জোড়ার সংখ্যা (প্রতিটি দুটি অভিন্ন ডিস্কের)।\n\n    Returns:\n    int: সমস্ত ডিস্ক A পোল থেকে C পোল পর্যন্ত স্থানান্তর করতে প্রয়োজনীয় ন্যূনতম চলাচলের সংখ্যা।\n\n    উদাহরণ:\n    - n=1 এর জন্য, ফাংশনটি 2 ফেরত দেবে, যেহেতু দুটি অভিন্ন ডিস্ক রয়েছে যা দুটি চলাচলে সরানো যেতে পারে।\n    - n=2 এর জন্য, ফাংশনটি 6 ফেরত দেবে, কারণ প্রথম জোড়ার জন্য 2 চলাচল এবং তারপর দ্বিতীয় জোড়ার জন্য আরও 4 চলাচল লাগে।\n    - n=3 এর জন্য, ফাংশনটি 14 ফেরত দেবে, যা পুনরাবৃত্ত প্রক্রিয়ার ফলাফল: প্রথম জোড়ার জন্য 2 চলাচল, দ্বিতীয়টির জন্য আরও 4, এবং তারপর তৃতীয় জোড়ার জন্য অতিরিক্ত 8 চলাচল।\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "bg": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Изчислява минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n    \n    Тази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за преместване\n    на 2n диска от полюса A към полюса C в настройка на Ханойските кули с двойни дискове, следвайки правилата, че само един диск \n    може да се премества наведнъж и не може да се поставя диск върху по-малък диск. Функцията използва известна рекурсивна връзка \n    и итеративно изчислява общия брой ходове за n двойки дискове.\n    \n    Args:\n    n (int): Броят на двойките дискове (всяка от два идентични диска) на полюса A.\n\n    Returns:\n    int: Минималният брой ходове, необходими за преместване на всички дискове от полюса A към полюса C.\n\n    Примери:\n    - За n=1, функцията трябва да върне 2, тъй като има два идентични диска, които могат да бъдат преместени в два хода.\n    - За n=2, функцията трябва да върне 6, тъй като са необходими 2 хода за първата двойка и след това още 4 хода за втората двойка.\n    - За n=3, функцията трябва да върне 14, което е резултат от итеративния процес: 2 хода за първата двойка, \n      още 4 за втората и след това още 8 хода за третата двойка.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "zh": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    计算解决双盘汉诺塔问题所需的最小移动次数，对于n对圆盘。\n    \n    此函数实现了一个迭代算法，以确定在双盘汉诺塔设置中，将2n个圆盘从A杆转移到C杆所需的最小移动次数，\n    遵循的规则是每次只能移动一个圆盘，且不能将圆盘放在比它小的圆盘上。该函数使用已知的递归关系，并迭代计算n对圆盘的总移动次数。\n    \n    参数：\n    n (int): A杆上的圆盘对数（每对由两个相同的圆盘组成）。\n\n    返回：\n    int: 将所有圆盘从A杆转移到C杆所需的最小移动次数。\n\n    情况：\n    - 对于n=1，函数应返回2，因为有两个相同的圆盘，可以在两次移动中完成。\n    - 对于n=2，函数应返回6，因为第一对需要2次移动，然后第二对需要再移动4次。\n    - 对于n=3，函数应返回14，这是迭代过程的结果：第一对需要2次移动，第二对再需要4次，然后第三对再需要8次移动。\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "fr": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n    \n    Cette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n    2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque \n    peut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue \n    et calcule de manière itérative le nombre total de mouvements pour n paires de disques.\n    \n    Args:\n    n (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\n    Returns:\n    int: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\n    Cas:\n    - Pour n=1, la fonction doit retourner 2, car il y a deux disques identiques qui peuvent être déplacés en deux mouvements.\n    - Pour n=2, la fonction doit retourner 6, car il faut 2 mouvements pour la première paire puis 4 mouvements supplémentaires pour la deuxième paire.\n    - Pour n=3, la fonction doit retourner 14, ce qui est le résultat du processus itératif : 2 mouvements pour la première paire, \n      4 de plus pour la deuxième, puis 8 mouvements supplémentaires pour la troisième paire.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "de": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Berechne die minimale Anzahl von Zügen, die erforderlich sind, um das Doppelscheiben-Hanoi-Türme-Problem für n Scheibenpaare zu lösen.\n    \n    Diese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, \n    um 2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppelscheiben-Hanoi-Türme-Setup zu übertragen, wobei die Regeln befolgt werden, \n    dass nur eine Scheibe gleichzeitig bewegt werden kann und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. \n    Die Funktion verwendet eine bekannte rekursive Beziehung und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n    \n    Argumente:\n    n (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\n    Rückgabewert:\n    int: Die minimale Anzahl von Zügen, die erforderlich sind, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\n    Fälle:\n    - Für n=1 sollte die Funktion 2 zurückgeben, da es zwei identische Scheiben gibt, die in zwei Zügen bewegt werden können.\n    - Für n=2 sollte die Funktion 6 zurückgeben, da es 2 Züge für das erste Paar und dann 4 weitere Züge für das zweite Paar benötigt.\n    - Für n=3 sollte die Funktion 14 zurückgeben, was das Ergebnis des iterativen Prozesses ist: 2 Züge für das erste Paar, \n      4 weitere für das zweite und dann 8 zusätzliche Züge für das dritte Paar.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "ha": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Lissafa mafi ƙarancin yawan motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don n nau'i biyu na faifai.\n    \n    Wannan aikin yana aiwatar da wani tsari mai maimaitawa don ƙayyade mafi ƙarancin yawan motsi da ake buƙata don canja wurin\n    2n faifai daga sandar A zuwa sandar C a cikin saitin hasumiyar Hanoi mai faifan diski biyu, bisa ga dokokin cewa ana iya motsa faifan guda ɗaya \n    a lokaci guda kuma babu wani faifan da za a iya sanya shi a saman faifan da ya fi shi girma. Aikin yana amfani da wata sananniyar dangantaka mai maimaitawa \n    kuma yana lissafa jimillar yawan motsi don n nau'i biyu na faifai.\n    \n    Args:\n    n (int): Yawan nau'i biyu na faifai (kowanne na faifai biyu masu kama) a kan sandar A.\n\n    Returns:\n    int: Mafi ƙarancin yawan motsi da ake buƙata don canja duk faifan daga sandar A zuwa sandar C.\n\n    Lokuta:\n    - Ga n=1, aikin ya kamata ya dawo da 2, tun da akwai faifai biyu masu kama da za a iya motsa su cikin motsi biyu.\n    - Ga n=2, aikin ya kamata ya dawo da 6, domin yana ɗaukar motsi 2 don nau'i na farko sannan kuma motsi 4 don nau'i na biyu.\n    - Ga n=3, aikin ya kamata ya dawo da 14, wanda shine sakamakon tsarin maimaitawa: motsi 2 don nau'i na farko, \n      4 ƙarin don na biyu, sannan kuma 8 ƙarin motsi don nau'i na uku.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "hi": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    दोहरे-डिस्क हनोई टावर्स समस्या के लिए n जोड़ों के डिस्क के लिए आवश्यक न्यूनतम चालों की गणना करें।\n    \n    यह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि यह निर्धारित किया जा सके कि दोहरे-डिस्क हनोई टावर्स सेटअप में \n    2n डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या कितनी है, इस नियम का पालन करते हुए \n    कि केवल एक डिस्क को एक बार में स्थानांतरित किया जा सकता है और किसी भी डिस्क को एक छोटी डिस्क के ऊपर नहीं रखा जा सकता। \n    फ़ंक्शन एक ज्ञात पुनरावृत्त संबंध का उपयोग करता है और n जोड़ों के डिस्क के लिए कुल चालों की संख्या को पुनरावृत्त रूप से गणना करता है।\n    \n    Args:\n    n (int): A पोल पर डिस्क जोड़ों की संख्या (प्रत्येक दो समान डिस्क के).\n\n    Returns:\n    int: A पोल से C पोल तक सभी डिस्क को स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\n    मामले:\n    - n=1 के लिए, फ़ंक्शन को 2 लौटाना चाहिए, क्योंकि दो समान डिस्क हैं जिन्हें दो चालों में स्थानांतरित किया जा सकता है।\n    - n=2 के लिए, फ़ंक्शन को 6 लौटाना चाहिए, क्योंकि पहले जोड़े के लिए 2 चालें लगती हैं और फिर दूसरे जोड़े के लिए 4 और चालें लगती हैं।\n    - n=3 के लिए, फ़ंक्शन को 14 लौटाना चाहिए, जो पुनरावृत्त प्रक्रिया का परिणाम है: पहले जोड़े के लिए 2 चालें, \n      दूसरे के लिए 4 और फिर तीसरे जोड़े के लिए 8 अतिरिक्त चालें।\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "hu": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Számítsa ki a minimális lépések számát, amely szükséges a dupla korongos Hanoi-tornyok problémájának megoldásához n korongpár esetén.\n    \n    Ez a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy hány lépés szükséges 2n korong áthelyezéséhez\n    az A oszlopról a C oszlopra egy dupla korongos Hanoi-tornyok elrendezésben, követve azokat a szabályokat, hogy egyszerre csak egy korong\n    mozgatható, és egy korong sem helyezhető kisebb korong tetejére. A függvény egy ismert rekurzív összefüggést használ, és iteratívan \n    kiszámítja a teljes lépésszámot n korongpár esetén.\n    \n    Args:\n    n (int): A korongpárok száma (mindegyik két azonos korongból áll) az A oszlopon.\n\n    Returns:\n    int: A minimális lépések száma, amely szükséges az összes korong áthelyezéséhez az A oszlopról a C oszlopra.\n\n    Esetek:\n    - Ha n=1, a függvénynek 2-t kell visszaadnia, mivel két azonos korong van, amelyeket két lépésben lehet áthelyezni.\n    - Ha n=2, a függvénynek 6-ot kell visszaadnia, mivel 2 lépés szükséges az első párhoz, majd további 4 lépés a második párhoz.\n    - Ha n=3, a függvénynek 14-et kell visszaadnia, amely az iteratív folyamat eredménye: 2 lépés az első párhoz, \n      további 4 a másodikhoz, majd 8 további lépés a harmadik párhoz.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves"
    },
    "prompt_bertscore": {
      "sq": "0.9403163376281609",
      "hy": "0.9126286529245647",
      "bn": "0.9441616231746154",
      "bg": "0.9498221917733476",
      "zh": "0.9190315032572244",
      "fr": "0.9527430515264657",
      "de": "0.9497532670311285",
      "ha": "0.9369473677354282",
      "hi": "0.9509092958487515",
      "hu": "0.915920554229456"
    },
    "canonical_solution": "    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
    "instruction": {
      "en": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nՏվյալ Python կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\n请用不超过500个字符的中文，为以下Python代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nBada taƙaitaccen bayani a cikin yaren ɗan adam (docstring) na lambar Python a Hausa ba tare da wucewa haruffa 500 ba.",
      "hi": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nदिए गए Python कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.8856909965397564",
      "bn": "0.8842060358111395",
      "bg": "0.8983697723915943",
      "zh": "0.8735882487929195",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9178869950017013",
      "hi": "0.8964889413135749",
      "hu": "0.941426482827765"
    },
    "level": "",
    "test": "def test_hanoi_double_iterative():\n    # Test case 1: n = 1\n    assert hanoi_double_iterative(1) == 2, \"Test case 1 failed\"\n\n    # Test case 2: n = 2\n    assert hanoi_double_iterative(2) == 6, \"Test case 2 failed\"\n\n    # Test case 3: n = 3\n    assert hanoi_double_iterative(3) == 14, \"Test case 3 failed\"\n\n    # Additional test cases can be added based on computed or known results\n    # Test case 4: n = 4 (computed using the formula)\n    assert hanoi_double_iterative(4) == 30, \"Test case 4 failed\"\n\n    # Test case 5: n = 5 (computed using the formula)\n    assert hanoi_double_iterative(5) == 62, \"Test case 5 failed\"\n\n    # Test case 6: Large n, n = 10 (computed using the formula or a trusted source)\n    assert hanoi_double_iterative(10) == 2046, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_hanoi_double_iterative()",
    "entry_point": "hanoi_double_iterative",
    "signature": "def hanoi_double_iterative(n: int) -> int:",
    "docstring": {
      "en": "Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n\nThis function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc\ncan be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation\nand iteratively computes the total number of moves for n pairs of discs.\n\nArgs:\nn (int): The number of disc pairs (each of two identical discs) on the A pole.\n\nReturns:\nint: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\nCases:\n- For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n- For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n- For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair,\n4 more for the second, and then 8 additional moves for the third pair.",
      "sq": "Llogarit numrin minimal të lëvizjeve të nevojshme për të zgjidhur problemin e Kullave të Hanoi me dy disqe për n çifte disqesh.\n\nKjo funksion implementon një algoritëm iterativ për të përcaktuar numrin minimal të lëvizjeve të nevojshme për të transferuar\n2n disqe nga shtylla A në shtyllën C në një konfigurim të Kullave të Hanoi me dy disqe, duke ndjekur rregullat që vetëm një disk\nmund të zhvendoset në një kohë dhe asnjë disk nuk mund të vendoset mbi një disk më të vogël. Funksioni përdor një marrëdhënie të njohur rekursive\ndhe llogarit në mënyrë iterative numrin total të lëvizjeve për n çifte disqesh.\n\nArgumentet:\nn (int): Numri i çifteve të disqeve (secili me dy disqe identike) në shtyllën A.\n\nKthen:\nint: Numri minimal i lëvizjeve të nevojshme për të transferuar të gjithë disqet nga shtylla A në shtyllën C.\n\nRastet:\n- Për n=1, funksioni duhet të kthejë 2, pasi ka dy disqe identike që mund të zhvendosen në dy lëvizje.\n- Për n=2, funksioni duhet të kthejë 6, pasi duhen 2 lëvizje për çiftin e parë dhe pastaj 4 lëvizje të tjera për çiftin e dytë.\n- Për n=3, funksioni duhet të kthejë 14, që është rezultati i procesit iterativ: 2 lëvizje për çiftin e parë,\n4 të tjera për të dytin, dhe pastaj 8 lëvizje shtesë për çiftin e tretë.",
      "hy": "Հաշվել նվազագույն քայլերի քանակը, որը պահանջվում է կրկնակի սկավառակներով Հանոյի աշտարակների խնդիրը լուծելու համար n զույգ սկավառակների համար։\n\nԱյս ֆունկցիան իրականացնում է իտերատիվ ալգորիթմ՝ որոշելու նվազագույն քայլերի քանակը, որը անհրաժեշտ է 2n սկավառակները A ձողից C ձող տեղափոխելու համար կրկնակի սկավառակներով Հանոյի աշտարակների պարագայում՝ հետևելով այն կանոններին, որ միայն մեկ սկավառակ կարելի է տեղափոխել միաժամանակ և ոչ մի սկավառակ չի կարող տեղադրվել ավելի փոքր սկավառակի վրա։ Ֆունկցիան օգտագործում է հայտնի ռեկուրսիվ հարաբերություն և իտերատիվ կերպով հաշվարկում է ընդհանուր քայլերի քանակը n զույգ սկավառակների համար։\n\nԱրգումենտներ:\nn (int): Սկավառակների զույգերի քանակը (յուրաքանչյուր զույգ բաղկացած է երկու նույնական սկավառակներից) A ձողի վրա։\n\nՎերադարձնում է:\nint: Նվազագույն քայլերի քանակը, որը պահանջվում է բոլոր սկավառակները A ձողից C ձող տեղափոխելու համար։\n\nԴեպքեր:\n- n=1-ի համար ֆունկցիան պետք է վերադարձնի 2, քանի որ կան երկու նույնական սկավառակներ, որոնք կարելի է տեղափոխել երկու քայլով։\n- n=2-ի համար ֆունկցիան պետք է վերադարձնի 6, քանի որ առաջին զույգի համար պահանջվում է 2 քայլ, իսկ երկրորդ զույգի համար՝ ևս 4 քայլ։\n- n=3-ի համար ֆունկցիան պետք է վերադարձնի 14, որը իտերատիվ գործընթացի արդյունքն է՝ 2 քայլ առաջին զույգի համար, 4 քայլ երկրորդ զույգի համար, և ապա 8 լրացուցիչ քայլեր երրորդ զույգի համար։",
      "bn": "ডাবল-ডিস্ক হ্যানয় টাওয়ার সমস্যা সমাধানের জন্য প্রয়োজনীয় ন্যূনতম পদক্ষেপের সংখ্যা গণনা করুন n জোড়া ডিস্কের জন্য।\n\nএই ফাংশনটি একটি পুনরাবৃত্তিমূলক অ্যালগরিদম বাস্তবায়ন করে যা ডাবল-ডিস্ক হ্যানয় টাওয়ার সেটআপে 2n ডিস্ককে A খুঁটি থেকে C খুঁটিতে স্থানান্তর করার জন্য প্রয়োজনীয় ন্যূনতম পদক্ষেপের সংখ্যা নির্ধারণ করে, এই নিয়মগুলি অনুসরণ করে যে একবারে শুধুমাত্র একটি ডিস্ক সরানো যেতে পারে এবং কোনো ডিস্ক ছোট ডিস্কের উপরে রাখা যাবে না। ফাংশনটি একটি পরিচিত পুনরাবৃত্ত সম্পর্ক ব্যবহার করে এবং n জোড়া ডিস্কের জন্য মোট পদক্ষেপের সংখ্যা পুনরাবৃত্তিমূলকভাবে গণনা করে।\n\nআর্গুমেন্টসমূহ:\nn (int): A খুঁটিতে থাকা ডিস্কের জোড়ার সংখ্যা (প্রত্যেকটি দুটি অভিন্ন ডিস্কের)।\n\nরিটার্নস:\nint: সমস্ত ডিস্ক A খুঁটি থেকে C খুঁটিতে স্থানান্তর করার জন্য প্রয়োজনীয় ন্যূনতম পদক্ষেপের সংখ্যা।\n\nঘটনাগুলি:\n- n=1 এর জন্য, ফাংশনটি 2 ফেরত দেবে, যেহেতু দুটি অভিন্ন ডিস্ক রয়েছে যা দুটি পদক্ষেপে সরানো যেতে পারে।\n- n=2 এর জন্য, ফাংশনটি 6 ফেরত দেবে, কারণ প্রথম জোড়ার জন্য 2 পদক্ষেপ এবং তারপর দ্বিতীয় জোড়ার জন্য আরও 4 পদক্ষেপ লাগে।\n- n=3 এর জন্য, ফাংশনটি 14 ফেরত দেবে, যা পুনরাবৃত্তিমূলক প্রক্রিয়ার ফলাফল: প্রথম জোড়ার জন্য 2 পদক্ষেপ, দ্বিতীয়টির জন্য আরও 4, এবং তারপর তৃতীয় জোড়ার জন্য অতিরিক্ত 8 পদক্ষেপ।",
      "bg": "Изчисляване на минималния брой ходове, необходими за решаване на проблема с двойните дискове на Ханойските кули за n двойки дискове.\n\nТази функция реализира итеративен алгоритъм за определяне на минималния брой ходове, необходими за преместване на 2n диска от стълба A към стълба C в конфигурация на Ханойските кули с двойни дискове, следвайки правилата, че само един диск може да бъде преместен наведнъж и никой диск не може да бъде поставен върху по-малък диск. Функцията използва известна рекурсивна връзка и итеративно изчислява общия брой ходове за n двойки дискове.\n\nАргументи:\nn (int): Броят на двойките дискове (всяка от два идентични диска) на стълба A.\n\nВръща:\nint: Минималният брой ходове, необходими за преместване на всички дискове от стълба A към стълба C.\n\nСлучаи:\n- За n=1, функцията трябва да върне 2, тъй като има два идентични диска, които могат да бъдат преместени в два хода.\n- За n=2, функцията трябва да върне 6, тъй като са необходими 2 хода за първата двойка и след това още 4 хода за втората двойка.\n- За n=3, функцията трябва да върне 14, което е резултат от итеративния процес: 2 хода за първата двойка, още 4 за втората и след това още 8 хода за третата двойка.",
      "zh": "计算解决双盘汉诺塔问题所需的最小移动次数，对于 n 对圆盘。\n\n此函数实现了一种迭代算法，以确定在双盘汉诺塔设置中，将 2n 个圆盘从 A 柱移动到 C 柱所需的最小移动次数，遵循的规则是一次只能移动一个圆盘，并且不能将圆盘放在比它小的圆盘上。该函数使用已知的递归关系，并迭代计算 n 对圆盘的总移动次数。\n\n参数：\nn (int): A 柱上的圆盘对数（每对由两个相同的圆盘组成）。\n\n返回：\nint: 将所有圆盘从 A 柱转移到 C 柱所需的最小移动次数。\n\n情况：\n- 对于 n=1，函数应返回 2，因为有两个相同的圆盘，可以通过两次移动完成。\n- 对于 n=2，函数应返回 6，因为第一对需要 2 次移动，然后第二对需要再 4 次移动。\n- 对于 n=3，函数应返回 14，这是迭代过程的结果：第一对需要 2 次移动，第二对再需要 4 次，第三对再需要 8 次移动。",
      "fr": "Calculer le nombre minimum de mouvements nécessaires pour résoudre le problème des Tours de Hanoï à double disque pour n paires de disques.\n\nCette fonction implémente un algorithme itératif pour déterminer le nombre minimum de mouvements nécessaires pour transférer\n2n disques du poteau A au poteau C dans une configuration de Tours de Hanoï à double disque, en suivant les règles selon lesquelles un seul disque\npeut être déplacé à la fois et aucun disque ne peut être placé sur un disque plus petit. La fonction utilise une relation récursive connue\net calcule de manière itérative le nombre total de mouvements pour n paires de disques.\n\nArgs:\nn (int): Le nombre de paires de disques (chacune de deux disques identiques) sur le poteau A.\n\nReturns:\nint: Le nombre minimum de mouvements nécessaires pour transférer tous les disques du poteau A au poteau C.\n\nCas:\n- Pour n=1, la fonction doit retourner 2, car il y a deux disques identiques qui peuvent être déplacés en deux mouvements.\n- Pour n=2, la fonction doit retourner 6, car il faut 2 mouvements pour la première paire et ensuite 4 mouvements supplémentaires pour la deuxième paire.\n- Pour n=3, la fonction doit retourner 14, ce qui est le résultat du processus itératif : 2 mouvements pour la première paire,\n4 de plus pour la deuxième, puis 8 mouvements supplémentaires pour la troisième paire.",
      "de": "Berechne die minimale Anzahl von Zügen, die erforderlich sind, um das Doppelscheiben-Hanoi-Türme-Problem für n Scheibenpaare zu lösen.\n\nDiese Funktion implementiert einen iterativen Algorithmus, um die minimale Anzahl von Zügen zu bestimmen, die notwendig sind, um 2n Scheiben vom A-Pfosten zum C-Pfosten in einem Doppelscheiben-Hanoi-Türme-Aufbau zu übertragen, wobei die Regeln befolgt werden, dass jeweils nur eine Scheibe bewegt werden kann und keine Scheibe auf eine kleinere Scheibe gelegt werden darf. Die Funktion verwendet eine bekannte rekursive Beziehung und berechnet iterativ die Gesamtanzahl der Züge für n Scheibenpaare.\n\nArgumente:\nn (int): Die Anzahl der Scheibenpaare (jeweils zwei identische Scheiben) auf dem A-Pfosten.\n\nRückgabewert:\nint: Die minimale Anzahl von Zügen, die erforderlich ist, um alle Scheiben vom A-Pfosten zum C-Pfosten zu übertragen.\n\nFälle:\n- Für n=1 sollte die Funktion 2 zurückgeben, da es zwei identische Scheiben gibt, die in zwei Zügen bewegt werden können.\n- Für n=2 sollte die Funktion 6 zurückgeben, da es 2 Züge für das erste Paar und dann 4 weitere Züge für das zweite Paar benötigt.\n- Für n=3 sollte die Funktion 14 zurückgeben, was das Ergebnis des iterativen Prozesses ist: 2 Züge für das erste Paar, 4 weitere für das zweite und dann 8 zusätzliche Züge für das dritte Paar.",
      "ha": "Lissafa mafi ƙarancin yawan motsi da ake buƙata don warware matsalar hasumiyar Hanoi mai faifan diski biyu don n nau'i biyu na faifai.\n\nWannan aikin yana aiwatar da wata dabara mai maimaitawa don tantance adadin motsi mafi karanci da ake bukata don canja wurin\nfaifan 2n daga sandar A zuwa sandar C a cikin saitin double-disc Hanoi Towers, bisa ga dokokin da ke cewa faifan daya kawai\nza a iya motsawa a lokaci daya kuma babu wani faifan da za a iya sanya shi a saman faifan da ya fi shi girma. Aikin yana amfani da wata dangantaka mai maimaitawa da aka sani\nkuma yana lissafa jimlar adadin motsi don nau'i-nau'i na faifan diski.\n\nArgs:\nn (int): Adadin nau'i-nau'i na faifan diski (kowanne na faifan diski guda biyu masu kama) a kan sandar A.\n\nReturns:\nint: Adadin motsi mafi karanci da ake bukata don canja dukkan faifan daga sandar A zuwa sandar C.\n\nCases:\n- Don n=1, aikin ya kamata ya dawo da 2, tun da akwai faifan diski guda biyu masu kama da za a iya motsawa a cikin motsi biyu.\n- Don n=2, aikin ya kamata ya dawo da 6, saboda yana daukar motsi 2 don nau'i na farko sannan kuma karin motsi 4 don nau'i na biyu.\n- Don n=3, aikin ya kamata ya dawo da 14, wanda shine sakamakon tsarin maimaitawa: motsi 2 don nau'i na farko,\nkarin motsi 4 don na biyu, sannan kuma karin motsi 8 don nau'i na uku.",
      "hi": "दोहरे-डिस्क हनोई टावर्स समस्या के लिए n जोड़ों के डिस्क के लिए आवश्यक न्यूनतम चालों की गणना करें।\n\nयह फ़ंक्शन एक पुनरावृत्त एल्गोरिदम को लागू करता है ताकि यह निर्धारित किया जा सके कि दोहरे-डिस्क हनोई टावर्स सेटअप में 2n डिस्क को A पोल से C पोल तक स्थानांतरित करने के लिए न्यूनतम चालों की संख्या क्या है, इस नियम का पालन करते हुए कि एक समय में केवल एक डिस्क को स्थानांतरित किया जा सकता है और कोई भी डिस्क छोटी डिस्क के ऊपर नहीं रखी जा सकती। यह फ़ंक्शन ज्ञात पुनरावर्ती संबंध का उपयोग करता है और n जोड़े डिस्क के लिए कुल चालों की संख्या को पुनरावृत्त रूप से गणना करता है।\n\nArgs:\nn (int): A पोल पर डिस्क के जोड़ों की संख्या (प्रत्येक दो समान डिस्क का)।\n\nReturns:\nint: A पोल से C पोल तक सभी डिस्क को स्थानांतरित करने के लिए आवश्यक न्यूनतम चालों की संख्या।\n\nCases:\n- n=1 के लिए, फ़ंक्शन को 2 लौटाना चाहिए, क्योंकि दो समान डिस्क हैं जिन्हें दो चालों में स्थानांतरित किया जा सकता है।\n- n=2 के लिए, फ़ंक्शन को 6 लौटाना चाहिए, क्योंकि पहले जोड़े के लिए 2 चालें लगती हैं और फिर दूसरे जोड़े के लिए 4 और चालें लगती हैं।\n- n=3 के लिए, फ़ंक्शन को 14 लौटाना चाहिए, जो पुनरावृत्त प्रक्रिया का परिणाम है: पहले जोड़े के लिए 2 चालें, दूसरे के लिए 4 और फिर तीसरे जोड़े के लिए 8 अतिरिक्त चालें।",
      "hu": "Számítsa ki a minimális lépések számát, amely szükséges a dupla korongos Hanoi tornyok problémájának megoldásához n korongpár esetén.\n\nEz a függvény egy iteratív algoritmust valósít meg annak meghatározására, hogy mi a minimális lépésszám, amely szükséges 2n korong áthelyezéséhez az A oszlopról a C oszlopra egy dupla korongos Hanoi tornyok felállásban, követve azokat a szabályokat, hogy egyszerre csak egy korong mozgatható, és egyetlen korong sem helyezhető kisebb korong tetejére. A függvény egy ismert rekurzív összefüggést használ, és iteratívan kiszámítja a teljes lépésszámot n korongpár esetén.\n\nArgs:\nn (int): A korongpárok száma (mindegyik két azonos korongból áll) az A oszlopon.\n\nReturns:\nint: A minimális lépésszám, amely szükséges az összes korong áthelyezéséhez az A oszlopról a C oszlopra.\n\nEsetek:\n- Ha n=1, a függvénynek 2-t kell visszaadnia, mivel két azonos korong van, amelyeket két lépésben lehet áthelyezni.\n- Ha n=2, a függvénynek 6-ot kell visszaadnia, mivel 2 lépés szükséges az első párhoz, majd további 4 lépés a második párhoz.\n- Ha n=3, a függvénynek 14-et kell visszaadnia, ami az iteratív folyamat eredménye: 2 lépés az első párhoz, további 4 a másodikhoz, majd 8 további lépés a harmadik párhoz."
    },
    "docstring_bertscore": {
      "sq": "0.9402968718508196",
      "hy": "0.9066276318527388",
      "bn": "0.9170515556190686",
      "bg": "0.929129673198657",
      "zh": "0.918425283334306",
      "fr": "0.9336987678536026",
      "de": "0.9614784184236179",
      "ha": "0.9380825403630426",
      "hi": "0.9708527792565594",
      "hu": "0.9275364589123762"
    }
  },
  {
    "task_id": "Python/50",
    "prompt": {
      "en": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "sq": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Llogarit numrin total të cigareve që Peter mund të pijë.\n    Peter fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve të nevojshëm për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "hy": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Հաշվում է ընդհանուր ծխախոտների քանակը, որ Պետերը կարող է ծխել։\n    Պետերը սկսում է n ծխախոտներով և կարող է փոխանակել k մնացորդները մեկ նոր ծխախոտի համար։\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ն սկզբնական ծխախոտների քանակն է,\n    և k-ն այն մնացորդների քանակն է, որոնք անհրաժեշտ են մեկ նոր ծխախոտի փոխանակման համար։\n    Ֆունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որ Պետերը կարող է ծխել։\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "bn": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    পিটার মোট কতগুলি সিগারেট খেতে পারে তা গণনা করে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k টুকরো বাট দিয়ে একটি নতুন সিগারেট বিনিময় করতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট নেয়, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেট বিনিময়ের জন্য প্রয়োজনীয় সিগারেট বাটের সংখ্যা।\n    ফাংশনটি পিটার মোট কতগুলি সিগারেট খেতে পারে তা ফেরত দেয়।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "bg": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Изчислява общия брой цигари, които Петър може да изпуши.\n    Петър започва с n цигари и може да размени k фасове за една нова цигара.\n    Функцията приема два аргумента, n и k, където n е началният брой цигари,\n    а k е броят на фасовете, необходими за размяна за една нова цигара.\n    Функцията връща общия брой цигари, които Петър може да изпуши.\n    Пример:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "zh": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    计算Peter可以抽的香烟总数。\n    Peter开始时有n支香烟，可以用k个烟头换一支新香烟。\n    该函数接受两个参数，n和k，其中n是初始香烟数量，\n    k是换取一支新香烟所需的烟头数量。\n    该函数返回Peter可以抽的香烟总数。\n    示例：\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "fr": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarettes nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction renvoie le nombre total de cigarettes que Peter peut fumer.\n    Exemple:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "de": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist,\n    und k die Anzahl der Kippen ist, die für eine neue Zigarette eingetauscht werden müssen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "ha": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Lissafa jimillar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da sigari n kuma yana iya musanya k butts don sabon sigari daya.\n    Aikin yana daukar hujjoji guda biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake bukata don musanya sabon sigari daya.\n    Aikin yana mayar da jimillar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "hi": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    कुल सिगरेटों की संख्या की गणना करता है जो पीटर पी सकता है।\n    पीटर n सिगरेटों से शुरू करता है और k बट्स के लिए एक नई सिगरेट का आदान-प्रदान कर सकता है।\n    फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेटों की संख्या है,\n    और k वह संख्या है जो एक नई सिगरेट के लिए आदान-प्रदान करने के लिए आवश्यक है।\n    फ़ंक्शन कुल सिगरेटों की संख्या लौटाता है जो पीटर पी सकता है।\n    उदाहरण:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "hu": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Kiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n    Péter n cigarettával kezd, és k csikket tud beváltani egy új cigarettára.\n    A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigarettaszám,\n    és k az a csikkszám, ami szükséges egy új cigaretta beváltásához.\n    A függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\""
    },
    "prompt_bertscore": {
      "sq": "0.9851879338558474",
      "hy": "0.9887114381850253",
      "bn": "0.9878992385569736",
      "bg": "0.9974013187249205",
      "zh": "0.9828578008559271",
      "fr": "0.993292847923595",
      "de": "0.9843284601971094",
      "ha": "0.9976406683340676",
      "hi": "0.9810327849149785",
      "hu": "0.9843135629185318"
    },
    "canonical_solution": "    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total",
    "instruction": {
      "en": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "sq": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Python në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nՏվեք Python կոդի հակիրճ բնութագրությունը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nপাইথন কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nПредоставете кратко описание на Python кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\n请用中文为以下 Python 代码提供简洁的自然语言描述（文档字符串），字数不超过500个字符。",
      "fr": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nFournissez une description concise en langage naturel (docstring) du code Python en français en utilisant au maximum 500 caractères.",
      "de": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Python-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Python a cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nदिए गए Python कोड का संक्षिप्त प्राकृतिक भाषा विवरण (docstring) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Python kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9544230672892587",
      "hy": "0.9310565865250765",
      "bn": "0.8842060358111395",
      "bg": "0.8983697723915943",
      "zh": "0.8886474111310796",
      "fr": "0.9690480236144765",
      "de": "0.925758518371733",
      "ha": "0.9215501364887467",
      "hi": "0.9332389385215069",
      "hu": "0.953223935678951"
    },
    "level": "",
    "test": "assert total_smoked_cigarettes(4, 3) == 5\nassert total_smoked_cigarettes(10, 3) == 14\nassert total_smoked_cigarettes(1, 2) == 1  # Peter cannot exchange butts as he starts with less than k\nassert total_smoked_cigarettes(20, 4) == 26\nassert total_smoked_cigarettes(0, 5) == 0  # Peter starts with no cigarettes",
    "entry_point": "total_smoked_cigarettes",
    "signature": "def total_smoked_cigarettes(n, k):",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "sq": "Llogarit numrin total të cigareve që Peter mund të pijë.\n    Peter fillon me n cigare dhe mund të shkëmbejë k bishta për një cigare të re.\n    Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve,\n    dhe k është numri i bishtave të cigareve të nevojshëm për të shkëmbyer për një cigare të re.\n    Funksioni kthen numrin total të cigareve që Peter mund të pijë.\n    Shembull:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hy": "Հաշվում է, թե քանի ծխախոտ կարող է ծխել Պետերը:\n    Պետերը սկսում է n ծխախոտով և կարող է փոխանակել k մնացորդները մեկ նոր ծխախոտի համար:\n    Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ը ծխախոտների սկզբնական քանակն է,\n    և k-ը այն ծխախոտի մնացորդների քանակն է, որոնք անհրաժեշտ են մեկ նոր ծխախոտի համար փոխանակելու համար:\n    Ֆունկցիան վերադարձնում է այն ծխախոտների ընդհանուր քանակը, որոնք Պետերը կարող է ծխել:\n    Օրինակ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "bn": "সিগারেটের মোট সংখ্যা গণনা করে যা পিটার ধূমপান করতে পারে।\n    পিটার n সিগারেট দিয়ে শুরু করে এবং k বাট দিয়ে একটি নতুন সিগারেট বিনিময় করতে পারে।\n    ফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা,\n    এবং k হল একটি নতুন সিগারেট বিনিময়ের জন্য প্রয়োজনীয় সিগারেটের বাটের সংখ্যা।\n    ফাংশনটি পিটার কতগুলি সিগারেট ধূমপান করতে পারে তার মোট সংখ্যা প্রদান করে।\n    উদাহরণ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши.  \nПетър започва с n цигари и може да размени k фасове за една нова цигара.  \nФункцията приема два аргумента, n и k, където n е началният брой цигари,  \nа k е броят на фасовете, необходими за размяна за една нова цигара.  \nФункцията връща общия брой цигари, които Петър може да изпуши.  \nПример:  \n>>> total_smoked_cigarettes(4, 3)  \n    5  \n>>> total_smoked_cigarettes(10, 3)  \n    14  ",
      "zh": "计算 Peter 可以抽的香烟总数。\n    Peter 从 n 支香烟开始，可以用 k 个烟头换一支新香烟。\n    该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，\n    k 是换取一支新香烟所需的烟头数量。\n    该函数返回 Peter 可以抽的香烟总数。\n    示例：\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer.\n    Peter commence avec n cigarettes et peut échanger k mégots contre une nouvelle cigarette.\n    La fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes,\n    et k est le nombre de mégots de cigarette nécessaires pour échanger contre une nouvelle cigarette.\n    La fonction renvoie le nombre total de cigarettes que Peter peut fumer.\n    Exemple :\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n    Peter beginnt mit n Zigaretten und kann k Kippen gegen eine neue Zigarette eintauschen.\n    Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist,\n    und k die Anzahl der Kippen ist, die für eine neue Zigarette eingetauscht werden müssen.\n    Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n    Beispiel:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "ha": "Yana ƙididdige jimlar adadin sigari da Peter zai iya sha.\n    Peter yana farawa da n sigari kuma zai iya musanya k butts don sabon sigari ɗaya.\n    Aikin yana ɗaukar hujjoji biyu, n da k, inda n shine adadin sigari na farko,\n    kuma k shine adadin bututun sigari da ake buƙata don musanya don sabon sigari ɗaya.\n    Aikin yana mayar da jimlar adadin sigari da Peter zai iya sha.\n    Misali:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hi": "कुल सिगरेट की संख्या की गणना करता है जो पीटर पी सकता है।  \n    पीटर n सिगरेट के साथ शुरू करता है और एक नई सिगरेट के लिए k बट्स का आदान-प्रदान कर सकता है।  \n    फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है,  \n    और k वह संख्या है जितने सिगरेट बट्स एक नई सिगरेट के लिए आदान-प्रदान करने की आवश्यकता होती है।  \n    फ़ंक्शन वह कुल सिगरेट की संख्या लौटाता है जो पीटर पी सकता है।  \n    उदाहरण:  \n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "hu": "Kiszámítja, hogy összesen hány cigarettát tud elszívni Péter.\n    Péter n cigarettával kezd, és k csikket tud beváltani egy új cigarettára.\n    A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigaretták száma,\n    és k a csikkek száma, amelyeket be kell váltani egy új cigarettára.\n    A függvény visszaadja az összes cigaretta számát, amit Péter el tud szívni.\n    Példa:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14"
    },
    "docstring_bertscore": {
      "sq": "0.9842970765969059",
      "hy": "0.9860537636867784",
      "bn": "0.9741728860755576",
      "bg": "0.9927781966063335",
      "zh": "0.9791158031076108",
      "fr": "0.9842970765969059",
      "de": "0.98204262177216",
      "ha": "0.9892973978090781",
      "hi": "0.9898724327621742",
      "hu": "0.977597075214218"
    }
  }
]