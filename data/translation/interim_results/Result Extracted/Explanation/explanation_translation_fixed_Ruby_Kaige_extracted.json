[
  {
    "task_id": "Ruby/1",
    "prompt": {
      "en": "# Check if in given list of numbers, any two numbers are closer to each other than\n# given threshold.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "sq": "# Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se\n# pragu i dhënë.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "hy": "# Ստուգել, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ միմյանց ավելի մոտ են, քան\n# տրված շեմը։\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "bn": "# প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা পরীক্ষা করুন।\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "bg": "# Проверете дали в дадения списък от числа, някои две числа са по-близо едно до друго от\n# даден праг.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "zh": "# 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "fr": "# Vérifiez si, dans la liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que\n# le seuil donné.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "de": "# Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n# der gegebene Schwellenwert.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "ha": "# Duba idan a cikin jerin lambobi da aka bayar, akwai wasu lambobi biyu da ke kusa da juna fiye da\n# ƙayyadadden iyaka.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "hi": "# दिए गए संख्याओं की सूची में जाँच करें कि क्या कोई दो संख्याएँ एक-दूसरे के करीब हैं\n# दिए गए सीमा से।\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "hu": "# Ellenőrzi, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)"
    },
    "prompt_bertscore": {
      "sq": "0.9874191489260122",
      "hy": "0.9826778417307095",
      "bn": "0.9719915272310324",
      "bg": "0.9872135664816412",
      "zh": "0.9446838224463561",
      "fr": "0.9822096699226103",
      "de": "0.9794598309275633",
      "ha": "0.9662809037762794",
      "hi": "0.9702984018630911",
      "hu": "0.9710959028429462"
    },
    "canonical_solution": "numbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end",
    "instruction": {
      "en": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nՏվյալ Ruby կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nনিচের Ruby কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Ruby 代码，字数不超过 500 个字符。",
      "fr": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def has_close_elements(numbers, threshold)\nnumbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8853185645753159",
      "bn": "0.8737062352392543",
      "bg": "0.8991035130191372",
      "zh": "0.8895074806809606",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9215894653041917",
      "hi": "0.9027873120658102",
      "hu": "0.9311801346220803"
    },
    "level": "",
    "test": "  # Test cases\n  def check(has_close_elements)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n    raise 'Test failed' unless has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0)\n    raise 'Test failed' if has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\n  \n    puts 'All tests passed!'\n  end\n  \n  check(method(:has_close_elements))",
    "entry_point": "has_close_elements",
    "signature": "def has_close_elements(numbers, threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sq": "Kontrollo nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Ստուգեք, արդյոք տրված թվերի ցանկում որևէ երկու թիվ միմյանց ավելի մոտ են, քան տրված շեմը։\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা দেওয়া থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bg": "Проверете дали в даден списък от числа, някои две числа са по-близо едно до друго от даден праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "zh": "检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  ",
      "fr": "Vérifiez si, dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Duba idan a cikin jerin lambobi da aka bayar, ko akwai wasu lambobi biyu da suka fi kusa da juna fiye da ƙayyadadden tazara.\n\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hi": "जाँच करें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ एक-दूसरे के अधिक निकट हैं दिए गए सीमा से।  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  ",
      "hu": "Ellenőrizze, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "sq": "0.9859016128149057",
      "hy": "0.9762038817216394",
      "bn": "0.9517050091551773",
      "bg": "0.9857848181508572",
      "zh": "0.9502381237912346",
      "fr": "0.9776661985868182",
      "de": "0.9677543439427962",
      "ha": "0.9586534971445397",
      "hi": "0.9722461713795192",
      "hu": "0.9722892741722038"
    }
  },
  {
    "task_id": "Ruby/2",
    "prompt": {
      "en": "# Counts the number of times the digit '1' appears in all numbers from 1 to n.\n# The function takes a single argument, n, which is a positive integer, and \n# returns the total count of the digit '1' appearing in all numbers from 1 to n.\n#\n# Example:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "sq": "# Numëron sa herë shfaqet shifra '1' në të gjitha numrat nga 1 deri në n.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe\n# kthen numrin total të shifrës '1' që shfaqet në të gjitha numrat nga 1 deri në n.\n#\n# Shembull:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "hy": "# Հաշվում է, թե քանի անգամ է '1' թվանշանը հայտնվում 1-ից n բոլոր թվերի մեջ:\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և\n# վերադարձնում է '1' թվանշանի ընդհանուր քանակը, որը հայտնվում է 1-ից n բոլոր թվերի մեջ:\n#\n# Օրինակ:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "bn": "# সংখ্যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যায় অঙ্ক '1' কতবার উপস্থিত হয়েছে তা গণনা করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা,\n# এবং 1 থেকে n পর্যন্ত সমস্ত সংখ্যায় অঙ্ক '1' এর মোট গণনা প্রদান করে।\n#\n# উদাহরণ:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "bg": "# Брои колко пъти цифрата '1' се появява във всички числа от 1 до n.\n# Функцията приема един аргумент, n, който е положително цяло число, и\n# връща общия брой на появяванията на цифрата '1' във всички числа от 1 до n.\n#\n# Пример:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "zh": "# 计算数字 '1' 在从 1 到 n 的所有数字中出现的次数。\n# 该函数接受一个参数 n，它是一个正整数，并返回数字 '1' 在从 1 到 n 的所有数字中出现的总次数。\n#\n# 示例:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "fr": "# Compte le nombre de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n.\n# La fonction prend un seul argument, n, qui est un entier positif, et\n# renvoie le nombre total de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n.\n#\n# Exemple:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "de": "# Zählt, wie oft die Ziffer '1' in allen Zahlen von 1 bis n vorkommt.\n# Die Funktion nimmt ein einziges Argument, n, das eine positive Ganzzahl ist,\n# und gibt die Gesamtanzahl der Ziffer '1' zurück, die in allen Zahlen von 1 bis n vorkommt.\n#\n# Beispiel:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "ha": "# Yana ƙirga yawan lokutan da adadin '1' ya bayyana a duk lambobi daga 1 zuwa n.\n# Aiki yana ɗaukar hujja guda, n, wanda yake lamba mai kyau, kuma\n# yana dawowa da jimillar ƙididdigar adadin '1' da ya bayyana a duk lambobi daga 1 zuwa n.\n#\n# Misali:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "hi": "# 1 से n तक सभी संख्याओं में अंक '1' कितनी बार आता है, इसकी गणना करता है।\n# फ़ंक्शन एक एकल तर्क लेता है, n, जो एक धनात्मक पूर्णांक है, और \n# 1 से n तक सभी संख्याओं में अंक '1' के आने की कुल गणना को लौटाता है।\n#\n# उदाहरण:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "hu": "# Megszámolja, hogy az '1' számjegy hányszor fordul elő az összes 1-től n-ig terjedő számban.\n# A függvény egyetlen argumentumot vesz fel, n, amely egy pozitív egész szám, és\n# visszaadja az '1' számjegy összes előfordulásának számát az 1-től n-ig terjedő összes számban.\n#\n# Példa:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9857727016976141",
      "hy": "0.9764156217078226",
      "bn": "0.9801812564714819",
      "bg": "0.9793428376331337",
      "zh": "0.9610038904433256",
      "fr": "0.9864037504181619",
      "de": "0.9791013030897953",
      "ha": "0.9896670489481841",
      "hi": "0.9882510129617864",
      "hu": "0.9816227171466522"
    },
    "canonical_solution": "  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n",
    "instruction": {
      "en": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nনিচের Ruby কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\n请为以下 Ruby 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nBa da taƙaitaccen bayanin yaren halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_ones_in_range(n)\n  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.8888019455675248",
      "bn": "0.8673498644157568",
      "bg": "0.8364486908745768",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9408021875401723",
      "hi": "0.9119288780921788",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_ones_in_range(15) == 8\nraise 'Test failed' unless count_ones_in_range(20) == 12\nraise 'Test failed' unless count_ones_in_range(100) == 21\nraise 'Test failed' unless count_ones_in_range(5) == 1\nraise 'Test failed' unless count_ones_in_range(55) == 16\nraise 'Test failed' unless count_ones_in_range(0) == 0\n\nputs 'All tests passed!'",
    "entry_point": "count_ones_in_range",
    "signature": "def count_ones_in_range(n)",
    "docstring": {
      "en": "Counts the number of times the digit '1' appears in all numbers from 1 to n.\nThe function takes a single argument, n, which is a positive integer, and\nreturns the total count of the digit '1' appearing in all numbers from 1 to n.\n\nExample:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "sq": "Numëron sa herë shfaqet shifra '1' në të gjitha numrat nga 1 deri në n. Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen numrin total të shifrës '1' që shfaqet në të gjitha numrat nga 1 deri në n.\n\nShembull:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hy": "Հաշվում է, թե քանի անգամ է թիվ '1'-ը հայտնվում 1-ից մինչև n բոլոր թվերի մեջ:\nՖունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և\nվերադարձնում է թիվ '1'-ի ընդհանուր քանակը, որը հայտնվում է 1-ից մինչև n բոլոր թվերի մեջ:\n\nՕրինակ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "bn": "সংখ্যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যায় ডিজিট '1' কতবার প্রদর্শিত হয় তা গণনা করে। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং \n1 থেকে n পর্যন্ত সমস্ত সংখ্যায় ডিজিট '1' প্রদর্শনের মোট সংখ্যা ফেরত দেয়।\n\nউদাহরণ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "bg": "Брои колко пъти цифрата '1' се появява във всички числа от 1 до n. \nФункцията приема един аргумент, n, който е положително цяло число, и \nвръща общия брой на появяванията на цифрата '1' във всички числа от 1 до n.\n\nПример:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "zh": "计算数字 '1' 在从 1 到 n 的所有数字中出现的次数。  \n该函数接受一个参数 n，这是一个正整数，并返回数字 '1' 在从 1 到 n 的所有数字中出现的总次数。\n\n示例:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "fr": "Compte le nombre de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n. La fonction prend un seul argument, n, qui est un entier positif, et retourne le compte total du chiffre '1' apparaissant dans tous les nombres de 1 à n.\n\nExemple :\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "de": "Zählt die Anzahl der Vorkommen der Ziffer '1' in allen Zahlen von 1 bis n.\nDie Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und\ngibt die Gesamtanzahl der Ziffer '1' zurück, die in allen Zahlen von 1 bis n erscheint.\n\nBeispiel:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "ha": "Yana ƙididdige yawan lokutan da lamba '1' ta bayyana a duk lambobi daga 1 zuwa n. \n\nAikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau, kuma \nyana mayar da jimlar ƙididdigar lamba '1' da ta bayyana a duk lambobi daga 1 zuwa n.\n\nMisali:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hi": "सभी संख्याओं में अंक '1' कितनी बार आता है, इसकी गणना करता है 1 से n तक।\nयह फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और\n1 से n तक सभी संख्याओं में अंक '1' की कुल गणना लौटाता है।\n\nउदाहरण:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hu": "Számolja meg, hányszor fordul elő az '1' számjegy az összes 1-től n-ig terjedő számokban. A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja az '1' számjegy összes előfordulásának számát az 1-től n-ig terjedő számokban.\n\nPélda:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12"
    },
    "docstring_bertscore": {
      "sq": "0.9825968005352472",
      "hy": "0.9817291830308869",
      "bn": "0.9761172788755081",
      "bg": "0.9725915896121389",
      "zh": "0.9552473833705535",
      "fr": "1",
      "de": "0.9786378984108409",
      "ha": "0.9861715515027322",
      "hi": "0.9788565904603603",
      "hu": "0.9632053109563352"
    }
  },
  {
    "task_id": "Ruby/3",
    "prompt": {
      "en": "# Calculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\n# The function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum \n# of all '1's in the binary representation of each number in the range [l, r].\n#\n# Examples:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "sq": "# Llogarit numrin total të shifrës '1' në përfaqësimin binar të të gjitha numrave në një interval të dhënë [l, r].\n# Funksioni merr dy argumente, l dhe r, ku l <= r dhe të dy janë numra të plotë jo-negativë. Ai kthen shumën\n# e të gjitha '1'-ve në përfaqësimin binar të secilit numër në intervalin [l, r].\n#\n# Shembuj:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "hy": "# Հաշվում է թվային '1'-ի ընդհանուր քանակը տրված միջակայքում [l, r] գտնվող բոլոր թվերի երկբայական ներկայացման մեջ։\n# Ֆունկցիան ընդունում է երկու արգումենտ՝ l և r, որտեղ l <= r և երկուսն էլ ոչ բացասական ամբողջ թվեր են։ Այն վերադարձնում է\n# բոլոր '1'-երի գումարը յուրաքանչյուր թվի երկբայական ներկայացման մեջ միջակայքում [l, r]։\n#\n# Օրինակներ:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "bn": "# প্রদত্ত সীমার মধ্যে [l, r] সকল সংখ্যার বাইনারি উপস্থাপনায় ডিজিট '1' এর মোট সংখ্যা গণনা করে।\n# ফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, l এবং r, যেখানে l <= r এবং উভয়ই অ-ঋণাত্মক পূর্ণসংখ্যা। এটি সীমার [l, r] প্রতিটি সংখ্যার \n# বাইনারি উপস্থাপনায় সকল '1' এর যোগফল প্রদান করে।\n#\n# উদাহরণ:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "bg": "# Изчислява общия брой на цифрата '1' в двоичното представяне на всички числа в даден интервал [l, r].\n# Функцията приема два аргумента, l и r, където l <= r и двете са неотрицателни цели числа. Тя връща сумата\n# на всички '1' в двоичното представяне на всяко число в интервала [l, r].\n#\n# Примери:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "zh": "# 计算给定范围 [l, r] 内所有数字的二进制表示中数字 '1' 的总数。\n# 该函数接受两个参数，l 和 r，其中 l <= r 且两者都是非负整数。它返回范围 [l, r] 内每个数字的二进制表示中所有 '1' 的和。\n#\n# 例子:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "fr": "# Calcule le nombre total du chiffre '1' dans la représentation binaire de tous les nombres dans une plage donnée [l, r].\n# La fonction prend deux arguments, l et r, où l <= r et les deux sont des entiers non négatifs. Elle renvoie la somme \n# de tous les '1' dans la représentation binaire de chaque nombre dans la plage [l, r].\n#\n# Exemples:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "de": "# Berechnet die Gesamtanzahl des Zeichens '1' in der Binärdarstellung aller Zahlen in einem gegebenen Bereich [l, r].\n# Die Funktion nimmt zwei Argumente, l und r, wobei l <= r und beide nicht-negative ganze Zahlen sind. Sie gibt die Summe \n# aller '1's in der Binärdarstellung jeder Zahl im Bereich [l, r] zurück.\n#\n# Beispiele:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "ha": "# Lissafi jimillar adadin lamba '1' a cikin wakilcin binary na duk lambobi a cikin kewayon da aka bayar [l, r].\n# Aikin yana ɗaukar hujjoji biyu, l da r, inda l <= r kuma duka lambobi ne marasa kyau. Yana mayar da jumlar \n# duk '1's a cikin wakilcin binary na kowane lamba a cikin kewayon [l, r].\n#\n# Misalai:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "hi": "# दिए गए सीमा [l, r] में सभी संख्याओं के बाइनरी प्रतिनिधित्व में अंक '1' की कुल गिनती की गणना करता है।\n# फ़ंक्शन दो तर्क लेता है, l और r, जहाँ l <= r और दोनों गैर-ऋणात्मक पूर्णांक हैं। यह सीमा [l, r] में प्रत्येक संख्या के \n# बाइनरी प्रतिनिधित्व में सभी '1's का योग लौटाता है।\n#\n# उदाहरण:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "hu": "# Kiszámítja az összes '1' számjegy előfordulását a megadott [l, r] tartományba eső összes szám bináris reprezentációjában.\n# A függvény két argumentumot vesz fel, l és r, ahol l <= r és mindkettő nem-negatív egész szám. Visszaadja az összes\n# '1' összegét az egyes számok bináris reprezentációjában a [l, r] tartományban.\n#\n# Példák:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)"
    },
    "prompt_bertscore": {
      "sq": "0.995342912086256",
      "hy": "0.9693251129960202",
      "bn": "0.976275984549955",
      "bg": "0.9851915092027059",
      "zh": "0.964786806050135",
      "fr": "0.995342912086256",
      "de": "0.9914509484002584",
      "ha": "0.9730345353618467",
      "hi": "0.9896444050847462",
      "hu": "0.9628207625386517"
    },
    "canonical_solution": "  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend",
    "instruction": {
      "en": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nনিচের Ruby কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\n请提供一个简洁的中文自然语言描述（文档字符串），描述该Ruby代码，字符数不超过500个。",
      "fr": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def sum_of_binary_ones(l, r)\n  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.8856923869524236",
      "bn": "0.8673498644157568",
      "bg": "0.8364486908745768",
      "zh": "0.8895023162910538",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9531146889693819",
      "hi": "0.9119288780921788",
      "hu": "0.9433102933614999"
    },
    "level": "",
    "test": "raise 'Test failed' unless sum_of_binary_ones(2, 3) == 3\nraise 'Test failed' unless sum_of_binary_ones(5, 5) == 2\nraise 'Test failed' unless sum_of_binary_ones(0, 4) == 5\nraise 'Test failed' unless sum_of_binary_ones(10, 15) == 17\nraise 'Test failed' unless sum_of_binary_ones(0, 0) == 0\n\n\n\nputs 'All tests passed!'",
    "entry_point": "sum_of_binary_ones",
    "signature": "def sum_of_binary_ones(l, r)",
    "docstring": {
      "en": "Calculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\nThe function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum\nof all '1's in the binary representation of each number in the range [l, r].\n\nExamples:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "sq": "Llogarit numrin total të shifrës '1' në përfaqësimin binar të të gjitha numrave në një interval të dhënë [l, r]. Funksioni merr dy argumente, l dhe r, ku l <= r dhe të dy janë numra të plotë jo-negativë. Ai kthen shumën e të gjitha '1'-ve në përfaqësimin binar të secilit numër në intervalin [l, r].\n\nShembuj:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hy": "Հաշվում է թվային '1'-ի ընդհանուր քանակը բոլոր թվերի երկային ներկայացման մեջ տրված [l, r] միջակայքում:\nՖունկցիան ընդունում է երկու արգումենտ՝ l և r, որտեղ l <= r և երկուսն էլ ոչ բացասական ամբողջ թվեր են: Այն վերադարձնում է\nբոլոր '1'-երի գումարը յուրաքանչյուր թվի երկային ներկայացման մեջ [l, r] միջակայքում:\n\nՕրինակներ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "bn": "বাইনারি উপস্থাপনার মধ্যে '1' সংখ্যাটির মোট গণনা নির্ধারণ করে একটি নির্দিষ্ট পরিসরে [l, r] এর সব সংখ্যার জন্য। ফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, l এবং r, যেখানে l <= r এবং উভয়ই অ-ঋণাত্মক পূর্ণসংখ্যা। এটি পরিসর [l, r] এর প্রতিটি সংখ্যার বাইনারি উপস্থাপনার মধ্যে সব '1' এর যোগফল প্রদান করে।\n\nউদাহরণ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "bg": "Изчислява общия брой на цифрата '1' в двоичното представяне на всички числа в даден интервал [l, r]. Функцията приема два аргумента, l и r, където l <= r и и двете са неотрицателни цели числа. Тя връща сумата на всички '1' в двоичното представяне на всяко число в интервала [l, r].\n\nПримери:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "zh": "计算给定范围 [l, r] 内所有数字的二进制表示中数字 '1' 的总数。\n该函数接受两个参数，l 和 r，其中 l <= r 且两者都是非负整数。它返回范围 [l, r] 内每个数字的二进制表示中所有 '1' 的总和。\n\n示例：\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "fr": "Calcule le nombre total du chiffre '1' dans la représentation binaire de tous les nombres dans une plage donnée [l, r].  \nLa fonction prend deux arguments, l et r, où l <= r et les deux sont des entiers non négatifs. Elle renvoie la somme  \nde tous les '1' dans la représentation binaire de chaque nombre dans la plage [l, r].\n\nExemples:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "de": "Berechnet die Gesamtanzahl des Zeichens '1' in der Binärdarstellung aller Zahlen in einem gegebenen Bereich [l, r].\nDie Funktion nimmt zwei Argumente, l und r, wobei l <= r und beide nicht negative ganze Zahlen sind. Sie gibt die Summe\naller '1's in der Binärdarstellung jeder Zahl im Bereich [l, r] zurück.\n\nBeispiele:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "ha": "Yana ƙididdige adadin jimillar lamba '1' a cikin wakilcin binary na duk lambobi a cikin kewayon da aka bayar [l, r]. \n\nAikin yana ɗaukar hujjoji guda biyu, l da r, inda l <= r kuma dukansu lambobi ne marasa kyau. Yana dawo da jumlar duk '1's a cikin wakilcin binary na kowane lamba a cikin kewayon [l, r].\n\nMisalai:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hi": "दिए गए रेंज [l, r] में सभी संख्याओं के बाइनरी रूप में अंक '1' की कुल गिनती की गणना करता है। \nयह फ़ंक्शन दो तर्क लेता है, l और r, जहाँ l <= r और दोनों गैर-ऋणात्मक पूर्णांक हैं। यह रेंज [l, r] में प्रत्येक संख्या के बाइनरी रूप में सभी '1's का योग लौटाता है।\n\nउदाहरण:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hu": "Kiszámítja az összes '1' számjegy előfordulását a megadott tartomány [l, r] összes számának bináris ábrázolásában.\nA függvény két argumentumot vesz fel, l és r, ahol l <= r és mindkettő nem-negatív egész szám. Visszaadja az összes '1' összegét az egyes számok bináris ábrázolásában a [l, r] tartományban.\n\nPéldák:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5"
    },
    "docstring_bertscore": {
      "sq": "0.9733602891867439",
      "hy": "0.9820285190151065",
      "bn": "0.9697680587457279",
      "bg": "0.9953858162485596",
      "zh": "0.9622681728186127",
      "fr": "0.9936617045411767",
      "de": "0.9896561242772272",
      "ha": "0.9686666532828895",
      "hi": "0.974283125937032",
      "hu": "0.9745896126149688"
    }
  },
  {
    "task_id": "Ruby/4",
    "prompt": {
      "en": "# Converts a positive integer into a unique binary power representation.\n# The function takes a single argument, n, which is a positive integer, and\n# returns a string representing n as a sum of powers of 2, with the powers \n# themselves also represented as sums of powers of 2 when applicable.\n#\n# The representation is formatted as '2(b)' where 'b' is the power. If 'b' itself \n# is a power of 2, it's represented in a similar nested format. Spaces are not \n# used in the representation.\n#\n# Example:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "sq": "# Konverton një numër të plotë pozitiv në një përfaqësim unik të fuqisë binare.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe\n# kthen një varg që përfaqëson n si një shumë të fuqive të 2, me fuqitë\n# vetë të përfaqësuara gjithashtu si shuma të fuqive të 2 kur është e aplikueshme.\n#\n# Përfaqësimi është i formatuar si '2(b)' ku 'b' është fuqia. Nëse 'b' vetë\n# është një fuqi e 2, ajo përfaqësohet në një format të ngjashëm të folezuar. Hapësirat nuk\n# përdoren në përfaqësim.\n#\n# Shembull:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\" \n\ndef binary_power_representation(n)",
      "hy": "# Դարձնում է դրական ամբողջ թիվը եզակի երկբայական աստիճան ներկայացման:\n# Ֆունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, և\n# վերադարձնում է n-ի տողային ներկայացումը որպես 2-ի աստիճանների գումար, որտեղ\n# աստիճանները նույնպես ներկայացված են որպես 2-ի աստիճանների գումար, եթե կիրառելի է:\n#\n# Ներկայացումը ձևաչափվում է որպես '2(b)', որտեղ 'b'-ն աստիճանն է: Եթե 'b'-ն ինքնին\n# 2-ի աստիճան է, այն ներկայացվում է նման բովանդակային ձևաչափով: Ներկայացման մեջ\n# բացատներ չեն օգտագործվում:\n#\n# Օրինակ:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "bn": "# একটি ধনাত্মক পূর্ণসংখ্যাকে একটি অনন্য বাইনারি শক্তি উপস্থাপনায় রূপান্তর করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং\n# একটি স্ট্রিং রিটার্ন করে যা n কে 2 এর শক্তির যোগফল হিসাবে উপস্থাপন করে, যেখানে শক্তিগুলিও\n# প্রয়োজনে 2 এর শক্তির যোগফল হিসাবে উপস্থাপিত হয়।\n#\n# উপস্থাপনাটি '2(b)' হিসাবে বিন্যাসিত যেখানে 'b' হল শক্তি। যদি 'b' নিজেই\n# 2 এর একটি শক্তি হয়, তাহলে এটি অনুরূপ নেস্টেড বিন্যাসে উপস্থাপিত হয়। উপস্থাপনায়\n# স্পেস ব্যবহার করা হয় না।\n#\n# উদাহরণ:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\" \n\ndef binary_power_representation(n)",
      "bg": "# Преобразува положително цяло число в уникално представяне чрез степени на две.\n# Функцията приема един аргумент, n, който е положително цяло число, и\n# връща низ, представляващ n като сума от степени на 2, като самите степени\n# също се представят като суми от степени на 2, когато е приложимо.\n#\n# Представянето е форматирано като '2(b)', където 'b' е степента. Ако 'b' сам по себе си\n# е степен на 2, той се представя в подобен вложен формат. Интервали не се\n# използват в представянето.\n#\n# Пример:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "zh": "# 将一个正整数转换为唯一的二进制幂表示。\n# 该函数接受一个参数 n，它是一个正整数，并返回一个字符串，\n# 该字符串将 n 表示为 2 的幂的和，其中幂本身也在适用时表示为 2 的幂的和。\n#\n# 表示形式格式为 '2(b)'，其中 'b' 是幂。如果 'b' 本身是 2 的幂，\n# 则以类似的嵌套格式表示。不在表示中使用空格。\n#\n# 示例:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "fr": "# Convertit un entier positif en une représentation unique de puissance binaire.\n# La fonction prend un seul argument, n, qui est un entier positif, et\n# renvoie une chaîne représentant n comme une somme de puissances de 2, avec les puissances\n# elles-mêmes également représentées comme des sommes de puissances de 2 lorsque c'est applicable.\n#\n# La représentation est formatée comme '2(b)' où 'b' est la puissance. Si 'b' lui-même\n# est une puissance de 2, il est représenté dans un format imbriqué similaire. Les espaces ne sont pas\n# utilisés dans la représentation.\n#\n# Exemple:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "de": "# Wandelt eine positive ganze Zahl in eine einzigartige Binärpotenzdarstellung um.\n# Die Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und\n# gibt einen String zurück, der n als Summe von Potenzen von 2 darstellt, wobei die Potenzen\n# selbst auch als Summen von Potenzen von 2 dargestellt werden, wenn anwendbar.\n#\n# Die Darstellung ist formatiert als '2(b)', wobei 'b' die Potenz ist. Wenn 'b' selbst\n# eine Potenz von 2 ist, wird sie in einem ähnlichen verschachtelten Format dargestellt. \n# Leerzeichen werden in der Darstellung nicht verwendet.\n#\n# Beispiel:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\" \n\ndef binary_power_representation(n)",
      "ha": "# Yana canza lamba mai kyau zuwa wakilcin ƙarfin binary na musamman.\n# Aikin yana ɗaukar hujja guda ɗaya, n, wanda lamba ce mai kyau, kuma\n# yana mayar da igiya da ke wakiltar n a matsayin jumlar ƙarfi na 2, tare da ƙarfafan \n# kansu kuma ana wakilta su a matsayin jumlar ƙarfi na 2 idan ya dace.\n#\n# Wakilcin yana da tsari a matsayin '2(b)' inda 'b' shine ƙarfin. Idan 'b' kansa\n# ƙarfin 2 ne, ana wakilta shi a cikin tsari mai kama da juna. Ba a amfani da sarari \n# a cikin wakilcin.\n#\n# Misali:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "hi": "# एक धनात्मक पूर्णांक को एक अद्वितीय द्विआधारी शक्ति प्रतिनिधित्व में परिवर्तित करता है।\n# यह फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और\n# n को 2 की शक्तियों के योग के रूप में एक स्ट्रिंग लौटाता है, जिसमें शक्तियों को भी \n# जब लागू हो, 2 की शक्तियों के योग के रूप में दर्शाया जाता है।\n#\n# प्रतिनिधित्व को '2(b)' के रूप में स्वरूपित किया गया है जहाँ 'b' शक्ति है। यदि 'b' स्वयं \n# 2 की शक्ति है, तो इसे समान नेस्टेड प्रारूप में दर्शाया जाता है। प्रतिनिधित्व में \n# रिक्त स्थान का उपयोग नहीं किया जाता है।\n#\n# उदाहरण:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "hu": "# Egy pozitív egész számot alakít át egyedi bináris hatvány reprezentációvá.\n# A függvény egyetlen argumentumot vesz fel, n, amely egy pozitív egész szám, és\n# visszaad egy karakterláncot, amely n-t az 2 hatványainak összegével reprezentálja, ahol a hatványok\n# maguk is 2 hatványainak összegével vannak ábrázolva, ha alkalmazható.\n#\n# A reprezentáció formátuma '2(b)', ahol 'b' a hatvány. Ha 'b' maga is\n# 2 hatványa, akkor hasonló beágyazott formátumban van ábrázolva. A reprezentációban\n# nem használnak szóközöket.\n#\n# Példa:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9993774923858366",
      "hy": "0.9579273044714762",
      "bn": "0.9874008749309571",
      "bg": "0.9691318456352732",
      "zh": "0.9679343030680139",
      "fr": "0.9993774923858366",
      "de": "0.9809636615423784",
      "ha": "0.9710478342907357",
      "hi": "0.9646366414820726",
      "hu": "0.9649584226993492"
    },
    "canonical_solution": "    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end",
    "instruction": {
      "en": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nনিচের Ruby কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\n请为以下 Ruby 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na wannan lambar Ruby a cikin Hausa, ba fiye da haruffa 500 ba.",
      "hi": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def binary_power_representation(n)\n    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8913444144447713",
      "bn": "0.8673498644157568",
      "bg": "0.8394899671718035",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9007585013539199",
      "hi": "0.9119288780921788",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless binary_power_representation(137) == \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\nraise 'Test failed' unless binary_power_representation(1315) == \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\nraise 'Test failed' unless binary_power_representation(1) == \"2(0)\"\nraise 'Test failed' unless binary_power_representation(3) == \"2+2(0)\"\nraise 'Test failed' unless binary_power_representation(10) == \"2(2+2(0))+2\"\n\n\nputs 'All tests passed!'",
    "entry_point": "binary_power_representation",
    "signature": "def binary_power_representation(n)",
    "docstring": {
      "en": "Converts a positive integer into a unique binary power representation.\nThe function takes a single argument, n, which is a positive integer, and\nreturns a string representing n as a sum of powers of 2, with the powers\nthemselves also represented as sums of powers of 2 when applicable.\n\nThe representation is formatted as '2(b)' where 'b' is the power. If 'b' itself\nis a power of 2, it's represented in a similar nested format. Spaces are not\nused in the representation.\n\nExample:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "sq": "Konverton një numër të plotë pozitiv në një përfaqësim unik të fuqisë binare.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe\nkthen një varg që përfaqëson n si një shumë të fuqive të 2, me fuqitë\nvetë të përfaqësuara gjithashtu si shuma të fuqive të 2 kur është e aplikueshme.\n\nPërfaqësimi është i formatuar si '2(b)' ku 'b' është fuqia. Nëse 'b' vetë\nështë një fuqi e 2, ajo përfaqësohet në një format të ngjashëm të folezuar. Hapësirat nuk\npërdoren në përfaqësim.\n\nShembull:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hy": "Փոխակերպում է դրական ամբողջ թիվը եզակի երկբայական ուժի ներկայացման:\nՖունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, և վերադարձնում է տող, որը ներկայացնում է n-ը որպես 2-ի ուժերի գումար, ընդ որում ուժերը նույնպես ներկայացվում են որպես 2-ի ուժերի գումար, երբ կիրառելի է:\n\nՆերկայացումը ձևաչափված է որպես '2(b)', որտեղ 'b'-ն ուժն է: Եթե 'b'-ն ինքնին 2-ի ուժ է, այն ներկայացվում է նմանատիպ ներդրված ձևաչափով: Ներկայացման մեջ բացատներ չեն օգտագործվում:\n\nՕրինակ:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "bn": "একটি ধনাত্মক পূর্ণসংখ্যাকে একটি অনন্য বাইনারি শক্তি উপস্থাপনায় রূপান্তর করে। ফাংশনটি একটি একক আর্গুমেন্ট, n, গ্রহণ করে, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং একটি স্ট্রিং প্রদান করে যা n-কে 2-এর শক্তির যোগফল হিসাবে উপস্থাপন করে, যেখানে প্রযোজ্য হলে শক্তিগুলোকেও 2-এর শক্তির যোগফল হিসাবে উপস্থাপন করা হয়।\n\nউপস্থাপনাটি '2(b)' হিসাবে বিন্যাসিত হয় যেখানে 'b' হল শক্তি। যদি 'b' নিজেই 2-এর একটি শক্তি হয়, তবে এটি একইভাবে নেস্টেড ফরম্যাটে উপস্থাপিত হয়। উপস্থাপনায় স্পেস ব্যবহার করা হয় না।\n\nউদাহরণ:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "bg": "Преобразува положително цяло число в уникално представяне чрез степени на двойката.\nФункцията приема един аргумент, n, който е положително цяло число, и\nвръща низ, представляващ n като сума от степени на двойката, като самите степени\nсъщо са представени като суми от степени на двойката, когато е приложимо.\n\nПредставянето е форматирано като '2(b)', където 'b' е степента. Ако 'b' сам по себе си\nе степен на двойката, той е представен в подобен вложен формат. Интервали не се\nизползват в представянето.\n\nПример:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "zh": "将正整数转换为唯一的二进制幂表示形式。  \n该函数接受一个参数 n，它是一个正整数，并返回一个字符串，将 n 表示为 2 的幂之和，其中幂本身也在适用时表示为 2 的幂之和。\n\n表示形式格式为 '2(b)'，其中 'b' 是幂。如果 'b' 本身是 2 的幂，则以类似的嵌套格式表示。不在表示中使用空格。\n\n示例：\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "fr": "Convertit un entier positif en une représentation unique de puissances binaires.\nLa fonction prend un seul argument, n, qui est un entier positif, et\nrenvoie une chaîne représentant n comme une somme de puissances de 2, avec les puissances\nelles-mêmes également représentées comme des sommes de puissances de 2 lorsque c'est applicable.\n\nLa représentation est formatée comme '2(b)' où 'b' est la puissance. Si 'b' lui-même\nest une puissance de 2, il est représenté dans un format imbriqué similaire. Les espaces ne sont pas\nutilisés dans la représentation.\n\nExemple:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "de": "Konvertiert eine positive ganze Zahl in eine einzigartige Binärpotenzdarstellung.\nDie Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und\ngibt einen String zurück, der n als Summe von Potenzen von 2 darstellt, wobei die Potenzen\nselbst auch als Summen von Potenzen von 2 dargestellt werden, wenn zutreffend.\n\nDie Darstellung ist formatiert als '2(b)', wobei 'b' die Potenz ist. Wenn 'b' selbst\neine Potenz von 2 ist, wird sie in einem ähnlichen verschachtelten Format dargestellt. Leerzeichen werden in der Darstellung nicht verwendet.\n\nBeispiel:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "ha": "Yana canza lamba mai kyau zuwa wakilcin ƙarfin binary na musamman. \n\nAikin yana ɗaukar hujja guda ɗaya, n, wanda shine lamba mai kyau, kuma yana dawowa da igiyar da ke wakiltar n a matsayin jumla na ƙarfin 2, tare da ƙarfin kansu kuma an wakilta su a matsayin jumla na ƙarfin 2 idan ya dace.\n\nWakilcin yana da tsari kamar '2(b)' inda 'b' shine ƙarfin. Idan 'b' kansa shine ƙarfin 2, ana wakilta shi a cikin irin wannan tsarin da aka haɗa. Ba a amfani da sarari a cikin wakilcin.\n\nMisali:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hi": "एक धनात्मक पूर्णांक को अद्वितीय द्विआधारी घातांक प्रतिनिधित्व में परिवर्तित करता है। \nयह फ़ंक्शन एकल तर्क, n, लेता है, जो एक धनात्मक पूर्णांक है, और \nn को 2 की घाताओं के योग के रूप में एक स्ट्रिंग लौटाता है, जिसमें घातांक \nभी लागू होने पर 2 की घाताओं के योग के रूप में दर्शाए जाते हैं।\n\nप्रतिनिधित्व '2(b)' के रूप में स्वरूपित होता है जहाँ 'b' घातांक है। यदि 'b' स्वयं \n2 की घात है, तो इसे समान नेस्टेड प्रारूप में दर्शाया जाता है। \nप्रतिनिधित्व में रिक्त स्थान का उपयोग नहीं किया जाता है।\n\nउदाहरण:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hu": "Konvertál egy pozitív egész számot egyedi bináris hatvány reprezentációvá.  \nA függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és  \nvisszaad egy karakterláncot, amely n-t a 2 hatványainak összegével reprezentálja, ahol a hatványok  \nszintén a 2 hatványainak összegével vannak reprezentálva, ha alkalmazható.\n\nA reprezentáció formátuma '2(b)', ahol 'b' a hatvány. Ha 'b' maga is  \na 2 hatványa, akkor hasonló beágyazott formátumban van reprezentálva. A reprezentációban  \nnem használnak szóközöket.\n\nPélda:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\""
    },
    "docstring_bertscore": {
      "sq": "0.9989087246865943",
      "hy": "0.9559026649975876",
      "bn": "0.9842078915558212",
      "bg": "0.9610511644740118",
      "zh": "0.9676452958636081",
      "fr": "0.9995689720731543",
      "de": "0.9829958489707463",
      "ha": "0.984878467722195",
      "hi": "0.9758380045597731",
      "hu": "0.9623335222139732"
    }
  },
  {
    "task_id": "Ruby/5",
    "prompt": {
      "en": "# Finds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\n# The function takes a single argument, n, which is a positive integer, and returns the highest LCM\n# attainable by any combination of three distinct numbers from 1 to n.\n#\n# Example:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "sq": "# Gjen Numrin më të Madh të Përbashkët (LCM) maksimal të mundshëm të çdo tre numrave të zgjedhur midis 1 dhe n.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen LCM-në më të lartë\n# të arritshme nga çdo kombinim i tre numrave të ndryshëm nga 1 deri në n.\n#\n# Shembull:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "hy": "# Գտնում է 1-ից n միջակայքում ընտրված ցանկացած երեք թվերի առավելագույն հնարավոր ամենափոքր ընդհանուր բազմապատիկը (LCM):\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է ամենաբարձր LCM-ը,\n# որը հնարավոր է ստանալ 1-ից n միջակայքում գտնվող երեք տարբեր թվերի համադրությամբ:\n#\n# Օրինակ:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "bn": "# ১ থেকে n এর মধ্যে যেকোনো তিনটি সংখ্যার সর্বাধিক সম্ভাব্য লঘিষ্ঠ সাধারণ গুণনীয়ক (LCM) খুঁজে বের করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং ১ থেকে n এর মধ্যে তিনটি ভিন্ন সংখ্যার যেকোনো সংমিশ্রণের দ্বারা অর্জনযোগ্য সর্বোচ্চ LCM প্রদান করে।\n#\n# উদাহরণ:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "bg": "# Намира максимално възможното Най-малко Общо Кратно (НОК) на произволни три числа, избрани между 1 и n.\n# Функцията приема един аргумент, n, който е положително цяло число, и връща най-високото НОК,\n# което може да бъде постигнато от всяка комбинация от три различни числа от 1 до n.\n#\n# Пример:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "zh": "# 找出从1到n中任意三个数字的最大可能最小公倍数（LCM）。\n# 该函数接受一个参数n，这是一个正整数，并返回从1到n中任意三个不同数字组合所能达到的最高LCM。\n#\n# 示例：\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "fr": "# Trouve le Plus Petit Multiple Commun (PPMC) maximum possible de n'importe quels trois nombres choisis entre 1 et n.\n# La fonction prend un seul argument, n, qui est un entier positif, et renvoie le PPMC le plus élevé\n# atteignable par n'importe quelle combinaison de trois nombres distincts de 1 à n.\n#\n# Exemple:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "de": "# Findet das maximal mögliche kleinste gemeinsame Vielfache (KGV) von drei beliebigen Zahlen, die zwischen 1 und n gewählt werden.\n# Die Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und gibt das höchste KGV zurück,\n# das durch eine beliebige Kombination von drei verschiedenen Zahlen von 1 bis n erreichbar ist.\n#\n# Beispiel:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "ha": "# Nemi mafi girman Maɗaukakin Maɗaukaki (LCM) na kowanne lambobi uku da aka zaɓa tsakanin 1 da n.\n# Aikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau, kuma yana mayar da mafi girman LCM\n# da za a iya samu ta kowanne haɗin lambobi uku daban-daban daga 1 zuwa n.\n#\n# Misali:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "hi": "# 1 और n के बीच चुने गए किसी भी तीन संख्याओं का अधिकतम संभव लघुत्तम समापवर्तक (LCM) खोजता है।\n# फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और 1 से n तक की तीन भिन्न संख्याओं के किसी भी संयोजन द्वारा प्राप्त उच्चतम LCM लौटाता है।\n#\n# उदाहरण:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "hu": "# Megkeresi bármely három szám legnagyobb lehetséges legkisebb közös többszörösét (LKKT) az 1 és n között.\n# A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja a legnagyobb LKKT-t,\n# amely bármely három különböző szám kombinációjával elérhető 1-től n-ig.\n#\n# Példa:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9805429623953464",
      "hy": "0.9460595364654036",
      "bn": "0.9718050133032408",
      "bg": "0.982999622947986",
      "zh": "0.9551522394180377",
      "fr": "0.9914906744764654",
      "de": "0.9813106688180463",
      "ha": "0.9742408176658716",
      "hi": "0.9824323345797503",
      "hu": "0.9675894807265373"
    },
    "canonical_solution": "    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end",
    "instruction": {
      "en": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def max_lcm_of_three(n)\n    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8838310216517457",
      "bn": "0.8746987912532856",
      "bg": "0.8991035130191372",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9353344890414249",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_lcm_of_three(9) == 504\nraise 'Test failed' unless max_lcm_of_three(10) == 630\nraise 'Test failed' unless max_lcm_of_three(3) == 6\nraise 'Test failed' unless max_lcm_of_three(5) == 60\nraise 'Test failed' unless max_lcm_of_three(1) == 1\n  \n\nputs 'All tests passed!'",
    "entry_point": "max_lcm_of_three",
    "signature": "def max_lcm_of_three(n)",
    "docstring": {
      "en": "Finds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\nThe function takes a single argument, n, which is a positive integer, and returns the highest LCM\nattainable by any combination of three distinct numbers from 1 to n.\n\nExample:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "sq": "Gjen Minimumin e Përbashkët Shumëfishin (LCM) maksimal të mundshëm të çdo tre numrave të zgjedhur midis 1 dhe n. Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen LCM më të lartë të arritshëm nga çdo kombinim i tre numrave të ndryshëm nga 1 deri në n.\n\nShembull:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hy": "Գտնում է հնարավոր ամենամեծ նվազագույն ընդհանուր բազմապատիկը (LCM) ցանկացած երեք թվերի, որոնք ընտրված են 1-ից մինչև n միջակայքում: Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է ամենաբարձր LCM-ը, որը հնարավոր է ստանալ 1-ից մինչև n միջակայքում գտնվող երեք տարբեր թվերի ցանկացած համադրությամբ:\n\nՕրինակ:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "bn": "১ থেকে n এর মধ্যে যেকোনো তিনটি সংখ্যার সর্বাধিক সম্ভাব্য লঘিষ্ঠ সাধারণ গুণনীয়ক (LCM) খুঁজে বের করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং 1 থেকে n পর্যন্ত যেকোনো তিনটি ভিন্ন সংখ্যার সংমিশ্রণে প্রাপ্ত সর্বোচ্চ LCM ফেরত দেয়।\n\nউদাহরণ:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "bg": "Намира максималната възможна Най-малка обща кратност (НОК) на три числа, избрани между 1 и n. Функцията приема един аргумент, n, който е положително цяло число, и връща най-високата НОК, постижима от всяка комбинация от три различни числа от 1 до n.\n\nПример:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "zh": "查找在1到n之间选择的任意三个数字的最大可能最小公倍数（LCM）。  \n该函数接受一个参数n，它是一个正整数，并返回从1到n中任意三个不同数字组合可以达到的最高LCM。\n\n示例：\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "fr": "Trouve le Plus Petit Multiple Commun (PPMC) maximum possible de trois nombres choisis entre 1 et n. La fonction prend un seul argument, n, qui est un entier positif, et retourne le PPMC le plus élevé atteignable par n'importe quelle combinaison de trois nombres distincts de 1 à n.\n\nExemple :\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "de": "Findet das maximal mögliche kleinste gemeinsame Vielfache (KGV) von drei beliebigen Zahlen, die zwischen 1 und n gewählt werden. Die Funktion nimmt ein einziges Argument n, das eine positive ganze Zahl ist, und gibt das höchste KGV zurück, das durch jede Kombination von drei verschiedenen Zahlen von 1 bis n erreichbar ist.\n\nBeispiel:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "ha": "Yana nemo mafi girman Maɗaukakin Maɗaukaki (LCM) na kowanne lambobi uku da aka zaɓa tsakanin 1 da n. Aikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau, kuma yana mayar da mafi girman LCM da za a iya samu ta kowanne haɗin lambobi uku daban-daban daga 1 zuwa n.\n\nMisali:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hi": "किसी भी तीन संख्याओं के बीच 1 से n के बीच चुनी गई अधिकतम संभव लघुत्तम समापवर्त्य (LCM) को खोजता है। \nयह फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और 1 से n तक की तीन भिन्न संख्याओं के किसी भी संयोजन द्वारा प्राप्त उच्चतम LCM लौटाता है।\n\nउदाहरण:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hu": "Megkeresi bármely három szám legnagyobb közös többszörösének (LKT) maximálisan elérhető értékét, amelyeket az 1 és n közötti számok közül választanak ki. A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja a legmagasabb LKT-t, amely bármely három különböző szám kombinációjával elérhető az 1 és n között.\n\nPélda:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630"
    },
    "docstring_bertscore": {
      "sq": "0.9726956719318012",
      "hy": "0.9663591641464072",
      "bn": "0.9813899223400793",
      "bg": "0.9797907491423674",
      "zh": "0.9466339755273566",
      "fr": "0.9775519861177231",
      "de": "0.9632448384021611",
      "ha": "0.9708333134792181",
      "hi": "0.9725496786017406",
      "hu": "0.9522307837737767"
    }
  },
  {
    "task_id": "Ruby/6",
    "prompt": {
      "en": "# Swaps the case of each letter in a given string.\n# The function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters. \n# It returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n#\n# Example:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "sq": "# Ndërron rastin e secilës shkronjë në një varg të dhënë.\n# Funksioni merr një argument të vetëm, input_string, i cili është një varg që përmban vetëm alfabetet angleze pa ndonjë hapësirë ose lloje të tjera karakteresh.\n# Kthen një varg të ri ku çdo shkronjë e vogël shndërrohet në shkronjë të madhe dhe çdo shkronjë e madhe shndërrohet në shkronjë të vogël.\n#\n# Shembull:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "hy": "# Փոխում է տրված տողի յուրաքանչյուր տառի մեծատառ/փոքրատառը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ input_string, որը տող է, որը պարունակում է միայն անգլերեն այբուբենի տառեր՝ առանց բացատների կամ այլ տեսակի սիմվոլների։\n# Այն վերադարձնում է նոր տող, որտեղ յուրաքանչյուր փոքրատառ տառ փոխարկվում է մեծատառի, և յուրաքանչյուր մեծատառ տառ փոխարկվում է փոքրատառի։\n#\n# Օրինակ:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "bn": "# প্রদত্ত স্ট্রিংয়ের প্রতিটি অক্ষরের কেস পরিবর্তন করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, input_string, যা একটি স্ট্রিং যা শুধুমাত্র ইংরেজি বর্ণমালা ধারণ করে, কোন স্পেস বা অন্যান্য ধরনের অক্ষর ছাড়া।\n# এটি একটি নতুন স্ট্রিং রিটার্ন করে যেখানে প্রতিটি ছোট হাতের অক্ষর বড় হাতের অক্ষরে এবং প্রতিটি বড় হাতের অক্ষর ছোট হাতের অক্ষরে রূপান্তরিত হয়।\n#\n# উদাহরণ:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "bg": "# Разменя регистъра на всяка буква в даден низ.\n# Функцията приема един аргумент, input_string, който е низ, съдържащ само английски букви без никакви интервали или други видове символи.\n# Връща нов низ, където всяка малка буква е преобразувана в главна, а всяка главна буква е преобразувана в малка.\n#\n# Пример:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "zh": "# 交换给定字符串中每个字母的大小写。\n# 该函数接受一个参数 input_string，这是一个仅包含英文字母的字符串，没有空格或其他类型的字符。\n# 它返回一个新字符串，其中每个小写字母都转换为大写，而每个大写字母都转换为小写。\n#\n# 示例:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "fr": "# Échange la casse de chaque lettre dans une chaîne donnée.\n# La fonction prend un seul argument, input_string, qui est une chaîne contenant uniquement des alphabets anglais sans espaces ni autres types de caractères.\n# Elle renvoie une nouvelle chaîne où chaque lettre minuscule est convertie en majuscule et chaque lettre majuscule est convertie en minuscule.\n#\n# Exemple :\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "de": "# Vertauscht die Groß- und Kleinschreibung jedes Buchstabens in einem gegebenen String.\n# Die Funktion nimmt ein einziges Argument, input_string, das ein String ist, der nur englische Buchstaben ohne Leerzeichen oder andere Zeichenarten enthält.\n# Sie gibt einen neuen String zurück, bei dem jeder Kleinbuchstabe in einen Großbuchstaben und jeder Großbuchstabe in einen Kleinbuchstaben umgewandelt wird.\n#\n# Beispiel:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "ha": "# Canza harafin kowane wata a cikin kirtani da aka bayar.\n# Aikin yana karɓar hujja guda ɗaya, input_string, wanda kirtani ne mai ɗauke da haruffan Ingilishi kawai ba tare da sarari ko wasu nau'ikan haruffa ba.\n# Yana mayar da sabon kirtani inda dukkan ƙaramin harafi aka canza zuwa babban harafi kuma dukkan babban harafi aka canza zuwa ƙaramin harafi.\n#\n# Misali:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "hi": "# दिए गए स्ट्रिंग में प्रत्येक अक्षर का केस बदलता है।\n# फ़ंक्शन एकल तर्क लेता है, input_string, जो एक स्ट्रिंग है जिसमें केवल अंग्रेजी वर्णमाला के अक्षर होते हैं, बिना किसी स्पेस या अन्य प्रकार के वर्णों के।\n# यह एक नया स्ट्रिंग लौटाता है जहाँ प्रत्येक लोअरकेस अक्षर को अपरकेस में और प्रत्येक अपरकेस अक्षर को लोअरकेस में बदला जाता है।\n#\n# उदाहरण:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\" \n\ndef swap_case(input_string)",
      "hu": "# Minden betű esetét megcseréli egy adott sztringben.\n# A függvény egyetlen argumentumot vesz fel, az input_string-et, amely egy sztring, amely csak angol ábécé betűit tartalmazza, szóközök vagy más karakterek nélkül.\n# Egy új sztringet ad vissza, ahol minden kisbetű nagybetűvé alakul és minden nagybetű kisbetűvé alakul.\n#\n# Példa:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)"
    },
    "prompt_bertscore": {
      "sq": "0.9936215812042076",
      "hy": "0.9483976146805654",
      "bn": "0.9801963523804406",
      "bg": "0.969250030711989",
      "zh": "0.9546379853615384",
      "fr": "0.9883886638158436",
      "de": "0.9737434471917602",
      "ha": "0.955768589490389",
      "hi": "0.9653270806865499",
      "hu": "0.9667685413617201"
    },
    "canonical_solution": "    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end",
    "instruction": {
      "en": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nনিচের রুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\n请为以下 Ruby 代码提供一个简洁的中文自然语言描述（文档字符串），不超过 500 个字符。",
      "fr": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nGeben Sie eine prägnante Beschreibung (Docstring) des Ruby-Codes in deutscher Sprache mit maximal 500 Zeichen.",
      "ha": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def swap_case(input_string)\n    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.8856923869524236",
      "bn": "0.8737062352392543",
      "bg": "0.8364486908745768",
      "zh": "0.8714821708628067",
      "fr": "0.9691999758559682",
      "de": "0.9239160229572533",
      "ha": "0.9111357469807065",
      "hi": "0.9119288780921788",
      "hu": "0.9410598111443745"
    },
    "level": "",
    "test": "raise 'Test failed' unless swap_case(\"HelloWorld\") == \"hELLOwORLD\"\nraise 'Test failed' unless swap_case(\"Ruby\") == \"rUBY\"\nraise 'Test failed' unless swap_case(\"AeDb\") == \"aEdB\"\nraise 'Test failed' unless swap_case(\"JAVA\") == \"java\"\nraise 'Test failed' unless swap_case(\"python\") == \"PYTHON\"\n  \n\nputs 'All tests passed!'",
    "entry_point": "swap_case",
    "signature": "def swap_case(input_string)",
    "docstring": {
      "en": "Swaps the case of each letter in a given string.\nThe function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters.\nIt returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n\nExample:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "sq": "Ndërron rastin e secilës shkronjë në një varg të dhënë.\nFunksioni merr një argument të vetëm, input_string, i cili është një varg që përmban vetëm alfabetin anglez pa hapësira ose lloje të tjera karakteresh.\nKthen një varg të ri ku çdo shkronjë e vogël konvertohet në të madhe dhe çdo shkronjë e madhe konvertohet në të vogël.\n\nShembull:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "hy": "Փոխում է տրված տողի յուրաքանչյուր տառի ռեգիստրը։\nՖունկցիան ընդունում է մեկ արգումենտ՝ input_string, որը տող է, որը պարունակում է միայն անգլերեն այբուբենի տառեր՝ առանց բացատների կամ այլ տեսակի սիմվոլների։\nԱյն վերադարձնում է նոր տող, որտեղ յուրաքանչյուր փոքրատառ տառ փոխարկվում է մեծատառի, իսկ յուրաքանչյուր մեծատառ տառ՝ փոքրատառի։\n\nՕրինակ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "bn": "প্রত্যেকটি অক্ষরের কেস পরিবর্তন করে একটি প্রদত্ত স্ট্রিং-এ। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, input_string, যা একটি স্ট্রিং যা শুধুমাত্র ইংরেজি বর্ণমালা ধারণ করে, কোনো ফাঁকা স্থান বা অন্যান্য ধরনের অক্ষর ছাড়াই। \nএটি একটি নতুন স্ট্রিং ফেরত দেয় যেখানে প্রতিটি ছোট হাতের অক্ষর বড় হাতের অক্ষরে পরিবর্তিত হয় এবং প্রতিটি বড় হাতের অক্ষর ছোট হাতের অক্ষরে পরিবর্তিত হয়।\n\nউদাহরণ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "bg": "Разменя регистъра на всяка буква в даден низ. \nФункцията приема един аргумент, input_string, който е низ, съдържащ само английски букви без никакви интервали или други видове символи. \nТя връща нов низ, където всяка малка буква е преобразувана в главна, а всяка главна буква е преобразувана в малка.\n\nПример:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "zh": "交换给定字符串中每个字母的大小写。\n该函数接受一个参数，input_string，这是一个仅包含英文字母的字符串，没有空格或其他类型的字符。\n它返回一个新字符串，其中每个小写字母转换为大写字母，每个大写字母转换为小写字母。\n\n示例：\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "fr": "Échange la casse de chaque lettre dans une chaîne donnée.  \nLa fonction prend un seul argument, input_string, qui est une chaîne contenant uniquement des alphabets anglais sans espaces ni autres types de caractères.  \nElle retourne une nouvelle chaîne où chaque lettre minuscule est convertie en majuscule et chaque lettre majuscule est convertie en minuscule.  \n\nExemple :  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"  ",
      "de": "Vertauscht die Groß- und Kleinschreibung jedes Buchstabens in einem gegebenen String.  \nDie Funktion nimmt ein einzelnes Argument, input_string, das ein String ist, der nur englische Buchstaben ohne Leerzeichen oder andere Zeichenarten enthält.  \nSie gibt einen neuen String zurück, bei dem jeder Kleinbuchstabe in einen Großbuchstaben und jeder Großbuchstabe in einen Kleinbuchstaben umgewandelt wird.  \n\nBeispiel:  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"  ",
      "ha": "Sauya harafin kowanne harafi a cikin kowane rubutu da aka bayar.\n\nAikin yana ɗaukar hujja guda ɗaya, input_string, wanda rubutu ne da ke ɗauke da haruffan Turanci kawai ba tare da sarari ko wasu nau'ikan haruffa ba.\n\nYana dawo da sabon rubutu inda kowane ƙaramin harafi aka canza zuwa babba kuma kowane babban harafi aka canza zuwa ƙarami.\n\nMisali:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "hi": "प्रत्येक अक्षर के मामले को दिए गए स्ट्रिंग में बदलता है।  \nयह फ़ंक्शन एकल तर्क लेता है, input_string, जो एक स्ट्रिंग है जिसमें केवल अंग्रेजी अक्षर होते हैं, बिना किसी स्पेस या अन्य प्रकार के वर्णों के।  \nयह एक नया स्ट्रिंग लौटाता है जहाँ प्रत्येक छोटे अक्षर को बड़े अक्षर में और प्रत्येक बड़े अक्षर को छोटे अक्षर में बदला जाता है।  \n\nउदाहरण:  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"  ",
      "hu": "Megcseréli minden betű esetét egy adott sztringben.\nA függvény egyetlen argumentumot vesz fel, az input_string-et, amely egy sztring, amely csak angol ábécé betűit tartalmazza, szóközök vagy más típusú karakterek nélkül.\nEgy új sztringet ad vissza, ahol minden kisbetű nagybetűvé alakul, és minden nagybetű kisbetűvé alakul.\n\nPélda:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\""
    },
    "docstring_bertscore": {
      "sq": "0.9841437339427469",
      "hy": "0.9092221418898164",
      "bn": "0.9844641247473562",
      "bg": "0.9627474679280498",
      "zh": "0.9448318020802271",
      "fr": "0.9813901209704603",
      "de": "0.9691507155214715",
      "ha": "0.9638566199757487",
      "hi": "0.9589156892475058",
      "hu": "0.9651844640729669"
    }
  },
  {
    "task_id": "Ruby/7",
    "prompt": {
      "en": "# Finds the maximum value in an array and returns its value along with its index.\n# The function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\n# It returns an array containing the maximum value and its index in the format [max_value, index].\n#\n# Example:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "sq": "# Gjen vlerën maksimale në një varg dhe kthen vlerën e saj së bashku me indeksin e saj.\n# Funksioni merr një argument të vetëm, arr, i cili është një varg me numra të plotë. Madhësia e vargut duhet të jetë midis 1 dhe 100.\n# Kthen një varg që përmban vlerën maksimale dhe indeksin e saj në formatin [max_value, index].\n#\n# Shembull:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "hy": "# Գտնում է զանգվածի առավելագույն արժեքը և վերադարձնում դրա արժեքը և ինդեքսը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ arr, որը ամբողջ թվերի զանգված է։ Զանգվածի չափը պետք է լինի 1-ից 100։\n# Վերադարձնում է զանգված, որը պարունակում է առավելագույն արժեքը և դրա ինդեքսը [max_value, index] ձևաչափով։\n#\n# Օրինակ:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "bn": "# একটি অ্যারেতে সর্বাধিক মান খুঁজে বের করে এবং তার মান সহ তার সূচক ফেরত দেয়।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, arr, যা একটি পূর্ণসংখ্যার অ্যারে। অ্যারের আকার 1 থেকে 100 এর মধ্যে হওয়া উচিত।\n# এটি একটি অ্যারে ফেরত দেয় যা সর্বাধিক মান এবং তার সূচককে [max_value, index] বিন্যাসে ধারণ করে।\n#\n# উদাহরণ:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "bg": "# Намира максималната стойност в масив и връща нейната стойност заедно с индекса й.\n# Функцията приема един аргумент, arr, който е масив от цели числа. Размерът на масива трябва да бъде между 1 и 100.\n# Връща масив, съдържащ максималната стойност и индекса й във формат [max_value, index].\n#\n# Пример:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "zh": "# 查找数组中的最大值，并返回其值及其索引。\n# 该函数接受一个参数，arr，它是一个整数数组。数组大小应在1到100之间。\n# 它返回一个包含最大值及其索引的数组，格式为[max_value, index]。\n#\n# 示例:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "fr": "# Trouve la valeur maximale dans un tableau et renvoie sa valeur avec son indice.\n# La fonction prend un seul argument, arr, qui est un tableau d'entiers. La taille du tableau doit être comprise entre 1 et 100.\n# Elle renvoie un tableau contenant la valeur maximale et son indice au format [max_value, index].\n#\n# Exemple :\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "de": "# Findet den maximalen Wert in einem Array und gibt diesen Wert zusammen mit seinem Index zurück.\n# Die Funktion nimmt ein einziges Argument, arr, das ein Array von ganzen Zahlen ist. Die Arraygröße sollte zwischen 1 und 100 liegen.\n# Sie gibt ein Array zurück, das den maximalen Wert und seinen Index im Format [max_value, index] enthält.\n#\n# Beispiel:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "ha": "# Nemi mafi girman ƙima a cikin jerin kuma mayar da ƙimarsa tare da ma'aunin sa.\n# Aikin yana karɓar hujja guda ɗaya, arr, wanda jerin lambobi ne. Girman jerin yakamata ya kasance tsakanin 1 da 100.\n# Yana mayar da jerin da ke ɗauke da mafi girman ƙima da ma'auninsa a cikin tsarin [max_value, index].\n#\n# Misali:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "hi": "# एक array में अधिकतम मान खोजता है और उसके मान के साथ उसके सूचकांक को लौटाता है।\n# फ़ंक्शन एकल तर्क, arr लेता है, जो पूर्णांकों का एक array है। array का आकार 1 से 100 के बीच होना चाहिए।\n# यह अधिकतम मान और उसके सूचकांक को [max_value, index] प्रारूप में लौटाता है।\n#\n# उदाहरण:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "hu": "# Megkeresi a maximális értéket egy tömbben, és visszaadja annak értékét és indexét.\n# A függvény egyetlen argumentumot vesz fel, arr, amely egy egész számokat tartalmazó tömb. A tömb méretének 1 és 100 között kell lennie.\n# Visszaad egy tömböt, amely a maximális értéket és annak indexét tartalmazza a következő formátumban: [max_value, index].\n#\n# Példa:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)"
    },
    "prompt_bertscore": {
      "sq": "0.9904403170215529",
      "hy": "0.9756536755661728",
      "bn": "0.9859812635977007",
      "bg": "0.9884559995150144",
      "zh": "0.9706881146706815",
      "fr": "0.9876872999404094",
      "de": "0.9962663447276872",
      "ha": "0.958444736614072",
      "hi": "0.9845614536340633",
      "hu": "0.9765610191467401"
    },
    "canonical_solution": "    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end",
    "instruction": {
      "en": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nনিচের Ruby কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def find_max_with_index(arr)\n    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9252859766952509",
      "bn": "0.8673498644157568",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9379331703165044",
      "ha": "0.9408021875401723",
      "hi": "0.9027873120658102",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_max_with_index([3, 2, 1]) == [3, 0]\nraise 'Test failed' unless find_max_with_index([10, 20, 30, 40]) == [40, 3]\nraise 'Test failed' unless find_max_with_index([5]) == [5, 0]\nraise 'Test failed' unless find_max_with_index([-3, -2, -1, -4]) == [-1, 2]\nraise 'Test failed' unless find_max_with_index([100, 200, 100, 50]) == [200, 1]\n  \nputs 'All tests passed!'",
    "entry_point": "find_max_with_index",
    "signature": "def find_max_with_index(arr)",
    "docstring": {
      "en": "Finds the maximum value in an array and returns its value along with its index.\nThe function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\nIt returns an array containing the maximum value and its index in the format [max_value, index].\n\nExample:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "sq": "Gjen vlerën maksimale në një varg dhe kthen vlerën e saj së bashku me indeksin e saj. Funksioni merr një argument të vetëm, arr, i cili është një varg me numra të plotë. Madhësia e vargut duhet të jetë midis 1 dhe 100. Ai kthen një varg që përmban vlerën maksimale dhe indeksin e saj në formatin [max_value, index].\n\nShembull:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hy": "Գտնում է զանգվածի առավելագույն արժեքը և վերադարձնում դրա արժեքը և ինդեքսը:\nՖունկցիան ընդունում է մեկ արգումենտ, arr, որը ամբողջ թվերի զանգված է: Զանգվածի չափը պետք է լինի 1-ից 100-ի միջև:\nԱյն վերադարձնում է զանգված, որը պարունակում է առավելագույն արժեքը և դրա ինդեքսը [max_value, index] ձևաչափով:\n\nՕրինակ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "bn": "একটি অ্যারেতে সর্বাধিক মান খুঁজে বের করে এবং এর মান এবং সূচক সহ ফেরত দেয়। ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, arr, যা পূর্ণসংখ্যার একটি অ্যারে। অ্যারের আকার 1 এবং 100 এর মধ্যে হওয়া উচিত। এটি একটি অ্যারে ফেরত দেয় যা সর্বাধিক মান এবং এর সূচক [max_value, index] বিন্যাসে ধারণ করে।\n\nউদাহরণ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "bg": "Намира максималната стойност в масив и връща нейната стойност заедно с индекса й. \nФункцията приема един аргумент, arr, който е масив от цели числа. Размерът на масива трябва да бъде между 1 и 100. \nВръща масив, съдържащ максималната стойност и нейния индекс във формат [max_value, index].\n\nПример:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "zh": "找到数组中的最大值，并返回其值及其索引。\n该函数接受一个参数，arr，它是一个整数数组。数组大小应在1到100之间。\n它返回一个数组，包含最大值及其索引，格式为[max_value, index]。\n\n示例：\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "fr": "Trouve la valeur maximale dans un tableau et renvoie sa valeur ainsi que son indice. La fonction prend un seul argument, arr, qui est un tableau d'entiers. La taille du tableau doit être comprise entre 1 et 100. Elle renvoie un tableau contenant la valeur maximale et son indice au format [max_value, index].\n\nExemple :\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "de": "Findet den maximalen Wert in einem Array und gibt diesen Wert zusammen mit seinem Index zurück. Die Funktion nimmt ein einziges Argument, arr, das ein Array von ganzen Zahlen ist. Die Arraygröße sollte zwischen 1 und 100 liegen. Sie gibt ein Array zurück, das den maximalen Wert und seinen Index im Format [max_value, index] enthält.\n\nBeispiel:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "ha": "Nemi mafi girman ƙima a cikin jerin kuma mayar da ƙimar tare da ma'aunin sa. \n\nAikin yana ɗaukar hujja guda, arr, wanda jerin lambobi ne. Girman jerin ya kamata ya kasance tsakanin 1 da 100. \n\nYana mayar da jerin da ke ɗauke da mafi girman ƙima da ma'aunin sa a cikin tsarin [max_value, index].\n\nMisali:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hi": "सरणी में अधिकतम मान खोजता है और इसके मान के साथ-साथ इसके सूचकांक को भी लौटाता है। \nयह फ़ंक्शन एकल तर्क, arr, लेता है, जो पूर्णांकों की एक सरणी है। सरणी का आकार 1 और 100 के बीच होना चाहिए। \nयह [max_value, index] प्रारूप में अधिकतम मान और उसके सूचकांक वाली एक सरणी लौटाता है।\n\nउदाहरण:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hu": "Megkeresi a maximális értéket egy tömbben, és visszaadja annak értékét a hozzá tartozó indexszel együtt.\nA függvény egyetlen argumentumot vesz fel, az arr-t, amely egy egész számokat tartalmazó tömb. A tömb méretének 1 és 100 között kell lennie.\nEgy tömböt ad vissza, amely a maximális értéket és annak indexét tartalmazza a következő formátumban: [max_value, index].\n\nPélda:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.989125185268721",
      "hy": "0.9756864495790435",
      "bn": "0.9906298104050602",
      "bg": "0.9858052770801038",
      "zh": "0.9655529234297866",
      "fr": "0.9792359744881369",
      "de": "0.9956436384831429",
      "ha": "0.9604844719969193",
      "hi": "0.9849249472313572",
      "hu": "0.9720376094794326"
    }
  },
  {
    "task_id": "Ruby/8",
    "prompt": {
      "en": "# Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\n# The character can move up one or two floors at a time, but cannot use the two-floor jump consecutively. \n# Moving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n#\n# Args:\n# - floor_heights (Array): An array of integers representing the height of each floor.\n#\n# Returns:\n# - Integer: The minimum time required to reach the top of the building.\n#\n# Example:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "sq": "# Llogarit kohën minimale të nevojshme që një karakter të arrijë majën e një ndërtese me lartësi të ndryshme katësh.\n# Karakteri mund të lëvizë një ose dy kate njëherësh, por nuk mund të përdorë kërcimin me dy kate radhazi.\n# Lëvizja një kat lart merr një njësi kohe, ndërsa kërcimi dy kate është i menjëhershëm.\n#\n# Argumentet:\n# - floor_heights (Array): Një varg me numra të plotë që përfaqëson lartësinë e secilit kat.\n#\n# Kthen:\n# - Integer: Koha minimale e nevojshme për të arritur majën e ndërtesës.\n#\n# Shembull:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "hy": "# Հաշվում է շենքի գագաթին հասնելու համար անհրաժեշտ նվազագույն ժամանակը, երբ հարկերի բարձրությունները տարբեր են:\n# Տարրը կարող է բարձրանալ մեկ կամ երկու հարկ միաժամանակ, բայց չի կարող օգտագործել երկու հարկի թռիչքը հաջորդաբար:\n# Մեկ հարկ բարձրանալը տևում է մեկ միավոր ժամանակ, մինչդեռ երկու հարկ թռիչքը ակնթարթային է:\n#\n# Պարամետրեր:\n# - floor_heights (Array): Թվերի զանգված, որը ներկայացնում է յուրաքանչյուր հարկի բարձրությունը:\n#\n# Վերադարձնում է:\n# - Integer: Շենքի գագաթին հասնելու համար անհրաժեշտ նվազագույն ժամանակը:\n#\n# Օրինակ:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "bn": "# একটি চরিত্রকে বিভিন্ন তলার উচ্চতার একটি ভবনের শীর্ষে পৌঁছানোর জন্য প্রয়োজনীয় ন্যূনতম সময় গণনা করে।\n# চরিত্রটি একবারে এক বা দুই তলা উপরে উঠতে পারে, তবে পরপর দুই তলা লাফ ব্যবহার করতে পারে না।\n# এক তলা উপরে উঠতে এক ইউনিট সময় লাগে, যখন দুই তলা লাফানো তাৎক্ষণিক হয়।\n#\n# আর্গুমেন্টসমূহ:\n# - floor_heights (Array): প্রতিটি তলার উচ্চতা উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে।\n#\n# রিটার্নস:\n# - পূর্ণসংখ্যা: ভবনের শীর্ষে পৌঁছানোর জন্য প্রয়োজনীয় ন্যূনতম সময়।\n#\n# উদাহরণ:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "bg": "# Изчислява минималното време, необходимо на един герой да достигне върха на сграда с различни височини на етажите.\n# Героят може да се движи нагоре с един или два етажа наведнъж, но не може да използва скок от два етажа последователно.\n# Движението нагоре с един етаж отнема една единица време, докато скокът нагоре с два етажа е мигновен.\n#\n# Аргументи:\n# - floor_heights (Масив): Масив от цели числа, представляващи височината на всеки етаж.\n#\n# Връща:\n# - Цяло число: Минималното време, необходимо за достигане на върха на сградата.\n#\n# Пример:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "zh": "# 计算角色到达具有不同楼层高度的建筑物顶部所需的最短时间。\n# 角色可以一次向上移动一层或两层，但不能连续使用两层跳跃。\n# 向上一层需要一个时间单位，而跳跃两层是瞬时的。\n#\n# 参数:\n# - floor_heights (Array): 一个整数数组，表示每层楼的高度。\n#\n# 返回:\n# - Integer: 到达建筑物顶部所需的最短时间。\n#\n# 示例:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "fr": "# Calcule le temps minimum requis pour qu'un personnage atteigne le sommet d'un bâtiment avec des hauteurs d'étage variables.\n# Le personnage peut monter d'un ou deux étages à la fois, mais ne peut pas utiliser le saut de deux étages consécutivement.\n# Monter d'un étage prend une unité de temps, tandis que sauter de deux étages est instantané.\n#\n# Arguments:\n# - floor_heights (Array): Un tableau d'entiers représentant la hauteur de chaque étage.\n#\n# Renvoie:\n# - Integer: Le temps minimum requis pour atteindre le sommet du bâtiment.\n#\n# Exemple:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "de": "# Berechnet die minimale Zeit, die ein Charakter benötigt, um die Spitze eines Gebäudes mit unterschiedlichen Stockwerkshöhen zu erreichen.\n# Der Charakter kann sich jeweils um ein oder zwei Stockwerke nach oben bewegen, darf jedoch nicht zweimal hintereinander den Zwei-Stockwerke-Sprung verwenden.\n# Das Bewegen um ein Stockwerk nach oben dauert eine Zeiteinheit, während der Sprung um zwei Stockwerke sofort erfolgt.\n#\n# Argumente:\n# - floor_heights (Array): Ein Array von ganzen Zahlen, das die Höhe jedes Stockwerks darstellt.\n#\n# Rückgabewerte:\n# - Integer: Die minimale Zeit, die benötigt wird, um die Spitze des Gebäudes zu erreichen.\n#\n# Beispiel:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "ha": "# Lissafi na mafi ƙarancin lokaci da ake buƙata don wata alama ta isa saman gini tare da tsayin bene daban-daban.\n# Alamar na iya motsawa sama bene ɗaya ko biyu a lokaci guda, amma ba za ta iya amfani da tsalle bene biyu a jere ba.\n# Motsawa sama bene ɗaya yana ɗaukar ɗaya na lokaci, yayin da tsalle sama bene biyu ba ya ɗaukar lokaci.\n#\n# Args:\n# - floor_heights (Array): Jerin lambobi masu wakiltar tsayin kowanne bene.\n#\n# Returns:\n# - Integer: Mafi ƙarancin lokaci da ake buƙata don isa saman ginin.\n#\n# Misali:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "hi": "# एक चरित्र को विभिन्न मंजिल ऊंचाइयों वाले एक भवन की चोटी पर पहुँचने के लिए आवश्यक न्यूनतम समय की गणना करता है।\n# चरित्र एक समय में एक या दो मंजिल ऊपर जा सकता है, लेकिन लगातार दो मंजिल की छलांग का उपयोग नहीं कर सकता।\n# एक मंजिल ऊपर जाने में एक इकाई समय लगता है, जबकि दो मंजिल ऊपर कूदना तात्कालिक होता है।\n#\n# आर्ग्स:\n# - floor_heights (Array): प्रत्येक मंजिल की ऊंचाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक श्रृंखला।\n#\n# रिटर्न करता है:\n# - पूर्णांक: भवन की चोटी पर पहुँचने के लिए आवश्यक न्यूनतम समय।\n#\n# उदाहरण:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "hu": "# Kiszámítja a minimális időt, amely szükséges ahhoz, hogy egy karakter elérje egy épület tetejét változó emeletmagasságokkal.\n# A karakter egyszerre egy vagy két emeletet léphet fel, de nem használhatja a két emelet ugrást egymás után.\n# Egy emelet felmászása egy időegységet vesz igénybe, míg két emelet ugrása azonnali.\n#\n# Argumentumok:\n# - floor_heights (Tömb): Egész számokat tartalmazó tömb, amely az egyes emeletek magasságát jelöli.\n#\n# Visszatér:\n# - Egész szám: A minimális idő, amely szükséges az épület tetejére jutáshoz.\n#\n# Példa:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)"
    },
    "prompt_bertscore": {
      "sq": "0.9818469708468406",
      "hy": "0.9464897698707253",
      "bn": "0.9760126006647027",
      "bg": "0.9742165847593853",
      "zh": "0.9689306330592848",
      "fr": "0.9735168099269994",
      "de": "0.9654766493634692",
      "ha": "0.9557433634319976",
      "hi": "0.9754878191980086",
      "hu": "0.971698150158244"
    },
    "canonical_solution": "    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end",
    "instruction": {
      "en": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nনিচের Ruby কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\n请为以下 Ruby 代码提供一个简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def minimum_time_to_top(heights)\n    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9202439431030613",
      "bn": "0.8737062352392543",
      "bg": "0.8394899671718035",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9531146889693819",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless minimum_time_to_top([3, 5, 1, 8, 4]) == 1\nraise 'Test failed' unless minimum_time_to_top([2, 2, 2, 2, 2]) == 2\nraise 'Test failed' unless minimum_time_to_top([1, 1, 1, 1, 1]) == 1\nraise 'Test failed' unless minimum_time_to_top([10]) == 0\n\n\n\nputs 'All tests passed!'",
    "entry_point": "minimum_time_to_top",
    "signature": "def minimum_time_to_top(heights)",
    "docstring": {
      "en": "Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\nThe character can move up one or two floors at a time, but cannot use the two-floor jump consecutively.\nMoving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n\nArgs:\n- floor_heights (Array): An array of integers representing the height of each floor.\n\nReturns:\n- Integer: The minimum time required to reach the top of the building.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "sq": "Llogarit kohën minimale të nevojshme që një personazh të arrijë në majë të një ndërtese me lartësi të ndryshme katësh. Personazhi mund të ngjitet një ose dy kate njëherësh, por nuk mund të përdorë kërcimin me dy kate radhazi. Ngjitja një kat merr një njësi kohe, ndërsa kërcimi me dy kate është i menjëhershëm.\n\nArgumentet:\n- floor_heights (Array): Një varg me numra të plotë që përfaqësojnë lartësinë e secilit kat.\n\nKthen:\n- Integer: Koha minimale e nevojshme për të arritur në majë të ndërtesës.\n\nShembull:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "hy": "Հաշվում է շենքի գագաթին հասնելու համար անհրաժեշտ նվազագույն ժամանակը, որտեղ հարկերի բարձրությունները տարբեր են:\nՏարրը կարող է շարժվել մեկ կամ երկու հարկ վերև միաժամանակ, բայց չի կարող երկու հարկի թռիչքը օգտագործել անընդմեջ:\nՄեկ հարկ վերև շարժվելը տևում է մեկ ժամանակային միավոր, իսկ երկու հարկ վեր թռիչքը ակնթարթային է:\n\nԱրձանագրություններ:\n- floor_heights (Array): Բազմություն, որը ներկայացնում է յուրաքանչյուր հարկի բարձրությունը ամբողջ թվերով:\n\nՎերադարձնում է:\n- Integer: Շենքի գագաթին հասնելու համար անհրաժեշտ նվազագույն ժամանակը:\n\nՕրինակ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "bn": "বিভিন্ন মেঝের উচ্চতার একটি ভবনের শীর্ষে পৌঁছানোর জন্য একটি চরিত্রের ন্যূনতম সময় গণনা করে। চরিত্রটি এক বা দুই মেঝে উপরে উঠতে পারে, তবে পরপর দুই মেঝে লাফ দিতে পারে না। এক মেঝে উপরে উঠতে এক ইউনিট সময় লাগে, যখন দুই মেঝে উপরে লাফ দেওয়া তাৎক্ষণিক হয়।\n\nআর্গুমেন্টস:\n- floor_heights (Array): প্রতিটি মেঝের উচ্চতা উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে।\n\nরিটার্নস:\n- পূর্ণসংখ্যা: ভবনের শীর্ষে পৌঁছানোর জন্য প্রয়োজনীয় ন্যূনতম সময়।\n\nউদাহরণ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "bg": "Изчислява минималното време, необходимо на един герой да достигне върха на сграда с различни височини на етажите. Героят може да се движи нагоре с един или два етажа наведнъж, но не може да използва скок от два етажа последователно. Движението нагоре с един етаж отнема една единица време, докато скокът нагоре с два етажа е мигновен.\n\nАргументи:\n- floor_heights (Array): Масив от цели числа, представляващи височината на всеки етаж.\n\nВръща:\n- Integer: Минималното време, необходимо за достигане на върха на сградата.\n\nПример:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "zh": "计算角色到达具有不同楼层高度的建筑物顶部所需的最短时间。\n角色可以每次向上移动一层或两层，但不能连续使用两层跳跃。\n向上移动一层需要一个时间单位，而跳跃两层是瞬时的。\n\n参数:\n- floor_heights (Array): 一个整数数组，表示每层楼的高度。\n\n返回:\n- Integer: 到达建筑物顶部所需的最短时间。\n\n示例:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "fr": "Calcule le temps minimum nécessaire pour qu'un personnage atteigne le sommet d'un bâtiment avec des hauteurs d'étage variables. Le personnage peut monter d'un ou deux étages à la fois, mais ne peut pas utiliser le saut de deux étages consécutivement. Monter d'un étage prend une unité de temps, tandis que sauter de deux étages est instantané.\n\nArgs:\n- floor_heights (Array): Un tableau d'entiers représentant la hauteur de chaque étage.\n\nReturns:\n- Integer: Le temps minimum nécessaire pour atteindre le sommet du bâtiment.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "de": "Berechnet die minimale Zeit, die erforderlich ist, damit ein Charakter die Spitze eines Gebäudes mit unterschiedlichen Stockwerkshöhen erreicht.\nDer Charakter kann sich um ein oder zwei Stockwerke nach oben bewegen, darf jedoch nicht den Zwei-Stockwerk-Sprung aufeinanderfolgend verwenden.\nDas Bewegen um ein Stockwerk nach oben dauert eine Zeiteinheit, während der Sprung um zwei Stockwerke sofort erfolgt.\n\nArgs:\n- floor_heights (Array): Ein Array von ganzen Zahlen, das die Höhe jedes Stockwerks darstellt.\n\nReturns:\n- Integer: Die minimale Zeit, die erforderlich ist, um die Spitze des Gebäudes zu erreichen.\n\nBeispiel:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "ha": "Lissafa mafi ƙarancin lokaci da ake buƙata don wata alama ta kai saman wani gini mai tsayin bene daban-daban.\nAlamar na iya motsawa sama bene ɗaya ko biyu a lokaci guda, amma ba za ta iya amfani da tsalle bene biyu a jere ba.\nMotsawa sama bene ɗaya yana ɗaukar ɗaya na lokaci, yayin da tsalle sama bene biyu ba ya ɗaukar lokaci.\n\nArgs:\n- floor_heights (Array): Jerin lambobi da ke wakiltar tsayin kowanne bene.\n\nReturns:\n- Integer: Mafi ƙarancin lokaci da ake buƙata don kai saman ginin.\n\nMisali:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "hi": "चरित्र को विभिन्न मंजिल ऊंचाइयों वाली इमारत के शीर्ष पर पहुंचने के लिए आवश्यक न्यूनतम समय की गणना करता है।\nचरित्र एक समय में एक या दो मंजिल ऊपर जा सकता है, लेकिन लगातार दो-मंजिल की छलांग का उपयोग नहीं कर सकता।\nएक मंजिल ऊपर जाने में एक समय इकाई लगती है, जबकि दो मंजिल ऊपर कूदना तात्कालिक होता है।  \n\nArgs:\n- floor_heights (Array): प्रत्येक मंजिल की ऊंचाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी।\n\nReturns:\n- Integer: इमारत के शीर्ष पर पहुंचने के लिए आवश्यक न्यूनतम समय।  \n\nExample:  \n>>> minimum_time_to_top([3, 5, 1, 8, 4])  \n1",
      "hu": "Kiszámítja a minimális időt, amely szükséges ahhoz, hogy egy karakter elérje egy épület tetejét különböző emeletmagasságokkal.\nA karakter egyszerre egy vagy két emeletet tud felmenni, de nem használhatja a két emeletes ugrást egymás után.\nEgy emelet felmenetele egy időegységet vesz igénybe, míg két emelet ugrása azonnali.\n\nArgs:\n- floor_heights (Array): Egész számokat tartalmazó tömb, amely az egyes emeletek magasságát reprezentálja.\n\nReturns:\n- Integer: A minimális idő, amely szükséges az épület tetejére való eljutáshoz.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1"
    },
    "docstring_bertscore": {
      "sq": "0.968356392627713",
      "hy": "0.9357311539123516",
      "bn": "1",
      "bg": "0.9739116871244967",
      "zh": "0.9588586823281487",
      "fr": "0.9774576366867316",
      "de": "0.982100025952279",
      "ha": "0.9630686532541832",
      "hi": "0.8639445451632947",
      "hu": "0.9732039670768694"
    }
  },
  {
    "task_id": "Ruby/9",
    "prompt": {
      "en": "# Transposes a given n x m matrix.\n# The function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\n# The matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\n# The function returns a new matrix which is the transpose of the input matrix.\n#\n# Example:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "sq": "# Transpozon një matricë të dhënë n x m.\n# Funksioni merr një argument të vetëm, matrix, i cili është një varg vargjesh që përfaqëson matricën n x m.\n# Matrica ka n rreshta dhe m kolona, ku 1 ≤ n ≤ 20 dhe 1 ≤ m ≤ 20. Çdo element në matricë është një numër i plotë.\n# Funksioni kthen një matricë të re e cila është transpozimi i matricës hyrëse.\n#\n# Shembull:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "hy": "# Տրված n x m մատրիցի տրանսպոզիցիա է կատարում։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ matrix, որը n x m մատրիցի ներկայացնող զանգվածների զանգված է։\n# Մատրիցը ունի n տող և m սյունակ, որտեղ 1 ≤ n ≤ 20 և 1 ≤ m ≤ 20։ Մատրիցի յուրաքանչյուր տարր ամբողջ թիվ է։\n# Ֆունկցիան վերադարձնում է նոր մատրից, որը մուտքային մատրիցի տրանսպոզիցիան է։\n#\n# Օրինակ:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "bn": "# একটি প্রদত্ত n x m ম্যাট্রিক্স ট্রান্সপোজ করে।\n# ফাংশনটি একটি মাত্র আর্গুমেন্ট গ্রহণ করে, matrix, যা n x m ম্যাট্রিক্সকে উপস্থাপনকারী অ্যারে অফ অ্যারে।\n# ম্যাট্রিক্সের n সারি এবং m কলাম রয়েছে, যেখানে 1 ≤ n ≤ 20 এবং 1 ≤ m ≤ 20। ম্যাট্রিক্সের প্রতিটি উপাদান একটি পূর্ণসংখ্যা।\n# ফাংশনটি একটি নতুন ম্যাট্রিক্স রিটার্ন করে যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ।\n#\n# উদাহরণ:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "bg": "# Транспонира дадена n x m матрица.\n# Функцията приема един аргумент, matrix, който е масив от масиви, представляващ n x m матрицата.\n# Матрицата има n реда и m колони, където 1 ≤ n ≤ 20 и 1 ≤ m ≤ 20. Всеки елемент в матрицата е цяло число.\n# Функцията връща нова матрица, която е транспонираната на входната матрица.\n#\n# Пример:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "zh": "# 转置给定的 n x m 矩阵。\n# 该函数接受一个参数 matrix，它是一个数组的数组，表示 n x m 矩阵。\n# 矩阵有 n 行和 m 列，其中 1 ≤ n ≤ 20 且 1 ≤ m ≤ 20。矩阵中的每个元素都是一个整数。\n# 该函数返回一个新的矩阵，该矩阵是输入矩阵的转置矩阵。\n#\n# 示例:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "fr": "# Transpose une matrice donnée de n x m.\n# La fonction prend un seul argument, matrix, qui est un tableau de tableaux représentant la matrice n x m.\n# La matrice a n lignes et m colonnes, où 1 ≤ n ≤ 20 et 1 ≤ m ≤ 20. Chaque élément de la matrice est un entier.\n# La fonction renvoie une nouvelle matrice qui est la transposée de la matrice d'entrée.\n#\n# Exemple:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "de": "# Transponiert eine gegebene n x m Matrix.\n# Die Funktion nimmt ein einzelnes Argument, matrix, das ein Array von Arrays darstellt, welches die n x m Matrix repräsentiert.\n# Die Matrix hat n Zeilen und m Spalten, wobei 1 ≤ n ≤ 20 und 1 ≤ m ≤ 20. Jedes Element in der Matrix ist ein Integer.\n# Die Funktion gibt eine neue Matrix zurück, die die Transponierte der Eingabematrix ist.\n#\n# Beispiel:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "ha": "# Canza wuri na matrix n x m da aka bayar.\n# Aikin yana ɗaukar hujja guda, matrix, wanda shine jeri na jerin da ke wakiltar matrix n x m.\n# Matrix yana da layuka n da ginshikai m, inda 1 ≤ n ≤ 20 da 1 ≤ m ≤ 20. Kowanne abu a cikin matrix lamba ce.\n# Aikin yana mayar da sabon matrix wanda shine canza wurin matrix na shigarwa.\n#\n# Misali:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "hi": "# दिए गए n x m मैट्रिक्स का ट्रांसपोज़ करता है।\n# फ़ंक्शन एकल आर्ग्युमेंट लेता है, matrix, जो n x m मैट्रिक्स का प्रतिनिधित्व करने वाले ऐरे का ऐरे है।\n# मैट्रिक्स में n पंक्तियाँ और m स्तंभ होते हैं, जहाँ 1 ≤ n ≤ 20 और 1 ≤ m ≤ 20। मैट्रिक्स में प्रत्येक तत्व एक पूर्णांक होता है।\n# फ़ंक्शन एक नया मैट्रिक्स लौटाता है जो इनपुट मैट्रिक्स का ट्रांसपोज़ है।\n#\n# उदाहरण:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "hu": "# Egy adott n x m mátrix transzponálása.\n# A függvény egyetlen argumentumot vesz fel, matrix, amely egy tömbök tömbje, ami az n x m mátrixot reprezentálja.\n# A mátrix n sorból és m oszlopból áll, ahol 1 ≤ n ≤ 20 és 1 ≤ m ≤ 20. A mátrix minden eleme egy egész szám.\n# A függvény egy új mátrixot ad vissza, amely a bemeneti mátrix transzponáltja.\n#\n# Példa:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)"
    },
    "prompt_bertscore": {
      "sq": "0.9987381011892854",
      "hy": "0.9705663542471071",
      "bn": "0.9978176480035696",
      "bg": "0.995325631243106",
      "zh": "0.9794093788107804",
      "fr": "0.9967335233838812",
      "de": "0.9989200466183134",
      "ha": "0.9845958166899823",
      "hi": "0.996937318154823",
      "hu": "0.9923400179857705"
    },
    "canonical_solution": "    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end",
    "instruction": {
      "en": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nনিচের Ruby কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def transpose_matrix(matrix)\n    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8888019455675248",
      "bn": "0.8673498644157568",
      "bg": "0.8991035130191372",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.8973126615037266",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]]) == [[34, -4], [76, 5], [-54, 23], [7, 9]]\nraise 'Test failed' unless transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]]\nraise 'Test failed' unless transpose_matrix([[10]]) == [[10]]\nraise 'Test failed' unless transpose_matrix([]) == []\nraise 'Test failed' unless transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]]\n\n\nputs 'All tests passed!'",
    "entry_point": "transpose_matrix",
    "signature": "def transpose_matrix(matrix)",
    "docstring": {
      "en": "Transposes a given n x m matrix.\nThe function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\nThe matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\nThe function returns a new matrix which is the transpose of the input matrix.\n\nExample:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "sq": "Transpozon një matricë të dhënë n x m.  \nFunksioni merr një argument të vetëm, matrix, i cili është një varg vargjesh që përfaqëson matricën n x m.  \nMatrica ka n rreshta dhe m kolona, ku 1 ≤ n ≤ 20 dhe 1 ≤ m ≤ 20. Çdo element në matricë është një numër i plotë.  \nFunksioni kthen një matricë të re e cila është transpozimi i matricës hyrëse.  \n\nShembull:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hy": "Տրված n x m մատրիցի տրանսպոզիցիա է կատարում:\nՖունկցիան ընդունում է մեկ արգումենտ՝ matrix, որը ներկայացնում է n x m մատրիցը՝ զանգվածների զանգված:\nՄատրիցն ունի n տող և m սյունակ, որտեղ 1 ≤ n ≤ 20 և 1 ≤ m ≤ 20: Մատրիցի յուրաքանչյուր տարր ամբողջ թիվ է:\nՖունկցիան վերադարձնում է նոր մատրից, որը մուտքային մատրիցի տրանսպոզիցիան է:\n\nՕրինակ:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "bn": "একটি প্রদত্ত n x m ম্যাট্রিক্স ট্রান্সপোজ করে। \nফাংশনটি একটি মাত্র আর্গুমেন্ট গ্রহণ করে, matrix, যা n x m ম্যাট্রিক্সের প্রতিনিধিত্বকারী অ্যারে অফ অ্যারে। \nম্যাট্রিক্সের n টি সারি এবং m টি কলাম রয়েছে, যেখানে 1 ≤ n ≤ 20 এবং 1 ≤ m ≤ 20। ম্যাট্রিক্সের প্রতিটি উপাদান একটি পূর্ণসংখ্যা। \nফাংশনটি একটি নতুন ম্যাট্রিক্স প্রদান করে যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ।\n\nউদাহরণ:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "bg": "Транспонира дадена n x m матрица.  \nФункцията приема един аргумент, matrix, който е масив от масиви, представляващи n x m матрицата.  \nМатрицата има n реда и m колони, където 1 ≤ n ≤ 20 и 1 ≤ m ≤ 20. Всеки елемент в матрицата е цяло число.  \nФункцията връща нова матрица, която е транспонирана версия на входната матрица.  \n\nПример:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "zh": "转置给定的 n x m 矩阵。  \n该函数接受一个参数 matrix，它是一个表示 n x m 矩阵的数组的数组。  \n矩阵有 n 行和 m 列，其中 1 ≤ n ≤ 20 且 1 ≤ m ≤ 20。矩阵中的每个元素都是一个整数。  \n该函数返回一个新矩阵，该矩阵是输入矩阵的转置矩阵。\n\n示例：\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "fr": "Transpose une matrice n x m donnée.  \nLa fonction prend un seul argument, matrix, qui est un tableau de tableaux représentant la matrice n x m.  \nLa matrice a n lignes et m colonnes, où 1 ≤ n ≤ 20 et 1 ≤ m ≤ 20. Chaque élément de la matrice est un entier.  \nLa fonction renvoie une nouvelle matrice qui est la transposée de la matrice d'entrée.  \n\nExemple:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "de": "Transponiert eine gegebene n x m Matrix.  \nDie Funktion nimmt ein einzelnes Argument, matrix, das ein Array von Arrays darstellt, welches die n x m Matrix repräsentiert.  \nDie Matrix hat n Zeilen und m Spalten, wobei 1 ≤ n ≤ 20 und 1 ≤ m ≤ 20. Jedes Element in der Matrix ist ein Integer.  \nDie Funktion gibt eine neue Matrix zurück, die die Transponierte der Eingabematrix ist.\n\nBeispiel:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "ha": "Ya juya matrix n x m da aka bayar.\nAikin yana ɗaukar hujja guda, matrix, wanda shine jeri na jerin da ke wakiltar matrix n x m.\nMatrix yana da layuka n da ginshikai m, inda 1 ≤ n ≤ 20 da 1 ≤ m ≤ 20. Kowanne abu a cikin matrix ɗin lamba ce.\nAikin yana dawowa da sabon matrix wanda shine juyawar matrix ɗin da aka shigar.\n\nMisali:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hi": "दिए गए n x m मैट्रिक्स का ट्रांसपोज़ करता है।  \nयह फ़ंक्शन एकल तर्क, मैट्रिक्स, लेता है, जो n x m मैट्रिक्स का प्रतिनिधित्व करने वाली एरेज़ की एक एरे है।  \nमैट्रिक्स में n पंक्तियाँ और m स्तंभ होते हैं, जहाँ 1 ≤ n ≤ 20 और 1 ≤ m ≤ 20। मैट्रिक्स का प्रत्येक तत्व एक पूर्णांक है।  \nयह फ़ंक्शन एक नया मैट्रिक्स लौटाता है जो इनपुट मैट्रिक्स का ट्रांसपोज़ है।\n\nउदाहरण:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hu": "Transzponál egy adott n x m mátrixot.  \nA függvény egyetlen argumentumot vesz fel, a mátrixot, amely tömbök tömbjeként ábrázolja az n x m mátrixot.  \nA mátrix n sorral és m oszloppal rendelkezik, ahol 1 ≤ n ≤ 20 és 1 ≤ m ≤ 20. A mátrix minden eleme egész szám.  \nA függvény visszaad egy új mátrixot, amely a bemeneti mátrix transzponáltja.\n\nPélda:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]"
    },
    "docstring_bertscore": {
      "sq": "0.9980633537849098",
      "hy": "0.96033490332",
      "bn": "0.9876724026618318",
      "bg": "0.9869422373811475",
      "zh": "0.9831289313260397",
      "fr": "0.9956198028374187",
      "de": "0.9986586490368714",
      "ha": "0.9570569061417813",
      "hi": "0.9815371074524261",
      "hu": "0.9848262279319828"
    }
  },
  {
    "task_id": "Ruby/10",
    "prompt": {
      "en": "# Sorts a list of students by their scores in descending order. If two students have the same score,\n# they are sorted alphabetically by their names. The function takes an array of arrays as an argument,\n# where each sub-array contains a student's name and their score. The function returns an array of \n# student names sorted as per the mentioned criteria.\n#\n# Example:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "sq": "# Rendit një listë studentësh sipas pikëve të tyre në rend zbritës. Nëse dy studentë kanë të njëjtën pikë,\n# ata renditen alfabetikisht sipas emrave të tyre. Funksioni merr një varg arraysh si argument,\n# ku çdo nën-array përmban emrin e studentit dhe pikën e tij. Funksioni kthen një varg me \n# emrat e studentëve të renditur sipas kritereve të përmendura.\n#\n# Shembull:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "hy": "# Դասավորում է ուսանողների ցուցակը իրենց գնահատականներով նվազման կարգով: Եթե երկու ուսանող ունեն նույն գնահատականը,\n# նրանք դասավորվում են այբբենական կարգով իրենց անուններով: Ֆունկցիան ընդունում է զանգվածների զանգված որպես արգումենտ,\n# որտեղ յուրաքանչյուր ենթազանգված պարունակում է ուսանողի անունը և նրա գնահատականը: Ֆունկցիան վերադարձնում է ուսանողների \n# անունների զանգված, դասավորված ըստ նշված չափանիշների:\n#\n# Օրինակ:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "bn": "# শিক্ষার্থীদের একটি তালিকা তাদের স্কোর অনুযায়ী অবতরণী ক্রমে সাজায়। যদি দুই শিক্ষার্থীর স্কোর একই হয়,\n# তবে তাদের নামের বর্ণানুক্রমিক ক্রমে সাজানো হয়। ফাংশনটি একটি অ্যারে অফ অ্যারে গ্রহণ করে,\n# যেখানে প্রতিটি উপ-অ্যারে একটি শিক্ষার্থীর নাম এবং তাদের স্কোর থাকে। ফাংশনটি উল্লিখিত মানদণ্ড অনুযায়ী\n# সাজানো শিক্ষার্থীদের নামের একটি অ্যারে ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "bg": "# Сортира списък от студенти по техните оценки в низходящ ред. Ако двама студенти имат еднаква оценка,\n# те се сортират по азбучен ред по имената си. Функцията приема масив от масиви като аргумент,\n# където всеки подмасив съдържа името на студент и неговата оценка. Функцията връща масив от\n# имена на студенти, сортирани според споменатите критерии.\n#\n# Пример:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "zh": "# 按学生的分数以降序排序。如果两个学生的分数相同，\n# 则按他们的名字按字母顺序排序。该函数接受一个数组的数组作为参数，\n# 每个子数组包含一个学生的名字和他们的分数。该函数返回一个\n# 按上述标准排序的学生名字数组。\n#\n# 示例:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "fr": "# Trie une liste d'étudiants par leurs scores par ordre décroissant. Si deux étudiants ont le même score,\n# ils sont triés par ordre alphabétique de leurs noms. La fonction prend un tableau de tableaux comme argument,\n# où chaque sous-tableau contient le nom d'un étudiant et son score. La fonction renvoie un tableau de\n# noms d'étudiants triés selon les critères mentionnés.\n#\n# Exemple:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "de": "# Sortiert eine Liste von Studenten nach ihren Punktzahlen in absteigender Reihenfolge. Wenn zwei Studenten die gleiche Punktzahl haben,\n# werden sie alphabetisch nach ihren Namen sortiert. Die Funktion nimmt ein Array von Arrays als Argument,\n# wobei jedes Unter-Array den Namen eines Studenten und seine Punktzahl enthält. Die Funktion gibt ein Array von\n# Studentennamen zurück, sortiert nach den genannten Kriterien.\n#\n# Beispiel:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "ha": "# Yana tsara jerin ɗalibai ta maki nasu daga manya zuwa ƙanana. Idan ɗalibai biyu suna da maki iri ɗaya,\n# za a tsara su bisa haruffa ta sunayensu. Aikin yana karɓar jerin jerin azaman hujja,\n# inda kowace ƙaramin jeri ke ɗauke da sunan ɗalibi da maki nasu. Aikin yana mayar da jerin\n# sunayen ɗalibai da aka tsara bisa ga ka'idodin da aka ambata.\n#\n# Misali:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "hi": "# छात्रों की सूची को उनके अंकों के अनुसार घटते क्रम में क्रमबद्ध करता है। यदि दो छात्रों के अंक समान हैं,\n# तो उन्हें उनके नामों के अनुसार वर्णानुक्रम में क्रमबद्ध किया जाता है। यह फ़ंक्शन एक सरणी का तर्क के रूप में लेता है,\n# जहाँ प्रत्येक उप-सरणी में एक छात्र का नाम और उनके अंक होते हैं। यह फ़ंक्शन छात्र नामों की एक सरणी लौटाता है \n# जो उल्लिखित मानदंडों के अनुसार क्रमबद्ध होती है।\n#\n# उदाहरण:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "hu": "# Egy listát rendez a diákok pontszámai alapján csökkenő sorrendben. Ha két diáknak azonos a pontszáma,\n# akkor ábécé sorrendben rendezi őket a nevük alapján. A függvény egy tömbök tömbjét veszi argumentumként,\n# ahol minden al-tömb tartalmazza a diák nevét és a pontszámát. A függvény visszaad egy tömböt a diáknevekkel,\n# rendezve a megadott kritériumok szerint.\n#\n# Példa:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)"
    },
    "prompt_bertscore": {
      "sq": "0.9849597075480383",
      "hy": "0.9877546356395802",
      "bn": "0.9840464050560398",
      "bg": "0.9957286522862258",
      "zh": "0.9724056715754902",
      "fr": "0.9978855795938836",
      "de": "0.9978855795938836",
      "ha": "0.9730097065642174",
      "hi": "0.988340595263633",
      "hu": "0.981030004089644"
    },
    "canonical_solution": "    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end",
    "instruction": {
      "en": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nՏվեք կարճ բնութագրություն (docstring) այս Ruby կոդի մասին հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nনিচের রুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\n请为以下 Ruby 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def sort_students_by_score(student_scores)\n    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8903929749196142",
      "bn": "0.8673498644157568",
      "bg": "0.8991035130191372",
      "zh": "0.8953416522327174",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9319514163916387",
      "hi": "0.9119288780921788",
      "hu": "0.9311801346220803"
    },
    "level": "",
    "test": "raise 'Test failed' unless sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]]) == [\"bbb\", \"ccc\", \"aaa\"]\nraise 'Test failed' unless sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]]) == [\"charlie\", \"alice\", \"bob\"]\nraise 'Test failed' unless sort_students_by_score([[\"zoe\", 95], [\"adam\", 95], [\"mia\", 88]]) == [\"adam\", \"zoe\", \"mia\"]\nraise 'Test failed' unless sort_students_by_score([[\"lara\", 70], [\"max\", 70], [\"sam\", 70]]) == [\"lara\", \"max\", \"sam\"]\nraise 'Test failed' unless sort_students_by_score([[\"john\", 100]]) == [\"john\"]\n\n\nputs 'All tests passed!'",
    "entry_point": "sort_students_by_score",
    "signature": "def sort_students_by_score(student_scores)",
    "docstring": {
      "en": "Sorts a list of students by their scores in descending order. If two students have the same score,\nthey are sorted alphabetically by their names. The function takes an array of arrays as an argument,\nwhere each sub-array contains a student's name and their score. The function returns an array of\nstudent names sorted as per the mentioned criteria.\n\nExample:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "sq": "Rendit një listë studentësh sipas pikëve të tyre në rend zbritës. Nëse dy studentë kanë të njëjtën pikë, ata renditen alfabetikisht sipas emrave të tyre. Funksioni merr një varg arrays si argument, ku çdo nën-array përmban emrin e një studenti dhe pikën e tij. Funksioni kthen një varg emrash studentësh të renditur sipas kritereve të përmendura.\n\nShembull:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hy": "Դասավորում է ուսանողների ցուցակը ըստ նրանց գնահատականների նվազման կարգով։ Եթե երկու ուսանող ունեն նույն գնահատականը, ապա նրանք դասավորվում են այբբենական կարգով իրենց անուններով։ Ֆունկցիան ընդունում է զանգվածների զանգված որպես արգումենտ, որտեղ յուրաքանչյուր ենթազանգված պարունակում է ուսանողի անունը և նրա գնահատականը։ Ֆունկցիան վերադարձնում է ուսանողների անունների զանգվածը, դասավորված ըստ նշված չափանիշների։\n\nՕրինակ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "bn": "ছাত্রদের একটি তালিকা তাদের স্কোর অনুযায়ী অবনমিত ক্রমে সাজায়। যদি দুই ছাত্রের একই স্কোর থাকে, তাহলে তাদের নামের বর্ণানুক্রম অনুযায়ী সাজানো হয়। ফাংশনটি একটি অ্যারে অফ অ্যারে আর্গুমেন্ট হিসাবে নেয়, যেখানে প্রতিটি সাব-অ্যারে একটি ছাত্রের নাম এবং তাদের স্কোর থাকে। ফাংশনটি ছাত্রদের নামের একটি অ্যারে ফেরত দেয় যা উল্লেখিত মানদণ্ড অনুযায়ী সাজানো হয়।\n\nউদাহরণ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "bg": "Сортира списък от студенти по техните оценки в низходящ ред. Ако двама студенти имат еднаква оценка, те се сортират по азбучен ред на имената им. Функцията приема масив от масиви като аргумент, където всеки подмасив съдържа името на студент и неговата оценка. Функцията връща масив от имена на студенти, сортирани според споменатите критерии.\n\nПример:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "zh": "对学生列表按分数进行降序排序。如果两个学生的分数相同，则按他们的名字按字母顺序排序。该函数接受一个数组的数组作为参数，其中每个子数组包含一个学生的名字和他们的分数。该函数返回一个按上述标准排序的学生名字数组。\n\n示例：\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "fr": "Trie une liste d'étudiants par leurs scores dans l'ordre décroissant. Si deux étudiants ont le même score, ils sont triés par ordre alphabétique de leurs noms. La fonction prend un tableau de tableaux comme argument, où chaque sous-tableau contient le nom d'un étudiant et son score. La fonction renvoie un tableau de noms d'étudiants triés selon les critères mentionnés.\n\nExemple :\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "de": "Sortiert eine Liste von Studenten nach ihren Punktzahlen in absteigender Reihenfolge. Wenn zwei Studenten die gleiche Punktzahl haben, werden sie alphabetisch nach ihren Namen sortiert. Die Funktion nimmt ein Array von Arrays als Argument, wobei jedes Unter-Array den Namen eines Studenten und seine Punktzahl enthält. Die Funktion gibt ein Array von Studentennamen zurück, das nach den genannten Kriterien sortiert ist.\n\nBeispiel:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "ha": "Yana tsara jerin ɗalibai ta hanyar maki nasu a cikin tsari mai saukowa. Idan ɗalibai biyu suna da maki iri ɗaya, za a tsara su bisa haruffa ta sunayensu. Aikin yana ɗaukar jerin jerin a matsayin hujja, inda kowace ƙaramin jeri ke ɗauke da sunan ɗalibi da maki nasu. Aikin yana mayar da jerin sunayen ɗalibai da aka tsara bisa ga ka'idodin da aka ambata.\n\nMisali:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hi": "छात्रों की सूची को उनके अंकों के अनुसार अवरोही क्रम में क्रमबद्ध करता है। यदि दो छात्रों के अंक समान हैं, तो उन्हें उनके नामों के अनुसार वर्णानुक्रम में क्रमबद्ध किया जाता है। यह फ़ंक्शन एक तर्क के रूप में सरणियों की एक सरणी लेता है, जहाँ प्रत्येक उप-सरणी में एक छात्र का नाम और उनके अंक होते हैं। यह फ़ंक्शन छात्र नामों की एक सरणी लौटाता है जो उल्लिखित मानदंडों के अनुसार क्रमबद्ध होती है।\n\nउदाहरण:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hu": "Sorba rendezi a diákok listáját a pontszámaik alapján csökkenő sorrendben. Ha két diáknak azonos a pontszáma, akkor ábécé sorrendben vannak rendezve a nevük alapján. A függvény egy tömbök tömbjét veszi argumentumként, ahol minden al-tömb tartalmazza egy diák nevét és pontszámát. A függvény egy tömböt ad vissza a diákok neveivel, a megadott kritériumok szerint rendezve.\n\nPélda:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9905229472600634",
      "hy": "0.9894433911391388",
      "bn": "0.9882216156653932",
      "bg": "0.9950833021782434",
      "zh": "0.9672261857596245",
      "fr": "0.9905229472600634",
      "de": "0.9979658262678217",
      "ha": "0.978780515024424",
      "hi": "0.9895595899120442",
      "hu": "0.9848401320586553"
    }
  },
  {
    "task_id": "Ruby/11",
    "prompt": {
      "en": "# Calculates the total number of drinks a customer can enjoy under a promotional offer.\n# Under this offer, for every 3 bottle caps, the customer can get 1 additional drink.\n# The promotion continues as long as the customer has enough caps for exchange.\n#\n# The function takes a single integer argument, n, which represents the initial number\n# of drinks purchased. It returns an integer representing the total number of drinks\n# the customer can enjoy, including those received through the promotion.\n#\n# Examples:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "sq": "# Llogarit numrin total të pijeve që një klient mund të shijojë nën një ofertë promocionale.\n# Nën këtë ofertë, për çdo 3 tapa shishe, klienti mund të marrë 1 pije shtesë.\n# Promocioni vazhdon për sa kohë që klienti ka mjaft tapa për shkëmbim.\n#\n# Funksioni merr një argument të vetëm të tipit integer, n, i cili përfaqëson numrin fillestar\n# të pijeve të blera. Ai kthen një integer që përfaqëson numrin total të pijeve\n# që klienti mund të shijojë, duke përfshirë ato të marra përmes promocionit.\n#\n# Shembuj:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "hy": "# Հաշվում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել ակցիայի շրջանակներում:\n# Այս ակցիայի շրջանակներում, յուրաքանչյուր 3 շշի կափարիչի դիմաց, հաճախորդը կարող է ստանալ 1 լրացուցիչ խմիչք:\n# Ակցիան շարունակվում է, քանի դեռ հաճախորդը ունի բավարար կափարիչներ փոխանակման համար:\n#\n# Ֆունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ, n, որը ներկայացնում է սկզբնական գնված խմիչքների քանակը:\n# Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է խմիչքների ընդհանուր քանակը,\n# որը հաճախորդը կարող է վայելել, ներառյալ ակցիայի միջոցով ստացվածները:\n#\n# Օրինակներ:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "bn": "# একটি প্রচারমূলক অফারের অধীনে একজন গ্রাহক কতগুলি পানীয় উপভোগ করতে পারেন তা গণনা করে।\n# এই অফারের অধীনে, প্রতি ৩টি বোতলের ক্যাপের জন্য, গ্রাহক ১টি অতিরিক্ত পানীয় পেতে পারেন।\n# যতক্ষণ গ্রাহকের কাছে বিনিময়ের জন্য যথেষ্ট ক্যাপ থাকবে ততক্ষণ প্রচার চলতে থাকে।\n#\n# ফাংশনটি একটি একক পূর্ণসংখ্যা আর্গুমেন্ট, n, গ্রহণ করে, যা প্রাথমিকভাবে কেনা পানীয়ের সংখ্যা\n# উপস্থাপন করে। এটি একটি পূর্ণসংখ্যা ফেরত দেয় যা গ্রাহক কতগুলি পানীয় উপভোগ করতে পারেন তা\n# উপস্থাপন করে, প্রচারের মাধ্যমে প্রাপ্ত পানীয় সহ।\n#\n# উদাহরণ:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "bg": "# Изчислява общия брой напитки, които клиентът може да се наслади при промоционална оферта.\n# При тази оферта, за всеки 3 капачки от бутилки, клиентът може да получи 1 допълнителна напитка.\n# Промоцията продължава, докато клиентът има достатъчно капачки за размяна.\n#\n# Функцията приема един цялочислен аргумент n, който представлява първоначалния брой\n# закупени напитки. Тя връща цяло число, представляващо общия брой напитки,\n# които клиентът може да се наслади, включително тези, получени чрез промоцията.\n#\n# Примери:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "zh": "# 计算客户在促销优惠下可以享用的饮料总数。\n# 根据此优惠，每3个瓶盖，客户可以获得1瓶额外的饮料。\n# 促销活动会持续进行，只要客户有足够的瓶盖可以兑换。\n#\n# 该函数接受一个整数参数n，表示最初购买的饮料数量。\n# 它返回一个整数，表示客户可以享用的饮料总数，包括通过促销获得的饮料。\n#\n# 示例:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "fr": "# Calcule le nombre total de boissons qu'un client peut apprécier dans le cadre d'une offre promotionnelle.\n# Dans le cadre de cette offre, pour chaque 3 capsules, le client peut obtenir 1 boisson supplémentaire.\n# La promotion continue tant que le client a suffisamment de capsules pour l'échange.\n#\n# La fonction prend un seul argument entier, n, qui représente le nombre initial\n# de boissons achetées. Elle renvoie un entier représentant le nombre total de boissons\n# que le client peut apprécier, y compris celles reçues grâce à la promotion.\n#\n# Exemples :\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "de": "# Berechnet die Gesamtanzahl der Getränke, die ein Kunde im Rahmen eines Sonderangebots genießen kann.\n# Bei diesem Angebot kann der Kunde für je 3 Kronkorken 1 zusätzliches Getränk erhalten.\n# Die Aktion läuft weiter, solange der Kunde genügend Kronkorken zum Eintauschen hat.\n#\n# Die Funktion nimmt ein einzelnes ganzzahliges Argument, n, das die anfängliche Anzahl\n# der gekauften Getränke darstellt. Sie gibt eine ganze Zahl zurück, die die Gesamtanzahl\n# der Getränke darstellt, die der Kunde genießen kann, einschließlich derer, die durch die Aktion erhalten wurden.\n#\n# Beispiele:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "ha": "# Lissafa jimillar adadin abin sha da abokin ciniki zai iya morewa a ƙarƙashin tayin talla.\n# A ƙarƙashin wannan tayin, don kowace kwalba 3, abokin ciniki zai iya samun karin abin sha 1.\n# Tayin yana ci gaba muddin abokin ciniki yana da isassun kwalabe don musanya.\n#\n# Aikin yana ɗaukar hujja guda ɗaya, n, wanda ke wakiltar adadin farko\n# na abin sha da aka saya. Yana mayar da adadi wanda ke wakiltar jimillar adadin abin sha\n# da abokin ciniki zai iya morewa, ciki har da waɗanda aka samu ta hanyar tayin.\n#\n# Misalai:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "hi": "# एक प्रचारात्मक ऑफर के तहत ग्राहक कितने कुल पेय का आनंद ले सकता है, इसकी गणना करता है।\n# इस ऑफर के तहत, हर 3 बोतल कैप्स के लिए, ग्राहक को 1 अतिरिक्त पेय मिलता है।\n# प्रचार तब तक जारी रहता है जब तक ग्राहक के पास विनिमय के लिए पर्याप्त कैप्स हैं।\n#\n# यह फ़ंक्शन एक एकल पूर्णांक तर्क n लेता है, जो खरीदे गए प्रारंभिक पेय की संख्या का प्रतिनिधित्व करता है।\n# यह एक पूर्णांक लौटाता है जो उस कुल पेय की संख्या का प्रतिनिधित्व करता है जिसका ग्राहक आनंद ले सकता है, जिसमें प्रचार के माध्यम से प्राप्त पेय भी शामिल हैं।\n#\n# उदाहरण:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "hu": "# Kiszámítja a teljes italok számát, amit egy vásárló élvezhet egy promóciós ajánlat keretében.\n# Ezen ajánlat szerint minden 3 kupakért a vásárló 1 további italt kaphat.\n# A promóció addig tart, amíg a vásárlónak elegendő kupakja van a cseréhez.\n#\n# A függvény egyetlen egész szám argumentumot vesz fel, n, amely a kezdetben vásárolt italok számát jelenti.\n# Visszaad egy egész számot, amely a vásárló által élvezhető teljes italok számát jelenti, beleértve a promóció révén kapottakat is.\n#\n# Példák:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9969569825625455",
      "hy": "0.9763546421808449",
      "bn": "0.973896392585157",
      "bg": "0.9857474756392226",
      "zh": "0.9648817513722697",
      "fr": "0.9795015433075805",
      "de": "0.9730496312708053",
      "ha": "0.9690059139736971",
      "hi": "0.9759220252109508",
      "hu": "0.9758981895652267"
    },
    "canonical_solution": "    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end",
    "instruction": {
      "en": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nՏվեք Ruby կոդի հակիրճ բնական լեզվով նկարագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nনিচের Ruby কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nДайте кратко описание на Ruby кода на български език, използвайки максимум 500 знака.",
      "zh": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def total_drinks_with_promo(n)\n    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.962235796066504",
      "bn": "0.8737062352392543",
      "bg": "0.8424698201480888",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9171840420832189",
      "hi": "0.9119288780921788",
      "hu": "0.9311801346220803"
    },
    "level": "",
    "test": "raise 'Test failed' unless total_drinks_with_promo(100) == 149\nraise 'Test failed' unless total_drinks_with_promo(3) == 4\nraise 'Test failed' unless total_drinks_with_promo(9) == 13\nraise 'Test failed' unless total_drinks_with_promo(10) == 14\nraise 'Test failed' unless total_drinks_with_promo(1) == 1\n  \nputs 'All tests passed!'",
    "entry_point": "total_drinks_with_promo",
    "signature": "def total_drinks_with_promo(n)",
    "docstring": {
      "en": "Calculates the total number of drinks a customer can enjoy under a promotional offer.\nUnder this offer, for every 3 bottle caps, the customer can get 1 additional drink.\nThe promotion continues as long as the customer has enough caps for exchange.\n\nThe function takes a single integer argument, n, which represents the initial number\nof drinks purchased. It returns an integer representing the total number of drinks\nthe customer can enjoy, including those received through the promotion.\n\nExamples:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "sq": "Llogarit numrin total të pijeve që një klient mund të shijojë nën një ofertë promocionale.\nNën këtë ofertë, për çdo 3 tapa shishe, klienti mund të marrë 1 pije shtesë.  \nPromocioni vazhdon për sa kohë që klienti ka mjaft tapa për shkëmbim.\n\nFunksioni merr një argument të vetëm të tipit integer, n, që përfaqëson numrin fillestar  \ntë pijeve të blera. Ai kthen një integer që përfaqëson numrin total të pijeve  \nqë klienti mund të shijojë, duke përfshirë ato të marra përmes promocionit.\n\nShembuj:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "hy": "Հաշվում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել գովազդային առաջարկի շրջանակներում։ Այս առաջարկի համաձայն, յուրաքանչյուր 3 շշի կափարիչի դիմաց հաճախորդը կարող է ստանալ 1 լրացուցիչ խմիչք։ Գովազդը շարունակվում է այնքան ժամանակ, քանի դեռ հաճախորդը բավարար կափարիչներ ունի փոխանակման համար։\n\nՖունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ, n, որը ներկայացնում է սկզբնական գնված խմիչքների քանակը։ Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել, ներառյալ այն խմիչքները, որոնք ստացվել են գովազդի միջոցով։\n\nՕրինակներ:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "bn": "একটি প্রচারমূলক অফারের অধীনে একজন গ্রাহক মোট কতগুলি পানীয় উপভোগ করতে পারেন তা গণনা করে।\nএই প্রমোশনাল অফারের অধীনে, প্রতি ৩টি বোতলের ঢাকনার জন্য, গ্রাহক ১টি অতিরিক্ত পানীয় পেতে পারেন।  \nপ্রমোশনটি চলতে থাকে যতক্ষণ পর্যন্ত গ্রাহকের কাছে বিনিময়ের জন্য যথেষ্ট ঢাকনা থাকে।\n\nThe function takes a single integer argument, n, which represents the initial number  \nফাংশনটি একটি পূর্ণসংখ্যা আর্গুমেন্ট গ্রহণ করে, n, যা প্রাথমিকভাবে কেনা পানীয়ের সংখ্যা নির্দেশ করে।  \nof drinks purchased. It returns an integer representing the total number of drinks  \nএটি একটি পূর্ণসংখ্যা রিটার্ন করে যা গ্রাহক কতগুলি মোট পানীয় উপভোগ করতে পারবেন তা নির্দেশ করে,  \nthe customer can enjoy, including those received through the promotion.  \nপ্রমোশনের মাধ্যমে প্রাপ্ত পানীয় সহ।\n\nExamples:  \nউদাহরণসমূহ:\n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4  ",
      "bg": "Изчислява общия брой напитки, които клиентът може да се наслади по време на промоционална оферта. При тази оферта, за всеки 3 капачки от бутилки, клиентът може да получи 1 допълнителна напитка. Промоцията продължава, докато клиентът има достатъчно капачки за размяна.\n\nФункцията приема един аргумент от тип цяло число, n, който представлява първоначалния брой закупени напитки. Връща цяло число, представляващо общия брой напитки, които клиентът може да се наслади, включително тези, получени чрез промоцията.\n\nПримери:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "zh": "计算客户在促销优惠下可以享用的饮料总数。\n在此优惠下，每3个瓶盖，客户可以获得1瓶额外的饮料。\n只要客户有足够的瓶盖进行兑换，促销活动就会继续。  \n\n该函数接受一个整数参数n，表示最初购买的饮料数量。  \n它返回一个整数，表示客户可以享用的饮料总数，包括通过促销获得的饮料。  \n\n示例：  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4",
      "fr": "Calcule le nombre total de boissons qu'un client peut apprécier dans le cadre d'une offre promotionnelle.  \nDans le cadre de cette offre, pour chaque 3 capsules de bouteilles, le client peut obtenir 1 boisson supplémentaire.  \nLa promotion continue tant que le client a suffisamment de capsules pour un échange.\n\nLa fonction prend un seul argument entier, n, qui représente le nombre initial  \nde boissons achetées. Elle renvoie un entier représentant le nombre total de boissons  \nque le client peut apprécier, y compris celles reçues grâce à la promotion.\n\nExemples :\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "de": "Berechnet die Gesamtanzahl der Getränke, die ein Kunde im Rahmen eines Sonderangebots genießen kann.\nUnter diesem Angebot kann der Kunde für je 3 Flaschendeckel 1 zusätzliches Getränk erhalten.\nDie Aktion läuft weiter, solange der Kunde genügend Deckel für den Umtausch hat.\n\nDie Funktion nimmt ein einzelnes ganzzahliges Argument, n, das die anfängliche Anzahl der gekauften Getränke darstellt. Sie gibt eine ganze Zahl zurück, die die Gesamtanzahl der Getränke darstellt, die der Kunde genießen kann, einschließlich der durch die Aktion erhaltenen.\n\nBeispiele:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "ha": "Yana lissafin jimillar adadin abin sha da abokin ciniki zai iya morewa karkashin tayin talla.\nKarkashin wannan tayin, don kowanne kwalba uku na murfi, abokin ciniki zai iya samun karin abin sha guda daya.  \nTallan yana ci gaba muddin abokin ciniki yana da isassun murfi don musanya.  \n\nAikin yana daukar hujja guda daya mai lamba, n, wanda ke wakiltar adadin farko  \nna abin sha da aka saya. Yana mayar da lamba mai lamba wadda ke wakiltar jimillar adadin abin sha  \nda abokin ciniki zai iya morewa, ciki har da wadanda aka samu ta hanyar talla.  \n\nMisalai:  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4",
      "hi": "एक प्रचारक प्रस्ताव के तहत एक ग्राहक कितने कुल पेय का आनंद ले सकता है, इसकी गणना करता है।\nइस प्रमोशनल ऑफर के तहत, हर 3 बोतल कैप्स के लिए, ग्राहक को 1 अतिरिक्त ड्रिंक मिल सकती है।  \nप्रमोशन तब तक जारी रहता है जब तक ग्राहक के पास एक्सचेंज के लिए पर्याप्त कैप्स होते हैं।\n\nArgs:  \n    n: यह एकल पूर्णांक तर्क है, जो खरीदी गई प्रारंभिक ड्रिंक्स की संख्या को दर्शाता है।  \n\nReturns:  \n    यह एक पूर्णांक लौटाता है जो ग्राहक द्वारा आनंदित की जा सकने वाली कुल ड्रिंक्स की संख्या को दर्शाता है, जिसमें प्रमोशन के माध्यम से प्राप्त ड्रिंक्स भी शामिल हैं।  \n\nExamples:  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4  ",
      "hu": "Számítja ki az összes ital számát, amit egy vásárló élvezhet egy promóciós ajánlat keretében. \nEzen ajánlat szerint minden 3 kupakért a vásárló 1 további italt kaphat. \nA promóció addig folytatódik, amíg a vásárlónak elegendő kupakja van a cseréhez.\n\nA függvény egyetlen egész szám argumentumot vesz fel, n, amely az eredetileg vásárolt italok számát jelenti. \nEgész számot ad vissza, amely az összes italt jelenti, amit a vásárló élvezhet, beleértve a promóció révén kapottakat is.\n\nPéldák:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.995154809115416",
      "hy": "0.9882464444630226",
      "bn": "0.9196977095552155",
      "bg": "0.977050245775229",
      "zh": "0.969289756788196",
      "fr": "0.9837697129352583",
      "de": "0.983614781238051",
      "ha": "0.9799558109890074",
      "hi": "0.933797884413739",
      "hu": "0.9680753306385487"
    }
  },
  {
    "task_id": "Ruby/12",
    "prompt": {
      "en": "# Determines the maximum length of a string that can be accepted by a simplified regular expression.\n# The function takes a single argument, regex, which is a string representing a regular expression \n# composed only of 'x', '(', ')', and '|'. The function returns the length of the longest string \n# that can be accepted by this regular expression.\n#\n# Example:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "sq": "# Përcakton gjatësinë maksimale të një vargu që mund të pranohet nga një shprehje e rregullt e thjeshtuar.\n# Funksioni merr një argument të vetëm, regex, i cili është një varg që përfaqëson një shprehje të rregullt\n# e përbërë vetëm nga 'x', '(', ')', dhe '|'. Funksioni kthen gjatësinë e vargut më të gjatë\n# që mund të pranohet nga kjo shprehje e rregullt.\n#\n# Shembull:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "hy": "# Սահմանում է տողի առավելագույն երկարությունը, որը կարող է ընդունվել պարզեցված կանոնավոր արտահայտությամբ։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ regex, որը տող է, ներկայացնող կանոնավոր արտահայտություն,\n# որը կազմված է միայն 'x', '(', ')', և '|' նշաններից։ Ֆունկցիան վերադարձնում է ամենաերկար տողի երկարությունը,\n# որը կարող է ընդունվել այս կանոնավոր արտահայտությամբ։\n#\n# Օրինակ:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "bn": "# একটি সরলীকৃত নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে এমন স্ট্রিংয়ের সর্বাধিক দৈর্ঘ্য নির্ধারণ করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, regex, যা একটি স্ট্রিং যা একটি নিয়মিত অভিব্যক্তি উপস্থাপন করে \n# যা শুধুমাত্র 'x', '(', ')', এবং '|' নিয়ে গঠিত। ফাংশনটি সেই দীর্ঘতম স্ট্রিংয়ের দৈর্ঘ্য ফেরত দেয় \n# যা এই নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে।\n#\n# উদাহরণ:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "bg": "# Определя максималната дължина на низ, който може да бъде приет от опростено регулярни изрази.\n# Функцията приема един аргумент, regex, който е низ, представляващ регулярни изрази, \n# съставени само от 'x', '(', ')', и '|'. Функцията връща дължината на най-дългия низ, \n# който може да бъде приет от този регулярни израз.\n#\n# Пример:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "zh": "# 确定可以被简化正则表达式接受的字符串的最大长度。\n# 该函数接受一个参数，regex，这是一个仅由 'x'、'('、')' 和 '|' 组成的字符串，表示正则表达式。\n# 函数返回可以被此正则表达式接受的最长字符串的长度。\n#\n# 示例：\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "fr": "# Détermine la longueur maximale d'une chaîne qui peut être acceptée par une expression régulière simplifiée.\n# La fonction prend un seul argument, regex, qui est une chaîne représentant une expression régulière\n# composée uniquement de 'x', '(', ')', et '|'. La fonction renvoie la longueur de la plus longue chaîne\n# qui peut être acceptée par cette expression régulière.\n#\n# Exemple :\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "de": "# Bestimmt die maximale Länge eines Strings, der von einem vereinfachten regulären Ausdruck akzeptiert werden kann.\n# Die Funktion nimmt ein einzelnes Argument, regex, das einen regulären Ausdruck darstellt, \n# der nur aus 'x', '(', ')', und '|' besteht. Die Funktion gibt die Länge des längsten Strings zurück, \n# der von diesem regulären Ausdruck akzeptiert werden kann.\n#\n# Beispiel:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "ha": "# Yana tantance tsawon mafi girman kirtani da za a iya karɓa ta hanyar sauƙaƙƙen magana mai tsari.\n# Aikin yana ɗaukar hujja guda ɗaya, regex, wanda kirtani ne da ke wakiltar magana mai tsari\n# wanda aka haɗa kawai da 'x', '(', ')', da '|'. Aikin yana mayar da tsawon mafi girman kirtani\n# da za a iya karɓa ta wannan magana mai tsari.\n#\n# Misali:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "hi": "# एक सरलीकृत नियमित अभिव्यक्ति द्वारा स्वीकार की जा सकने वाली स्ट्रिंग की अधिकतम लंबाई निर्धारित करता है।\n# यह फ़ंक्शन एक एकल तर्क लेता है, regex, जो एक स्ट्रिंग है जो एक नियमित अभिव्यक्ति का प्रतिनिधित्व करता है \n# जो केवल 'x', '(', ')', और '|' से बनी होती है। यह फ़ंक्शन उस सबसे लंबी स्ट्रिंग की लंबाई लौटाता है \n# जिसे यह नियमित अभिव्यक्ति स्वीकार कर सकती है।\n#\n# उदाहरण:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "hu": "# Meghatározza egy egyszerűsített reguláris kifejezés által elfogadható maximális hosszúságú karakterláncot.\n# A függvény egyetlen argumentumot vesz fel, regex, amely egy reguláris kifejezést reprezentáló karakterlánc,\n# amely csak 'x', '(', ')' és '|' karakterekből áll. A függvény visszaadja a leghosszabb karakterlánc hosszát,\n# amelyet ez a reguláris kifejezés elfogadhat.\n#\n# Példa:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9832588355952365",
      "bn": "0.998542450263966",
      "bg": "0.9847640566227189",
      "zh": "0.9676248369343615",
      "fr": "1",
      "de": "0.9857768729356158",
      "ha": "0.9892318497833367",
      "hi": "0.9863705791445291",
      "hu": "0.9788240150778705"
    },
    "canonical_solution": "    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end",
    "instruction": {
      "en": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nՏվյալ Ruby կոդի համար տրամադրեք հակիրճ բնութագիր (docstring) հայերեն լեզվով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nনিচের রুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\n请为以下 Ruby 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def max_regex_string_length(regex)\n    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8853185645753159",
      "bn": "0.8737062352392543",
      "bg": "0.8364486908745768",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9353344890414249",
      "hi": "0.9119288780921788",
      "hu": "0.9410598111443745"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\") == 6\nraise 'Test failed' unless max_regex_string_length(\"x(xx|x)x\") == 4\nraise 'Test failed' unless max_regex_string_length(\"xx|x\") == 2\nraise 'Test failed' unless max_regex_string_length(\"(xx|x)(x|xx)\") == 4\nraise 'Test failed' unless max_regex_string_length(\"x\") == 1\n  \n\nputs 'All tests passed!'",
    "entry_point": "max_regex_string_length",
    "signature": "def max_regex_string_length(regex)",
    "docstring": {
      "en": "Determines the maximum length of a string that can be accepted by a simplified regular expression.\nThe function takes a single argument, regex, which is a string representing a regular expression\ncomposed only of 'x', '(', ')', and '|'. The function returns the length of the longest string\nthat can be accepted by this regular expression.\n\nExample:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "sq": "Përcakton gjatësinë maksimale të një vargu që mund të pranohet nga një shprehje e rregullt e thjeshtuar. Funksioni merr një argument të vetëm, regex, i cili është një varg që përfaqëson një shprehje të rregullt të përbërë vetëm nga 'x', '(', ')', dhe '|'. Funksioni kthen gjatësinë e vargut më të gjatë që mund të pranohet nga kjo shprehje e rregullt.\n\nShembull:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hy": "Սահմանում է տողի առավելագույն երկարությունը, որը կարող է ընդունվել պարզեցված կանոնավոր արտահայտությամբ։ Ֆունկցիան ընդունում է մեկ արգումենտ՝ regex, որը տող է, ներկայացնող կանոնավոր արտահայտություն, կազմված միայն 'x', '(', ')', և '|'-ից։ Ֆունկցիան վերադարձնում է ամենաերկար տողի երկարությունը, որը կարող է ընդունվել այս կանոնավոր արտահայտությամբ։\n\nՕրինակ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "bn": "একটি সরলীকৃত নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে এমন একটি স্ট্রিংয়ের সর্বাধিক দৈর্ঘ্য নির্ধারণ করে। ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, regex, যা একটি স্ট্রিং যা একটি নিয়মিত অভিব্যক্তি উপস্থাপন করে এবং কেবলমাত্র 'x', '(', ')', এবং '|' নিয়ে গঠিত। ফাংশনটি সেই সর্বাধিক দৈর্ঘ্যের স্ট্রিংয়ের দৈর্ঘ্য ফেরত দেয় যা এই নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে।\n\nউদাহরণ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "bg": "Определя максималната дължина на низ, който може да бъде приет от опростено регулярни изрази. Функцията приема един аргумент, regex, който е низ, представляващ регулярни изрази, съставени само от 'x', '(', ')', и '|'. Функцията връща дължината на най-дългия низ, който може да бъде приет от този регулярни израз.\n\nПример:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "zh": "确定可以被简化正则表达式接受的字符串的最大长度。  \n该函数接受一个参数，regex，这是一个仅由 'x'、'('、')' 和 '|' 组成的字符串，表示一个正则表达式。  \n该函数返回可以被此正则表达式接受的最长字符串的长度。\n\n示例：\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "fr": "Détermine la longueur maximale d'une chaîne qui peut être acceptée par une expression régulière simplifiée. La fonction prend un seul argument, regex, qui est une chaîne représentant une expression régulière composée uniquement de 'x', '(', ')', et '|'. La fonction renvoie la longueur de la plus longue chaîne qui peut être acceptée par cette expression régulière.\n\nExemple :\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "de": "Bestimmt die maximale Länge eines Strings, der von einem vereinfachten regulären Ausdruck akzeptiert werden kann. Die Funktion nimmt ein einzelnes Argument, regex, das einen String darstellt, der einen regulären Ausdruck repräsentiert, der nur aus 'x', '(', ')', und '|' besteht. Die Funktion gibt die Länge des längsten Strings zurück, der von diesem regulären Ausdruck akzeptiert werden kann.\n\nBeispiel:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "ha": "Yana ƙayyade tsawon mafi girman kirtani da za a iya karɓa ta hanyar sauƙaƙan magana na yau da kullum.\nAikin yana ɗaukar hujja guda ɗaya, regex, wanda shine kirtani da ke wakiltar magana na yau da kullum\nwanda aka ƙirƙira kawai da 'x', '(', ')', da '|'. Aikin yana mayar da tsawon mafi tsawon kirtani\nda za a iya karɓa ta wannan magana na yau da kullum.\n\nMisali:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hi": "यह एक सरलीकृत नियमित अभिव्यक्ति द्वारा स्वीकार किए जा सकने वाले स्ट्रिंग की अधिकतम लंबाई निर्धारित करता है। \nयह फ़ंक्शन एकल तर्क, regex, लेता है, जो एक स्ट्रिंग है जो 'x', '(', ')', और '|' से बनी नियमित अभिव्यक्ति का प्रतिनिधित्व करता है। \nयह फ़ंक्शन उस नियमित अभिव्यक्ति द्वारा स्वीकार किए जा सकने वाले सबसे लंबे स्ट्रिंग की लंबाई लौटाता है।\n\nउदाहरण:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hu": "Meghatározza a maximális hosszúságát egy karakterláncnak, amelyet egy egyszerűsített reguláris kifejezés elfogadhat.\nA függvény egyetlen argumentumot vesz fel, regex, amely egy reguláris kifejezést reprezentáló karakterlánc,\namely csak 'x', '(', ')', és '|' karakterekből áll. A függvény visszaadja a leghosszabb karakterlánc hosszát,\namelyet ez a reguláris kifejezés elfogadhat.\n\nPélda:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4"
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9839854255290621",
      "bn": "0.9859592156254058",
      "bg": "0.9805421678738223",
      "zh": "0.9727876377982203",
      "fr": "0.9909937012631161",
      "de": "0.9982893951585275",
      "ha": "0.9841145352767349",
      "hi": "0.9786418710184616",
      "hu": "0.9729892476349707"
    }
  },
  {
    "task_id": "Ruby/13",
    "prompt": {
      "en": "# Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\n# This function takes an array of numbers and an integer k as arguments. It returns the maximum sum \n# of any three numbers from the array such that this sum is divisible by k. It's guaranteed that there \n# are at least three numbers in the array and that a solution exists.\n#\n# Example:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "sq": "# Gjen shumën maksimale të çdo treshe numrash nga një varg i dhënë që është i pjestueshëm me një numër të specifikuar k.\n# Kjo funksion merr një varg numrash dhe një numër të plotë k si argumente. Ajo kthen shumën maksimale\n# të çdo treshe numrash nga vargu në mënyrë që kjo shumë të jetë e pjestueshme me k. Është e garantuar që ka\n# të paktën tre numra në varg dhe që ekziston një zgjidhje.\n#\n# Shembull:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "hy": "# Գտնում է տրված զանգվածից ցանկացած երեք թվերի առավելագույն գումարը, որը բաժանվում է տրված k թվով:\n# Այս ֆունկցիան ընդունում է թվերի զանգված և k ամբողջ թիվ որպես արգումենտներ։ Այն վերադարձնում է \n# զանգվածից ցանկացած երեք թվերի առավելագույն գումարը, որը բաժանվում է k թվով։ Երաշխավորված է, որ \n# զանգվածում առնվազն երեք թիվ կա և որ լուծում գոյություն ունի։\n#\n# Օրինակ:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "bn": "# একটি প্রদত্ত অ্যারের যেকোনো তিনটি সংখ্যার সর্বাধিক যোগফল খুঁজে বের করে যা একটি নির্দিষ্ট সংখ্যা k দ্বারা বিভাজ্য।\n# এই ফাংশনটি একটি সংখ্যার অ্যারে এবং একটি পূর্ণসংখ্যা k কে আর্গুমেন্ট হিসেবে গ্রহণ করে। এটি অ্যারের যেকোনো তিনটি সংখ্যার \n# সর্বাধিক যোগফল প্রদান করে যাতে এই যোগফলটি k দ্বারা বিভাজ্য হয়। এটি নিশ্চিত যে অ্যারেতে অন্তত তিনটি সংখ্যা রয়েছে এবং \n# একটি সমাধান বিদ্যমান।\n#\n# উদাহরণ:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "bg": "# Намира максималната сума на произволни три числа от даден масив, която е делима на зададено число k.\n# Тази функция приема масив от числа и цяло число k като аргументи. Тя връща максималната сума \n# на произволни три числа от масива, така че тази сума да е делима на k. Гарантирано е, че в масива \n# има поне три числа и че съществува решение.\n#\n# Пример:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "zh": "# 查找给定数组中任意三个数字的最大和，该和可以被指定的数字k整除。\n# 这个函数接受一个数字数组和一个整数k作为参数。它返回数组中任意三个数字的最大和，\n# 使得这个和可以被k整除。可以保证数组中至少有三个数字，并且存在一个解决方案。\n#\n# 示例:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "fr": "# Trouve la somme maximale de n'importe quels trois nombres d'un tableau donné qui est divisible par un nombre spécifié k.\n# Cette fonction prend un tableau de nombres et un entier k comme arguments. Elle renvoie la somme maximale \n# de n'importe quels trois nombres du tableau telle que cette somme soit divisible par k. Il est garanti qu'il y a \n# au moins trois nombres dans le tableau et qu'une solution existe.\n#\n# Exemple:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "de": "# Findet die maximale Summe von beliebigen drei Zahlen aus einem gegebenen Array, die durch eine angegebene Zahl k teilbar ist.\n# Diese Funktion nimmt ein Array von Zahlen und eine ganze Zahl k als Argumente. Sie gibt die maximale Summe \n# von beliebigen drei Zahlen aus dem Array zurück, sodass diese Summe durch k teilbar ist. Es ist garantiert, dass es \n# mindestens drei Zahlen im Array gibt und dass eine Lösung existiert.\n#\n# Beispiel:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "ha": "# Nemi mafi girman jimillar kowace uku daga cikin lambobin da aka bayar daga wani jeri da za a iya rabawa da wani lamba k da aka fayyace.\n# Wannan aikin yana karɓar jeri na lambobi da kuma cikakken lamba k a matsayin hujjoji. Yana dawo da mafi girman jimillar \n# kowace uku daga cikin lambobin daga jerin da za a iya rabawa da k. An tabbatar da cewa akwai aƙalla lambobi uku a cikin jerin \n# kuma akwai mafita.\n#\n# Misali:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "hi": "# दिए गए array से किसी भी तीन संख्याओं का अधिकतम योग खोजें जो किसी निर्दिष्ट संख्या k से विभाज्य हो।\n# यह फ़ंक्शन एक array और एक पूर्णांक k को तर्क के रूप में लेता है। यह array से किसी भी तीन संख्याओं का \n# अधिकतम योग लौटाता है ताकि यह योग k से विभाज्य हो। यह सुनिश्चित है कि array में कम से कम तीन संख्याएँ \n# हैं और एक समाधान मौजूद है।\n#\n# उदाहरण:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "hu": "# Megkeresi bármely három szám maximális összegét egy adott tömbből, amely osztható egy megadott k számmal.\n# Ez a függvény egy számokból álló tömböt és egy egész számot, k-t vesz át argumentumként. Visszaadja bármely három szám maximális összegét a tömbből úgy, hogy ez az összeg osztható legyen k-val. Garantált, hogy legalább három szám van a tömbben, és létezik megoldás.\n#\n# Példa:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)"
    },
    "prompt_bertscore": {
      "sq": "0.9742962355421803",
      "hy": "0.9704680322084949",
      "bn": "0.9799343589078556",
      "bg": "0.989615007788353",
      "zh": "0.965213265478217",
      "fr": "0.9931371217048636",
      "de": "0.9961126048127662",
      "ha": "0.9329137805877528",
      "hi": "0.9737267622397533",
      "hu": "0.9834199248342558"
    },
    "canonical_solution": "    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end",
    "instruction": {
      "en": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nՏվեք կարճ բնութագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nনিচের রুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\n请为以下 Ruby 代码提供一个简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def max_sum_divisible_by_k(numbers, k)\n    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.8824237254021134",
      "bn": "0.8737062352392543",
      "bg": "0.8364486908745768",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9353344890414249",
      "hi": "0.9027873120658102",
      "hu": "0.9226231378070973"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_sum_divisible_by_k([1, 2, 3, 4], 3) == 9\nraise 'Test failed' unless max_sum_divisible_by_k([4, 5, 10, 20], 5) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([6, 12, 17, 23, 29], 7) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([7, 14, 21, 28], 7) == 63\nraise 'Test failed' unless max_sum_divisible_by_k([10, 15, 25, 30, 40], 10) == 80\n\n\nputs 'All tests passed!'",
    "entry_point": "max_sum_divisible_by_k",
    "signature": "def max_sum_divisible_by_k(numbers, k)",
    "docstring": {
      "en": "Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\nThis function takes an array of numbers and an integer k as arguments. It returns the maximum sum\nof any three numbers from the array such that this sum is divisible by k. It's guaranteed that there\nare at least three numbers in the array and that a solution exists.\n\nExample:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "sq": "Gjen shumën maksimale të çdo treshe numrash nga një varg i dhënë që është e pjesëtueshme me një numër të specifikuar k. Kjo funksion merr një varg numrash dhe një numër të plotë k si argumente. Ajo kthen shumën maksimale të çdo treshe numrash nga vargu në mënyrë që kjo shumë të jetë e pjesëtueshme me k. Është e garantuar që ka të paktën tre numra në varg dhe që ekziston një zgjidhje.\n\nShembull:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hy": "Գտնում է տրված զանգվածից ցանկացած երեք թվերի առավելագույն գումարը, որը բաժանվում է նշված k թվով:\nԱյս ֆունկցիան ընդունում է թվերի զանգված և ամբողջ թիվ k որպես արգումենտներ։ Այն վերադարձնում է զանգվածից ցանկացած երեք թվերի առավելագույն գումարը այնպես, որ այս գումարը բաժանվի k թվով։ Երաշխավորվում է, որ զանգվածում առնվազն երեք թիվ կա և որ լուծում գոյություն ունի։\n\nՕրինակ:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "bn": "নির্দিষ্ট সংখ্যা k দ্বারা বিভাজ্য প্রদত্ত অ্যারের যেকোনো তিনটি সংখ্যার সর্বাধিক যোগফল খুঁজে বের করে। \nএই ফাংশনটি একটি সংখ্যা অ্যারে এবং একটি পূর্ণসংখ্যা k কে আর্গুমেন্ট হিসেবে গ্রহণ করে। এটি অ্যারের যেকোনো তিনটি সংখ্যার সর্বাধিক যোগফল প্রদান করে যাতে এই যোগফলটি k দ্বারা বিভাজ্য হয়। এটি নিশ্চিত যে অ্যারেতে অন্তত তিনটি সংখ্যা রয়েছে এবং একটি সমাধান বিদ্যমান।\n\nউদাহরণ:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "bg": "Намира максималната сума на произволни три числа от даден масив, която е делима на определено число k. \nТази функция приема масив от числа и цяло число k като аргументи. Тя връща максималната сума \nна произволни три числа от масива, така че тази сума да е делима на k. Гарантирано е, че в масива \nима поне три числа и че съществува решение.\n\nПример:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "zh": "找到给定数组中任意三个数字的最大和，该和可被指定的数字k整除。\n此函数接受一个数字数组和一个整数k作为参数。它返回数组中任意三个数字的最大和，使得该和可被k整除。可以保证数组中至少有三个数字，并且存在一个解。\n\n示例:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "fr": "Trouve la somme maximale de trois nombres quelconques d'un tableau donné qui est divisible par un nombre spécifié k. Cette fonction prend un tableau de nombres et un entier k comme arguments. Elle renvoie la somme maximale de trois nombres du tableau telle que cette somme soit divisible par k. Il est garanti qu'il y a au moins trois nombres dans le tableau et qu'une solution existe.\n\nExemple :\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "de": "Findet die maximale Summe von beliebigen drei Zahlen aus einem gegebenen Array, die durch eine angegebene Zahl k teilbar ist.\nDiese Funktion nimmt ein Array von Zahlen und eine ganze Zahl k als Argumente. Sie gibt die maximale Summe\nvon beliebigen drei Zahlen aus dem Array zurück, so dass diese Summe durch k teilbar ist. Es ist garantiert, dass es\nmindestens drei Zahlen im Array gibt und dass eine Lösung existiert.\n\nBeispiel:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "ha": "Nemo mafi girman jimillar kowanne lambobi uku daga jerin lambobi da aka bayar wanda za a iya rabawa da wani lamba k da aka fayyace.\nWannan aikin yana ɗaukar jerin lambobi da kuma adadi k a matsayin hujjoji. Yana mayar da mafi girman jimillar kowanne lambobi uku daga jerin lambobin da wannan jimillar za a iya rabawa da k. An tabbatar da cewa a kalla akwai lambobi uku a cikin jerin kuma akwai mafita.\n\nMisali:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hi": "दिए गए एरे से किसी भी तीन संख्याओं का अधिकतम योग खोजता है जो एक निर्दिष्ट संख्या k से विभाज्य है। यह फ़ंक्शन एक एरे और एक पूर्णांक k को तर्क के रूप में लेता है। यह एरे से किसी भी तीन संख्याओं का अधिकतम योग लौटाता है ताकि यह योग k से विभाज्य हो। यह गारंटी है कि एरे में कम से कम तीन संख्याएँ हैं और एक समाधान मौजूद है।\n\nउदाहरण:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hu": "Megtalálja a maximális összeget bármely három számból egy adott tömbből, amely osztható egy megadott k számmal.\nEz a függvény egy számokból álló tömböt és egy egész számot, k-t vesz argumentumként. Visszaadja a tömb bármely három számának maximális összegét úgy, hogy ez az összeg osztható legyen k-val. Garantált, hogy a tömbben legalább három szám van, és hogy létezik megoldás.\n\nPélda:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35"
    },
    "docstring_bertscore": {
      "sq": "0.9703925526637016",
      "hy": "0.9873641283104656",
      "bn": "0.97311001490664",
      "bg": "0.9883040472735227",
      "zh": "0.9759810184341182",
      "fr": "0.9867930659649903",
      "de": "0.9953117271164336",
      "ha": "0.9304736063567391",
      "hi": "0.9849940706039573",
      "hu": "0.9854568793917686"
    }
  },
  {
    "task_id": "Ruby/14",
    "prompt": {
      "en": "# Calculates the difference in the number of victories between the most and least successful teams.\n# This function takes a string, team_sequence, representing the sequence of winning teams, where each team\n# is identified by a lowercase letter. It returns an integer representing the difference in the number\n# of victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n#\n# Example:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "sq": "# Llogarit diferencën në numrin e fitoreve midis ekipeve më të suksesshme dhe atyre më pak të suksesshme.\n# Kjo funksion merr një varg, team_sequence, që përfaqëson sekuencën e ekipeve fituese, ku çdo ekip\n# identifikohet nga një shkronjë e vogël. Kthen një numër të plotë që përfaqëson diferencën në numrin\n# e fitoreve midis ekipit që fitoi më shumë dhe ekipit që fitoi më pak (duke përjashtuar ekipet me zero fitore).\n#\n# Shembull:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "hy": "# Հաշվում է հաղթանակների քանակի տարբերությունը ամենահաջողակ և ամենաքիչ հաջողակ թիմերի միջև։\n# Այս ֆունկցիան ընդունում է team_sequence տողը, որը ներկայացնում է հաղթող թիմերի հաջորդականությունը, որտեղ յուրաքանչյուր թիմ\n# նշվում է փոքրատառ տառով։ Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է հաղթանակների քանակի տարբերությունը\n# ամենաշատ հաղթած և ամենաքիչ հաղթած թիմերի միջև (բացառելով զրո հաղթանակ ունեցող թիմերը)։\n#\n# Օրինակ:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "bn": "# সবচেয়ে সফল এবং কম সফল দলের মধ্যে জয়ের সংখ্যার পার্থক্য গণনা করে।\n# এই ফাংশনটি একটি স্ট্রিং, team_sequence, গ্রহণ করে যা বিজয়ী দলের ক্রম উপস্থাপন করে, যেখানে প্রতিটি দল\n# একটি ছোট হাতের অক্ষর দ্বারা চিহ্নিত করা হয়। এটি একটি পূর্ণসংখ্যা প্রদান করে যা সবচেয়ে বেশি জয়ী দল এবং সবচেয়ে কম জয়ী দলের\n# মধ্যে জয়ের সংখ্যার পার্থক্য উপস্থাপন করে (শূন্য জয়ের দলগুলি বাদ দিয়ে)।\n#\n# উদাহরণ:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "bg": "# Изчислява разликата в броя на победите между най-успешните и най-малко успешните отбори.\n# Тази функция приема низ, team_sequence, представляващ последователността от печеливши отбори, където всеки отбор\n# е идентифициран с малка буква. Тя връща цяло число, представляващо разликата в броя\n# на победите между отбора с най-много победи и отбора с най-малко победи (изключвайки отборите с нула победи).\n#\n# Пример:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "zh": "# 计算最成功和最不成功的团队之间胜利次数的差异。\n# 此函数接收一个字符串，team_sequence，表示获胜团队的顺序，其中每个团队\n# 由一个小写字母标识。它返回一个整数，表示胜利次数最多的团队与胜利次数最少的团队之间的差异（不包括胜利次数为零的团队）。\n#\n# 示例:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "fr": "# Calcule la différence dans le nombre de victoires entre les équipes les plus et les moins performantes.\n# Cette fonction prend une chaîne de caractères, team_sequence, représentant la séquence des équipes gagnantes, où chaque équipe\n# est identifiée par une lettre minuscule. Elle renvoie un entier représentant la différence dans le nombre\n# de victoires entre l'équipe qui a gagné le plus et l'équipe qui a gagné le moins (en excluant les équipes avec zéro victoire).\n#\n# Exemple:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "de": "# Berechnet die Differenz in der Anzahl der Siege zwischen den erfolgreichsten und den am wenigsten erfolgreichen Teams.\n# Diese Funktion nimmt einen String, team_sequence, der die Reihenfolge der siegreichen Teams darstellt, wobei jedes Team\n# durch einen Kleinbuchstaben identifiziert wird. Sie gibt eine ganze Zahl zurück, die die Differenz in der Anzahl\n# der Siege zwischen dem Team, das am meisten gewonnen hat, und dem Team, das am wenigsten gewonnen hat, darstellt (ausgenommen Teams ohne Siege).\n#\n# Beispiel:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "ha": "# Lissafin bambanci a cikin adadin nasarori tsakanin ƙungiyoyin da suka fi nasara da waɗanda suka fi rashin nasara.\n# Wannan aikin yana karɓar kirtani, team_sequence, wanda ke wakiltar jerin ƙungiyoyin da suka yi nasara, inda kowace ƙungiya\n# take da alama ta wata ƙaramin harafi. Yana mayar da cikakken lamba wadda ke wakiltar bambanci a cikin adadin\n# nasarori tsakanin ƙungiyar da ta fi nasara da ƙungiyar da ta fi rashin nasara (ba tare da ƙungiyoyin da ba su da nasara ba).\n#\n# Misali:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "hi": "# सबसे सफल और सबसे कम सफल टीमों के बीच जीत की संख्या में अंतर की गणना करता है।\n# यह फ़ंक्शन एक स्ट्रिंग लेता है, team_sequence, जो विजेता टीमों के अनुक्रम का प्रतिनिधित्व करता है,\n# जहाँ प्रत्येक टीम को एक छोटे अक्षर द्वारा पहचाना जाता है। यह एक पूर्णांक लौटाता है जो\n# सबसे अधिक जीतने वाली टीम और सबसे कम जीतने वाली टीम के बीच जीत की संख्या में अंतर का प्रतिनिधित्व करता है\n# (शून्य जीत वाली टीमों को छोड़कर)।\n#\n# उदाहरण:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "hu": "# Kiszámítja a győzelmek számának különbségét a legsikeresebb és a legkevésbé sikeres csapatok között.\n# Ez a függvény egy karakterláncot, team_sequence-t vesz fel, amely a győztes csapatok sorozatát\n# jelenti, ahol minden csapatot egy kisbetűs betű azonosít. Egy egész számot ad vissza, amely a legtöbbet\n# nyerő csapat és a legkevesebbet nyerő csapat győzelmeinek számának különbségét jelenti (kivéve azokat a csapatokat, amelyeknek nulla győzelmük van).\n#\n# Példa:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)"
    },
    "prompt_bertscore": {
      "sq": "0.9776620273488165",
      "hy": "0.965281792959674",
      "bn": "0.9721393082345224",
      "bg": "0.9855303726327515",
      "zh": "0.9665274040791437",
      "fr": "0.9956343028552342",
      "de": "0.9703879841649379",
      "ha": "0.9539848886686957",
      "hi": "0.9483366351535877",
      "hu": "0.968008988091283"
    },
    "canonical_solution": "    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end",
    "instruction": {
      "en": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nনিচের রুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки не повече от 500 символа.",
      "zh": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\n请为以下 Ruby 代码提供一个简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def victory_gap_in_teams(team_sequence)\n    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9202439431030613",
      "bn": "0.8737062352392543",
      "bg": "0.8991035130191372",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9171840420832189",
      "hi": "0.9119288780921788",
      "hu": "0.9311801346220803"
    },
    "level": "",
    "test": "raise 'Test failed' unless victory_gap_in_teams(\"abaabcaa\") == 4\nraise 'Test failed' unless victory_gap_in_teams(\"abcd\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"a\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"aaabbbccc\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"abcdaaa\") == 3\n\nputs 'All tests passed!'",
    "entry_point": "victory_gap_in_teams",
    "signature": "def victory_gap_in_teams(team_sequence)",
    "docstring": {
      "en": "Calculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n\nExample:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "sq": "Llogarit diferencën në numrin e fitoreve midis ekipeve më të suksesshme dhe atyre më pak të suksesshme.\nKjo funksion merr një varg, team_sequence, që përfaqëson sekuencën e ekipeve fituese, ku secili ekip\nidentifikohet nga një shkronjë e vogël. Kthen një numër të plotë që përfaqëson diferencën në numrin\ne fitoreve midis ekipit që fitoi më shumë dhe ekipit që fitoi më pak (duke përjashtuar ekipet me zero fitore).\n\nShembull:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hy": "Հաշվում է հաղթանակների քանակի տարբերությունը ամենահաջողակ և ամենաքիչ հաջողակ թիմերի միջև։  \nԱյս գործառույթը ընդունում է team_sequence տողը, որը ներկայացնում է հաղթող թիմերի հերթականությունը, որտեղ յուրաքանչյուր թիմ  \nներկայացված է փոքրատառ տառով։ Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է հաղթանակների քանակի տարբերությունը  \nամենաշատ հաղթած և ամենաքիչ հաղթած թիմերի միջև (բացառելով զրո հաղթանակ ունեցող թիմերը)։\n\nՕրինակ:  \n>>> victory_gap_in_teams(\"abaabcaa\")  \n4  \n>>> victory_gap_in_teams(\"abcd\")  \n0",
      "bn": "বিজয়ী দলের মধ্যে সবচেয়ে সফল এবং কম সফল দলের বিজয়ের সংখ্যা মধ্যে পার্থক্য গণনা করে। \nএই ফাংশনটি একটি স্ট্রিং, team_sequence, গ্রহণ করে, যা বিজয়ী দলের ক্রমকে উপস্থাপন করে, যেখানে প্রতিটি দল একটি ছোট হাতের অক্ষর দ্বারা চিহ্নিত হয়। এটি একটি পূর্ণসংখ্যা প্রদান করে যা সবচেয়ে বেশি বিজয়ী দল এবং সবচেয়ে কম বিজয়ী দলের বিজয়ের সংখ্যা মধ্যে পার্থক্য উপস্থাপন করে (শূন্য বিজয়ী দলগুলি বাদ দিয়ে)।\n\nউদাহরণ:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "bg": "Изчислява разликата в броя на победите между най-успешните и най-малко успешните отбори.\nТази функция приема низ, team_sequence, представляващ последователността от печеливши отбори, където всеки отбор\nе идентифициран с малка буква. Връща цяло число, представляващо разликата в броя\nна победите между отбора, който е спечелил най-много, и отбора, който е спечелил най-малко (изключвайки отбори с нула победи).\n\nПример:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "zh": "计算最成功和最不成功的团队之间胜利次数的差异。\n此函数接受一个字符串 `team_sequence`，表示获胜团队的顺序，其中每个团队由一个小写字母标识。它返回一个整数，表示获胜次数最多的团队和获胜次数最少的团队之间的差异（不包括胜利次数为零的团队）。\n\n示例：\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "fr": "Calcule la différence du nombre de victoires entre les équipes les plus et les moins performantes.  \nCette fonction prend une chaîne de caractères, team_sequence, représentant la séquence des équipes gagnantes, où chaque équipe est identifiée par une lettre minuscule. Elle retourne un entier représentant la différence du nombre de victoires entre l'équipe qui a gagné le plus et l'équipe qui a gagné le moins (en excluant les équipes avec zéro victoire).\n\nExemple :\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "de": "Berechnet den Unterschied in der Anzahl der Siege zwischen den erfolgreichsten und den am wenigsten erfolgreichen Teams.\nDiese Funktion nimmt einen String, team_sequence, der die Reihenfolge der siegreichen Teams darstellt, wobei jedes Team durch einen Kleinbuchstaben identifiziert wird. Sie gibt eine ganze Zahl zurück, die den Unterschied in der Anzahl der Siege zwischen dem Team, das am meisten gewonnen hat, und dem Team, das am wenigsten gewonnen hat (ohne Teams mit null Siegen), darstellt.\n\nBeispiel:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "ha": "Yana lissafin bambanci a cikin adadin nasarori tsakanin ƙungiyoyin da suka fi nasara da waɗanda suka fi rashin nasara.\nWannan aikin yana karɓar kirtani, team_sequence, wanda ke wakiltar jerin ƙungiyoyin da suka yi nasara, inda kowace ƙungiya\nana ganeta da wata ƙaramin harafi. Yana dawowa da cikakken lamba wanda ke wakiltar bambanci a cikin adadin\nnasarori tsakanin ƙungiyar da ta fi nasara da ƙungiyar da ta fi rashin nasara (ban da ƙungiyoyin da ba su da nasara).\n\nMisali:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hi": "विजेता टीमों के बीच जीत की संख्या में अंतर की गणना करता है।\nयह फ़ंक्शन एक स्ट्रिंग, team_sequence लेता है, जो विजेता टीमों के अनुक्रम का प्रतिनिधित्व करता है, जहाँ प्रत्येक टीम को एक छोटे अक्षर द्वारा पहचाना जाता है। यह एक पूर्णांक लौटाता है जो सबसे अधिक जीतने वाली टीम और सबसे कम जीतने वाली टीम के बीच जीत की संख्या में अंतर का प्रतिनिधित्व करता है (शून्य जीत वाली टीमों को छोड़कर)।\n\nउदाहरण:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hu": "Számítja a győzelmek számának különbségét a legsikeresebb és a legkevésbé sikeres csapatok között.  \nEz a függvény egy karakterláncot vesz fel, team_sequence, amely a győztes csapatok sorozatát jelöli, ahol minden csapatot egy kisbetű azonosít. Egy egész számot ad vissza, amely a legtöbbet nyert csapat és a legkevesebbet nyert csapat győzelmeinek számának különbségét jelenti (nulla győzelemmel rendelkező csapatok kizárva).\n\nPélda:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9800340713591351",
      "hy": "0.9665180684512351",
      "bn": "0.9691656128000491",
      "bg": "0.9837856033657411",
      "zh": "0.9601336907440118",
      "fr": "0.9884134926134729",
      "de": "0.9675751793391028",
      "ha": "0.9501048428055602",
      "hi": "0.9633713659548804",
      "hu": "0.9640997435621353"
    }
  },
  {
    "task_id": "Ruby/15",
    "prompt": {
      "en": "# Determines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\n# The function takes a single argument, n, which is the height of the building (number of floors).\n# It returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n#\n# The problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n#\n# Example:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "sq": "# Përcakton numrin maksimal të testeve të hedhjes të nevojshme për të gjetur lartësinë e tolerancës së hedhjes së një pajisjeje nga një ndërtesë me një lartësi të dhënë.\n# Funksioni merr një argument të vetëm, n, i cili është lartësia e ndërtesës (numri i kateve).\n# Ai kthen numrin maksimal të testeve të nevojshme për të gjetur katin e saktë nga i cili, nëse pajisja hidhet, do të thyhet.\n#\n# Problemi supozon skenarin më të keq, ku rezultati i secilit test është më pak i favorshëm, duke kërkuar kështu numrin maksimal të testeve.\n#\n# Shembull:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "hy": "# Որոշում է առավելագույն թեստերի քանակը, որոնք անհրաժեշտ են սարքի ընկնելու հանդուրժողականության բարձրությունը գտնելու համար շենքի տրված բարձրությունից:\n# Ֆունկցիան ընդունում է մեկ արգումենտ, n, որը շենքի բարձրությունն է (հարկերի քանակը):\n# Այն վերադարձնում է առավելագույն թեստերի քանակը, որոնք անհրաժեշտ են ճշգրիտ հարկը գտնելու համար, որից եթե սարքը ընկնի, այն կկոտրվի:\n#\n# Խնդիրը ենթադրում է ամենավատ դեպքը, որտեղ յուրաքանչյուր թեստի արդյունքը ամենաանբարենպաստն է, ուստի պահանջվում է առավելագույն թեստերի քանակը:\n#\n# Օրինակ:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "bn": "# একটি ভবনের প্রদত্ত উচ্চতা থেকে একটি ডিভাইসের ড্রপ সহনশীলতা উচ্চতা খুঁজে বের করতে প্রয়োজনীয় সর্বাধিক ড্রপ পরীক্ষার সংখ্যা নির্ধারণ করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা ভবনের উচ্চতা (তলার সংখ্যা)।\n# এটি প্রয়োজনীয় সর্বাধিক পরীক্ষার সংখ্যা ফেরত দেয়, যা সঠিক তলা খুঁজে বের করতে প্রয়োজনীয়, যেখান থেকে ডিভাইসটি ফেলে দিলে এটি ভেঙে যাবে।\n#\n# সমস্যাটি সবচেয়ে খারাপ পরিস্থিতি ধরে নেয়, যেখানে প্রতিটি পরীক্ষার ফলাফল সবচেয়ে অনুকূল নয়, ফলে সর্বাধিক পরীক্ষার প্রয়োজন হয়।\n#\n# উদাহরণ:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "bg": "# Определя максималния брой тестове за изпускане, необходими за намиране на височината на толерантност при изпускане на устройство от сграда с дадена височина.\n# Функцията приема един аргумент, n, който е височината на сградата (брой етажи).\n# Връща максималния брой тестове, необходими за намиране на точния етаж, от който ако устройството се изпусне, ще се счупи.\n#\n# Проблемът предполага най-лошия сценарий, при който резултатът от всеки тест е най-неблагоприятен, изискващ максимален брой тестове.\n#\n# Пример:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "zh": "# 确定需要的最大跌落测试次数，以找出设备从给定高度的建筑物跌落的耐受高度。\n# 该函数接受一个参数 n，即建筑物的高度（楼层数）。\n# 它返回找到确切楼层所需的最大测试次数，如果设备从该楼层跌落，它将会损坏。\n#\n# 该问题假设最坏情况，即每次测试的结果都是最不利的，因此需要最大次数的测试。\n#\n# 例子:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "fr": "# Détermine le nombre maximum de tests de chute nécessaires pour trouver la hauteur de tolérance de chute d'un appareil depuis un bâtiment d'une hauteur donnée.\n# La fonction prend un seul argument, n, qui est la hauteur du bâtiment (nombre d'étages).\n# Elle renvoie le nombre maximum de tests nécessaires pour trouver l'étage exact à partir duquel, si l'appareil est lâché, il se cassera.\n#\n# Le problème suppose le pire des cas, où le résultat de chaque test est le moins favorable, nécessitant ainsi le nombre maximum de tests.\n#\n# Exemple :\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "de": "# Bestimmt die maximale Anzahl an Falltests, die benötigt werden, um die Falltoleranzhöhe eines Geräts von einem Gebäude mit gegebener Höhe zu finden.\n# Die Funktion nimmt ein einziges Argument, n, das die Höhe des Gebäudes (Anzahl der Stockwerke) ist.\n# Sie gibt die maximale Anzahl an Tests zurück, die benötigt werden, um das genaue Stockwerk zu finden, von dem aus das Gerät, wenn es fallen gelassen wird, zerbricht.\n#\n# Das Problem geht vom schlimmsten Fall aus, bei dem das Ergebnis jedes Tests am ungünstigsten ist und somit die maximale Anzahl an Tests erfordert.\n#\n# Beispiel:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "ha": "# Yana tantance yawan gwaje-gwajen saukewa da ake bukata don gano tsayin juriya na saukewa na na'ura daga gini mai tsayin da aka bayar.\n# Aikin yana daukar hujja guda, n, wanda shine tsayin ginin (yawan bene).\n# Yana mayar da yawan gwaje-gwajen da ake bukata don gano daidai benen da idan aka sauke na'urar, zai karye.\n#\n# Matsalar tana daukar yanayin mafi muni, inda sakamakon kowanne gwaji shine mafi rashin jin dadi, don haka yana bukatar yawan gwaje-gwaje.\n#\n# Misali:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "hi": "# यह निर्धारित करता है कि किसी उपकरण की ड्रॉप सहनशीलता ऊंचाई को खोजने के लिए अधिकतम कितने ड्रॉप परीक्षणों की आवश्यकता होगी, जब इसे एक दी गई ऊंचाई वाली इमारत से गिराया जाए।\n# यह फ़ंक्शन एकल तर्क, n, लेता है, जो इमारत की ऊंचाई (मंजिलों की संख्या) है।\n# यह उन परीक्षणों की अधिकतम संख्या लौटाता है जो यह पता लगाने के लिए आवश्यक हैं कि किस सटीक मंजिल से यदि उपकरण गिराया जाए, तो वह टूट जाएगा।\n#\n# समस्या सबसे खराब स्थिति मानती है, जहां प्रत्येक परीक्षण का परिणाम सबसे कम अनुकूल होता है, जिससे अधिकतम संख्या में परीक्षणों की आवश्यकता होती है।\n#\n# उदाहरण:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "hu": "# Meghatározza a maximális számú ejtési tesztet, amely szükséges ahhoz, hogy megtaláljuk egy eszköz ejtési tűréshatárának magasságát egy adott magasságú épületből.\n# A függvény egyetlen argumentumot vesz fel, n-t, ami az épület magassága (emeletek száma).\n# Visszaadja a szükséges maximális tesztek számát, hogy megtaláljuk azt a pontos emeletet, ahonnan ha az eszközt leejtjük, az eltörik.\n#\n# A probléma a legrosszabb forgatókönyvet feltételezi, ahol minden teszt kimenetele a legkedvezőtlenebb, így a maximális számú teszt szükséges.\n#\n# Példa:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9931824094317395",
      "hy": "0.9771312869706913",
      "bn": "0.9646372373732157",
      "bg": "0.9813607236740671",
      "zh": "0.958842791897666",
      "fr": "0.9915496676996327",
      "de": "0.9908367832620986",
      "ha": "0.967894775622188",
      "hi": "0.9837893773429807",
      "hu": "0.9833406713122229"
    },
    "canonical_solution": "    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end",
    "instruction": {
      "en": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) për kodin Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nনিচের Ruby কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\n请为以下 Ruby 代码提供一个简洁的中文自然语言描述（文档字符串），不超过500个字符。",
      "fr": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nFournir une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def max_drop_test_height(n)\n    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9451549737101708",
      "hy": "0.8824237254021134",
      "bn": "0.8737062352392543",
      "bg": "0.8364486908745768",
      "zh": "0.8714821708628067",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9531146889693819",
      "hi": "0.9119288780921788",
      "hu": "0.9410598111443745"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_drop_test_height(3) == 2\nraise 'Test failed' unless max_drop_test_height(10) == 4\nraise 'Test failed' unless max_drop_test_height(15) == 5\nraise 'Test failed' unless max_drop_test_height(6) == 3\nraise 'Test failed' unless max_drop_test_height(100) == 9\n\n\nputs 'All tests passed!'",
    "entry_point": "max_drop_test_height",
    "signature": "def max_drop_test_height(n)",
    "docstring": {
      "en": "Determines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\nThe function takes a single argument, n, which is the height of the building (number of floors).\nIt returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n\nThe problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n\nExample:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "sq": "Përcakton numrin maksimal të testeve të hedhjes të nevojshme për të gjetur lartësinë e tolerancës së hedhjes së një pajisjeje nga një ndërtesë me një lartësi të caktuar.\nFunksioni merr një argument të vetëm, n, i cili është lartësia e ndërtesës (numri i kateve).\nKthen numrin maksimal të testeve të nevojshme për të gjetur katin e saktë nga i cili, nëse pajisja hidhet, do të thyhet.\n\nProblemi supozon skenarin më të keq, ku rezultati i secilit test është më pak i favorshëm, duke kërkuar kështu numrin maksimal të testeve.\n\nShembull:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hy": "Սահմանում է սարքի անկման դիմացկունության բարձրությունը գտնելու համար անհրաժեշտ առավելագույն թեստերի քանակը շենքի որոշակի բարձրությունից:\nՖունկցիան ընդունում է մեկ արգումենտ, n, որը շենքի բարձրությունն է (հարկերի քանակը):\nԱյն վերադարձնում է անհրաժեշտ առավելագույն թեստերի քանակը՝ գտնելու այն ճշգրիտ հարկը, որից սարքը գցելու դեպքում այն կկոտրվի:\n\nԽնդիրը ենթադրում է ամենավատ դեպքը, երբ յուրաքանչյուր թեստի արդյունքը ամենաանբարենպաստն է, հետևաբար պահանջվում է առավելագույն քանակով թեստեր:\n\nՕրինակ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "bn": "একটি ভবনের নির্দিষ্ট উচ্চতা থেকে একটি যন্ত্রের পতন সহনশীলতা উচ্চতা নির্ধারণ করতে প্রয়োজনীয় সর্বাধিক সংখ্যক পতন পরীক্ষার সংখ্যা নির্ধারণ করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা ভবনের উচ্চতা (তলার সংখ্যা)।\nএটি প্রয়োজনীয় সর্বাধিক পরীক্ষার সংখ্যা ফেরত দেয়, যা থেকে সঠিক তলা নির্ধারণ করা যাবে, যেখান থেকে যন্ত্রটি ফেলা হলে তা ভেঙে যাবে।\n\nসমস্যাটি সর্বাধিক খারাপ পরিস্থিতি ধরে নেয়, যেখানে প্রতিটি পরীক্ষার ফলাফল সবচেয়ে অপ্রিয়, ফলে সর্বাধিক সংখ্যক পরীক্ষার প্রয়োজন হয়।\n\nউদাহরণ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "bg": "Определя максималния брой тестове за изпускане, необходими за намиране на височината на допустимото изпускане на устройство от сграда с дадена височина. Функцията приема един аргумент, n, който е височината на сградата (брой етажи). Връща максималния брой тестове, необходими за намиране на точния етаж, от който ако устройството бъде изпуснато, ще се счупи.\n\nПроблемът предполага най-лошия сценарий, при който резултатът от всеки тест е най-неблагоприятен, което изисква максимален брой тестове.\n\nПример:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "zh": "确定需要的最大跌落测试次数，以找出设备从给定高度的建筑物跌落的耐受高度。\n该函数接受一个参数 n，即建筑物的高度（楼层数）。\n它返回找到确切楼层所需的最大测试次数，从该楼层跌落设备将会损坏。\n\n该问题假设最坏情况，即每次测试的结果都是最不利的，因此需要最大次数的测试。\n\n示例：\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "fr": "Détermine le nombre maximum de tests de chute nécessaires pour trouver la hauteur de tolérance de chute d'un appareil depuis un bâtiment d'une hauteur donnée.  \nLa fonction prend un seul argument, n, qui est la hauteur du bâtiment (nombre d'étages).  \nElle renvoie le nombre maximum de tests nécessaires pour trouver l'étage exact à partir duquel, si l'appareil est lâché, il se cassera.  \n\nLe problème suppose le pire des cas, où le résultat de chaque test est le moins favorable, nécessitant ainsi le nombre maximum de tests.  \n\nExemple :  \n>>> max_drop_test_height(3)  \n2  \n>>> max_drop_test_height(10)  \n4  ",
      "de": "Bestimmt die maximale Anzahl an Falltests, die benötigt werden, um die Falltoleranzhöhe eines Geräts von einem Gebäude mit einer gegebenen Höhe zu finden. Die Funktion nimmt ein einzelnes Argument, n, das die Höhe des Gebäudes (Anzahl der Stockwerke) ist. Sie gibt die maximale Anzahl an Tests zurück, die benötigt werden, um das genaue Stockwerk zu finden, von dem aus das Gerät, wenn es fallen gelassen wird, zerbricht.\n\nDas Problem geht vom schlimmsten Fall aus, bei dem das Ergebnis jedes Tests am ungünstigsten ist, was die maximale Anzahl an Tests erfordert.\n\nBeispiel:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "ha": "Yana tantance yawan gwaje-gwajen da ake bukata don gano tsayin jurewa na na'ura daga gini mai tsayin da aka bayar.\nAikin yana karɓar hujja guda ɗaya, n, wanda shine tsayin ginin (yawan bene).\nYana dawo da yawan gwaje-gwajen da ake bukata don gano ainihin bene daga wanda idan aka jefa na'urar, za ta karye.\n\nMatsalar tana ɗaukar yanayin mafi muni, inda sakamakon kowane gwaji shine mafi rashin alheri, don haka yana buƙatar yawan gwaje-gwaje.\n\nMisali:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hi": "निर्धारित करता है कि किसी इमारत की दी गई ऊँचाई से एक उपकरण की ड्रॉप सहनशीलता ऊँचाई खोजने के लिए अधिकतम कितने ड्रॉप परीक्षणों की आवश्यकता होगी।\nयह फ़ंक्शन एकल तर्क n लेता है, जो इमारत की ऊँचाई (मंजिलों की संख्या) है।\nयह उस मंजिल को खोजने के लिए आवश्यक परीक्षणों की अधिकतम संख्या लौटाता है, जिससे यदि उपकरण गिराया जाए, तो वह टूट जाएगा।\n\nसमस्या सबसे खराब स्थिति मानती है, जहाँ प्रत्येक परीक्षण का परिणाम सबसे कम अनुकूल होता है, इस प्रकार अधिकतम संख्या में परीक्षणों की आवश्यकता होती है।\n\nउदाहरण:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hu": "Meghatározza a maximális ejtési tesztek számát, amely szükséges ahhoz, hogy megtaláljuk egy eszköz ejtési tűrési magasságát egy adott magasságú épületből.\nA függvény egyetlen argumentumot vesz fel, n, amely az épület magassága (emeletek száma).\nVisszaadja a maximális tesztek számát, amely szükséges annak az emeletnek a pontos megtalálásához, ahonnan ha az eszközt leejtik, az eltörik.\n\nA probléma a legrosszabb forgatókönyvet feltételezi, ahol minden teszt kimenetele a legkedvezőtlenebb, így a maximális számú teszt szükséges.\n\nPélda:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9871627171040962",
      "hy": "0.9520142766584486",
      "bn": "0.9480414704073699",
      "bg": "0.9699547713039007",
      "zh": "0.9329046435902251",
      "fr": "0.9837689184137342",
      "de": "0.9805491199371585",
      "ha": "0.9536694636236124",
      "hi": "0.9766380877345816",
      "hu": "0.9719088969925219"
    }
  },
  {
    "task_id": "Ruby/16",
    "prompt": {
      "en": "# Computes the repeated sum of digits of a given number string until it reduces to a single digit.\n# The function takes a single argument, `input_string`, which is a string representing a non-negative number.\n# It repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n#\n# Example:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "sq": "# Llogarit shumën e përsëritur të shifrave të një vargu numrash të dhënë derisa të reduktohet në një shifër të vetme.\n# Funksioni merr një argument të vetëm, `input_string`, i cili është një varg që përfaqëson një numër jo-negativ.\n# Ai përsëritësisht mbledh shifrat e numrit derisa shuma të jetë një shifër e vetme, pastaj kthen këtë shifër të vetme.\n#\n# Shembull:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "hy": "# Հաշվում է տրված թվային տողի թվանշանների կրկնվող գումարը, մինչև այն կրճատվի մեկ թվանշանի:\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ `input_string`, որը ներկայացնում է ոչ բացասական թիվ:\n# Այն կրկնվող գումարում է թվի թվանշանները, մինչև գումարը դառնա մեկ թվանշան, ապա վերադարձնում է այդ մեկ թվանշանը:\n#\n# Օրինակ:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "bn": "# একটি প্রদত্ত সংখ্যা স্ট্রিংয়ের অঙ্কগুলির পুনরাবৃত্ত যোগফল গণনা করে যতক্ষণ না এটি একটি একক অঙ্কে হ্রাস পায়।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, `input_string`, যা একটি অ-ঋণাত্মক সংখ্যাকে উপস্থাপনকারী একটি স্ট্রিং।\n# এটি সংখ্যার অঙ্কগুলির যোগফল বারবার গণনা করে যতক্ষণ না যোগফলটি একটি একক অঙ্ক হয়, তারপর এই একক অঙ্কটি ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "bg": "# Изчислява повтарящата се сума на цифрите на даден низ от числа, докато се намали до една цифра.\n# Функцията приема един аргумент, `input_string`, който е низ, представляващ неотрицателно число.\n# Тя многократно сумира цифрите на числото, докато сумата стане едноцифрена, след което връща тази едноцифрена стойност.\n#\n# Пример:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "zh": "# 计算给定数字字符串的重复数字和，直到其简化为个位数。\n# 该函数接受一个参数 `input_string`，它是一个表示非负数的字符串。\n# 它反复对数字的各位进行求和，直到和为个位数，然后返回这个个位数。\n#\n# 例子:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "fr": "# Calcule la somme répétée des chiffres d'une chaîne de nombres donnée jusqu'à ce qu'elle se réduise à un seul chiffre.\n# La fonction prend un seul argument, `input_string`, qui est une chaîne représentant un nombre non négatif.\n# Elle additionne de manière répétée les chiffres du nombre jusqu'à ce que la somme soit un seul chiffre, puis retourne ce chiffre unique.\n#\n# Exemple :\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "de": "# Berechnet die wiederholte Summe der Ziffern einer gegebenen Zahlenzeichenkette, bis sie auf eine einzelne Ziffer reduziert ist.\n# Die Funktion nimmt ein einzelnes Argument, `input_string`, das eine Zeichenkette darstellt, die eine nicht-negative Zahl repräsentiert.\n# Sie summiert wiederholt die Ziffern der Zahl, bis die Summe eine einzelne Ziffer ist, und gibt dann diese einzelne Ziffer zurück.\n#\n# Beispiel:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "ha": "# Lissafin jimillar lambobin wata lamba har sai ta ragu zuwa lamba guda.\n# Aikin yana karɓar hujja guda, `input_string`, wanda yake wakiltar wata lamba mara kyau.\n# Yana maimaita lissafin jimillar lambobin har sai jimillar ta zama lamba guda, sannan ya dawo da wannan lamba guda.\n#\n# Misali:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "hi": "# एक दिए गए संख्या स्ट्रिंग के अंकों के बार-बार योग की गणना करता है जब तक कि यह एकल अंक में नहीं बदल जाता।\n# फ़ंक्शन एकल तर्क लेता है, `input_string`, जो एक गैर-ऋणात्मक संख्या का प्रतिनिधित्व करने वाली स्ट्रिंग है।\n# यह संख्या के अंकों का बार-बार योग करता है जब तक कि योग एकल अंक न हो, फिर इस एकल अंक को लौटाता है।\n#\n# उदाहरण:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "hu": "# Egy adott számjegy sorozat ismételt összegét számítja ki, amíg az egyetlen számjegyre nem redukálódik.\n# A függvény egyetlen argumentumot vesz fel, `input_string`, amely egy nem-negatív számot reprezentáló karakterlánc.\n# Ismételten összegzi a számjegyeket, amíg az összeg egyetlen számjegy nem lesz, majd visszaadja ezt az egyetlen számjegyet.\n#\n# Példa:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)"
    },
    "prompt_bertscore": {
      "sq": "0.9787429738824084",
      "hy": "0.9703760663420757",
      "bn": "0.9738870569572484",
      "bg": "0.9660292390835082",
      "zh": "0.953684162271809",
      "fr": "0.9727195075775253",
      "de": "0.9800704207188645",
      "ha": "0.9504514528204661",
      "hi": "0.9847827278785362",
      "hu": "0.9736254607454254"
    },
    "canonical_solution": "    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end",
    "instruction": {
      "en": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Ruby a cikin Hausa ba tare da wuce haruffa 500 ba.",
      "hi": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def digit_sum_to_single(input_string)\n    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8824237254021134",
      "bn": "0.9054402194349122",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9176980975093372",
      "hi": "0.9119288780921788",
      "hu": "0.9320642384480665"
    },
    "level": "",
    "test": "raise 'Test failed' unless digit_sum_to_single(\"35379\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"24815\") == 2\nraise 'Test failed' unless digit_sum_to_single(\"9999\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"12345\") == 6\nraise 'Test failed' unless digit_sum_to_single(\"0\") == 0\n  \n\nputs 'All tests passed!'",
    "entry_point": "digit_sum_to_single",
    "signature": "def digit_sum_to_single(input_string)",
    "docstring": {
      "en": "Computes the repeated sum of digits of a given number string until it reduces to a single digit.\nThe function takes a single argument, `input_string`, which is a string representing a non-negative number.\nIt repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n\nExample:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "sq": "Llogarit shumën e përsëritur të shifrave të një vargu numrash të dhënë derisa të reduktohet në një shifër të vetme. Funksioni merr një argument të vetëm, `input_string`, i cili është një varg që përfaqëson një numër jo-negativ. Ai përsëritësisht mbledh shifrat e numrit derisa shuma të jetë një shifër e vetme, pastaj kthen këtë shifër të vetme.\n\nShembull:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hy": "Հաշվում է տրված թվային տողի թվանշանների կրկնվող գումարը, մինչև այն կրճատվի մեկ թվանշանի:\nՖունկցիան ընդունում է մեկ արգումենտ՝ `input_string`, որը տող է, ներկայացնող ոչ բացասական թիվ:\nԱյն կրկնվող կերպով գումարում է թվանշանները, մինչև գումարը դառնա մեկ թվանշան, ապա վերադարձնում է այդ մեկ թվանշանը:\n\nՕրինակ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "bn": "একটি প্রদত্ত সংখ্যা স্ট্রিংয়ের অঙ্কগুলির পুনরাবৃত্ত যোগফল গণনা করে যতক্ষণ না এটি একটি একক অঙ্কে সংকুচিত হয়। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, `input_string`, যা একটি অ-ঋণাত্মক সংখ্যাকে উপস্থাপন করে এমন একটি স্ট্রিং। \nএটি সংখ্যার অঙ্কগুলির যোগফল বারবার করে যতক্ষণ না যোগফলটি একটি একক অঙ্ক হয়, তারপর এই একক অঙ্কটি ফেরত দেয়।\n\nউদাহরণ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "bg": "Изчислява повторната сума на цифрите на даден низ от числа, докато се намали до едноцифрено число. Функцията приема един аргумент, `input_string`, който е низ, представляващ неотрицателно число. Тя многократно събира цифрите на числото, докато сумата стане едноцифрено число, след което връща това едноцифрено число.\n\nПример:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "zh": "计算给定数字字符串的重复数字和，直到其减少为单个数字。\n该函数接受一个参数 `input_string`，它是一个表示非负数的字符串。\n它重复地对数字的各位求和，直到和为单个数字，然后返回这个单个数字。\n\n示例：\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "fr": "Calcule la somme répétée des chiffres d'une chaîne de caractères numérique donnée jusqu'à ce qu'elle se réduise à un seul chiffre.  \nLa fonction prend un seul argument, `input_string`, qui est une chaîne représentant un nombre non négatif.  \nElle additionne de manière répétée les chiffres du nombre jusqu'à ce que la somme soit un seul chiffre, puis retourne ce chiffre unique.\n\nExemple:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "de": "Berechnet die wiederholte Summe der Ziffern einer gegebenen Zahlenzeichenkette, bis sie auf eine einzelne Ziffer reduziert ist.\nDie Funktion nimmt ein einzelnes Argument, `input_string`, das eine Zeichenkette ist, die eine nicht-negative Zahl darstellt.\nSie summiert wiederholt die Ziffern der Zahl, bis die Summe eine einzelne Ziffer ist, und gibt dann diese einzelne Ziffer zurück.\n\nBeispiel:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "ha": "Yana ƙididdige jimillar maimaita lambobi na wani baƙaƙe na lamba har sai ya ragu zuwa lamba guda ɗaya.\nAikin yana ɗaukar hujja guda, `input_string`, wanda shine baƙaƙe da ke wakiltar lamba mara kyau.\nYana maimaita jimillar lambobin lambar har sai jimillar ta zama lamba guda ɗaya, sannan ya dawo da wannan lamba guda ɗaya.\n\nMisali:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hi": "संख्या स्ट्रिंग के अंकों के बार-बार योग की गणना करता है जब तक कि यह एकल अंक तक न सिमट जाए। \nयह फ़ंक्शन एकल तर्क, `input_string`, लेता है, जो एक गैर-ऋणात्मक संख्या का प्रतिनिधित्व करने वाली स्ट्रिंग है। \nयह संख्या के अंकों का बार-बार योग करता है जब तक कि योग एकल अंक न हो जाए, फिर इस एकल अंक को लौटाता है।\n\nउदाहरण:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hu": "Kiszámítja egy adott számjegy sorozatos összegét, amíg az egyetlen számjegyre nem csökken.\nA függvény egyetlen argumentumot vesz fel, `input_string`, amely egy nem negatív számot reprezentáló karakterlánc.\nIsmételten összegzi a számjegyeket, amíg az összeg egyetlen számjegy nem lesz, majd visszaadja ezt az egyetlen számjegyet.\n\nPélda:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3"
    },
    "docstring_bertscore": {
      "sq": "0.9626749678389721",
      "hy": "0.958957004366761",
      "bn": "0.9737247759359429",
      "bg": "0.9321679235069668",
      "zh": "0.9487023136850729",
      "fr": "0.972170890465107",
      "de": "0.9695789626229827",
      "ha": "0.9603319238642846",
      "hi": "0.9714657526124332",
      "hu": "0.9557332332825648"
    }
  },
  {
    "task_id": "Ruby/17",
    "prompt": {
      "en": "# Calculates the minimum number of seat swaps required to group representatives of the same company together.\n# Given a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\n# the function returns the minimum number of swaps needed so that all representatives of each company are seated together.\n# The input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n#\n# Examples:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "sq": "# Llogarit numrin minimal të ndërrimeve të vendeve të nevojshme për të grupuar përfaqësuesit e së njëjtës kompani së bashku.\n# Duke pasur një varg që përfaqëson një sekuencë vendesh të zëna nga përfaqësues të tre kompanive, A, B, dhe T,\n# funksioni kthen numrin minimal të ndërrimeve të nevojshme që të gjithë përfaqësuesit e secilës kompani të ulen së bashku.\n# Vargu i hyrjes përmban vetëm karakteret 'A', 'B', dhe 'T', dhe secili karakter përfaqëson një vend të zënë nga një përfaqësues nga kompanitë përkatëse.\n#\n# Shembuj:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "hy": "# Հաշվում է նվազագույն նստատեղերի փոխանակումների քանակը, որը պահանջվում է նույն ընկերության ներկայացուցիչներին միասին խմբավորելու համար։\n# Տրված է տող, որը ներկայացնում է երեք ընկերությունների՝ A, B և T ներկայացուցիչների զբաղեցրած նստատեղերի հաջորդականություն,\n# ֆունկցիան վերադարձնում է նվազագույն փոխանակումների քանակը, որպեսզի յուրաքանչյուր ընկերության ներկայացուցիչները նստեն միասին։\n# Մուտքային տողը պարունակում է միայն 'A', 'B' և 'T' սիմվոլները, և յուրաքանչյուր սիմվոլ ներկայացնում է համապատասխան ընկերության ներկայացուցչի զբաղեցրած նստատեղը։\n#\n# Օրինակներ:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "bn": "# একই কোম্পানির প্রতিনিধিদের একসাথে বসানোর জন্য প্রয়োজনীয় সর্বনিম্ন আসন বিনিময়ের সংখ্যা গণনা করে।\n# তিনটি কোম্পানি, A, B, এবং T এর প্রতিনিধিদের দ্বারা দখলকৃত আসনের একটি ক্রম উপস্থাপনকারী একটি স্ট্রিং দেওয়া হয়েছে,\n# ফাংশনটি প্রয়োজনীয় সর্বনিম্ন বিনিময়ের সংখ্যা ফেরত দেয় যাতে প্রতিটি কোম্পানির সমস্ত প্রতিনিধি একসাথে বসে থাকে।\n# ইনপুট স্ট্রিং শুধুমাত্র 'A', 'B', এবং 'T' অক্ষরগুলি ধারণ করে এবং প্রতিটি অক্ষর সংশ্লিষ্ট কোম্পানির প্রতিনিধির দ্বারা দখলকৃত একটি আসনকে উপস্থাপন করে।\n#\n# উদাহরণ:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "bg": "# Изчислява минималния брой размени на места, необходими за групиране на представители на една и съща компания заедно.\n# Даден е низ, представляващ последователност от места, заети от представители на три компании: A, B и T,\n# функцията връща минималния брой размени, необходими, така че всички представители на всяка компания да седят заедно.\n# Входният низ съдържа само символите 'A', 'B' и 'T', като всеки символ представлява място, заето от представител на съответната компания.\n#\n# Примери:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "zh": "# 计算将相同公司代表聚集在一起所需的最小座位交换次数。\n# 给定一个字符串，表示由三家公司 A、B 和 T 的代表占据的座位序列，\n# 该函数返回所需的最小交换次数，以便每个公司的所有代表都坐在一起。\n# 输入字符串仅包含字符 'A'、'B' 和 'T'，每个字符代表相应公司代表占据的一个座位。\n#\n# 例子:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "fr": "# Calcule le nombre minimum d'échanges de sièges nécessaires pour regrouper les représentants de la même entreprise ensemble.\n# Étant donné une chaîne représentant une séquence de sièges occupés par des représentants de trois entreprises, A, B et T,\n# la fonction renvoie le nombre minimum d'échanges nécessaires pour que tous les représentants de chaque entreprise soient assis ensemble.\n# La chaîne d'entrée contient uniquement les caractères 'A', 'B' et 'T', et chaque caractère représente un siège occupé par un représentant des entreprises respectives.\n#\n# Exemples :\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "de": "# Berechnet die minimale Anzahl von Sitzplatzwechseln, die erforderlich sind, um Vertreter desselben Unternehmens zusammen zu gruppieren.\n# Gegeben ist ein String, der eine Sitzfolge darstellt, die von Vertretern dreier Unternehmen, A, B und T, besetzt ist.\n# Die Funktion gibt die minimale Anzahl von Wechseln zurück, die benötigt werden, damit alle Vertreter jedes Unternehmens zusammen sitzen.\n# Der Eingabestring enthält nur die Zeichen 'A', 'B' und 'T', und jedes Zeichen repräsentiert einen Sitzplatz, der von einem Vertreter der jeweiligen Unternehmen eingenommen wird.\n#\n# Beispiele:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "ha": "# Lissafin mafi ƙarancin adadin sauye-sauyen wurin zama da ake buƙata don tara wakilan kamfani guda ɗaya tare.\n# An ba da wani kirtani wanda ke wakiltar jerin kujeru da wakilan kamfanoni guda uku, A, B, da T suka mamaye,\n# aikin yana mayar da mafi ƙarancin adadin sauye-sauyen da ake buƙata don haka duk wakilan kowanne kamfani suna zaune tare.\n# Kirtanin shigarwa yana ƙunshe da haruffa kawai 'A', 'B', da 'T', kuma kowanne harafi yana wakiltar kujera da wakili daga kamfanoni masu dacewa ya ɗauka.\n#\n# Misalai:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "hi": "# एक ही कंपनी के प्रतिनिधियों को एक साथ समूहित करने के लिए आवश्यक न्यूनतम सीट अदला-बदली की गणना करता है।\n# एक स्ट्रिंग दी गई है जो तीन कंपनियों, A, B, और T के प्रतिनिधियों द्वारा कब्जा की गई सीटों का अनुक्रम दर्शाती है,\n# यह फ़ंक्शन न्यूनतम अदला-बदली की संख्या लौटाता है ताकि प्रत्येक कंपनी के सभी प्रतिनिधि एक साथ बैठे हों।\n# इनपुट स्ट्रिंग में केवल 'A', 'B', और 'T' वर्ण होते हैं, और प्रत्येक वर्ण संबंधित कंपनियों के प्रतिनिधि द्वारा ली गई सीट का प्रतिनिधित्व करता है।\n#\n# उदाहरण:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "hu": "# Kiszámítja a minimális számú üléscserét, amely szükséges ahhoz, hogy ugyanazon vállalat képviselői együtt üljenek.\n# Egy karakterláncot kapunk, amely három vállalat, A, B és T képviselői által elfoglalt ülések sorozatát ábrázolja,\n# a függvény visszaadja a minimális számú cserét, amely szükséges ahhoz, hogy minden vállalat képviselői együtt üljenek.\n# A bemeneti karakterlánc csak az 'A', 'B' és 'T' karaktereket tartalmazza, és minden karakter egy adott vállalat képviselője által elfoglalt ülést jelöl.\n#\n# Példák:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)"
    },
    "prompt_bertscore": {
      "sq": "0.967417466816561",
      "hy": "0.9588753672801558",
      "bn": "0.9562546380327814",
      "bg": "0.9660530747292324",
      "zh": "0.9539318543569594",
      "fr": "0.9774624038158765",
      "de": "0.9589476687388524",
      "ha": "0.9460335158854881",
      "hi": "0.9593274500273912",
      "hu": "0.9542180807360306"
    },
    "canonical_solution": "    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end",
    "instruction": {
      "en": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nনিচের রুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\n请为以下 Ruby 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def minimum_swaps_to_group_companies(s)\n    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8794023586761918",
      "bn": "0.8737062352392543",
      "bg": "0.8364486908745768",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9215894653041917",
      "hi": "0.9027873120658102",
      "hu": "0.9433102933614999"
    },
    "level": "",
    "test": "raise 'Test failed' unless minimum_swaps_to_group_companies(\"TABTABBTTTT\") == 3\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"BBTAAT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"AABBBTTT\") == 0\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"ATBT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"TTABAB\") == 1\n  \n\n\n\nputs 'All tests passed!'",
    "entry_point": "minimum_swaps_to_group_companies",
    "signature": "def minimum_swaps_to_group_companies(s)",
    "docstring": {
      "en": "Calculates the minimum number of seat swaps required to group representatives of the same company together.\nGiven a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\nthe function returns the minimum number of swaps needed so that all representatives of each company are seated together.\nThe input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n\nExamples:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "sq": "Llogarit numrin minimal të ndërrimeve të vendeve të nevojshme për të grupuar së bashku përfaqësuesit e së njëjtës kompani.\nDuke pasur një varg që përfaqëson një sekuencë vendesh të zëna nga përfaqësues të tre kompanive, A, B, dhe T,\nfunksioni kthen numrin minimal të ndërrimeve të nevojshme që të gjithë përfaqësuesit e secilës kompani të ulen së bashku.\nVargu i hyrjes përmban vetëm karakteret 'A', 'B', dhe 'T', dhe secili karakter përfaqëson një vend të zënë nga një përfaqësues nga kompanitë përkatëse.\n\nShembuj:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "hy": "Հաշվում է նստատեղերի նվազագույն փոխանակումների քանակը, որը պահանջվում է նույն ընկերության ներկայացուցիչներին միասին խմբավորելու համար:\nՏրված է տող, որը ներկայացնում է երեք ընկերությունների՝ A, B և T ներկայացուցիչների զբաղեցրած նստատեղերի հաջորդականությունը,\nֆունկցիան վերադարձնում է նվազագույն փոխանակումների քանակը, որը պահանջվում է, որպեսզի յուրաքանչյուր ընկերության բոլոր ներկայացուցիչները նստեն միասին:\nՄուտքագրած տողը պարունակում է միայն 'A', 'B' և 'T' նիշերը, և յուրաքանչյուր նիշ ներկայացնում է համապատասխան ընկերությունների ներկայացուցչի զբաղեցրած նստատեղ:\n\nՕրինակներ:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "bn": "একই কোম্পানির প্রতিনিধিদের একসাথে বসানোর জন্য প্রয়োজনীয় সর্বনিম্ন আসন বিনিময় সংখ্যা গণনা করে।\nএকটি স্ট্রিং দেওয়া হয়েছে যা তিনটি কোম্পানি, A, B, এবং T এর প্রতিনিধিদের দ্বারা দখল করা আসনের একটি ক্রম উপস্থাপন করে,\nফাংশনটি প্রয়োজনীয় সর্বনিম্ন বিনিময়ের সংখ্যা ফেরত দেয় যাতে প্রতিটি কোম্পানির সমস্ত প্রতিনিধি একসাথে বসে।\nইনপুট স্ট্রিং শুধুমাত্র 'A', 'B', এবং 'T' অক্ষরগুলি ধারণ করে এবং প্রতিটি অক্ষর সংশ্লিষ্ট কোম্পানির প্রতিনিধির দ্বারা নেওয়া একটি আসন উপস্থাপন করে।\n\nউদাহরণ:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "bg": "Изчислява минималния брой размени на места, необходими за групиране на представители на една и съща компания заедно.\nДаден е низ, представляващ последователност от места, заети от представители на три компании, A, B и T,\nфункцията връща минималния брой размени, необходими, така че всички представители на всяка компания да бъдат седнали заедно.\nВходният низ съдържа само символите 'A', 'B' и 'T', и всеки символ представлява място, заето от представител на съответната компания.\n\nПримери:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "zh": "计算将同一公司的代表聚集在一起所需的最少座位交换次数。\n给定一个字符串，表示由三家公司 A、B 和 T 的代表占据的座位序列，\n该函数返回所需的最少交换次数，以便每个公司的所有代表都坐在一起。\n输入字符串仅包含字符 'A'、'B' 和 'T'，每个字符代表一个由相应公司代表占据的座位。\n\n示例：\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "fr": "Calcule le nombre minimum d'échanges de sièges nécessaires pour regrouper les représentants de la même entreprise ensemble.\nÉtant donné une chaîne représentant une séquence de sièges occupés par des représentants de trois entreprises, A, B et T,\nla fonction renvoie le nombre minimum d'échanges nécessaires pour que tous les représentants de chaque entreprise soient assis ensemble.\nLa chaîne d'entrée contient uniquement les caractères 'A', 'B' et 'T', et chaque caractère représente un siège occupé par un représentant des entreprises respectives.\n\nExemples :\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "de": "Berechnet die minimale Anzahl von Sitzplatzwechseln, die erforderlich sind, um Vertreter desselben Unternehmens zusammen zu gruppieren.\nGegeben ist ein String, der eine Sitzreihe darstellt, die von Vertretern dreier Unternehmen, A, B und T, besetzt ist. \nDie Funktion gibt die minimale Anzahl von Wechseln zurück, die erforderlich sind, damit alle Vertreter jedes Unternehmens zusammen sitzen.\nDer Eingabestring enthält nur die Zeichen 'A', 'B' und 'T', und jedes Zeichen repräsentiert einen von einem Vertreter der jeweiligen Unternehmen besetzten Sitz.\n\nBeispiele:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "ha": "Yana ƙididdige mafi ƙarancin adadin musayar kujeru da ake buƙata don tara wakilai na kamfani ɗaya tare.\nAn ba da wata kirtani da ke wakiltar jerin kujeru da wakilan kamfanoni uku, A, B, da T suka mamaye,\naikin yana dawo da mafi ƙarancin adadin musayar da ake buƙata don duk wakilan kowane kamfani su zauna tare.\nKirtanin shigarwa yana ƙunshe da haruffa 'A', 'B', da 'T' kawai, kuma kowanne hali yana wakiltar kujera da wakili daga kamfanonin da suka dace ya ɗauka.\n\nMisalai:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "hi": "प्रतिनिधियों को एक ही कंपनी के साथ समूहबद्ध करने के लिए आवश्यक न्यूनतम सीट अदला-बदली की गणना करता है। तीन कंपनियों, A, B, और T के प्रतिनिधियों द्वारा कब्जा की गई सीटों के अनुक्रम का प्रतिनिधित्व करने वाले एक स्ट्रिंग को दिया गया है, यह फ़ंक्शन आवश्यक न्यूनतम अदला-बदली की संख्या लौटाता है ताकि प्रत्येक कंपनी के सभी प्रतिनिधि एक साथ बैठे हों। इनपुट स्ट्रिंग में केवल 'A', 'B', और 'T' वर्ण होते हैं, और प्रत्येक वर्ण संबंधित कंपनियों के प्रतिनिधि द्वारा ली गई एक सीट का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "hu": "Kiszámítja a minimálisan szükséges helycserék számát annak érdekében, hogy az azonos vállalat képviselői egymás mellett üljenek.\nEgy karakterláncot kapunk, amely három vállalat, A, B és T képviselői által elfoglalt ülések sorozatát jelöli,\na függvény visszaadja a szükséges minimális helycserék számát, hogy minden vállalat képviselői egymás mellett üljenek.\nA bemeneti karakterlánc csak az 'A', 'B' és 'T' karaktereket tartalmazza, és minden karakter egy adott vállalat képviselője által elfoglalt ülést jelöl.\n\nPéldák:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1"
    },
    "docstring_bertscore": {
      "sq": "0.9704791555098329",
      "hy": "0.933962946260379",
      "bn": "0.9505332885374524",
      "bg": "0.9671455418249243",
      "zh": "0.9578027632225673",
      "fr": "0.9696669558817812",
      "de": "0.9559213362534048",
      "ha": "0.9548268828539026",
      "hi": "0.9817708954109041",
      "hu": "0.9564786931025887"
    }
  },
  {
    "task_id": "Ruby/18",
    "prompt": {
      "en": "# Calculates the final minimum weight of fish in a simulated feeding game.\n# In this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\n# The game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\n# and its weight becomes the sum of both. The function returns the weight of the lightest fish\n# after 'm' rounds.\n#\n# Arguments:\n# n (Integer) -- The number of fish.\n# m (Integer) -- The number of rounds the game will be played.\n# weights (Array of Integers) -- An array representing the weights of each fish.\n#\n# Example:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "sq": "# Llogarit peshën minimale përfundimtare të peshkut në një lojë të simuluar ushqimi.\n# Në këtë lojë, ka 'n' peshq, secili me një peshë fillestare të dhënë në vargun 'weights'.\n# Loja vazhdon për 'm' raunde. Në secilin raund, peshku më i lehtë ha të dytin më të lehtë,\n# dhe pesha e tij bëhet shuma e të dyjave. Funksioni kthen peshën e peshkut më të lehtë\n# pas 'm' raundeve.\n#\n# Argumentet:\n# n (Integer) -- Numri i peshqve.\n# m (Integer) -- Numri i raundeve që loja do të luhet.\n# weights (Array of Integers) -- Një varg që përfaqëson peshat e secilit peshk.\n#\n# Shembull:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "hy": "# Հաշվում է ձկների վերջնական նվազագույն քաշը սիմուլացված կերակրման խաղում:\n# Այս խաղում կա 'n' ձուկ, որոնցից յուրաքանչյուրը ունի սկզբնական քաշ, որը տրված է 'weights' զանգվածում:\n# Խաղը շարունակվում է 'm' փուլերի համար: Յուրաքանչյուր փուլում ամենաթեթև ձուկը ուտում է երկրորդ ամենաթեթևին,\n# և նրա քաշը դառնում է երկուսի գումարը: Ֆունկցիան վերադարձնում է ամենաթեթև ձկան քաշը\n# 'm' փուլերից հետո:\n#\n# Արգումենտներ:\n# n (Integer) -- Ձկների քանակը:\n# m (Integer) -- Փուլերի քանակը, որոնք խաղը կխաղարկվի:\n# weights (Array of Integers) -- Զանգված, որը ներկայացնում է յուրաքանչյուր ձկան քաշը:\n#\n# Օրինակ:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "bn": "# একটি সিমুলেটেড খাদ্য খেলার মধ্যে মাছের চূড়ান্ত সর্বনিম্ন ওজন গণনা করে।\n# এই খেলায়, 'n' টি মাছ আছে, প্রতিটি মাছের প্রাথমিক ওজন 'weights' অ্যারেতে দেওয়া আছে।\n# খেলা 'm' রাউন্ডের জন্য চলে। প্রতিটি রাউন্ডে, সবচেয়ে হালকা মাছ দ্বিতীয় সবচেয়ে হালকা মাছকে খায়,\n# এবং তার ওজন উভয়ের যোগফল হয়ে যায়। ফাংশনটি 'm' রাউন্ডের পরে সবচেয়ে হালকা মাছের ওজন ফেরত দেয়।\n#\n# আর্গুমেন্টসমূহ:\n# n (পূর্ণসংখ্যা) -- মাছের সংখ্যা।\n# m (পূর্ণসংখ্যা) -- খেলা কত রাউন্ড খেলা হবে।\n# weights (পূর্ণসংখ্যার অ্যারে) -- প্রতিটি মাছের ওজনের প্রতিনিধিত্বকারী একটি অ্যারে।\n#\n# উদাহরণ:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "bg": "# Изчислява крайната минимална тежест на рибата в симулирана игра на хранене.\n# В тази игра има 'n' риби, всяка с начална тежест, дадена в масива 'weights'.\n# Играта продължава 'm' рунда. Във всеки рунд най-леката риба изяжда втората най-лека,\n# и нейната тежест става сумата от двете. Функцията връща тежестта на най-леката риба\n# след 'm' рунда.\n#\n# Аргументи:\n# n (Цяло число) -- Броят на рибите.\n# m (Цяло число) -- Броят на рундовете, които ще се играят.\n# weights (Масив от цели числа) -- Масив, представляващ тежестите на всяка риба.\n#\n# Пример:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "zh": "# 计算模拟喂食游戏中鱼的最终最小重量。\n# 在这个游戏中，有'n'条鱼，每条鱼的初始重量在'weights'数组中给出。\n# 游戏进行'm'轮。在每一轮中，最轻的鱼吃掉第二轻的鱼，\n# 它的重量变成两者之和。函数返回'm'轮后最轻鱼的重量。\n#\n# 参数:\n# n (Integer) -- 鱼的数量。\n# m (Integer) -- 游戏进行的轮数。\n# weights (Array of Integers) -- 一个数组，表示每条鱼的重量。\n#\n# 示例:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "fr": "# Calcule le poids minimum final des poissons dans un jeu de simulation d'alimentation.\n# Dans ce jeu, il y a 'n' poissons, chacun avec un poids initial donné dans le tableau 'weights'.\n# Le jeu se déroule pendant 'm' tours. À chaque tour, le poisson le plus léger mange le deuxième plus léger,\n# et son poids devient la somme des deux. La fonction retourne le poids du poisson le plus léger\n# après 'm' tours.\n#\n# Arguments:\n# n (Integer) -- Le nombre de poissons.\n# m (Integer) -- Le nombre de tours pendant lesquels le jeu sera joué.\n# weights (Array of Integers) -- Un tableau représentant les poids de chaque poisson.\n#\n# Exemple:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "de": "# Berechnet das endgültige Mindestgewicht der Fische in einem simulierten Fütterungsspiel.\n# In diesem Spiel gibt es 'n' Fische, jeder mit einem Anfangsgewicht, das im 'weights'-Array angegeben ist.\n# Das Spiel läuft über 'm' Runden. In jeder Runde frisst der leichteste Fisch den zweitleichtesten,\n# und sein Gewicht wird zur Summe beider. Die Funktion gibt das Gewicht des leichtesten Fisches\n# nach 'm' Runden zurück.\n#\n# Argumente:\n# n (Integer) -- Die Anzahl der Fische.\n# m (Integer) -- Die Anzahl der Runden, die das Spiel gespielt wird.\n# weights (Array von Integern) -- Ein Array, das die Gewichte jedes Fisches darstellt.\n#\n# Beispiel:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "ha": "# Lissafin ƙarshen mafi ƙarancin nauyin kifi a cikin wasan ciyarwa na kwaikwayo.\n# A cikin wannan wasan, akwai 'n' kifi, kowanne da nauyin farko da aka bayar a cikin jerin 'weights'.\n# Wasan yana ci gaba na 'm' zagaye. A kowanne zagaye, mafi ƙarancin kifi yana cin na biyu mafi ƙaranci,\n# kuma nauyinsa ya zama jimlar duka biyun. Aikin yana dawowa da nauyin mafi ƙarancin kifi\n# bayan 'm' zagaye.\n#\n# Huɗɗa:\n# n (Lamba) -- Yawan kifaye.\n# m (Lamba) -- Yawan zagayen da za a buga wasan.\n# weights (Jerin Lambobi) -- Jerin da ke wakiltar nauyin kowanne kifi.\n#\n# Misali:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "hi": "# एक सिम्युलेटेड फीडिंग गेम में मछलियों के अंतिम न्यूनतम वजन की गणना करता है।\n# इस खेल में, 'n' मछलियाँ हैं, जिनमें से प्रत्येक का प्रारंभिक वजन 'weights' array में दिया गया है।\n# खेल 'm' राउंड के लिए चलता है। प्रत्येक राउंड में, सबसे हल्की मछली दूसरी सबसे हल्की मछली को खा जाती है,\n# और उसका वजन दोनों का योग बन जाता है। यह फ़ंक्शन 'm' राउंड के बाद सबसे हल्की मछली का वजन लौटाता है।\n#\n# तर्क:\n# n (पूर्णांक) -- मछलियों की संख्या।\n# m (पूर्णांक) -- खेल कितने राउंड खेला जाएगा।\n# weights (पूर्णांकों की array) -- प्रत्येक मछली के वजन को दर्शाने वाली array।\n#\n# उदाहरण:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "hu": "# Kiszámítja a halak végső minimális súlyát egy szimulált etetési játékban.\n# Ebben a játékban 'n' hal van, mindegyik kezdeti súlya a 'weights' tömbben van megadva.\n# A játék 'm' fordulóból áll. Minden fordulóban a legkönnyebb hal megeszi a második legkönnyebbet,\n# és a súlya mindkettő összegévé válik. A függvény visszaadja a legkönnyebb hal súlyát\n# 'm' forduló után.\n#\n# Argumentumok:\n# n (Egész szám) -- A halak száma.\n# m (Egész szám) -- A játék során játszott fordulók száma.\n# weights (Egész számok tömbje) -- Egy tömb, amely az egyes halak súlyát reprezentálja.\n#\n# Példa:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)"
    },
    "prompt_bertscore": {
      "sq": "0.9935981428192455",
      "hy": "0.9853972902774581",
      "bn": "0.9757502099313556",
      "bg": "0.980517537706574",
      "zh": "0.9690498112879058",
      "fr": "0.9768524099157183",
      "de": "0.9919246818590266",
      "ha": "0.942018997254392",
      "hi": "0.9732285972441178",
      "hu": "0.9795486187078858"
    },
    "canonical_solution": "  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend",
    "instruction": {
      "en": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nনিচের Ruby কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки най-много 500 знака.",
      "zh": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\n请为以下 Ruby 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def final_min_weight_fish(m, weights)\n  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.9252859766952509",
      "bn": "0.8737062352392543",
      "bg": "0.9081133871028797",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9171840420832189",
      "hi": "0.9119288780921788",
      "hu": "0.9226231378070973"
    },
    "level": "",
    "test": "raise 'Test failed' unless final_min_weight_fish(1, [1, 2, 3]) == 3\nraise 'Test failed' unless final_min_weight_fish(2, [4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [5, 4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [3, 2, 1]) == 6\nraise 'Test failed' unless final_min_weight_fish(3, [1, 2, 3, 4]) == 10\n  \nputs 'All tests passed!'",
    "entry_point": "final_min_weight_fish",
    "signature": "def final_min_weight_fish(m, weights)",
    "docstring": {
      "en": "Calculates the final minimum weight of fish in a simulated feeding game.\nIn this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\nThe game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\nand its weight becomes the sum of both. The function returns the weight of the lightest fish\nafter 'm' rounds.\n\nArguments:\nn (Integer) -- The number of fish.\nm (Integer) -- The number of rounds the game will be played.\nweights (Array of Integers) -- An array representing the weights of each fish.\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "sq": "Llogarit peshën përfundimtare minimale të peshkut në një lojë të simuluar ushqimi.\nNë këtë lojë, ka 'n' peshq, secili me një peshë fillestare të dhënë në vargun 'weights'.\nLoja vazhdon për 'm' raunde. Në çdo raund, peshku më i lehtë ha të dytin më të lehtë,\ndhe pesha e tij bëhet shuma e të dyve. Funksioni kthen peshën e peshkut më të lehtë\npas 'm' raundeve.\n\nArgumentet:\nn (Integer) -- Numri i peshqve.\nm (Integer) -- Numri i raundeve që loja do të luhet.\nweights (Array of Integers) -- Një varg që përfaqëson peshat e secilit peshk.\n\nShembull:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hy": "Հաշվում է ձկների վերջնական նվազագույն քաշը սիմուլացված կերակրման խաղում:\nԱյս խաղում կա 'n' ձուկ, որոնցից յուրաքանչյուրն ունի սկզբնական քաշ, որը տրված է 'weights' զանգվածում:\nԽաղը ընթանում է 'm' փուլերի ընթացքում: Յուրաքանչյուր փուլում ամենաթեթև ձուկը ուտում է երկրորդ ամենաթեթևին,\nև նրա քաշը դառնում է երկուսի գումարը: Ֆունկցիան վերադարձնում է ամենաթեթև ձկան քաշը\n'm' փուլերից հետո:\n\nԱրգումենտներ:\nn (Integer) -- Ձկների քանակը:\nm (Integer) -- Փուլերի քանակը, որ խաղը կխաղարկվի:\nweights (Array of Integers) -- Զանգված, որը ներկայացնում է յուրաքանչյուր ձկան քաշը:\n\nՕրինակ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "bn": "মাছের একটি সিমুলেটেড খাওয়ানোর খেলায় চূড়ান্ত ন্যূনতম ওজন গণনা করে। \nএই খেলায়, 'n' সংখ্যক মাছ আছে, প্রতিটির প্রাথমিক ওজন 'weights' অ্যারেতে দেওয়া আছে। \nখেলা 'm' রাউন্ডের জন্য চলে। প্রতিটি রাউন্ডে, সবচেয়ে হালকা মাছ দ্বিতীয় সবচেয়ে হালকা মাছকে খায়, \nএবং তার ওজন উভয়ের যোগফল হয়ে যায়। ফাংশনটি 'm' রাউন্ডের পরে সবচেয়ে হালকা মাছের ওজন ফেরত দেয়।\n\nআর্গুমেন্টসমূহ:\nn (পূর্ণসংখ্যা) -- মাছের সংখ্যা।\nm (পূর্ণসংখ্যা) -- খেলা কত রাউন্ড খেলা হবে।\nweights (পূর্ণসংখ্যার অ্যারে) -- প্রতিটি মাছের ওজন উপস্থাপনকারী একটি অ্যারে।\n\nউদাহরণ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "bg": "Изчислява крайната минимална тежест на рибата в симулирана игра на хранене. В тази игра има 'n' риби, всяка с начална тежест, дадена в масива 'weights'. Играта продължава 'm' рунда. Във всеки рунд най-леката риба изяжда втората най-лека и нейната тежест става сумата от двете. Функцията връща тежестта на най-леката риба след 'm' рунда.\n\nАргументи:\nn (Цяло число) -- Броят на рибите.\nm (Цяло число) -- Броят на рундовете, в които ще се играе играта.\nweights (Масив от цели числа) -- Масив, представляващ тежестите на всяка риба.\n\nПример:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "zh": "计算模拟喂食游戏中鱼的最终最小重量。\n在这个游戏中，有 'n' 条鱼，每条鱼的初始重量在 'weights' 数组中给出。  \n游戏进行 'm' 轮。在每一轮中，最轻的鱼吃掉第二轻的鱼，其重量变为两者之和。  \n该函数返回 'm' 轮后最轻鱼的重量。\n\n参数：\nn (Integer) -- 鱼的数量。  \nm (Integer) -- 游戏进行的轮数。  \nweights (Array of Integers) -- 一个数组，表示每条鱼的重量。\n\n示例：\n>>> final_min_weight_fish(1, [1, 2, 3])  \n3  \n>>> final_min_weight_fish(2, [4, 3, 2, 1])  \n4  ",
      "fr": "Calcule le poids minimum final des poissons dans un jeu de simulation d'alimentation.\nDans ce jeu, il y a 'n' poissons, chacun avec un poids initial donné dans le tableau 'weights'.\nLe jeu se déroule sur 'm' tours. À chaque tour, le poisson le plus léger mange le deuxième plus léger,\net son poids devient la somme des deux. La fonction renvoie le poids du poisson le plus léger\naprès 'm' tours.\n\nArguments:\nn (Integer) -- Le nombre de poissons.\nm (Integer) -- Le nombre de tours pendant lesquels le jeu sera joué.\nweights (Array of Integers) -- Un tableau représentant les poids de chaque poisson.\n\nExemple:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "de": "Berechnet das endgültige Mindestgewicht der Fische in einem simulierten Fütterungsspiel. In diesem Spiel gibt es 'n' Fische, jeder mit einem Anfangsgewicht, das im 'weights'-Array angegeben ist. Das Spiel verläuft über 'm' Runden. In jeder Runde frisst der leichteste Fisch den zweitleichtesten, und sein Gewicht wird zur Summe beider. Die Funktion gibt das Gewicht des leichtesten Fisches nach 'm' Runden zurück.\n\nArgumente:\nn (Integer) -- Die Anzahl der Fische.\nm (Integer) -- Die Anzahl der Runden, die das Spiel gespielt wird.\nweights (Array von Integern) -- Ein Array, das die Gewichte jedes Fisches darstellt.\n\nBeispiel:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "ha": "Lissafi na karshe na mafi karancin nauyin kifi a cikin wani wasan ciyarwa na kwaikwayo.\nA cikin wannan wasan, akwai 'n' kifi, kowanne da nauyin farko da aka bayar a cikin jerin 'weights'.\nWasan yana gudana har na tsawon zagaye 'm'. A kowane zagaye, mafi saukin kifi yana cin na biyu mafi sauki,\nkuma nauyinsa yana zama jimlar duka biyun. Aikin yana dawowa da nauyin mafi saukin kifi\nbayan zagaye 'm'.\n\nArguments:\nn (Integer) -- Yawan kifaye.\nm (Integer) -- Yawan zagayen da za a yi wasan.\nweights (Array of Integers) -- Jerin da ke wakiltar nauyin kowanne kifi.\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hi": "एक सिम्युलेटेड फीडिंग गेम में मछलियों के अंतिम न्यूनतम वजन की गणना करता है।\nइस खेल में, 'n' मछलियाँ हैं, प्रत्येक की प्रारंभिक वजन 'weights' array में दी गई है। खेल 'm' राउंड के लिए चलता है। प्रत्येक राउंड में, सबसे हल्की मछली दूसरी सबसे हल्की मछली को खाती है, और उसका वजन दोनों का योग बन जाता है। यह फ़ंक्शन 'm' राउंड के बाद सबसे हल्की मछली का वजन लौटाता है।\n\nArguments:\nn (Integer) -- मछलियों की संख्या।\nm (Integer) -- खेल कितने राउंड खेला जाएगा।\nweights (Array of Integers) -- प्रत्येक मछली के वजन को दर्शाने वाला एक array।\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hu": "Kiszámítja a halak végső minimális súlyát egy szimulált etetési játékban.\nEbben a játékban 'n' hal van, mindegyik kezdeti súlya a 'weights' tömbben van megadva.\nA játék 'm' fordulón keresztül zajlik. Minden fordulóban a legkönnyebb hal megeszi a második legkönnyebbet,\nés a súlya mindkettő összegévé válik. A függvény visszaadja a legkönnyebb hal súlyát 'm' forduló után.\n\nArgumentumok:\nn (Egész szám) -- A halak száma.\nm (Egész szám) -- A játék fordulóinak száma.\nweights (Egész számok tömbje) -- Egy tömb, amely az egyes halak súlyát ábrázolja.\n\nPélda:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9908538654748675",
      "hy": "0.9768103002749389",
      "bn": "0.971851890073165",
      "bg": "0.9781268224404381",
      "zh": "0.9636567978124275",
      "fr": "0.9770458759068462",
      "de": "0.9888522671251789",
      "ha": "0.9762712174208101",
      "hi": "0.9570298924099606",
      "hu": "0.9845060357577545"
    }
  },
  {
    "task_id": "Ruby/19",
    "prompt": {
      "en": "# Sorts a list of patient information based on their age and registration order.\n# The function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\n# The sorting criteria are as follows:\n# 1. Patients aged 60 and above are given priority over younger patients.\n# 2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n# 3. Younger patients (below 60) are sorted based on their registration order.\n#\n# Example:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "sq": "# Rregullon një listë të informacionit të pacientëve bazuar në moshën dhe rendin e regjistrimit të tyre.\n# Funksioni merr një varg të vargjeve, ku secili nën-varg përmban ID-në e pacientit (një varg) dhe moshën (një numër i plotë).\n# Kriteret e renditjes janë si më poshtë:\n# 1. Pacientët e moshës 60 vjeç e lart kanë përparësi mbi pacientët më të rinj.\n# 2. Pacientët e moshuar (të moshës 60+) renditen në rend zbritës të moshës. Nëse moshat janë të barabarta, ata renditen sipas rendit të regjistrimit.\n# 3. Pacientët më të rinj (nën 60 vjeç) renditen bazuar në rendin e regjistrimit të tyre.\n#\n# Shembull:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "hy": "# Տեսակավորում է հիվանդների տեղեկատվության ցուցակը ըստ նրանց տարիքի և գրանցման կարգի:\n# Ֆունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված պարունակում է հիվանդի ID (տող) և տարիքը (ամբողջ թիվ):\n# Տեսակավորման չափանիշներն են հետևյալը:\n# 1. 60 և ավելի բարձր տարիքի հիվանդները առաջնահերթություն ունեն ավելի երիտասարդ հիվանդների նկատմամբ:\n# 2. Տարեց հիվանդները (60+) տեսակավորվում են ըստ տարիքի նվազման կարգով: Եթե տարիքները հավասար են, ապա տեսակավորվում են ըստ գրանցման կարգի:\n# 3. Ավելի երիտասարդ հիվանդները (60-ից ցածր) տեսակավորվում են ըստ գրանցման կարգի:\n#\n# Օրինակ:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "bn": "# রোগীর তথ্যের একটি তালিকা তাদের বয়স এবং নিবন্ধন ক্রমের উপর ভিত্তি করে সাজায়।\n# ফাংশনটি একটি অ্যারের অ্যারে নেয়, যেখানে প্রতিটি উপ-অ্যারে একটি রোগীর আইডি (একটি স্ট্রিং) এবং বয়স (একটি পূর্ণসংখ্যা) থাকে।\n# বাছাইয়ের মানদণ্ড নিম্নরূপ:\n# 1. ৬০ এবং তার বেশি বয়সী রোগীদের অগ্রাধিকার দেওয়া হয় অপেক্ষাকৃত কম বয়সী রোগীদের উপর।\n# 2. বয়স্ক রোগীদের (বয়স ৬০+) বয়সের অবরোহ ক্রমে সাজানো হয়। যদি বয়স সমান হয়, তাহলে তাদের নিবন্ধন ক্রম অনুযায়ী সাজানো হয়।\n# 3. অপেক্ষাকৃত কম বয়সী রোগীদের (৬০ এর নিচে) তাদের নিবন্ধন ক্রম অনুযায়ী সাজানো হয়।\n#\n# উদাহরণ:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "bg": "# Сортира списък с информация за пациенти на базата на тяхната възраст и ред на регистрация.\n# Функцията приема масив от масиви, където всеки подмасив съдържа ID на пациент (низ) и възраст (цяло число).\n# Критериите за сортиране са следните:\n# 1. Пациентите на възраст 60 и повече години имат приоритет пред по-младите пациенти.\n# 2. Възрастните пациенти (на 60+ години) се сортират в низходящ ред по възраст. Ако възрастите са равни, те се сортират по ред на регистрация.\n# 3. По-младите пациенти (под 60 години) се сортират на базата на реда на регистрация.\n#\n# Пример:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "zh": "# 根据患者的年龄和注册顺序对患者信息列表进行排序。\n# 该函数接受一个数组的数组，其中每个子数组包含患者的ID（字符串）和年龄（整数）。\n# 排序标准如下：\n# 1. 年龄在60岁及以上的患者优先于年轻患者。\n# 2. 老年患者（年龄60岁及以上）按年龄降序排序。如果年龄相同，则按注册顺序排序。\n# 3. 年轻患者（年龄低于60岁）按注册顺序排序。\n#\n# 示例:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "fr": "# Trie une liste d'informations sur les patients en fonction de leur âge et de leur ordre d'enregistrement.\n# La fonction prend un tableau de tableaux, où chaque sous-tableau contient l'ID d'un patient (une chaîne) et l'âge (un entier).\n# Les critères de tri sont les suivants :\n# 1. Les patients âgés de 60 ans et plus sont prioritaires par rapport aux patients plus jeunes.\n# 2. Les patients âgés (60 ans et plus) sont triés par ordre décroissant d'âge. Si les âges sont égaux, ils sont triés par leur ordre d'enregistrement.\n# 3. Les patients plus jeunes (moins de 60 ans) sont triés en fonction de leur ordre d'enregistrement.\n#\n# Exemple :\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "de": "# Sortiert eine Liste von Patienteninformationen basierend auf ihrem Alter und ihrer Registrierungsreihenfolge.\n# Die Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die ID eines Patienten (ein String) und das Alter (ein Integer) enthält.\n# Die Sortierkriterien sind wie folgt:\n# 1. Patienten im Alter von 60 und älter haben Vorrang vor jüngeren Patienten.\n# 2. Ältere Patienten (ab 60 Jahren) werden in absteigender Reihenfolge ihres Alters sortiert. Wenn das Alter gleich ist, werden sie nach ihrer Registrierungsreihenfolge sortiert.\n# 3. Jüngere Patienten (unter 60 Jahren) werden basierend auf ihrer Registrierungsreihenfolge sortiert.\n#\n# Beispiel:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "ha": "# Tana tsara jerin bayanan marasa lafiya bisa ga shekarunsu da kuma tsarin rijista.\n# Aikin yana daukar jerin jerin, inda kowace ƙananan jeri ke dauke da ID na mara lafiya (kirtani) da shekaru (lamba).\n# Ka'idojin tsarawa sune kamar haka:\n# 1. Marasa lafiya masu shekaru 60 da sama suna da fifiko akan marasa lafiya masu ƙuruciya.\n# 2. Marasa lafiya tsofaffi (masu shekaru 60+) suna tsarawa a cikin tsarin raguwa na shekaru. Idan shekarun sun yi daidai, ana tsarasu bisa tsarin rijistarsu.\n# 3. Marasa lafiya masu ƙuruciya (ƙasa da shekaru 60) suna tsarawa bisa tsarin rijistarsu.\n#\n# Misali:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "hi": "# रोगियों की जानकारी की सूची को उनकी आयु और पंजीकरण क्रम के आधार पर क्रमबद्ध करता है।\n# यह फ़ंक्शन एक सरणी का सरणी लेता है, जहाँ प्रत्येक उप-सरणी में एक रोगी की आईडी (एक स्ट्रिंग) और आयु (एक पूर्णांक) होती है।\n# क्रमबद्ध करने के मापदंड निम्नलिखित हैं:\n# 1. 60 वर्ष और उससे अधिक आयु के रोगियों को छोटे रोगियों पर प्राथमिकता दी जाती है।\n# 2. वृद्ध रोगियों (60+ आयु) को आयु के अवरोही क्रम में क्रमबद्ध किया जाता है। यदि आयु समान है, तो उन्हें उनके पंजीकरण क्रम के अनुसार क्रमबद्ध किया जाता है।\n# 3. छोटे रोगियों (60 से कम आयु) को उनके पंजीकरण क्रम के अनुसार क्रमबद्ध किया जाता है।\n#\n# उदाहरण:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "hu": "# Egy listát rendez a betegek adatai alapján életkoruk és regisztrációs sorrendjük szerint.\n# A függvény egy tömbök tömbjét veszi át, ahol minden al-tömb egy beteg azonosítóját (egy string) és életkorát (egy egész szám) tartalmazza.\n# A rendezési kritériumok a következők:\n# 1. A 60 éves és idősebb betegek elsőbbséget élveznek a fiatalabb betegekkel szemben.\n# 2. Az idős betegek (60+) életkoruk szerint csökkenő sorrendben vannak rendezve. Ha az életkorok megegyeznek, a regisztrációs sorrendjük szerint vannak rendezve.\n# 3. A fiatalabb betegek (60 év alatt) a regisztrációs sorrendjük alapján vannak rendezve.\n#\n# Példa:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)"
    },
    "prompt_bertscore": {
      "sq": "0.9870993540125461",
      "hy": "0.9730379120783242",
      "bn": "0.9884093213754712",
      "bg": "0.9742743862002664",
      "zh": "0.9707453202204196",
      "fr": "0.9876219505450489",
      "de": "0.9735285291194804",
      "ha": "0.9558009662424977",
      "hi": "0.9738042280883569",
      "hu": "0.9863491270633773"
    },
    "canonical_solution": "    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end",
    "instruction": {
      "en": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nনিচের Ruby কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\n请为以下 Ruby 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def sort_patients(patient_info)\n    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9362996340628734",
      "hy": "0.9374465258829688",
      "bn": "0.8673498644157568",
      "bg": "0.8364486908745768",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9531146889693819",
      "hi": "0.9119288780921788",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]]) == [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\nraise 'Test failed' unless sort_patients([[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]) == [[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]\nraise 'Test failed' unless sort_patients([[\"987654\", 45], [\"123456\", 65], [\"543210\", 55]]) == [[\"123456\", 65], [\"987654\", 45], [\"543210\", 55]]\n\n\n\nputs 'All tests passed!'",
    "entry_point": "sort_patients",
    "signature": "def sort_patients(patient_info)",
    "docstring": {
      "en": "Sorts a list of patient information based on their age and registration order.\nThe function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\nThe sorting criteria are as follows:\n1. Patients aged 60 and above are given priority over younger patients.\n2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n3. Younger patients (below 60) are sorted based on their registration order.\n\nExample:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "sq": "Rendit një listë të informacionit të pacientëve bazuar në moshën dhe rendin e regjistrimit të tyre. Funksioni merr një varg vargjesh, ku çdo nën-varg përmban ID-në e pacientit (një varg) dhe moshën (një numër i plotë). Kriteret e renditjes janë si më poshtë: \n1. Pacientët e moshës 60 vjeç e lart kanë përparësi mbi pacientët më të rinj. \n2. Pacientët e moshuar (60+ vjeç) renditen në rend zbritës sipas moshës. Nëse moshat janë të barabarta, ata renditen sipas rendit të regjistrimit të tyre. \n3. Pacientët më të rinj (nën 60 vjeç) renditen bazuar në rendin e regjistrimit të tyre.\n\nShembull:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hy": "Դասավորում է հիվանդների տեղեկատվության ցուցակը՝ հիմնված նրանց տարիքին և գրանցման կարգին:\nՖունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված պարունակում է հիվանդի ID (տող) և տարիքը (ամբողջ թիվ):\nԴասավորման չափանիշներն են հետևյալը.\n1. 60 և ավելի բարձր տարիքի հիվանդները առաջնահերթություն են ստանում ավելի երիտասարդ հիվանդների նկատմամբ:\n2. Տարեց հիվանդները (60+ տարեկան) դասավորվում են ըստ տարիքային նվազման կարգի: Եթե տարիքները հավասար են, ապա նրանք դասավորվում են ըստ իրենց գրանցման կարգի:\n3. Ավելի երիտասարդ հիվանդները (60-ից ցածր) դասավորվում են ըստ իրենց գրանցման կարգի:\n\nՕրինակ:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "bn": "রোগীর তথ্যের একটি তালিকা তাদের বয়স এবং নিবন্ধন ক্রম অনুযায়ী সাজায়।\nফাংশনটি একটি অ্যারের অ্যারে নেয়, যেখানে প্রতিটি উপ-অ্যারে একটি রোগীর আইডি (একটি স্ট্রিং) এবং বয়স (একটি পূর্ণসংখ্যা) থাকে।\nসাজানোর মানদণ্ড নিম্নরূপ:\n1. ৬০ বছর বা তার বেশি বয়সের রোগীদের কম বয়সী রোগীদের তুলনায় অগ্রাধিকার দেওয়া হয়।\n2. বয়স্ক রোগীদের (বয়স ৬০+) বয়সের অবরোহ ক্রমে সাজানো হয়। যদি বয়স সমান হয়, তবে তাদের নিবন্ধন ক্রম অনুযায়ী সাজানো হয়।\n3. কম বয়সী রোগীদের (৬০ বছরের নিচে) তাদের নিবন্ধন ক্রম অনুযায়ী সাজানো হয়।\n\nউদাহরণ:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "bg": "Сортира списък с информация за пациенти въз основа на тяхната възраст и ред на регистрация. \nФункцията приема масив от масиви, където всеки подмасив съдържа ID на пациент (низ) и възраст (цяло число). \nКритериите за сортиране са следните: \n1. Пациентите на възраст 60 и повече години имат приоритет пред по-младите пациенти. \n2. Възрастните пациенти (на 60+ години) се сортират в низходящ ред по възраст. Ако възрастите са равни, те се сортират по реда на регистрация. \n3. По-младите пациенти (под 60 години) се сортират въз основа на реда на регистрация.\n\nПример:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "zh": "根据患者的年龄和注册顺序对患者信息列表进行排序。\n该函数接受一个数组的数组，其中每个子数组包含一个患者的ID（字符串）和年龄（整数）。\n排序标准如下：\n1. 年龄在60岁及以上的患者优先于年轻患者。\n2. 老年患者（60岁及以上）按年龄降序排序。如果年龄相同，则按注册顺序排序。\n3. 年轻患者（60岁以下）按注册顺序排序。\n\n示例：\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "fr": "Trie une liste d'informations sur les patients en fonction de leur âge et de leur ordre d'enregistrement.  \nLa fonction prend un tableau de tableaux, où chaque sous-tableau contient l'identifiant d'un patient (une chaîne) et son âge (un entier).  \nLes critères de tri sont les suivants :  \n1. Les patients âgés de 60 ans et plus ont la priorité sur les patients plus jeunes.  \n2. Les patients âgés (60 ans et plus) sont triés par ordre décroissant d'âge. Si les âges sont égaux, ils sont triés par leur ordre d'enregistrement.  \n3. Les patients plus jeunes (moins de 60 ans) sont triés en fonction de leur ordre d'enregistrement.  \n\nExemple :  \n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])  \n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "de": "Sortiert eine Liste von Patienteninformationen basierend auf ihrem Alter und ihrer Registrierungsreihenfolge.\nDie Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die Patienten-ID (ein String) und das Alter (ein Integer) enthält.\nDie Sortierkriterien sind wie folgt:\n1. Patienten im Alter von 60 Jahren und älter haben Vorrang vor jüngeren Patienten.\n2. Ältere Patienten (im Alter von 60+) werden in absteigender Reihenfolge ihres Alters sortiert. Wenn das Alter gleich ist, werden sie nach ihrer Registrierungsreihenfolge sortiert.\n3. Jüngere Patienten (unter 60) werden basierend auf ihrer Registrierungsreihenfolge sortiert.\n\nBeispiel:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "ha": "Tana tsara jerin bayanan marasa lafiya bisa ga shekarunsu da kuma tsarin rijista. \nAikin yana karɓar jerin jerin, inda kowace ƙaramin jeri ke ɗauke da ID na mara lafiya (kirtani) da shekaru (adadi). \nKa'idojin tsara su ne kamar haka:\n1. Ana bai wa marasa lafiya masu shekaru 60 da sama fifiko akan marasa lafiya matasa.\n2. Ana tsara marasa lafiya tsofaffi (masu shekaru 60+) a cikin tsarin raguwa na shekaru. Idan shekaru sun yi daidai, ana tsara su bisa ga tsarin rijistarsu.\n3. Ana tsara marasa lafiya matasa (ƙasa da shekaru 60) bisa ga tsarin rijistarsu.\n\nMisali:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hi": "उम्र और पंजीकरण क्रम के आधार पर रोगी जानकारी की सूची को क्रमबद्ध करता है। \nयह फ़ंक्शन एक सरणी का सरणी लेता है, जहाँ प्रत्येक उप-सरणी में एक रोगी की आईडी (एक स्ट्रिंग) और उम्र (एक पूर्णांक) होती है। \nक्रमबद्ध करने के मापदंड निम्नलिखित हैं:\n1. 60 और उससे अधिक उम्र के रोगियों को छोटे रोगियों पर प्राथमिकता दी जाती है।\n2. वृद्ध रोगियों (उम्र 60+) को उम्र के अवरोही क्रम में क्रमबद्ध किया जाता है। यदि उम्र समान है, तो उन्हें उनके पंजीकरण क्रम के अनुसार क्रमबद्ध किया जाता है।\n3. छोटे रोगियों (60 से कम उम्र) को उनके पंजीकरण क्रम के आधार पर क्रमबद्ध किया जाता है।\n\nउदाहरण:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hu": "Rendezi a betegek adatait tartalmazó listát életkoruk és regisztrációs sorrendjük alapján.\nA függvény egy tömbökből álló tömböt vesz át, ahol minden al-tömb egy beteg azonosítóját (egy karakterlánc) és életkorát (egy egész szám) tartalmazza.\nA rendezési kritériumok a következők:\n1. A 60 éves és idősebb betegek elsőbbséget élveznek a fiatalabb betegekkel szemben.\n2. Az idős betegek (60 év felettiek) életkoruk szerint csökkenő sorrendben vannak rendezve. Ha az életkorok megegyeznek, akkor a regisztrációs sorrendjük alapján vannak rendezve.\n3. A fiatalabb betegek (60 év alattiak) a regisztrációs sorrendjük alapján vannak rendezve.\n\nPélda:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]"
    },
    "docstring_bertscore": {
      "sq": "0.9761701145568634",
      "hy": "0.9710744507617944",
      "bn": "0.9789191590303863",
      "bg": "0.9696335859777673",
      "zh": "0.965401567079438",
      "fr": "0.9817456693525127",
      "de": "0.9806291679807156",
      "ha": "0.9577970029415173",
      "hi": "0.9880539716237997",
      "hu": "0.9673511242692955"
    }
  },
  {
    "task_id": "Ruby/20",
    "prompt": {
      "en": "# Finds the intersection point of two linear functions.\n# This function takes four arguments: slope1, intercept1, slope2, intercept2.\n# slope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\n# The function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\n# The coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n#\n# Example:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Parallel lines with no intersection\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "sq": "# Gjen pikën e prerjes së dy funksioneve lineare.\n# Kjo funksion merr katër argumente: slope1, intercept1, slope2, intercept2.\n# slope1 dhe slope2 janë pjerrësitë e dy vijave, ndërsa intercept1 dhe intercept2 janë prerjet e tyre në boshtin y.\n# Funksioni llogarit dhe kthen koordinatat e pikës së prerjes së këtyre dy vijave, nëse ekziston.\n# Koordinatat kthehen si një varg me dy elemente [x, y], të rrumbullakosura në dy shifra dhjetore.\n#\n# Shembull:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Vija paralele pa pikë prerjeje\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "hy": "# Գտնում է երկու գծային ֆունկցիաների հատման կետը։\n# Այս ֆունկցիան ընդունում է չորս արգումենտ՝ slope1, intercept1, slope2, intercept2։\n# slope1 և slope2-ը երկու գծերի թեքություններն են, իսկ intercept1 և intercept2-ը՝ նրանց y-հատումները։\n# Ֆունկցիան հաշվարկում և վերադարձնում է այդ երկու գծերի հատման կետի կոորդինատները, եթե այն գոյություն ունի։\n# Կոորդինատները վերադարձվում են որպես երկու տարրից բաղկացած զանգված [x, y], կլորացված մինչև երկու տասնորդական նշան։\n#\n# Օրինակ:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Զուգահեռ գծեր առանց հատման կետի\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "bn": "# দুটি সরলরেখার ছেদবিন্দু খুঁজে বের করে।\n# এই ফাংশনটি চারটি আর্গুমেন্ট নেয়: slope1, intercept1, slope2, intercept2।\n# slope1 এবং slope2 হল দুটি রেখার ঢাল, যেখানে intercept1 এবং intercept2 হল তাদের y-অবস্থানান্তর।\n# ফাংশনটি এই দুটি রেখার ছেদবিন্দুর স্থানাঙ্ক হিসাব করে এবং ফেরত দেয়, যদি এটি বিদ্যমান থাকে।\n# স্থানাঙ্কগুলি একটি দুই-উপাদান বিশিষ্ট অ্যারে [x, y] হিসাবে ফেরত দেওয়া হয়, যা দুই দশমিক স্থান পর্যন্ত গোল করা হয়।\n#\n# উদাহরণ:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # সমান্তরাল রেখা যার কোনো ছেদবিন্দু নেই\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "bg": "# Намира точката на пресичане на две линейни функции.\n# Тази функция приема четири аргумента: slope1, intercept1, slope2, intercept2.\n# slope1 и slope2 са наклоните на двете прави, докато intercept1 и intercept2 са техните y-пресечни точки.\n# Функцията изчислява и връща координатите на точката на пресичане на тези две прави, ако съществува.\n# Координатите се връщат като масив от два елемента [x, y], закръглени до два знака след десетичната запетая.\n#\n# Пример:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Успоредни прави без точка на пресичане\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "zh": "# 找到两个线性函数的交点。\n# 此函数接受四个参数：slope1, intercept1, slope2, intercept2。\n# slope1 和 slope2 是两条直线的斜率，而 intercept1 和 intercept2 是它们的 y 截距。\n# 该函数计算并返回这两条直线的交点坐标（如果存在）。\n# 坐标以一个两元素数组 [x, y] 的形式返回，保留两位小数。\n#\n# 示例：\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # 平行线无交点\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "fr": "# Trouve le point d'intersection de deux fonctions linéaires.\n# Cette fonction prend quatre arguments : slope1, intercept1, slope2, intercept2.\n# slope1 et slope2 sont les pentes des deux lignes, tandis que intercept1 et intercept2 sont leurs ordonnées à l'origine.\n# La fonction calcule et retourne les coordonnées du point d'intersection de ces deux lignes, si celui-ci existe.\n# Les coordonnées sont retournées sous forme d'un tableau à deux éléments [x, y], arrondies à deux décimales.\n#\n# Exemple :\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Lignes parallèles sans intersection\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "de": "# Findet den Schnittpunkt von zwei linearen Funktionen.\n# Diese Funktion nimmt vier Argumente: slope1, intercept1, slope2, intercept2.\n# slope1 und slope2 sind die Steigungen der beiden Linien, während intercept1 und intercept2 deren y-Achsenabschnitte sind.\n# Die Funktion berechnet und gibt die Koordinaten des Schnittpunkts dieser beiden Linien zurück, falls er existiert.\n# Die Koordinaten werden als ein zwei Elemente umfassendes Array [x, y] zurückgegeben, gerundet auf zwei Dezimalstellen.\n#\n# Beispiel:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Parallele Linien ohne Schnittpunkt\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "ha": "# Nemi wurin da layuka biyu masu madaidaici suka hadu.\n# Wannan aikin yana daukar huɗu: slope1, intercept1, slope2, intercept2.\n# slope1 da slope2 su ne gangara na layuka biyu, yayin da intercept1 da intercept2 su ne wuraren da suke tsallake y.\n# Aikin yana lissafi kuma yana dawo da daidaitattun wuraren da layuka biyu suka hadu, idan yana nan.\n# Daidaitattun wuraren ana dawo dasu a matsayin jerin abubuwa biyu [x, y], an zagaye zuwa wurare biyu na goma.\n#\n# Misali:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Layuka masu layi daya ba tare da wurin haduwa ba\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "hi": "# दो रेखीय फलनों के प्रतिच्छेदन बिंदु को खोजता है।\n# यह फ़ंक्शन चार तर्क लेता है: slope1, intercept1, slope2, intercept2।\n# slope1 और slope2 दो रेखाओं के ढलान हैं, जबकि intercept1 और intercept2 उनके y-अवरोध हैं।\n# फ़ंक्शन इन दो रेखाओं के प्रतिच्छेदन बिंदु के निर्देशांक की गणना करता है और लौटाता है, यदि यह मौजूद है।\n# निर्देशांक एक दो-तत्वीय सरणी [x, y] के रूप में लौटाए जाते हैं, जो दो दशमलव स्थानों तक गोल होते हैं।\n#\n# उदाहरण:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # समानांतर रेखाएँ जिनका कोई प्रतिच्छेदन नहीं है\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "hu": "# Megtalálja két lineáris függvény metszéspontját.\n# Ez a függvény négy argumentumot vesz át: slope1, intercept1, slope2, intercept2.\n# A slope1 és a slope2 a két egyenes meredeksége, míg az intercept1 és az intercept2 az y-metszéspontjaik.\n# A függvény kiszámítja és visszaadja a két egyenes metszéspontjának koordinátáit, ha létezik.\n# A koordináták egy két elemből álló tömbként [x, y] kerülnek visszaadásra, két tizedesjegyre kerekítve.\n#\n# Példa:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Párhuzamos egyenesek, nincs metszéspont\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)"
    },
    "prompt_bertscore": {
      "sq": "0.9783147267808971",
      "hy": "0.9970910580697441",
      "bn": "0.9846665291056308",
      "bg": "0.9934712180057642",
      "zh": "0.9768577729360062",
      "fr": "0.9954424259071545",
      "de": "0.995655953566767",
      "ha": "0.9754814630258155",
      "hi": "1",
      "hu": "0.9889531713587447"
    },
    "canonical_solution": "    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end",
    "instruction": {
      "en": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\n请为以下 Ruby 代码提供简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def find_intersection(slope1, intercept1, slope2, intercept2)\n    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9202439431030613",
      "bn": "0.9138385105754483",
      "bg": "0.8364486908745768",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9215894653041917",
      "hi": "0.9027873120658102",
      "hu": "0.9320642384480665"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_intersection(1.0, 0.0, -1.0, 2.0) == [1.00, 1.00]\nraise 'Test failed' unless find_intersection(2.0, 3.0, 2.0, -1.0).nil?\nraise 'Test failed' unless find_intersection(0.5, 1.0, -0.5, -1.0) == [-2.00, 0.00]\nraise 'Test failed' unless find_intersection(3.0, 2.0, -1.0, 4.0) == [0.50, 3.50]\nraise 'Test failed' unless find_intersection(2.0, 0.0, 0.0, 2.0) == [1.0, 2.0]\n  \n\nputs 'All tests passed!'",
    "entry_point": "find_intersection",
    "signature": "def find_intersection(slope1, intercept1, slope2, intercept2)",
    "docstring": {
      "en": "Finds the intersection point of two linear functions.\nThis function takes four arguments: slope1, intercept1, slope2, intercept2.\nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n\nExample:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallel lines with no intersection",
      "sq": "Gjen pikën e prerjes së dy funksioneve lineare.\nKjo funksion merr katër argumente: slope1, intercept1, slope2, intercept2.\nslope1 dhe slope2 janë pjerrësitë e dy vijave, ndërsa intercept1 dhe intercept2 janë prerjet e tyre në boshtin y.\nFunksioni llogarit dhe kthen koordinatat e pikës së prerjes së këtyre dy vijave, nëse ekziston.\nKoordinatat kthehen si një varg me dy elemente [x, y], të rrumbullakosura në dy vende dhjetore.\n\nShembull:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Vija paralele pa pikë prerjeje",
      "hy": "Գտնում է երկու գծային ֆունկցիաների հատման կետը։\nԱյս ֆունկցիան ընդունում է չորս արգումենտ՝ slope1, intercept1, slope2, intercept2։  \nslope1 և slope2-ը երկու գծերի թեքություններն են, իսկ intercept1 և intercept2-ը՝ նրանց y-հատումները։  \nՖունկցիան հաշվարկում և վերադարձնում է այս երկու գծերի հատման կետի կոորդինատները, եթե այն գոյություն ունի։  \nԿոորդինատները վերադարձվում են որպես երկու տարրերից բաղկացած զանգված՝ [x, y], կլորացված մինչև երկու տասնորդական տեղ։\n\nՕրինակ՝  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Զուգահեռ գծեր առանց հատման կետի  ",
      "bn": "দুটি সরল রেখার ছেদবিন্দু খুঁজে বের করে।\nএই ফাংশনটি চারটি আর্গুমেন্ট নেয়: slope1, intercept1, slope2, intercept2। \nslope1 এবং slope2 হল দুটি রেখার ঢাল, যেখানে intercept1 এবং intercept2 হল তাদের y-অবস্থানান্তর। \nফাংশনটি এই দুটি রেখার ছেদবিন্দুর স্থানাঙ্ক গণনা করে এবং ফেরত দেয়, যদি তা থাকে। \nস্থানাঙ্কগুলি একটি দুটি উপাদানের অ্যারে [x, y] হিসাবে ফেরত দেওয়া হয়, যা দুই দশমিক স্থান পর্যন্ত গোলাকার।\n\nউদাহরণ:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  সমান্তরাল রেখা যার কোনো ছেদবিন্দু নেই",
      "bg": "Намира точката на пресичане на две линейни функции.\nТази функция приема четири аргумента: slope1, intercept1, slope2, intercept2.  \nslope1 и slope2 са наклоните на двете прави, докато intercept1 и intercept2 са техните y-пресечни точки.  \nФункцията изчислява и връща координатите на точката на пресичане на тези две прави, ако съществува такава.  \nКоординатите се връщат като масив с два елемента [x, y], закръглени до два десетични знака.  \n\nПример:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Паралелни прави без пресечна точка",
      "zh": "找到两个线性函数的交点。\n此函数接受四个参数：slope1, intercept1, slope2, intercept2。\nslope1 和 slope2 是两条直线的斜率，而 intercept1 和 intercept2 是它们的 y 截距。\n该函数计算并返回这两条直线的交点坐标（如果存在）。\n坐标以一个两元素数组 [x, y] 的形式返回，保留两位小数。\n\n示例：\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  平行线无交点",
      "fr": "Trouve le point d'intersection de deux fonctions linéaires.\nCette fonction prend quatre arguments : slope1, intercept1, slope2, intercept2.  \nslope1 et slope2 sont les pentes des deux lignes, tandis que intercept1 et intercept2 sont leurs ordonnées à l'origine.  \nLa fonction calcule et renvoie les coordonnées du point d'intersection de ces deux lignes, si celui-ci existe.  \nLes coordonnées sont renvoyées sous forme d'un tableau à deux éléments [x, y], arrondies à deux décimales.\n\nExemple :  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Lignes parallèles sans intersection",
      "de": "Findet den Schnittpunkt von zwei linearen Funktionen.\nDiese Funktion nimmt vier Argumente entgegen: slope1, intercept1, slope2, intercept2.\nslope1 und slope2 sind die Steigungen der beiden Linien, während intercept1 und intercept2 deren y-Achsenabschnitte sind.\nDie Funktion berechnet und gibt die Koordinaten des Schnittpunkts dieser beiden Linien zurück, falls er existiert.\nDie Koordinaten werden als ein zwei Elemente umfassendes Array [x, y] zurückgegeben, gerundet auf zwei Dezimalstellen.\n\nBeispiel:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallele Linien ohne Schnittpunkt",
      "ha": "Nemi wurin haɗuwa na hanyoyi biyu na layi.\nWannan aikin yana samun wurin haɗuwa na hanyoyi biyu masu madaidaiciya.  \nThis function takes four arguments: slope1, intercept1, slope2, intercept2.  \nWannan aikin yana karɓar hujjoji guda huɗu: slope1, intercept1, slope2, intercept2.  \nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.  \nslope1 da slope2 su ne gangaren hanyoyi biyu, yayin da intercept1 da intercept2 su ne wuraren y-intercept ɗinsu.  \nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.  \nAikin yana ƙididdige kuma yana dawowa da daidaitattun wuraren haɗuwa na waɗannan hanyoyi biyu, idan suna wanzu.  \nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.  \nDaidaitattun wuraren suna dawowa a matsayin jerin abubuwa guda biyu [x, y], an zagaye zuwa wurare biyu na goma.  \n\nExample:  \nMisali:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Layukan da ke daidai ba su da wurin haɗuwa  ",
      "hi": "दो रेखीय फलनों के प्रतिच्छेदन बिंदु को खोजता है।\nयह फ़ंक्शन चार तर्क लेता है: slope1, intercept1, slope2, intercept2।  \nslope1 और slope2 दो रेखाओं के ढलान हैं, जबकि intercept1 और intercept2 उनके y-अवरोध हैं।  \nयह फ़ंक्शन इन दो रेखाओं के प्रतिच्छेदन बिंदु के निर्देशांक की गणना करता है और लौटाता है, यदि यह मौजूद है।  \nनिर्देशांक को [x, y] के रूप में दो तत्वों की एक सरणी के रूप में लौटाया जाता है, जो दो दशमलव स्थानों तक गोल होते हैं।\n\nउदाहरण:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  समानांतर रेखाएँ जिनका कोई प्रतिच्छेदन नहीं है",
      "hu": "Megtalálja két lineáris függvény metszéspontját.\nEz a függvény négy argumentumot vesz: slope1, intercept1, slope2, intercept2.\nA slope1 és slope2 a két egyenes meredeksége, míg az intercept1 és intercept2 az y-metszéspontjaik.\nA függvény kiszámítja és visszaadja a két egyenes metszéspontjának koordinátáit, ha létezik.\nA koordináták egy kételemű tömbként [x, y] formában kerülnek visszaadásra, két tizedesjegyre kerekítve.\n\nPélda:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Párhuzamos egyenesek, nincs metszéspont"
    },
    "docstring_bertscore": {
      "sq": "0.9740348379607384",
      "hy": "0.9922595726814515",
      "bn": "0.9828075473695252",
      "bg": "0.9926008196760694",
      "zh": "0.9809144012078818",
      "fr": "0.9894970213420182",
      "de": "0.9900774193154022",
      "ha": "0.9706366694019936",
      "hi": "0.999999801369619",
      "hu": "0.9807251064547555"
    }
  },
  {
    "task_id": "Ruby/21",
    "prompt": {
      "en": "# This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\n# The function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n#\n# Examples:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "sq": "# Kjo metodë llogarit numrin minimal të hapave të nevojshëm për të transformuar një numër të dhënë në një palindrom duke përmbysur në mënyrë të përsëritur shifrat e tij dhe duke shtuar rezultatin në numrin origjinal. Procesi ndalet kur merret një palindrom. Nëse palindromi nuk merret brenda 8 hapave, metoda kthen 0.\n# Funksioni merr një argument të vetëm, m, i cili është një numër i plotë pozitiv midis 12 dhe 100, dhe kthen numrin e hapave të ndërmarrë për të arritur një palindrom. Vetë numri i hyrjes m nuk është një palindrom.\n#\n# Shembuj:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "hy": "# Այս մեթոդը հաշվարկում է նվազագույն քայլերի քանակը, որոնք անհրաժեշտ են տրված թիվը պալինդրոմ դարձնելու համար՝ կրկնակի շրջելով նրա թվանշանները և գումարելով արդյունքը սկզբնական թվին: Գործընթացը դադարում է, երբ ստացվում է պալինդրոմ: Եթե պալինդրոմը չի ստացվում 8 քայլի ընթացքում, մեթոդը վերադարձնում է 0:\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ m, որը դրական ամբողջ թիվ է 12-ից 100 միջակայքում, և վերադարձնում է այն քայլերի քանակը, որոնք անհրաժեշտ են պալինդրոմի հասնելու համար: Մուտքային թիվը m ինքնին պալինդրոմ չէ:\n#\n# Օրինակներ:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "bn": "# এই পদ্ধতিটি প্রদত্ত সংখ্যাটিকে একটি প্যালিনড্রোমে রূপান্তর করার জন্য প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা গণনা করে, যা বারবার এর অঙ্কগুলি উল্টে এবং ফলাফলটি মূল সংখ্যার সাথে যোগ করে। যখন একটি প্যালিনড্রোম পাওয়া যায়, তখন প্রক্রিয়াটি বন্ধ করা হয়। যদি 8 ধাপের মধ্যে প্যালিনড্রোম পাওয়া না যায়, তাহলে পদ্ধতিটি 0 প্রদান করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, m, যা 12 এবং 100 এর মধ্যে একটি ধনাত্মক পূর্ণসংখ্যা, এবং একটি প্যালিনড্রোমে পৌঁছানোর জন্য নেওয়া ধাপের সংখ্যা প্রদান করে। ইনপুট সংখ্যা m নিজেই একটি প্যালিনড্রোম নয়।\n#\n# উদাহরণ:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "bg": "# Този метод изчислява минималния брой стъпки, необходими за преобразуване на дадено число в палиндром, като многократно обръща цифрите му и добавя резултата към оригиналното число. Процесът се спира, когато се получи палиндром. Ако палиндром не се получи в рамките на 8 стъпки, методът връща 0.\n# Функцията приема един аргумент, m, който е положително цяло число между 12 и 100, и връща броя на стъпките, необходими за достигане на палиндром. Самото входно число m не е палиндром.\n#\n# Примери:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "zh": "# 此方法计算将给定数字转换为回文所需的最小步骤数，通过反复反转其数字并将结果加到原始数字上。 当获得回文时，过程停止。 如果在8步内未获得回文，该方法返回0。\n# 该函数接受一个参数m，这是一个介于12和100之间的正整数，并返回达到回文所需的步骤数。 输入数字m本身不是回文。\n#\n# 示例:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "fr": "# Cette méthode calcule le nombre minimum d'étapes nécessaires pour transformer un nombre donné en un palindrome en inversant à plusieurs reprises ses chiffres et en ajoutant le résultat au nombre original. Le processus s'arrête lorsqu'un palindrome est obtenu. Si le palindrome n'est pas obtenu en 8 étapes, la méthode renvoie 0.\n# La fonction prend un seul argument, m, qui est un entier positif compris entre 12 et 100, et renvoie le nombre d'étapes nécessaires pour atteindre un palindrome. Le nombre d'entrée m lui-même n'est pas un palindrome.\n#\n# Exemples :\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "de": "# Diese Methode berechnet die minimale Anzahl von Schritten, die erforderlich sind, um eine gegebene Zahl in ein Palindrom zu verwandeln, indem wiederholt ihre Ziffern umgekehrt und das Ergebnis zur ursprünglichen Zahl addiert wird. Der Prozess wird gestoppt, wenn ein Palindrom erreicht wird. Wenn das Palindrom nicht innerhalb von 8 Schritten erreicht wird, gibt die Methode 0 zurück.\n# Die Funktion nimmt ein einziges Argument, m, das eine positive ganze Zahl zwischen 12 und 100 ist, und gibt die Anzahl der Schritte zurück, die benötigt werden, um ein Palindrom zu erreichen. Die Eingabezahl m selbst ist kein Palindrom.\n#\n# Beispiele:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "ha": "# Wannan hanyar tana ƙididdige mafi ƙarancin adadin matakai da ake buƙata don sauya wata lamba zuwa palindrome ta hanyar juyar da lambobin sa akai-akai da ƙara sakamakon zuwa lambar asali. Ana dakatar da aikin lokacin da aka sami palindrome. Idan ba a sami palindrome ba cikin matakai 8, hanyar tana dawowa 0.\n# Aikin yana ɗaukar hujja guda ɗaya, m, wanda yake lamba mai kyau tsakanin 12 da 100, kuma yana dawowa adadin matakan da aka ɗauka don isa ga palindrome. Lambar shigarwa m kanta ba palindrome ba ce.\n#\n# Misalai:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "hi": "# यह विधि एक दिए गए संख्या को एक पालिंड्रोम में बदलने के लिए आवश्यक न्यूनतम चरणों की गणना करती है, इसके अंकों को बार-बार उलटकर और परिणाम को मूल संख्या में जोड़कर। प्रक्रिया तब रोकी जाती है जब एक पालिंड्रोम प्राप्त हो जाता है। यदि पालिंड्रोम 8 चरणों के भीतर प्राप्त नहीं होता है, तो विधि 0 लौटाती है।\n# फ़ंक्शन एक एकल तर्क, m, लेता है, जो 12 और 100 के बीच एक धनात्मक पूर्णांक है, और पालिंड्रोम तक पहुँचने के लिए लिए गए चरणों की संख्या लौटाता है। इनपुट संख्या m स्वयं एक पालिंड्रोम नहीं है।\n#\n# उदाहरण:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "hu": "# Ez a metódus kiszámítja a minimális lépések számát, amelyek szükségesek ahhoz, hogy egy adott számot palindrómmá alakítsunk azáltal, hogy ismételten megfordítjuk a számjegyeit, és az eredményt hozzáadjuk az eredeti számhoz. A folyamat akkor áll le, amikor palindrómot kapunk. Ha a palindrómot nem kapjuk meg 8 lépésen belül, a metódus 0-t ad vissza.\n# A függvény egyetlen argumentumot vesz fel, m-et, amely egy 12 és 100 közötti pozitív egész szám, és visszaadja a palindróm eléréséhez szükséges lépések számát. Az m bemeneti szám maga nem palindróm.\n#\n# Példák:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)"
    },
    "prompt_bertscore": {
      "sq": "0.995661912478198",
      "hy": "0.9703822238838878",
      "bn": "0.968567338092372",
      "bg": "0.9862287570524702",
      "zh": "0.9794852556163357",
      "fr": "0.9915498663300137",
      "de": "0.9882071156475777",
      "ha": "0.9863221133315566",
      "hi": "0.9895909735122477",
      "hu": "0.9922889699778447"
    },
    "canonical_solution": "  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend",
    "instruction": {
      "en": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nՏվեք Ruby կոդի հակիրճ բնութագիրը (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Ruby 代码，字数不超过500个字符。",
      "fr": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nBa da takaitaccen bayani a cikin yare na dabi'a (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def palindrome_sum_steps(m)\n  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9262890601194771",
      "bn": "0.8746987912532856",
      "bg": "0.8991035130191372",
      "zh": "0.8895074806809606",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9353344890414249",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless palindrome_sum_steps(12) == 1\nraise 'Test failed' unless palindrome_sum_steps(87) == 4\nraise 'Test failed' unless palindrome_sum_steps(89) == 0\nraise 'Test failed' unless palindrome_sum_steps(56) == 1\nraise 'Test failed' unless palindrome_sum_steps(95) == 3\n\nputs 'All tests passed!'",
    "entry_point": "palindrome_sum_steps",
    "signature": "def palindrome_sum_steps(m)",
    "docstring": {
      "en": "This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\nThe function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n\nExamples:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "sq": "Kjo metodë llogarit numrin minimal të hapave të nevojshëm për të transformuar një numër të dhënë në një palindromë duke përmbysur përsëri shifrat e tij dhe duke shtuar rezultatin në numrin origjinal. Procesi ndalet kur merret një palindromë. Nëse palindroma nuk merret brenda 8 hapave, metoda kthen 0. \n\nFunksioni merr një argument të vetëm, m, i cili është një numër i plotë pozitiv midis 12 dhe 100, dhe kthen numrin e hapave të ndërmarrë për të arritur një palindromë. Numri hyrës m vetë nuk është një palindromë.\n\nShembuj:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hy": "Այս մեթոդը հաշվարկում է նվազագույն քայլերի քանակը, որը պահանջվում է տրված թիվը պալինդրոմ դարձնելու համար՝ բազմիցս շրջելով նրա թվանշանները և գումարելով արդյունքը սկզբնական թվին: Գործընթացը դադարում է, երբ ստացվում է պալինդրոմ: Եթե պալինդրոմը չի ստացվում 8 քայլի ընթացքում, մեթոդը վերադարձնում է 0: \n\nՖունկցիան ընդունում է մեկ արգումենտ՝ m, որը դրական ամբողջ թիվ է 12-ից մինչև 100 միջակայքում, և վերադարձնում է քայլերի քանակը, որը պահանջվում է պալինդրոմ ստանալու համար: Մուտքային թիվ m-ը ինքնին պալինդրոմ չէ:\n\nՕրինակներ:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "bn": "এই পদ্ধতিটি একটি প্রদত্ত সংখ্যাকে একটি প্যালিনড্রোমে রূপান্তর করার জন্য প্রয়োজনীয় সর্বনিম্ন ধাপের সংখ্যা গণনা করে, যা তার অঙ্কগুলি উল্টে এবং ফলাফলটি মূল সংখ্যার সাথে যোগ করে বারবার করা হয়। যখন একটি প্যালিনড্রোম প্রাপ্ত হয় তখন প্রক্রিয়াটি বন্ধ করা হয়। যদি ৮ ধাপের মধ্যে প্যালিনড্রোম প্রাপ্ত না হয়, তাহলে পদ্ধতিটি ০ ফেরত দেয়। \n\nArgs: \n    m: একটি ধনাত্মক পূর্ণসংখ্যা যা ১২ এবং ১০০ এর মধ্যে, এবং এটি একটি প্যালিনড্রোম নয়।\n\nReturns: \n    একটি পূর্ণসংখ্যা যা প্যালিনড্রোমে পৌঁছানোর জন্য নেওয়া ধাপের সংখ্যা নির্দেশ করে।\n\nExamples:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "bg": "Този метод изчислява минималния брой стъпки, необходими за преобразуване на дадено число в палиндром, чрез многократно обръщане на цифрите му и добавяне на резултата към оригиналното число. Процесът спира, когато се получи палиндром. Ако палиндром не бъде получен в рамките на 8 стъпки, методът връща 0. \n\nФункцията приема един аргумент, m, който е положително цяло число между 12 и 100, и връща броя на стъпките, необходими за достигане на палиндром. Самото входно число m не е палиндром.\n\nПримери:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "zh": "此方法计算将给定数字转换为回文所需的最小步骤数，方法是反复反转其数字并将结果加到原始数字上。当获得回文时，过程停止。如果在8步内未获得回文，则该方法返回0。  \n该函数接受一个参数m，它是一个介于12和100之间的正整数，并返回达到回文所需的步骤数。输入数字m本身不是回文。\n\n示例：\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "fr": "Cette méthode calcule le nombre minimum d'étapes nécessaires pour transformer un nombre donné en palindrome en inversant à plusieurs reprises ses chiffres et en ajoutant le résultat au nombre original. Le processus s'arrête lorsqu'un palindrome est obtenu. Si le palindrome n'est pas obtenu en 8 étapes, la méthode retourne 0. \n\nLa fonction prend un seul argument, m, qui est un entier positif compris entre 12 et 100, et retourne le nombre d'étapes nécessaires pour atteindre un palindrome. Le nombre d'entrée m lui-même n'est pas un palindrome.\n\nExemples :\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "de": "Diese Methode berechnet die minimale Anzahl von Schritten, die erforderlich sind, um eine gegebene Zahl in ein Palindrom zu transformieren, indem wiederholt ihre Ziffern umgekehrt und das Ergebnis zur ursprünglichen Zahl addiert werden. Der Prozess wird gestoppt, wenn ein Palindrom erreicht wird. Wenn das Palindrom nicht innerhalb von 8 Schritten erreicht wird, gibt die Methode 0 zurück. \n\nDie Funktion nimmt ein einziges Argument, m, das eine positive ganze Zahl zwischen 12 und 100 ist, und gibt die Anzahl der Schritte zurück, die benötigt werden, um ein Palindrom zu erreichen. Die Eingabezahl m selbst ist kein Palindrom.\n\nBeispiele:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "ha": "Wannan hanyar tana ƙididdige mafi ƙarancin adadin matakan da ake buƙata don canza wata lamba zuwa palindrome ta hanyar juyar da lambobinta akai-akai da ƙara sakamakon ga ainihin lambar. Ana dakatar da aikin lokacin da aka sami palindrome. Idan ba a sami palindrome ba cikin matakai 8, hanyar tana dawowa 0.\n\nHanyar tana ɗaukar hujja guda ɗaya, m, wanda lamba ce mai kyau tsakanin 12 da 100, kuma tana dawowa adadin matakan da aka ɗauka don isa ga palindrome. Lambar shigar m kanta ba palindrome ba ce.\n\nMisalai:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hi": "इस विधि द्वारा एक दिए गए संख्या को एक पालिंड्रोम में बदलने के लिए आवश्यक न्यूनतम चरणों की गणना की जाती है, जिसमें बार-बार इसके अंकों को उलटकर और परिणाम को मूल संख्या में जोड़कर किया जाता है। प्रक्रिया तब रोकी जाती है जब एक पालिंड्रोम प्राप्त होता है। यदि पालिंड्रोम 8 चरणों के भीतर प्राप्त नहीं होता है, तो विधि 0 लौटाती है। \n\nयह फ़ंक्शन एकल तर्क m लेता है, जो 12 और 100 के बीच की एक धनात्मक पूर्णांक है, और पालिंड्रोम तक पहुँचने में लिए गए चरणों की संख्या लौटाता है। इनपुट संख्या m स्वयं एक पालिंड्रोम नहीं है।\n\nउदाहरण:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hu": "Ez a metódus kiszámítja a minimális lépések számát, amely szükséges egy adott szám palindrómmá alakításához úgy, hogy ismételten megfordítja a számjegyeit, és hozzáadja az eredményt az eredeti számhoz. A folyamat akkor áll meg, amikor palindrómot kapunk. Ha a palindrómot nem kapjuk meg 8 lépésen belül, a metódus 0-t ad vissza. \n\nA függvény egyetlen argumentumot vesz fel, m-et, amely egy 12 és 100 közötti pozitív egész szám, és visszaadja a palindróm eléréséhez szükséges lépések számát. Az m bemeneti szám maga nem palindróm.\n\nPéldák:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9913985099796652",
      "hy": "0.9768516153941942",
      "bn": "0.9229308162673203",
      "bg": "0.9856137973927862",
      "zh": "0.9778173563067858",
      "fr": "0.9908498928672469",
      "de": "0.9863149626378394",
      "ha": "0.9880261633704549",
      "hi": "0.9804202088198669",
      "hu": "0.991471605959886"
    }
  },
  {
    "task_id": "Ruby/22",
    "prompt": {
      "en": "# This function calculates the number of different prime pairs whose sum equals a given even number.\n# The function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\n# It returns the count of distinct prime pairs whose sum equals the given even number.\n# A prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n#\n# Example:\n# >>> count_prime_pairs(10)\n# 2 (since 10 can be expressed as 3+7 and 5+5)\n# >>> count_prime_pairs(14)\n# 2 (since 14 can be expressed as 3+11 and 7+7)\n \ndef count_prime_pairs(even_number)",
      "sq": "# Kjo funksion llogarit numrin e çifteve të ndryshme të numrave të thjeshtë, shuma e të cilëve është e barabartë me një numër çift të dhënë.\n# Funksioni pranon një argument të vetëm, even_number, i cili është një numër çift më i madh se 6 dhe më i vogël se 32767.\n# Ai kthen numrin e çifteve të ndryshme të numrave të thjeshtë, shuma e të cilëve është e barabartë me numrin çift të dhënë.\n# Një çift numrash të thjeshtë konsiderohet i ndryshëm nëse numrat e thjeshtë në çift janë të ndryshëm, pavarësisht nga rendi i tyre.\n#\n# Shembull:\n# >>> count_prime_pairs(10)\n# 2 (meqë 10 mund të shprehet si 3+7 dhe 5+5)\n# >>> count_prime_pairs(14)\n# 2 (meqë 14 mund të shprehet si 3+11 dhe 7+7)\n\ndef count_prime_pairs(even_number)",
      "hy": "# Այս ֆունկցիան հաշվարկում է տարբեր պարզ թվերի զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, even_number, որը զույգ թիվ է, մեծ քան 6 և փոքր քան 32767։\n# Այն վերադարձնում է տարբեր պարզ զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։\n# Պարզ զույգը համարվում է տարբեր, եթե զույգի պարզ թվերը տարբեր են, անկախ նրանց հերթականությունից։\n#\n# Օրինակ:\n# >>> count_prime_pairs(10)\n# 2 (քանի որ 10-ը կարելի է արտահայտել որպես 3+7 և 5+5)\n# >>> count_prime_pairs(14)\n# 2 (քանի որ 14-ը կարելի է արտահայտել որպես 3+11 և 7+7)\n\ndef count_prime_pairs(even_number)",
      "bn": "# এই ফাংশনটি বিভিন্ন মৌলিক সংখ্যার যুগলের সংখ্যা গণনা করে যাদের যোগফল একটি প্রদত্ত জোড় সংখ্যার সমান।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, even_number, যা ৬ এর চেয়ে বড় এবং ৩২৭৬৭ এর চেয়ে ছোট একটি জোড় সংখ্যা।\n# এটি পৃথক মৌলিক সংখ্যার যুগলের সংখ্যা ফেরত দেয় যাদের যোগফল প্রদত্ত জোড় সংখ্যার সমান।\n# একটি মৌলিক যুগলকে পৃথক ধরা হয় যদি যুগলের মৌলিক সংখ্যা ভিন্ন হয়, তাদের ক্রম নির্বিশেষে।\n#\n# উদাহরণ:\n# >>> count_prime_pairs(10)\n# 2 (কারণ 10 কে 3+7 এবং 5+5 হিসাবে প্রকাশ করা যায়)\n# >>> count_prime_pairs(14)\n# 2 (কারণ 14 কে 3+11 এবং 7+7 হিসাবে প্রকাশ করা যায়)\n\ndef count_prime_pairs(even_number)",
      "bg": "# Тази функция изчислява броя на различните двойки прости числа, чиято сума е равна на дадено четно число.\n# Функцията приема един аргумент, even_number, което е четно число по-голямо от 6 и по-малко от 32767.\n# Тя връща броя на различните двойки прости числа, чиято сума е равна на даденото четно число.\n# Една двойка прости числа се счита за различна, ако простите числа в двойката са различни, независимо от техния ред.\n#\n# Пример:\n# >>> count_prime_pairs(10)\n# 2 (тъй като 10 може да се изрази като 3+7 и 5+5)\n# >>> count_prime_pairs(14)\n# 2 (тъй като 14 може да се изрази като 3+11 и 7+7)\n\ndef count_prime_pairs(even_number)",
      "zh": "# 这个函数计算和等于给定偶数的不同素数对的数量。\n# 该函数接受一个参数 even_number，它是一个大于 6 且小于 32767 的偶数。\n# 它返回和等于给定偶数的不同素数对的数量。\n# 如果素数对中的素数不同，则认为素数对是不同的，无论它们的顺序如何。\n#\n# 示例：\n# >>> count_prime_pairs(10)\n# 2 (因为 10 可以表示为 3+7 和 5+5)\n# >>> count_prime_pairs(14)\n# 2 (因为 14 可以表示为 3+11 和 7+7) \n\ndef count_prime_pairs(even_number)",
      "fr": "# Cette fonction calcule le nombre de paires de nombres premiers différentes dont la somme est égale à un nombre pair donné.\n# La fonction accepte un seul argument, even_number, qui est un nombre pair supérieur à 6 et inférieur à 32767.\n# Elle renvoie le nombre de paires de nombres premiers distinctes dont la somme est égale au nombre pair donné.\n# Une paire de nombres premiers est considérée comme distincte si les nombres premiers dans la paire sont différents, indépendamment de leur ordre.\n#\n# Exemple :\n# >>> count_prime_pairs(10)\n# 2 (puisque 10 peut être exprimé comme 3+7 et 5+5)\n# >>> count_prime_pairs(14)\n# 2 (puisque 14 peut être exprimé comme 3+11 et 7+7)\n\ndef count_prime_pairs(even_number)",
      "de": "# Diese Funktion berechnet die Anzahl der verschiedenen Primzahlpaare, deren Summe einer gegebenen geraden Zahl entspricht.\n# Die Funktion akzeptiert ein einzelnes Argument, even_number, welches eine gerade Zahl größer als 6 und kleiner als 32767 ist.\n# Sie gibt die Anzahl der unterschiedlichen Primzahlpaare zurück, deren Summe der gegebenen geraden Zahl entspricht.\n# Ein Primzahlpaar wird als unterschiedlich betrachtet, wenn die Primzahlen im Paar verschieden sind, unabhängig von ihrer Reihenfolge.\n#\n# Beispiel:\n# >>> count_prime_pairs(10)\n# 2 (da 10 als 3+7 und 5+5 ausgedrückt werden kann)\n# >>> count_prime_pairs(14)\n# 2 (da 14 als 3+11 und 7+7 ausgedrückt werden kann)\n\ndef count_prime_pairs(even_number)",
      "ha": "# Wannan aikin yana ƙididdige adadin nau'ikan ma'aurata lambobi masu lamba waɗanda jimlarsu ta yi daidai da wata lamba mai ma'ana.\n# Aikin yana karɓar hujja guda ɗaya, even_number, wanda wata lamba ce mai ma'ana mafi girma da 6 kuma ƙasa da 32767.\n# Yana mayar da adadin ma'aurata lambobi masu lamba waɗanda jimlarsu ta yi daidai da wannan lamba mai ma'ana.\n# Ana ɗaukar ma'aurata lambobi masu lamba daban-daban idan lambobin a cikin ma'auratan sun bambanta, ba tare da la'akari da tsarinsu ba.\n#\n# Misali:\n# >>> count_prime_pairs(10)\n# 2 (saboda 10 za a iya bayyana shi azaman 3+7 da 5+5)\n# >>> count_prime_pairs(14)\n# 2 (saboda 14 za a iya bayyana shi azaman 3+11 da 7+7)\n\ndef count_prime_pairs(even_number)",
      "hi": "# यह फ़ंक्शन उन विभिन्न अभाज्य युग्मों की संख्या की गणना करता है जिनका योग एक दिए गए सम संख्या के बराबर होता है।\n# फ़ंक्शन एकल तर्क स्वीकार करता है, even_number, जो 6 से बड़ा और 32767 से कम एक सम संख्या है।\n# यह उन भिन्न अभाज्य युग्मों की गणना लौटाता है जिनका योग दिए गए सम संख्या के बराबर होता है।\n# एक अभाज्य युग्म को भिन्न माना जाता है यदि युग्म में अभाज्य संख्याएँ अलग-अलग हैं, चाहे उनका क्रम कुछ भी हो।\n#\n# उदाहरण:\n# >>> count_prime_pairs(10)\n# 2 (क्योंकि 10 को 3+7 और 5+5 के रूप में व्यक्त किया जा सकता है)\n# >>> count_prime_pairs(14)\n# 2 (क्योंकि 14 को 3+11 और 7+7 के रूप में व्यक्त किया जा सकता है)\n\ndef count_prime_pairs(even_number)",
      "hu": "# Ez a függvény kiszámítja a különböző prímpárok számát, amelyek összege egy adott páros szám.\n# A függvény egyetlen argumentumot fogad el, even_number, amely egy 6-nál nagyobb és 32767-nél kisebb páros szám.\n# Visszaadja azon különböző prímpárok számát, amelyek összege megegyezik az adott páros számmal.\n# Egy prímpárt akkor tekintünk különbözőnek, ha a párban lévő prímek különböznek, függetlenül a sorrendtől.\n#\n# Példa:\n# >>> count_prime_pairs(10)\n# 2 (mivel a 10 kifejezhető 3+7 és 5+5 összegeként)\n# >>> count_prime_pairs(14)\n# 2 (mivel a 14 kifejezhető 3+11 és 7+7 összegeként)\n\ndef count_prime_pairs(even_number)"
    },
    "prompt_bertscore": {
      "sq": "0.963181078049849",
      "hy": "0.9597340464173696",
      "bn": "0.9629669544990934",
      "bg": "0.9599306904945941",
      "zh": "0.9671173363108173",
      "fr": "0.971601615793061",
      "de": "0.9879030125342132",
      "ha": "0.9476730110505501",
      "hi": "0.990196200283261",
      "hu": "0.9794767145099512"
    },
    "canonical_solution": "    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n",
    "instruction": {
      "en": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nরুবি কোডের একটি সংক্ষিপ্ত বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nFournir une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Ruby a cikin Hausa, ba tare da wucewa haruffa 500 ba.",
      "hi": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_prime_pairs(even_number)\n    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.923607152714744",
      "bn": "0.8654859169201254",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9171840420832189",
      "hi": "0.9027873120658102",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_prime_pairs(10) == 2\nraise 'Test failed' unless count_prime_pairs(14) == 2\nraise 'Test failed' unless count_prime_pairs(20) == 2\nraise 'Test failed' unless count_prime_pairs(26) == 3\nraise 'Test failed' unless count_prime_pairs(100) == 6\nraise 'Test failed' unless count_prime_pairs(1234) == 25\n\n\nputs 'All tests passed!'",
    "entry_point": "count_prime_pairs",
    "signature": "def count_prime_pairs(even_number)",
    "docstring": {
      "en": "This function calculates the number of different prime pairs whose sum equals a given even number.\nThe function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\nIt returns the count of distinct prime pairs whose sum equals the given even number.\nA prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n\nExample:\n>>> count_prime_pairs(10)\n2 (since 10 can be expressed as 3+7 and 5+5)\n>>> count_prime_pairs(14)\n2 (since 14 can be expressed as 3+11 and 7+7)",
      "sq": "Kjo funksion llogarit numrin e çifteve të ndryshme të numrave të parë, shuma e të cilëve është e barabartë me një numër çift të dhënë.\nFunksioni pranon një argument të vetëm, even_number, i cili është një numër çift më i madh se 6 dhe më i vogël se 32767.\nKthen numrin e çifteve të ndryshme të numrave të parë, shuma e të cilëve është e barabartë me numrin çift të dhënë.\nNjë çift numrash të parë konsiderohet i ndryshëm nëse numrat e parë në çift janë të ndryshëm, pavarësisht nga rendi i tyre.\n\nShembull:\n>>> count_prime_pairs(10)\n2 (meqë 10 mund të shprehet si 3+7 dhe 5+5)\n>>> count_prime_pairs(14)\n2 (meqë 14 mund të shprehet si 3+11 dhe 7+7)",
      "hy": "Այս ֆունկցիան հաշվարկում է տարբեր պարզ թվերի զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։  \nՖունկցիան ընդունում է մեկ արգումենտ՝ even_number, որը զույգ թիվ է՝ մեծ 6-ից և փոքր 32767-ից։  \nԱյն վերադարձնում է տարբեր պարզ զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։  \nՊարզ զույգը համարվում է տարբեր, եթե զույգի մեջ գտնվող պարզ թվերը տարբեր են՝ անկախ դրանց կարգից։  \n\nՕրինակ:  \n>>> count_prime_pairs(10)  \n2 (քանի որ 10-ը կարող է արտահայտվել որպես 3+7 և 5+5)  \n>>> count_prime_pairs(14)  \n2 (քանի որ 14-ը կարող է արտահայտվել որպես 3+11 և 7+7)",
      "bn": "এই ফাংশনটি বিভিন্ন মৌলিক জোড়ার সংখ্যা গণনা করে যাদের যোগফল একটি প্রদত্ত জোড় সংখ্যার সমান হয়। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, even_number, যা একটি জোড় সংখ্যা যা ৬ এর চেয়ে বড় এবং ৩২৭৬৭ এর চেয়ে ছোট। \nএটি ভিন্ন মৌলিক জোড়ার সংখ্যা ফেরত দেয় যাদের যোগফল প্রদত্ত জোড় সংখ্যার সমান। \nএকটি মৌলিক জোড়াকে ভিন্ন বলে বিবেচনা করা হয় যদি জোড়ার মৌলিক সংখ্যা ভিন্ন হয়, তাদের ক্রম নির্বিশেষে।\n\nউদাহরণ:\n>>> count_prime_pairs(10)\n2 (কারণ 10 কে 3+7 এবং 5+5 হিসাবে প্রকাশ করা যায়)\n>>> count_prime_pairs(14)\n2 (কারণ 14 কে 3+11 এবং 7+7 হিসাবে প্রকাশ করা যায়)",
      "bg": "Тази функция изчислява броя на различните двойки прости числа, чиято сума е равна на дадено четно число. \nФункцията приема един аргумент, even_number, което е четно число по-голямо от 6 и по-малко от 32767. \nТя връща броя на различните двойки прости числа, чиято сума е равна на даденото четно число. \nДвойка прости числа се счита за различна, ако простите числа в двойката са различни, независимо от техния ред.\n\nПример:\n>>> count_prime_pairs(10)\n2 (тъй като 10 може да се изрази като 3+7 и 5+5)\n>>> count_prime_pairs(14)\n2 (тъй като 14 може да се изрази като 3+11 и 7+7)",
      "zh": "该函数计算和等于给定偶数的不同质数对的数量。  \n该函数接受一个参数，even_number，这是一个大于6且小于32767的偶数。  \n它返回和等于给定偶数的不同质数对的数量。  \n如果质数对中的质数不同，则该质数对被视为不同的，无论它们的顺序如何。\n\n示例：  \n>>> count_prime_pairs(10)  \n2 (因为10可以表示为3+7和5+5)  \n>>> count_prime_pairs(14)  \n2 (因为14可以表示为3+11和7+7)",
      "fr": "Cette fonction calcule le nombre de paires de nombres premiers différentes dont la somme est égale à un nombre pair donné.\nLa fonction accepte un seul argument, even_number, qui est un nombre pair supérieur à 6 et inférieur à 32767.\nElle renvoie le nombre de paires de nombres premiers distinctes dont la somme est égale au nombre pair donné.\nUne paire de nombres premiers est considérée comme distincte si les nombres premiers de la paire sont différents, indépendamment de leur ordre.\n\nExemple :\n>>> count_prime_pairs(10)\n2 (puisque 10 peut être exprimé comme 3+7 et 5+5)\n>>> count_prime_pairs(14)\n2 (puisque 14 peut être exprimé comme 3+11 et 7+7)",
      "de": "Diese Funktion berechnet die Anzahl der verschiedenen Primzahlpaare, deren Summe einer gegebenen geraden Zahl entspricht.  \nDie Funktion akzeptiert ein einziges Argument, even_number, das eine gerade Zahl größer als 6 und kleiner als 32767 ist.  \nSie gibt die Anzahl der unterschiedlichen Primzahlpaare zurück, deren Summe der gegebenen geraden Zahl entspricht.  \nEin Primzahlpaar wird als unterschiedlich betrachtet, wenn die Primzahlen im Paar verschieden sind, unabhängig von ihrer Reihenfolge.  \n\nBeispiel:  \n>>> count_prime_pairs(10)  \n2 (da 10 als 3+7 und 5+5 ausgedrückt werden kann)  \n>>> count_prime_pairs(14)  \n2 (da 14 als 3+11 und 7+7 ausgedrückt werden kann)  ",
      "ha": "Wannan aikin yana ƙididdige adadin nau'ikan ma'aurata lambobin farko daban-daban waɗanda jimlarsu ta yi daidai da wani lamba mai ma'ana.\n\nAikin yana karɓar hujja guda ɗaya, even_number, wanda shine lamba mai ma'ana wanda ya fi 6 kuma ƙasa da 32767.\n\nYana mayar da adadin ma'aurata lambobin farko daban-daban waɗanda jimlarsu ta yi daidai da lambar mai ma'ana da aka bayar.\n\nAna ɗaukar ma'aurata lambobin farko daban-daban idan lambobin farko a cikin ma'auratan sun bambanta, ba tare da la'akari da tsarinsu ba.\n\nMisali:\n>>> count_prime_pairs(10)\n2 (saboda 10 za a iya bayyana shi da 3+7 da 5+5)\n>>> count_prime_pairs(14)\n2 (saboda 14 za a iya bayyana shi da 3+11 da 7+7)",
      "hi": "यह फ़ंक्शन उन विभिन्न अभाज्य युग्मों की संख्या की गणना करता है जिनका योग एक दिए गए सम संख्या के बराबर होता है। \nयह फ़ंक्शन एकल तर्क, even_number, को स्वीकार करता है, जो 6 से बड़ा और 32767 से कम एक सम संख्या है। \nयह उन भिन्न अभाज्य युग्मों की गिनती लौटाता है जिनका योग दिए गए सम संख्या के बराबर होता है। \nएक अभाज्य युग्म को भिन्न माना जाता है यदि युग्म में अभाज्य संख्याएँ अलग-अलग हों, चाहे उनकी क्रम कुछ भी हो।\n\nउदाहरण:\n>>> count_prime_pairs(10)\n2 (क्योंकि 10 को 3+7 और 5+5 के रूप में व्यक्त किया जा सकता है)\n>>> count_prime_pairs(14)\n2 (क्योंकि 14 को 3+11 और 7+7 के रूप में व्यक्त किया जा सकता है)",
      "hu": "Ez a függvény kiszámítja azon különböző prímpárok számát, amelyek összege megegyezik egy adott páros számmal.  \nA függvény egyetlen argumentumot fogad el, even_number, amely egy 6-nál nagyobb és 32767-nél kisebb páros szám.  \nVisszaadja azon különböző prímpárok számát, amelyek összege megegyezik a megadott páros számmal.  \nEgy prímpárt akkor tekintünk különbözőnek, ha a párban lévő prímek különböznek, függetlenül a sorrendtől.\n\nPélda:\n>>> count_prime_pairs(10)\n2 (mivel a 10 kifejezhető 3+7 és 5+5 összegeként)\n>>> count_prime_pairs(14)\n2 (mivel a 14 kifejezhető 3+11 és 7+7 összegeként)"
    },
    "docstring_bertscore": {
      "sq": "0.9592039019303874",
      "hy": "0.9508578505800634",
      "bn": "0.9816878679116315",
      "bg": "0.9549937323739719",
      "zh": "0.9636369347743241",
      "fr": "0.9626553034312496",
      "de": "0.9811414357334046",
      "ha": "0.9475740931207948",
      "hi": "0.8619679742416165",
      "hu": "0.9814906279432639"
    }
  },
  {
    "task_id": "Ruby/23",
    "prompt": {
      "en": "# Calculates the minimum number of character operations needed to transform one string into another.\n# The function takes two string arguments, str_a and str_b. The operations allowed are:\n# 1. Delete a character;\n# 2. Insert a character;\n# 3. Replace a character with another.\n# It returns an integer representing the minimum number of operations required to transform str_a into str_b.\n# Both strings should have a length less than 200.\n#\n# Example:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "sq": "# Llogarit numrin minimal të operacioneve të karaktereve të nevojshme për të transformuar një varg në një tjetër.\n# Funksioni merr dy argumente vargjesh, str_a dhe str_b. Operacionet e lejuara janë:\n# 1. Fshi një karakter;\n# 2. Fut një karakter;\n# 3. Zëvendëso një karakter me një tjetër.\n# Kthen një numër të plotë që përfaqëson numrin minimal të operacioneve të nevojshme për të transformuar str_a në str_b.\n# Të dy vargjet duhet të kenë një gjatësi më pak se 200.\n#\n# Shembull:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "hy": "# Հաշվում է նվազագույն քանակով գործողությունները, որոնք անհրաժեշտ են մեկ տողը մյուսի վերափոխելու համար։\n# Ֆունկցիան ընդունում է երկու տողային արգումենտ՝ str_a և str_b։ Թույլատրված գործողություններն են՝\n# 1. Ջնջել տառը;\n# 2. Ներդնել տառը;\n# 3. Փոխարինել տառը մեկ այլ տառով։\n# Վերադարձնում է ամբողջ թիվ, որը ներկայացնում է նվազագույն գործողությունների քանակը, որոնք անհրաժեշտ են str_a-ը str_b-ի վերափոխելու համար։\n# Երկու տողերի երկարությունը պետք է լինի 200-ից պակաս։\n#\n# Օրինակ:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "bn": "# একটি স্ট্রিংকে অন্য স্ট্রিংয়ে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক চরিত্র অপারেশন গণনা করে।\n# ফাংশনটি দুটি স্ট্রিং আর্গুমেন্ট নেয়, str_a এবং str_b। অনুমোদিত অপারেশনগুলি হল:\n# 1. একটি চরিত্র মুছে ফেলা;\n# 2. একটি চরিত্র সন্নিবেশ করা;\n# 3. একটি চরিত্রকে অন্যটির সাথে প্রতিস্থাপন করা।\n# এটি একটি পূর্ণসংখ্যা প্রদান করে যা str_a কে str_b তে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন অপারেশনের সংখ্যা নির্দেশ করে।\n# উভয় স্ট্রিংয়ের দৈর্ঘ্য ২০০ এর কম হওয়া উচিত।\n#\n# উদাহরণ:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "bg": "# Изчислява минималния брой операции с символи, необходими за преобразуване на един низ в друг.\n# Функцията приема два аргумента от тип низ, str_a и str_b. Разрешените операции са:\n# 1. Изтриване на символ;\n# 2. Вмъкване на символ;\n# 3. Замяна на един символ с друг.\n# Връща цяло число, представляващо минималния брой операции, необходими за преобразуване на str_a в str_b.\n# И двата низа трябва да имат дължина по-малка от 200.\n#\n# Пример:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "zh": "# 计算将一个字符串转换为另一个字符串所需的最小字符操作数。\n# 该函数接受两个字符串参数，str_a 和 str_b。允许的操作有：\n# 1. 删除一个字符；\n# 2. 插入一个字符；\n# 3. 用另一个字符替换一个字符。\n# 它返回一个整数，表示将 str_a 转换为 str_b 所需的最小操作数。\n# 两个字符串的长度都应小于 200。\n#\n# 示例：\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "fr": "# Calcule le nombre minimum d'opérations de caractères nécessaires pour transformer une chaîne en une autre.\n# La fonction prend deux arguments de type chaîne, str_a et str_b. Les opérations autorisées sont :\n# 1. Supprimer un caractère ;\n# 2. Insérer un caractère ;\n# 3. Remplacer un caractère par un autre.\n# Elle renvoie un entier représentant le nombre minimum d'opérations nécessaires pour transformer str_a en str_b.\n# Les deux chaînes doivent avoir une longueur inférieure à 200.\n#\n# Exemple:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "de": "# Berechnet die minimale Anzahl von Zeichenoperationen, die erforderlich sind, um einen String in einen anderen zu transformieren.\n# Die Funktion nimmt zwei String-Argumente, str_a und str_b. Die erlaubten Operationen sind:\n# 1. Ein Zeichen löschen;\n# 2. Ein Zeichen einfügen;\n# 3. Ein Zeichen durch ein anderes ersetzen.\n# Sie gibt eine ganze Zahl zurück, die die minimale Anzahl von Operationen darstellt, die erforderlich sind, um str_a in str_b zu transformieren.\n# Beide Strings sollten eine Länge von weniger als 200 haben.\n#\n# Beispiel:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "ha": "# Lissafin mafi ƙarancin adadin ayyukan haruffa da ake buƙata don canza kirtani ɗaya zuwa wani.\n# Aikin yana ɗaukar hujjoji guda biyu na kirtani, str_a da str_b. Ayyukan da aka yarda su ne:\n# 1. Goge harafi;\n# 2. Saka harafi;\n# 3. Maye gurbin harafi da wani.\n# Yana dawowa da lamba mai nuna mafi ƙarancin adadin ayyukan da ake buƙata don canza str_a zuwa str_b.\n# Duk kirtanai ya kamata su kasance da tsawon ƙasa da 200.\n#\n# Misali:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "hi": "# एक स्ट्रिंग को दूसरी स्ट्रिंग में बदलने के लिए आवश्यक न्यूनतम वर्ण संचालन की गणना करता है।\n# फ़ंक्शन दो स्ट्रिंग तर्क लेता है, str_a और str_b। अनुमत संचालन हैं:\n# 1. एक वर्ण हटाएं;\n# 2. एक वर्ण जोड़ें;\n# 3. एक वर्ण को दूसरे के साथ बदलें।\n# यह एक पूर्णांक लौटाता है जो str_a को str_b में बदलने के लिए आवश्यक न्यूनतम संचालन की संख्या का प्रतिनिधित्व करता है।\n# दोनों स्ट्रिंग्स की लंबाई 200 से कम होनी चाहिए।\n#\n# उदाहरण:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "hu": "# Kiszámítja a minimális karakterműveletek számát, amelyek szükségesek az egyik string átalakításához a másikká.\n# A függvény két string argumentumot vesz fel, str_a és str_b. Az engedélyezett műveletek a következők:\n# 1. Egy karakter törlése;\n# 2. Egy karakter beszúrása;\n# 3. Egy karakter cseréje egy másikra.\n# Visszaad egy egész számot, amely a minimális műveletek számát jelenti, amelyek szükségesek str_a átalakításához str_b-vé.\n# Mindkét string hossza kevesebb, mint 200 legyen.\n#\n# Példa:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)"
    },
    "prompt_bertscore": {
      "sq": "0.9923670317175913",
      "hy": "0.9853377011631477",
      "bn": "0.9769562936049995",
      "bg": "0.9704392308032448",
      "zh": "0.9809074491445455",
      "fr": "0.9936376702650715",
      "de": "0.99426693131219",
      "ha": "0.974003851621297",
      "hi": "0.9829704242819739",
      "hu": "0.9698663807843402"
    },
    "canonical_solution": "    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end",
    "instruction": {
      "en": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nJepni një përshkrim të shkurtër në gjuhën natyrale (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nনিচের রুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简明的自然语言描述（文档字符串）。",
      "fr": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def min_operations_to_transform(str_a, str_b)\n    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.923607152714744",
      "bn": "0.8737062352392543",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9341001998536741",
      "hi": "0.9027873120658102",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless min_operations_to_transform(\"apple\", \"aple\") == 1\nraise 'Test failed' unless min_operations_to_transform(\"kitten\", \"sitting\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"sfdxbqw\", \"gfdgw\") == 4\nraise 'Test failed' unless min_operations_to_transform(\"horse\", \"ros\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"\", \"abc\") == 3\n\n\n\nputs 'All tests passed!'",
    "entry_point": "min_operations_to_transform",
    "signature": "def min_operations_to_transform(str_a, str_b)",
    "docstring": {
      "en": "Calculates the minimum number of character operations needed to transform one string into another.\nThe function takes two string arguments, str_a and str_b. The operations allowed are:\n1. Delete a character;\n2. Insert a character;\n3. Replace a character with another.\nIt returns an integer representing the minimum number of operations required to transform str_a into str_b.\nBoth strings should have a length less than 200.\n\nExample:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "sq": "Llogarit numrin minimal të operacioneve të karaktereve të nevojshme për të transformuar një varg në një tjetër. Funksioni merr dy argumente vargjesh, str_a dhe str_b. Operacionet e lejuara janë:\n1. Fshi një karakter;\n2. Shto një karakter;\n3. Zëvendëso një karakter me një tjetër.\nKthen një numër të plotë që përfaqëson numrin minimal të operacioneve të nevojshme për të transformuar str_a në str_b. Të dy vargjet duhet të kenë një gjatësi më pak se 200.\n\nShembull:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "hy": "Հաշվում է նվազագույն քանակով սիմվոլային գործողությունները, որոնք անհրաժեշտ են մեկ տողը մյուսի վերածելու համար։ \nՖունկցիան ընդունում է երկու տողային արգումենտ՝ str_a և str_b։ Թույլատրված գործողություններն են՝ \n1. Ջնջել սիմվոլը;\n2. Ներդնել սիմվոլը;\n3. Փոխարինել սիմվոլը մեկ այլ սիմվոլով։\nԱյն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է նվազագույն գործողությունների քանակը՝ str_a-ն str_b-ի վերածելու համար։\nԵրկու տողերի երկարությունը պետք է լինի 200-ից փոքր։\n\nՕրինակ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "bn": "একটি স্ট্রিংকে অন্য স্ট্রিংয়ে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক চরিত্র অপারেশন গণনা করে। ফাংশনটি দুটি স্ট্রিং আর্গুমেন্ট নেয়, str_a এবং str_b। অনুমোদিত অপারেশনগুলো হল:\n1. একটি চরিত্র মুছে ফেলা;\n2. একটি চরিত্র সন্নিবেশ করা;\n3. একটি চরিত্রকে অন্যটির সাথে প্রতিস্থাপন করা।\nএটি একটি পূর্ণসংখ্যা প্রদান করে যা str_a কে str_b তে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন অপারেশনের সংখ্যা নির্দেশ করে। উভয় স্ট্রিংয়ের দৈর্ঘ্য ২০০ এর কম হওয়া উচিত।\n\nউদাহরণ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "bg": "Изчислява минималния брой операции с символи, необходими за преобразуване на един низ в друг. Функцията приема два аргумента от тип низ, str_a и str_b. Позволените операции са:\n1. Изтриване на символ;\n2. Вмъкване на символ;\n3. Замяна на символ с друг.\nВръща цяло число, представляващо минималния брой операции, необходими за преобразуване на str_a в str_b. И двата низа трябва да имат дължина по-малка от 200.\n\nПример:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "zh": "计算将一个字符串转换为另一个字符串所需的最小字符操作数。\n该函数接受两个字符串参数，str_a 和 str_b。允许的操作有：\n1. 删除一个字符；\n2. 插入一个字符；\n3. 用另一个字符替换一个字符。\n它返回一个整数，表示将 str_a 转换为 str_b 所需的最小操作数。\n两个字符串的长度应小于 200。\n\n示例：\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "fr": "Calcule le nombre minimum d'opérations de caractères nécessaires pour transformer une chaîne en une autre.  \nLa fonction prend deux arguments de chaîne, str_a et str_b. Les opérations autorisées sont :  \n1. Supprimer un caractère ;  \n2. Insérer un caractère ;  \n3. Remplacer un caractère par un autre.  \nElle renvoie un entier représentant le nombre minimum d'opérations nécessaires pour transformer str_a en str_b.  \nLes deux chaînes doivent avoir une longueur inférieure à 200.\n\nExemple :  \n>>> min_operations_to_transform(\"apple\", \"aple\")  \n1  \n>>> min_operations_to_transform(\"kitten\", \"sitting\")  \n3  ",
      "de": "Berechnet die minimale Anzahl von Zeichenoperationen, die erforderlich sind, um einen String in einen anderen zu transformieren.\nDie Funktion nimmt zwei Zeichenfolgenargumente, str_a und str_b. Die erlaubten Operationen sind:\n1. Ein Zeichen löschen;\n2. Ein Zeichen einfügen;\n3. Ein Zeichen durch ein anderes ersetzen.\nSie gibt eine ganze Zahl zurück, die die minimale Anzahl von Operationen darstellt, die erforderlich sind, um str_a in str_b zu transformieren.\nBeide Zeichenfolgen sollten eine Länge von weniger als 200 haben.\n\nBeispiel:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "ha": "Yana lissafin mafi ƙarancin adadin ayyukan haruffa da ake buƙata don canza kirtani ɗaya zuwa wani.\nAikin yana ɗaukar hujjoji guda biyu na kirtani, str_a da str_b. Ayyukan da aka yarda sune:\n1. Goge harafi;\n2. Saka harafi;\n3. Maye gurbin harafi da wani.\nYana mayar da lamba mai nuna mafi ƙarancin adadin ayyukan da ake buƙata don canza str_a zuwa str_b.\nDuk kirtani yakamata su kasance da tsawon ƙasa da 200.\n\nMisali:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "hi": "एक स्ट्रिंग को दूसरी में बदलने के लिए आवश्यक न्यूनतम वर्ण ऑपरेशनों की गणना करता है। \nयह फ़ंक्शन दो स्ट्रिंग तर्क लेता है, str_a और str_b। अनुमत ऑपरेशन्स हैं:\n1. एक वर्ण को हटाना;\n2. एक वर्ण जोड़ना;\n3. एक वर्ण को दूसरे के साथ बदलना।\nयह एक पूर्णांक लौटाता है जो str_a को str_b में बदलने के लिए आवश्यक ऑपरेशन्स की न्यूनतम संख्या का प्रतिनिधित्व करता है।\nदोनों स्ट्रिंग्स की लंबाई 200 से कम होनी चाहिए।\n\nउदाहरण:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "hu": "Számítja a minimális karakter műveletek számát, amelyek szükségesek egy karakterlánc másikra történő átalakításához.  \nA függvény két karakterlánc argumentumot vesz fel, str_a és str_b. Az engedélyezett műveletek a következők:  \n1. Egy karakter törlése;  \n2. Egy karakter beszúrása;  \n3. Egy karakter másikra cserélése.  \nEgy egész számot ad vissza, amely a minimális műveletek számát jelenti, amelyek szükségesek str_a str_b-vé történő átalakításához.  \nMindkét karakterlánc hossza kevesebb, mint 200 kell legyen.  \n\nPélda:  \n>>> min_operations_to_transform(\"apple\", \"aple\")  \n1  \n>>> min_operations_to_transform(\"kitten\", \"sitting\")  \n3  "
    },
    "docstring_bertscore": {
      "sq": "0.9862593461311495",
      "hy": "0.98292553381586",
      "bn": "0.9682098034065092",
      "bg": "0.9676296040635063",
      "zh": "0.9689167289326124",
      "fr": "0.9914223456253893",
      "de": "0.9928614227359871",
      "ha": "0.9710682932199823",
      "hi": "0.9705649638344399",
      "hu": "0.9628936598884915"
    }
  },
  {
    "task_id": "Ruby/24",
    "prompt": {
      "en": "# Reverses the order of words in a given sentence and reverses each word itself.\n# The function takes a single argument, 'sentence', which is a string. It returns \n# a new string with each word in the sentence reversed and the order of words also reversed.\n# Punctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words \n# and is removed in the returned string.\n#\n# Example:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "sq": "# Kthen renditjen e fjalëve në një fjali të dhënë dhe kthen secilën fjalë vetë.\n# Funksioni merr një argument të vetëm, 'sentence', i cili është një varg. Ai kthen\n# një varg të ri me secilën fjalë në fjali të kthyer dhe renditja e fjalëve gjithashtu e kthyer.\n# Piksimi (hapësirat, presjet, pikat, shenjat e pikëçuditjes, shenjat e pikëpyetjes) përdoret për të identifikuar fjalët\n# dhe hiqet në vargun e kthyer.\n#\n# Shembull:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "hy": "# Շրջում է տրված նախադասության բառերի հերթականությունը և շրջում է յուրաքանչյուր բառը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ 'sentence', որը տող է։ Այն վերադարձնում է\n# նոր տող, որտեղ նախադասության յուրաքանչյուր բառ շրջված է, և բառերի հերթականությունը նույնպես շրջված է։\n# Կետադրությունը (դատարկություններ, ստորակետեր, կետեր, բացականչական նշաններ, հարցական նշաններ) օգտագործվում է բառերը \n# որոշելու համար և հեռացվում է վերադարձվող տողում։\n#\n# Օրինակ:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "bn": "# একটি প্রদত্ত বাক্যে শব্দগুলির ক্রম উল্টানো এবং প্রতিটি শব্দ নিজেই উল্টানো হয়।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, 'sentence', যা একটি স্ট্রিং। এটি একটি নতুন স্ট্রিং ফেরত দেয় \n# যেখানে বাক্যের প্রতিটি শব্দ উল্টানো হয় এবং শব্দগুলির ক্রমও উল্টানো হয়।\n# যতিচিহ্ন (স্পেস, কমা, পিরিয়ড, বিস্ময়সূচক চিহ্ন, প্রশ্নবোধক চিহ্ন) শব্দ চিহ্নিত করতে ব্যবহৃত হয় \n# এবং এটি ফেরত দেওয়া স্ট্রিং থেকে সরানো হয়।\n#\n# উদাহরণ:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "bg": "# Обръща реда на думите в дадено изречение и обръща всяка дума самостоятелно.\n# Функцията приема един аргумент, 'sentence', който е низ. Връща нов низ с всяка дума в изречението обърната и редът на думите също обърнат.\n# Пунктуацията (интервали, запетаи, точки, удивителни знаци, въпросителни знаци) се използва за идентифициране на думите и се премахва в върнатия низ.\n#\n# Пример:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "zh": "# 反转给定句子中单词的顺序，并反转每个单词本身。\n# 该函数接受一个参数 'sentence'，它是一个字符串。它返回一个新的字符串，\n# 其中句子中的每个单词都被反转，并且单词的顺序也被反转。\n# 标点符号（空格、逗号、句号、感叹号、问号）用于识别单词，并在返回的字符串中被移除。\n#\n# 示例:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "fr": "# Inverse l'ordre des mots dans une phrase donnée et inverse chaque mot lui-même.\n# La fonction prend un seul argument, 'sentence', qui est une chaîne de caractères. Elle retourne\n# une nouvelle chaîne avec chaque mot dans la phrase inversé et l'ordre des mots également inversé.\n# La ponctuation (espaces, virgules, points, points d'exclamation, points d'interrogation) est utilisée pour identifier les mots\n# et est supprimée dans la chaîne retournée.\n#\n# Exemple :\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "de": "# Kehrt die Reihenfolge der Wörter in einem gegebenen Satz um und kehrt jedes Wort selbst um.\n# Die Funktion nimmt ein einzelnes Argument, 'sentence', das ein String ist. Sie gibt \n# einen neuen String zurück, bei dem jedes Wort im Satz umgekehrt und die Reihenfolge der Wörter ebenfalls umgekehrt ist.\n# Satzzeichen (Leerzeichen, Kommas, Punkte, Ausrufezeichen, Fragezeichen) werden verwendet, um Wörter zu identifizieren \n# und werden im zurückgegebenen String entfernt.\n#\n# Beispiel:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "ha": "# Juya tsarin kalmomi a cikin jumla da aka bayar kuma juya kowace kalma kanta.\n# Aikin yana karɓar hujja guda ɗaya, 'sentence', wanda yake a matsayin igiya. Yana mayar da \n# sabon igiya tare da kowace kalma a cikin jumlar an juyata kuma tsarin kalmomi ma an juyata.\n# Alamomin rubutu (tazara, wakafi, maki, alamar mamaki, tambaya) ana amfani da su don gano kalmomi \n# kuma an cire su a cikin igiyar da aka mayar.\n#\n# Misali:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "hi": "# वाक्य में शब्दों के क्रम को उलटता है और प्रत्येक शब्द को स्वयं भी उलटता है।\n# यह फ़ंक्शन एकल तर्क 'sentence' लेता है, जो एक स्ट्रिंग है। यह एक नई स्ट्रिंग लौटाता है \n# जिसमें वाक्य के प्रत्येक शब्द को उलटा किया गया है और शब्दों का क्रम भी उलटा किया गया है।\n# विराम चिह्न (स्पेस, कॉमा, पीरियड, विस्मयादिबोधक चिह्न, प्रश्न चिह्न) का उपयोग शब्दों की पहचान के लिए किया जाता है \n# और लौटाई गई स्ट्रिंग में हटा दिया जाता है।\n#\n# उदाहरण:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "hu": "# Megfordítja a szavak sorrendjét egy adott mondatban, és megfordítja magukat a szavakat is.\n# A függvény egyetlen argumentumot vesz fel, 'sentence', amely egy string. Visszaad egy új stringet,\n# amelyben a mondat minden szava meg van fordítva, és a szavak sorrendje is meg van fordítva.\n# A központozás (szóközök, vesszők, pontok, felkiáltójelek, kérdőjelek) a szavak azonosítására szolgál,\n# és eltávolításra kerül a visszaadott stringben.\n#\n# Példa:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)"
    },
    "prompt_bertscore": {
      "sq": "0.9769779443165323",
      "hy": "0.977773061731815",
      "bn": "0.9807112023280831",
      "bg": "0.9795581529661755",
      "zh": "0.971709869350725",
      "fr": "0.9838056650342256",
      "de": "0.9804051129109083",
      "ha": "0.9823294440423743",
      "hi": "0.9755051000411586",
      "hu": "0.9730206312351742"
    },
    "canonical_solution": "    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end",
    "instruction": {
      "en": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def reverse_words_in_sentence(sentence)\n    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9202439431030613",
      "bn": "0.8897698714143077",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9408021875401723",
      "hi": "0.9027873120658102",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless reverse_words_in_sentence(\"hello world!\") == \"dlrow olleh\"\nraise 'Test failed' unless reverse_words_in_sentence(\"This is, a test.\") == \"tset a si sihT\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Ruby, programming!\") == \"gnimmargorp ybuR\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Keep calm and code on.\") == \"no edoc dna mlac peeK\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Simple sentence.\") == \"ecnetnes elpmiS\"\n\n\n\nputs 'All tests passed!'",
    "entry_point": "reverse_words_in_sentence",
    "signature": "def reverse_words_in_sentence(sentence)",
    "docstring": {
      "en": "Reverses the order of words in a given sentence and reverses each word itself.\nThe function takes a single argument, 'sentence', which is a string. It returns\na new string with each word in the sentence reversed and the order of words also reversed.\nPunctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words\nand is removed in the returned string.\n\nExample:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "sq": "Kthen renditjen e fjalëve në një fjali të dhënë dhe kthen secilën fjalë vetë.\nFunksioni merr një argument të vetëm, 'sentence', i cili është një varg. Ai kthen\nnjë varg të ri me secilën fjalë në fjali të kthyer dhe renditjen e fjalëve gjithashtu të kthyer.\nPikësimi (hapësirat, presjet, pikat, shenjat e pikëçuditjes, shenjat e pikëpyetjes) përdoret për të identifikuar fjalët\ndhe hiqet në vargun e kthyer.\n\nShembull:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hy": "Փոխում է տրված նախադասության բառերի հերթականությունը և փոխում է յուրաքանչյուր բառը:\nՖունկցիան ընդունում է մեկ արգումենտ, 'sentence', որը տող է։ Այն վերադարձնում է\nնոր տող, որտեղ նախադասության յուրաքանչյուր բառը փոխված է, և բառերի հերթականությունը նույնպես փոխված է:\nԿետադրությունը (բացատներ, ստորակետներ, կետեր, բացականչական նշաններ, հարցական նշաններ) օգտագործվում է բառերը որոշելու համար\nև հեռացվում է վերադարձվող տողում։\n\nՕրինակ:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "bn": "প্রদত্ত বাক্যে শব্দগুলির ক্রম উল্টে দেয় এবং প্রতিটি শব্দ নিজেই উল্টে দেয়।\nফাংশনটি একটি একক আর্গুমেন্ট, 'sentence', গ্রহণ করে, যা একটি স্ট্রিং। এটি একটি নতুন স্ট্রিং ফেরত দেয় যেখানে বাক্যের প্রতিটি শব্দ উল্টানো হয় এবং শব্দগুলির ক্রমও উল্টানো হয়। \nবিরামচিহ্ন (স্পেস, কমা, পিরিয়ড, বিস্ময়সূচক চিহ্ন, প্রশ্নবোধক চিহ্ন) শব্দগুলি চিহ্নিত করতে ব্যবহৃত হয় এবং ফেরত দেওয়া স্ট্রিং-এ সরানো হয়।\n\nউদাহরণ:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "bg": "Обръща реда на думите в дадено изречение и обръща всяка дума сама по себе си.\nФункцията приема един аргумент, 'sentence', който е низ. Връща нов низ с всяка дума в изречението обърната и редът на думите също обърнат. \nПунктуацията (интервали, запетаи, точки, удивителни знаци, въпросителни знаци) се използва за идентифициране на думите и се премахва в върнатия низ.\n\nПример:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "zh": "将给定句子中的单词顺序颠倒，并且每个单词本身也颠倒。\n该函数接受一个参数，'sentence'，它是一个字符串。它返回一个新的字符串，其中句子中的每个单词都被颠倒，单词的顺序也被颠倒。\n标点符号（空格、逗号、句号、感叹号、问号）用于识别单词，并在返回的字符串中被移除。\n\n示例：\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "fr": "Inverse l'ordre des mots dans une phrase donnée et inverse chaque mot lui-même.\nLa fonction prend un seul argument, 'sentence', qui est une chaîne de caractères. Elle renvoie  \nune nouvelle chaîne avec chaque mot de la phrase inversé et l'ordre des mots également inversé.  \nLa ponctuation (espaces, virgules, points, points d'exclamation, points d'interrogation) est utilisée pour identifier les mots  \net est supprimée dans la chaîne renvoyée.  \n\nExemple :  \n>>> reverse_words_in_sentence(\"hello world!\")  \n\"dlrow olleh\"  \n>>> reverse_words_in_sentence(\"This is, a test.\")  \n\"tset a si sihT\"",
      "de": "Kehrt die Reihenfolge der Wörter in einem gegebenen Satz um und kehrt jedes Wort selbst um.\nDie Funktion nimmt ein einzelnes Argument, 'sentence', das ein String ist. Sie gibt\neinen neuen String zurück, bei dem jedes Wort im Satz umgekehrt ist und die Reihenfolge der Wörter ebenfalls umgekehrt ist.\nInterpunktion (Leerzeichen, Kommas, Punkte, Ausrufezeichen, Fragezeichen) wird verwendet, um Wörter zu identifizieren\nund wird im zurückgegebenen String entfernt.\n\nBeispiel:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "ha": "Juya tsarin kalmomi a cikin jumla da aka bayar kuma juya kowace kalma kanta.\nAikin yana ɗaukar hujja guda, 'sentence', wanda yake a matsayin kirtani. Yana dawowa\nda sabon kirtani tare da kowanne kalma a cikin jimla an juyar da ita kuma an juyar da tsarin kalmomin.\nAlamomin rubutu (tazara, wakafi, maki, alamun mamaki, tambayoyi) ana amfani da su don gano kalmomi\nkuma an cire su a cikin sabon kirtani da aka dawo dashi.\n\nMisali:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hi": "शब्दों के क्रम को उलटता है और दिए गए वाक्य में प्रत्येक शब्द को भी उलटता है।\nयह फ़ंक्शन एकल तर्क 'sentence' लेता है, जो एक स्ट्रिंग है। यह एक नई स्ट्रिंग लौटाता है जिसमें वाक्य के प्रत्येक शब्द को उलटा किया गया है और शब्दों का क्रम भी उलटा किया गया है। \nविराम चिह्न (स्पेस, कॉमा, पीरियड, विस्मयादिबोधक चिह्न, प्रश्न चिह्न) का उपयोग शब्दों की पहचान के लिए किया जाता है और लौटाई गई स्ट्रिंग में हटा दिया जाता है।\n\nउदाहरण:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hu": "Megfordítja a szavak sorrendjét egy adott mondatban, és magukat a szavakat is megfordítja.\nA függvény egyetlen argumentumot vesz fel, a 'sentence' nevűt, amely egy karakterlánc. Visszaad\negy új karakterláncot, amelyben minden szó a mondatban meg van fordítva, és a szavak sorrendje is meg van fordítva.\nA központozás (szóközök, vesszők, pontok, felkiáltójelek, kérdőjelek) a szavak azonosítására szolgál\nés el van távolítva a visszaadott karakterláncban.\n\nPélda:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\""
    },
    "docstring_bertscore": {
      "sq": "0.9856549138816604",
      "hy": "0.9778958153072945",
      "bn": "0.9827626569034114",
      "bg": "0.9852945983704631",
      "zh": "0.9610011096179911",
      "fr": "0.9825179442739764",
      "de": "0.9819939573288063",
      "ha": "1",
      "hi": "0.9859570306912144",
      "hu": "0.9686672491740326"
    }
  },
  {
    "task_id": "Ruby/25",
    "prompt": {
      "en": "# Calculates the number of unique permutations of a given string.\n# The function takes a single argument, str, which is a string consisting of\n# lowercase letters. It returns the total number of unique permutations that\n# can be formed with the characters in str.\n#\n# Example:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "sq": "# Llogarit numrin e permutacioneve unike të një vargu të dhënë.\n# Funksioni merr një argument të vetëm, str, i cili është një varg që përbëhet\n# nga shkronja të vogla. Ai kthen numrin total të permutacioneve unike që\n# mund të formohen me karakteret në str.\n#\n# Shembull:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "hy": "# Հաշվում է տրված տողի եզակի փոխատեղումների քանակը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ str, որը փոքրատառ տառերից\n# կազմված տող է։ Այն վերադարձնում է եզակի փոխատեղումների ընդհանուր քանակը,\n# որոնք կարելի է կազմել str-ի սիմվոլներով։\n#\n# Օրինակ:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "bn": "# প্রদত্ত একটি স্ট্রিং-এর ইউনিক পারমুটেশনের সংখ্যা গণনা করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা ছোট হাতের অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n# এটি স্ট্র-এ থাকা অক্ষরগুলির সাথে গঠিত ইউনিক পারমুটেশনের মোট সংখ্যা প্রদান করে।\n#\n# উদাহরণ:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "bg": "# Изчислява броя на уникалните пермутации на даден низ.\n# Функцията приема един аргумент, str, който е низ, състоящ се от\n# малки букви. Тя връща общия брой уникални пермутации, които\n# могат да бъдат образувани с символите в str.\n#\n# Пример:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "zh": "# 计算给定字符串的唯一排列数。\n# 该函数接受一个参数，str，这是一个由小写字母组成的字符串。\n# 它返回可以用 str 中的字符形成的唯一排列的总数。\n#\n# 示例:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "fr": "# Calcule le nombre de permutations uniques d'une chaîne donnée.\n# La fonction prend un seul argument, str, qui est une chaîne composée de\n# lettres minuscules. Elle renvoie le nombre total de permutations uniques qui\n# peuvent être formées avec les caractères dans str.\n#\n# Exemple:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "de": "# Berechnet die Anzahl der einzigartigen Permutationen eines gegebenen Strings.\n# Die Funktion nimmt ein einzelnes Argument, str, das ein String bestehend aus\n# Kleinbuchstaben ist. Sie gibt die Gesamtzahl der einzigartigen Permutationen zurück, die\n# mit den Zeichen in str gebildet werden können.\n#\n# Beispiel:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "ha": "# Lissafa adadin permutations na musamman na wani kirtani da aka bayar.\n# Aikin yana karɓar hujja guda ɗaya, str, wanda kirtani ne da ya ƙunshi\n# haruffa ƙanana. Yana mayar da jimlar adadin permutations na musamman da za a iya\n# samarwa da haruffan da ke cikin str.\n#\n# Misali:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "hi": "# दिए गए स्ट्रिंग के अद्वितीय क्रमपरिवर्तन की संख्या की गणना करता है।\n# यह फ़ंक्शन एक एकल तर्क लेता है, str, जो छोटे अक्षरों से बना एक स्ट्रिंग है।\n# यह उन कुल अद्वितीय क्रमपरिवर्तनों की संख्या लौटाता है जो\n# str में वर्णों के साथ बनाए जा सकते हैं।\n#\n# उदाहरण:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "hu": "# Kiszámítja egy adott karakterlánc egyedi permutációinak számát.\n# A függvény egyetlen argumentumot vesz fel, str, amely egy kisbetűkből álló\n# karakterlánc. Visszaadja az összes egyedi permutáció számát, amely\n# a str karaktereivel képezhető.\n#\n# Példa:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)"
    },
    "prompt_bertscore": {
      "sq": "0.9960182553817747",
      "hy": "0.9668031030480202",
      "bn": "0.9678770975182758",
      "bg": "0.9946117536536666",
      "zh": "0.9785199119645062",
      "fr": "0.9975965723894779",
      "de": "1",
      "ha": "0.973673727928017",
      "hi": "0.9868903948516974",
      "hu": "0.9813948880996052"
    },
    "canonical_solution": "    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end",
    "instruction": {
      "en": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\n请提供一段简洁的自然语言描述（文档字符串），用中文描述以下 Ruby 代码，字数不超过500个字符。",
      "fr": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nBa da takaitaccen bayanin yanayi (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def unique_permutations_count(str)\n    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9355553660251357",
      "hy": "0.8856923869524236",
      "bn": "0.9066884127493354",
      "bg": "0.8991035130191372",
      "zh": "0.8895074806809606",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.874888681897555",
      "hi": "0.9119288780921788",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless unique_permutations_count(\"aacc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abcd\") == 24\nraise 'Test failed' unless unique_permutations_count(\"aaa\") == 1\nraise 'Test failed' unless unique_permutations_count(\"ab\") == 2\nraise 'Test failed' unless unique_permutations_count(\"aacdarwqea\") == 151200\n\n  \n\nputs 'All tests passed!'",
    "entry_point": "unique_permutations_count",
    "signature": "def unique_permutations_count(str)",
    "docstring": {
      "en": "Calculates the number of unique permutations of a given string.\nThe function takes a single argument, str, which is a string consisting of\nlowercase letters. It returns the total number of unique permutations that\ncan be formed with the characters in str.\n\nExample:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "sq": "Llogarit numrin e permutacioneve unike të një vargu të dhënë. Funksioni merr një argument të vetëm, str, i cili është një varg që përbëhet nga shkronja të vogla. Ai kthen numrin total të permutacioneve unike që mund të formohen me karakteret në str.\n\nShembull:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "hy": "Հաշվում է տրված տողի եզակի փոխատեղումների քանակը։  \nՖունկցիան ընդունում է մեկ արգումենտ, str, որը տող է, բաղկացած փոքրատառերից։ Այն վերադարձնում է եզակի փոխատեղումների ընդհանուր քանակը,  \nորոնք կարող են կազմվել str-ի նիշերով։\n\nՕրինակ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "bn": "একটি প্রদত্ত স্ট্রিংয়ের অনন্য বিন্যাসের সংখ্যা গণনা করে। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা ছোট হাতের অক্ষর নিয়ে গঠিত একটি স্ট্রিং। এটি মোট অনন্য বিন্যাসের সংখ্যা ফেরত দেয় যা str-এর অক্ষরগুলির সাথে গঠন করা যেতে পারে।\n\nউদাহরণ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "bg": "Изчислява броя на уникалните пермутации на даден низ. Функцията приема един аргумент, str, който е низ, състоящ се от малки букви. Тя връща общия брой уникални пермутации, които могат да бъдат образувани с буквите в str.\n\nПример:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "zh": "计算给定字符串的唯一排列数。  \n该函数接受一个参数，str，这是一个由小写字母组成的字符串。它返回可以用 str 中的字符形成的唯一排列的总数。\n\n示例：\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "fr": "Calcule le nombre de permutations uniques d'une chaîne donnée.  \nLa fonction prend un seul argument, str, qui est une chaîne composée de lettres minuscules. Elle renvoie le nombre total de permutations uniques qui peuvent être formées avec les caractères de str.\n\nExemple :\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "de": "Berechnet die Anzahl der eindeutigen Permutationen eines gegebenen Strings.\nDie Funktion nimmt ein einziges Argument, str, das ein String bestehend aus\nKleinbuchstaben ist. Sie gibt die Gesamtanzahl der eindeutigen Permutationen zurück, die\nmit den Zeichen in str gebildet werden können.\n\nBeispiel:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "ha": "Yana lissafin adadin permutations na musamman na wata takamaiman kirtani. \n\nAikin yana ɗaukar hujja guda, str, wanda kirtani ne da ya ƙunshi haruffa ƙanana. Yana dawowa da jimillar adadin permutations na musamman da za a iya samarwa tare da haruffan da ke cikin str.\n\nMisali:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "hi": "दिए गए स्ट्रिंग की अद्वितीय क्रमपरिवर्तनों की संख्या की गणना करता है। \nयह फ़ंक्शन एकल तर्क लेता है, str, जो कि छोटे अक्षरों से बना एक स्ट्रिंग है। यह उन कुल अद्वितीय क्रमपरिवर्तनों की संख्या लौटाता है जो str में वर्णों के साथ बनाए जा सकते हैं।\n\nउदाहरण:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "hu": "Kiszámítja egy adott karakterlánc egyedi permutációinak számát.  \nA függvény egyetlen argumentumot vesz fel, str, amely egy kisbetűkből álló karakterlánc.  \nVisszaadja az összes egyedi permutáció számát, amely a str karaktereivel képezhető.\n\nPélda:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9969561880410214",
      "hy": "0.9885084379356076",
      "bn": "0.9814652032544915",
      "bg": "0.9881445470775516",
      "zh": "0.9793593239547596",
      "fr": "0.9902899538231095",
      "de": "0.999999801369619",
      "ha": "0.983284260284009",
      "hi": "0.9897737134627999",
      "hu": "0.989439021270756"
    }
  },
  {
    "task_id": "Ruby/26",
    "prompt": {
      "en": "# Finds the longest palindrome within a given string.\n# The function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\n# It returns the length of the longest palindrome that can be found within the string.\n# Palindromes are sequences that read the same backward as forward.\n# Note: The function is case-sensitive and considers each character.\n#\n# Example:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "sq": "# Gjen palindromin më të gjatë brenda një vargu të dhënë.\n# Funksioni merr një argument të vetëm, str, i cili është një varg që mund të përfshijë shkronja, numra dhe simbole.\n# Ai kthen gjatësinë e palindromit më të gjatë që mund të gjendet brenda vargut.\n# Palindromet janë sekuenca që lexohen njësoj mbrapsht si përpara.\n# Shënim: Funksioni është i ndjeshëm ndaj shkronjave të mëdha dhe konsideron secilën karakter.\n#\n# Shembull:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "hy": "# Գտնում է տրված տողի ամենաերկար պալինդրոմը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, str, որը տող է, որը կարող է ներառել տառեր, թվեր և սիմվոլներ։\n# Այն վերադարձնում է տողի մեջ գտնված ամենաերկար պալինդրոմի երկարությունը։\n# Պալինդրոմները այն հաջորդականություններն են, որոնք նույնն են կարդացվում հետադարձ և առաջ։\n# Նշում: Ֆունկցիան զգայուն է մեծատառերի նկատմամբ և հաշվի է առնում յուրաքանչյուր սիմվոլը։\n#\n# Օրինակ:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "bn": "# একটি প্রদত্ত স্ট্রিংয়ের মধ্যে সবচেয়ে দীর্ঘ প্যালিনড্রোম খুঁজে বের করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা একটি স্ট্রিং যা অক্ষর, সংখ্যা এবং প্রতীক অন্তর্ভুক্ত করতে পারে।\n# এটি স্ট্রিংয়ের মধ্যে পাওয়া সবচেয়ে দীর্ঘ প্যালিনড্রোমের দৈর্ঘ্য ফেরত দেয়।\n# প্যালিনড্রোম হল এমন সিকোয়েন্স যা পেছন থেকে পড়লেও সামনে থেকে পড়ার মতোই হয়।\n# নোট: ফাংশনটি কেস-সেন্সিটিভ এবং প্রতিটি অক্ষর বিবেচনা করে।\n#\n# উদাহরণ:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "bg": "# Намира най-дългия палиндром в даден низ.\n# Функцията приема един аргумент, str, който е низ и може да включва букви, цифри и символи.\n# Връща дължината на най-дългия палиндром, който може да бъде намерен в низа.\n# Палиндромите са последователности, които се четат еднакво напред и назад.\n# Забележка: Функцията е чувствителна към големината на буквите и разглежда всеки символ.\n#\n# Пример:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "zh": "# 查找给定字符串中的最长回文。\n# 该函数接收一个参数，str，这是一个可能包含字母、数字和符号的字符串。\n# 它返回可以在字符串中找到的最长回文的长度。\n# 回文是指正反读都相同的序列。\n# 注意：该函数区分大小写，并考虑每个字符。\n#\n# 示例:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "fr": "# Trouve le plus long palindrome dans une chaîne donnée.\n# La fonction prend un seul argument, str, qui est une chaîne pouvant inclure des lettres, des chiffres et des symboles.\n# Elle renvoie la longueur du plus long palindrome qui peut être trouvé dans la chaîne.\n# Les palindromes sont des séquences qui se lisent de la même manière à l'envers qu'à l'endroit.\n# Remarque : La fonction est sensible à la casse et considère chaque caractère.\n#\n# Exemple :\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "de": "# Findet das längste Palindrom innerhalb eines gegebenen Strings.\n# Die Funktion nimmt ein einziges Argument, str, das ein String ist, der Buchstaben, Zahlen und Symbole enthalten kann.\n# Sie gibt die Länge des längsten Palindroms zurück, das innerhalb des Strings gefunden werden kann.\n# Palindrome sind Sequenzen, die vorwärts und rückwärts gleich gelesen werden.\n# Hinweis: Die Funktion ist case-sensitiv und berücksichtigt jedes Zeichen.\n#\n# Beispiel:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "ha": "# Nemi mafi tsawon palindrome a cikin kowane igiyar rubutu da aka bayar.\n# Aikin yana karɓar hujja guda ɗaya, str, wanda igiyar rubutu ce da za ta iya haɗawa da haruffa, lambobi, da alamomi.\n# Yana mayar da tsawon mafi tsawon palindrome da za a iya samu a cikin igiyar rubutu.\n# Palindromes su ne jeri da suke karantawa iri ɗaya daga baya zuwa gaba da kuma gaba zuwa baya.\n# Lura: Aikin yana bambanta manyan baki da ƙananan baki kuma yana la'akari da kowane hali.\n#\n# Misali:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "hi": "# दिए गए स्ट्रिंग के भीतर सबसे लंबा पलिंड्रोम खोजता है।\n# फ़ंक्शन एकल तर्क लेता है, str, जो एक स्ट्रिंग है जिसमें अक्षर, संख्या, और प्रतीक शामिल हो सकते हैं।\n# यह उस स्ट्रिंग के भीतर पाए जाने वाले सबसे लंबे पलिंड्रोम की लंबाई लौटाता है।\n# पलिंड्रोम वे अनुक्रम होते हैं जो आगे और पीछे से पढ़ने पर समान होते हैं।\n# नोट: फ़ंक्शन केस-संवेदी है और प्रत्येक वर्ण को ध्यान में रखता है।\n#\n# उदाहरण:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "hu": "# Megkeresi a leghosszabb palindrómát egy adott sztringben.\n# A függvény egyetlen argumentumot vesz fel, str, amely egy sztring, ami tartalmazhat betűket, számokat és szimbólumokat.\n# Visszaadja a leghosszabb palindróma hosszát, amely megtalálható a sztringben.\n# A palindrómák olyan sorozatok, amelyek visszafelé olvasva ugyanazok, mint előre.\n# Megjegyzés: A függvény kis- és nagybetű érzékeny, és minden karaktert figyelembe vesz.\n#\n# Példa:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)"
    },
    "prompt_bertscore": {
      "sq": "0.9953524463445457",
      "hy": "0.9723963359475816",
      "bn": "0.9838324801356653",
      "bg": "0.9786295559348375",
      "zh": "0.9759142786260905",
      "fr": "0.9931869779305034",
      "de": "0.9916785788169244",
      "ha": "0.9866613740223642",
      "hi": "0.9808184627338419",
      "hu": "0.9778060343750667"
    },
    "canonical_solution": "    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end",
    "instruction": {
      "en": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\n请为以下 Ruby 代码提供一个简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def find_longest_palindrome(str)\n    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9403240842130213",
      "hy": "0.921106992108658",
      "bn": "0.8746987912532856",
      "bg": "0.8991035130191372",
      "zh": "0.8953416522327174",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9215894653041917",
      "hi": "0.9119288780921788",
      "hu": "0.9320642384480665"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_longest_palindrome(\"ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"12ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"A\") == 1\nraise 'Test failed' unless find_longest_palindrome(\"ABAKK\") == 3\nraise 'Test failed' unless find_longest_palindrome(\"51233214\") == 6\nraise 'Test failed' unless find_longest_palindrome(\"abaaab\") == 5\n\n\nputs 'All tests passed!'",
    "entry_point": "find_longest_palindrome",
    "signature": "def find_longest_palindrome(str)",
    "docstring": {
      "en": "Finds the longest palindrome within a given string.\nThe function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\nIt returns the length of the longest palindrome that can be found within the string.\nPalindromes are sequences that read the same backward as forward.\nNote: The function is case-sensitive and considers each character.\n\nExample:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "sq": "Gjen palindromën më të gjatë brenda një vargu të dhënë.\nFunksioni merr një argument të vetëm, str, i cili është një varg që mund të përfshijë shkronja, numra dhe simbole.\nKthen gjatësinë e palindromës më të gjatë që mund të gjendet brenda vargut.\nPalindromet janë sekuenca që lexohen njësoj nga mbrapa si përpara.\nShënim: Funksioni është i ndjeshëm ndaj shkronjave të mëdha dhe konsideron secilën karakter.\n\nShembull:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "hy": "Գտնում է ամենաերկար պալինդրոմը տրված տողում:\nՖունկցիան ընդունում է մեկ արգումենտ, str, որը տող է, որը կարող է ներառել տառեր, թվեր և սիմվոլներ:\nԱյն վերադարձնում է ամենաերկար պալինդրոմի երկարությունը, որը կարող է գտնվել տողի մեջ:\nՊալինդրոմները հաջորդականություններ են, որոնք նույնն են կարդացվում հետադարձ և առաջ:\nՆշում: Ֆունկցիան զգայուն է մեծատառերի նկատմամբ և հաշվի է առնում յուրաքանչյուր սիմվոլը:\n\nՕրինակ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "bn": "প্রদত্ত স্ট্রিংয়ের মধ্যে দীর্ঘতম প্যালিনড্রোম খুঁজে বের করে। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা একটি স্ট্রিং যা অক্ষর, সংখ্যা এবং প্রতীক অন্তর্ভুক্ত করতে পারে। \nএটি স্ট্রিংয়ের মধ্যে পাওয়া যেতে পারে এমন দীর্ঘতম প্যালিনড্রোমের দৈর্ঘ্য ফেরত দেয়। \nপ্যালিনড্রোম হল এমন ক্রম যা পিছন থেকে পড়লেও সামনে থেকে পড়ার মতোই থাকে। \nদ্রষ্টব্য: ফাংশনটি কেস-সেনসিটিভ এবং প্রতিটি অক্ষর বিবেচনা করে।\n\nউদাহরণ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "bg": "Намира най-дългия палиндром в даден низ.\nФункцията приема един аргумент, str, който е низ и може да включва букви, цифри и символи.\nВръща дължината на най-дългия палиндром, който може да бъде намерен в низа.\nПалиндромите са последователности, които се четат еднакво напред и назад.\nЗабележка: Функцията е чувствителна към малки и големи букви и разглежда всеки символ.\n\nПример:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "zh": "找到给定字符串中的最长回文。\n该函数接受一个参数，str，这是一个可能包含字母、数字和符号的字符串。\n它返回可以在字符串中找到的最长回文的长度。\n回文是正反读都相同的序列。\n注意：该函数区分大小写，并考虑每个字符。\n\n示例：\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "fr": "Trouve le plus long palindrome dans une chaîne donnée.  \nLa fonction prend un seul argument, str, qui est une chaîne pouvant inclure des lettres, des chiffres et des symboles.  \nElle renvoie la longueur du plus long palindrome qui peut être trouvé dans la chaîne.  \nLes palindromes sont des séquences qui se lisent de la même manière à l'envers qu'à l'endroit.  \nRemarque : La fonction est sensible à la casse et considère chaque caractère.\n\nExemple :\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "de": "Findet das längste Palindrom innerhalb eines gegebenen Strings.\nDie Funktion nimmt ein einzelnes Argument, str, das ein String ist, der Buchstaben, Zahlen und Symbole enthalten kann.\nSie gibt die Länge des längsten Palindroms zurück, das innerhalb des Strings gefunden werden kann.\nPalindrome sind Sequenzen, die rückwärts genauso gelesen werden wie vorwärts.\nHinweis: Die Funktion ist case-sensitive und betrachtet jedes Zeichen.\n\nBeispiel:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "ha": "Nemi mafi tsawon palindrome a cikin wani igiyar rubutu da aka bayar.\nAikin yana ɗaukar hujja guda ɗaya, str, wanda igiyar rubutu ce da za ta iya haɗa haruffa, lambobi, da alamomi.\nYana mayar da tsawon mafi tsawon palindrome da za a iya samu a cikin igiyar rubutun.\nPalindromes su ne jerin abubuwa da ake karantawa iri daya a baya kamar yadda suke a gaba.\nLura: Aikin yana da bambanci tsakanin manyan baki da ƙananan baki kuma yana la'akari da kowane hali.\n\nMisali:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "hi": "दिए गए स्ट्रिंग में सबसे लंबा पलिंड्रोम खोजता है।  \nयह फ़ंक्शन एकल तर्क, str लेता है, जो एक स्ट्रिंग है जिसमें अक्षर, संख्याएँ, और प्रतीक शामिल हो सकते हैं।  \nयह उस स्ट्रिंग में पाए जा सकने वाले सबसे लंबे पलिंड्रोम की लंबाई लौटाता है।  \nपलिंड्रोम वे अनुक्रम होते हैं जो आगे और पीछे से पढ़ने पर समान होते हैं।  \nनोट: फ़ंक्शन केस-संवेदी है और प्रत्येक वर्ण को ध्यान में रखता है।  \n\nउदाहरण:  \n>>> find_longest_palindrome(\"ABBA\")  \n4  \n>>> find_longest_palindrome(\"12ABBA\")  \n4  \n>>> find_longest_palindrome(\"A\")  \n1  \n>>> find_longest_palindrome(\"ABAKK\")  \n3  \n>>> find_longest_palindrome(\"51233214\")  \n6  \n>>> find_longest_palindrome(\"abaaab\")  \n5  ",
      "hu": "Megkeresi a leghosszabb palindrómát egy adott karakterláncban.\nA függvény egyetlen argumentumot vesz fel, str, amely egy karakterlánc, amely tartalmazhat betűket, számokat és szimbólumokat.\nVisszaadja a karakterláncban található leghosszabb palindróma hosszát.\nA palindrómák olyan sorozatok, amelyek előre és hátra olvasva is ugyanazok.\nMegjegyzés: A függvény kis- és nagybetűérzékeny, és minden karaktert figyelembe vesz.\n\nPélda:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5"
    },
    "docstring_bertscore": {
      "sq": "0.99157985951755",
      "hy": "0.9802907018114322",
      "bn": "0.987628108086861",
      "bg": "0.9802370716085528",
      "zh": "0.9713302866925674",
      "fr": "0.991602702011369",
      "de": "0.9961849062714629",
      "ha": "0.990088145355978",
      "hi": "0.9866071479283416",
      "hu": "0.9762126214584049"
    }
  },
  {
    "task_id": "Ruby/27",
    "prompt": {
      "en": "# Calculates the sum of two integers as perceived by Xiao Ming, a child who \n# simplifies numbers larger than 99 to their last two digits before addition, \n# and also keeps only the last two digits of the result if it exceeds 99.\n#\n# The function takes two arguments, a and b, which are non-negative integers, and \n# returns the final sum according to Xiao Ming's calculation method.\n#\n# Examples:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "sq": "# Llogarit shumën e dy numrave të plotë siç e percepton Xiao Ming, një fëmijë që\n# thjeshton numrat më të mëdhenj se 99 në dy shifrat e fundit të tyre para mbledhjes,\n# dhe gjithashtu mban vetëm dy shifrat e fundit të rezultatit nëse tejkalon 99.\n#\n# Funksioni merr dy argumente, a dhe b, të cilat janë numra të plotë jo-negativë, dhe\n# kthen shumën përfundimtare sipas metodës së llogaritjes së Xiao Ming.\n#\n# Shembuj:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "hy": "# Հաշվում է երկու ամբողջ թվերի գումարը, ինչպես ընկալում է Սյաո Մինը, \n# երեխա, ով պարզեցնում է 99-ից մեծ թվերը՝ պահելով միայն վերջին երկու թվանշանները \n# գումարումից առաջ, և եթե արդյունքը գերազանցում է 99-ը, պահում է միայն վերջին երկու թվանշանները։\n#\n# Ֆունկցիան ընդունում է երկու արգումենտ՝ a և b, որոնք ոչ բացասական ամբողջ թվեր են, և \n# վերադարձնում է վերջնական գումարը՝ համաձայն Սյաո Մինի հաշվարկի մեթոդի։\n#\n# Օրինակներ:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "bn": "# দুটি পূর্ণসংখ্যার যোগফল হিসাব করে যা জিয়াও মিং, একটি শিশু, যিনি 99 এর চেয়ে বড় সংখ্যাগুলিকে \n# যোগ করার আগে তাদের শেষ দুটি অঙ্কে সরলীকরণ করে, এবং যদি ফলাফল 99 ছাড়িয়ে যায় তবে \n# শুধুমাত্র শেষ দুটি অঙ্ক রাখে।\n#\n# ফাংশনটি দুটি আর্গুমেন্ট নেয়, a এবং b, যা অ-ঋণাত্মক পূর্ণসংখ্যা, এবং \n# জিয়াও মিং এর গণনা পদ্ধতি অনুযায়ী চূড়ান্ত যোগফল প্রদান করে।\n#\n# উদাহরণ:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "bg": "# Изчислява сумата на две цели числа, както я възприема Сяо Мин, дете, което \n# опростява числата, по-големи от 99, до последните им две цифри преди събиране, \n# и също така запазва само последните две цифри на резултата, ако той надвишава 99.\n#\n# Функцията приема два аргумента, a и b, които са неотрицателни цели числа, и \n# връща крайната сума според метода на изчисление на Сяо Мин.\n#\n# Примери:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "zh": "# 计算两个整数的和，按照小明的理解，一个孩子在加法前将大于99的数字简化为它们的最后两位数字，\n# 并且如果结果超过99，也只保留结果的最后两位数字。\n#\n# 该函数接受两个参数，a 和 b，它们是非负整数，并根据小明的计算方法返回最终的和。\n#\n# 示例:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "fr": "# Calcule la somme de deux entiers telle que perçue par Xiao Ming, un enfant qui \n# simplifie les nombres supérieurs à 99 à leurs deux derniers chiffres avant l'addition, \n# et conserve également uniquement les deux derniers chiffres du résultat si celui-ci dépasse 99.\n#\n# La fonction prend deux arguments, a et b, qui sont des entiers non négatifs, et \n# renvoie la somme finale selon la méthode de calcul de Xiao Ming.\n#\n# Exemples:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "de": "# Berechnet die Summe von zwei ganzen Zahlen, wie sie von Xiao Ming wahrgenommen wird, \n# einem Kind, das Zahlen größer als 99 auf ihre letzten zwei Ziffern vereinfacht, bevor \n# es sie addiert, und auch nur die letzten zwei Ziffern des Ergebnisses beibehält, wenn \n# es 99 übersteigt.\n#\n# Die Funktion nimmt zwei Argumente, a und b, die nicht-negative ganze Zahlen sind, und \n# gibt die endgültige Summe gemäß Xiao Mings Berechnungsmethode zurück.\n#\n# Beispiele:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "ha": "# Lissafin jimillar lambobi biyu kamar yadda Xiao Ming, wani yaro wanda\n# ke saukake lambobi masu girma fiye da 99 zuwa lambobinsu na ƙarshe biyu kafin a haɗa su,\n# kuma yana riƙe da lambobin ƙarshe biyu na sakamakon idan ya wuce 99.\n#\n# Aikin yana ɗaukar hujjoji guda biyu, a da b, waɗanda lambobi ne marasa kyau,\n# kuma yana mayar da jimillar ƙarshe bisa ga hanyar lissafin Xiao Ming.\n#\n# Misalai:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "hi": "# दो पूर्णांकों का योग गणना करता है जैसा कि शियाओ मिंग, एक बच्चा जो \n# 99 से बड़े संख्याओं को जोड़ने से पहले उनके अंतिम दो अंकों तक सरल करता है, \n# और यदि परिणाम 99 से अधिक हो तो केवल अंतिम दो अंकों को रखता है।\n#\n# यह फ़ंक्शन दो तर्क लेता है, a और b, जो गैर-ऋणात्मक पूर्णांक हैं, और \n# शियाओ मिंग की गणना विधि के अनुसार अंतिम योग लौटाता है।\n#\n# उदाहरण:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "hu": "# Kiszámítja két egész szám összegét Xiao Ming szerint, aki egy gyermek, \n# aki azokat a számokat, amelyek nagyobbak, mint 99, az utolsó két számjegyükre \n# egyszerűsíti összeadás előtt, és az eredményből is csak az utolsó két számjegyet \n# tartja meg, ha az meghaladja a 99-et.\n#\n# A függvény két argumentumot vesz fel, a és b, amelyek nem negatív egész számok, \n# és visszaadja a végső összeget Xiao Ming számítási módszere szerint.\n#\n# Példák:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)"
    },
    "prompt_bertscore": {
      "sq": "0.9939060199098496",
      "hy": "0.957840701625345",
      "bn": "0.9463529135381922",
      "bg": "0.9946055961118545",
      "zh": "0.9364666822133237",
      "fr": "0.9978953124825544",
      "de": "0.9596710805865815",
      "ha": "0.965891190968689",
      "hi": "0.9382478008400637",
      "hu": "0.9774353900840557"
    },
    "canonical_solution": "    a %= 100\n    b %= 100\n    (a + b) % 100\n  end",
    "instruction": {
      "en": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def ming_sum(a, b)\n    a %= 100\n    b %= 100\n    (a + b) % 100\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8888019455675248",
      "bn": "0.8746987912532856",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9215894653041917",
      "hi": "0.9119288780921788",
      "hu": "0.9320642384480665"
    },
    "level": "",
    "test": "raise 'Test failed' unless ming_sum(35, 80) == 15\nraise 'Test failed' unless ming_sum(15, 1152) == 67\nraise 'Test failed' unless ming_sum(1234, 5678) == 12\nraise 'Test failed' unless ming_sum(0, 99) == 99\nraise 'Test failed' unless ming_sum(50, 50) == 0\n\n\n\n\nputs 'All tests passed!'",
    "entry_point": "ming_sum",
    "signature": "def ming_sum(a, b)",
    "docstring": {
      "en": "Calculates the sum of two integers as perceived by Xiao Ming, a child who\nsimplifies numbers larger than 99 to their last two digits before addition,\nand also keeps only the last two digits of the result if it exceeds 99.\n\nThe function takes two arguments, a and b, which are non-negative integers, and\nreturns the final sum according to Xiao Ming's calculation method.\n\nExamples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "sq": "Llogarit shumën e dy numrave të plotë siç e percepton Xiao Ming, një fëmijë që thjeshton numrat më të mëdhenj se 99 në dy shifrat e tyre të fundit para mbledhjes, dhe gjithashtu mban vetëm dy shifrat e fundit të rezultatit nëse tejkalon 99.\n\nFunksioni merr dy argumente, a dhe b, të cilat janë numra të plotë jo-negativë, dhe kthen shumën përfundimtare sipas metodës së llogaritjes së Xiao Ming.\n\nShembuj:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hy": "Հաշվում է երկու ամբողջ թվերի գումարը, ինչպես ընկալում է Սյաո Մինը՝ մի երեխա, ով պարզեցնում է 99-ից մեծ թվերը՝ թողնելով միայն վերջին երկու թվանշանները, նախքան գումարելը, և եթե արդյունքը գերազանցում է 99-ը, պահում է միայն վերջին երկու թվանշանները:\n\nՖունկցիան ընդունում է երկու արգումենտ՝ a և b, որոնք ոչ բացասական ամբողջ թվեր են, և վերադարձնում է վերջնական գումարը՝ ըստ Սյաո Մինի հաշվարկի մեթոդի:\n\nՕրինակներ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "bn": "দুটি পূর্ণসংখ্যার যোগফল হিসাব করে যা শিয়াও মিং, একটি শিশু যিনি ৯৯ এর চেয়ে বড় সংখ্যাগুলিকে যোগ করার আগে তাদের শেষ দুটি অঙ্কে সরলীকৃত করে, এবং ফলাফল যদি ৯৯ এর বেশি হয় তবে শুধুমাত্র শেষ দুটি অঙ্ক রাখে।\n\nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, a এবং b, যা অ-ঋণাত্মক পূর্ণসংখ্যা, এবং\nXiao Ming এর গণনা পদ্ধতি অনুযায়ী চূড়ান্ত যোগফল প্রদান করে।\n\nউদাহরণসমূহ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "bg": "Изчислява сумата на две цели числа, както я възприема Сяо Минг, дете, което опростява числата, по-големи от 99, до последните им две цифри преди събирането, и също така запазва само последните две цифри на резултата, ако той надвишава 99.\n\nФункцията приема два аргумента, a и b, които са неотрицателни цели числа, и връща крайната сума според метода на изчисление на Сяо Минг.\n\nПримери:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "zh": "计算两个整数的和，按照小明的理解，一个孩子在加法前将大于99的数字简化为它们的最后两位数字，并且如果结果超过99，也只保留结果的最后两位数字。\n\nArgs:\n    a: 非负整数\n    b: 非负整数\n\nReturns:\n    根据小明的计算方法返回最终的和。\n\nExamples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "fr": "Calcule la somme de deux entiers telle que perçue par Xiao Ming, un enfant qui\nsimplifie les nombres supérieurs à 99 à leurs deux derniers chiffres avant l'addition,\net conserve également uniquement les deux derniers chiffres du résultat si celui-ci dépasse 99.\n\nLa fonction prend deux arguments, a et b, qui sont des entiers non négatifs, et\nrenvoie la somme finale selon la méthode de calcul de Xiao Ming.\n\nExemples :\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "de": "Berechnet die Summe von zwei ganzen Zahlen, wie sie von Xiao Ming wahrgenommen wird, einem Kind, das Zahlen größer als 99 auf ihre letzten beiden Ziffern vereinfacht, bevor es sie addiert, und auch nur die letzten beiden Ziffern des Ergebnisses behält, wenn es 99 übersteigt.\n\nDie Funktion nimmt zwei Argumente, a und b, die nicht-negative ganze Zahlen sind, und gibt die endgültige Summe gemäß Xiao Mings Berechnungsmethode zurück.\n\nBeispiele:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "ha": "Yana lissafin jimillar lambobi guda biyu kamar yadda Xiao Ming, wani yaro da\nke saukaka lambobi masu girma fiye da 99 zuwa lambobin ƙarshe biyu kafin ƙara,\nkuma yana riƙe da lambobin ƙarshe biyu na sakamakon idan ya wuce 99.\n\nAikin yana ɗaukar hujjoji guda biyu, a da b, waɗanda lambobi ne marasa kyau, kuma\nyana mayar da jimillar ƙarshe bisa ga hanyar lissafin Xiao Ming.\n\nMisalai:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hi": "Xiao Ming द्वारा देखे गए दो पूर्णांकों का योग गणना करता है, जो एक बच्चा है जो 99 से बड़े संख्याओं को जोड़ने से पहले उनके अंतिम दो अंकों तक सरल करता है, और यदि परिणाम 99 से अधिक हो जाता है तो केवल अंतिम दो अंकों को रखता है।\n\nयह फ़ंक्शन दो तर्क लेता है, a और b, जो गैर-ऋणात्मक पूर्णांक हैं, और Xiao Ming की गणना विधि के अनुसार अंतिम योग लौटाता है।\n\nउदाहरण:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hu": "Kiszámítja két egész szám összegét úgy, ahogyan Xiao Ming, egy gyermek, aki az\n99-nél nagyobb számokat az utolsó két számjegyükre egyszerűsíti összeadás előtt,\nés az eredményből is csak az utolsó két számjegyet tartja meg, ha az meghaladja a 99-et.\n\nA függvény két argumentumot vesz fel, a és b, amelyek nem negatív egész számok, és\nvisszaadja a végső összeget Xiao Ming számítási módszere szerint.\n\nPéldák:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67"
    },
    "docstring_bertscore": {
      "sq": "0.9932942383362622",
      "hy": "0.9552918765759053",
      "bn": "0.9915137156006655",
      "bg": "0.9909215984348004",
      "zh": "0.9208640671526522",
      "fr": "0.9916805651207348",
      "de": "0.9865590793761312",
      "ha": "0.9532950453553616",
      "hi": "0.9586878602004588",
      "hu": "0.9811513672524563"
    }
  },
  {
    "task_id": "Ruby/28",
    "prompt": {
      "en": "# Finds the longest word in a given sentence.\n# The function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\n# Each word is composed only of lowercase letters. The function returns the longest word found in the sentence.\n# If there are multiple words of the same longest length, it returns the first one encountered.\n#\n# Example:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "sq": "# Gjen fjalën më të gjatë në një fjali të dhënë.\n# Funksioni merr një argument të vetëm, fjali, e cila është një varg që përmban fjalë të shumta të ndara me hapësira.\n# Çdo fjalë përbëhet vetëm nga shkronja të vogla. Funksioni kthen fjalën më të gjatë të gjetur në fjali.\n# Nëse ka disa fjalë me të njëjtën gjatësi më të gjatë, kthen të parën që haset.\n#\n# Shembull:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "hy": "# Գտնում է ամենաերկար բառը տրված նախադասության մեջ։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ sentence, որը տող է, պարունակող բազմաթիվ բառեր, որոնք բաժանված են բացատներով։\n# Յուրաքանչյուր բառ բաղկացած է միայն փոքրատառ տառերից։ Ֆունկցիան վերադարձնում է նախադասության մեջ գտնված ամենաերկար բառը։\n# Եթե կան մի քանի նույն երկարությամբ բառեր, վերադարձնում է առաջին հանդիպածը։\n#\n# Օրինակ:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "bn": "# প্রদত্ত বাক্যে দীর্ঘতম শব্দটি খুঁজে বের করে।\n# ফাংশনটি একটি মাত্র আর্গুমেন্ট গ্রহণ করে, sentence, যা একটি স্ট্রিং যা একাধিক শব্দ দ্বারা গঠিত এবং স্পেস দ্বারা পৃথক।\n# প্রতিটি শব্দ শুধুমাত্র ছোট হাতের অক্ষর নিয়ে গঠিত। ফাংশনটি বাক্যে পাওয়া দীর্ঘতম শব্দটি ফেরত দেয়।\n# যদি একই দীর্ঘতম দৈর্ঘ্যের একাধিক শব্দ থাকে, তাহলে এটি প্রথম যে শব্দটি পাওয়া যায় সেটি ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "bg": "# Намира най-дългата дума в дадено изречение.\n# Функцията приема един аргумент, sentence, който е низ, съдържащ няколко думи, разделени с интервали.\n# Всяка дума е съставена само от малки букви. Функцията връща най-дългата дума, намерена в изречението.\n# Ако има няколко думи с една и съща най-голяма дължина, връща първата срещната.\n#\n# Пример:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "zh": "# 在给定的句子中找到最长的单词。\n# 该函数接受一个参数，sentence，这是一个包含多个以空格分隔的单词的字符串。\n# 每个单词仅由小写字母组成。函数返回在句子中找到的最长单词。\n# 如果有多个单词长度相同，则返回第一个遇到的单词。\n#\n# 示例:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "fr": "# Trouve le mot le plus long dans une phrase donnée.\n# La fonction prend un seul argument, sentence, qui est une chaîne contenant plusieurs mots séparés par des espaces.\n# Chaque mot est composé uniquement de lettres minuscules. La fonction renvoie le mot le plus long trouvé dans la phrase.\n# S'il y a plusieurs mots de même longueur maximale, elle renvoie le premier rencontré.\n#\n# Exemple :\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "de": "# Findet das längste Wort in einem gegebenen Satz.\n# Die Funktion nimmt ein einzelnes Argument, sentence, das ein String mit mehreren durch Leerzeichen getrennten Wörtern ist.\n# Jedes Wort besteht nur aus Kleinbuchstaben. Die Funktion gibt das längste Wort im Satz zurück.\n# Wenn es mehrere Wörter mit der gleichen längsten Länge gibt, wird das erste gefundene zurückgegeben.\n#\n# Beispiel:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "ha": "# Nemi kalma mafi tsawo a cikin jimla da aka bayar.\n# Aikin yana karɓar hujja guda ɗaya, sentence, wanda shine jeri na kalmomi da aka raba ta wurin sarari.\n# Kowace kalma an ƙirƙira ta ne kawai da ƙananan haruffa. Aikin yana dawowa da kalma mafi tsawo da aka samo a cikin jimlar.\n# Idan akwai kalmomi da yawa masu tsawon iri ɗaya, yana dawowa da na farko da aka haɗu da shi.\n#\n# Misali:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "hi": "# दिए गए वाक्य में सबसे लंबा शब्द खोजता है।\n# फ़ंक्शन एकल तर्क लेता है, sentence, जो एक स्ट्रिंग है जिसमें कई शब्द स्पेस द्वारा अलग किए गए होते हैं।\n# प्रत्येक शब्द केवल छोटे अक्षरों से बना होता है। फ़ंक्शन वाक्य में पाए गए सबसे लंबे शब्द को लौटाता है।\n# यदि समान लंबाई के कई शब्द हैं, तो यह पहले मिलने वाले को लौटाता है।\n#\n# उदाहरण:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "hu": "# Megkeresi a leghosszabb szót egy adott mondatban.\n# A függvény egyetlen argumentumot vesz fel, sentence, amely egy szóközökkel elválasztott szavakat tartalmazó string.\n# Minden szó csak kisbetűkből áll. A függvény visszaadja a mondatban talált leghosszabb szót.\n# Ha több azonos hosszúságú szó van, az elsőként találtat adja vissza.\n#\n# Példa:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)"
    },
    "prompt_bertscore": {
      "sq": "0.9889752193310396",
      "hy": "0.9821218752941928",
      "bn": "0.9841735284999021",
      "bg": "0.9846728852778239",
      "zh": "0.9715736089093351",
      "fr": "0.9920106888140148",
      "de": "0.9794745295757599",
      "ha": "0.9766148479800005",
      "hi": "0.9936591223462232",
      "hu": "0.984132412011028"
    },
    "canonical_solution": "  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend",
    "instruction": {
      "en": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\n请用最多500个字符的中文对该Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def find_longest_word(sentence)\n  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.923607152714744",
      "bn": "0.8882638558653012",
      "bg": "0.8364486908745768",
      "zh": "0.9600578764263327",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9215894653041917",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_longest_word(\"I am a student\") == \"student\"\nraise 'Test failed' unless find_longest_word(\"The quick brown fox jumps over the lazy dog\") == \"quick\"\nraise 'Test failed' unless find_longest_word(\"Hello world\") == \"Hello\"\nraise 'Test failed' unless find_longest_word(\"A B C D EFG HI\") == \"EFG\"\nraise 'Test failed' unless find_longest_word(\"Ruby Python Java\") == \"Python\"",
    "entry_point": "find_longest_word",
    "signature": "def find_longest_word(sentence)",
    "docstring": {
      "en": "Finds the longest word in a given sentence.\nThe function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\nEach word is composed only of lowercase letters. The function returns the longest word found in the sentence.\nIf there are multiple words of the same longest length, it returns the first one encountered.\n\nExample:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "sq": "Gjen fjalën më të gjatë në një fjali të dhënë.  \nFunksioni merr një argument të vetëm, fjali, i cili është një varg që përmban disa fjalë të ndara me hapësira.  \nÇdo fjalë përbëhet vetëm nga shkronja të vogla. Funksioni kthen fjalën më të gjatë të gjetur në fjali.  \nNëse ka disa fjalë me të njëjtën gjatësi më të madhe, kthen të parën që haset.  \n\nShembull:  \n>>> find_longest_word(\"I am a student\")  \n\"student\"  \n>>> find_longest_word(\"The quick brown fox\")  \n\"quick\"",
      "hy": "Գտնում է տրված նախադասության մեջ ամենաերկար բառը։ \nՖունկցիան ընդունում է մեկ արգումենտ՝ sentence, որը տող է, որը պարունակում է բազմաթիվ բառեր, որոնք բաժանված են բացատներով։ \nՅուրաքանչյուր բառ կազմված է միայն փոքրատառ տառերից։ Ֆունկցիան վերադարձնում է նախադասության մեջ գտնված ամենաերկար բառը։ \nԵթե կան մի քանի բառեր նույն ամենաերկար երկարությամբ, այն վերադարձնում է առաջինը, որը հանդիպում է։\n\nՕրինակ:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "bn": "প্রদত্ত বাক্যে সবচেয়ে দীর্ঘ শব্দটি খুঁজে বের করে। \nফাংশনটি একটি একক আর্গুমেন্ট sentence গ্রহণ করে, যা একটি স্ট্রিং যা একাধিক শব্দ স্পেস দ্বারা পৃথক করা থাকে। \nপ্রতিটি শব্দ শুধুমাত্র ছোট হাতের অক্ষর নিয়ে গঠিত। ফাংশনটি বাক্যে পাওয়া সবচেয়ে দীর্ঘ শব্দটি ফেরত দেয়। \nযদি একই দীর্ঘতম দৈর্ঘ্যের একাধিক শব্দ থাকে, তাহলে এটি প্রথমে যে শব্দটি পাওয়া যায় সেটি ফেরত দেয়।\n\nউদাহরণ:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "bg": "Намира най-дългата дума в дадено изречение.\nФункцията приема един аргумент, sentence, който е низ, съдържащ няколко думи, разделени с интервали.\nВсяка дума се състои само от малки букви. Функцията връща най-дългата дума, намерена в изречението.\nАко има няколко думи с еднаква най-голяма дължина, връща първата срещната.\n\nПример:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "zh": "找到给定句子中最长的单词。\n该函数接受一个参数 sentence，它是一个包含多个由空格分隔的单词的字符串。\n每个单词仅由小写字母组成。函数返回在句子中找到的最长单词。\n如果有多个单词具有相同的最长长度，则返回第一个遇到的单词。\n\n示例：\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "fr": "Trouve le mot le plus long dans une phrase donnée.  \nLa fonction prend un seul argument, sentence, qui est une chaîne de caractères contenant plusieurs mots séparés par des espaces.  \nChaque mot est composé uniquement de lettres minuscules. La fonction renvoie le mot le plus long trouvé dans la phrase.  \nS'il y a plusieurs mots de la même longueur maximale, elle renvoie le premier rencontré.  \n\nExemple :  \n>>> find_longest_word(\"I am a student\")  \n\"student\"  \n>>> find_longest_word(\"The quick brown fox\")  \n\"quick\"  ",
      "de": "Findet das längste Wort in einem gegebenen Satz.\nDie Funktion nimmt ein einzelnes Argument, sentence, das ein String ist, der mehrere durch Leerzeichen getrennte Wörter enthält.\nJedes Wort besteht nur aus Kleinbuchstaben. Die Funktion gibt das längste im Satz gefundene Wort zurück.\nWenn es mehrere Wörter mit der gleichen längsten Länge gibt, wird das erste gefundene zurückgegeben.\n\nBeispiel:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "ha": "Nemo mafi tsawon kalma a cikin wata jimla da aka bayar.\nAikin yana ɗaukar hujja guda ɗaya, sentence, wanda shine igiyar da ke ɗauke da kalmomi da yawa da aka raba su da sarari.\nKowane kalma an ƙirƙira shi ne kawai da ƙananan haruffa. Aikin yana mayar da mafi tsawon kalma da aka samu a cikin jimlar.\nIdan akwai kalmomi da yawa masu tsawon iri ɗaya, yana mayar da na farko da aka ci karo da shi.\n\nMisali:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "hi": "दिए गए वाक्य में सबसे लंबा शब्द खोजता है। \nयह फ़ंक्शन एकल तर्क लेता है, sentence, जो एक स्ट्रिंग है जिसमें कई शब्द स्पेस द्वारा अलग किए गए होते हैं। \nप्रत्येक शब्द केवल छोटे अक्षरों से बना होता है। फ़ंक्शन वाक्य में पाया गया सबसे लंबा शब्द लौटाता है। \nयदि समान लंबाई के कई शब्द हैं, तो यह पहले मिलने वाले शब्द को लौटाता है।\n\nउदाहरण:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "hu": "Megkeresi a leghosszabb szót egy adott mondatban.\nA függvény egyetlen argumentumot vesz fel, a sentence-t, amely egy szóközökkel elválasztott szavakat tartalmazó karakterlánc.\nMinden szó csak kisbetűkből áll. A függvény visszaadja a mondatban talált leghosszabb szót.\nHa több azonos hosszúságú szó van, az elsőként találtat adja vissza.\n\nPélda:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\""
    },
    "docstring_bertscore": {
      "sq": "0.9781812471648417",
      "hy": "0.9766194164787644",
      "bn": "0.9762253338027911",
      "bg": "0.9750591748357353",
      "zh": "0.9563227682534764",
      "fr": "0.9861787021964494",
      "de": "0.983677349808077",
      "ha": "0.9701093057403459",
      "hi": "0.9851219885693437",
      "hu": "0.9794193103298321"
    }
  },
  {
    "task_id": "Ruby/29",
    "prompt": {
      "en": "# Decrypts a message encrypted with Caesar's cipher.\n# The cipher shifts each letter in the message 5 positions to the right in the alphabet.\n# Non-letter characters are left unchanged. All letters are in uppercase.\n#\n# Example:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "sq": "# Dekripton një mesazh të koduar me shifrën e Cezarit.\n# Shifra zhvendos secilën shkronjë në mesazh 5 pozicione djathtas në alfabet.\n# Karakteret që nuk janë shkronja mbeten të pandryshuara. Të gjitha shkronjat janë me shkronja të mëdha.\n#\n# Shembull:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "hy": "# Ապակոդավորում է հաղորդագրությունը, որը կոդավորված է Կեսարի ծածկագրով։\n# Ծածկագիրը յուրաքանչյուր տառը հաղորդագրության մեջ տեղափոխում է 5 դիրքով դեպի աջ այբուբենում։\n# Ոչ տառային նիշերը մնում են անփոփոխ։ Բոլոր տառերը մեծատառ են։\n#\n# Օրինակ:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "bn": "# একটি বার্তা ডিক্রিপ্ট করে যা সিজারের সাইফার দিয়ে এনক্রিপ্ট করা হয়েছে।\n# সাইফার বার্তার প্রতিটি অক্ষরকে বর্ণমালায় ৫টি অবস্থান ডানদিকে সরিয়ে দেয়।\n# অক্ষর ব্যতীত অন্যান্য চরিত্র অপরিবর্তিত থাকে। সমস্ত অক্ষর বড় হাতের।\n#\n# উদাহরণ:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "bg": "# Декриптира съобщение, криптирано с шифъра на Цезар.\n# Шифърът измества всяка буква в съобщението с 5 позиции надясно в азбуката.\n# Символите, които не са букви, остават непроменени. Всички букви са с главни букви.\n#\n# Пример:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "zh": "# 解密使用凯撒密码加密的信息。\n# 密码将消息中的每个字母在字母表中向右移动5个位置。\n# 非字母字符保持不变。所有字母均为大写。\n#\n# 例子:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "fr": "# Décrypte un message chiffré avec le chiffre de César.\n# Le chiffre déplace chaque lettre du message de 5 positions vers la droite dans l'alphabet.\n# Les caractères non alphabétiques restent inchangés. Toutes les lettres sont en majuscules.\n#\n# Exemple :\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "de": "# Entschlüsselt eine mit dem Caesar-Verschlüsselung verschlüsselte Nachricht.\n# Die Verschlüsselung verschiebt jeden Buchstaben in der Nachricht um 5 Positionen nach rechts im Alphabet.\n# Nicht-Buchstaben-Zeichen bleiben unverändert. Alle Buchstaben sind in Großbuchstaben.\n#\n# Beispiel:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "ha": "# Yana warware saƙon da aka ɓoye tare da amfani da sifiri na Caesar.\n# Sifirin yana matsar da kowace harafi a cikin saƙon zuwa matsayi 5 a dama a cikin haruffan.\n# Haruffan da ba na harafi ba suna kasancewa ba a canza ba. Duk haruffa suna cikin manyan baki.\n#\n# Misali:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "hi": "# एक संदेश को डिक्रिप्ट करता है जिसे सीज़र के सिफर से एन्क्रिप्ट किया गया है।\n# सिफर संदेश में प्रत्येक अक्षर को वर्णमाला में 5 स्थान दाईं ओर स्थानांतरित करता है।\n# गैर-अक्षर वर्ण अपरिवर्तित रहते हैं। सभी अक्षर बड़े अक्षरों में होते हैं।\n#\n# उदाहरण:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "hu": "# Dekódolja a Caesar-rejtjel által titkosított üzenetet.\n# A rejtjel az üzenet minden betűjét 5 pozícióval jobbra tolja az ábécében.\n# A nem betű karakterek változatlanok maradnak. Minden betű nagybetűs.\n#\n# Példa:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)"
    },
    "prompt_bertscore": {
      "sq": "0.9873770392852329",
      "hy": "0.9859598115165489",
      "bn": "0.9852814887653147",
      "bg": "0.988607753126125",
      "zh": "0.9707063886657368",
      "fr": "0.9909925094808298",
      "de": "0.9843290560882525",
      "ha": "0.9848174881952173",
      "hi": "0.9882728623037002",
      "hu": "0.9759855869328821"
    },
    "canonical_solution": "    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end",
    "instruction": {
      "en": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\n请用最多500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nBa da takaitaccen bayanin yanayi na dabi'a (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def decrypt_caesar_cipher(message)\n    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8838310216517457",
      "bn": "0.88409480279776",
      "bg": "0.8364486908745768",
      "zh": "0.880690675327584",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9660421500582755",
      "hi": "0.9027873120658102",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX') == 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\nraise 'Test failed' unless decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ') == 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\nraise 'Test failed' unless decrypt_caesar_cipher('IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ') == 'DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE'\nraise 'Test failed' unless decrypt_caesar_cipher('ABCDEF') == 'VWXYZA'\nraise 'Test failed' unless decrypt_caesar_cipher('XYZ') == 'STU'\n\n  \n\n\nputs 'All tests passed!'",
    "entry_point": "decrypt_caesar_cipher",
    "signature": "def decrypt_caesar_cipher(message)",
    "docstring": {
      "en": "Decrypts a message encrypted with Caesar's cipher.\nThe cipher shifts each letter in the message 5 positions to the right in the alphabet.\nNon-letter characters are left unchanged. All letters are in uppercase.\n\nExample:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "sq": "Dekripton një mesazh të koduar me shifrën e Cezarit. Shifra zhvendos secilën shkronjë në mesazh 5 pozicione djathtas në alfabet. Karakteret që nuk janë shkronja mbeten të pandryshuara. Të gjitha shkronjat janë me shkronja të mëdha.\n\nShembull:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hy": "Վերծանում է Կեսարի գաղտնագրով կոդավորված հաղորդագրությունը։\nԳաղտնագիրը յուրաքանչյուր տառը հաղորդագրության մեջ տեղափոխում է 5 դիրքով դեպի աջ այբուբենում։  \nՈչ տառային նիշերը մնում են անփոփոխ։ Բոլոր տառերը մեծատառ են։\n\nՕրինակ՝\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "bn": "Caesar এর সাইফার দিয়ে এনক্রিপ্ট করা একটি বার্তা ডিক্রিপ্ট করে। \nসাইফারটি বার্তার প্রতিটি অক্ষরকে বর্ণমালায় ৫টি অবস্থান ডানদিকে সরিয়ে দেয়। \nঅক্ষর ছাড়া অন্যান্য অক্ষর অপরিবর্তিত থাকে। সমস্ত অক্ষর বড় হাতের।\n\nউদাহরণ:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "bg": "Декриптира съобщение, криптирано с шифъра на Цезар.\nШифърът измества всяка буква в съобщението с 5 позиции надясно в азбуката. \nСимволите, които не са букви, остават непроменени. Всички букви са с главни букви.\n\nПример:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "zh": "解密使用凯撒密码加密的消息。\n该密码将消息中的每个字母在字母表中向右移动5个位置。\n非字母字符保持不变。所有字母均为大写。\n\n示例：\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "fr": "Décrypte un message chiffré avec le chiffre de César.\nLe chiffre déplace chaque lettre du message de 5 positions vers la droite dans l'alphabet.  \nLes caractères non alphabétiques restent inchangés. Toutes les lettres sont en majuscules.\n\nExemple :\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "de": "Entschlüsselt eine mit dem Caesar-Verschlüsselung verschlüsselte Nachricht.\nDer Verschlüsselungsalgorithmus verschiebt jeden Buchstaben in der Nachricht um 5 Positionen nach rechts im Alphabet.  \nNicht-Buchstaben-Zeichen bleiben unverändert. Alle Buchstaben sind in Großbuchstaben.\n\nBeispiel:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "ha": "Yana warware saƙo da aka ɓoye tare da sifirin Caesar.\nLambar yana matsar da kowace harafi a cikin saƙon matsayi 5 zuwa dama a cikin haruffa.  \nHaruffa marasa haruffa ba a canza su ba. Duk haruffa suna cikin manyan baƙaƙe.\n\nMisali:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hi": "संदेश को डिक्रिप्ट करता है जो सीज़र के सिफर के साथ एन्क्रिप्ट किया गया है।\nसिफर संदेश में प्रत्येक अक्षर को वर्णमाला में 5 स्थान दाईं ओर स्थानांतरित करता है।\nगैर-अक्षर वर्ण अपरिवर्तित रहते हैं। सभी अक्षर बड़े अक्षरों में हैं।\nउदाहरण:  \n\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')  \n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'  \n\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')  \n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hu": "Dekódol egy Caesar-rejtjel segítségével titkosított üzenetet.  \nA rejtjel minden betűt 5 pozícióval jobbra tol az ábécében.  \nA nem betű karakterek változatlanok maradnak. Minden betű nagybetűs.\n\nPélda:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'"
    },
    "docstring_bertscore": {
      "sq": "0.9853786190216408",
      "hy": "0.9742592902913078",
      "bn": "0.973429015298582",
      "bg": "0.9867074562707643",
      "zh": "0.9770202525876928",
      "fr": "0.9901135700447505",
      "de": "0.9922279904508668",
      "ha": "0.9919806956264785",
      "hi": "0.9012304471392587",
      "hu": "0.9629441120052744"
    }
  },
  {
    "task_id": "Ruby/30",
    "prompt": {
      "en": "# Calculates the number of possible photo arrangements for a group of people.\n# In this arrangement, people are lined up in such a way that the age difference\n# between any two adjacent persons is no more than two years.\n# The function takes a single integer argument, n, representing the number of people\n# in the group, where each person has a distinct age from 1 to n years.\n#\n# Example:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "sq": "# Llogarit numrin e mundshëm të rregullimeve të fotografive për një grup njerëzish.\n# Në këtë rregullim, njerëzit janë rreshtuar në mënyrë të tillë që diferenca e moshës\n# midis çdo dy personave ngjitur të mos jetë më shumë se dy vjet.\n# Funksioni merr një argument të vetëm integer, n, që përfaqëson numrin e njerëzve\n# në grup, ku secili person ka një moshë të dallueshme nga 1 deri në n vjet.\n#\n# Shembull:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "hy": "# Հաշվում է մարդկանց խմբի համար հնարավոր լուսանկարների դասավորությունների քանակը։\n# Այս դասավորության մեջ մարդիկ կանգնած են այնպես, որ\n# ցանկացած երկու հարակից անձանց միջև տարիքային տարբերությունը\n# չի գերազանցում երկու տարին։\n# Ֆունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ, n, որը ներկայացնում է խմբի մարդկանց քանակը,\n# որտեղ յուրաքանչյուր անձ ունի 1-ից մինչև n տարի տարբեր տարիք։\n#\n# Օրինակ:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "bn": "# মানুষের একটি দলের জন্য সম্ভাব্য ফটো বিন্যাসের সংখ্যা গণনা করে।\n# এই বিন্যাসে, মানুষ এমনভাবে সারিবদ্ধ থাকে যেন যে কোনও দুটি সংলগ্ন ব্যক্তির\n# মধ্যে বয়সের পার্থক্য দুই বছরের বেশি না হয়।\n# ফাংশনটি একটি একক পূর্ণসংখ্যা আর্গুমেন্ট গ্রহণ করে, n, যা দলের মানুষের সংখ্যা\n# উপস্থাপন করে, যেখানে প্রতিটি ব্যক্তির বয়স 1 থেকে n বছরের মধ্যে পৃথক।\n#\n# উদাহরণ:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "bg": "# Изчислява броя на възможните подредби за снимка за група хора.\n# В тази подредба хората са наредени така, че разликата във възрастта\n# между всеки двама съседни души да не е повече от две години.\n# Функцията приема един аргумент, n, представляващ броя на хората\n# в групата, където всеки човек има различна възраст от 1 до n години.\n#\n# Пример:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "zh": "# 计算一组人的可能拍照排列数量。\n# 在这种排列中，人们排列成一行，使得任何两个相邻人的年龄差不超过两岁。\n# 该函数接受一个整数参数 n，表示组中人的数量，其中每个人的年龄从 1 到 n 岁不重复。\n#\n# 示例:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "fr": "# Calcule le nombre de dispositions possibles de photos pour un groupe de personnes.\n# Dans cette disposition, les personnes sont alignées de telle manière que la différence d'âge\n# entre deux personnes adjacentes ne dépasse pas deux ans.\n# La fonction prend un seul argument entier, n, représentant le nombre de personnes\n# dans le groupe, où chaque personne a un âge distinct de 1 à n ans.\n#\n# Exemple:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "de": "# Berechnet die Anzahl der möglichen Fotoanordnungen für eine Gruppe von Personen.\n# In dieser Anordnung stehen die Personen so in einer Reihe, dass der Altersunterschied\n# zwischen zwei benachbarten Personen nicht mehr als zwei Jahre beträgt.\n# Die Funktion nimmt ein einzelnes ganzzahliges Argument n, das die Anzahl der Personen\n# in der Gruppe darstellt, wobei jede Person ein unterschiedliches Alter von 1 bis n Jahren hat.\n#\n# Beispiel:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "ha": "# Lissafa yawan yiwuwar shirye-shiryen daukar hoto ga wata kungiya ta mutane.\n# A cikin wannan tsari, mutane suna layi a cikin wata hanya da bambancin shekaru\n# tsakanin kowane mutum biyu masu makwabtaka ba ya wuce shekaru biyu.\n# Aikin yana karɓar hujja guda ɗaya, n, wanda ke wakiltar yawan mutanen\n# a cikin ƙungiyar, inda kowane mutum yana da shekaru daban-daban daga 1 zuwa n.\n#\n# Misali:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "hi": "# लोगों के एक समूह के लिए संभावित फोटो व्यवस्थाओं की संख्या की गणना करता है।\n# इस व्यवस्था में, लोग इस तरह से पंक्तिबद्ध होते हैं कि किसी भी दो आसन्न व्यक्तियों के बीच\n# आयु का अंतर दो वर्षों से अधिक नहीं होता है।\n# यह फ़ंक्शन एक एकल पूर्णांक तर्क n लेता है, जो समूह में लोगों की संख्या का प्रतिनिधित्व करता है,\n# जहां प्रत्येक व्यक्ति की आयु 1 से n वर्षों तक भिन्न होती है।\n#\n# उदाहरण:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "hu": "# Kiszámítja a lehetséges fényképelrendezések számát egy csoport számára.\n# Ebben az elrendezésben az emberek úgy vannak sorba állítva, hogy az életkorkülönbség\n# bármely két szomszédos személy között legfeljebb két év.\n# A függvény egyetlen egész szám argumentumot vesz fel, n, amely a csoportban\n# lévő emberek számát jelenti, ahol minden személy életkora 1-től n évig terjed.\n#\n# Példa:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)"
    },
    "prompt_bertscore": {
      "sq": "0.992815340487587",
      "hy": "0.962919680468407",
      "bn": "0.9708825738137147",
      "bg": "0.972148047971288",
      "zh": "0.9483854982273222",
      "fr": "0.987713916411468",
      "de": "0.9657668483501611",
      "ha": "0.9433104919918809",
      "hi": "0.9782920829174592",
      "hu": "0.962452501812213"
    },
    "canonical_solution": "    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end",
    "instruction": {
      "en": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简明的自然语言描述（文档字符串）。",
      "fr": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nBayar da takaitaccen bayanin yare na dabi'a (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def photo_arrangements_count(n)\n    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9202439431030613",
      "bn": "0.9235737828107302",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9408021875401723",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "  \nraise 'Test failed' unless photo_arrangements_count(4) == 4\nraise 'Test failed' unless photo_arrangements_count(5) == 6\nraise 'Test failed' unless photo_arrangements_count(6) == 9\nraise 'Test failed' unless photo_arrangements_count(7) == 14\nraise 'Test failed' unless photo_arrangements_count(8) == 21\n  \n\nputs 'All tests passed!'",
    "entry_point": "photo_arrangements_count",
    "signature": "def photo_arrangements_count(n)",
    "docstring": {
      "en": "Calculates the number of possible photo arrangements for a group of people.\nIn this arrangement, people are lined up in such a way that the age difference\nbetween any two adjacent persons is no more than two years.\nThe function takes a single integer argument, n, representing the number of people\nin the group, where each person has a distinct age from 1 to n years.\n\nExample:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "sq": "Llogarit numrin e mundshëm të rregullimeve të fotografive për një grup njerëzish. Në këtë rregullim, njerëzit rreshtohen në një mënyrë të tillë që diferenca e moshës midis çdo dy personave ngjitur nuk është më shumë se dy vjet. Funksioni merr një argument të vetëm të tipit integer, n, që përfaqëson numrin e njerëzve në grup, ku secili person ka një moshë të veçantë nga 1 deri në n vjet.\n\nShembull:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hy": "Հաշվում է մարդկանց խմբի համար հնարավոր լուսանկարների դասավորությունների քանակը։\nԱյս դասավորության մեջ մարդիկ շարքում են այնպես, որ ցանկացած երկու հարակից անձանց միջև տարիքային տարբերությունը\nչգերազանցի երկու տարին։\nՖունկցիան ընդունում է մեկ ամբողջ թվային արգումենտ՝ n, որը ներկայացնում է խմբի մարդկանց քանակը,\nորտեղ յուրաքանչյուր անձ ունի 1-ից n տարի տարբեր տարիք։\n\nՕրինակ:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "bn": "মানুষের একটি দলের জন্য সম্ভাব্য ছবি বিন্যাসের সংখ্যা গণনা করে। \nএই বিন্যাসে, মানুষদের এমনভাবে সারিবদ্ধ করা হয় যাতে যে কোনো দুটি সংলগ্ন ব্যক্তির মধ্যে বয়সের পার্থক্য দুই বছরের বেশি না হয়। \nফাংশনটি একটি একক পূর্ণসংখ্যা আর্গুমেন্ট, n, গ্রহণ করে, যা দলে মানুষের সংখ্যা উপস্থাপন করে, যেখানে প্রতিটি ব্যক্তির বয়স 1 থেকে n বছরের মধ্যে পৃথক।\n\nউদাহরণ:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "bg": "Изчислява броя на възможните подреждания за снимка на група хора. В това подреждане хората са наредени така, че разликата във възрастта между всеки двама съседни души да не е повече от две години. Функцията приема един аргумент, n, представляващ броя на хората в групата, където всеки човек има различна възраст от 1 до n години.\n\nПример:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "zh": "计算一组人的可能照片排列数量。\n在这种排列中，人们排成一行，使得任何两个相邻人的年龄差不超过两岁。\n该函数接受一个整数参数 n，表示组中人数，其中每个人的年龄从 1 到 n 岁不等。\n\n示例：\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "fr": "Calcule le nombre de dispositions possibles de photos pour un groupe de personnes.  \nDans cette disposition, les personnes sont alignées de telle manière que la différence d'âge  \nentre deux personnes adjacentes ne dépasse pas deux ans.  \nLa fonction prend un seul argument entier, n, représentant le nombre de personnes  \ndans le groupe, où chaque personne a un âge distinct de 1 à n ans.\n\nExemple :\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "de": "Berechnet die Anzahl der möglichen Fotoanordnungen für eine Gruppe von Personen.\nIn dieser Anordnung stehen die Personen so in einer Reihe, dass der Altersunterschied\nzwischen zwei benachbarten Personen nicht mehr als zwei Jahre beträgt.\nDie Funktion nimmt ein einzelnes ganzzahliges Argument, n, das die Anzahl der Personen\nin der Gruppe darstellt, wobei jede Person ein unterschiedliches Alter von 1 bis n Jahren hat.\n\nBeispiel:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "ha": "Yana ƙididdige yawan yiwuwar shirye-shiryen hotuna don wata ƙungiyar mutane.\nA cikin wannan tsari, mutane suna tsaye cikin layi ta yadda bambancin shekaru\ntsakanin kowane mutum biyu masu makwabtaka ba ya wuce shekaru biyu.\nAikin yana ɗaukar hujja guda ɗaya, n, wanda ke wakiltar yawan mutanen\na cikin ƙungiyar, inda kowane mutum yana da shekaru daban-daban daga 1 zuwa n.\n\nMisali:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hi": "लोगों के एक समूह के लिए संभावित फोटो व्यवस्थाओं की संख्या की गणना करता है। इस व्यवस्था में, लोग इस तरह से पंक्तिबद्ध होते हैं कि किसी भी दो आसन्न व्यक्तियों के बीच उम्र का अंतर दो वर्षों से अधिक नहीं होता है। यह फ़ंक्शन एकल पूर्णांक तर्क n लेता है, जो समूह में लोगों की संख्या का प्रतिनिधित्व करता है, जहाँ प्रत्येक व्यक्ति की आयु 1 से n वर्षों तक भिन्न होती है।\n\nउदाहरण:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hu": "Számítja a lehetséges fényképelrendezések számát egy csoport ember számára. Ebben az elrendezésben az emberek úgy vannak sorba állítva, hogy bármely két szomszédos személy közötti korkülönbség legfeljebb két év. A függvény egyetlen egész szám argumentumot vesz fel, n, amely a csoportban lévő emberek számát jelenti, ahol minden személynek különböző életkora van 1-től n évig.\n\nPélda:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9844994809551805",
      "hy": "0.9700489221045113",
      "bn": "0.9755781960213795",
      "bg": "0.9560552131302223",
      "zh": "0.9504911788966731",
      "fr": "0.9760092239482252",
      "de": "0.9623835770699939",
      "ha": "0.9436155882571504",
      "hi": "0.9779959250193361",
      "hu": "0.9692573800360873"
    }
  },
  {
    "task_id": "Ruby/31",
    "prompt": {
      "en": "# Converts a numerical score into a corresponding letter grade based on predefined ranges.\n# The function takes a single argument, score, which is an integer representing the score.\n# It returns a string representing the letter grade, or an error message for invalid scores.\n#\n# Grade Conversion:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Any other score: 'Score is error!'\n#\n# Examples:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "sq": "# Konverton një rezultat numerik në një notë përkatëse me shkronjë bazuar në intervale të paracaktuara.\n# Funksioni merr një argument të vetëm, score, i cili është një numër i plotë që përfaqëson rezultatin.\n# Ai kthen një varg që përfaqëson notën me shkronjë, ose një mesazh gabimi për rezultatet e pavlefshme.\n#\n# Konvertimi i Notave:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Çdo rezultat tjetër: 'Score is error!'\n#\n# Shembuj:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "hy": "# Թվային գնահատականը փոխակերպում է համապատասխան տառային գնահատականի՝ հիմնված նախապես սահմանված միջակայքերի վրա։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ score, որը ամբողջ թիվ է՝ ներկայացնող գնահատականը։\n# Այն վերադարձնում է տող, որը ներկայացնում է տառային գնահատականը, կամ սխալի հաղորդագրություն ոչ վավեր գնահատականների համար։\n#\n# Գնահատականի փոխակերպում:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Ցանկացած այլ գնահատական: 'Score is error!'\n#\n# Օրինակներ:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "bn": "# একটি সংখ্যাসূচক স্কোরকে পূর্বনির্ধারিত সীমার উপর ভিত্তি করে একটি সংশ্লিষ্ট অক্ষর গ্রেডে রূপান্তর করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, score, যা স্কোরের প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা।\n# এটি একটি স্ট্রিং প্রদান করে যা অক্ষর গ্রেডের প্রতিনিধিত্ব করে, অথবা অবৈধ স্কোরের জন্য একটি ত্রুটি বার্তা প্রদান করে।\n#\n# গ্রেড রূপান্তর:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# অন্য কোনো স্কোর: 'Score is error!'\n#\n# উদাহরণ:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "bg": "# Преобразува числова оценка в съответна буквена оценка въз основа на предварително определени диапазони.\n# Функцията приема един аргумент, score, който е цяло число, представляващо оценката.\n# Връща низ, представляващ буквена оценка, или съобщение за грешка при невалидни оценки.\n#\n# Преобразуване на оценка:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Всяка друга оценка: 'Score is error!'\n#\n# Примери:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "zh": "# 将数值分数转换为基于预定义范围的相应字母等级。\n# 该函数接受一个参数，score，它是一个表示分数的整数。\n# 它返回一个表示字母等级的字符串，或者对于无效分数返回错误信息。\n#\n# 等级转换：\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# 其他任何分数: 'Score is error!'\n#\n# 示例：\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "fr": "# Convertit un score numérique en une note correspondante basée sur des plages prédéfinies.\n# La fonction prend un seul argument, score, qui est un entier représentant le score.\n# Elle renvoie une chaîne de caractères représentant la note, ou un message d'erreur pour les scores invalides.\n#\n# Conversion des notes :\n# 90-100 : 'A'\n# 80-89 : 'B'\n# 70-79 : 'C'\n# 60-69 : 'D'\n# 0-59 : 'E'\n# Tout autre score : 'Score is error!'\n#\n# Exemples :\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "de": "# Wandelt eine numerische Punktzahl in eine entsprechende Buchstabennote basierend auf vordefinierten Bereichen um.\n# Die Funktion nimmt ein einziges Argument, score, das eine ganze Zahl darstellt, die die Punktzahl repräsentiert.\n# Sie gibt einen String zurück, der die Buchstabennote darstellt, oder eine Fehlermeldung für ungültige Punktzahlen.\n#\n# Notenumwandlung:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Jede andere Punktzahl: 'Score is error!'\n#\n# Beispiele:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "ha": "# Yana canza maki na lambobi zuwa harafin daraja daidai da kewayon da aka riga aka ayyana.\n# Aikin yana ɗaukar hujja guda ɗaya, score, wanda yake wakiltar maki.\n# Yana mayar da kirtani wanda ke wakiltar harafin daraja, ko saƙon kuskure don maki mara inganci.\n#\n# Canjin Daraja:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Wani maki daban: 'Score is error!'\n#\n# Misalai:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "hi": "# एक संख्यात्मक स्कोर को पूर्वनिर्धारित श्रेणियों के आधार पर एक संबंधित पत्र ग्रेड में परिवर्तित करता है।\n# फ़ंक्शन एक एकल तर्क लेता है, score, जो स्कोर का प्रतिनिधित्व करने वाला एक पूर्णांक है।\n# यह एक स्ट्रिंग लौटाता है जो पत्र ग्रेड का प्रतिनिधित्व करता है, या अमान्य स्कोर के लिए एक त्रुटि संदेश।\n#\n# ग्रेड रूपांतरण:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# कोई अन्य स्कोर: 'Score is error!'\n#\n# उदाहरण:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!' \n\ndef convert_score_to_grade(score)",
      "hu": "# Egy numerikus pontszámot átalakít egy előre meghatározott tartományok alapján megfelelő betűjeggyé.\n# A függvény egyetlen argumentumot vesz át, a score-t, amely egy egész számot képvisel.\n# Egy karakterláncot ad vissza, amely a betűjegyet jelöli, vagy egy hibaüzenetet érvénytelen pontszámok esetén.\n#\n# Jegy átváltás:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Bármely más pontszám: 'Score is error!'\n#\n# Példák:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)"
    },
    "prompt_bertscore": {
      "sq": "0.9920863669891891",
      "hy": "0.9946113563929045",
      "bn": "0.9855865850305844",
      "bg": "0.9884762598138799",
      "zh": "0.974733023750076",
      "fr": "0.9839969460911622",
      "de": "0.9995431501236197",
      "ha": "0.9739563789602296",
      "hi": "0.9914982224309448",
      "hu": "0.9791467894470522"
    },
    "canonical_solution": "    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end",
    "instruction": {
      "en": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nՏվեք կարճ բնութագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\n请用最多500个字符的中文对该Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nFournir une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def convert_score_to_grade(score)\n    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8794023586761918",
      "bn": "0.9138385105754483",
      "bg": "0.8364486908745768",
      "zh": "0.9851744894778132",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9531146889693819",
      "hi": "0.9119288780921788",
      "hu": "0.9311801346220803"
    },
    "level": "",
    "test": "raise 'Test failed' unless convert_score_to_grade(56) == 'E'\nraise 'Test failed' unless convert_score_to_grade(67) == 'D'\nraise 'Test failed' unless convert_score_to_grade(100) == 'A'\nraise 'Test failed' unless convert_score_to_grade(123) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(-5) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(85) == 'B'\n  \n\nputs 'All tests passed!'",
    "entry_point": "convert_score_to_grade",
    "signature": "def convert_score_to_grade(score)",
    "docstring": {
      "en": "Converts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\nExamples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "sq": "Konverton një rezultat numerik në një notë përkatëse me shkronja bazuar në intervalet e paracaktuara. Funksioni merr një argument të vetëm, score, i cili është një numër i plotë që përfaqëson rezultatin. Ai kthen një varg që përfaqëson notën me shkronja, ose një mesazh gabimi për rezultate të pavlefshme.\n\nKonvertimi i Notës:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nÇdo rezultat tjetër: 'Score is error!'\n\nShembuj:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "hy": "Թվային գնահատականը վերածում է համապատասխան տառային գնահատականի՝ հիմնված նախապես սահմանված միջակայքերի վրա։ \nՖունկցիան ընդունում է մեկ արգումենտ՝ score, որը ամբողջ թիվ է, ներկայացնելով գնահատականը։ \nԱյն վերադարձնում է տող, որը ներկայացնում է տառային գնահատականը կամ սխալի հաղորդագրություն՝ անվավեր գնահատականների համար։\n\nԳնահատականի փոխարկում՝\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nՑանկացած այլ գնահատական՝ 'Գնահատականը սխալ է!'\n\nՕրինակներ՝\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Գնահատականը սխալ է!'",
      "bn": "সংখ্যাগত স্কোরকে পূর্বনির্ধারিত সীমার উপর ভিত্তি করে একটি সংশ্লিষ্ট অক্ষর গ্রেডে রূপান্তর করে। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, score, যা স্কোরকে উপস্থাপনকারী একটি পূর্ণসংখ্যা। \nএটি একটি স্ট্রিং প্রদান করে যা অক্ষর গ্রেডকে উপস্থাপন করে, অথবা অবৈধ স্কোরের জন্য একটি ত্রুটি বার্তা প্রদান করে।\n\nগ্রেড রূপান্তর:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nযেকোনো অন্যান্য স্কোর: 'Score is error!'\n\nউদাহরণ:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "bg": "Преобразува числова оценка в съответстваща буквена оценка въз основа на предварително определени диапазони. \nФункцията приема един аргумент, score, който е цяло число, представляващо оценката. \nВръща низ, представляващ буквена оценка, или съобщение за грешка за невалидни оценки.\n\nПреобразуване на оценки:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nВсяка друга оценка: 'Score is error!'\n\nПримери:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "zh": "将数值分数转换为基于预定义范围的相应字母等级。\n该函数接受一个参数，score，它是表示分数的整数。\n它返回一个表示字母等级的字符串，或者对于无效分数返回错误信息。\n\n等级转换：\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\n任何其他分数: 'Score is error!'\n\n示例：\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "fr": "Convertit un score numérique en une note correspondante basée sur des plages prédéfinies.\nLa fonction prend un seul argument, score, qui est un entier représentant le score.\nElle renvoie une chaîne de caractères représentant la note, ou un message d'erreur pour les scores non valides.\n\nConversion des notes :\n90-100 : 'A'\n80-89 : 'B'\n70-79 : 'C'\n60-69 : 'D'\n0-59 : 'E'\nTout autre score : 'Score is error!'\n\nExemples :\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "de": "Konvertiert eine numerische Punktzahl in eine entsprechende Buchstabennote basierend auf vordefinierten Bereichen.\nDie Funktion nimmt ein einzelnes Argument, score, das eine ganze Zahl darstellt, die die Punktzahl repräsentiert.\nSie gibt einen String zurück, der die Buchstabennote darstellt, oder eine Fehlermeldung für ungültige Punktzahlen.\n\nNotenumrechnung:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nJede andere Punktzahl: 'Score is error!'\n\nBeispiele:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "ha": "Yana canza maki na lambobi zuwa harafin daraja daidai da kewayon da aka riga aka ayyana.\nAikin yana ɗaukar hujja guda ɗaya, score, wanda shi ne cikakken lamba da ke wakiltar maki.\nYana dawowa da igiyar da ke wakiltar harafin daraja, ko kuma saƙon kuskure don maki mara inganci.\n\nCanjin Daraja:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nDuk wani maki daban: 'Score is error!'\n\nMisalai:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "hi": "संख्यात्मक स्कोर को पूर्वनिर्धारित श्रेणियों के आधार पर संबंधित अक्षर ग्रेड में परिवर्तित करता है। \nयह फ़ंक्शन एक एकल तर्क लेता है, score, जो स्कोर का प्रतिनिधित्व करने वाला एक पूर्णांक है। \nयह एक स्ट्रिंग लौटाता है जो अक्षर ग्रेड का प्रतिनिधित्व करता है, या अमान्य स्कोर के लिए एक त्रुटि संदेश।\n\nग्रेड रूपांतरण:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nकोई अन्य स्कोर: 'Score is error!'\n\nउदाहरण:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "hu": "Átalakít egy numerikus pontszámot a megfelelő betűjeggyé előre meghatározott tartományok alapján.\nA függvény egyetlen argumentumot vesz fel, score, amely egy egész számot képvisel.\nEgy karakterláncot ad vissza, amely a betűjegyet képviseli, vagy egy hibaüzenetet érvénytelen pontszámok esetén.\n\nJegy átváltás:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nBármely más pontszám: 'Score is error!'\n\nPéldák:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'"
    },
    "docstring_bertscore": {
      "sq": "0.9966701602923311",
      "hy": "0.9751286954690975",
      "bn": "0.9983096554573931",
      "bg": "0.9903914539478184",
      "zh": "0.971049621964165",
      "fr": "0.9813547647626361",
      "de": "0.9993606088034487",
      "ha": "0.981678929544485",
      "hi": "0.9877671493535853",
      "hu": "0.9774904106996023"
    }
  },
  {
    "task_id": "Ruby/32",
    "prompt": {
      "en": "# Calculates the minimum time required to reverse the order of M people standing in a circle.\n# In each minute, only a pair of adjacent people can swap places. The function returns the \n# minimum number of minutes required to reverse the order of the people, such that each person's \n# left neighbor becomes their right neighbor and vice versa.\n#\n# Args:\n# - m: A positive integer representing the number of people in the circle.\n#\n# Returns:\n# - An integer representing the minimum number of minutes required to achieve the reversed order.\n#\n# Examples:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "sq": "# Llogarit kohën minimale të nevojshme për të kthyer rendin e M personave që qëndrojnë në një rreth.\n# Në çdo minutë, vetëm një çift personash ngjitur mund të ndërrojnë vendet. Funksioni kthen \n# numrin minimal të minutave të nevojshme për të kthyer rendin e personave, në mënyrë që \n# fqinji i majtë i secilit person të bëhet fqinji i tij i djathtë dhe anasjelltas.\n#\n# Argumentet:\n# - m: Një numër i plotë pozitiv që përfaqëson numrin e personave në rreth.\n#\n# Kthen:\n# - Një numër i plotë që përfaqëson numrin minimal të minutave të nevojshme për të arritur rendin e kthyer.\n#\n# Shembuj:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "hy": "# Հաշվում է M մարդկանց շրջանի մեջ կանգնած կարգը շրջելու համար անհրաժեշտ նվազագույն ժամանակը։\n# Ամեն րոպեում միայն հարակից զույգ մարդիկ կարող են տեղերը փոխել։ Ֆունկցիան վերադարձնում է \n# մարդկանց կարգը շրջելու համար անհրաժեշտ նվազագույն րոպեների քանակը, այնպես, որ յուրաքանչյուր մարդու \n# ձախ հարևանը դառնա աջ հարևան և հակառակը։\n#\n# Արգումենտներ:\n# - m: Դրական ամբողջ թիվ, որը ներկայացնում է մարդկանց քանակը շրջանի մեջ։\n#\n# Վերադարձնում է:\n# - Ամբողջ թիվ, որը ներկայացնում է շրջված կարգը ստանալու համար անհրաժեշտ նվազագույն րոպեների քանակը։\n#\n# Օրինակներ:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "bn": "# একটি বৃত্তে দাঁড়িয়ে থাকা M জন ব্যক্তির ক্রম উল্টাতে প্রয়োজনীয় ন্যূনতম সময় গণনা করে।\n# প্রতি মিনিটে, শুধুমাত্র একটি জোড়া সংলগ্ন ব্যক্তি স্থান পরিবর্তন করতে পারে। ফাংশনটি সেই \n# ন্যূনতম মিনিটের সংখ্যা প্রদান করে যা ব্যক্তিদের ক্রম উল্টাতে প্রয়োজন, যাতে প্রতিটি ব্যক্তির \n# বাম প্রতিবেশী তাদের ডান প্রতিবেশী হয়ে যায় এবং এর বিপরীত।\n#\n# আর্গুমেন্ট:\n# - m: বৃত্তে থাকা ব্যক্তিদের সংখ্যা নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা।\n#\n# রিটার্ন:\n# - একটি পূর্ণসংখ্যা যা উল্টানো ক্রম অর্জনের জন্য প্রয়োজনীয় ন্যূনতম মিনিটের সংখ্যা নির্দেশ করে।\n#\n# উদাহরণ:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "bg": "# Изчислява минималното време, необходимо за обръщане на реда на M души, стоящи в кръг.\n# Всяка минута само двойка съседни хора могат да разменят местата си. Функцията връща \n# минималния брой минути, необходими за обръщане на реда на хората, така че левият съсед \n# на всеки човек да стане десният му съсед и обратно.\n#\n# Аргументи:\n# - m: Положително цяло число, представляващо броя на хората в кръга.\n#\n# Връща:\n# - Цяло число, представляващо минималния брой минути, необходими за постигане на обърнатия ред.\n#\n# Примери:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "zh": "# 计算将站成圆圈的 M 个人的顺序反转所需的最短时间。\n# 每分钟只能交换一对相邻的人。函数返回反转这些人顺序所需的最少分钟数，\n# 使得每个人的左邻居变成他们的右邻居，反之亦然。\n#\n# 参数:\n# - m: 一个正整数，表示圆圈中人的数量。\n#\n# 返回:\n# - 一个整数，表示实现反转顺序所需的最少分钟数。\n#\n# 示例:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "fr": "# Calcule le temps minimum nécessaire pour inverser l'ordre de M personnes debout en cercle.\n# Chaque minute, seule une paire de personnes adjacentes peut échanger leurs places. La fonction retourne le\n# nombre minimum de minutes nécessaires pour inverser l'ordre des personnes, de sorte que le voisin de gauche\n# de chaque personne devienne leur voisin de droite et vice versa.\n#\n# Args:\n# - m: Un entier positif représentant le nombre de personnes dans le cercle.\n#\n# Returns:\n# - Un entier représentant le nombre minimum de minutes nécessaires pour atteindre l'ordre inversé.\n#\n# Examples:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "de": "# Berechnet die minimale Zeit, die benötigt wird, um die Reihenfolge von M Personen, die in einem Kreis stehen, umzukehren.\n# In jeder Minute kann nur ein Paar benachbarter Personen die Plätze tauschen. Die Funktion gibt die \n# minimale Anzahl von Minuten zurück, die benötigt wird, um die Reihenfolge der Personen umzukehren, sodass der linke Nachbar \n# jeder Person zu ihrem rechten Nachbarn wird und umgekehrt.\n#\n# Argumente:\n# - m: Eine positive ganze Zahl, die die Anzahl der Personen im Kreis darstellt.\n#\n# Rückgabewert:\n# - Eine ganze Zahl, die die minimale Anzahl von Minuten darstellt, die benötigt wird, um die umgekehrte Reihenfolge zu erreichen.\n#\n# Beispiele:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "ha": "# Lissafin mafi ƙarancin lokaci da ake buƙata don juyar da tsarin M mutane da ke tsaye a cikin da'ira.\n# A kowane minti, mutane biyu masu makwabtaka kawai za su iya musanya wurare. Aikin yana mayar da \n# mafi ƙarancin adadin mintuna da ake buƙata don juyar da tsarin mutanen, ta yadda makwabcin hagu \n# na kowane mutum zai zama makwabcin dama nasu kuma akasin haka.\n#\n# Args:\n# - m: Lamba mai kyau da ke wakiltar adadin mutanen a cikin da'irar.\n#\n# Returns:\n# - Lamba da ke wakiltar mafi ƙarancin adadin mintuna da ake buƙata don cimma tsarin da aka juyar.\n#\n# Misalai:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "hi": "# एक वृत्त में खड़े M लोगों के क्रम को उलटने के लिए आवश्यक न्यूनतम समय की गणना करता है।\n# प्रत्येक मिनट में, केवल एक जोड़ी आसन्न लोग स्थान बदल सकते हैं। फ़ंक्शन उन लोगों के क्रम को उलटने के लिए \n# आवश्यक न्यूनतम मिनटों की संख्या लौटाता है, ताकि प्रत्येक व्यक्ति का बायां पड़ोसी उनका दायां पड़ोसी बन जाए और इसके विपरीत।\n#\n# तर्क:\n# - m: वृत्त में लोगों की संख्या को दर्शाने वाला एक धनात्मक पूर्णांक।\n#\n# लौटाता है:\n# - एक पूर्णांक जो उलटे क्रम को प्राप्त करने के लिए आवश्यक न्यूनतम मिनटों की संख्या का प्रतिनिधित्व करता है।\n#\n# उदाहरण:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "hu": "# Kiszámítja a minimális időt, amely szükséges ahhoz, hogy M ember sorrendjét megfordítsuk, akik egy körben állnak.\n# Minden percben csak egy pár szomszédos ember cserélhet helyet. A függvény visszaadja a minimális percek számát, \n# amely szükséges ahhoz, hogy az emberek sorrendjét megfordítsuk, úgy hogy minden ember bal oldali szomszédja \n# jobb oldali szomszédjává váljon, és fordítva.\n#\n# Argumentumok:\n# - m: Egy pozitív egész szám, amely az emberek számát jelöli a körben.\n#\n# Visszatérési érték:\n# - Egy egész szám, amely a megfordított sorrend eléréséhez szükséges minimális percek számát jelenti.\n#\n# Példák:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)"
    },
    "prompt_bertscore": {
      "sq": "0.9864528121222775",
      "hy": "0.9740570845634143",
      "bn": "0.9729179393281792",
      "bg": "0.984668118148679",
      "zh": "0.9667298084374183",
      "fr": "0.9895490625018494",
      "de": "0.9838841240347344",
      "ha": "0.9782654664464004",
      "hi": "0.9912235166139735",
      "hu": "0.9791634743990592"
    },
    "canonical_solution": "    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end",
    "instruction": {
      "en": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nՏվեք հակիրճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nBa da takaitaccen bayanin yare na dabi'a (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 ko kasa da haka.",
      "hi": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def min_time_to_reverse_order(m)\n    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8991958761463184",
      "bn": "0.8746987912532856",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9408021875401723",
      "hi": "0.9027873120658102",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless min_time_to_reverse_order(4) == 2\nraise 'Test failed' unless min_time_to_reverse_order(5) == 4\nraise 'Test failed' unless min_time_to_reverse_order(6) == 6\nraise 'Test failed' unless min_time_to_reverse_order(7) == 9\nraise 'Test failed' unless min_time_to_reverse_order(10) == 20\n\n\n\nputs 'All tests passed!'",
    "entry_point": "min_time_to_reverse_order",
    "signature": "def min_time_to_reverse_order(m)",
    "docstring": {
      "en": "Calculates the minimum time required to reverse the order of M people standing in a circle.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: A positive integer representing the number of people in the circle.\n\nReturns:\n- An integer representing the minimum number of minutes required to achieve the reversed order.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "sq": "Llogarit kohën minimale të kërkuar për të kthyer rendin e M personave që qëndrojnë në një rreth. Në çdo minutë, vetëm një çift personash ngjitur mund të ndërrojnë vendet. Funksioni kthen numrin minimal të minutave të kërkuara për të kthyer rendin e personave, në mënyrë që fqinji i majtë i secilit person të bëhet fqinji i tyre i djathtë dhe anasjelltas.\n\nArgs:\n- m: Një numër i plotë pozitiv që përfaqëson numrin e personave në rreth.\n\nReturns:\n- Një numër i plotë që përfaqëson numrin minimal të minutave të kërkuara për të arritur rendin e kthyer.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "hy": "Հաշվում է նվազագույն ժամանակը, որը պահանջվում է շրջադարձելու համար M մարդկանց հերթականությունը, ովքեր կանգնած են շրջանաձև:\nՅուրաքանչյուր րոպեում միայն հարևան զույգ մարդիկ կարող են փոխել իրենց տեղերը։ Ֆունկցիան վերադարձնում է\nնվազագույն րոպեների քանակը, որը պահանջվում է մարդկանց հերթականությունը շրջադարձելու համար, այնպես, որ յուրաքանչյուր մարդու\nձախ հարևանը դառնա աջ հարևան և հակառակը։\n\nԱրգումենտներ:\n- m: Դրական ամբողջ թիվ, որը ներկայացնում է մարդկանց քանակը շրջանաձև։\n\nՎերադարձնում է:\n- Ամբողջ թիվ, որը ներկայացնում է նվազագույն րոպեների քանակը, որը պահանջվում է շրջադարձված հերթականությունը ստանալու համար։\n\nՕրինակներ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "bn": "বৃত্তে দাঁড়িয়ে থাকা M জন ব্যক্তির ক্রম বিপরীত করতে প্রয়োজনীয় সর্বনিম্ন সময় গণনা করে। \nপ্রতিটি মিনিটে, কেবলমাত্র একটি জোড়া সংলগ্ন ব্যক্তি তাদের স্থান পরিবর্তন করতে পারে। ফাংশনটি প্রয়োজনীয় \nমিনিটের সর্বনিম্ন সংখ্যা ফেরত দেয় যাতে ব্যক্তিদের ক্রম বিপরীত হয়, যাতে প্রতিটি ব্যক্তির বাম পার্শ্বের \nপ্রতিবেশী তাদের ডান পার্শ্বের প্রতিবেশী হয়ে যায় এবং এর বিপরীত।\n\nআর্গস:\n- m: বৃত্তে ব্যক্তিদের সংখ্যা নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা।\n\nরিটার্নস:\n- একটি পূর্ণসংখ্যা যা বিপরীত ক্রম অর্জন করতে প্রয়োজনীয় সর্বনিম্ন মিনিটের সংখ্যা নির্দেশ করে।\n\nউদাহরণ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "bg": "Изчислява минималното време, необходимо за обръщане на реда на M хора, стоящи в кръг. \nВсяка минута само двойка съседни хора могат да разменят местата си. Функцията връща \nминималния брой минути, необходими за обръщане на реда на хората, така че левият съсед на всеки човек да стане десен съсед и обратно.\n\nАргументи:\n- m: Положително цяло число, представляващо броя на хората в кръга.\n\nВръща:\n- Цяло число, представляващо минималния брой минути, необходими за постигане на обърнатия ред.\n\nПримери:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "zh": "计算将M个人按顺序反转所需的最短时间，这些人站成一个圆圈。\n在每一分钟内，只能交换一对相邻的人。函数返回反转这些人的顺序所需的最少分钟数，使得每个人的左邻居变成他们的右邻居，反之亦然。\n\n参数：\n- m: 一个正整数，表示圆圈中的人数。\n\n返回：\n- 一个整数，表示实现反转顺序所需的最少分钟数。\n\n示例：\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "fr": "Calcule le temps minimum nécessaire pour inverser l'ordre de M personnes se tenant en cercle.  \nChaque minute, seule une paire de personnes adjacentes peut échanger leurs places. La fonction retourne le nombre minimum de minutes nécessaires pour inverser l'ordre des personnes, de sorte que le voisin de gauche de chaque personne devienne son voisin de droite et vice versa.\n\nArgs:\n- m: Un entier positif représentant le nombre de personnes dans le cercle.\n\nReturns:\n- Un entier représentant le nombre minimum de minutes nécessaires pour obtenir l'ordre inversé.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "de": "Berechnet die minimale Zeit, die erforderlich ist, um die Reihenfolge von M Personen in einem Kreis umzukehren.\nIn jeder Minute kann nur ein Paar benachbarter Personen die Plätze tauschen. Die Funktion gibt die\nminimale Anzahl von Minuten zurück, die erforderlich ist, um die Reihenfolge der Personen umzukehren, sodass der linke Nachbar jeder Person zu ihrem rechten Nachbarn wird und umgekehrt.\n\nArgs:\n- m: Eine positive ganze Zahl, die die Anzahl der Personen im Kreis darstellt.\n\nReturns:\n- Eine ganze Zahl, die die minimale Anzahl von Minuten darstellt, die erforderlich ist, um die umgekehrte Reihenfolge zu erreichen.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "ha": "Lissafi na mafi ƙarancin lokaci da ake buƙata don juyar da tsarin mutane M da ke tsaye a cikin da'ira.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: Wani cikakken lamba mai kyau wanda ke wakiltar adadin mutanen da ke cikin da'ira.\n\nReturns:\n- Wani cikakken lamba wanda ke wakiltar mafi ƙarancin adadin mintuna da ake buƙata don cimma tsarin da aka juyar.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "hi": "वृत्त में खड़े M लोगों के क्रम को उलटने के लिए आवश्यक न्यूनतम समय की गणना करता है।\nप्रत्येक मिनट में, केवल एक जोड़ी आसन्न लोग स्थान बदल सकते हैं। यह फ़ंक्शन उन मिनटों की न्यूनतम संख्या लौटाता है जो लोगों के क्रम को उलटने के लिए आवश्यक हैं, ताकि प्रत्येक व्यक्ति का बायां पड़ोसी उनका दायां पड़ोसी बन जाए और इसके विपरीत।\n\nArgs:  \n- m: एक धनात्मक पूर्णांक जो वृत्त में लोगों की संख्या का प्रतिनिधित्व करता है।\n\nReturns:  \n- एक पूर्णांक जो उलटे क्रम को प्राप्त करने के लिए आवश्यक न्यूनतम मिनटों की संख्या का प्रतिनिधित्व करता है।\n\nExamples:  \n>>> min_time_to_reverse_order(4)  \n2  \n>>> min_time_to_reverse_order(5)  \n4  \n>>> min_time_to_reverse_order(6)  \n6  ",
      "hu": "Kiszámítja a minimális időt, amely szükséges ahhoz, hogy M ember sorrendjét megfordítsuk egy körben állva.\nMinden percben csak egy pár szomszédos ember cserélhet helyet. A függvény visszaadja a\nminimális percek számát, amely szükséges ahhoz, hogy az emberek sorrendjét megfordítsuk, úgy, hogy minden személy bal oldali szomszédja jobb oldali szomszédjává váljon és fordítva.\n\nArgs:\n- m: Egy pozitív egész szám, amely a körben álló emberek számát jelöli.\n\nReturns:\n- Egy egész szám, amely a megfordított sorrend eléréséhez szükséges minimális percek számát jelöli.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9808653395037661",
      "hy": "0.9737988650680689",
      "bn": "0.9778382124967944",
      "bg": "0.9797416874382517",
      "zh": "0.9693729829178496",
      "fr": "0.9881264717128775",
      "de": "0.9923048604083274",
      "ha": "0.9959801183486159",
      "hi": "0.9920241956799251",
      "hu": "0.9845910495608375"
    }
  },
  {
    "task_id": "Ruby/33",
    "prompt": {
      "en": "# Generates all unique four-digit permutations using the given four digits.\n# Each digit is used exactly once in each permutation. The function accepts\n# four integers as arguments and returns an array of strings, each representing\n# a unique permutation. The permutations are sorted in ascending order.\n#\n# Example:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "sq": "# Gjeneron të gjitha permutacionet unike me katër shifra duke përdorur katër shifrat e dhëna.\n# Çdo shifër përdoret saktësisht një herë në secilën permutacion. Funksioni pranon\n# katër numra të plotë si argumente dhe kthen një varg me vargje, secila që përfaqëson\n# një permutacion unik. Permutacionet janë të renditura në rend rritës.\n#\n# Shembull:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "hy": "# Գեներացնում է բոլոր եզակի չորսանիշ փոխատեղումները տրված չորս թվանշաններով։\n# Յուրաքանչյուր թվանշան օգտագործվում է հենց մեկ անգամ յուրաքանչյուր փոխատեղման մեջ։ Ֆունկցիան ընդունում է\n# չորս ամբողջ թիվ որպես արգումենտ և վերադարձնում է տողերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է\n# եզակի փոխատեղում։ Փոխատեղումները դասավորված են աճման կարգով։\n#\n# Օրինակ:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "bn": "# প্রদত্ত চারটি অঙ্ক ব্যবহার করে সমস্ত অনন্য চার-অঙ্কের বিন্যাস তৈরি করে।\n# প্রতিটি অঙ্ক প্রতিটি বিন্যাসে ঠিক একবার ব্যবহার করা হয়। ফাংশনটি\n# চারটি পূর্ণসংখ্যা আর্গুমেন্ট হিসাবে গ্রহণ করে এবং একটি স্ট্রিংয়ের অ্যারে\n# ফেরত দেয়, প্রতিটি একটি অনন্য বিন্যাস উপস্থাপন করে। বিন্যাসগুলি\n# ঊর্ধ্বক্রমে সাজানো হয়।\n#\n# উদাহরণ:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "bg": "# Генерира всички уникални четирицифрени пермутации, използвайки дадените четири цифри.\n# Всяка цифра се използва точно веднъж във всяка пермутация. Функцията приема\n# четири цели числа като аргументи и връща масив от низове, всеки от които представлява\n# уникална пермутация. Пермутациите са сортирани във възходящ ред.\n#\n# Пример:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "zh": "# 生成使用给定四个数字的所有唯一四位数排列。\n# 每个排列中每个数字只使用一次。该函数接受四个整数作为参数，\n# 并返回一个字符串数组，每个字符串表示一个唯一的排列。\n# 排列按升序排序。\n#\n# 示例:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "fr": "# Génère toutes les permutations uniques à quatre chiffres en utilisant les quatre chiffres donnés.\n# Chaque chiffre est utilisé exactement une fois dans chaque permutation. La fonction accepte\n# quatre entiers comme arguments et renvoie un tableau de chaînes, chacune représentant\n# une permutation unique. Les permutations sont triées par ordre croissant.\n#\n# Exemple :\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "de": "# Generiert alle einzigartigen vierstelligen Permutationen mit den gegebenen vier Ziffern.\n# Jede Ziffer wird in jeder Permutation genau einmal verwendet. Die Funktion akzeptiert\n# vier ganze Zahlen als Argumente und gibt ein Array von Strings zurück, wobei jeder String\n# eine einzigartige Permutation darstellt. Die Permutationen sind in aufsteigender Reihenfolge sortiert.\n#\n# Beispiel:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "ha": "# Yana samar da dukkan abubuwan permutation na musamman na lamba huɗu ta amfani da lambobi huɗu da aka bayar.\n# Ana amfani da kowace lamba sau ɗaya kawai a cikin kowane permutation. Aiki yana karɓar lambobi huɗu\n# a matsayin hujjoji kuma yana mayar da jerin kirtani, kowanne yana wakiltar permutation na musamman.\n# Ana tsara permutations a cikin tsari mai tashi.\n#\n# Misali:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "hi": "# दिए गए चार अंकों का उपयोग करके सभी अद्वितीय चार-अंकीय क्रमचयों का सृजन करता है।\n# प्रत्येक क्रमचय में प्रत्येक अंक का उपयोग ठीक एक बार किया जाता है। फ़ंक्शन\n# चार पूर्णांक को तर्क के रूप में स्वीकार करता है और स्ट्रिंग्स की एक array लौटाता है,\n# प्रत्येक अद्वितीय क्रमचय का प्रतिनिधित्व करती है। क्रमचय आरोही क्रम में व्यवस्थित होते हैं।\n#\n# उदाहरण:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hu": "# Generálja az összes egyedi négyjegyű permutációt a megadott négy számjegy felhasználásával.\n# Minden számjegy pontosan egyszer szerepel minden permutációban. A függvény négy egész számot\n# fogad el argumentumként, és egy karakterláncokat tartalmazó tömböt ad vissza, amelyek mindegyike\n# egy egyedi permutációt képvisel. A permutációk növekvő sorrendben vannak rendezve.\n#\n# Példa:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)"
    },
    "prompt_bertscore": {
      "sq": "0.9971035717837493",
      "hy": "0.9813575455879706",
      "bn": "0.969045441419523",
      "bg": "0.9990513413001774",
      "zh": "0.9652792107647206",
      "fr": "0.9828840200662237",
      "de": "0.9717192049786336",
      "ha": "0.9626086252917064",
      "hi": "0.9519451532858485",
      "hu": "0.989131740071295"
    },
    "canonical_solution": "    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end",
    "instruction": {
      "en": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\n请用最多500个字符的中文对该Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def generate_four_digit_permutations(*digits)\n    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9362996340628734",
      "hy": "0.8913444144447713",
      "bn": "0.9019111534550653",
      "bg": "0.8364486908745768",
      "zh": "0.9851744894778132",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9353344890414249",
      "hi": "0.9027873120658102",
      "hu": "0.9410598111443745"
    },
    "level": "",
    "test": "raise 'Test failed' unless generate_four_digit_permutations(1, 2, 3, 4) == [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", \"2134\", \"2143\", \"2314\", \"2341\", \"2413\", \"2431\", \"3124\", \"3142\", \"3214\", \"3241\", \"3412\", \"3421\", \"4123\", \"4132\", \"4213\", \"4231\", \"4312\", \"4321\"]\n\nraise 'Test failed' unless generate_four_digit_permutations(1, 2, 3, 5) == [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", \"2135\", \"2153\", \"2315\", \"2351\", \"2513\", \"2531\", \"3125\", \"3152\", \"3215\", \"3251\", \"3512\", \"3521\", \"5123\", \"5132\", \"5213\", \"5231\", \"5312\", \"5321\"]\n   \n\n\nputs 'All tests passed!'",
    "entry_point": "generate_four_digit_permutations",
    "signature": "def generate_four_digit_permutations(*digits)",
    "docstring": {
      "en": "Generates all unique four-digit permutations using the given four digits.\nEach digit is used exactly once in each permutation. The function accepts\nfour integers as arguments and returns an array of strings, each representing\na unique permutation. The permutations are sorted in ascending order.\n\nExample:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "sq": "Gjeneron të gjitha permutacionet unike me katër shifra duke përdorur katër shifrat e dhëna. Çdo shifër përdoret saktësisht një herë në secilën permutacion. Funksioni pranon katër numra të plotë si argumente dhe kthen një varg me vargje, secila që përfaqëson një permutacion unik. Permutacionet janë të renditura në rend rritës.\n\nShembull:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hy": "Ստեղծում է բոլոր եզակի չորսանիշ կոմբինացիաները օգտագործելով տրված չորս թվանշանները։  \nՅուրաքանչյուր թվանշան օգտագործվում է հենց մեկ անգամ յուրաքանչյուր կոմբինացիայում։ Ֆունկցիան ընդունում է  \nչորս ամբողջ թիվ որպես արգումենտ և վերադարձնում է տողերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է  \nեզակի կոմբինացիա։ Կոմբինացիաները դասավորված են աճման կարգով։\n\nՕրինակ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "bn": "প্রদত্ত চারটি অঙ্ক ব্যবহার করে সমস্ত অনন্য চার-অঙ্কের বিন্যাস তৈরি করে। প্রতিটি বিন্যাসে প্রতিটি অঙ্ক একবার করে ব্যবহৃত হয়। ফাংশনটি চারটি পূর্ণসংখ্যা আর্গুমেন্ট হিসেবে গ্রহণ করে এবং একটি স্ট্রিংয়ের অ্যারে প্রদান করে, প্রতিটি অনন্য বিন্যাসকে উপস্থাপন করে। বিন্যাসগুলি ঊর্ধ্বক্রমে সাজানো থাকে।\n\nউদাহরণ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "bg": "Генерира всички уникални четирицифрени пермутации, използвайки дадените четири цифри. Всяка цифра се използва точно веднъж във всяка пермутация. Функцията приема четири цели числа като аргументи и връща масив от низове, всеки от които представлява уникална пермутация. Пермутациите са сортирани във възходящ ред.\n\nПример:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "zh": "生成使用给定四个数字的所有唯一四位数排列。\n每个排列中每个数字恰好使用一次。该函数接受四个整数作为参数，并返回一个字符串数组，每个字符串表示一个唯一的排列。排列按升序排序。\n\n示例：\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "fr": "Génère toutes les permutations uniques à quatre chiffres en utilisant les quatre chiffres donnés. Chaque chiffre est utilisé exactement une fois dans chaque permutation. La fonction accepte quatre entiers comme arguments et renvoie un tableau de chaînes de caractères, chacune représentant une permutation unique. Les permutations sont triées par ordre croissant.\n\nExemple :\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "de": "Erzeugt alle einzigartigen vierstelligen Permutationen mit den gegebenen vier Ziffern. Jede Ziffer wird in jeder Permutation genau einmal verwendet. Die Funktion akzeptiert vier ganze Zahlen als Argumente und gibt ein Array von Strings zurück, wobei jeder String eine einzigartige Permutation darstellt. Die Permutationen sind in aufsteigender Reihenfolge sortiert.\n\nBeispiel:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "ha": "Yana haifar da dukkan haɗakar lambobi guda huɗu na musamman ta amfani da lambobi guda huɗu da aka bayar. Ana amfani da kowace lamba sau ɗaya kawai a kowane haɗakarwa. Aikin yana karɓar lambobi guda huɗu na cikakken lamba a matsayin hujjoji kuma yana mayar da jerin kirtani, kowanne yana wakiltar haɗakarwa na musamman. Ana jera haɗakarwan a cikin tsari mai hawa.\n\nMisali:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hi": "दिए गए चार अंकों का उपयोग करके सभी अद्वितीय चार-अंकीय क्रमचय उत्पन्न करता है। प्रत्येक क्रमचय में प्रत्येक अंक का उपयोग ठीक एक बार किया जाता है। यह फ़ंक्शन चार पूर्णांकों को तर्क के रूप में स्वीकार करता है और स्ट्रिंग्स की एक सरणी लौटाता है, जिनमें से प्रत्येक एक अद्वितीय क्रमचय का प्रतिनिधित्व करती है। क्रमचयों को आरोही क्रम में क्रमबद्ध किया जाता है।\n\nउदाहरण:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hu": "Generálja az összes egyedi négyjegyű permutációt a megadott négy számjegy felhasználásával. Minden számjegy pontosan egyszer szerepel minden permutációban. A függvény négy egész számot fogad el argumentumként, és egy karakterláncokat tartalmazó tömböt ad vissza, amelyek mindegyike egy egyedi permutációt képvisel. A permutációk növekvő sorrendben vannak rendezve.\n\nPélda:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]"
    },
    "docstring_bertscore": {
      "sq": "0.9965716396233378",
      "hy": "0.9574849546129115",
      "bn": "0.9474859012316152",
      "bg": "0.9986578545153473",
      "zh": "0.988254588308645",
      "fr": "1",
      "de": "0.9882919308202796",
      "ha": "0.9714049717158365",
      "hi": "0.9838886925334982",
      "hu": "0.9899238780308622"
    }
  },
  {
    "task_id": "Ruby/34",
    "prompt": {
      "en": "# Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\n# The function takes a single argument, n, which is a positive integer, and returns the count of numbers \n# that are related to 7 as per the criteria.\n#\n# Example:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "sq": "# Numëron numrin e numrave më të vegjël ose të barabartë me n që janë ose shumëfish i 7 ose përmbajnë shifrën '7'.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen numrin e numrave\n# që janë të lidhur me 7 sipas kritereve.\n#\n# Shembull:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "hy": "# Հաշվում է n-ից փոքր կամ հավասար այն թվերի քանակը, որոնք կամ 7-ի բազմապատիկ են, կամ պարունակում են '7' թվանշանը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է այն թվերի քանակը,\n# որոնք կապված են 7-ի հետ նշված չափանիշներով։\n#\n# Օրինակ:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "bn": "# n এর চেয়ে ছোট বা সমান সংখ্যাগুলির সংখ্যা গণনা করে যা হয় 7 এর গুণিতক বা '7' অঙ্কটি ধারণ করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং 7 এর সাথে সম্পর্কিত সংখ্যাগুলির সংখ্যা\n# নির্ধারিত মানদণ্ড অনুযায়ী ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "bg": "# Брои броя на числата, които са по-малки или равни на n и са или кратни на 7, или съдържат цифрата '7'.\n# Функцията приема един аргумент, n, който е положително цяло число, и връща броя на числата,\n# които са свързани със 7 според критериите.\n#\n# Пример:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "zh": "# 计算小于或等于 n 的数字中是 7 的倍数或包含数字 '7' 的数量。\n# 该函数接受一个参数 n，它是一个正整数，并返回与 7 相关的数字数量，符合这些标准。\n#\n# 示例:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "fr": "# Compte le nombre de nombres inférieurs ou égaux à n qui sont soit des multiples de 7, soit contiennent le chiffre '7'.\n# La fonction prend un seul argument, n, qui est un entier positif, et renvoie le compte des nombres \n# qui sont liés à 7 selon les critères.\n#\n# Exemple:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "de": "# Zählt die Anzahl der Zahlen, die kleiner oder gleich n sind und entweder Vielfache von 7 sind oder die Ziffer '7' enthalten.\n# Die Funktion nimmt ein einziges Argument, n, das eine positive ganze Zahl ist, und gibt die Anzahl der Zahlen zurück,\n# die gemäß den Kriterien mit 7 in Beziehung stehen.\n#\n# Beispiel:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "ha": "# Yana ƙididdige yawan lambobin da suka yi ƙasa da ko daidai da n waɗanda ko dai lambobin 7 ne ko kuma suna ɗauke da lamba '7'.\n# Aikin yana ɗaukar hujja guda, n, wanda yake lamba mai kyau, kuma yana dawo da ƙididdigar lambobin\n# waɗanda suka danganta da 7 bisa ga ƙa'idodin.\n#\n# Misali:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "hi": "# उन संख्याओं की संख्या गिनता है जो n से कम या बराबर हैं और या तो 7 के गुणज हैं या जिनमें अंक '7' शामिल है।\n# फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और उन संख्याओं की गिनती लौटाता है \n# जो दिए गए मानदंडों के अनुसार 7 से संबंधित हैं।\n#\n# उदाहरण:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "hu": "# Megszámolja azon számok számát, amelyek kisebbek vagy egyenlők n-nél, és amelyek vagy 7 többszörösei, vagy tartalmazzák a '7' számjegyet.\n# A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja azon számok számát,\n# amelyek a 7-hez kapcsolódnak a megadott kritériumok szerint.\n#\n# Példa:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9946894181326512",
      "hy": "0.9861715515027322",
      "bn": "0.9799333657559505",
      "bg": "0.9853613381784908",
      "zh": "0.9511095152728347",
      "fr": "0.9978400932366266",
      "de": "0.9878692453694373",
      "ha": "0.9865112094543018",
      "hi": "0.979794125858845",
      "hu": "0.9753509628654755"
    },
    "canonical_solution": "    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end",
    "instruction": {
      "en": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nনিচের রুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nBa da gajeriyar bayanin yanayi (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_seven_related_numbers(n)\n    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end\n\nAdj meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8824237254021134",
      "bn": "0.8737062352392543",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9379331703165044",
      "ha": "0.9070701803416844",
      "hi": "0.9119288780921788",
      "hu": "0.9226231378070973"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_seven_related_numbers(20) == 3\nraise 'Test failed' unless count_seven_related_numbers(15) == 2\nraise 'Test failed' unless count_seven_related_numbers(50) == 11\nraise 'Test failed' unless count_seven_related_numbers(28) == 6\nraise 'Test failed' unless count_seven_related_numbers(100) == 30\n  \n\nputs 'All tests passed!'",
    "entry_point": "count_seven_related_numbers",
    "signature": "def count_seven_related_numbers(n)",
    "docstring": {
      "en": "Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\nThe function takes a single argument, n, which is a positive integer, and returns the count of numbers\nthat are related to 7 as per the criteria.\n\nExample:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "sq": "Numëron numrin e numrave më të vegjël ose të barabartë me n që janë ose shumëfish i 7 ose përmbajnë shifrën '7'. Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen numrin e numrave që janë të lidhur me 7 sipas kritereve.\n\nShembull:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "hy": "Հաշվում է n-ից փոքր կամ հավասար թվերի քանակը, որոնք կամ 7-ի բազմապատիկ են կամ պարունակում են '7' թվանշանը:\nՖունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է թվերի քանակը,\nորոնք կապված են 7-ի հետ նշված չափանիշներով:\n\nՕրինակ:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "bn": "সংখ্যাটি n এর চেয়ে ছোট বা সমান সংখ্যাগুলি গণনা করে যা হয় 7 এর গুণিতক বা '7' অঙ্কটি ধারণ করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং সংখ্যাগুলির গণনা ফেরত দেয়\nযা নির্ধারিত মানদণ্ড অনুযায়ী 7 এর সাথে সম্পর্কিত।\nউদাহরণ:\n\n>>> count_seven_related_numbers(20)  \n3\n\n>>> count_seven_related_numbers(15)  \n2",
      "bg": "Брои броя на числата, по-малки или равни на n, които са или кратни на 7, или съдържат цифрата '7'. Функцията приема един аргумент, n, който е положително цяло число, и връща броя на числата, свързани със 7 според критериите.\n\nПример:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "zh": "计算小于或等于 n 的数字中是 7 的倍数或包含数字 '7' 的数量。\n该函数接受一个参数 n，它是一个正整数，并返回根据标准与 7 相关的数字的计数。\n\n示例：\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "fr": "Compte le nombre de nombres inférieurs ou égaux à n qui sont soit des multiples de 7, soit contiennent le chiffre '7'.  \nLa fonction prend un seul argument, n, qui est un entier positif, et renvoie le compte des nombres  \nqui sont liés à 7 selon les critères.\n\nExemple :\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "de": "Zählt die Anzahl der Zahlen, die kleiner oder gleich n sind und entweder Vielfache von 7 sind oder die Ziffer '7' enthalten.\nDie Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und gibt die Anzahl der Zahlen zurück,\ndie gemäß den Kriterien mit 7 in Beziehung stehen.\n\nBeispiel:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "ha": "Yana ƙididdige adadin lambobi da suka yi ƙasa da ko daidai da n waɗanda ko dai sau biyu na 7 ne ko kuma suna ɗauke da lamba '7'. \n\nAikin yana ɗaukar hujja guda ɗaya, n, wanda shi ne cikakken lamba mai kyau, kuma yana dawo da ƙididdigar lambobin da suka danganci 7 bisa ga ƙa'idodin.\n\nMisali:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "hi": "7 के गुणक हैं या जिनमें अंक '7' शामिल है, ऐसे n से कम या बराबर संख्याओं की गिनती करता है।  \nयह फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और उन संख्याओं की गिनती लौटाता है  \nजो दिए गए मानदंडों के अनुसार 7 से संबंधित हैं।\n\nउदाहरण:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "hu": "Számolja meg azon számok számát, amelyek kisebbek vagy egyenlők n-nél, és amelyek vagy 7 többszörösei, vagy tartalmazzák a '7' számjegyet.\nA függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja azon számok számát, amelyek a megadott kritériumok szerint kapcsolódnak a 7-hez.\n\nPélda:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9933061561591243",
      "hy": "0.9768146701433217",
      "bn": "0.999999801369619",
      "bg": "0.9822861426193087",
      "zh": "0.9547907321245542",
      "fr": "0.9972382431820909",
      "de": "0.9795047213936772",
      "ha": "0.9910497150305679",
      "hi": "0.9508872478764566",
      "hu": "0.9755625042212777"
    }
  },
  {
    "task_id": "Ruby/35",
    "prompt": {
      "en": "# Finds all possible last two digits of a number that, when added to the number 'a',\n# makes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is \n# a positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\n# The function returns an array of strings representing the possible two-digit suffixes.\n#\n# Example:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "sq": "# Gjen të gjitha dy shifrat e fundit të mundshme të një numri që, kur i shtohen numrit 'a',\n# e bëjnë atë të plotpjesëtueshëm me 'b'. Funksioni merr dy argumente, 'a' dhe 'b', ku 'a' është\n# një numër i plotë pozitiv më pak se 10000, dhe 'b' është një numër i plotë pozitiv midis 10 dhe 100.\n# Funksioni kthen një varg me vargje që përfaqësojnë prapashtesat e mundshme me dy shifra.\n#\n# Shembull:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "hy": "# Գտնում է թվի բոլոր հնարավոր վերջին երկու թվանշանները, որոնք, երբ գումարվում են 'a' թվին,\n# դարձնում են այն բաժանվող 'b'-ով։ Ֆունկցիան ընդունում է երկու արգումենտ՝ 'a' և 'b', որտեղ 'a' \n# դրական ամբողջ թիվ է, որը փոքր է 10000-ից, իսկ 'b' դրական ամբողջ թիվ է 10-ից 100 միջակայքում։\n# Ֆունկցիան վերադարձնում է տողերի զանգված, որը ներկայացնում է հնարավոր երկու թվանշաններից բաղկացած վերջավորությունները։\n#\n# Օրինակ:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "bn": "# এমন সব সম্ভাব্য শেষ দুই অঙ্ক খুঁজে বের করে যা সংখ্যা 'a' এর সাথে যোগ করলে,\n# এটি 'b' দ্বারা বিভাজ্য হয়। ফাংশনটি দুটি আর্গুমেন্ট নেয়, 'a' এবং 'b', যেখানে 'a' \n# একটি ধনাত্মক পূর্ণসংখ্যা যা 10000 এর চেয়ে কম, এবং 'b' একটি ধনাত্মক পূর্ণসংখ্যা যা 10 থেকে 100 এর মধ্যে।\n# ফাংশনটি স্ট্রিংগুলোর একটি অ্যারে ফেরত দেয় যা সম্ভাব্য দুই-অঙ্কের উপসর্গগুলি উপস্থাপন করে।\n#\n# উদাহরণ:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "bg": "# Намира всички възможни последни две цифри на число, които, когато се добавят към числото 'a',\n# го правят делимо на 'b'. Функцията приема два аргумента, 'a' и 'b', където 'a' е\n# положително цяло число по-малко от 10000, а 'b' е положително цяло число между 10 и 100.\n# Функцията връща масив от низове, представляващи възможните суфикси от две цифри.\n#\n# Пример:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "zh": "# 查找一个数字的所有可能的最后两位数字，当它们加到数字 'a' 上时，\n# 使其可以被 'b' 整除。函数接受两个参数，'a' 和 'b'，其中 'a' 是\n# 小于 10000 的正整数，'b' 是介于 10 和 100 之间的正整数。\n# 该函数返回一个字符串数组，表示可能的两位数后缀。\n#\n# 示例:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "fr": "# Trouve tous les deux derniers chiffres possibles d'un nombre qui, lorsqu'ils sont ajoutés au nombre 'a',\n# le rendent divisible par 'b'. La fonction prend deux arguments, 'a' et 'b', où 'a' est \n# un entier positif inférieur à 10000, et 'b' est un entier positif entre 10 et 100.\n# La fonction renvoie un tableau de chaînes représentant les suffixes possibles à deux chiffres.\n#\n# Exemple :\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "de": "# Findet alle möglichen letzten zwei Ziffern einer Zahl, die, wenn sie zu der Zahl 'a' hinzugefügt werden,\n# diese durch 'b' teilbar machen. Die Funktion nimmt zwei Argumente, 'a' und 'b', wobei 'a' \n# eine positive ganze Zahl kleiner als 10000 ist und 'b' eine positive ganze Zahl zwischen 10 und 100 ist.\n# Die Funktion gibt ein Array von Strings zurück, die die möglichen zweistelligen Suffixe darstellen.\n#\n# Beispiel:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "ha": "# Nemi dukkan yiwuwar lambobin ƙarshe guda biyu na wata lamba da, idan an ƙara su da lamba 'a',\n# zai sa ta zama mai raba ta da 'b'. Aikin yana ɗaukar hujjoji guda biyu, 'a' da 'b', inda 'a' \n# yake zama lamba mai kyau ƙasa da 10000, kuma 'b' yana zama lamba mai kyau tsakanin 10 da 100.\n# Aikin yana dawo da jerin kirtani na lambobin ƙarshe guda biyu masu yiwuwa.\n#\n# Misali:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "hi": "# वह सभी संभावित अंतिम दो अंक खोजता है जो संख्या 'a' में जोड़ने पर उसे 'b' से विभाज्य बनाते हैं।\n# यह फ़ंक्शन दो तर्क लेता है, 'a' और 'b', जहाँ 'a' एक धनात्मक पूर्णांक है जो 10000 से कम है,\n# और 'b' एक धनात्मक पूर्णांक है जो 10 और 100 के बीच है।\n# यह फ़ंक्शन स्ट्रिंग्स की एक सरणी लौटाता है जो संभावित दो-अंकीय प्रत्यय का प्रतिनिधित्व करती है।\n#\n# उदाहरण:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "hu": "# Megtalálja egy szám összes lehetséges utolsó két számjegyét, amelyek hozzáadva az 'a' számhoz,\n# oszthatóvá teszik 'b'-vel. A függvény két argumentumot vesz fel, 'a' és 'b', ahol 'a' egy \n# pozitív egész szám, amely kisebb mint 10000, és 'b' egy pozitív egész szám 10 és 100 között.\n# A függvény egy karakterláncokból álló tömböt ad vissza, amely az összes lehetséges kétjegyű \n# végződést tartalmazza.\n#\n# Példa:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)"
    },
    "prompt_bertscore": {
      "sq": "0.9960784403872281",
      "hy": "0.9819979299364271",
      "bn": "0.9797917422942726",
      "bg": "0.9994188075050919",
      "zh": "0.987303943305012",
      "fr": "0.9917776953770608",
      "de": "0.9930580668132117",
      "ha": "0.9660413555367514",
      "hi": "0.9560691172568948",
      "hu": "0.9845398029225305"
    },
    "canonical_solution": "    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end",
    "instruction": {
      "en": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বর্ণনা (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\n请用最多500个字符的中文，为以下Ruby代码提供简明的自然语言描述（文档字符串）。",
      "fr": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def find_possible_last_digits(a, b)\n    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9362996340628734",
      "hy": "0.9202439431030613",
      "bn": "0.8882638558653012",
      "bg": "0.8364486908745768",
      "zh": "0.880690675327584",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9353344890414249",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_possible_last_digits(200, 40) == [\"00\", \"40\", \"80\"]\nraise 'Test failed' unless find_possible_last_digits(1992, 95) == [\"15\"]\nraise 'Test failed' unless find_possible_last_digits(1500, 25) == [\"00\", \"25\", \"50\", \"75\"]\nraise 'Test failed' unless find_possible_last_digits(300, 30) == [\"00\", \"30\", \"60\", \"90\"]\n  \nputs 'All tests passed!'",
    "entry_point": "find_possible_last_digits",
    "signature": "def find_possible_last_digits(a, b)",
    "docstring": {
      "en": "Finds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n\nExample:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "sq": "Gjen të gjitha shifrat e fundit të mundshme të një numri që, kur i shtohen numrit 'a',\ne bën atë të plotpjesëtueshëm me 'b'. Funksioni merr dy argumente, 'a' dhe 'b', ku 'a' është\nnjë numër i plotë pozitiv më pak se 10000, dhe 'b' është një numër i plotë pozitiv midis 10 dhe 100.\nFunksioni kthen një varg me vargje që përfaqësojnë prapashtesat e mundshme me dy shifra.\n\nShembull:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hy": "Գտնում է թվի բոլոր հնարավոր վերջին երկու թվանշանները, որոնք, երբ գումարվում են 'a' թվին, դարձնում են այն բաժանվող 'b'-ով։ Ֆունկցիան ընդունում է երկու արգումենտ՝ 'a' և 'b', որտեղ 'a'-ն դրական ամբողջ թիվ է, որը փոքր է 10000-ից, իսկ 'b'-ն դրական ամբողջ թիվ է 10-ից 100 միջակայքում։ Ֆունկցիան վերադարձնում է տողերի զանգված, որը ներկայացնում է հնարավոր երկնիշ վերջավորությունները։\n\nՕրինակ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "bn": "সংখ্যাটির সম্ভাব্য শেষ দুটি অঙ্ক খুঁজে বের করে যা, যখন সংখ্যা 'a' এর সাথে যোগ করা হয়, তখন এটি 'b' দ্বারা বিভাজ্য হয়। ফাংশনটি দুটি আর্গুমেন্ট নেয়, 'a' এবং 'b', যেখানে 'a' একটি ধনাত্মক পূর্ণসংখ্যা যা 10000 এর চেয়ে কম, এবং 'b' একটি ধনাত্মক পূর্ণসংখ্যা যা 10 এবং 100 এর মধ্যে। ফাংশনটি সম্ভাব্য দুটি অঙ্কের উপসর্গগুলির প্রতিনিধিত্বকারী স্ট্রিংগুলির একটি অ্যারে ফেরত দেয়।\n\nউদাহরণ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "bg": "Намира всички възможни последни две цифри на число, което, когато се добави към числото 'a', го прави делимо на 'b'. Функцията приема два аргумента, 'a' и 'b', където 'a' е положително цяло число по-малко от 10000, а 'b' е положително цяло число между 10 и 100. Функцията връща масив от низове, представляващи възможните двуцифрени суфикси.\n\nПример:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "zh": "找到一个数的所有可能的最后两位数字，当它与数字 'a' 相加时，使其可以被 'b' 整除。该函数接受两个参数，'a' 和 'b'，其中 'a' 是小于 10000 的正整数，'b' 是介于 10 和 100 之间的正整数。函数返回一个字符串数组，表示可能的两位数后缀。\n\n示例：\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "fr": "Trouve tous les deux derniers chiffres possibles d'un nombre qui, lorsqu'ils sont ajoutés au nombre 'a', le rendent divisible par 'b'. La fonction prend deux arguments, 'a' et 'b', où 'a' est un entier positif inférieur à 10000, et 'b' est un entier positif compris entre 10 et 100. La fonction renvoie un tableau de chaînes représentant les suffixes possibles à deux chiffres.\n\nExemple :\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "de": "Findet alle möglichen letzten zwei Ziffern einer Zahl, die, wenn sie zur Zahl 'a' hinzugefügt werden, diese durch 'b' teilbar machen. Die Funktion nimmt zwei Argumente, 'a' und 'b', wobei 'a' eine positive ganze Zahl kleiner als 10000 ist und 'b' eine positive ganze Zahl zwischen 10 und 100. Die Funktion gibt ein Array von Strings zurück, das die möglichen zweistelligen Suffixe darstellt.\n\nBeispiel:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "ha": "Yana nemo dukkan yiwuwar lambobin ƙarshe guda biyu na wani lamba wanda, idan aka ƙara shi da lambar 'a', zai sa ya raba shi da 'b' ba tare da saura ba. Aikin yana ɗaukar hujjoji guda biyu, 'a' da 'b', inda 'a' yake zama lamba mai kyau ƙasa da 10000, kuma 'b' yana zama lamba mai kyau tsakanin 10 da 100. Aikin yana dawowa da jerin igiyoyi da ke wakiltar yiwuwar ƙarewar lambobi guda biyu.\n\nMisali:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hi": "संख्या के सभी संभावित अंतिम दो अंकों को खोजता है, जो संख्या 'a' में जोड़ने पर इसे 'b' से विभाज्य बनाते हैं। यह फ़ंक्शन दो तर्क लेता है, 'a' और 'b', जहाँ 'a' 10000 से कम का एक धनात्मक पूर्णांक है, और 'b' 10 और 100 के बीच का एक धनात्मक पूर्णांक है। फ़ंक्शन संभावित दो-अंकीय प्रत्ययों का प्रतिनिधित्व करने वाले स्ट्रिंग्स की एक सरणी लौटाता है।\n\nउदाहरण:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hu": "Megtalálja egy szám összes lehetséges utolsó két számjegyét, amely hozzáadva az 'a' számhoz, oszthatóvá teszi azt 'b'-vel. A függvény két argumentumot vesz fel, 'a' és 'b', ahol 'a' egy pozitív egész szám, amely kisebb, mint 10000, és 'b' egy pozitív egész szám 10 és 100 között. A függvény egy karakterláncokat tartalmazó tömböt ad vissza, amely a lehetséges kétjegyű utótagokat képviseli.\n\nPélda:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]"
    },
    "docstring_bertscore": {
      "sq": "0.983198849220164",
      "hy": "0.9808637504607178",
      "bn": "0.9761282035464651",
      "bg": "0.9936708415387043",
      "zh": "0.9757694770783161",
      "fr": "0.9927631006973748",
      "de": "0.9904254197429753",
      "ha": "0.9505189871500179",
      "hi": "0.9845155700160443",
      "hu": "0.9987557792931975"
    }
  },
  {
    "task_id": "Ruby/36",
    "prompt": {
      "en": "# Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\n# The tiles used must be smaller than n x n and can be of varying sizes. \n# The function takes a single argument, n, which is a positive integer representing the size of the room, \n# and returns the minimum number of tiles required.\n#\n# Example:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "sq": "# Llogarit numrin minimal të pllakave katrore të nevojshme për të mbuluar plotësisht një dhomë katrore me madhësi n x n.\n# Pllakat e përdorura duhet të jenë më të vogla se n x n dhe mund të jenë me madhësi të ndryshme.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson madhësinë e dhomës,\n# dhe kthen numrin minimal të pllakave të nevojshme.\n#\n# Shembull:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "hy": "# Հաշվում է քառակուսի սալիկների նվազագույն քանակը, որոնք անհրաժեշտ են n x n չափսի քառակուսի սենյակը ամբողջությամբ ծածկելու համար։\n# Օգտագործվող սալիկները պետք է լինեն n x n-ից փոքր և կարող են ունենալ տարբեր չափսեր։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է և ներկայացնում է սենյակի չափսը,\n# և վերադարձնում է անհրաժեշտ սալիկների նվազագույն քանակը։\n#\n# Օրինակ:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "bn": "# n x n আকারের একটি বর্গাকার ঘর সম্পূর্ণভাবে ঢাকতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক বর্গাকার টাইল গণনা করে।\n# ব্যবহৃত টাইলগুলি n x n এর চেয়ে ছোট হতে হবে এবং বিভিন্ন আকারের হতে পারে।\n# ফাংশনটি একটি একক আর্গুমেন্ট n গ্রহণ করে, যা ঘরের আকারের প্রতিনিধিত্বকারী একটি ধনাত্মক পূর্ণসংখ্যা,\n# এবং প্রয়োজনীয় টাইলের সর্বনিম্ন সংখ্যা ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "bg": "# Изчислява минималния брой квадратни плочки, необходими за пълното покриване на квадратна стая с размер n x n.\n# Използваните плочки трябва да бъдат по-малки от n x n и могат да бъдат с различни размери.\n# Функцията приема един аргумент, n, който е положително цяло число, представляващо размера на стаята,\n# и връща минималния брой необходими плочки.\n#\n# Пример:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "zh": "# 计算完全覆盖一个 n x n 大小的正方形房间所需的最小方形瓷砖数量。\n# 使用的瓷砖必须小于 n x n，并且可以是不同的大小。\n# 该函数接受一个参数 n，n 是一个表示房间大小的正整数，\n# 返回所需的最小瓷砖数量。\n#\n# 示例:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "fr": "# Calcule le nombre minimum de carreaux carrés nécessaires pour couvrir complètement une pièce carrée de taille n x n.\n# Les carreaux utilisés doivent être plus petits que n x n et peuvent être de tailles variées.\n# La fonction prend un seul argument, n, qui est un entier positif représentant la taille de la pièce,\n# et retourne le nombre minimum de carreaux nécessaires.\n#\n# Exemple:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "de": "# Berechnet die minimale Anzahl von quadratischen Fliesen, die benötigt werden, um einen quadratischen Raum der Größe n x n vollständig abzudecken.\n# Die verwendeten Fliesen müssen kleiner als n x n sein und können unterschiedliche Größen haben.\n# Die Funktion nimmt ein einziges Argument n, das eine positive ganze Zahl ist, die die Größe des Raumes darstellt,\n# und gibt die minimale Anzahl der benötigten Fliesen zurück.\n#\n# Beispiel:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "ha": "# Lissafin mafi ƙarancin adadin fale-falen murabba'i da ake buƙata don rufe ɗakin murabba'i mai girman n x n.\n# Fale-falen da aka yi amfani da su dole ne su zama ƙanana fiye da n x n kuma za su iya zama masu girma dabam-dabam.\n# Aikin yana ɗaukar hujja guda, n, wanda yake lamba mai kyau da ke wakiltar girman ɗakin,\n# kuma yana dawowa da mafi ƙarancin adadin fale-falen da ake buƙata.\n#\n# Misali:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "hi": "# एक वर्गाकार कमरे को पूरी तरह से ढकने के लिए आवश्यक न्यूनतम संख्या में वर्गाकार टाइल्स की गणना करता है।\n# उपयोग की जाने वाली टाइल्स n x n से छोटी होनी चाहिए और विभिन्न आकारों की हो सकती हैं।\n# यह फ़ंक्शन एक एकल आर्ग्युमेंट n लेता है, जो कमरे के आकार का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है,\n# और आवश्यक न्यूनतम टाइल्स की संख्या लौटाता है।\n#\n# उदाहरण:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "hu": "# Kiszámítja a minimális számú négyzet alakú csempe szükségességét egy n x n méretű négyzet alakú szoba teljes lefedéséhez.\n# A használt csempék kisebbek kell legyenek, mint az n x n, és különböző méretűek lehetnek.\n# A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, ami a szoba méretét jelenti,\n# és visszaadja a szükséges minimális csempék számát.\n#\n# Példa:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9898724327621742",
      "hy": "0.9868218673702404",
      "bn": "0.9815782239413003",
      "bg": "0.9915498663300137",
      "zh": "0.9717791913537062",
      "fr": "0.99409034890345",
      "de": "0.9900746384900677",
      "ha": "0.9925102442223175",
      "hi": "0.9722890755418228",
      "hu": "0.9960053444070074"
    },
    "canonical_solution": "    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end",
    "instruction": {
      "en": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, използвайки не повече от 500 знака.",
      "zh": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nBa da taƙaitaccen bayanin yare na halitta (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 अक्षर हों।",
      "hu": "def min_tiles_required(n)\n    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8888019455675248",
      "bn": "0.8746987912532856",
      "bg": "0.8991035130191372",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9482625460214616",
      "hi": "0.9119288780921788",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless min_tiles_required(4) == 4\nraise 'Test failed' unless min_tiles_required(5) == 8\nraise 'Test failed' unless min_tiles_required(2) == 4\nraise 'Test failed' unless min_tiles_required(10) == 4\nraise 'Test failed' unless min_tiles_required(7) == 10\n  \nputs 'All tests passed!'   ",
    "entry_point": "min_tiles_required",
    "signature": "def min_tiles_required(n)",
    "docstring": {
      "en": "Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n\nExample:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "sq": "Llogarit numrin minimal të pllakave katrore të nevojshme për të mbuluar plotësisht një dhomë katrore me madhësi n x n. Pllakat e përdorura duhet të jenë më të vogla se n x n dhe mund të jenë të madhësive të ndryshme. Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson madhësinë e dhomës, dhe kthen numrin minimal të pllakave të nevojshme.\n\nShembull:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "hy": "Հաշվում է քառակուսի սալիկների նվազագույն քանակը, որոնք անհրաժեշտ են n x n չափսի քառակուսի սենյակը ամբողջությամբ ծածկելու համար։ Օգտագործվող սալիկները պետք է լինեն n x n-ից փոքր և կարող են ունենալ տարբեր չափսեր։ Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է և ներկայացնում է սենյակի չափսը, և վերադարձնում է անհրաժեշտ սալիկների նվազագույն քանակը։\n\nՕրինակ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "bn": "বর্গাকার ঘরের আয়তন n x n সম্পূর্ণভাবে ঢাকতে প্রয়োজনীয় ন্যূনতম সংখ্যক বর্গাকার টাইল গণনা করে। ব্যবহৃত টাইলগুলি n x n এর চেয়ে ছোট হতে হবে এবং বিভিন্ন আকারের হতে পারে। ফাংশনটি একটি একক আর্গুমেন্ট n গ্রহণ করে, যা ঘরের আকার নির্দেশ করে এমন একটি ধনাত্মক পূর্ণসংখ্যা, এবং প্রয়োজনীয় টাইলের ন্যূনতম সংখ্যা প্রদান করে।\n\nউদাহরণ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "bg": "Изчислява минималния брой квадратни плочки, необходими за пълно покриване на квадратна стая с размер n x n. Използваните плочки трябва да бъдат по-малки от n x n и могат да бъдат с различни размери. Функцията приема един аргумент, n, който е положително цяло число, представляващо размера на стаята, и връща минималния брой необходими плочки.\n\nПример:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "zh": "计算完全覆盖一个大小为 n x n 的正方形房间所需的最小方形瓷砖数量。\n使用的瓷砖必须小于 n x n，并且可以有不同的尺寸。\n该函数接受一个参数 n，这是一个表示房间大小的正整数，并返回所需的最小瓷砖数量。\n\n示例：\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "fr": "Calcule le nombre minimum de carreaux carrés nécessaires pour couvrir complètement une pièce carrée de taille n x n.  \nLes carreaux utilisés doivent être plus petits que n x n et peuvent être de tailles variées.  \nLa fonction prend un seul argument, n, qui est un entier positif représentant la taille de la pièce,  \net renvoie le nombre minimum de carreaux nécessaires.\n\nExemple :\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "de": "Berechnet die minimale Anzahl von quadratischen Fliesen, die benötigt werden, um einen quadratischen Raum der Größe n x n vollständig abzudecken. Die verwendeten Fliesen müssen kleiner als n x n sein und können unterschiedliche Größen haben. Die Funktion nimmt ein einziges Argument, n, das eine positive ganze Zahl darstellt, die die Größe des Raumes angibt, und gibt die minimale Anzahl der benötigten Fliesen zurück.\n\nBeispiel:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "ha": "Yana ƙididdige mafi ƙarancin adadin fale-falen murabba'i da ake buƙata don rufe ɗakin murabba'i mai girman n x n gaba ɗaya.\nFale-falen da ake amfani da su dole ne su kasance ƙanana fiye da n x n kuma za su iya zama masu girma dabam-dabam.\nAikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau da ke wakiltar girman ɗakin,\nkuma yana mayar da mafi ƙarancin adadin fale-falen da ake buƙata.\n\nMisali:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "hi": "वर्गाकार कमरे के आकार n x n को पूरी तरह से ढकने के लिए आवश्यक न्यूनतम वर्ग टाइलों की संख्या की गणना करता है। उपयोग की जाने वाली टाइलें n x n से छोटी होनी चाहिए और विभिन्न आकारों की हो सकती हैं। यह फ़ंक्शन एकल तर्क n लेता है, जो कमरे के आकार का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है, और आवश्यक टाइलों की न्यूनतम संख्या लौटाता है।\n\nउदाहरण:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "hu": "Kiszámítja a minimálisan szükséges négyzet alakú csempék számát, amelyek teljesen lefedik az n x n méretű négyzet alakú szobát. A használt csempék kisebbek kell legyenek, mint az n x n, és különböző méretűek lehetnek. A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, ami a szoba méretét jelenti, és visszaadja a szükséges csempék minimális számát.\n\nPélda:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8"
    },
    "docstring_bertscore": {
      "sq": "0.9935151153199729",
      "hy": "0.9901989811085955",
      "bn": "0.9901270769106609",
      "bg": "0.9901989811085955",
      "zh": "0.9709898342194735",
      "fr": "0.9924768743183036",
      "de": "0.9915997225556535",
      "ha": "0.9885886846095456",
      "hi": "0.8855273251057836",
      "hu": "0.997045174451725"
    }
  },
  {
    "task_id": "Ruby/37",
    "prompt": {
      "en": "# Sorts a list of dates in the format 'MM/DD/YYYY'.\n# The function takes an array of string dates and returns an array of dates sorted in ascending order.\n# The sorting is done based on the chronological order of the dates.\n#\n# Examples:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "sq": "# Radhit një listë datash në formatin 'MM/DD/YYYY'.\n# Funksioni merr një varg me data në formë string dhe kthen një varg me data të renditura në rend rritës.\n# Renditja bëhet bazuar në rendin kronologjik të datave.\n#\n# Shembuj:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "hy": "# Դասավորում է ամսաթվերի ցուցակը 'MM/DD/YYYY' ձևաչափով:\n# Ֆունկցիան ընդունում է տողային ամսաթվերի զանգված և վերադարձնում է ամսաթվերի զանգվածը դասավորված աճման կարգով:\n# Դասավորումը կատարվում է ամսաթվերի ժամանակագրական կարգի հիման վրա:\n#\n# Օրինակներ:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "bn": "# 'MM/DD/YYYY' ফরম্যাটে একটি তালিকা সাজায়।\n# ফাংশনটি একটি তারিখের স্ট্রিংয়ের অ্যারে নেয় এবং একটি তারিখের অ্যারে ফেরত দেয় যা ঊর্ধ্বক্রমে সাজানো থাকে।\n# তারিখগুলির কালানুক্রমিক ক্রমের উপর ভিত্তি করে সাজানো হয়।\n#\n# উদাহরণ:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "bg": "# Сортира списък от дати във формат 'MM/DD/YYYY'.\n# Функцията приема масив от дати като низове и връща масив от дати, сортирани във възходящ ред.\n# Сортирането се извършва въз основа на хронологичния ред на датите.\n#\n# Примери:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "zh": "# 对格式为 'MM/DD/YYYY' 的日期列表进行排序。\n# 该函数接受一个字符串日期数组，并返回一个按升序排序的日期数组。\n# 排序是基于日期的时间顺序进行的。\n#\n# 示例：\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "fr": "# Trie une liste de dates au format 'MM/JJ/AAAA'.\n# La fonction prend un tableau de dates sous forme de chaînes et renvoie un tableau de dates triées par ordre croissant.\n# Le tri est effectué en fonction de l'ordre chronologique des dates.\n#\n# Exemples :\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "de": "# Sortiert eine Liste von Daten im Format 'MM/DD/YYYY'.\n# Die Funktion nimmt ein Array von Datumsstrings und gibt ein Array von Daten zurück, das in aufsteigender Reihenfolge sortiert ist.\n# Die Sortierung erfolgt basierend auf der chronologischen Reihenfolge der Daten.\n#\n# Beispiele:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "ha": "# Tana tsara jerin kwanakin a cikin tsarin 'MM/DD/YYYY'.\n# Aikin yana ɗaukar jerin kwanakin rubutu kuma yana mayar da jerin kwanakin da aka tsara a tsari mai tashi.\n# Ana yin tsarin ne bisa ga tsarin kwanakin a jere.\n#\n# Misalai:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "hi": "# 'MM/DD/YYYY' प्रारूप में तारीखों की एक सूची को छांटता है।\n# यह फ़ंक्शन स्ट्रिंग तारीखों की एक array लेता है और तारीखों की एक array लौटाता है जो आरोही क्रम में छांटी गई होती है।\n# छंटाई तारीखों के कालानुक्रमिक क्रम के आधार पर की जाती है।\n#\n# उदाहरण:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "hu": "# Dátumok listáját rendezi 'MM/DD/YYYY' formátumban.\n# A függvény egy tömböt vesz át dátumokkal, és visszaad egy tömböt a dátumokkal növekvő sorrendben rendezve.\n# A rendezés a dátumok időrendi sorrendje alapján történik.\n#\n# Példák:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)"
    },
    "prompt_bertscore": {
      "sq": "0.9950417884286071",
      "hy": "0.9876443957781058",
      "bn": "0.9681243923426642",
      "bg": "0.9947275551658099",
      "zh": "0.9898915012787535",
      "fr": "0.9957290495469878",
      "de": "0.9951178638645435",
      "ha": "0.9744924823586427",
      "hi": "0.9911285712918387",
      "hu": "0.9837381307046738"
    },
    "canonical_solution": "    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end",
    "instruction": {
      "en": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\n请用最多500个字符的中文对该Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nFournir une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nBa da takaitaccen bayani a cikin harshen halitta (docstring) na lambar Ruby a Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def sort_dates(dates)\n    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8794023586761918",
      "bn": "0.8746987912532856",
      "bg": "0.8364486908745768",
      "zh": "0.9851744894778132",
      "fr": "0.9691999758559682",
      "de": "0.9379331703165044",
      "ha": "0.9097338137513623",
      "hi": "0.9119288780921788",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless sort_dates([\"10/21/2003\", \"15/12/1999\",  \"02/12/2004\"]) == [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\nraise 'Test failed' unless sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"]) == [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\nraise 'Test failed' unless sort_dates([\"01/01/2000\", \"12/31/1999\"]) == [\"12/31/1999\", \"01/01/2000\"]\n  \n\nputs 'All tests passed!'",
    "entry_point": "sort_dates",
    "signature": "def sort_dates(dates)",
    "docstring": {
      "en": "Sorts a list of dates in the format 'MM/DD/YYYY'.\nThe function takes an array of string dates and returns an array of dates sorted in ascending order.\nThe sorting is done based on the chronological order of the dates.\n\nExamples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "sq": "Rendit një listë datash në formatin 'MM/DD/YYYY'. Funksioni merr një varg datash si string dhe kthen një varg datash të renditura në rend rritës. Renditja bëhet bazuar në rendin kronologjik të datave.\n\nShembuj:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hy": "Տեսակավորում է ամսաթվերի ցուցակը 'MM/DD/YYYY' ձևաչափով:\nՖունկցիան ընդունում է տողային ամսաթվերի զանգված և վերադարձնում է ամսաթվերի զանգվածը, տեսակավորված աճման կարգով:\nՏեսակավորումը կատարվում է ամսաթվերի ժամանակագրական կարգի հիման վրա:\n\nՕրինակներ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "bn": "তারিখগুলিকে 'MM/DD/YYYY' বিন্যাসে সাজায়। ফাংশনটি একটি স্ট্রিং তারিখের অ্যারে নেয় এবং একটি অ্যারে রিটার্ন করে যা তারিখগুলিকে ঊর্ধ্বক্রমে সাজানো থাকে। তারিখগুলির কালানুক্রমিক ক্রমের উপর ভিত্তি করে সাজানো হয়।\n\nউদাহরণ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "bg": "Сортира списък от дати във формат 'MM/DD/YYYY'. \nФункцията приема масив от дати като низове и връща масив от дати, сортирани във възходящ ред. \nСортирането се извършва въз основа на хронологичния ред на датите.\n\nПримери:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "zh": "对格式为 'MM/DD/YYYY' 的日期列表进行排序。\n该函数接受一个字符串日期数组，并返回按升序排序的日期数组。\n排序是根据日期的时间顺序完成的。\n\n示例：\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "fr": "Trie une liste de dates au format 'MM/JJ/AAAA'.  \nLa fonction prend un tableau de dates sous forme de chaînes de caractères et renvoie un tableau de dates triées par ordre croissant.  \nLe tri est effectué en fonction de l'ordre chronologique des dates.\n\nExemples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "de": "Sortiert eine Liste von Daten im Format 'MM/DD/YYYY'.\nDie Funktion nimmt ein Array von Datumsstrings und gibt ein Array von Daten zurück, das in aufsteigender Reihenfolge sortiert ist.\nDie Sortierung erfolgt basierend auf der chronologischen Reihenfolge der Daten.\n\nBeispiele:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "ha": "Yana tsara jerin ranaku a cikin tsarin 'MM/DD/YYYY'. \nAikin yana ɗaukar jerin ranakun rubutu kuma yana mayar da jerin ranaku da aka tsara a cikin tsari mai ƙaruwa. \nAna yin tsarawa bisa ga tsari na lokaci na ranakun.\n\nMisalai:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hi": "तिथियों की एक सूची को 'MM/DD/YYYY' प्रारूप में क्रमबद्ध करता है। \nयह फ़ंक्शन स्ट्रिंग तिथियों की एक array लेता है और तिथियों की एक array लौटाता है जो आरोही क्रम में क्रमबद्ध होती है। \nक्रमबद्धता तिथियों के कालानुक्रमिक क्रम के आधार पर की जाती है।\n\nउदाहरण:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hu": "Rendez egy dátumlistát az 'HH/NN/ÉÉÉÉ' formátumban.  \nA függvény egy karakterlánc dátumokból álló tömböt vesz át, és egy dátumokat növekvő sorrendben rendezett tömböt ad vissza.  \nA rendezés a dátumok időrendi sorrendje alapján történik.\n\nPéldák:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9886870066481579",
      "hy": "0.9941533147342381",
      "bn": "0.9805199212711464",
      "bg": "0.9942075408282606",
      "zh": "0.9910068108682644",
      "fr": "0.9953468846938767",
      "de": "0.9950084185245932",
      "ha": "0.9743305985980993",
      "hi": "0.9923580933504448",
      "hu": "0.9865622574622277"
    }
  },
  {
    "task_id": "Ruby/38",
    "prompt": {
      "en": "# Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\n# The function takes one argument, input_string, which is a string of letters and possibly digits.\n# Returns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n#\n# Examples:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "sq": "# Gjen shkronjën/shkronjat më të mëdha në vargun e dhënë (duke konsideruar 'A' dhe 'a' si të njëjtën shkronjë) dhe fut \"(max)\" pas secilës paraqitje të saj.\n# Funksioni merr një argument, input_string, i cili është një varg shkronjash dhe ndoshta shifra.\n# Kthen një varg të ri me \"(max)\" të futur pas secilës paraqitje të shkronjës/shkronjave më të mëdha.\n#\n# Shembuj:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "hy": "# Գտնում է մուտքագրած տողում ամենամեծ տառ(եր)ը (հաշվի առնելով 'A' և 'a' որպես նույն տառ) և տեղադրում \"(max)\" յուրաքանչյուրի հանդիպման հետո։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ input_string, որը տառերի և հնարավոր թվերի տող է։\n# Վերադարձնում է նոր տող, որտեղ \"(max)\" տեղադրված է ամենամեծ տառ(եր)ի յուրաքանչյուր հանդիպման հետո։\n#\n# Օրինակներ:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"",
      "bn": "# ইনপুট স্ট্রিংয়ে সবচেয়ে বড় অক্ষর(গুলি) খুঁজে বের করে (যেখানে 'A' এবং 'a' একই অক্ষর হিসেবে বিবেচিত হয়) এবং এর প্রতিটি উপস্থিতির পরে \"(max)\" সন্নিবেশ করে।\n# ফাংশনটি একটি আর্গুমেন্ট নেয়, input_string, যা অক্ষর এবং সম্ভবত সংখ্যা সম্বলিত একটি স্ট্রিং।\n# একটি নতুন স্ট্রিং রিটার্ন করে যেখানে সবচেয়ে বড় অক্ষর(গুলি) এর প্রতিটি উপস্থিতির পরে \"(max)\" সন্নিবেশ করা হয়।\n#\n# উদাহরণ:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "bg": "# Намира най-голямата буква(и) в входния низ (като се счита, че 'A' и 'a' са една и съща буква) и вмъква \"(max)\" след всяко нейно появяване.\n# Функцията приема един аргумент, input_string, който е низ от букви и възможно цифри.\n# Връща нов низ с вмъкнато \"(max)\" след всяко появяване на най-голямата буква(и).\n#\n# Примери:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "zh": "# 查找输入字符串中最大的字母（将 'A' 和 'a' 视为相同的字母），并在其每次出现后插入 \"(max)\"。\n# 该函数接受一个参数，input_string，它是一个可能包含字母和数字的字符串。\n# 返回一个新字符串，在每次出现最大的字母后插入 \"(max)\"。\n#\n# 示例:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "fr": "# Trouve la ou les plus grandes lettres dans la chaîne d'entrée (en considérant 'A' et 'a' comme la même lettre) et insère \"(max)\" après chacune de ses occurrences.\n# La fonction prend un argument, input_string, qui est une chaîne de lettres et éventuellement de chiffres.\n# Retourne une nouvelle chaîne avec \"(max)\" inséré après chaque occurrence de la ou des plus grandes lettres.\n#\n# Exemples :\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "de": "# Findet die größten Buchstaben im Eingabestring (wobei 'A' und 'a' als derselbe Buchstabe betrachtet werden) und fügt \"(max)\" nach jedem Vorkommen davon ein.\n# Die Funktion nimmt ein Argument, input_string, das ein String aus Buchstaben und möglicherweise Ziffern ist.\n# Gibt einen neuen String zurück, bei dem \"(max)\" nach jedem Vorkommen der größten Buchstaben eingefügt ist.\n#\n# Beispiele:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"",
      "ha": "# Nemi mafi girman haruffa a cikin rubutun shigarwa (ta la'akari da 'A' da 'a' a matsayin harafi daya) kuma saka \"(max)\" bayan kowanne daga cikin bayyanar sa.\n# Aikin yana daukar hujja daya, input_string, wanda shine rubutu na haruffa da watakila lambobi.\n# Mayar da sabon rubutu tare da \"(max)\" da aka saka bayan kowanne bayyanar mafi girman haruffa.\n#\n# Misalai:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "hi": "# इनपुट स्ट्रिंग में सबसे बड़े अक्षर(अक्षरों) को ढूंढता है (जहां 'A' और 'a' को एक ही अक्षर माना जाता है) और उसके प्रत्येक occurrence के बाद \"(max)\" जोड़ता है।\n# यह फ़ंक्शन एक आर्ग्युमेंट लेता है, input_string, जो अक्षरों और संभवतः अंकों की एक स्ट्रिंग है।\n# एक नई स्ट्रिंग लौटाता है जिसमें सबसे बड़े अक्षर(अक्षरों) के प्रत्येक occurrence के बाद \"(max)\" जोड़ा गया है।\n#\n# उदाहरण:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "hu": "# Megkeresi a legnagyobb betű(ke)t a bemeneti sztringben (az 'A' és 'a' ugyanannak a betűnek számít), és \"(max)\"-ot illeszt minden előfordulása után.\n# A függvény egy argumentumot vár, az input_string-et, amely egy betűkből és esetleg számjegyekből álló sztring.\n# Visszaad egy új sztringet, amelyben \"(max)\" van beszúrva a legnagyobb betű(k) minden előfordulása után.\n#\n# Példák:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)"
    },
    "prompt_bertscore": {
      "sq": "0.9870264566627063",
      "hy": "0.970963813639558",
      "bn": "0.9580047703200798",
      "bg": "0.9903831114718149",
      "zh": "0.947108503507649",
      "fr": "0.9913915579163289",
      "de": "0.9505610967907974",
      "ha": "0.9635773456600136",
      "hi": "0.9804595376353118",
      "hu": "0.974209036804906"
    },
    "canonical_solution": "    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end",
    "instruction": {
      "en": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def insert_max_after_largest_letters(input_string)\n    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.8856923869524236",
      "bn": "0.8746987912532856",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9379331703165044",
      "ha": "0.9660421500582755",
      "hi": "0.9119288780921788",
      "hu": "0.9327224995308161"
    },
    "level": "",
    "test": "raise 'Test failed' unless insert_max_after_largest_letters(\"abcdefgfedcba\") == \"abcdefg(max)fedcba\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"xxxxx\") == \"x(max)x(max)x(max)x(max)x(max)\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Hello World!\") == \"Hello W(max)orld!\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Ruby123\") == \"Ruby(max)123\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"\") == \"\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"aAbBcC\") == \"aAbBc(max)C(max)\"\n  \n\nputs 'All tests passed!'",
    "entry_point": "insert_max_after_largest_letters",
    "signature": "def insert_max_after_largest_letters(input_string)",
    "docstring": {
      "en": "Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\nThe function takes one argument, input_string, which is a string of letters and possibly digits.\nReturns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n\nExamples:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "sq": "Gjen shkronjën/shkronjat më të mëdha në vargun hyrës (duke konsideruar 'A' dhe 'a' si të njëjtën shkronjë) dhe fut \"(max)\" pas secilës prej paraqitjeve të saj.\nFunksioni merr një argument, input_string, i cili është një varg shkronjash dhe ndoshta shifrash.\nKthen një varg të ri me \"(max)\" të futur pas secilës paraqitje të shkronjës/shkronjave më të mëdha.\n\nShembuj:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hy": "Գտնում է մուտքային տողում ամենամեծ տառ(եր)ը (հաշվի առնելով 'A' և 'a' որպես նույն տառ) և տեղադրում \"(max)\" յուրաքանչյուր հանդիպման հետևից։ \nՖունկցիան ընդունում է մեկ արգումենտ, input_string, որը տառերի և հնարավոր թվերի տող է։ \nՎերադարձնում է նոր տող, որտեղ \"(max)\" տեղադրված է ամենամեծ տառ(եր)ի յուրաքանչյուր հանդիպման հետևից։\n\nՕրինակներ:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "bn": "ইনপুট স্ট্রিং-এ সবচেয়ে বড় অক্ষর(গুলি) খুঁজে বের করে (যেখানে 'A' এবং 'a' একই অক্ষর হিসেবে বিবেচিত হয়) এবং এর প্রতিটি উপস্থিতির পরে \"(max)\" সন্নিবেশ করে।\nফাংশনটি একটি আর্গুমেন্ট নেয়, input_string, যা অক্ষর এবং সম্ভবত সংখ্যার একটি স্ট্রিং।\nএটি একটি নতুন স্ট্রিং প্রদান করে যেখানে সবচেয়ে বড় অক্ষর(গুলি)-এর প্রতিটি উপস্থিতির পরে \"(max)\" সন্নিবেশ করা হয়েছে।\n\nExamples:\nউদাহরণসমূহ:\n\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "bg": "Намира най-голямата(ите) буква(и) в входния низ (като се разглеждат 'A' и 'a' като една и съща буква) и вмъква \"(max)\" след всяко нейно появяване.\nФункцията приема един аргумент, input_string, който е низ от букви и евентуално цифри.\nВръща нов низ с вмъкнато \"(max)\" след всяко появяване на най-голямата(ите) буква(и).\n\nПримери:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "zh": "找到输入字符串中最大的字母（将 'A' 和 'a' 视为相同的字母），并在其每次出现后插入 \"(max)\"。\n该函数接受一个参数，input_string，这是一个可能包含字母和数字的字符串。\n返回一个新字符串，在每个最大字母出现后插入 \"(max)\"。\n\n示例：\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "fr": "Trouve la ou les plus grandes lettres dans la chaîne d'entrée (considérant 'A' et 'a' comme la même lettre) et insère \"(max)\" après chacune de ses occurrences.  \nLa fonction prend un argument, input_string, qui est une chaîne de lettres et éventuellement de chiffres.  \nRenvoie une nouvelle chaîne avec \"(max)\" inséré après chaque occurrence de la ou des plus grandes lettres.  \n\nExemples :  \n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")  \n\"abcdefg(max)fedcba\"  \n>>> insert_max_after_largest_letters(\"aAbBcC\")  \n\"aAbBc(max)C(max)\"  ",
      "de": "Findet die größten Buchstaben im Eingabestring (wobei 'A' und 'a' als derselbe Buchstabe betrachtet werden) und fügt \"(max)\" nach jedem Vorkommen ein.\nDie Funktion nimmt ein Argument, input_string, das ein String aus Buchstaben und möglicherweise Ziffern ist.\nGibt einen neuen String zurück, in dem nach jedem Vorkommen der größten Buchstaben \"(max)\" eingefügt wird.\n\nBeispiele:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "ha": "Nemi mafi girman haruffa a cikin igiyar shigarwa (la'akari da 'A' da 'a' a matsayin harafi daya) kuma saka \"(max)\" bayan kowanne daga cikin bayyanarsa.\nAikin yana daukar hujja daya, input_string, wadda ita ce igiyar haruffa da watakila lambobi.\nYana dawowa da sabon igiya tare da \"(max)\" da aka saka bayan kowanne daga cikin mafi girman haruffa.\nMisalai:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hi": "इनपुट स्ट्रिंग में सबसे बड़े अक्षर(अक्षरों) को ढूंढता है (जहां 'A' और 'a' को एक ही अक्षर माना जाता है) और इसके प्रत्येक प्रकट होने के बाद \"(max)\" डालता है।\nयह फ़ंक्शन एक तर्क लेता है, input_string, जो अक्षरों और संभवतः अंकों की एक स्ट्रिंग है।\nएक नई स्ट्रिंग लौटाता है जिसमें सबसे बड़े अक्षर(अक्षरों) के प्रत्येक प्रकट होने के बाद \"(max)\" डाला गया है।\n\nExamples:\nउदाहरण:\n\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hu": "Megkeresi a legnagyobb betű(ke)t a bemeneti sztringben (az 'A' és 'a' ugyanannak a betűnek számít), és \"(max)\"-t szúr be minden előfordulása után.\nA függvény egy argumentumot vesz fel, input_string, amely egy betűkből és esetleg számjegyekből álló sztring.\nVisszaad egy új sztringet, amelyben \"(max)\" van beszúrva a legnagyobb betű(k) minden előfordulása után.\n\nPéldák:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\""
    },
    "docstring_bertscore": {
      "sq": "0.9867009014681901",
      "hy": "0.9545994510676177",
      "bn": "0.9570473718834916",
      "bg": "0.9945664659267907",
      "zh": "0.9326889309964213",
      "fr": "0.9909660916401523",
      "de": "0.9507936929669892",
      "ha": "0.999999801369619",
      "hi": "0.9778886646135773",
      "hu": "0.9833192192310711"
    }
  },
  {
    "task_id": "Ruby/39",
    "prompt": {
      "en": "# Calculates the total number of ways to safely place nuclear materials in N pits arranged in a line\n# such that no three consecutive pits contain nuclear materials, avoiding an explosion.\n# The function takes a single argument, n, which is a positive integer representing the number of pits,\n# and returns the total count of safe placement combinations for the given number of pits.\n#\n# Example:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "sq": "# Llogarit numrin total të mënyrave për të vendosur në mënyrë të sigurt materialet bërthamore në N gropa të rreshtuara në një vijë\n# në mënyrë të tillë që asnjë nga tre gropat e njëpasnjëshme të mos përmbajë materiale bërthamore, duke shmangur një shpërthim.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson numrin e gropave,\n# dhe kthen numrin total të kombinimeve të vendosjes së sigurt për numrin e dhënë të gropave.\n#\n# Shembull:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "hy": "# Հաշվում է ընդհանուր եղանակների քանակը՝ անվտանգ տեղադրելու միջուկային նյութերը N փոսերում, որոնք դասավորված են գծով\n# այնպես, որ ոչ մի երեք հաջորդական փոսեր չպարունակեն միջուկային նյութեր՝ խուսափելով պայթյունից:\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է՝ ներկայացնող փոսերի քանակը,\n# և վերադարձնում է անվտանգ տեղադրման կոմբինացիաների ընդհանուր քանակը տրված փոսերի համար:\n#\n# Օրինակ:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "bn": "# পরমাণু উপকরণগুলি একটি সরলরেখায় সাজানো N গর্তে নিরাপদে স্থাপন করার মোট সংখ্যা গণনা করে\n# যাতে কোনো তিনটি পরপর গর্তে পরমাণু উপকরণ না থাকে, বিস্ফোরণ এড়াতে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা গর্তের সংখ্যা নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা,\n# এবং প্রদত্ত গর্তের সংখ্যার জন্য নিরাপদ স্থাপনার সংমিশ্রণের মোট গণনা প্রদান করে।\n#\n# উদাহরণ:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "bg": "# Изчислява общия брой начини за безопасно поставяне на ядрени материали в N ями, подредени в линия\n# така че нито три последователни ями да съдържат ядрени материали, избягвайки експлозия.\n# Функцията приема един аргумент, n, който е положително цяло число, представляващо броя на ямите,\n# и връща общия брой безопасни комбинации за поставяне за дадения брой ями.\n#\n# Пример:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "zh": "# 计算在 N 个按顺序排列的坑中安全放置核材料的总方法数\n# 确保没有三个连续的坑中含有核材料，以避免爆炸。\n# 该函数接受一个参数 n，它是一个表示坑数量的正整数，\n# 并返回给定数量的坑的安全放置组合的总数。\n#\n# 示例:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "fr": "# Calcule le nombre total de façons de placer en toute sécurité des matériaux nucléaires dans N fosses disposées en ligne\n# de telle sorte qu'aucune trois fosses consécutives ne contiennent de matériaux nucléaires, évitant ainsi une explosion.\n# La fonction prend un seul argument, n, qui est un entier positif représentant le nombre de fosses,\n# et renvoie le nombre total de combinaisons de placement sûres pour le nombre donné de fosses.\n#\n# Exemple :\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "de": "# Berechnet die Gesamtanzahl der Möglichkeiten, nukleares Material sicher in N Gruben anzuordnen,\n# die in einer Linie angeordnet sind, sodass keine drei aufeinanderfolgenden Gruben nukleares Material enthalten,\n# um eine Explosion zu vermeiden.\n# Die Funktion nimmt ein einzelnes Argument n, das eine positive ganze Zahl darstellt, die die Anzahl der Gruben angibt,\n# und gibt die Gesamtanzahl der sicheren Platzierungskombinationen für die gegebene Anzahl von Gruben zurück.\n#\n# Beispiel:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "ha": "# Lissafi jimillar hanyoyin da za a sanya kayan nukiliya cikin rami N da aka tsara a layi\n# ta yadda babu ramuka uku a jere da ke dauke da kayan nukiliya, don guje wa fashewa.\n# Aikin yana daukar hujja guda, n, wanda yake lamba mai kyau da ke wakiltar adadin ramuka,\n# kuma yana mayar da jimillar adadin hanyoyin sanya kayan cikin aminci don adadin ramukan da aka bayar.\n#\n# Misali:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "hi": "# पंक्ति में व्यवस्थित N गड्ढों में परमाणु सामग्री को सुरक्षित रूप से रखने के कुल तरीकों की गणना करता है\n# ताकि कोई भी तीन लगातार गड्ढे परमाणु सामग्री न रखें, जिससे विस्फोट से बचा जा सके।\n# यह फ़ंक्शन एकल तर्क n लेता है, जो गड्ढों की संख्या का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है,\n# और दिए गए गड्ढों की संख्या के लिए सुरक्षित प्लेसमेंट संयोजनों की कुल गणना लौटाता है।\n#\n# उदाहरण:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "hu": "# Kiszámítja a nukleáris anyagok biztonságos elhelyezésének összes lehetséges módját N gödörben, amelyek egy sorban vannak elrendezve,\n# úgy, hogy ne legyen három egymást követő gödör, amely nukleáris anyagokat tartalmaz, elkerülve ezzel a robbanást.\n# A függvény egyetlen argumentumot vesz fel, n, amely egy pozitív egész szám, és a gödrök számát jelenti,\n# és visszaadja a biztonságos elhelyezési kombinációk teljes számát a megadott gödörszámra.\n#\n# Példa:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9846554058042928",
      "hy": "0.9821123410359032",
      "bn": "0.9243611536411525",
      "bg": "0.9879387660027995",
      "zh": "0.9503769664275781",
      "fr": "0.9904683239052788",
      "de": "0.9694160857105342",
      "ha": "0.9586064217442345",
      "hi": "0.9893492403385282",
      "hu": "0.9580828320598265"
    },
    "canonical_solution": "    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end",
    "instruction": {
      "en": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\n请用最多500个字符的中文对该Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nBa da takaitaccen bayanin yaren halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_safe_placements(n)\n    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8535025460322906",
      "bn": "0.897616168725948",
      "bg": "0.8364486908745768",
      "zh": "0.9851194688622666",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9111357469807065",
      "hi": "0.9119288780921788",
      "hu": "0.9226231378070973"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_safe_placements(1) == 2\nraise 'Test failed' unless count_safe_placements(4) == 13\nraise 'Test failed' unless count_safe_placements(10) == 504\nraise 'Test failed' unless count_safe_placements(3) == 7\nraise 'Test failed' unless count_safe_placements(2) == 4\n    \n\nputs 'All tests passed!'",
    "entry_point": "count_safe_placements",
    "signature": "def count_safe_placements(n)",
    "docstring": {
      "en": "Calculates the total number of ways to safely place nuclear materials in N pits arranged in a line\nsuch that no three consecutive pits contain nuclear materials, avoiding an explosion.\nThe function takes a single argument, n, which is a positive integer representing the number of pits,\nand returns the total count of safe placement combinations for the given number of pits.\n\nExample:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "sq": "Llogarit numrin total të mënyrave për të vendosur në mënyrë të sigurt materialet bërthamore në N gropa të renditura në një vijë\ntë tilla që asnjë nga tre gropat e njëpasnjëshme të mos përmbajnë materiale bërthamore, duke shmangur një shpërthim.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson numrin e gropave,\ndhe kthen numrin total të kombinimeve të vendosjes së sigurt për numrin e dhënë të gropave.\n\nShembull:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hy": "Հաշվում է միջուկային նյութերի անվտանգ տեղադրման եղանակների ընդհանուր քանակը N փոսերում, որոնք դասավորված են գծով այնպես, որ ոչ մի երեք հաջորդական փոսերում չլինեն միջուկային նյութեր՝ խուսափելով պայթյունից։ Ֆունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է՝ ներկայացնելով փոսերի քանակը, և վերադարձնում է տվյալ քանակի փոսերի համար անվտանգ տեղադրման համակցությունների ընդհանուր քանակը։\n\nՕրինակ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "bn": "নিউক্লিয়ার উপকরণগুলি একটি লাইনে সাজানো N গর্তে নিরাপদে স্থাপন করার মোট পদ্ধতির সংখ্যা গণনা করে যাতে কোনো তিনটি ধারাবাহিক গর্তে নিউক্লিয়ার উপকরণ না থাকে, বিস্ফোরণ এড়ানো যায়। ফাংশনটি একটি একক আর্গুমেন্ট নেয়, n, যা গর্তের সংখ্যা নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা, এবং প্রদত্ত গর্তের সংখ্যার জন্য নিরাপদ স্থাপনার সংমিশ্রণের মোট সংখ্যা ফেরত দেয়।\n\nউদাহরণ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "bg": "Изчислява общия брой начини за безопасно поставяне на ядрени материали в N ями, подредени в линия, така че нито три последователни ями да съдържат ядрени материали, избягвайки експлозия. Функцията приема един аргумент, n, който е положително цяло число, представляващо броя на ямите, и връща общия брой на безопасните комбинации за поставяне за дадения брой ями.\n\nПример:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "zh": "计算在一排的 N 个坑中安全放置核材料的总方法数，确保没有三个连续的坑中含有核材料，以避免爆炸。该函数接受一个参数 n，这是一个表示坑数量的正整数，并返回给定坑数量的安全放置组合的总计数。\n\n示例：\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "fr": "Calcule le nombre total de façons de placer en toute sécurité des matériaux nucléaires dans N fosses disposées en ligne\nde sorte qu'aucune trois fosses consécutives ne contiennent de matériaux nucléaires, évitant ainsi une explosion.\nLa fonction prend un seul argument, n, qui est un entier positif représentant le nombre de fosses,\net retourne le nombre total de combinaisons de placements sûrs pour le nombre donné de fosses.\n\nExemple :\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "de": "Berechnet die Gesamtanzahl der Möglichkeiten, nukleares Material sicher in N Gruben anzuordnen, die in einer Linie aufgestellt sind, sodass keine drei aufeinanderfolgenden Gruben nukleares Material enthalten, um eine Explosion zu vermeiden. Die Funktion nimmt ein einzelnes Argument n, das eine positive ganze Zahl darstellt, die die Anzahl der Gruben angibt, und gibt die Gesamtanzahl der sicheren Platzierungskombinationen für die gegebene Anzahl von Gruben zurück.\n\nBeispiel:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "ha": "Yana ƙididdige jimillar hanyoyin da za a sanya kayan nukiliya cikin aminci a cikin ramuka N da aka shirya a layi\nta yadda babu ramuka guda uku a jere da ke dauke da kayan nukiliya, don guje wa fashewa.\nAikin yana karɓar hujja guda, n, wanda yake lamba mai kyau da ke wakiltar adadin ramuka,\nkuma yana mayar da jimillar adadin haɗakar amintattun wuraren da aka sanya don adadin ramukan da aka bayar.\n\nMisali:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hi": "N गड्ढों में परमाणु सामग्री को सुरक्षित रूप से रखने के कुल तरीकों की गणना करता है जो एक पंक्ति में व्यवस्थित हैं ताकि कोई तीन लगातार गड्ढे परमाणु सामग्री न रखें, जिससे विस्फोट से बचा जा सके। यह फ़ंक्शन एकल तर्क n लेता है, जो गड्ढों की संख्या का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है, और दिए गए गड्ढों की संख्या के लिए सुरक्षित प्लेसमेंट संयोजनों की कुल गणना लौटाता है।\n\nउदाहरण:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hu": "Kiszámítja a nukleáris anyagok biztonságos elhelyezésének összes lehetséges módját N gödörben, amelyek egy sorban helyezkednek el úgy, hogy ne legyen három egymást követő gödör, amely nukleáris anyagokat tartalmaz, elkerülve a robbanást. A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és a gödrök számát jelenti, és visszaadja a biztonságos elhelyezési kombinációk teljes számát a megadott gödrök számához.\n\nPélda:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504"
    },
    "docstring_bertscore": {
      "sq": "0.9950044459169726",
      "hy": "0.9774004311369935",
      "bn": "0.9617131995340011",
      "bg": "0.9875276011140574",
      "zh": "0.9547599444154938",
      "fr": "0.9912848934017132",
      "de": "0.9670253704443982",
      "ha": "0.9472249009109354",
      "hi": "0.9715829445372437",
      "hu": "0.9660077870023565"
    }
  },
  {
    "task_id": "Ruby/40",
    "prompt": {
      "en": "# Calculates the time needed to hang a saline solution.\n#\n# The function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\n# and d, which is the volume of each drop in milliliters. The function assumes that each drop takes \n# one second to fall and there is a one-second pause after a certain number of drops, which increases \n# sequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\n# The function returns the total time in seconds required to hang the entire volume of saline solution.\n#\n# Examples:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "sq": "# Llogarit kohën e nevojshme për të varur një solucion fiziologjik.\n#\n# Funksioni merr dy argumente: vul, që është vëllimi total i solucionit fiziologjik në mililitra,\n# dhe d, që është vëllimi i secilës pikë në mililitra. Funksioni supozon se çdo pikë bie për një sekondë\n# dhe ka një pauzë një sekondë pas një numri të caktuar pikash, që rritet në mënyrë sekuenciale \n# (1 pikë, pastaj një pauzë, 2 pika, pastaj një pauzë, e kështu me radhë).\n# Funksioni kthen kohën totale në sekonda të nevojshme për të varur të gjithë vëllimin e solucionit fiziologjik.\n#\n# Shembuj:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\ndef calculate_hanging_time(vul, d)",
      "hy": "# Հաշվում է ֆիզիոլոգիական լուծույթի կախման համար անհրաժեշտ ժամանակը։\n#\n# Ֆունկցիան ընդունում է երկու արգումենտ՝ vul, որը ֆիզիոլոգիական լուծույթի ընդհանուր ծավալն է միլիլիտրերով,\n# և d, որը յուրաքանչյուր կաթիլի ծավալն է միլիլիտրերով։ Ֆունկցիան ենթադրում է, որ յուրաքանչյուր կաթիլ ընկնում է\n# մեկ վայրկյանում, և կա մեկ վայրկյան դադար որոշակի քանակությամբ կաթիլներից հետո, որը հաջորդաբար ավելանում է\n# (1 կաթիլ, ապա դադար, 2 կաթիլ, ապա դադար և այլն)։\n# Ֆունկցիան վերադարձնում է ֆիզիոլոգիական լուծույթի ամբողջ ծավալը կախելու համար անհրաժեշտ ընդհանուր ժամանակը վայրկյաններով։\n#\n# Օրինակներ:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "bn": "# স্যালাইন দ্রবণ ঝোলানোর জন্য প্রয়োজনীয় সময় গণনা করে।\n#\n# ফাংশনটি দুটি আর্গুমেন্ট নেয়: vul, যা স্যালাইন দ্রবণের মোট ভলিউম মিলিলিটারে,\n# এবং d, যা প্রতিটি ফোঁটার ভলিউম মিলিলিটারে। ফাংশনটি ধরে নেয় যে প্রতিটি ফোঁটা পড়তে এক সেকেন্ড সময় নেয় \n# এবং একটি নির্দিষ্ট সংখ্যক ফোঁটার পর এক সেকেন্ডের বিরতি থাকে, যা ক্রমান্বয়ে বৃদ্ধি পায় \n# (১ ফোঁটা, তারপর বিরতি, ২ ফোঁটা, তারপর বিরতি, এভাবে চলতে থাকে)।\n# ফাংশনটি স্যালাইন দ্রবণের পুরো ভলিউম ঝোলানোর জন্য প্রয়োজনীয় মোট সময় সেকেন্ডে প্রদান করে।\n#\n# উদাহরণ:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "bg": "# Изчислява времето, необходимо за окачване на физиологичен разтвор.\n#\n# Функцията приема два аргумента: vul, който е общият обем на физиологичния разтвор в милилитри,\n# и d, който е обемът на всяка капка в милилитри. Функцията предполага, че всяка капка пада \n# за една секунда и има пауза от една секунда след определен брой капки, която се увеличава \n# последователно (1 капка, след това пауза, 2 капки, след това пауза и така нататък).\n# Функцията връща общото време в секунди, необходимо за окачване на целия обем на физиологичния разтвор.\n#\n# Примери:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "zh": "# 计算悬挂生理盐水所需的时间。\n#\n# 该函数接受两个参数：vul，即生理盐水的总体积（以毫升为单位），\n# 和d，即每滴的体积（以毫升为单位）。函数假设每滴需要一秒钟滴落，\n# 并且在一定数量的滴落后有一秒钟的暂停，暂停的频率依次递增（1滴，然后暂停，2滴，然后暂停，依此类推）。\n# 函数返回悬挂整个生理盐水体积所需的总时间（以秒为单位）。\n#\n# 例子：\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "fr": "# Calcule le temps nécessaire pour suspendre une solution saline.\n#\n# La fonction prend deux arguments : vul, qui est le volume total de la solution saline en millilitres,\n# et d, qui est le volume de chaque goutte en millilitres. La fonction suppose que chaque goutte prend\n# une seconde pour tomber et qu'il y a une pause d'une seconde après un certain nombre de gouttes, qui augmente\n# séquentiellement (1 goutte, puis une pause, 2 gouttes, puis une pause, et ainsi de suite).\n# La fonction renvoie le temps total en secondes nécessaire pour suspendre l'ensemble du volume de solution saline.\n#\n# Exemples :\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "de": "# Berechnet die benötigte Zeit, um eine Kochsalzlösung aufzuhängen.\n#\n# Die Funktion nimmt zwei Argumente: vul, das ist das Gesamtvolumen der Kochsalzlösung in Millilitern,\n# und d, das ist das Volumen jedes Tropfens in Millilitern. Die Funktion geht davon aus, dass jeder Tropfen \n# eine Sekunde benötigt, um zu fallen, und es nach einer bestimmten Anzahl von Tropfen eine einsekündige \n# Pause gibt, die sich sequentiell erhöht (1 Tropfen, dann eine Pause, 2 Tropfen, dann eine Pause, und so weiter).\n# Die Funktion gibt die Gesamtzeit in Sekunden zurück, die benötigt wird, um das gesamte Volumen der Kochsalzlösung aufzuhängen.\n#\n# Beispiele:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "ha": "# Lissafin lokacin da ake bukata don rataye ruwan magani.\n#\n# Aikin yana karɓar hujjoji guda biyu: vul, wanda shine jimillar adadin ruwan magani a cikin mililitoci,\n# da d, wanda shine adadin kowace digo a cikin mililitoci. Aikin yana ɗauka cewa kowace digo tana ɗaukar \n# daƙiƙa ɗaya don faɗuwa kuma akwai dakatarwa na daƙiƙa ɗaya bayan adadin wasu digo, wanda ke ƙaruwa \n# a jere (digo 1, sannan dakatarwa, digo 2, sannan dakatarwa, da dai sauransu).\n# Aikin yana dawo da jimillar lokacin a cikin daƙiƙoƙi da ake buƙata don rataye dukkan adadin ruwan magani.\n#\n# Misalai:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "hi": "# एक सलाइन घोल को लटकाने के लिए आवश्यक समय की गणना करता है।\n#\n# फ़ंक्शन दो तर्क लेता है: vul, जो सलाइन घोल की कुल मात्रा मिलीलीटर में है,\n# और d, जो प्रत्येक बूंद की मात्रा मिलीलीटर में है। फ़ंक्शन मानता है कि प्रत्येक बूंद को गिरने में \n# एक सेकंड लगता है और एक निश्चित संख्या में बूंदों के बाद एक सेकंड का विराम होता है, जो क्रमिक रूप से बढ़ता है \n# (1 बूंद, फिर एक विराम, 2 बूंदें, फिर एक विराम, और इसी तरह)।\n# फ़ंक्शन कुल समय सेकंड में लौटाता है जो पूरे सलाइन घोल की मात्रा को लटकाने के लिए आवश्यक है।\n#\n# उदाहरण:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "hu": "# Kiszámítja a szükséges időt egy sóoldat felakasztásához.\n#\n# A függvény két argumentumot vesz: vul, amely a sóoldat teljes térfogata milliliterben,\n# és d, amely minden csepp térfogata milliliterben. A függvény feltételezi, hogy minden csepp \n# egy másodperc alatt esik le, és van egy másodperces szünet bizonyos számú csepp után, amely \n# szekvenciálisan növekszik (1 csepp, majd szünet, 2 csepp, majd szünet, és így tovább).\n# A függvény visszaadja a teljes időt másodpercben, amely szükséges az egész sóoldat felakasztásához.\n#\n# Példák:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)"
    },
    "prompt_bertscore": {
      "sq": "0.989307527958511",
      "hy": "0.9753352710653738",
      "bn": "0.9722922536279193",
      "bg": "0.9773217735061037",
      "zh": "0.9577827015540828",
      "fr": "0.9958122756766414",
      "de": "0.9857454893354123",
      "ha": "0.9602745196841654",
      "hi": "0.9917286336729452",
      "hu": "0.9776415684195698"
    },
    "canonical_solution": "    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end",
    "instruction": {
      "en": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nՏրամադրել հակիրճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def calculate_hanging_time(vul, d)\n    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9374465258829688",
      "bn": "0.8879772322254679",
      "bg": "0.8991035130191372",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9171840420832189",
      "hi": "0.9119288780921788",
      "hu": "0.9410598111443745"
    },
    "level": "",
    "test": "raise 'Test failed' unless calculate_hanging_time(10, 1) == 13\nraise 'Test failed' unless calculate_hanging_time(20, 2) == 13\nraise 'Test failed' unless calculate_hanging_time(15, 3) == 7\nraise 'Test failed' unless calculate_hanging_time(50, 5) == 13\nraise 'Test failed' unless calculate_hanging_time(100, 10) == 13\n\n  \nputs 'All tests passed!'",
    "entry_point": "calculate_hanging_time",
    "signature": "def calculate_hanging_time(vul, d)",
    "docstring": {
      "en": "Calculates the time needed to hang a saline solution.\n\nThe function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\nand d, which is the volume of each drop in milliliters. The function assumes that each drop takes\none second to fall and there is a one-second pause after a certain number of drops, which increases\nsequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\nThe function returns the total time in seconds required to hang the entire volume of saline solution.\n\nExamples:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "sq": "Llogarit kohën e nevojshme për të varur një solucion fiziologjik.\n\nFunksioni merr dy argumente: vul, që është vëllimi total i solucionit fiziologjik në mililitra, dhe d, që është vëllimi i çdo pike në mililitra. Funksioni supozon se çdo pikë merr një sekondë për të rënë dhe ka një pauzë prej një sekonde pas një numri të caktuar pikash, i cili rritet në mënyrë sekuenciale (1 pikë, pastaj një pauzë, 2 pika, pastaj një pauzë, dhe kështu me radhë). Funksioni kthen kohën totale në sekonda të nevojshme për të varur të gjithë vëllimin e solucionit fiziologjik.\n\nShembuj:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hy": "Հաշվում է ֆիզիոլոգիական լուծույթի կախման համար անհրաժեշտ ժամանակը:\n\nՖունկցիան ընդունում է երկու արգումենտ՝ vul, որը ֆիզիոլոգիական լուծույթի ընդհանուր ծավալն է միլիլիտրերով, և d, որը յուրաքանչյուր կաթիլի ծավալն է միլիլիտրերով: Ֆունկցիան ենթադրում է, որ յուրաքանչյուր կաթիլ ընկնում է մեկ վայրկյանում և կա մեկ վայրկյան դադար որոշակի քանակի կաթիլներից հետո, որը հաջորդաբար մեծանում է (1 կաթիլ, ապա դադար, 2 կաթիլ, ապա դադար և այլն): Ֆունկցիան վերադարձնում է ընդհանուր ժամանակը վայրկյաններով, որը պահանջվում է ֆիզիոլոգիական լուծույթի ամբողջ ծավալը կախելու համար:\n\nՕրինակներ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "bn": "স্যালাইন সলিউশন ঝোলানোর জন্য প্রয়োজনীয় সময় গণনা করে।\n\nফাংশনটি দুটি আর্গুমেন্ট নেয়: vul, যা মিলিলিটার হিসাবে স্যালাইন সলিউশনের মোট ভলিউম, এবং d, যা মিলিলিটার হিসাবে প্রতিটি ড্রপের ভলিউম। ফাংশনটি ধরে নেয় যে প্রতিটি ড্রপ পড়তে এক সেকেন্ড সময় নেয় এবং একটি নির্দিষ্ট সংখ্যক ড্রপের পরে এক সেকেন্ডের বিরতি থাকে, যা ক্রমান্বয়ে বৃদ্ধি পায় (১ ড্রপ, তারপর বিরতি, ২ ড্রপ, তারপর বিরতি, এভাবে চলতে থাকে)। ফাংশনটি স্যালাইন সলিউশনের সম্পূর্ণ ভলিউম ঝোলানোর জন্য প্রয়োজনীয় মোট সময় সেকেন্ডে রিটার্ন করে।\n\nউদাহরণ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "bg": "Изчислява времето, необходимо за окачване на физиологичен разтвор.\n\nФункцията приема два аргумента: vul, който е общият обем на физиологичния разтвор в милилитри,\nи d, който е обемът на всяка капка в милилитри. Функцията предполага, че всяка капка отнема\nедна секунда да падне и има едносекундна пауза след определен брой капки, която се увеличава\nпоследователно (1 капка, след това пауза, 2 капки, след това пауза и така нататък).\nФункцията връща общото време в секунди, необходимо за окачване на целия обем на физиологичния разтвор.\n\nПримери:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "zh": "计算悬挂生理盐水所需的时间。\n\n该函数接受两个参数：vul，表示生理盐水的总体积（以毫升为单位），以及d，表示每滴的体积（以毫升为单位）。函数假设每滴需要一秒钟滴下，并且在一定数量的滴落后会有一秒钟的暂停，这个数量依次增加（1滴，然后暂停，2滴，然后暂停，依此类推）。\n函数返回悬挂整个生理盐水体积所需的总时间（以秒为单位）。\n\n示例：\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "fr": "Calcule le temps nécessaire pour suspendre une solution saline.\n\nLa fonction prend deux arguments : vul, qui est le volume total de la solution saline en millilitres, et d, qui est le volume de chaque goutte en millilitres. La fonction suppose que chaque goutte prend une seconde pour tomber et qu'il y a une pause d'une seconde après un certain nombre de gouttes, qui augmente séquentiellement (1 goutte, puis une pause, 2 gouttes, puis une pause, et ainsi de suite). La fonction renvoie le temps total en secondes nécessaire pour suspendre l'ensemble du volume de la solution saline.\n\nExemples :\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "de": "Berechnet die benötigte Zeit, um eine Kochsalzlösung aufzuhängen.\n\nDie Funktion nimmt zwei Argumente: vul, das ist das Gesamtvolumen der Kochsalzlösung in Millilitern, und d, das ist das Volumen jedes Tropfens in Millilitern. Die Funktion geht davon aus, dass jeder Tropfen eine Sekunde benötigt, um zu fallen, und es nach einer bestimmten Anzahl von Tropfen eine einsekündige Pause gibt, die sich nacheinander erhöht (1 Tropfen, dann eine Pause, 2 Tropfen, dann eine Pause und so weiter). Die Funktion gibt die Gesamtzeit in Sekunden zurück, die benötigt wird, um das gesamte Volumen der Kochsalzlösung aufzuhängen.\n\nBeispiele:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "ha": "Lissafin lokacin da ake bukata don rataye ruwan magani.\n\nAikin yana ɗaukar hujjoji guda biyu: vul, wanda shine jimillar adadin ruwan gishiri a cikin mililita,\nda d, wanda shine adadin kowace digo a cikin mililita. Aikin yana ɗauka cewa kowace digo tana ɗaukar\ndaukacin dakika ɗaya don faɗuwa kuma akwai dakatarwa na dakika ɗaya bayan wani adadin digo, wanda ke ƙaruwa\na jere (digo 1, sannan dakatarwa, digo 2, sannan dakatarwa, da dai sauransu).\nAikin yana dawowa da jimillar lokaci a cikin dakiku da ake buƙata don rataye dukkan adadin ruwan gishiri.\n\nMisalai:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hi": "सलाइन घोल को लटकाने के लिए आवश्यक समय की गणना करता है।\n\nयह फ़ंक्शन दो तर्क लेता है: vul, जो मिलीलीटर में सलाइन घोल की कुल मात्रा है, और d, जो प्रत्येक बूंद की मात्रा मिलीलीटर में है। फ़ंक्शन मानता है कि प्रत्येक बूंद गिरने में एक सेकंड का समय लेती है और एक निश्चित संख्या में बूंदों के बाद एक सेकंड का विराम होता है, जो क्रमिक रूप से बढ़ता है (1 बूंद, फिर विराम, 2 बूंदें, फिर विराम, और इसी तरह)।\nफ़ंक्शन सलाइन घोल की पूरी मात्रा को लटकाने के लिए आवश्यक कुल समय सेकंड में लौटाता है।\n\nउदाहरण:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hu": "Kiszámítja a szükséges időt a sóoldat felakasztásához.\n\nA függvény két argumentumot vesz: vul, amely a sóoldat teljes térfogata milliliterben, és d, amely minden csepp térfogata milliliterben. A függvény feltételezi, hogy minden csepp egy másodperc alatt esik le, és bizonyos számú csepp után egy másodperces szünet van, amely szekvenciálisan növekszik (1 csepp, majd szünet, 2 csepp, majd szünet, és így tovább). A függvény visszaadja a teljes időt másodpercben, amely szükséges a teljes sóoldat térfogatának felakasztásához.\n\nPéldák:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13"
    },
    "docstring_bertscore": {
      "sq": "0.9873824023055208",
      "hy": "0.9652144572605031",
      "bn": "0.9671280623513933",
      "bg": "0.9731634464791383",
      "zh": "0.9571651596994454",
      "fr": "0.9917147295462727",
      "de": "0.9911740576490958",
      "ha": "0.9544103549448725",
      "hi": "0.9866353534424486",
      "hu": "0.9632954891493251"
    }
  },
  {
    "task_id": "Ruby/41",
    "prompt": {
      "en": "# Counts the number of pairs of students who are considered \"equally matched opponents\".\n# Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n# is no more than 5 points, and the total score difference is no more than 10 points.\n# The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n# and returns the total count of \"equally matched\" student pairs.\n#\n# Example:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "sq": "# Numëron numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\".\n# Dy studentë janë \"të barabartë\" nëse diferenca në pikët për secilin lëndë (Kinezisht, Matematikë, Anglisht)\n# nuk është më shumë se 5 pikë, dhe diferenca totale e pikëve nuk është më shumë se 10 pikë.\n# Funksioni merr një varg të vargjeve, ku çdo nën-varg përfaqëson pikët e një studenti në tre lëndët,\n# dhe kthen numrin total të çifteve të studentëve \"të barabartë\".\n#\n# Shembull:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "hy": "# Հաշվում է ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասարապես համընկնող մրցակիցներ\":\n# Երկու ուսանողներ \"հավասարապես համընկնող\" են, եթե յուրաքանչյուր առարկայի (Չինարեն, Մաթեմատիկա, Անգլերեն) միավորների տարբերությունը\n# չի գերազանցում 5 միավորը, և ընդհանուր միավորների տարբերությունը չի գերազանցում 10 միավորը:\n# Ֆունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված ներկայացնում է ուսանողի միավորները երեք առարկաներում,\n# և վերադարձնում է \"հավասարապես համընկնող\" ուսանողների զույգերի ընդհանուր քանակը:\n#\n# Օրինակ:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "bn": "# \"সমানভাবে মেলানো প্রতিদ্বন্দ্বী\" হিসেবে বিবেচিত ছাত্রদের জোড়ার সংখ্যা গণনা করে।\n# দুটি ছাত্র \"সমানভাবে মেলানো\" হয় যদি প্রতিটি বিষয়ে (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য \n# ৫ পয়েন্টের বেশি না হয়, এবং মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি না হয়।\n# ফাংশনটি একটি অ্যারের অ্যারে নেয়, যেখানে প্রতিটি সাব-অ্যারে একটি ছাত্রের তিনটি বিষয়ে স্কোর উপস্থাপন করে,\n# এবং \"সমানভাবে মেলানো\" ছাত্র জোড়ার মোট সংখ্যা ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "bg": "# Брои броя на двойките ученици, които се считат за \"равностойни противници\".\n# Двама ученици са \"равностойни\", ако разликата в точките за всеки предмет (Китайски, Математика, Английски)\n# е не повече от 5 точки, а разликата в общия брой точки е не повече от 10 точки.\n# Функцията приема масив от масиви, където всеки подмасив представлява точките на ученик в трите предмета,\n# и връща общия брой на двойките ученици, които са \"равностойни\".\n#\n# Пример:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "zh": "# 计算被认为是“势均力敌的对手”的学生对数。\n# 如果每个科目（语文、数学、英语）的分数差不超过5分，并且总分差不超过10分，\n# 则两个学生被认为是“势均力敌”。\n# 该函数接受一个数组的数组，其中每个子数组代表一个学生在三个科目中的分数，\n# 并返回“势均力敌”学生对的总数。\n#\n# 示例:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "fr": "# Compte le nombre de paires d'étudiants qui sont considérés comme des \"adversaires également assortis\".\n# Deux étudiants sont \"également assortis\" si la différence de scores pour chaque matière (Chinois, Mathématiques, Anglais)\n# ne dépasse pas 5 points, et si la différence de score total ne dépasse pas 10 points.\n# La fonction prend un tableau de tableaux, où chaque sous-tableau représente les scores d'un étudiant dans les trois matières,\n# et renvoie le nombre total de paires d'étudiants \"également assortis\".\n#\n# Exemple :\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "de": "# Zählt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" gelten.\n# Zwei Schüler sind \"gleichwertig\", wenn der Unterschied in den Punktzahlen für jedes Fach (Chinesisch, Mathematik, Englisch)\n# nicht mehr als 5 Punkte beträgt und der Gesamtnotenunterschied nicht mehr als 10 Punkte beträgt.\n# Die Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die Punktzahlen eines Schülers in den drei Fächern darstellt,\n# und gibt die Gesamtanzahl der \"gleichwertigen\" Schülerpaare zurück.\n#\n# Beispiel:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "ha": "# Yana ƙidaya adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"abokan hamayya masu daidaituwa\".\n# Ana ɗaukar ɗalibai biyu \"masu daidaituwa\" idan bambancin maki a kowace darasi (Sinanci, Lissafi, Turanci)\n# ba ya wuce maki 5, kuma bambancin jimillar maki ba ya wuce maki 10.\n# Aikin yana ɗaukar jerin jerin, inda kowace ƙaramin jeri ke wakiltar maki na ɗalibi a cikin darussa uku,\n# kuma yana mayar da jimillar adadin ma'aurata na ɗalibai \"masu daidaituwa\".\n#\n# Misali:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "hi": "# उन छात्रों की जोड़ी की संख्या गिनता है जिन्हें \"समान रूप से मेल खाते प्रतिद्वंद्वी\" माना जाता है।\n# दो छात्र \"समान रूप से मेल खाते\" होते हैं यदि प्रत्येक विषय (चीनी, गणित, अंग्रेजी) के लिए अंकों का अंतर 5 अंकों से अधिक नहीं है,\n# और कुल अंकों का अंतर 10 अंकों से अधिक नहीं है।\n# यह फ़ंक्शन एक सरणी का सरणी लेता है, जहाँ प्रत्येक उप-सरणी तीन विषयों में एक छात्र के अंकों का प्रतिनिधित्व करती है,\n# और \"समान रूप से मेल खाते\" छात्र जोड़ों की कुल संख्या लौटाता है।\n#\n# उदाहरण:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "hu": "# Megszámolja azon diákpárok számát, akiket \"egyenlően illeszkedő ellenfeleknek\" tekintünk.\n# Két diák \"egyenlően illeszkedő\", ha az egyes tantárgyak (kínai, matematika, angol) pontszámai közötti különbség\n# legfeljebb 5 pont, és az összpontszám különbsége legfeljebb 10 pont.\n# A függvény egy tömböt vesz át, ahol minden al-tömb egy diák pontszámait képviseli a három tantárgyban,\n# és visszaadja az \"egyenlően illeszkedő\" diákpárok teljes számát.\n#\n# Példa:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)"
    },
    "prompt_bertscore": {
      "sq": "0.971220444091855",
      "hy": "0.9700614358185164",
      "bn": "0.9670023293201981",
      "bg": "0.9581436129564231",
      "zh": "0.9352051806633712",
      "fr": "0.9825360196386506",
      "de": "0.9660804857218153",
      "ha": "0.9284815422653402",
      "hi": "0.9648579157265456",
      "hu": "0.9624924265188011"
    },
    "canonical_solution": "  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend",
    "instruction": {
      "en": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nՏվեք կարճ բնութագիր (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 символа.",
      "zh": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\n请用不超过500个字符的中文，为以下Ruby代码提供简明的自然语言描述（文档字符串）。",
      "fr": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nBa da taƙaitaccen bayani a cikin yare na halitta (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_matching_pairs(students_scores)\n  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9403240842130213",
      "hy": "0.8794023586761918",
      "bn": "0.8746987912532856",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9035460801213635",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100], [100, 100, 105], [90, 90, 90]]) == 1\nraise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 80, 85], [80, 85, 80], [76, 81, 85]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100]]) == 0\nraise 'Test failed' unless count_matching_pairs([]) == 0",
    "entry_point": "count_matching_pairs",
    "signature": "def count_matching_pairs(students_scores)",
    "docstring": {
      "en": "Counts the number of pairs of students who are considered \"equally matched opponents\".\n Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n is no more than 5 points, and the total score difference is no more than 10 points.\n The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n and returns the total count of \"equally matched\" student pairs.\n\n Example:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "sq": "Numëron numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\". Dy studentë janë \"të barabartë\" nëse diferenca në pikët për secilin lëndë (Kinezisht, Matematikë, Anglisht) nuk është më shumë se 5 pikë, dhe diferenca totale e pikëve nuk është më shumë se 10 pikë. Funksioni merr një varg me vargje, ku secili nën-varg përfaqëson pikët e një studenti në tre lëndët, dhe kthen numrin total të çifteve të studentëve \"të barabartë\".\n\nShembull:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "hy": "Հաշվում է ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասարապես համընկնող մրցակիցներ\"։ \n Երկու ուսանող \"հավասարապես համընկնող\" են, եթե յուրաքանչյուր առարկայի (չինարեն, մաթեմատիկա, անգլերեն) միավորների տարբերությունը \n չի գերազանցում 5 միավորը, և ընդհանուր միավորների տարբերությունը չի գերազանցում 10 միավորը։\n Ֆունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված ներկայացնում է ուսանողի միավորները երեք առարկաներում,\n և վերադարձնում է \"հավասարապես համընկնող\" ուսանողների զույգերի ընդհանուր քանակը։\n\n Օրինակ:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "bn": "ছাত্রদের জোড়ার সংখ্যা গণনা করে যারা \"সমানভাবে মেলানো প্রতিপক্ষ\" হিসেবে বিবেচিত হয়।\n দুটি ছাত্র \"সমানভাবে মেলানো\" হয় যদি প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ পয়েন্টের বেশি না হয়, এবং মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি না হয়।\n ফাংশনটি একটি অ্যারের অ্যারে নেয়, যেখানে প্রতিটি উপ-অ্যারে তিনটি বিষয়ের মধ্যে একটি ছাত্রের স্কোর উপস্থাপন করে,\n এবং \"সমানভাবে মেলানো\" ছাত্র জোড়ার মোট সংখ্যা ফেরত দেয়।\n\n উদাহরণ:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "bg": "Брои броя на двойките ученици, които се считат за \"равностойни противници\".\n Двама ученици са \"равностойни\", ако разликата в оценките за всеки предмет (Китайски, Математика, Английски)\n е не повече от 5 точки, а разликата в общия резултат е не повече от 10 точки.\n Функцията приема масив от масиви, където всеки подмасив представлява оценките на ученика по трите предмета,\n и връща общия брой на двойките ученици, които са \"равностойни\".\n\n Пример:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "zh": "计算被认为是“势均力敌的对手”的学生对数。 如果两名学生在每个科目（语文、数学、英语）的分数差不超过5分，并且总分差不超过10分，则认为他们是“势均力敌”的。 该函数接受一个数组的数组，其中每个子数组表示一名学生在三个科目中的分数，并返回“势均力敌”学生对的总数。\n\n示例：\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "fr": "Compte le nombre de paires d'élèves considérés comme des \"adversaires également assortis\".\n Deux élèves sont \"également assortis\" si la différence de scores pour chaque matière (Chinois, Mathématiques, Anglais)\n ne dépasse pas 5 points, et si la différence totale de scores ne dépasse pas 10 points.\n La fonction prend un tableau de tableaux, où chaque sous-tableau représente les scores d'un élève dans les trois matières,\n et renvoie le nombre total de paires d'élèves \"également assortis\".\n\n Exemple :\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "de": "Zählt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" betrachtet werden. Zwei Schüler sind \"gleichwertig\", wenn der Unterschied in den Punkten für jedes Fach (Chinesisch, Mathematik, Englisch) nicht mehr als 5 Punkte beträgt und der Gesamtnotenunterschied nicht mehr als 10 Punkte beträgt. Die Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die Noten eines Schülers in den drei Fächern darstellt, und gibt die Gesamtanzahl der \"gleichwertigen\" Schülerpaare zurück.\n\nBeispiel:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "ha": "Yana ƙidaya adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"abokan hamayya daidai gwargwado\". \nAna ɗaukar ɗalibai biyu \"daidai gwargwado\" idan bambancin maki a kowace darasi (Sinanci, Lissafi, Turanci) \nba ya wuce maki 5, kuma bambancin jimillar maki ba ya wuce maki 10. \nAiki yana ɗaukar jerin jerin, inda kowace ƙaramin jeri ke wakiltar maki na ɗalibi a cikin darussa uku, \nkuma yana dawo da jimillar adadin ma'aurata na ɗalibai \"daidai gwargwado\".\n\nMisali:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "hi": "उन छात्रों की जोड़ी की संख्या गिनता है जिन्हें \"समान रूप से मेल खाते प्रतिद्वंद्वी\" माना जाता है।\nदो छात्रों को \"समान रूप से मेल खाते प्रतिद्वंद्वी\" माना जाता है यदि प्रत्येक विषय (चीनी, गणित, अंग्रेजी) के लिए अंकों का अंतर 5 अंकों से अधिक नहीं है, और कुल अंकों का अंतर 10 अंकों से अधिक नहीं है। \nयह फ़ंक्शन एक सरणी का सरणी लेता है, जहाँ प्रत्येक उप-सरणी तीन विषयों में एक छात्र के अंकों का प्रतिनिधित्व करती है, और \"समान रूप से मेल खाते\" छात्र जोड़ों की कुल गिनती लौटाता है।\n\nउदाहरण:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "hu": "Számolja meg azoknak a diákpároknak a számát, akiket \"egyenlően összemért ellenfeleknek\" tekintünk.\n Két diák akkor \"egyenlően összemért\", ha az egyes tantárgyak (kínai, matematika, angol) pontszámkülönbsége legfeljebb 5 pont, és az összpontszám különbsége legfeljebb 10 pont.\n A függvény egy tömbök tömbjét veszi, ahol minden al-tömb egy diák pontszámait képviseli a három tantárgyban, és visszaadja az \"egyenlően összemért\" diákpárok teljes számát.\n\n Példa:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2"
    },
    "docstring_bertscore": {
      "sq": "0.9672788228105987",
      "hy": "0.9699249767467455",
      "bn": "0.9774351914536746",
      "bg": "0.9567808099121429",
      "zh": "0.9268199991279834",
      "fr": "0.9709836766776615",
      "de": "0.9419661615730367",
      "ha": "0.9151826423639113",
      "hi": "0.9689175234541365",
      "hu": "0.9628293036450362"
    }
  },
  {
    "task_id": "Ruby/42",
    "prompt": {
      "en": "# Calculates the total number of cigarettes Peter can smoke given an initial\n# amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n# Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n#\n# The function takes two arguments, n and k, where n is the initial number of\n# cigarettes and k is the number of butts required for a new cigarette. It\n# returns the total number of cigarettes Peter can smoke.\n#\n# Examples:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "sq": "# Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur parasysh një sasi fillestare\n# të cigareve dhe një normë konvertimi të bishtave të cigareve në cigare të reja.\n# Pjetri fillon me n cigare dhe mund të kthejë çdo k bishta në një cigare të re.\n#\n# Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i\n# cigareve dhe k është numri i bishtave të kërkuara për një cigare të re. Ai\n# kthen numrin total të cigareve që Pjetri mund të pijë.\n#\n# Shembuj:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "hy": "# Հաշվում է ընդհանուր ծխախոտների քանակը, որոնք Պետերը կարող է ծխել տրված\n# սկզբնական ծխախոտների քանակը և ծխախոտի մնացորդների փոխարկման հարաբերակցությունը:\n# Պետերը սկսում է n ծխախոտներով և կարող է յուրաքանչյուր k մնացորդը վերածել նոր ծխախոտի:\n#\n# Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ը սկզբնական ծխախոտների\n# քանակն է, իսկ k-ը նոր ծխախոտի համար պահանջվող մնացորդների քանակը: Այն\n# վերադարձնում է ընդհանուր ծխախոտների քանակը, որոնք Պետերը կարող է ծխել:\n#\n# Օրինակներ:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "bn": "# পিটার কতগুলো সিগারেট খেতে পারবে তা গণনা করে, প্রাথমিক সিগারেটের সংখ্যা এবং সিগারেটের অবশিষ্টাংশ থেকে নতুন সিগারেট তৈরির হার দেওয়া হলে।\n# পিটার n সিগারেট দিয়ে শুরু করে এবং প্রতিটি k অবশিষ্টাংশকে একটি নতুন সিগারেটে পরিণত করতে পারে।\n#\n# ফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা এবং k হল একটি নতুন সিগারেটের জন্য প্রয়োজনীয় অবশিষ্টাংশের সংখ্যা। এটি পিটার মোট কতগুলো সিগারেট খেতে পারবে তা ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "bg": "# Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид начално\n# количество цигари и курс на конверсия на фасове в нови цигари.\n# Петър започва с n цигари и може да превърне всеки k фасове в нова цигара.\n#\n# Функцията приема два аргумента, n и k, където n е началният брой\n# цигари и k е броят на фасовете, необходими за нова цигара. Тя\n# връща общия брой цигари, които Петър може да изпуши.\n#\n# Примери:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "zh": "# 计算彼得可以抽的香烟总数，给定初始香烟数量和烟蒂转换成新香烟的比率。\n# 彼得从 n 支香烟开始，可以将每 k 个烟蒂转换成一支新香烟。\n#\n# 该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，k 是需要多少个烟蒂才能换一支新香烟。\n# 它返回彼得可以抽的香烟总数。\n#\n# 例子:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "fr": "# Calcule le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial\n# de cigarettes et un taux de conversion de mégots de cigarettes en nouvelles cigarettes.\n# Peter commence avec n cigarettes et peut transformer chaque k mégots en une nouvelle cigarette.\n#\n# La fonction prend deux arguments, n et k, où n est le nombre initial de\n# cigarettes et k est le nombre de mégots requis pour une nouvelle cigarette. Elle\n# renvoie le nombre total de cigarettes que Peter peut fumer.\n#\n# Exemples :\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "de": "# Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche\n# Menge an Zigaretten und eine Umtauschrate von Zigarettenstummeln in neue Zigaretten.\n# Peter beginnt mit n Zigaretten und kann jeden k Stummel in eine neue Zigarette umwandeln.\n#\n# Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl von\n# Zigaretten ist und k die Anzahl der Stummel ist, die für eine neue Zigarette benötigt werden. Sie\n# gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n#\n# Beispiele:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "ha": "# Lissafin jimillar adadin sigari da Peter zai iya sha idan aka ba shi adadin\n# farko na sigari da kuma yawan bututun sigari da ake buƙata don sabon sigari.\n# Peter yana farawa da n sigari kuma yana iya juya kowane k bututun sigari zuwa sabon sigari.\n#\n# Aikin yana ɗaukar hujjoji biyu, n da k, inda n shine adadin farko na\n# sigari kuma k shine yawan bututun da ake buƙata don sabon sigari. Yana\n# dawowa da jimillar adadin sigari da Peter zai iya sha.\n#\n# Misalai:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "hi": "# यह गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है, दिए गए प्रारंभिक\n# सिगरेट की संख्या और सिगरेट के बट्स को नई सिगरेट में बदलने की दर के आधार पर।\n# पीटर n सिगरेट से शुरू करता है और हर k बट्स को एक नई सिगरेट में बदल सकता है।\n#\n# यह फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है\n# और k वह संख्या है जो एक नई सिगरेट के लिए आवश्यक बट्स की है। यह\n# लौटाता है कि पीटर कुल कितनी सिगरेट पी सकता है।\n#\n# उदाहरण:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "hu": "# Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni, ha van egy kezdeti\n# mennyiségű cigarettája és egy átváltási arány a cigarettacsikkek új cigarettára váltásához.\n# Péter n cigarettával kezd, és minden k csikket új cigarettára tud váltani.\n#\n# A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigaretták száma,\n# és k az új cigarettához szükséges csikkek száma. Visszaadja az összes cigarettát,\n# amit Péter el tud szívni.\n#\n# Példák:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)"
    },
    "prompt_bertscore": {
      "sq": "0.9848393375371312",
      "hy": "0.9706692447844832",
      "bn": "0.9732502479556506",
      "bg": "0.9835740620099389",
      "zh": "0.9522707084803647",
      "fr": "0.987144443109041",
      "de": "0.9929468337998322",
      "ha": "0.9656591906836403",
      "hi": "0.9419548396413178",
      "hu": "0.9584314283785428"
    },
    "canonical_solution": "    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end",
    "instruction": {
      "en": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nনিচের রুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলা ভাষায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে সীমাবদ্ধ।",
      "bg": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\n请用最多500个字符的中文简明自然语言描述Ruby代码的功能（文档字符串）。",
      "fr": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen an.",
      "ha": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Ruby a cikin Hausa ba tare da wucewa haruffa 500 ba.",
      "hi": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def total_smoked_cigarettes(n, k)\n    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8888019455675248",
      "bn": "0.8753050111762041",
      "bg": "0.8364486908745768",
      "zh": "0.8483244506290921",
      "fr": "0.9691999758559682",
      "de": "0.9379331703165044",
      "ha": "0.9176980975093372",
      "hi": "0.9027873120658102",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless total_smoked_cigarettes(4, 3) == 5\nraise 'Test failed' unless total_smoked_cigarettes(10, 3) == 14\nraise 'Test failed' unless total_smoked_cigarettes(20, 4) == 26\nraise 'Test failed' unless total_smoked_cigarettes(1, 2) == 1\nraise 'Test failed' unless total_smoked_cigarettes(100, 5) == 124\n  ",
    "entry_point": "total_smoked_cigarettes",
    "signature": "def total_smoked_cigarettes(n, k)",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial\n amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n\n The function takes two arguments, n and k, where n is the initial number of\n cigarettes and k is the number of butts required for a new cigarette. It\n returns the total number of cigarettes Peter can smoke.\n\n Examples:\n >>> total_smoked_cigarettes(4, 3)\n 5\n >>> total_smoked_cigarettes(10, 3)\n 14",
      "sq": "Llogarit numrin total të cigareve që Peter mund të pijë duke pasur parasysh një sasi fillestare të cigareve dhe një normë konvertimi të bishtave të cigareve në cigare të reja. Peter fillon me n cigare dhe mund të kthejë çdo k bishta në një cigare të re.\n\nFunksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve dhe k është numri i bishtave të kërkuara për një cigare të re. Ai kthen numrin total të cigareve që Peter mund të pijë.\n\nShembuj:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "hy": "Հաշվում է ընդհանուր սիգարետների քանակը, որոնք Պետերը կարող է ծխել՝ հաշվի առնելով սիգարետների սկզբնական քանակը և սիգարետների մնացորդների նոր սիգարետների վերածման հարաբերակցությունը։ Պետերը սկսում է n սիգարետներով և կարող է յուրաքանչյուր k մնացորդը վերածել նոր սիգարետի։\n\nՖունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ը սիգարետների սկզբնական քանակն է, իսկ k-ը նոր սիգարետի համար պահանջվող մնացորդների քանակն է։ Այն վերադարձնում է ընդհանուր սիգարետների քանակը, որոնք Պետերը կարող է ծխել։\n\nՕրինակներ:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "bn": "সিগারেটের মোট সংখ্যা গণনা করে যা পিটার ধূমপান করতে পারে প্রদত্ত প্রাথমিক সিগারেটের সংখ্যা এবং সিগারেটের বাট থেকে নতুন সিগারেটের রূপান্তর হারের ভিত্তিতে। পিটার n সিগারেট দিয়ে শুরু করে এবং প্রতিটি k বাটকে একটি নতুন সিগারেটে পরিণত করতে পারে।\n\nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা এবং k হল একটি নতুন সিগারেটের জন্য প্রয়োজনীয় বাটের সংখ্যা। এটি পিটার কতগুলি সিগারেট ধূমপান করতে পারে তার মোট সংখ্যা প্রদান করে।\n\nউদাহরণসমূহ:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши, като се даде начално количество цигари и курс на преобразуване на фасове в нови цигари. Петър започва с n цигари и може да превърне всеки k фасове в нова цигара.\n\nФункцията приема два аргумента, n и k, където n е началният брой цигари, а k е броят на фасовете, необходими за нова цигара. Тя връща общия брой цигари, които Петър може да изпуши.\n\nПримери:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "zh": "计算彼得在给定初始香烟数量和烟蒂转换为新香烟的转换率的情况下可以抽的香烟总数。彼得从 n 支香烟开始，并且可以将每 k 个烟蒂转换为一支新香烟。\n\n该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，k 是需要转换为新香烟的烟蒂数量。它返回彼得可以抽的香烟总数。\n\n示例：\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un taux de conversion de mégots en nouvelles cigarettes. Peter commence avec n cigarettes et peut transformer chaque k mégots en une nouvelle cigarette.\n\nLa fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes et k est le nombre de mégots requis pour une nouvelle cigarette. Elle renvoie le nombre total de cigarettes que Peter peut fumer.\n\nExemples :\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und eine Umwandlungsrate von Zigarettenstummeln zu neuen Zigaretten. Peter beginnt mit n Zigaretten und kann jeden k Stummel in eine neue Zigarette umwandeln.\n\nDie Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist und k die Anzahl der Stummel, die für eine neue Zigarette benötigt werden. Sie gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n\nBeispiele:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "ha": "Yana ƙididdige adadin sigari da Peter zai iya sha la'akari da adadin farko\nna sigari da kuma ƙimar jujjuyawar bututun sigari zuwa sabbin sigari.\nPeter yana farawa da n sigari kuma zai iya juyar da kowane k bututun zuwa sabon sigari.\n\nAikin yana ɗaukar hujjoji guda biyu, n da k, inda n shine adadin farko na\nsigari kuma k shine adadin bututun da ake buƙata don sabon sigari. Yana\nmayar da adadin sigari da Peter zai iya sha.\n\nMisalai:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "hi": "कुल सिगरेटों की संख्या की गणना करता है जो पीटर धूम्रपान कर सकता है, दिए गए प्रारंभिक सिगरेटों की संख्या और सिगरेट के बट्स को नई सिगरेटों में बदलने की दर के आधार पर। पीटर n सिगरेटों के साथ शुरू करता है और हर k बट्स को एक नई सिगरेट में बदल सकता है।\n\nयह फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेटों की संख्या है और k एक नई सिगरेट के लिए आवश्यक बट्स की संख्या है। यह पीटर द्वारा धूम्रपान की जा सकने वाली कुल सिगरेटों की संख्या लौटाता है।\n\nउदाहरण:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "hu": "Kiszámítja, hogy összesen hány cigarettát tud elszívni Péter, ha adott egy kezdeti cigarettaszám és egy konverziós arány a cigarettacsikkekből új cigarettákra. Péter n cigarettával kezd, és minden k csikket új cigarettára tud váltani.\n\nA függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigaretták száma, k pedig az új cigarettához szükséges csikkek száma. Visszaadja az összes cigaretták számát, amit Péter el tud szívni.\n\nPéldák:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14"
    },
    "docstring_bertscore": {
      "sq": "0.9834475344572197",
      "hy": "0.97604279248262",
      "bn": "0.9741142901131523",
      "bg": "0.9812113536275289",
      "zh": "0.9777335342859891",
      "fr": "0.9866073465587226",
      "de": "0.9916118390088967",
      "ha": "0.9820610943975961",
      "hi": "0.9579251195372848",
      "hu": "0.9714067593892658"
    }
  },
  {
    "task_id": "Ruby/43",
    "prompt": {
      "en": "# Finds the length of the longest consecutive sequence in an array of integers.\n# The function takes an array of integers as an argument and returns the length\n# of the longest consecutive sequence of numbers present in the array.\n#\n# Example:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Because the longest consecutive sequence is 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "sq": "# Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në një varg të numrave të plotë.\n# Funksioni merr një varg të numrave të plotë si argument dhe kthen gjatësinë\n# e sekuencës më të gjatë të njëpasnjëshme të numrave të pranishëm në varg.\n#\n# Shembull:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "hy": "# Գտնում է ամենաերկար հաջորդական հաջորդականության երկարությունը ամբողջ թվերի զանգվածում։\n# Ֆունկցիան որպես արգումենտ ընդունում է ամբողջ թվերի զանգված և վերադարձնում\n# զանգվածում առկա ամենաերկար հաջորդական հաջորդականության երկարությունը։\n#\n# Օրինակ:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4, 5, 6 է\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է\ndef longest_consecutive_sequence(arr)",
      "bn": "# পূর্ণসংখ্যার একটি অ্যারেতে সবচেয়ে দীর্ঘ ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n# ফাংশনটি একটি পূর্ণসংখ্যার অ্যারে আর্গুমেন্ট হিসাবে গ্রহণ করে এবং অ্যারেতে উপস্থিত\n# সবচেয়ে দীর্ঘ ক্রমাগত সংখ্যার ক্রমের দৈর্ঘ্য ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # কারণ সবচেয়ে দীর্ঘ ক্রমাগত ক্রম হল 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # কারণ সবচেয়ে দীর্ঘ ক্রমাগত ক্রম হল 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "bg": "# Намира дължината на най-дългата последователна редица в масив от цели числа.\n# Функцията приема масив от цели числа като аргумент и връща дължината\n# на най-дългата последователна редица от числа, присъстваща в масива.\n#\n# Пример:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Защото най-дългата последователна редица е 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Защото най-дългата последователна редица е 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "zh": "# 查找整数数组中最长连续序列的长度。\n# 该函数接受一个整数数组作为参数，并返回数组中存在的最长连续序列的长度。\n#\n# 示例：\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # 因为最长的连续序列是 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # 因为最长的连续序列是 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "fr": "# Trouve la longueur de la plus longue séquence consécutive dans un tableau d'entiers.\n# La fonction prend un tableau d'entiers comme argument et renvoie la longueur\n# de la plus longue séquence consécutive de nombres présente dans le tableau.\n#\n# Exemple :\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Parce que la plus longue séquence consécutive est 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Parce que la plus longue séquence consécutive est 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "de": "# Findet die Länge der längsten aufeinanderfolgenden Sequenz in einem Array von ganzen Zahlen.\n# Die Funktion nimmt ein Array von ganzen Zahlen als Argument und gibt die Länge\n# der längsten aufeinanderfolgenden Zahlenfolge im Array zurück.\n#\n# Beispiel:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4, 5, 6 ist\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist\ndef longest_consecutive_sequence(arr)",
      "ha": "# Nemi tsawon jerin lambobi masu jere mafi tsawo a cikin jerin lambobi.\n# Aikin yana karɓar jerin lambobi a matsayin hujja kuma yana mayar da tsawon\n# jerin lambobi masu jere mafi tsawo da ke cikin jerin.\n#\n# Misali:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Domin jerin lambobi masu jere mafi tsawo su ne 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Domin jerin lambobi masu jere mafi tsawo su ne 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "hi": "# एक पूर्णांकों की array में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\n# यह फ़ंक्शन एक पूर्णांकों की array को तर्क के रूप में लेता है और array में मौजूद\n# सबसे लंबे लगातार अनुक्रम की लंबाई को लौटाता है।\n#\n# उदाहरण:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4, 5, 6 है\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4 है\ndef longest_consecutive_sequence(arr)",
      "hu": "# Megkeresi a leghosszabb egymást követő sorozat hosszát egy egész számokat tartalmazó tömbben.\n# A függvény egy egész számokat tartalmazó tömböt vesz argumentumként, és visszaadja a tömbben\n# található leghosszabb egymást követő számok sorozatának hosszát.\n#\n# Példa:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)"
    },
    "prompt_bertscore": {
      "sq": "0.995621789141229",
      "hy": "0.98680836050433",
      "bn": "0.9940982941186914",
      "bg": "1",
      "zh": "0.9599467795554579",
      "fr": "0.995621789141229",
      "de": "0.9791684401585851",
      "ha": "0.9577249001132017",
      "hi": "0.9838847199258774",
      "hu": "0.9964383586376634"
    },
    "canonical_solution": "    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end",
    "instruction": {
      "en": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nBa da taƙaitaccen bayanin yare na halitta (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def longest_consecutive_sequence(arr)\n    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9400922825583535",
      "hy": "0.9202439431030613",
      "bn": "0.9138385105754483",
      "bg": "0.8991035130191372",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9531146889693819",
      "hi": "0.9119288780921788",
      "hu": "0.9226231378070973"
    },
    "level": "",
    "test": "raise 'Test failed' unless longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9]) ==6\nraise 'Test failed' unless longest_consecutive_sequence([10, 4, 20, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([1, 2, 0, 1]) == 3\nraise 'Test failed' unless longest_consecutive_sequence([]) == 0\nraise 'Test failed' unless longest_consecutive_sequence([1]) == 1",
    "entry_point": "longest_consecutive_sequence",
    "signature": "def longest_consecutive_sequence(arr)",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in an array of integers.\n The function takes an array of integers as an argument and returns the length\n of the longest consecutive sequence of numbers present in the array.\n\n Example:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Because the longest consecutive sequence is 1, 2, 3, 4",
      "sq": "Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në një varg të numrave të plotë.\n Funksioni merr një varg të numrave të plotë si argument dhe kthen gjatësinë\n e sekuencës më të gjatë të njëpasnjëshme të numrave të pranishëm në varg.\n\n Shembull:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4",
      "hy": "Գտնում է ամբողջ թվերի զանգվածում ամենաերկար հաջորդական հաջորդականության երկարությունը։ Ֆունկցիան որպես արգումենտ ընդունում է ամբողջ թվերի զանգված և վերադարձնում է զանգվածում առկա ամենաերկար հաջորդական հաջորդականության երկարությունը։\n\nՕրինակ:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4, 5, 6 է\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է",
      "bn": "একটি পূর্ণসংখ্যার অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করে।\nইনটিজারগুলির একটি অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে। ফাংশনটি একটি ইনটিজার অ্যারে আর্গুমেন্ট হিসাবে গ্রহণ করে এবং অ্যারেতে উপস্থিত দীর্ঘতম ধারাবাহিক সংখ্যার ক্রমের দৈর্ঘ্য ফেরত দেয়।\n\nউদাহরণ:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   কারণ দীর্ঘতম ধারাবাহিক ক্রমটি হল 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   কারণ দীর্ঘতম ধারাবাহিক ক্রমটি হল 1, 2, 3, 4",
      "bg": "Намира дължината на най-дългата последователна поредица в масив от цели числа.\nФункцията приема масив от цели числа като аргумент и връща дължината на най-дългата последователна поредица от числа, присъстващи в масива.\n\nПример:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Защото най-дългата последователна поредица е 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Защото най-дългата последователна поредица е 1, 2, 3, 4",
      "zh": "找到整数数组中最长连续序列的长度。该函数接受一个整数数组作为参数，并返回数组中存在的最长连续数字序列的长度。\n\n示例：\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   因为最长的连续序列是 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   因为最长的连续序列是 1, 2, 3, 4",
      "fr": "Trouve la longueur de la plus longue séquence consécutive dans un tableau d'entiers.\n La fonction prend un tableau d'entiers comme argument et renvoie la longueur\n de la plus longue séquence consécutive de nombres présente dans le tableau.\n\n Exemple :\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Parce que la plus longue séquence consécutive est 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Parce que la plus longue séquence consécutive est 1, 2, 3, 4",
      "de": "Findet die Länge der längsten aufeinanderfolgenden Sequenz in einem Array von ganzen Zahlen.\n Die Funktion nimmt ein Array von ganzen Zahlen als Argument und gibt die Länge\n der längsten aufeinanderfolgenden Zahlenfolge im Array zurück.\n\n Beispiel:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4, 5, 6 ist\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist",
      "ha": "Yana gano tsawon mafi tsawo jere mai ci gaba a cikin jerin lambobi masu tsari. Aikin yana karɓar jerin lambobi masu tsari a matsayin hujja kuma yana mayar da tsawon mafi tsawo jere mai ci gaba na lambobi da ke cikin jerin.\n\nMisali:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Domin mafi tsawo jere mai ci gaba shine 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Domin mafi tsawo jere mai ci gaba shine 1, 2, 3, 4",
      "hi": "एक पूर्णांकों की array में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\nयह फ़ंक्शन पूर्णांकों की एक array को तर्क के रूप में लेता है और array में उपस्थित संख्याओं के सबसे लंबे लगातार अनुक्रम की लंबाई लौटाता है।\n\nउदाहरण:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4, 5, 6 है\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4 है",
      "hu": "Megtalálja a leghosszabb egymást követő sorozat hosszát egy egész számokat tartalmazó tömbben. \nA függvény egy egész számokat tartalmazó tömböt vesz argumentumként, és visszaadja a tömbben található leghosszabb egymást követő számok sorozatának hosszát.\n\nPélda:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4"
    },
    "docstring_bertscore": {
      "sq": "0.9930380051447272",
      "hy": "0.9854511191107186",
      "bn": "0.9605653145620006",
      "bg": "1",
      "zh": "0.959850443820656",
      "fr": "0.9930380051447272",
      "de": "0.9937201018732009",
      "ha": "0.9736417484366703",
      "hi": "0.9946492947956822",
      "hu": "0.9927219842085007"
    }
  },
  {
    "task_id": "Ruby/44",
    "prompt": {
      "en": "# Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n# The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n# It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n#\n# Examples:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "sq": "# Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\n# Funksioni merr tre argumente, a, b, dhe c, të cilat janë numra të plotë pozitivë që përfaqësojnë gjatësinë e brinjës së katrorit dhe brinjët e drejtkëndëshit, përkatësisht.\n# Kthen një varg që tregon se cila formë ka sipërfaqen më të madhe: \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n#\n# Shembuj:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "hy": "# Համեմատում է կողմի երկարությունը 'a' ունեցող քառակուսի մակերեսը կողմերի 'b' և 'c' ունեցող ուղղանկյան մակերեսի հետ։\n# Ֆունկցիան ընդունում է երեք արգումենտ՝ a, b և c, որոնք դրական ամբողջ թվեր են՝ համապատասխանաբար ներկայացնելով քառակուսու կողմի երկարությունը և ուղղանկյան կողմերը։\n# Այն վերադարձնում է տող, որը ցույց է տալիս, թե ում ձևն ունի ավելի մեծ մակերես՝ \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է։\n#\n# Օրինակներ:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "bn": "# একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এবং একটি আয়তক্ষেত্রের বাহু 'b' এবং 'c' এর ক্ষেত্রফল তুলনা করে।\n# ফাংশনটি তিনটি আর্গুমেন্ট নেয়, যথাক্রমে a, b, এবং c, যা বর্গক্ষেত্রের বাহুর দৈর্ঘ্য এবং আয়তক্ষেত্রের বাহুগুলিকে প্রতিনিধিত্ব করে, এবং এগুলি ধনাত্মক পূর্ণসংখ্যা।\n# এটি একটি স্ট্রিং ফেরত দেয় যা নির্দেশ করে যে কার আকৃতির ক্ষেত্রফল বেশি: \"Alice\" যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, এবং \"Bob\" যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n#\n# উদাহরণ:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "bg": "# Сравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'.\n# Функцията приема три аргумента, a, b и c, които са положителни цели числа, представляващи дължината на страната на квадрата и страните на правоъгълника, съответно.\n# Връща низ, указващ чия форма има по-голяма площ: \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n#\n# Примери:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "zh": "# 比较边长为 'a' 的正方形的面积与边长为 'b' 和 'c' 的矩形的面积。\n# 该函数接受三个参数 a、b 和 c，它们是表示正方形边长和矩形边长的正整数。\n# 它返回一个字符串，指示哪个形状的面积更大：\"Alice\" 如果正方形的面积更大，\"Bob\" 如果矩形的面积更大。\n#\n# 示例:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "fr": "# Compare la surface d'un carré avec une longueur de côté 'a' à la surface d'un rectangle avec des côtés 'b' et 'c'.\n# La fonction prend trois arguments, a, b, et c, qui sont des entiers positifs représentant la longueur du côté du carré et les côtés du rectangle, respectivement.\n# Elle renvoie une chaîne indiquant quelle forme a la plus grande surface : \"Alice\" si la surface du carré est plus grande, et \"Bob\" si la surface du rectangle est plus grande.\n#\n# Exemples :\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "de": "# Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\n# Die Funktion nimmt drei Argumente, a, b und c, die positive ganze Zahlen sind und die Seitenlänge des Quadrats bzw. die Seiten des Rechtecks darstellen.\n# Sie gibt einen String zurück, der angibt, welche Form die größere Fläche hat: \"Alice\", wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n#\n# Beispiele:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "ha": "# Kwatanta yanki na murabba'i tare da tsawon gefe 'a' da yanki na murabba'i mai gefuna 'b' da 'c'.\n# Aikin yana ɗaukar hujjoji guda uku, a, b, da c, waɗanda suke lambobi masu kyau suna wakiltar tsawon gefen murabba'i da gefunan murabba'in, bi da bi.\n# Yana mayar da wani rubutu wanda ke nuna wanda yake da yanki mafi girma: \"Alice\" idan yankin murabba'i ya fi girma, kuma \"Bob\" idan yankin murabba'in ya fi girma.\n#\n# Misalai:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "hi": "# एक वर्ग जिसका भुजा लंबाई 'a' है, उसके क्षेत्रफल की तुलना एक आयत के क्षेत्रफल से करता है जिसकी भुजाएँ 'b' और 'c' हैं।\n# यह फ़ंक्शन तीन तर्क लेता है, a, b, और c, जो क्रमशः वर्ग की भुजा लंबाई और आयत की भुजाओं का प्रतिनिधित्व करने वाले धनात्मक पूर्णांक हैं।\n# यह एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि किस आकृति का क्षेत्रफल बड़ा है: \"Alice\" यदि वर्ग का क्षेत्रफल बड़ा है, और \"Bob\" यदि आयत का क्षेत्रफल बड़ा है।\n#\n# उदाहरण:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "hu": "# Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' és 'c' oldalú téglalap területével.\n# A függvény három argumentumot vesz át: a, b és c, amelyek pozitív egész számok, és a négyzet oldalhosszát, valamint a téglalap oldalait képviselik.\n# Egy karakterláncot ad vissza, amely jelzi, hogy melyik alakzatnak nagyobb a területe: \"Alice\", ha a négyzet területe nagyobb, és \"Bob\", ha a téglalap területe nagyobb.\n#\n# Példák:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)"
    },
    "prompt_bertscore": {
      "sq": "0.9861830720648321",
      "hy": "0.9940027529054136",
      "bn": "0.9764005257988639",
      "bg": "0.9759979020165062",
      "zh": "0.9691427703062301",
      "fr": "0.9829050748866134",
      "de": "0.9864639354236154",
      "ha": "0.9797397011344414",
      "hi": "0.9731636451095194",
      "hu": "0.9852574544892095"
    },
    "canonical_solution": "    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end",
    "instruction": {
      "en": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简明的自然语言描述（文档字符串）。",
      "fr": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nBa da takaitaccen bayani a cikin harshen dabi'a (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def compare_area(a, b, c)\n    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.9202439431030613",
      "bn": "0.8746987912532856",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9379331703165044",
      "ha": "0.8973126615037266",
      "hi": "0.9119288780921788",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless compare_area(5, 4, 6) == \"Alice\"\nraise 'Test failed' unless compare_area(7, 5, 10) == \"Bob\"\nraise 'Test failed' unless compare_area(6, 3, 12) == \"Bob\"\nraise 'Test failed' unless compare_area(10, 10, 1) == \"Alice\"\nraise 'Test failed' unless compare_area(8, 8, 8) == \"Bob\" # Case where areas are equal, but based on the problem statement, Bob wins in a tie.",
    "entry_point": "compare_area",
    "signature": "def compare_area(a, b, c)",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n\n Examples:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "sq": "Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\n Funksioni merr tre argumente, a, b, dhe c, të cilat janë numra të plotë pozitivë që përfaqësojnë gjatësinë e brinjës së katrorit dhe brinjët e drejtkëndëshit, përkatësisht.\n Kthen një varg që tregon se cila formë ka sipërfaqen më të madhe: \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\n Shembuj:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "hy": "Համեմատում է կողմի երկարությունը 'a' ունեցող քառակուսու մակերեսը կողմերի 'b' և 'c' ունեցող ուղղանկյան մակերեսի հետ։ \nՖունկցիան ընդունում է երեք արգումենտ՝ a, b և c, որոնք դրական ամբողջ թվեր են՝ ներկայացնելով համապատասխանաբար քառակուսու կողմի երկարությունը և ուղղանկյան կողմերը։ \nԱյն վերադարձնում է տող, որը ցույց է տալիս, թե ում ձևն ունի ավելի մեծ մակերես՝ \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է։\n\nՕրինակներ:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "bn": "একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফল এবং একটি আয়তক্ষেত্রের বাহু 'b' এবং 'c' এর ক্ষেত্রফলের তুলনা করে। \nফাংশনটি তিনটি আর্গুমেন্ট গ্রহণ করে, যথাক্রমে বর্গক্ষেত্রের বাহুর দৈর্ঘ্য এবং আয়তক্ষেত্রের বাহুগুলি উপস্থাপনকারী ধনাত্মক পূর্ণসংখ্যা a, b, এবং c। \nএটি একটি স্ট্রিং প্রদান করে যা নির্দেশ করে কোন আকৃতির ক্ষেত্রফল বড়: \"Alice\" যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, এবং \"Bob\" যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\nউদাহরণ:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "bg": "Сравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'. \nФункцията приема три аргумента, a, b и c, които са положителни цели числа, представляващи дължината на страната на квадрата и страните на правоъгълника, съответно. \nТя връща низ, указващ чия форма има по-голяма площ: \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n\nПримери:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "zh": "比较边长为 'a' 的正方形与边长为 'b' 和 'c' 的矩形的面积。\n该函数接受三个参数，a、b 和 c，它们是表示正方形边长和矩形边长的正整数。\n它返回一个字符串，指示哪个形状的面积更大：“Alice” 如果正方形的面积更大，“Bob” 如果矩形的面积更大。\n\n示例：\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "fr": "Compare l'aire d'un carré avec une longueur de côté 'a' à l'aire d'un rectangle avec les côtés 'b' et 'c'.\n La fonction prend trois arguments, a, b, et c, qui sont des entiers positifs représentant la longueur du côté du carré et les côtés du rectangle, respectivement.\n Elle retourne une chaîne de caractères indiquant quelle forme a la plus grande aire : \"Alice\" si l'aire du carré est plus grande, et \"Bob\" si l'aire du rectangle est plus grande.\n\n Exemples :\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "de": "Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'. \nDie Funktion nimmt drei Argumente, a, b und c, die positive ganze Zahlen sind und die Seitenlänge des Quadrats bzw. die Seiten des Rechtecks darstellen. \nSie gibt einen String zurück, der angibt, welche Form die größere Fläche hat: \"Alice\", wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n\nBeispiele:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "ha": "Yana kwatanta yankin wani murabba'i tare da tsawon gefe 'a' da yankin wani murabba'in murabba'i tare da gefuna 'b' da 'c'.\n Ayyukan yana ɗaukar hujjoji guda uku, a, b, da c, waɗanda su ne lambobi masu kyau da ke wakiltar tsawon gefen murabba'i da gefuna na murabba'in murabba'i, bi da bi.\n Yana mayar da kirtani wanda ke nuna wanda siffar ke da yanki mafi girma: \"Alice\" idan yankin murabba'i ya fi girma, kuma \"Bob\" idan yankin murabba'in murabba'i ya fi girma.\n\n Misalai:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "hi": "वर्ग के क्षेत्रफल की तुलना भुजा लंबाई 'a' के साथ आयत के क्षेत्रफल से करें जिसकी भुजाएँ 'b' और 'c' हैं। \nयह फ़ंक्शन तीन तर्क लेता है, a, b, और c, जो क्रमशः वर्ग की भुजा लंबाई और आयत की भुजाओं का प्रतिनिधित्व करने वाले धनात्मक पूर्णांक हैं। \nयह एक स्ट्रिंग लौटाता है जो यह इंगित करता है कि किस आकृति का क्षेत्रफल बड़ा है: \"Alice\" यदि वर्ग का क्षेत्रफल बड़ा है, और \"Bob\" यदि आयत का क्षेत्रफल बड़ा है।\n\nउदाहरण:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "hu": "Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' és 'c' oldalú téglalap területével.\n A függvény három argumentumot vesz fel, a, b és c, amelyek pozitív egész számok, és a négyzet oldalhosszát, valamint a téglalap oldalait képviselik.\n Egy olyan karakterláncot ad vissza, amely jelzi, hogy melyik alakzatnak nagyobb a területe: \"Alice\", ha a négyzet területe nagyobb, és \"Bob\", ha a téglalap területe nagyobb.\n\n Példák:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\""
    },
    "docstring_bertscore": {
      "sq": "0.9840982475854899",
      "hy": "0.9951309734696918",
      "bn": "0.9721146780672741",
      "bg": "0.9745864345288723",
      "zh": "0.9546707593744092",
      "fr": "0.9711457590685859",
      "de": "0.9853335299251459",
      "ha": "0.9854103998826065",
      "hi": "0.9872515048844188",
      "hu": "0.986876887985787"
    }
  },
  {
    "task_id": "Ruby/45",
    "prompt": {
      "en": "# Finds M positive integers whose sum is N, such that their product is maximized.\n# The function returns an array of these integers in lexicographically smallest order.\n#\n# Args:\n#   n: A positive integer representing the sum of the integers to find.\n#   m: A positive integer representing the number of integers to find.\n#\n# Returns:\n#   An array of integers that are the lexicographically smallest set of integers\n#   whose sum is N and whose product is maximized.\n#\n# Examples:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "sq": "# Gjen M numra të plotë pozitivë, shuma e të cilëve është N, të tillë që prodhimi i tyre të jetë maksimal.\n# Funksioni kthen një varg të këtyre numrave në rendin më të vogël leksikografik.\n#\n# Argumentet:\n#   n: Një numër i plotë pozitiv që përfaqëson shumën e numrave për të gjetur.\n#   m: Një numër i plotë pozitiv që përfaqëson numrin e numrave për të gjetur.\n#\n# Kthen:\n#   Një varg numrash që janë grupi më i vogël leksikografik i numrave\n#   shuma e të cilëve është N dhe prodhimi i të cilëve është maksimal.\n#\n# Shembuj:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "hy": "# Գտնում է M դրական ամբողջ թվեր, որոնց գումարը N է, այնպես, որ նրանց արտադրյալը առավելագույն լինի։\n# Ֆունկցիան վերադարձնում է այս ամբողջ թվերի զանգվածը, որը լեքսիկոգրաֆիկորեն ամենափոքր հերթականությամբ է։\n#\n# Արգումենտներ:\n#   n: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու համար ամբողջ թվերի գումարը։\n#   m: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու համար ամբողջ թվերի քանակը։\n#\n# Վերադարձնում է:\n#   Ամբողջ թվերի զանգված, որը լեքսիկոգրաֆիկորեն ամենափոքր ամբողջ թվերի հավաքածուն է,\n#   որոնց գումարը N է և արտադրյալը առավելագույն է։\n#\n# Օրինակներ:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "bn": "# এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N, যাতে তাদের গুণফল সর্বাধিক হয়।\n# ফাংশনটি এই পূর্ণসংখ্যাগুলির একটি অ্যারে ফেরত দেয় যা বর্ণানুক্রমিকভাবে সবচেয়ে ছোট ক্রমে থাকে।\n#\n# আর্গুমেন্টসমূহ:\n#   n: একটি ধনাত্মক পূর্ণসংখ্যা যা খুঁজে বের করার পূর্ণসংখ্যাগুলির যোগফল নির্দেশ করে।\n#   m: একটি ধনাত্মক পূর্ণসংখ্যা যা খুঁজে বের করার পূর্ণসংখ্যাগুলির সংখ্যা নির্দেশ করে।\n#\n# রিটার্নস:\n#   একটি পূর্ণসংখ্যার অ্যারে যা বর্ণানুক্রমিকভাবে সবচেয়ে ছোট সেটের পূর্ণসংখ্যাগুলি\n#   যার যোগফল N এবং যার গুণফল সর্বাধিক।\n#\n# উদাহরণসমূহ:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "bg": "# Намира M положителни цели числа, чиято сума е N, така че техният произведение да е максимално.\n# Функцията връща масив от тези цели числа в лексикографски най-малък ред.\n#\n# Аргументи:\n#   n: Положително цяло число, представляващо сумата на числата, които трябва да се намерят.\n#   m: Положително цяло число, представляващо броя на числата, които трябва да се намерят.\n#\n# Връща:\n#   Масив от цели числа, които са лексикографски най-малкото множество от числа,\n#   чиято сума е N и чието произведение е максимално.\n#\n# Примери:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "zh": "# 找到 M 个正整数，其和为 N，使它们的乘积最大化。\n# 该函数返回这些整数的数组，按字典序最小的顺序排列。\n#\n# 参数：\n#   n: 一个正整数，表示要找到的整数的和。\n#   m: 一个正整数，表示要找到的整数的数量。\n#\n# 返回：\n#   一个整数数组，它是字典序最小的整数集合，其和为 N，且乘积最大化。\n#\n# 示例：\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "fr": "# Trouve M entiers positifs dont la somme est N, de sorte que leur produit soit maximisé.\n# La fonction renvoie un tableau de ces entiers dans l'ordre lexicographiquement le plus petit.\n#\n# Args:\n#   n: Un entier positif représentant la somme des entiers à trouver.\n#   m: Un entier positif représentant le nombre d'entiers à trouver.\n#\n# Returns:\n#   Un tableau d'entiers qui est l'ensemble lexicographiquement le plus petit d'entiers\n#   dont la somme est N et dont le produit est maximisé.\n#\n# Exemples:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "de": "# Findet M positive ganze Zahlen, deren Summe N ist, so dass ihr Produkt maximiert wird.\n# Die Funktion gibt ein Array dieser Zahlen in lexikographisch kleinster Reihenfolge zurück.\n#\n# Argumente:\n#   n: Eine positive ganze Zahl, die die Summe der zu findenden Zahlen darstellt.\n#   m: Eine positive ganze Zahl, die die Anzahl der zu findenden Zahlen darstellt.\n#\n# Rückgabewerte:\n#   Ein Array von ganzen Zahlen, das die lexikographisch kleinste Menge von Zahlen ist,\n#   deren Summe N ist und deren Produkt maximiert wird.\n#\n# Beispiele:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "ha": "# Nemi lambobi M masu kyau waɗanda jimlarsu ita ce N, ta yadda samfurinsu ya fi girma.\n# Aikin yana mayar da wani tsari na waɗannan lambobin a cikin mafi ƙarancin tsari na lexicographically.\n#\n# Args:\n#   n: Wani lamba mai kyau wanda ke wakiltar jimlar lambobin da za a nema.\n#   m: Wani lamba mai kyau wanda ke wakiltar adadin lambobin da za a nema.\n#\n# Returns:\n#   Wani tsari na lambobi waɗanda su ne mafi ƙarancin tsari na lexicographically na lambobin\n#   waɗanda jimlarsu ita ce N kuma samfurinsu ya fi girma.\n#\n# Misalai:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "hi": "# M धनात्मक पूर्णांक ढूंढता है जिनका योग N है, ताकि उनका गुणनफल अधिकतम हो।\n# फ़ंक्शन इन पूर्णांकों को शब्दकोशानुक्रम में सबसे छोटे क्रम में लौटाता है।\n#\n# तर्क:\n#   n: एक धनात्मक पूर्णांक जो ढूंढे जाने वाले पूर्णांकों के योग का प्रतिनिधित्व करता है।\n#   m: एक धनात्मक पूर्णांक जो ढूंढे जाने वाले पूर्णांकों की संख्या का प्रतिनिधित्व करता है।\n#\n# वापसी:\n#   पूर्णांकों की एक श्रृंखला जो शब्दकोशानुक्रम में सबसे छोटे सेट का प्रतिनिधित्व करती है\n#   जिनका योग N है और जिनका गुणनफल अधिकतम है।\n#\n# उदाहरण:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "hu": "# Megkeresi azt az M darab pozitív egész számot, amelyek összege N, úgy, hogy a szorzatuk maximális legyen.\n# A függvény visszaadja ezeknek a számoknak a tömbjét lexikografikusan a legkisebb sorrendben.\n#\n# Argumentumok:\n#   n: Egy pozitív egész szám, amely az összeget jelöli, amit meg kell találni.\n#   m: Egy pozitív egész szám, amely a megtalálandó számok számát jelöli.\n#\n# Visszatér:\n#   Egy egész számokat tartalmazó tömb, amely a lexikografikusan legkisebb számhalmaz,\n#   amelynek összege N és szorzata maximális.\n#\n# Példák:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)"
    },
    "prompt_bertscore": {
      "sq": "0.9538927241718955",
      "hy": "0.9759939294088855",
      "bn": "0.9550100200652167",
      "bg": "0.9703595800204499",
      "zh": "0.9686543381992654",
      "fr": "0.9931724779126878",
      "de": "0.9656764715267903",
      "ha": "0.9112318840851275",
      "hi": "0.9364420520460754",
      "hu": "0.9627150911759411"
    },
    "canonical_solution": "    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end",
    "instruction": {
      "en": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език (docstring) на български, като използвате не повече от 500 знака.",
      "zh": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\n请用不超过500个字符的中文为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def max_product_partition(n, m)\n    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8888019455675248",
      "bn": "0.8879772322254679",
      "bg": "0.8991035130191372",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9215894653041917",
      "hi": "0.9119288780921788",
      "hu": "0.9410598111443745"
    },
    "level": "",
    "test": "raise 'Test failed' unless max_product_partition(6, 3) == [2, 2, 2]\nraise 'Test failed' unless max_product_partition(8, 3) == [2, 3, 3]\nraise 'Test failed' unless max_product_partition(10, 2) == [5, 5]\nraise 'Test failed' unless max_product_partition(7, 3) == [2, 2, 3]\nraise 'Test failed' unless max_product_partition(20, 5) == [4, 4, 4, 4, 4]",
    "entry_point": "max_product_partition",
    "signature": "def max_product_partition(n, m)",
    "docstring": {
      "en": "Finds M positive integers whose sum is N, such that their product is maximized.\n The function returns an array of these integers in lexicographically smallest order.\n\n Args:\n   n: A positive integer representing the sum of the integers to find.\n   m: A positive integer representing the number of integers to find.\n\n Returns:\n   An array of integers that are the lexicographically smallest set of integers\n   whose sum is N and whose product is maximized.\n\n Examples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "sq": "Gjen M numra të plotë pozitivë, shuma e të cilëve është N, në mënyrë që prodhimi i tyre të jetë maksimal.\n Funksioni kthen një varg të këtyre numrave në rendin më të vogël leksikografik.\n\n Args:\n   n: Një numër i plotë pozitiv që përfaqëson shumën e numrave për të gjetur.\n   m: Një numër i plotë pozitiv që përfaqëson numrin e numrave për të gjetur.\n\n Returns:\n   Një varg numrash që janë grupi më i vogël leksikografik i numrave\n   shuma e të cilëve është N dhe prodhimi i të cilëve është maksimal.\n\n Examples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hy": "Գտնում է M դրական ամբողջ թվեր, որոնց գումարը N է, այնպես, որ նրանց արտադրյալը առավելագույն լինի։\nՖունկցիան վերադարձնում է այս թվերի զանգվածը լեքսիկոգրաֆիկորեն ամենափոքր կարգով։\n\nԱրգումենտներ:\n  n: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու թվերի գումարը։\n  m: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու թվերի քանակը։\n\nՎերադարձնում է:\n  Ամբողջ թվերի զանգված, որը լեքսիկոգրաֆիկորեն ամենափոքր թվերի հավաքածուն է,\n  որոնց գումարը N է և որոնց արտադրյալը առավելագույն է։\n\nՕրինակներ:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "bn": "Mটি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N, যাতে তাদের গুণফল সর্বাধিক হয়। ফাংশনটি এই পূর্ণসংখ্যাগুলির একটি অ্যারে ফেরত দেয় যা বর্ণানুক্রমিকভাবে ক্ষুদ্রতম ক্রমে থাকে।\n\nArgs:\n   n: একটি ধনাত্মক পূর্ণসংখ্যা যা খুঁজে বের করার পূর্ণসংখ্যাগুলির যোগফলকে উপস্থাপন করে।\n   m: একটি ধনাত্মক পূর্ণসংখ্যা যা খুঁজে বের করার পূর্ণসংখ্যাগুলির সংখ্যাকে উপস্থাপন করে।\n\nReturns:\n   একটি পূর্ণসংখ্যার অ্যারে যা বর্ণানুক্রমিকভাবে ক্ষুদ্রতম পূর্ণসংখ্যার সেট যাদের যোগফল N এবং যাদের গুণফল সর্বাধিক।\n\nExamples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "bg": "Намира M положителни цели числа, чиято сума е N, така че техният произведение да е максимално. Функцията връща масив от тези числа в лексикографски най-малък ред.\n\nArgs:\n  n: Положително цяло число, представляващо сумата на числата, които трябва да се намерят.\n  m: Положително цяло число, представляващо броя на числата, които трябва да се намерят.\n\nReturns:\n  Масив от цели числа, които са лексикографски най-малкото множество от числа, чиято сума е N и чието произведение е максимално.\n\nExamples:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "zh": "找到 M 个正整数，其和为 N，使其乘积最大化。该函数返回这些整数的数组，以字典序最小的顺序排列。\n\n参数：\n  n: 一个正整数，表示要找到的整数的和。\n  m: 一个正整数，表示要找到的整数的数量。\n\n返回：\n  一个整数数组，它是字典序最小的整数集合，其和为 N，且乘积最大化。\n\n示例：\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "fr": "Trouve M entiers positifs dont la somme est N, de sorte que leur produit soit maximisé.\nLa fonction renvoie un tableau de ces entiers dans l'ordre lexicographiquement le plus petit.\n\nArgs:\n  n: Un entier positif représentant la somme des entiers à trouver.\n  m: Un entier positif représentant le nombre d'entiers à trouver.\n\nReturns:\n  Un tableau d'entiers qui est l'ensemble d'entiers le plus petit lexicographiquement\n  dont la somme est N et dont le produit est maximisé.\n\nExamples:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "de": "Findet M positive ganze Zahlen, deren Summe N ist, sodass ihr Produkt maximiert wird. Die Funktion gibt ein Array dieser ganzen Zahlen in lexikografisch kleinster Reihenfolge zurück.\n\nArgs:\n   n: Eine positive ganze Zahl, die die Summe der zu findenden ganzen Zahlen darstellt.\n   m: Eine positive ganze Zahl, die die Anzahl der zu findenden ganzen Zahlen darstellt.\n\nReturns:\n   Ein Array von ganzen Zahlen, das die lexikografisch kleinste Menge von ganzen Zahlen ist, deren Summe N ist und deren Produkt maximiert wird.\n\nExamples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "ha": "Nemi lambobi masu kyau M waɗanda jimlarsu ita ce N, ta yadda samfurin su ya fi girma.\n Aiki yana dawowa da jerin waɗannan lambobi a cikin mafi ƙarancin tsari na haruffa.\n\n Args:\n   n: Lamba mai kyau wadda ke wakiltar jimlar lambobin da za a nema.\n   m: Lamba mai kyau wadda ke wakiltar adadin lambobin da za a nema.\n\n Returns:\n   Jerin lambobi waɗanda su ne mafi ƙarancin saiti na lambobi\n   waɗanda jimlarsu ita ce N kuma samfurin su ya fi girma.\n\n Misalai:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hi": "M धनात्मक पूर्णांक खोजता है जिनका योग N है, ताकि उनका गुणनफल अधिकतम हो। \nयह फ़ंक्शन इन पूर्णांकों की एक सरणी लौटाता है जो शब्दकोशानुसार सबसे छोटे क्रम में होते हैं।\n\nआर्ग्स:\n   n: एक धनात्मक पूर्णांक जो खोजे जाने वाले पूर्णांकों के योग का प्रतिनिधित्व करता है।\n   m: एक धनात्मक पूर्णांक जो खोजे जाने वाले पूर्णांकों की संख्या का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\n   पूर्णांकों की एक सरणी जो शब्दकोशानुसार सबसे छोटे सेट के पूर्णांक हैं\n   जिनका योग N है और जिनका गुणनफल अधिकतम है।\n\nउदाहरण:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hu": "Megtalálja azt az M pozitív egész számot, amelyek összege N, úgy, hogy a szorzatuk maximális legyen. A függvény visszaad egy tömböt ezekkel az egész számokkal lexikografikusan a legkisebb sorrendben.\n\nArgs:\n   n: Egy pozitív egész szám, amely az egész számok összegét jelenti, amelyeket meg kell találni.\n   m: Egy pozitív egész szám, amely az egész számok számát jelenti, amelyeket meg kell találni.\n\nReturns:\n   Egy egész számokból álló tömb, amely a lexikografikusan legkisebb egész számok halmaza, amelyek összege N és szorzatuk maximális.\n\nExamples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.9545070879404365",
      "hy": "0.9623029331352937",
      "bn": "0.9618286037853825",
      "bg": "0.9709705670725132",
      "zh": "0.9626729815351618",
      "fr": "0.9900414672164348",
      "de": "0.9696325928258621",
      "ha": "0.9446750827095906",
      "hi": "0.927967884099984",
      "hu": "0.9537320321936383"
    }
  },
  {
    "task_id": "Ruby/46",
    "prompt": {
      "en": "# Counts the number of characters in a given title, excluding spaces and newline characters.\n# The function takes a single argument, title, which is a string representing the title of an essay.\n# It returns the count of characters in the title, excluding any spaces and newline characters.\n#\n# Examples:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "sq": "# Numëron numrin e karaktereve në një titull të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtit të ri.\n# Funksioni merr një argument të vetëm, title, i cili është një varg që përfaqëson titullin e një eseje.\n# Kthen numrin e karaktereve në titull, duke përjashtuar çdo hapësirë dhe karakter të rreshtit të ri.\n#\n# Shembuj:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "hy": "# Հաշվում է տրված վերնագրի սիմվոլների քանակը՝ բացի բացատներից և նոր տողի սիմվոլներից։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ title, որը տողի տիպի է և ներկայացնում է շարադրանքի վերնագիրը։\n# Այն վերադարձնում է սիմվոլների քանակը վերնագրում՝ բացի բացատներից և նոր տողի սիմվոլներից։\n#\n# Օրինակներ:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "bn": "# প্রদত্ত শিরোনামে কতগুলি অক্ষর আছে তা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n# ফাংশনটি একটি একক আর্গুমেন্ট নেয়, title, যা একটি প্রবন্ধের শিরোনামকে প্রতিনিধিত্বকারী একটি স্ট্রিং।\n# এটি শিরোনামে অক্ষরের সংখ্যা ফেরত দেয়, যেকোনো ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n#\n# উদাহরণ:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "bg": "# Брои броя на символите в дадено заглавие, изключвайки интервалите и знаците за нов ред.\n# Функцията приема един аргумент, title, който е низ, представляващ заглавието на есе.\n# Връща броя на символите в заглавието, изключвайки всички интервали и знаци за нов ред.\n#\n# Примери:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "zh": "# 计算给定标题中的字符数量，不包括空格和换行符。\n# 该函数接受一个参数，title，它是一个表示文章标题的字符串。\n# 它返回标题中的字符数量，不包括任何空格和换行符。\n#\n# 示例:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "fr": "# Compte le nombre de caractères dans un titre donné, en excluant les espaces et les caractères de nouvelle ligne.\n# La fonction prend un seul argument, title, qui est une chaîne représentant le titre d'un essai.\n# Elle renvoie le compte des caractères dans le titre, en excluant les espaces et les caractères de nouvelle ligne.\n#\n# Exemples :\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "de": "# Zählt die Anzahl der Zeichen in einem gegebenen Titel, ohne Leerzeichen und Zeilenumbrüche.\n# Die Funktion nimmt ein einzelnes Argument, title, das ein String ist, der den Titel eines Aufsatzes darstellt.\n# Sie gibt die Anzahl der Zeichen im Titel zurück, ohne Leerzeichen und Zeilenumbrüche.\n#\n# Beispiele:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "ha": "# Yana ƙirga adadin haruffa a cikin take da aka bayar, banda sarari da haruffan sabon layi.\n# Aiki yana ɗaukar hujja guda ɗaya, title, wanda yake wakiltar take na rubutu.\n# Yana mayar da ƙididdigar haruffa a cikin take, banda duk wani sarari da haruffan sabon layi.\n#\n# Misalai:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "hi": "# दिए गए शीर्षक में वर्णों की संख्या गिनता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते।\n# यह फ़ंक्शन एकल तर्क लेता है, title, जो निबंध के शीर्षक का प्रतिनिधित्व करने वाली एक स्ट्रिंग है।\n# यह शीर्षक में वर्णों की गिनती लौटाता है, जिसमें कोई भी रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते।\n#\n# उदाहरण:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "hu": "# Megszámolja a karakterek számát egy adott címben, kihagyva a szóközöket és az új sor karaktereket.\n# A függvény egyetlen argumentumot vesz fel, a title-t, amely egy esszé címét reprezentáló string.\n# Visszaadja a karakterek számát a címben, kihagyva a szóközöket és az új sor karaktereket.\n#\n# Példák:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)"
    },
    "prompt_bertscore": {
      "sq": "0.9918108666506936",
      "hy": "0.976520101288247",
      "bn": "0.9854211259231823",
      "bg": "0.9852910230236045",
      "zh": "0.9656073481541901",
      "fr": "0.9965352902636084",
      "de": "0.9713878895030674",
      "ha": "0.9797067284911896",
      "hi": "0.9942125065877865",
      "hu": "0.9868528537096818"
    },
    "canonical_solution": "    title.count(\"^ \\n\")\n  end",
    "instruction": {
      "en": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nՏվեք համառոտ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\n请用不超过500个字符的中文为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nरूबी कोड का संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में अधिकतम 500 वर्णों का उपयोग करके प्रदान करें।",
      "hu": "def count_chars_in_title(title)\n    title.count(\"^ \\n\")\n  end\n\nAdj meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.8913444144447713",
      "bn": "0.8746987912532856",
      "bg": "0.8394899671718035",
      "zh": "0.8551313151567768",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9171840420832189",
      "hi": "0.9688954754818417",
      "hu": "0.953143490374632"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_chars_in_title(\"234\") == 3\nraise 'Test failed' unless count_chars_in_title(\"Ca 45\") == 4\nraise 'Test failed' unless count_chars_in_title(\"Hello World\\n\") == 10\nraise 'Test failed' unless count_chars_in_title(\"Ruby Programming 101 \") == 18\nraise 'Test failed' unless count_chars_in_title(\"\\nNew Line\\n\") == 7",
    "entry_point": "count_chars_in_title",
    "signature": "def count_chars_in_title(title)",
    "docstring": {
      "en": "Counts the number of characters in a given title, excluding spaces and newline characters.\n The function takes a single argument, title, which is a string representing the title of an essay.\n It returns the count of characters in the title, excluding any spaces and newline characters.\n\n Examples:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "sq": "Numëron numrin e karaktereve në një titull të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj. \nFunksioni merr një argument të vetëm, title, i cili është një varg që përfaqëson titullin e një eseje. \nAi kthen numrin e karaktereve në titull, duke përjashtuar çdo hapësirë dhe karakter të rreshtave të rinj.\n\nShembuj:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "hy": "Հաշվում է տրված վերնագրի մեջ գտնվող սիմվոլների քանակը՝ բացառելով բացատները և նոր տողի սիմվոլները։\nՖունկցիան ընդունում է մեկ արգումենտ՝ title, որը տող է, որը ներկայացնում է շարադրանքի վերնագիրը։ \nԱյն վերադարձնում է վերնագրի սիմվոլների քանակը՝ բացառելով ցանկացած բացատ և նոր տողի սիմվոլ։\n\nՕրինակներ:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "bn": "প্রদত্ত শিরোনামে অক্ষরের সংখ্যা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\nএই ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, title, যা একটি প্রবন্ধের শিরোনামকে প্রতিনিধিত্বকারী একটি স্ট্রিং।\nএটি শিরোনামে অক্ষরের সংখ্যা ফেরত দেয়, যেকোনো ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\nউদাহরণসমূহ:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "bg": "Брои броя на символите в дадено заглавие, изключвайки интервалите и символите за нов ред.\n Функцията приема един аргумент, title, който е низ, представляващ заглавието на есе.\n Връща броя на символите в заглавието, изключвайки всички интервали и символи за нов ред.\n\n Примери:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "zh": "计算给定标题中的字符数量，不包括空格和换行符。\n该函数接受一个参数，title，这是一个表示文章标题的字符串。\n它返回标题中字符的数量，不包括任何空格和换行符。\n\n示例：\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "fr": "Compte le nombre de caractères dans un titre donné, en excluant les espaces et les caractères de nouvelle ligne.\n La fonction prend un seul argument, title, qui est une chaîne de caractères représentant le titre d'un essai.\n Elle renvoie le nombre de caractères dans le titre, en excluant les espaces et les caractères de nouvelle ligne.\n\n Exemples :\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "de": "Zählt die Anzahl der Zeichen in einem gegebenen Titel, ohne Leerzeichen und Zeilenumbrüche.\n Die Funktion nimmt ein einziges Argument, title, das ein String ist, der den Titel eines Aufsatzes darstellt.\n Sie gibt die Anzahl der Zeichen im Titel zurück, ohne Leerzeichen und Zeilenumbrüche.\n\n Beispiele:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "ha": "Yana ƙididdige adadin haruffa a cikin take da aka bayar, ban da sarari da haruffan sabon layi.\nAikin yana ɗaukar hujja guda ɗaya, title, wanda shine kirtani da ke wakiltar taken wani rubutu.\nYana dawowa da ƙididdigar haruffa a cikin taken, ban da duk wani sarari da haruffan sabon layi.\n\nExamples:\nMisalai:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "hi": "दिए गए शीर्षक में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं। \nयह फ़ंक्शन एकल तर्क लेता है, title, जो एक निबंध के शीर्षक का प्रतिनिधित्व करने वाली एक स्ट्रिंग है। \nयह शीर्षक में वर्णों की गणना लौटाता है, जिसमें कोई भी रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\nउदाहरण:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "hu": "Számolja meg a karakterek számát egy adott címben, kihagyva a szóközöket és az új sor karaktereket.\n A függvény egyetlen argumentumot vesz fel, a title-t, amely egy sztring, és egy esszé címét jelenti.\n Visszaadja a karakterek számát a címben, kihagyva a szóközöket és az új sor karaktereket.\n\n Példák:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10"
    },
    "docstring_bertscore": {
      "sq": "0.996566872494193",
      "hy": "0.9610622877753499",
      "bn": "1",
      "bg": "0.9783761035686369",
      "zh": "0.9553802670954659",
      "fr": "0.985817592163728",
      "de": "0.9635839004625878",
      "ha": "0.9630182011374003",
      "hi": "0.9939165473200445",
      "hu": "0.9851231803516299"
    }
  },
  {
    "task_id": "Ruby/47",
    "prompt": {
      "en": "# Counts the number of students who have enrolled in both courses A and B.\n# This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n# a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n# The function returns the count of students who have enrolled in both courses.\n#\n# Example:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "sq": "# Numëron numrin e studentëve që janë regjistruar në të dyja kurset A dhe B.\n# Kjo funksion merr katër argumente: n dhe m janë numri i studentëve të regjistruar në kurset A dhe B, përkatësisht.\n# a_n është një varg i ID-ve të studentëve të regjistruar në kursin A, dhe b_m është një varg i ID-ve të studentëve të regjistruar në kursin B.\n# Funksioni kthen numrin e studentëve që janë regjistruar në të dyja kurset.\n#\n# Shembull:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "hy": "# Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ A, և՛ B դասընթացներում։\n# Այս ֆունկցիան ընդունում է չորս արգումենտ՝ n և m-ը ուսանողների քանակն են, ովքեր գրանցվել են համապատասխանաբար A և B դասընթացներում։\n# a_n-ը ուսանողների ID-ների զանգված է, ովքեր գրանցվել են A դասընթացում, իսկ b_m-ը ուսանողների ID-ների զանգված է, ովքեր գրանցվել են B դասընթացում։\n# Ֆունկցիան վերադարձնում է այն ուսանողների քանակը, ովքեր գրանցվել են երկու դասընթացներում։\n#\n# Օրինակ:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "bn": "# কতজন শিক্ষার্থী উভয় কোর্স A এবং B-তে ভর্তি হয়েছে তা গণনা করে।\n# এই ফাংশনটি চারটি আর্গুমেন্ট নেয়: n এবং m যথাক্রমে কোর্স A এবং B-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n# a_n একটি অ্যারে যা কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি ধারণ করে, এবং b_m একটি অ্যারে যা কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি ধারণ করে।\n# ফাংশনটি সেই শিক্ষার্থীদের সংখ্যা ফেরত দেয় যারা উভয় কোর্সে ভর্তি হয়েছে।\n#\n# উদাহরণ:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "bg": "# Брои броя на студентите, които са записани и в двата курса A и B.\n# Тази функция приема четири аргумента: n и m са броят на студентите, записани в курсовете A и B, съответно.\n# a_n е масив от студентски идентификационни номера, записани в курс A, а b_m е масив от студентски идентификационни номера, записани в курс B.\n# Функцията връща броя на студентите, които са записани и в двата курса.\n#\n# Пример:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "zh": "# 计算同时注册了课程A和课程B的学生人数。\n# 此函数接受四个参数：n和m分别是注册课程A和课程B的学生人数。\n# a_n是注册课程A的学生ID数组，b_m是注册课程B的学生ID数组。\n# 函数返回同时注册了两个课程的学生人数。\n#\n# 示例:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "fr": "# Compte le nombre d'étudiants qui se sont inscrits dans les deux cours A et B.\n# Cette fonction prend quatre arguments : n et m sont le nombre d'étudiants inscrits dans les cours A et B, respectivement.\n# a_n est un tableau d'identifiants d'étudiants inscrits dans le cours A, et b_m est un tableau d'identifiants d'étudiants inscrits dans le cours B.\n# La fonction renvoie le nombre d'étudiants qui se sont inscrits dans les deux cours.\n#\n# Exemple :\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "de": "# Zählt die Anzahl der Studenten, die sich in beide Kurse A und B eingeschrieben haben.\n# Diese Funktion nimmt vier Argumente: n und m sind die Anzahl der Studenten, die sich in die Kurse A bzw. B eingeschrieben haben.\n# a_n ist ein Array von Studenten-IDs, die sich in Kurs A eingeschrieben haben, und b_m ist ein Array von Studenten-IDs, die sich in Kurs B eingeschrieben haben.\n# Die Funktion gibt die Anzahl der Studenten zurück, die sich in beide Kurse eingeschrieben haben.\n#\n# Beispiel:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "ha": "# Yana ƙididdige yawan ɗaliban da suka yi rajista a duka darussan A da B.\n# Wannan aikin yana ɗaukar huɗu hujjoji: n da m su ne yawan ɗaliban da suka yi rajista a darussan A da B, bi da bi.\n# a_n tsari ne na ID ɗin ɗalibai da suka yi rajista a darasi A, kuma b_m tsari ne na ID ɗin ɗalibai da suka yi rajista a darasi B.\n# Aikin yana mayar da ƙididdigar ɗaliban da suka yi rajista a duka darussan.\n#\n# Misali:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "hi": "# गिनती करता है उन छात्रों की संख्या जो दोनों पाठ्यक्रम A और B में नामांकित हैं।\n# यह फ़ंक्शन चार तर्क लेता है: n और m क्रमशः पाठ्यक्रम A और B में नामांकित छात्रों की संख्या हैं।\n# a_n एक array है जिसमें पाठ्यक्रम A में नामांकित छात्र IDs हैं, और b_m एक array है जिसमें पाठ्यक्रम B में नामांकित छात्र IDs हैं।\n# फ़ंक्शन उन छात्रों की गिनती लौटाता है जो दोनों पाठ्यक्रमों में नामांकित हैं।\n#\n# उदाहरण:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "hu": "# Megszámolja azon diákok számát, akik mindkét A és B kurzusra beiratkoztak.\n# Ez a függvény négy argumentumot vesz át: n és m az A és B kurzusokra beiratkozott diákok száma.\n# a_n egy tömb az A kurzusra beiratkozott diákok azonosítóival, és b_m egy tömb a B kurzusra beiratkozott diákok azonosítóival.\n# A függvény visszaadja azon diákok számát, akik mindkét kurzusra beiratkoztak.\n#\n# Példa:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)"
    },
    "prompt_bertscore": {
      "sq": "0.9953973368106596",
      "hy": "0.9871057101847392",
      "bn": "0.9705746967231106",
      "bg": "0.9953973368106596",
      "zh": "0.9641585381549217",
      "fr": "0.9979769495691596",
      "de": "0.9789132001189552",
      "ha": "0.9541948409814496",
      "hi": "0.9849722212620434",
      "hu": "0.9734373577745854"
    },
    "canonical_solution": "    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end",
    "instruction": {
      "en": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nJepni një përshkrim të shkurtër në gjuhë natyrale (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nՏվեք կարճ բնութագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nДайте кратко описание на Ruby кода на естествен език на български, като използвате не повече от 500 знака.",
      "zh": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\n请为以下 Ruby 代码提供一个简洁的自然语言描述（文档字符串），使用中文且不超过500个字符。",
      "fr": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nGeben Sie eine prägnante Beschreibung (Docstring) des Ruby-Codes in deutscher Sprache mit maximal 500 Zeichen.",
      "ha": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nBa da takaitaccen bayanin harshen halitta (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 kacal.",
      "hi": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def count_common_students(n, m, a_n, b_m)\n    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9550807324808652",
      "hy": "0.8535025460322906",
      "bn": "0.9054402194349122",
      "bg": "0.8394899671718035",
      "zh": "0.8721255346669786",
      "fr": "0.9691999758559682",
      "de": "0.9239160229572533",
      "ha": "0.9215894653041917",
      "hi": "0.9119288780921788",
      "hu": "0.9410598111443745"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6]) == 4\nraise 'Test failed' unless count_common_students(3, 2, [1, 2, 3], [2, 4]) == 1\nraise 'Test failed' unless count_common_students(4, 4, [7, 8, 9, 10], [10, 11, 12, 13]) == 1\nraise 'Test failed' unless count_common_students(2, 3, [14, 15], [15, 16, 17]) == 1\nraise 'Test failed' unless count_common_students(6, 5, [18, 19, 20, 21, 22, 23], [20, 21, 24, 25, 26]) == 2",
    "entry_point": "count_common_students",
    "signature": "def count_common_students(n, m, a_n, b_m)",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both courses A and B.\n This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n The function returns the count of students who have enrolled in both courses.\n\n Example:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "sq": "Numëron numrin e studentëve që janë regjistruar në të dy kurset A dhe B. Kjo funksion merr katër argumente: n dhe m janë numri i studentëve të regjistruar në kurset A dhe B, përkatësisht. a_n është një varg i ID-ve të studentëve të regjistruar në kursin A, dhe b_m është një varg i ID-ve të studentëve të regjistruar në kursin B. Funksioni kthen numrin e studentëve që janë regjistruar në të dy kurset.\n\nShembull:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "hy": "Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են ինչպես A, այնպես էլ B դասընթացներում:\n Այս ֆունկցիան ընդունում է չորս արգումենտ՝ n և m-ը համապատասխանաբար A և B դասընթացներում գրանցված ուսանողների քանակն են:\n a_n-ը A դասընթացում գրանցված ուսանողների ID-ների զանգված է, իսկ b_m-ը՝ B դասընթացում գրանցված ուսանողների ID-ների զանգված:\n Ֆունկցիան վերադարձնում է այն ուսանողների քանակը, ովքեր գրանցվել են երկու դասընթացներում:\n\n Օրինակ:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "bn": "কোর্স A এবং B উভয়টিতে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা গণনা করে।\nএই ফাংশনটি চারটি আর্গুমেন্ট নেয়: n এবং m যথাক্রমে কোর্স A এবং B-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।  \na_n হল কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডির একটি অ্যারে, এবং b_m হল কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডির একটি অ্যারে।  \nফাংশনটি উভয় কোর্সে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা প্রদান করে।\n\nউদাহরণ:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "bg": "Брои броя на студентите, които са записани и в двата курса A и B. \nТази функция приема четири аргумента: n и m са броят на студентите, записани в курсовете A и B, съответно. \na_n е масив от студентски идентификатори, записани в курс A, а b_m е масив от студентски идентификатори, записани в курс B. \nФункцията връща броя на студентите, които са записани и в двата курса.\n\nПример:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "zh": "计算同时注册了课程A和课程B的学生人数。\n此函数接受四个参数：n和m分别是注册课程A和课程B的学生人数。  \na_n是注册课程A的学生ID数组，b_m是注册课程B的学生ID数组。  \n该函数返回同时注册了两个课程的学生人数。\n\n示例：\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "fr": "Compte le nombre d'étudiants qui se sont inscrits aux deux cours A et B.\n Cette fonction prend quatre arguments : n et m sont le nombre d'étudiants inscrits aux cours A et B, respectivement.\n a_n est un tableau d'ID d'étudiants inscrits au cours A, et b_m est un tableau d'ID d'étudiants inscrits au cours B.\n La fonction renvoie le nombre d'étudiants qui se sont inscrits aux deux cours.\n\n Exemple:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "de": "Zählt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n Diese Funktion nimmt vier Argumente entgegen: n und m sind die Anzahl der Studenten, die sich in die Kurse A bzw. B eingeschrieben haben.\n a_n ist ein Array von Studenten-IDs, die in Kurs A eingeschrieben sind, und b_m ist ein Array von Studenten-IDs, die in Kurs B eingeschrieben sind.\n Die Funktion gibt die Anzahl der Studenten zurück, die sich in beide Kurse eingeschrieben haben.\n\n Beispiel:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "ha": "Yana ƙidaya yawan ɗaliban da suka yi rajista a duka darussa A da B. \nWannan aikin yana ɗaukar huɗu huɗu: n da m suna nufin yawan ɗaliban da suka yi rajista a darussa A da B, bi da bi. \na_n tsari ne na lambobin ID ɗalibai da suka yi rajista a darasi A, kuma b_m tsari ne na lambobin ID ɗalibai da suka yi rajista a darasi B. \nAikin yana mayar da ƙidayar ɗaliban da suka yi rajista a duka darussa.\n\nMisali:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "hi": "दोनों पाठ्यक्रम A और B में नामांकित छात्रों की संख्या गिनता है।\nयह फ़ंक्शन चार तर्क लेता है: n और m क्रमशः पाठ्यक्रम A और B में नामांकित छात्रों की संख्या हैं।\na_n पाठ्यक्रम A में नामांकित छात्र आईडी की एक array है, और b_m पाठ्यक्रम B में नामांकित छात्र आईडी की एक array है।\nफ़ंक्शन उन छात्रों की संख्या लौटाता है जो दोनों पाठ्यक्रमों में नामांकित हैं।\n\nउदाहरण:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "hu": "Számolja meg azon diákok számát, akik mindkét kurzusra, A-ra és B-re beiratkoztak.\n Ez a függvény négy argumentumot vesz fel: n és m a kurzusokra A és B beiratkozott diákok száma.\n a_n egy tömb, amely az A kurzusra beiratkozott diákok azonosítóit tartalmazza, és b_m egy tömb, amely a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n A függvény visszaadja azon diákok számát, akik mindkét kurzusra beiratkoztak.\n\n Példa:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1"
    },
    "docstring_bertscore": {
      "sq": "0.994375383500235",
      "hy": "0.991306544113246",
      "bn": "0.9861902227585494",
      "bg": "0.994375383500235",
      "zh": "0.9531506410683492",
      "fr": "0.987833491900851",
      "de": "0.9839584117972414",
      "ha": "0.9525321060618066",
      "hi": "0.9803709484853703",
      "hu": "0.9749062294423384"
    }
  },
  {
    "task_id": "Ruby/48",
    "prompt": {
      "en": "# Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n# and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n# and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n# greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n#\n# Arguments:\n# - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n# - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n#\n# Returns:\n# - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n#\n# Examples:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "sq": "# Llogarit fitimet totale të Deliv-e-droid bazuar në numrin e dërgesave të suksesshme\n# dhe dërgesave të dështuara. Për çdo dërgesë të suksesshme, Deliv-e-droid fiton 50 njësi parash,\n# dhe për çdo dërgesë të dështuar, humb 10 njësi. Nëse numri i dërgesave të suksesshme është\n# më i madh se numri i atyre të dështuara, Deliv-e-droid merr një bonus prej 500 njësish.\n#\n# Argumentet:\n# - delivered: Numër i plotë që përfaqëson numrin e pakove të dorëzuara me sukses (0 <= delivered <= 100).\n# - failed: Numër i plotë që përfaqëson numrin e dërgesave të dështuara (0 <= failed <= 100).\n#\n# Kthen:\n# - Numër i plotë: Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n#\n# Shembuj:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "hy": "# Հաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնված հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա։\n# Յուրաքանչյուր հաջողված առաքման համար Deliv-e-droid-ը վաստակում է 50 միավոր գումար,\n# և յուրաքանչյուր ձախողված առաքման համար կորցնում է 10 միավոր։ Եթե հաջողված առաքումների քանակը\n# գերազանցում է ձախողվածներին, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս։\n#\n# Փաստարկներ:\n# - delivered: Integer, որը ներկայացնում է հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100)։\n# - failed: Integer, որը ներկայացնում է ձախողված առաքումների քանակը (0 <= failed <= 100)։\n#\n# Վերադարձնում է:\n# - Integer: Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները։\n#\n# Օրինակներ:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "bn": "# Deliv-e-droid এর মোট আয় গণনা করে সফলভাবে বিতরণ করা এবং ব্যর্থ বিতরণের সংখ্যার উপর ভিত্তি করে।\n# প্রতিটি সফল বিতরণের জন্য, Deliv-e-droid 50 ইউনিট অর্থ উপার্জন করে,\n# এবং প্রতিটি ব্যর্থ বিতরণের জন্য, এটি 10 ইউনিট হারায়। যদি সফল বিতরণের সংখ্যা\n# ব্যর্থগুলির চেয়ে বেশি হয়, তাহলে Deliv-e-droid 500 ইউনিট বোনাস পায়।\n#\n# আর্গুমেন্ট:\n# - delivered: সফলভাবে বিতরণ করা প্যাকেজের সংখ্যা নির্দেশ করে এমন পূর্ণসংখ্যা (0 <= delivered <= 100)।\n# - failed: ব্যর্থ বিতরণের সংখ্যা নির্দেশ করে এমন পূর্ণসংখ্যা (0 <= failed <= 100)।\n#\n# রিটার্ন:\n# - পূর্ণসংখ্যা: Deliv-e-droid এর মোট আয়, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভকে ছাড়িয়ে যায়।\n#\n# উদাহরণ:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "bg": "# Изчислява общите приходи на Deliv-e-droid въз основа на броя на успешно доставените\n# и неуспешните доставки. За всяка успешна доставка Deliv-e-droid печели 50 единици пари,\n# а за всяка неуспешна доставка губи 10 единици. Ако броят на успешните доставки е\n# по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n#\n# Аргументи:\n# - delivered: Цяло число, представляващо броя на успешно доставените пакети (0 <= delivered <= 100).\n# - failed: Цяло число, представляващо броя на неуспешните доставки (0 <= failed <= 100).\n#\n# Връща:\n# - Цяло число: Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n#\n# Примери:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "zh": "# 计算 Deliv-e-droid 的总收入，基于成功交付和失败交付的数量。\n# 每次成功交付，Deliv-e-droid 赚取 50 单位的钱，而每次失败交付，它损失 10 单位。\n# 如果成功交付的数量大于失败交付的数量，Deliv-e-droid 会获得 500 单位的奖金。\n#\n# 参数:\n# - delivered: 整数，表示成功交付的包裹数量 (0 <= delivered <= 100)。\n# - failed: 整数，表示失败交付的数量 (0 <= failed <= 100)。\n#\n# 返回:\n# - 整数: Deliv-e-droid 的总收入，如果损失超过收益，可能为负数。\n#\n# 示例:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "fr": "# Calcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies\n# et de livraisons échouées. Pour chaque livraison réussie, Deliv-e-droid gagne 50 unités d'argent,\n# et pour chaque livraison échouée, il perd 10 unités. Si le nombre de livraisons réussies est\n# supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n#\n# Arguments :\n# - delivered : Entier représentant le nombre de colis livrés avec succès (0 <= delivered <= 100).\n# - failed : Entier représentant le nombre de livraisons échouées (0 <= failed <= 100).\n#\n# Renvoie :\n# - Entier : Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n#\n# Exemples :\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "de": "# Berechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten\n# und fehlgeschlagenen Lieferungen. Für jede erfolgreiche Lieferung verdient Deliv-e-droid 50 Geldeinheiten,\n# und für jede fehlgeschlagene Lieferung verliert es 10 Einheiten. Wenn die Anzahl der erfolgreichen Lieferungen\n# größer ist als die der fehlgeschlagenen, erhält Deliv-e-droid einen Bonus von 500 Einheiten.\n#\n# Argumente:\n# - delivered: Ganzzahl, die die Anzahl der erfolgreich zugestellten Pakete darstellt (0 <= delivered <= 100).\n# - failed: Ganzzahl, die die Anzahl der fehlgeschlagenen Lieferungen darstellt (0 <= failed <= 100).\n#\n# Rückgabewert:\n# - Ganzzahl: Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne übersteigen.\n#\n# Beispiele:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "ha": "# Lissafa jimillar kudin shiga na Deliv-e-droid bisa ga adadin nasarar isar da\n# da kuma gazawar isar da kaya. Ga kowane nasarar isar da kaya, Deliv-e-droid yana samun 50 raka'a na kudi,\n# kuma ga kowane gazawar isar da kaya, yana rasa 10 raka'a. Idan adadin nasarar isar da kaya ya\n# fi na gazawar isar da kaya yawa, Deliv-e-droid yana samun karin 500 raka'a.\n#\n# Huɗoɗi:\n# - delivered: Lamba mai nuna adadin nasarar isar da kaya (0 <= delivered <= 100).\n# - failed: Lamba mai nuna adadin gazawar isar da kaya (0 <= failed <= 100).\n#\n# Komawa:\n# - Lamba: Jimillar kudin shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi ribar yawa.\n#\n# Misalai:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "hi": "# Deliv-e-droid की कुल कमाई की गणना करता है जो सफलतापूर्वक वितरित और असफल डिलीवरी की संख्या पर आधारित है।\n# प्रत्येक सफल डिलीवरी के लिए, Deliv-e-droid 50 यूनिट पैसे कमाता है, और प्रत्येक असफल डिलीवरी के लिए, यह 10 यूनिट खोता है।\n# यदि सफल डिलीवरी की संख्या असफल डिलीवरी की संख्या से अधिक है, तो Deliv-e-droid को 500 यूनिट का बोनस मिलता है।\n#\n# तर्क:\n# - delivered: सफलतापूर्वक वितरित पैकेजों की संख्या को दर्शाने वाला पूर्णांक (0 <= delivered <= 100)।\n# - failed: असफल डिलीवरी की संख्या को दर्शाने वाला पूर्णांक (0 <= failed <= 100)।\n#\n# लौटाता है:\n# - पूर्णांक: Deliv-e-droid की कुल कमाई, जो नकारात्मक भी हो सकती है यदि नुकसान लाभ से अधिक हो।\n#\n# उदाहरण:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "hu": "# Kiszámítja a Deliv-e-droid teljes bevételét a sikeresen kézbesített és a sikertelen kézbesítések száma alapján.\n# Minden sikeres kézbesítésért a Deliv-e-droid 50 egység pénzt keres, és minden sikertelen kézbesítésért 10 egységet veszít.\n# Ha a sikeres kézbesítések száma nagyobb, mint a sikerteleneké, a Deliv-e-droid 500 egység bónuszt kap.\n#\n# Argumentumok:\n# - delivered: Egész szám, amely a sikeresen kézbesített csomagok számát jelöli (0 <= delivered <= 100).\n# - failed: Egész szám, amely a sikertelen kézbesítések számát jelöli (0 <= failed <= 100).\n#\n# Visszatérési érték:\n# - Egész szám: A Deliv-e-droid teljes bevétele, amely negatív is lehet, ha a veszteségek meghaladják a nyereséget.\n#\n# Példák:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)"
    },
    "prompt_bertscore": {
      "sq": "0.9760803336246356",
      "hy": "0.975604017970914",
      "bn": "0.9815581622728158",
      "bg": "0.9807306681054244",
      "zh": "0.9698663807843402",
      "fr": "0.9944872124047577",
      "de": "0.9862863598629703",
      "ha": "0.9610096507243756",
      "hi": "0.9822102658137534",
      "hu": "0.965065881735489"
    },
    "canonical_solution": "    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end",
    "instruction": {
      "en": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në gjuhën shqipe duke përdorur maksimumi 500 karaktere.",
      "hy": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\n请用最多500个字符的中文对该Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nBa da takaitaccen bayani a cikin yaren dabi'a (docstring) na lambar Ruby a cikin Hausa ta amfani da haruffa 500 ko ƙasa da haka.",
      "hi": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def calculate_droid_earnings(delivered, failed)\n    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.923607152714744",
      "bn": "0.9138385105754483",
      "bg": "0.8364486908745768",
      "zh": "0.9931528759928416",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9225979117487058",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless calculate_droid_earnings(5, 2) == 730\nraise 'Test failed' unless calculate_droid_earnings(0, 10) == -100\nraise 'Test failed' unless calculate_droid_earnings(10, 0) == 1000\nraise 'Test failed' unless calculate_droid_earnings(3, 5) == 100\nraise 'Test failed' unless calculate_droid_earnings(20, 20) == 800",
    "entry_point": "calculate_droid_earnings",
    "signature": "def calculate_droid_earnings(delivered, failed)",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n Arguments:\n - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n\n Returns:\n - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n Examples:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "sq": "Llogarit fitimet totale të Deliv-e-droid bazuar në numrin e dërgesave të suksesshme dhe dërgesave të dështuara. Për çdo dërgesë të suksesshme, Deliv-e-droid fiton 50 njësi parash, dhe për çdo dërgesë të dështuar, humbet 10 njësi. Nëse numri i dërgesave të suksesshme është më i madh se numri i atyre të dështuara, Deliv-e-droid merr një bonus prej 500 njësish.\n\nArgumentet:\n- delivered: Numër i plotë që përfaqëson numrin e pakove të dorëzuara me sukses (0 <= delivered <= 100).\n- failed: Numër i plotë që përfaqëson numrin e dërgesave të dështuara (0 <= failed <= 100).\n\nKthen:\n- Numër i plotë: Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n\nShembuj:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "hy": "Հաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնվելով հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա։ Յուրաքանչյուր հաջողությամբ առաքման համար Deliv-e-droid-ը վաստակում է 50 միավոր գումար, իսկ յուրաքանչյուր ձախողված առաքման համար կորցնում է 10 միավոր։ Եթե հաջողությամբ առաքումների քանակը գերազանցում է ձախողվածների քանակին, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս։\n\nԱրգումենտներ:\n- delivered: Integer, որը ներկայացնում է հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100)։\n- failed: Integer, որը ներկայացնում է ձախողված առաքումների քանակը (0 <= failed <= 100)։\n\nՎերադարձնում է:\n- Integer: Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները։\n\nՕրինակներ:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "bn": "Deliv-e-droid এর মোট উপার্জন গণনা করে সফলভাবে বিতরণ করা এবং ব্যর্থ বিতরণগুলির সংখ্যার উপর ভিত্তি করে। প্রতিটি সফল বিতরণের জন্য, Deliv-e-droid 50 ইউনিট অর্থ উপার্জন করে, এবং প্রতিটি ব্যর্থ বিতরণের জন্য, এটি 10 ইউনিট হারায়। যদি সফল বিতরণের সংখ্যা ব্যর্থগুলির চেয়ে বেশি হয়, Deliv-e-droid 500 ইউনিট বোনাস পায়।\n\nArguments:\n- delivered: সফলভাবে বিতরণ করা প্যাকেজের সংখ্যা নির্দেশকারী পূর্ণসংখ্যা (0 <= delivered <= 100)।\n- failed: ব্যর্থ বিতরণের সংখ্যা নির্দেশকারী পূর্ণসংখ্যা (0 <= failed <= 100)।\n\nReturns:\n- Integer: Deliv-e-droid এর মোট উপার্জন, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভকে ছাড়িয়ে যায়।\n\nExamples:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "bg": "Изчислява общите приходи на Deliv-e-droid въз основа на броя на успешно доставените и неуспешните доставки. За всяка успешна доставка Deliv-e-droid печели 50 единици пари, а за всяка неуспешна губи 10 единици. Ако броят на успешните доставки е по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n\nАргументи:\n- delivered: Цяло число, представляващо броя на успешно доставените пакети (0 <= delivered <= 100).\n- failed: Цяло число, представляващо броя на неуспешните доставки (0 <= failed <= 100).\n\nВръща:\n- Цяло число: Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n\nПримери:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "zh": "计算 Deliv-e-droid 的总收入，基于成功交付和失败交付的数量。对于每次成功交付，Deliv-e-droid 赚取 50 个单位的金钱，而每次失败交付则损失 10 个单位。如果成功交付的数量大于失败的数量，Deliv-e-droid 将获得 500 个单位的奖金。\n\n参数:\n- delivered: 表示成功交付包裹数量的整数 (0 <= delivered <= 100)。\n- failed: 表示失败交付数量的整数 (0 <= failed <= 100)。\n\n返回:\n- 整数: Deliv-e-droid 的总收入，如果损失大于收益，则可能为负数。\n\n示例:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "fr": "Calcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies et échouées. Pour chaque livraison réussie, Deliv-e-droid gagne 50 unités d'argent, et pour chaque livraison échouée, il perd 10 unités. Si le nombre de livraisons réussies est supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n\nArguments:\n- delivered: Entier représentant le nombre de colis livrés avec succès (0 <= delivered <= 100).\n- failed: Entier représentant le nombre de livraisons échouées (0 <= failed <= 100).\n\nRetourne:\n- Entier: Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n\nExemples:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "de": "Berechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten und fehlgeschlagenen Lieferungen. Für jede erfolgreiche Lieferung verdient Deliv-e-droid 50 Geldeinheiten, und für jede fehlgeschlagene Lieferung verliert es 10 Einheiten. Wenn die Anzahl der erfolgreichen Lieferungen größer ist als die der fehlgeschlagenen, erhält Deliv-e-droid einen Bonus von 500 Einheiten.\n\nArgumente:\n- delivered: Ganzzahl, die die Anzahl der erfolgreich zugestellten Pakete darstellt (0 <= delivered <= 100).\n- failed: Ganzzahl, die die Anzahl der fehlgeschlagenen Lieferungen darstellt (0 <= failed <= 100).\n\nRückgabewerte:\n- Ganzzahl: Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne überwiegen.\n\nBeispiele:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "ha": "Ƙididdige jimillar kudaden shiga na Deliv-e-droid bisa ga adadin nasarorin da aka samu\nda kuma gazawar isarwa. Don kowane nasarar isarwa, Deliv-e-droid yana samun 50 raka'a na kudi,\nkuma don kowane gazawar isarwa, yana rasa 10 raka'a. Idan adadin nasarorin isarwa ya\nfi yawa akan adadin gazawar, Deliv-e-droid yana samun kari na 500 raka'a.\n\n Huɗɗa:\n - delivered: Lamba mai nuna yawan fakitoci da aka kai nasara (0 <= delivered <= 100).\n - failed: Lamba mai nuna yawan fakitoci da aka kasa kaiwa (0 <= failed <= 100).\n\n Dawowa:\n - Lamba: Jimillar kudaden shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi riba.\n\n Misalai:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "hi": "सफलतापूर्वक वितरित और असफल डिलीवरी की संख्या के आधार पर Deliv-e-droid की कुल कमाई की गणना करता है। प्रत्येक सफल डिलीवरी के लिए, Deliv-e-droid 50 इकाइयों की कमाई करता है, और प्रत्येक असफल डिलीवरी के लिए, यह 10 इकाइयों का नुकसान करता है। यदि सफल डिलीवरी की संख्या असफल डिलीवरी की संख्या से अधिक है, तो Deliv-e-droid को 500 इकाइयों का बोनस मिलता है।\n\n तर्क:\n - delivered: सफलतापूर्वक वितरित किए गए पैकेजों की संख्या को दर्शाने वाला पूर्णांक (0 <= delivered <= 100)।\n - failed: असफल डिलीवरी की संख्या को दर्शाने वाला पूर्णांक (0 <= failed <= 100)।\n\n वापसी:\n - पूर्णांक: Deliv-e-droid की कुल कमाई, जो नकारात्मक हो सकती है यदि नुकसान लाभ से अधिक हो।\n\n उदाहरण:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "hu": "Kiszámítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és a sikertelen kézbesítések száma alapján. Minden sikeres kézbesítésért a Deliv-e-droid 50 egységnyi pénzt keres, és minden sikertelen kézbesítésért 10 egységet veszít. Ha a sikeres kézbesítések száma nagyobb, mint a sikerteleneké, a Deliv-e-droid 500 egységnyi bónuszt kap.\n\nArgumentumok:\n- delivered: Egész szám, amely a sikeresen kézbesített csomagok számát jelöli (0 <= delivered <= 100).\n- failed: Egész szám, amely a sikertelen kézbesítések számát jelöli (0 <= failed <= 100).\n\nVisszatérési érték:\n- Egész szám: A Deliv-e-droid összes bevétele, amely negatív is lehet, ha a veszteségek meghaladják a nyereségeket.\n\nPéldák:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100"
    },
    "docstring_bertscore": {
      "sq": "0.9706670598502919",
      "hy": "0.9891295551371037",
      "bn": "0.9700443536057475",
      "bg": "0.9835492332123095",
      "zh": "0.9742682286584544",
      "fr": "0.9922218329090549",
      "de": "0.9823149440245588",
      "ha": "0.999999801369619",
      "hi": "0.9893381170371903",
      "hu": "0.9876710122491645"
    }
  },
  {
    "task_id": "Ruby/49",
    "prompt": {
      "en": "# Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n# The function takes a nested array (array of arrays) where each sub-array\n# contains ticket IDs for a particular batch. It returns an array with two elements:\n# the first is the missing ID, and the second is the duplicate ID.\n#\n# Example:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "sq": "# Gjen ID-në që mungon (të prishur) dhe ID-në e dyfishtë në një sekuencë ID-sh biletash.\n# Funksioni merr një varg të folezuar (varg arraysh) ku secili nën-array\n# përmban ID-të e biletave për një grup të caktuar. Ai kthen një varg me dy elemente:\n# e para është ID-ja që mungon, dhe e dyta është ID-ja e dyfishtë.\n#\n# Shembull:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "hy": "# Գտնում է բացակայող (կոտրված) և կրկնակի ID-ները տոմսերի ID-ների հաջորդականության մեջ։\n# Ֆունկցիան ընդունում է ներդրված զանգված (զանգվածների զանգված), որտեղ յուրաքանչյուր ենթազանգված\n# պարունակում է տոմսերի ID-ներ որոշակի խմբաքանակի համար։ Այն վերադարձնում է զանգված երկու էլեմենտով՝\n# առաջինը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնակի ID-ն։\n#\n# Օրինակ:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "bn": "# টিকিট আইডির একটি ক্রমে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\n# ফাংশনটি একটি নেস্টেড অ্যারে (অ্যারের অ্যারে) গ্রহণ করে যেখানে প্রতিটি সাব-অ্যারে\n# একটি নির্দিষ্ট ব্যাচের জন্য টিকিট আইডি থাকে। এটি দুটি উপাদান সহ একটি অ্যারে ফেরত দেয়:\n# প্রথমটি অনুপস্থিত আইডি এবং দ্বিতীয়টি সদৃশ আইডি।\n#\n# উদাহরণ:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "bg": "# Намира липсващото (счупено) и дублирано ID в последователност от ID на билети.\n# Функцията приема вложен масив (масив от масиви), където всеки подмасив\n# съдържа ID на билети за определена партида. Връща масив с два елемента:\n# първият е липсващото ID, а вторият е дублираното ID.\n#\n# Пример:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "zh": "# 查找票据ID序列中缺失（损坏）和重复的ID。\n# 该函数接收一个嵌套数组（数组的数组），其中每个子数组\n# 包含一个特定批次的票据ID。它返回一个包含两个元素的数组：\n# 第一个是缺失的ID，第二个是重复的ID。\n#\n# 例子:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "fr": "# Trouve l'ID manquant (cassé) et l'ID dupliqué dans une séquence d'IDs de tickets.\n# La fonction prend un tableau imbriqué (tableau de tableaux) où chaque sous-tableau\n# contient des IDs de tickets pour un lot particulier. Elle renvoie un tableau avec deux éléments :\n# le premier est l'ID manquant, et le second est l'ID dupliqué.\n#\n# Exemple :\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "de": "# Findet die fehlende (defekte) und doppelte ID in einer Sequenz von Ticket-IDs.\n# Die Funktion nimmt ein verschachteltes Array (Array von Arrays), wobei jedes Unter-Array\n# Ticket-IDs für eine bestimmte Charge enthält. Sie gibt ein Array mit zwei Elementen zurück:\n# das erste ist die fehlende ID, und das zweite ist die doppelte ID.\n#\n# Beispiel:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "ha": "# Nemi ID ɗin da ya ɓace (ya karye) da wanda aka maimaita a cikin jerin ID ɗin tikiti.\n# Aikin yana ɗaukar wani tsari mai ma'ana (tsarin tsare-tsare) inda kowace ƙaramar tsari\n# ke ɗauke da ID ɗin tikiti don wani rukuni na musamman. Yana mayar da tsari tare da abubuwa biyu:\n# na farko shine ID ɗin da ya ɓace, na biyu kuma shine ID ɗin da aka maimaita.\n#\n# Misali:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "hi": "# टिकट आईडी के अनुक्रम में गुम (टूटी हुई) और डुप्लिकेट आईडी खोजता है।\n# यह फ़ंक्शन एक नेस्टेड ऐरे (ऐरे का ऐरे) लेता है जहाँ प्रत्येक उप-ऐरे\n# किसी विशेष बैच के लिए टिकट आईडी शामिल करता है। यह एक ऐरे लौटाता है जिसमें दो तत्व होते हैं:\n# पहला गुम आईडी है, और दूसरा डुप्लिकेट आईडी है।\n#\n# उदाहरण:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "hu": "# Megkeresi a hiányzó (törött) és a duplikált azonosítót egy jegyazonosító-sorozatban.\n# A függvény egy beágyazott tömböt (tömbök tömbje) vesz át, ahol minden al-tömb\n# egy adott tétel jegyazonosítóit tartalmazza. Egy tömböt ad vissza két elemmel:\n# az első a hiányzó azonosító, a második a duplikált azonosító.\n#\n# Példa:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)"
    },
    "prompt_bertscore": {
      "sq": "0.9829537393299669",
      "hy": "0.9871794020561031",
      "bn": "0.9967577562903676",
      "bg": "0.9900404740645297",
      "zh": "0.9778954180465325",
      "fr": "0.9919763257580957",
      "de": "0.989649966735415",
      "ha": "0.9221635071053825",
      "hi": "0.9882567732428363",
      "hu": "0.9698328122499453"
    },
    "canonical_solution": "    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end",
    "instruction": {
      "en": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nJepni një përshkrim të shkurtër në gjuhën natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nՏվյալ Ruby կոդի համար տրամադրեք հակիրճ բնութագրություն (docstring) հայերենով՝ օգտագործելով առավելագույնը 500 նիշ:",
      "bn": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nরুবি কোডের জন্য একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে হবে।",
      "bg": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nBa da takaitaccen bayanin yare na halitta (docstring) na lambar Ruby cikin Hausa ta amfani da haruffa 500 kawai.",
      "hi": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जो अधिकतम 500 वर्णों का हो।",
      "hu": "def find_missing_and_duplicate_ids(ids)\n    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end\n\nAdjon meg egy tömör természetes nyelvű leírást (docstring) a Ruby kódhoz magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8853185645753159",
      "bn": "0.8746987912532856",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9531146889693819",
      "hi": "0.9119288780921788",
      "hu": "0.9419653670515126"
    },
    "level": "",
    "test": "raise 'Test failed' unless find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]]) == [7, 9]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5, 7]]) == [6, 5]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[20, 21, 23], [22, 24, 24, 26]]) == [25, 24]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[100, 102, 106], [101, 103, 103, 105]]) == [104, 103]",
    "entry_point": "find_missing_and_duplicate_ids",
    "signature": "def find_missing_and_duplicate_ids(ids)",
    "docstring": {
      "en": "Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n The function takes a nested array (array of arrays) where each sub-array\n contains ticket IDs for a particular batch. It returns an array with two elements:\n the first is the missing ID, and the second is the duplicate ID.\n\n Example:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "sq": "Gjen ID-në që mungon (të prishur) dhe ID-në e dublikuar në një sekuencë ID-sh biletash. Funksioni merr një varg të folezuar (varg vargjesh) ku secili nën-varg përmban ID-të e biletave për një grup të caktuar. Ai kthen një varg me dy elemente: i pari është ID-ja që mungon, dhe i dyti është ID-ja e dublikuar.\n\nShembull:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "hy": "Գտնում է բացակայող (կոտրված) և կրկնօրինակ ID-ները տոմսերի ID-ների հաջորդականության մեջ։ Ֆունկցիան ընդունում է ներդրված զանգված (զանգվածների զանգված), որտեղ յուրաքանչյուր ենթազանգված պարունակում է տոմսերի ID-ները որոշակի խմբաքանակի համար։ Այն վերադարձնում է զանգված երկու տարրերով՝ առաջինը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնօրինակ ID-ն։\n\nՕրինակ:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "bn": "টিকিট আইডির একটি ক্রমে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\nফাংশনটি একটি নেস্টেড অ্যারে (অ্যারের অ্যারে) গ্রহণ করে যেখানে প্রতিটি সাব-অ্যারে একটি নির্দিষ্ট ব্যাচের টিকেট আইডি থাকে। এটি একটি অ্যারে ফেরত দেয় যার দুটি উপাদান রয়েছে: প্রথমটি হল অনুপস্থিত আইডি, এবং দ্বিতীয়টি হল সদৃশ আইডি।\n\nউদাহরণ:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "bg": "Намира липсващото (счупено) и дублираното ID в последователност от ID на билети. Функцията приема вложен масив (масив от масиви), където всеки подмасив съдържа ID на билети за определена партида. Връща масив с два елемента: първият е липсващото ID, а вторият е дублираното ID.\n\nПример:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "zh": "查找序列中的缺失（损坏）和重复ID。\n该函数接受一个嵌套数组（数组的数组），其中每个子数组包含特定批次的票据ID。它返回一个包含两个元素的数组：第一个是缺失的ID，第二个是重复的ID。\n\n示例：\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "fr": "Trouve l'ID manquant (cassé) et l'ID dupliqué dans une séquence d'IDs de tickets. La fonction prend un tableau imbriqué (tableau de tableaux) où chaque sous-tableau contient des IDs de tickets pour un lot particulier. Elle renvoie un tableau avec deux éléments : le premier est l'ID manquant, et le second est l'ID dupliqué.\n\nExemple :\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "de": "Findet die fehlende (defekte) und doppelte ID in einer Sequenz von Ticket-IDs. Die Funktion nimmt ein verschachteltes Array (Array von Arrays) an, wobei jedes Unter-Array Ticket-IDs für eine bestimmte Charge enthält. Sie gibt ein Array mit zwei Elementen zurück: das erste ist die fehlende ID und das zweite die doppelte ID.\n\nBeispiel:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "ha": "Yana gano ID da ya ɓace (wanda ya karye) da kuma wanda aka maimaita a cikin jerin ID na tikiti. \nAikin yana karɓar tsararren array (array na arrays) inda kowace ƙaramin array \nke ɗauke da ID na tikiti don kowane batch. Yana dawowa da array tare da abubuwa biyu: \nna farko shine ID da ya ɓace, na biyu kuma shine ID da aka maimaita.\n\nMisali:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "hi": "टिकट आईडी के अनुक्रम में गायब (टूटा हुआ) और डुप्लिकेट आईडी खोजता है। \nयह फ़ंक्शन एक नेस्टेड ऐरे (ऐरे का ऐरे) लेता है जहाँ प्रत्येक उप-ऐरे में किसी विशेष बैच के लिए टिकट आईडी होती हैं। यह एक ऐरे लौटाता है जिसमें दो तत्व होते हैं: पहला गायब आईडी है, और दूसरा डुप्लिकेट आईडी है।\n\nउदाहरण:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "hu": "Megkeresi a hiányzó (törött) és a duplikált azonosítót egy jegyazonosító-sorozatban. A függvény egy beágyazott tömböt (tömbök tömbje) vesz fel, ahol minden al-tömb egy adott tétel jegyazonosítóit tartalmazza. Egy két elemből álló tömböt ad vissza: az első a hiányzó azonosító, a második a duplikált azonosító.\n\nPélda:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]"
    },
    "docstring_bertscore": {
      "sq": "0.9833929111024351",
      "hy": "0.9876404231704852",
      "bn": "0.99508071998329",
      "bg": "0.9890393769441138",
      "zh": "0.9676226520001702",
      "fr": "0.9892896512242177",
      "de": "0.9884647392517799",
      "ha": "0.9546197113664833",
      "hi": "0.9976464286151177",
      "hu": "0.9661305405778361"
    }
  },
  {
    "task_id": "Ruby/50",
    "prompt": {
      "en": "# Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n# The function takes a single argument, s, which is a string of length 8,\n# and returns an array with three integers representing the count of digits,\n# lowercase letters, and uppercase letters in the string, respectively.\n#\n# Examples:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "sq": "# Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë.\n# Funksioni merr një argument të vetëm, s, i cili është një varg me gjatësi 8,\n# dhe kthen një varg me tre numra të plotë që përfaqësojnë numrin e shifrave,\n# shkronjave të vogla dhe shkronjave të mëdha në varg, përkatësisht.\n#\n# Shembuj:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "hy": "# Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված տողում։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, s, որը 8 երկարությամբ տող է,\n# և վերադարձնում է զանգված երեք ամբողջ թվերով, որոնք ներկայացնում են թվանշանների,\n# փոքրատառերի և մեծատառերի քանակը տողում, համապատասխանաբար։\n#\n# Օրինակներ:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "bn": "# প্রদত্ত স্ট্রিং-এ সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, s, যা একটি 8 দৈর্ঘ্যের স্ট্রিং,\n# এবং একটি অ্যারে ফেরত দেয় যা তিনটি পূর্ণসংখ্যা নিয়ে গঠিত যা স্ট্রিং-এ সংখ্যা,\n# ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা প্রতিনিধিত্ব করে, যথাক্রমে।\n#\n# উদাহরণ:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "bg": "# Брои броя на цифрите, малките букви и главните букви в даден низ.\n# Функцията приема един аргумент, s, който е низ с дължина 8,\n# и връща масив с три цели числа, представляващи броя на цифрите,\n# малките букви и главните букви в низа, съответно.\n#\n# Примери:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "zh": "# 统计给定字符串中的数字、小写字母和大写字母的数量。\n# 该函数接受一个参数 s，它是一个长度为 8 的字符串，\n# 并返回一个包含三个整数的数组，分别表示字符串中数字、小写字母和大写字母的数量。\n#\n# 示例:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "fr": "# Compte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée.\n# La fonction prend un seul argument, s, qui est une chaîne de longueur 8,\n# et renvoie un tableau avec trois entiers représentant le compte des chiffres,\n# des lettres minuscules et des lettres majuscules dans la chaîne, respectivement.\n#\n# Exemples :\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "de": "# Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String.\n# Die Funktion nimmt ein einziges Argument, s, das ein String der Länge 8 ist,\n# und gibt ein Array mit drei ganzen Zahlen zurück, die die Anzahl der Ziffern,\n# Kleinbuchstaben und Großbuchstaben im String darstellen.\n#\n# Beispiele:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "ha": "# Yana ƙidaya adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu da aka bayar.\n# Aikin yana ɗaukar hujja guda ɗaya, s, wanda igiyar rubutu ce mai tsawon 8,\n# kuma yana mayar da jerin lambobi uku da ke wakiltar adadin lambobi,\n# ƙananan haruffa, da manyan haruffa a cikin igiyar rubutu, bi da bi.\n#\n# Misalai:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "hi": "# दिए गए स्ट्रिंग में अंकों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है।\n# फ़ंक्शन एकल आर्गुमेंट लेता है, s, जो कि 8 लंबाई का एक स्ट्रिंग है,\n# और तीन पूर्णांकों की एक array लौटाता है जो क्रमशः स्ट्रिंग में अंकों,\n# छोटे अक्षरों, और बड़े अक्षरों की संख्या को दर्शाता है।\n#\n# उदाहरण:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "hu": "# Megszámolja a számjegyek, kisbetűk és nagybetűk számát egy adott sztringben.\n# A függvény egyetlen argumentumot vesz fel, s, amely egy 8 hosszúságú sztring,\n# és egy tömböt ad vissza három egész számmal, amelyek a számjegyek,\n# kisbetűk és nagybetűk számát reprezentálják a sztringben, ebben a sorrendben.\n#\n# Példák:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)"
    },
    "prompt_bertscore": {
      "sq": "0.9923644495226379",
      "hy": "0.9770448827549411",
      "bn": "0.9903882758617217",
      "bg": "0.993281923252638",
      "zh": "0.9646696141253245",
      "fr": "1",
      "de": "0.9896169940921633",
      "ha": "0.9885136023255144",
      "hi": "0.9919951956442941",
      "hu": "0.9830381572419068"
    },
    "canonical_solution": "    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end",
    "instruction": {
      "en": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nProvide a concise natural language description (docstring) of the Ruby code in English using at most 500 characters.",
      "sq": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nSiguroni një përshkrim të shkurtër në gjuhë natyrore (docstring) të kodit Ruby në shqip duke përdorur maksimumi 500 karaktere.",
      "hy": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nՏվեք կարճ բնական լեզվով նկարագրություն (docstring) այս Ruby կոդի համար՝ օգտագործելով առավելագույնը 500 նիշ։",
      "bn": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nরুবি কোডের একটি সংক্ষিপ্ত প্রাকৃতিক ভাষার বিবরণ (ডকস্ট্রিং) বাংলায় প্রদান করুন, যা সর্বাধিক ৫০০ অক্ষরের মধ্যে থাকবে।",
      "bg": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nПредоставете кратко описание на Ruby кода на естествен език на български, използвайки не повече от 500 знака.",
      "zh": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\n请用不超过500个字符的中文，为以下Ruby代码提供简洁的自然语言描述（文档字符串）。",
      "fr": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nFournissez une description concise en langage naturel (docstring) du code Ruby en français en utilisant au maximum 500 caractères.",
      "de": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nGeben Sie eine prägnante Beschreibung in natürlicher Sprache (Docstring) des Ruby-Codes auf Deutsch mit maximal 500 Zeichen.",
      "ha": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nBa da takaitaccen bayani a cikin yaren halitta (docstring) na lambar Ruby a cikin Hausa, ba tare da wuce haruffa 500 ba.",
      "hi": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nरूबी कोड के लिए एक संक्षिप्त प्राकृतिक भाषा विवरण (डॉकस्ट्रिंग) हिंदी में प्रदान करें, जिसमें अधिकतम 500 वर्ण हों।",
      "hu": "def count_chars_types(s)\n    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end\n\nAdjon meg egy tömör, természetes nyelvű leírást (docstring) a Ruby kódról magyarul, legfeljebb 500 karakterben."
    },
    "instruction_bertscore": {
      "sq": "0.9548672048212528",
      "hy": "0.8888019455675248",
      "bn": "0.9138385105754483",
      "bg": "0.8364486908745768",
      "zh": "0.8746523117441235",
      "fr": "0.9691999758559682",
      "de": "0.9250084900529452",
      "ha": "0.9148767515771177",
      "hi": "0.9119288780921788",
      "hu": "0.9410598111443745"
    },
    "level": "",
    "test": "raise 'Test failed' unless count_chars_types(\"yLOI2022\") == [4, 1, 3]\nraise 'Test failed' unless count_chars_types(\"IAKIOIOI\") == [0, 0, 8]\nraise 'Test failed' unless count_chars_types(\"1n2s0e1s\") == [4, 4, 0]\nraise 'Test failed' unless count_chars_types(\"12345678\") == [8, 0, 0]\nraise 'Test failed' unless count_chars_types(\"abcdefgh\") == [0, 8, 0]",
    "entry_point": "count_chars_types",
    "signature": "def count_chars_types(s)",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.\n\n Examples:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "sq": "Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë.\n Funksioni merr një argument të vetëm, s, i cili është një varg me gjatësi 8,\n dhe kthen një varg me tre numra të plotë që përfaqësojnë numrin e shifrave,\n shkronjave të vogla dhe shkronjave të mëdha në varg, përkatësisht.\n\n Shembuj:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "hy": "Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված տողում։ Ֆունկցիան ընդունում է մեկ արգումենտ՝ s, որը 8 երկարությամբ տող է, և վերադարձնում է երեք ամբողջ թվերից կազմված զանգված, որը ներկայացնում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տողում, համապատասխանաբար։\n\nՕրինակներ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "bn": "সংখ্যা, ছোট হাতের অক্ষর এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে একটি প্রদত্ত স্ট্রিং-এ। ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, s, যা 8 দৈর্ঘ্যের একটি স্ট্রিং, এবং একটি অ্যারে ফেরত দেয় তিনটি পূর্ণসংখ্যা সহ যা যথাক্রমে স্ট্রিংয়ে সংখ্যা, ছোট হাতের অক্ষর এবং বড় হাতের অক্ষরের সংখ্যা উপস্থাপন করে।\n\nউদাহরণসমূহ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "bg": "Брои броя на цифрите, малките букви и главните букви в даден низ. \nФункцията приема един аргумент, s, който е низ с дължина 8, \nи връща масив с три цели числа, представляващи броя на цифрите, \nмалките букви и главните букви в низа, съответно.\n\nПримери:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "zh": "计算给定字符串中数字、小写字母和大写字母的数量。  \n该函数接受一个参数 s，它是一个长度为 8 的字符串，  \n并返回一个包含三个整数的数组，分别表示字符串中数字、小写字母和大写字母的数量。\n\n示例：\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "fr": "Compte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée. La fonction prend un seul argument, s, qui est une chaîne de longueur 8, et renvoie un tableau avec trois entiers représentant le compte des chiffres, des lettres minuscules et des lettres majuscules dans la chaîne, respectivement.\n\nExemples :\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "de": "Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String. Die Funktion nimmt ein einzelnes Argument, s, das ein String der Länge 8 ist, und gibt ein Array mit drei ganzen Zahlen zurück, die die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben im String darstellen.\n\nBeispiele:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "ha": "Yana ƙidaya adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani baƙaƙe da aka bayar. \nAiki yana ɗaukar hujja guda, s, wanda shine baƙaƙe na tsawon 8, \nkuma yana mayar da jerin lambobi uku da ke wakiltar ƙidayar lambobi, \nƙananan haruffa, da manyan haruffa a cikin baƙaƙen, bi da bi.\n\nMisalai:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "hi": "अक्षरों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है जो एक दिए गए स्ट्रिंग में होते हैं। \nयह फ़ंक्शन एक एकल तर्क लेता है, s, जो कि 8 लंबाई का एक स्ट्रिंग है, \nऔर तीन पूर्णांकों के साथ एक ऐरे लौटाता है जो क्रमशः स्ट्रिंग में अंकों, छोटे अक्षरों, और बड़े अक्षरों की गिनती का प्रतिनिधित्व करते हैं।\n\nउदाहरण:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "hu": "Számolja meg a számjegyek, kisbetűk és nagybetűk számát egy adott sztringben. A függvény egyetlen argumentumot vesz fel, s-t, amely egy 8 karakter hosszú sztring, és egy tömböt ad vissza három egész számmal, amelyek a számjegyek, kisbetűk és nagybetűk számát képviselik a sztringben, ebben a sorrendben.\n\nPéldák:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]"
    },
    "docstring_bertscore": {
      "sq": "0.9894062472578853",
      "hy": "0.9763431216187448",
      "bn": "0.9916303116343329",
      "bg": "0.9920172436165888",
      "zh": "0.9594527857978241",
      "fr": "0.999999801369619",
      "de": "0.9866431000273089",
      "ha": "0.9840994393677762",
      "hi": "0.9938007458079011",
      "hu": "0.9692182498510233"
    }
  }
]